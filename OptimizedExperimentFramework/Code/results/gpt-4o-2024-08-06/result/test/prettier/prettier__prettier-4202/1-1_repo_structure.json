{
    ".codecov.yml": {},
    ".eslintignore": {},
    ".eslintrc.yml": {},
    ".flowconfig": {},
    ".gitignore": {},
    ".ignore": {},
    ".pre-commit-hooks.yaml": {},
    ".prettierignore": {},
    ".travis.yml": {},
    ".yarnrc": {},
    "CHANGELOG.md": {},
    "CONTRIBUTING.md": {},
    "LICENSE": {},
    "README.md": {},
    "commands.md": {},
    "index.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "const version = require(\"./package.json\").version;",
            "",
            "const privateUtil = require(\"./src/common/util\");",
            "const sharedUtil = require(\"./src/common/util-shared\");",
            "const getSupportInfo = require(\"./src/common/support\").getSupportInfo;",
            "",
            "const comments = require(\"./src/main/comments\");",
            "const printAstToDoc = require(\"./src/main/ast-to-doc\");",
            "const normalizeOptions = require(\"./src/main/options\").normalize;",
            "const parser = require(\"./src/main/parser\");",
            "",
            "const config = require(\"./src/config/resolve-config\");",
            "",
            "const doc = require(\"./src/doc\");",
            "const printDocToString = doc.printer.printDocToString;",
            "const printDocToDebug = doc.debug.printDocToDebug;",
            "",
            "function guessLineEnding(text) {",
            "  const index = text.indexOf(\"\\n\");",
            "  if (index >= 0 && text.charAt(index - 1) === \"\\r\") {",
            "    return \"\\r\\n\";",
            "  }",
            "  return \"\\n\";",
            "}",
            "",
            "function attachComments(text, ast, opts) {",
            "  const astComments = ast.comments;",
            "  if (astComments) {",
            "    delete ast.comments;",
            "    comments.attach(astComments, ast, text, opts);",
            "  }",
            "  ast.tokens = [];",
            "  opts.originalText = text.trimRight();",
            "  return astComments;",
            "}",
            "",
            "function ensureAllCommentsPrinted(astComments) {",
            "  if (!astComments) {",
            "    return;",
            "  }",
            "",
            "  for (let i = 0; i < astComments.length; ++i) {",
            "    if (astComments[i].value.trim() === \"prettier-ignore\") {",
            "      // If there's a prettier-ignore, we're not printing that sub-tree so we",
            "      // don't know if the comments was printed or not.",
            "      return;",
            "    }",
            "  }",
            "",
            "  astComments.forEach(comment => {",
            "    if (!comment.printed) {",
            "      throw new Error(",
            "        'Comment \"' +",
            "          comment.value.trim() +",
            "          '\" was not printed. Please report this error!'",
            "      );",
            "    }",
            "    delete comment.printed;",
            "  });",
            "}",
            "",
            "function formatWithCursor(text, opts, addAlignmentSize) {",
            "  const selectedParser = parser.resolveParser(opts);",
            "  const hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);",
            "  if (opts.requirePragma && !hasPragma) {",
            "    return { formatted: text };",
            "  }",
            "",
            "  const UTF8BOM = 0xfeff;",
            "  const hasUnicodeBOM = text.charCodeAt(0) === UTF8BOM;",
            "  if (hasUnicodeBOM) {",
            "    text = text.substring(1);",
            "  }",
            "",
            "  if (",
            "    opts.insertPragma &&",
            "    opts.printer.insertPragma &&",
            "    !hasPragma &&",
            "    opts.rangeStart === 0 &&",
            "    opts.rangeEnd === Infinity",
            "  ) {",
            "    text = opts.printer.insertPragma(text);",
            "  }",
            "",
            "  addAlignmentSize = addAlignmentSize || 0;",
            "",
            "  const result = parser.parse(text, opts);",
            "  const ast = result.ast;",
            "  text = result.text;",
            "",
            "  const formattedRangeOnly = formatRange(text, opts, ast);",
            "  if (formattedRangeOnly) {",
            "    return { formatted: formattedRangeOnly };",
            "  }",
            "",
            "  let cursorOffset;",
            "  if (opts.cursorOffset >= 0) {",
            "    const cursorNodeAndParents = findNodeAtOffset(ast, opts.cursorOffset, opts);",
            "    const cursorNode = cursorNodeAndParents.node;",
            "    if (cursorNode) {",
            "      cursorOffset = opts.cursorOffset - opts.locStart(cursorNode);",
            "      opts.cursorNode = cursorNode;",
            "    }",
            "  }",
            "",
            "  const astComments = attachComments(text, ast, opts);",
            "  const doc = printAstToDoc(ast, opts, addAlignmentSize);",
            "  opts.newLine = guessLineEnding(text);",
            "  const toStringResult = printDocToString(doc, opts);",
            "  let str = toStringResult.formatted;",
            "  if (hasUnicodeBOM) {",
            "    str = String.fromCharCode(UTF8BOM) + str;",
            "  }",
            "  const cursorOffsetResult = toStringResult.cursor;",
            "  ensureAllCommentsPrinted(astComments);",
            "  // Remove extra leading indentation as well as the added indentation after last newline",
            "  if (addAlignmentSize > 0) {",
            "    return { formatted: str.trim() + opts.newLine };",
            "  }",
            "",
            "  if (cursorOffset !== undefined) {",
            "    return {",
            "      formatted: str,",
            "      cursorOffset: cursorOffsetResult + cursorOffset",
            "    };",
            "  }",
            "",
            "  return { formatted: str };",
            "}",
            "",
            "function format(text, opts, addAlignmentSize) {",
            "  return formatWithCursor(text, opts, addAlignmentSize).formatted;",
            "}",
            "",
            "function findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts) {",
            "  let resultStartNode = startNodeAndParents.node;",
            "  let resultEndNode = endNodeAndParents.node;",
            "",
            "  if (resultStartNode === resultEndNode) {",
            "    return {",
            "      startNode: resultStartNode,",
            "      endNode: resultEndNode",
            "    };",
            "  }",
            "",
            "  for (const endParent of endNodeAndParents.parentNodes) {",
            "    if (",
            "      endParent.type !== \"Program\" &&",
            "      endParent.type !== \"File\" &&",
            "      opts.locStart(endParent) >= opts.locStart(startNodeAndParents.node)",
            "    ) {",
            "      resultEndNode = endParent;",
            "    } else {",
            "      break;",
            "    }",
            "  }",
            "",
            "  for (const startParent of startNodeAndParents.parentNodes) {",
            "    if (",
            "      startParent.type !== \"Program\" &&",
            "      startParent.type !== \"File\" &&",
            "      opts.locEnd(startParent) <= opts.locEnd(endNodeAndParents.node)",
            "    ) {",
            "      resultStartNode = startParent;",
            "    } else {",
            "      break;",
            "    }",
            "  }",
            "",
            "  return {",
            "    startNode: resultStartNode,",
            "    endNode: resultEndNode",
            "  };",
            "}",
            "",
            "function findNodeAtOffset(node, offset, options, predicate, parentNodes) {",
            "  predicate = predicate || (() => true);",
            "  parentNodes = parentNodes || [];",
            "  const start = options.locStart(node, options.locStart);",
            "  const end = options.locEnd(node, options.locEnd);",
            "  if (start <= offset && offset <= end) {",
            "    for (const childNode of comments.getSortedChildNodes(",
            "      node,",
            "      undefined /* text */,",
            "      options",
            "    )) {",
            "      const childResult = findNodeAtOffset(",
            "        childNode,",
            "        offset,",
            "        options,",
            "        predicate,",
            "        [node].concat(parentNodes)",
            "      );",
            "      if (childResult) {",
            "        return childResult;",
            "      }",
            "    }",
            "",
            "    if (predicate(node)) {",
            "      return {",
            "        node: node,",
            "        parentNodes: parentNodes",
            "      };",
            "    }",
            "  }",
            "}",
            "",
            "// See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5",
            "function isSourceElement(opts, node) {",
            "  if (node == null) {",
            "    return false;",
            "  }",
            "  // JS and JS like to avoid repetitions",
            "  const jsSourceElements = [",
            "    \"FunctionDeclaration\",",
            "    \"BlockStatement\",",
            "    \"BreakStatement\",",
            "    \"ContinueStatement\",",
            "    \"DebuggerStatement\",",
            "    \"DoWhileStatement\",",
            "    \"EmptyStatement\",",
            "    \"ExpressionStatement\",",
            "    \"ForInStatement\",",
            "    \"ForStatement\",",
            "    \"IfStatement\",",
            "    \"LabeledStatement\",",
            "    \"ReturnStatement\",",
            "    \"SwitchStatement\",",
            "    \"ThrowStatement\",",
            "    \"TryStatement\",",
            "    \"VariableDeclaration\",",
            "    \"WhileStatement\",",
            "    \"WithStatement\",",
            "    \"ClassDeclaration\", // ES 2015",
            "    \"ImportDeclaration\", // Module",
            "    \"ExportDefaultDeclaration\", // Module",
            "    \"ExportNamedDeclaration\", // Module",
            "    \"ExportAllDeclaration\", // Module",
            "    \"TypeAlias\", // Flow",
            "    \"InterfaceDeclaration\", // Flow, TypeScript",
            "    \"TypeAliasDeclaration\", // TypeScript",
            "    \"ExportAssignment\", // TypeScript",
            "    \"ExportDeclaration\" // TypeScript",
            "  ];",
            "  const jsonSourceElements = [",
            "    \"ObjectExpression\",",
            "    \"ArrayExpression\",",
            "    \"StringLiteral\",",
            "    \"NumericLiteral\",",
            "    \"BooleanLiteral\",",
            "    \"NullLiteral\"",
            "  ];",
            "  const graphqlSourceElements = [",
            "    \"OperationDefinition\",",
            "    \"FragmentDefinition\",",
            "    \"VariableDefinition\",",
            "    \"TypeExtensionDefinition\",",
            "    \"ObjectTypeDefinition\",",
            "    \"FieldDefinition\",",
            "    \"DirectiveDefinition\",",
            "    \"EnumTypeDefinition\",",
            "    \"EnumValueDefinition\",",
            "    \"InputValueDefinition\",",
            "    \"InputObjectTypeDefinition\",",
            "    \"SchemaDefinition\",",
            "    \"OperationTypeDefinition\",",
            "    \"InterfaceTypeDefinition\",",
            "    \"UnionTypeDefinition\",",
            "    \"ScalarTypeDefinition\"",
            "  ];",
            "  switch (opts.parser) {",
            "    case \"flow\":",
            "    case \"babylon\":",
            "    case \"typescript\":",
            "      return jsSourceElements.indexOf(node.type) > -1;",
            "    case \"json\":",
            "      return jsonSourceElements.indexOf(node.type) > -1;",
            "    case \"graphql\":",
            "      return graphqlSourceElements.indexOf(node.kind) > -1;",
            "  }",
            "  return false;",
            "}",
            "",
            "function calculateRange(text, opts, ast) {",
            "  // Contract the range so that it has non-whitespace characters at its endpoints.",
            "  // This ensures we can format a range that doesn't end on a node.",
            "  const rangeStringOrig = text.slice(opts.rangeStart, opts.rangeEnd);",
            "  const startNonWhitespace = Math.max(",
            "    opts.rangeStart + rangeStringOrig.search(/\\S/),",
            "    opts.rangeStart",
            "  );",
            "  let endNonWhitespace;",
            "  for (",
            "    endNonWhitespace = opts.rangeEnd;",
            "    endNonWhitespace > opts.rangeStart;",
            "    --endNonWhitespace",
            "  ) {",
            "    if (text[endNonWhitespace - 1].match(/\\S/)) {",
            "      break;",
            "    }",
            "  }",
            "",
            "  const startNodeAndParents = findNodeAtOffset(",
            "    ast,",
            "    startNonWhitespace,",
            "    opts,",
            "    node => isSourceElement(opts, node)",
            "  );",
            "  const endNodeAndParents = findNodeAtOffset(",
            "    ast,",
            "    endNonWhitespace,",
            "    opts,",
            "    node => isSourceElement(opts, node)",
            "  );",
            "",
            "  if (!startNodeAndParents || !endNodeAndParents) {",
            "    return {",
            "      rangeStart: 0,",
            "      rangeEnd: 0",
            "    };",
            "  }",
            "",
            "  const siblingAncestors = findSiblingAncestors(",
            "    startNodeAndParents,",
            "    endNodeAndParents,",
            "    opts",
            "  );",
            "  const startNode = siblingAncestors.startNode;",
            "  const endNode = siblingAncestors.endNode;",
            "  const rangeStart = Math.min(",
            "    opts.locStart(startNode, opts.locStart),",
            "    opts.locStart(endNode, opts.locStart)",
            "  );",
            "  const rangeEnd = Math.max(",
            "    opts.locEnd(startNode, opts.locEnd),",
            "    opts.locEnd(endNode, opts.locEnd)",
            "  );",
            "",
            "  return {",
            "    rangeStart: rangeStart,",
            "    rangeEnd: rangeEnd",
            "  };",
            "}",
            "",
            "function formatRange(text, opts, ast) {",
            "  if (opts.rangeStart <= 0 && text.length <= opts.rangeEnd) {",
            "    return;",
            "  }",
            "",
            "  const range = calculateRange(text, opts, ast);",
            "  const rangeStart = range.rangeStart;",
            "  const rangeEnd = range.rangeEnd;",
            "  const rangeString = text.slice(rangeStart, rangeEnd);",
            "",
            "  // Try to extend the range backwards to the beginning of the line.",
            "  // This is so we can detect indentation correctly and restore it.",
            "  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0",
            "  const rangeStart2 = Math.min(",
            "    rangeStart,",
            "    text.lastIndexOf(\"\\n\", rangeStart) + 1",
            "  );",
            "  const indentString = text.slice(rangeStart2, rangeStart);",
            "",
            "  const alignmentSize = privateUtil.getAlignmentSize(",
            "    indentString,",
            "    opts.tabWidth",
            "  );",
            "",
            "  const rangeFormatted = format(",
            "    rangeString,",
            "    Object.assign({}, opts, {",
            "      rangeStart: 0,",
            "      rangeEnd: Infinity,",
            "      printWidth: opts.printWidth - alignmentSize",
            "    }),",
            "    alignmentSize",
            "  );",
            "",
            "  // Since the range contracts to avoid trailing whitespace,",
            "  // we need to remove the newline that was inserted by the `format` call.",
            "  const rangeTrimmed = rangeFormatted.trimRight();",
            "",
            "  return text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);",
            "}",
            "",
            "module.exports = {",
            "  formatWithCursor: function(text, opts) {",
            "    return formatWithCursor(text, normalizeOptions(opts));",
            "  },",
            "",
            "  format: function(text, opts) {",
            "    return format(text, normalizeOptions(opts));",
            "  },",
            "",
            "  check: function(text, opts) {",
            "    try {",
            "      const formatted = format(text, normalizeOptions(opts));",
            "      return formatted === text;",
            "    } catch (e) {",
            "      return false;",
            "    }",
            "  },",
            "",
            "  doc,",
            "",
            "  resolveConfig: config.resolveConfig,",
            "  clearConfigCache: config.clearCache,",
            "",
            "  getSupportInfo,",
            "",
            "  version,",
            "",
            "  util: sharedUtil,",
            "",
            "  /* istanbul ignore next */",
            "  __debug: {",
            "    parse: function(text, opts) {",
            "      opts = normalizeOptions(opts);",
            "      return parser.parse(text, opts);",
            "    },",
            "    formatAST: function(ast, opts) {",
            "      opts = normalizeOptions(opts);",
            "      const doc = printAstToDoc(ast, opts);",
            "      const str = printDocToString(doc, opts);",
            "      return str;",
            "    },",
            "    // Doesn't handle shebang for now",
            "    formatDoc: function(doc, opts) {",
            "      opts = normalizeOptions(opts);",
            "      const debug = printDocToDebug(doc);",
            "      const str = format(debug, opts);",
            "      return str;",
            "    },",
            "    printToDoc: function(text, opts) {",
            "      opts = normalizeOptions(opts);",
            "      const result = parser.parse(text, opts);",
            "      const ast = result.ast;",
            "      text = result.text;",
            "      attachComments(text, ast, opts);",
            "      const doc = printAstToDoc(ast, opts);",
            "      return doc;",
            "    },",
            "    printDocToString: function(doc, opts) {",
            "      opts = normalizeOptions(opts);",
            "      const str = printDocToString(doc, opts);",
            "      return str;",
            "    }",
            "  }",
            "};"
        ]
    },
    "jest.config.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "const ENABLE_COVERAGE = !!process.env.CI;",
            "",
            "module.exports = {",
            "  setupFiles: [\"<rootDir>/tests_config/run_spec.js\"],",
            "  snapshotSerializers: [\"<rootDir>/tests_config/raw-serializer.js\"],",
            "  testRegex: \"jsfmt\\\\.spec\\\\.js$|__tests__/.*\\\\.js$\",",
            "  testPathIgnorePatterns: [\"tests/new_react\", \"tests/more_react\"],",
            "  collectCoverage: ENABLE_COVERAGE,",
            "  collectCoverageFrom: [\"src/**/*.js\", \"index.js\", \"!<rootDir>/node_modules/\"],",
            "  coveragePathIgnorePatterns: [",
            "    \"<rootDir>/src/doc-debug.js\",",
            "    \"<rootDir>/src/clean-ast.js\",",
            "    \"<rootDir>/src/deprecated.js\"",
            "  ],",
            "  moduleNameMapper: {",
            "    // Jest wires `fs` to `graceful-fs`, which causes a memory leak when",
            "    // `graceful-fs` does `require('fs')`.",
            "    // Ref: https://github.com/facebook/jest/issues/2179#issuecomment-355231418",
            "    // If this is removed, see also rollup.bin.config.js and rollup.index.config.js.",
            "    \"graceful-fs\": \"<rootDir>/tests_config/fs.js\"",
            "  },",
            "  transform: {}",
            "};"
        ]
    },
    "package.json": {},
    "yarn.lock": {},
    "bin": {
        "prettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "#!/usr/bin/env node",
                "",
                "\"use strict\";",
                "",
                "require(\"../src/cli\").run(process.argv.slice(2));"
            ]
        }
    },
    "src": {
        "cli": {
            "constant.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const dedent = require(\"dedent\");",
                    "",
                    "const CATEGORY_CONFIG = \"Config\";",
                    "const CATEGORY_EDITOR = \"Editor\";",
                    "const CATEGORY_FORMAT = \"Format\";",
                    "const CATEGORY_OTHER = \"Other\";",
                    "const CATEGORY_OUTPUT = \"Output\";",
                    "",
                    "const categoryOrder = [",
                    "  CATEGORY_OUTPUT,",
                    "  CATEGORY_FORMAT,",
                    "  CATEGORY_CONFIG,",
                    "  CATEGORY_EDITOR,",
                    "  CATEGORY_OTHER",
                    "];",
                    "",
                    "/**",
                    " * {",
                    " *   [optionName]: {",
                    " *     // The type of the option. For 'choice', see also `choices` below.",
                    " *     // When passing a type other than the ones listed below, the option is",
                    " *     // treated as taking any string as argument, and `--option <${type}>` will",
                    " *     // be displayed in --help.",
                    " *     type: \"boolean\" | \"choice\" | \"int\" | string;",
                    " *",
                    " *     // Default value to be passed to the minimist option `default`.",
                    " *     default?: any;",
                    " *",
                    " *     // Alias name to be passed to the minimist option `alias`.",
                    " *     alias?: string;",
                    " *",
                    " *     // For grouping options by category in --help.",
                    " *     category?: string;",
                    " *",
                    " *     // Description to be displayed in --help. If omitted, the option won't be",
                    " *     // shown at all in --help (but see also `oppositeDescription` below).",
                    " *     description?: string;",
                    " *",
                    " *     // Description for `--no-${name}` to be displayed in --help. If omitted,",
                    " *     // `--no-${name}` won't be shown.",
                    " *     oppositeDescription?: string;",
                    " *",
                    " *     // Indicate if this option is simply passed to the API.",
                    " *     // true: use camelified name as the API option name.",
                    " *     // string: use this value as the API option name.",
                    " *     forwardToApi?: boolean | string;",
                    " *",
                    " *     // Indicate that a CLI flag should be an array when forwarded to the API.",
                    " *     array?: boolean;",
                    " *",
                    " *     // Specify available choices for validation. They will also be displayed",
                    " *     // in --help as <a|b|c>.",
                    " *     // Use an object instead of a string if a choice is deprecated and should",
                    " *     // be treated as `redirect` instead, or if you'd like to add description for",
                    " *     // the choice.",
                    " *     choices?: Array<",
                    " *       | string",
                    " *       | { value: string, description?: string, deprecated?: boolean, redirect?: string }",
                    " *     >;",
                    " *",
                    " *     // If the option has a value that is an exception to the regular value",
                    " *     // constraints, indicate that value here (or use a function for more",
                    " *     // flexibility).",
                    " *     exception?: ((value: any) => boolean);",
                    " *",
                    " *     // Indicate that the option is deprecated. Use a string to add an extra",
                    " *     // message to --help for the option, for example to suggest a replacement",
                    " *     // option.",
                    " *     deprecated?: true | string;",
                    " *   }",
                    " * }",
                    " *",
                    " * Note: The options below are sorted alphabetically.",
                    " */",
                    "const options = {",
                    "  color: {",
                    "    // The supports-color package (a sub sub dependency) looks directly at",
                    "    // `process.argv` for `--no-color` and such-like options. The reason it is",
                    "    // listed here is to avoid \"Ignored unknown option: --no-color\" warnings.",
                    "    // See https://github.com/chalk/supports-color/#info for more information.",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Colorize error messages.\",",
                    "    oppositeDescription: \"Do not colorize error messages.\"",
                    "  },",
                    "  config: {",
                    "    type: \"path\",",
                    "    category: CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).\",",
                    "    oppositeDescription: \"Do not look for a configuration file.\"",
                    "  },",
                    "  \"config-precedence\": {",
                    "    type: \"choice\",",
                    "    category: CATEGORY_CONFIG,",
                    "    default: \"cli-override\",",
                    "    choices: [",
                    "      {",
                    "        value: \"cli-override\",",
                    "        description: \"CLI options take precedence over config file\"",
                    "      },",
                    "      {",
                    "        value: \"file-override\",",
                    "        description: \"Config file take precedence over CLI options\"",
                    "      },",
                    "      {",
                    "        value: \"prefer-file\",",
                    "        description: dedent`",
                    "          If a config file is found will evaluate it and ignore other CLI options.",
                    "          If no config file is found CLI options will evaluate as normal.",
                    "        `",
                    "      }",
                    "    ],",
                    "    description:",
                    "      \"Define in which order config files and CLI options should be evaluated.\"",
                    "  },",
                    "  \"debug-check\": {",
                    "    type: \"boolean\"",
                    "  },",
                    "  \"debug-print-doc\": {",
                    "    type: \"boolean\"",
                    "  },",
                    "  editorconfig: {",
                    "    type: \"boolean\",",
                    "    category: CATEGORY_CONFIG,",
                    "    description: \"Take .editorconfig into account when parsing configuration.\",",
                    "    oppositeDescription:",
                    "      \"Don't take .editorconfig into account when parsing configuration.\",",
                    "    default: true",
                    "  },",
                    "  \"find-config-path\": {",
                    "    type: \"path\",",
                    "    category: CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Find and print the path to a configuration file for the given input file.\"",
                    "  },",
                    "  help: {",
                    "    type: \"flag\",",
                    "    alias: \"h\",",
                    "    description: dedent`",
                    "      Show CLI usage, or details about the given flag.",
                    "      Example: --help write",
                    "    `",
                    "  },",
                    "  \"ignore-path\": {",
                    "    type: \"path\",",
                    "    category: CATEGORY_CONFIG,",
                    "    default: \".prettierignore\",",
                    "    description: \"Path to a file with patterns describing files to ignore.\"",
                    "  },",
                    "  \"list-different\": {",
                    "    type: \"boolean\",",
                    "    category: CATEGORY_OUTPUT,",
                    "    alias: \"l\",",
                    "    description:",
                    "      \"Print the names of files that are different from Prettier's formatting.\"",
                    "  },",
                    "  loglevel: {",
                    "    type: \"choice\",",
                    "    description: \"What level of logs to report.\",",
                    "    default: \"log\",",
                    "    choices: [\"silent\", \"error\", \"warn\", \"log\", \"debug\"]",
                    "  },",
                    "  stdin: {",
                    "    type: \"boolean\",",
                    "    description: \"Force reading input from stdin.\"",
                    "  },",
                    "  \"support-info\": {",
                    "    type: \"boolean\",",
                    "    description: \"Print support information as JSON.\"",
                    "  },",
                    "  version: {",
                    "    type: \"boolean\",",
                    "    alias: \"v\",",
                    "    description: \"Print Prettier version.\"",
                    "  },",
                    "  \"with-node-modules\": {",
                    "    type: \"boolean\",",
                    "    category: CATEGORY_CONFIG,",
                    "    description: \"Process files inside 'node_modules' directory.\"",
                    "  },",
                    "  write: {",
                    "    type: \"boolean\",",
                    "    category: CATEGORY_OUTPUT,",
                    "    description: \"Edit files in-place. (Beware!)\"",
                    "  }",
                    "};",
                    "",
                    "const usageSummary = dedent`",
                    "  Usage: prettier [options] [file/glob ...]",
                    "",
                    "  By default, output is written to stdout.",
                    "  Stdin is read if it is piped to Prettier and no files are given.",
                    "`;",
                    "",
                    "module.exports = {",
                    "  CATEGORY_CONFIG,",
                    "  CATEGORY_EDITOR,",
                    "  CATEGORY_FORMAT,",
                    "  CATEGORY_OTHER,",
                    "  CATEGORY_OUTPUT,",
                    "  categoryOrder,",
                    "  options,",
                    "  usageSummary",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"../../index\");",
                    "const stringify = require(\"json-stable-stringify\");",
                    "const util = require(\"./util\");",
                    "",
                    "function run(args) {",
                    "  const context = util.createContext(args);",
                    "",
                    "  try {",
                    "    util.initContext(context);",
                    "",
                    "    context.logger.debug(`normalized argv: ${JSON.stringify(context.argv)}`);",
                    "",
                    "    if (context.argv[\"write\"] && context.argv[\"debug-check\"]) {",
                    "      context.logger.error(\"Cannot use --write and --debug-check together.\");",
                    "      process.exit(1);",
                    "    }",
                    "",
                    "    if (context.argv[\"find-config-path\"] && context.filePatterns.length) {",
                    "      context.logger.error(\"Cannot use --find-config-path with multiple files\");",
                    "      process.exit(1);",
                    "    }",
                    "",
                    "    if (context.argv[\"version\"]) {",
                    "      context.logger.log(prettier.version);",
                    "      process.exit(0);",
                    "    }",
                    "",
                    "    if (context.argv[\"help\"] !== undefined) {",
                    "      context.logger.log(",
                    "        typeof context.argv[\"help\"] === \"string\" && context.argv[\"help\"] !== \"\"",
                    "          ? util.createDetailedUsage(context, context.argv[\"help\"])",
                    "          : util.createUsage(context)",
                    "      );",
                    "      process.exit(0);",
                    "    }",
                    "",
                    "    if (context.argv[\"support-info\"]) {",
                    "      context.logger.log(",
                    "        prettier.format(stringify(prettier.getSupportInfo()), {",
                    "          parser: \"json\"",
                    "        })",
                    "      );",
                    "      process.exit(0);",
                    "    }",
                    "",
                    "    const hasFilePatterns = context.filePatterns.length !== 0;",
                    "    const useStdin =",
                    "      context.argv[\"stdin\"] || (!hasFilePatterns && !process.stdin.isTTY);",
                    "",
                    "    if (context.argv[\"find-config-path\"]) {",
                    "      util.logResolvedConfigPathOrDie(",
                    "        context,",
                    "        context.argv[\"find-config-path\"]",
                    "      );",
                    "    } else if (useStdin) {",
                    "      util.formatStdin(context);",
                    "    } else if (hasFilePatterns) {",
                    "      util.formatFiles(context);",
                    "    } else {",
                    "      context.logger.log(util.createUsage(context));",
                    "      process.exit(1);",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.message);",
                    "    process.exit(1);",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  run",
                    "};"
                ]
            },
            "minimist.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const minimist = require(\"minimist\");",
                    "",
                    "const PLACEHOLDER = null;",
                    "",
                    "/**",
                    " * unspecified boolean flag without default value is parsed as `undefined` instead of `false`",
                    " */",
                    "module.exports = function(args, options) {",
                    "  const boolean = options.boolean || [];",
                    "  const defaults = options.default || {};",
                    "",
                    "  const booleanWithoutDefault = boolean.filter(key => !(key in defaults));",
                    "  const newDefaults = Object.assign(",
                    "    {},",
                    "    defaults,",
                    "    booleanWithoutDefault.reduce(",
                    "      (reduced, key) => Object.assign(reduced, { [key]: PLACEHOLDER }),",
                    "      {}",
                    "    )",
                    "  );",
                    "",
                    "  const parsed = minimist(",
                    "    args,",
                    "    Object.assign({}, options, { default: newDefaults })",
                    "  );",
                    "",
                    "  return Object.keys(parsed).reduce((reduced, key) => {",
                    "    if (parsed[key] !== PLACEHOLDER) {",
                    "      reduced[key] = parsed[key];",
                    "    }",
                    "    return reduced;",
                    "  }, {});",
                    "};"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const camelCase = require(\"camelcase\");",
                    "const dashify = require(\"dashify\");",
                    "const fs = require(\"fs\");",
                    "const globby = require(\"globby\");",
                    "const ignore = require(\"ignore\");",
                    "const chalk = require(\"chalk\");",
                    "const readline = require(\"readline\");",
                    "const leven = require(\"leven\");",
                    "",
                    "const minimist = require(\"./minimist\");",
                    "const prettier = require(\"../../index\");",
                    "const cleanAST = require(\"../common/clean-ast\").cleanAST;",
                    "const errors = require(\"../common/errors\");",
                    "const resolver = require(\"../config/resolve-config\");",
                    "const constant = require(\"./constant\");",
                    "const optionsModule = require(\"../main/options\");",
                    "const optionsNormalizer = require(\"../main/options-normalizer\");",
                    "const thirdParty = require(\"../common/third-party\");",
                    "const getSupportInfo = require(\"../common/support\").getSupportInfo;",
                    "const util = require(\"../common/util\");",
                    "",
                    "const OPTION_USAGE_THRESHOLD = 25;",
                    "const CHOICE_USAGE_MARGIN = 3;",
                    "const CHOICE_USAGE_INDENTATION = 2;",
                    "",
                    "function getOptions(argv, detailedOptions) {",
                    "  return detailedOptions.filter(option => option.forwardToApi).reduce(",
                    "    (current, option) =>",
                    "      Object.assign(current, {",
                    "        [option.forwardToApi]: argv[option.name]",
                    "      }),",
                    "    {}",
                    "  );",
                    "}",
                    "",
                    "function cliifyOptions(object, apiDetailedOptionMap) {",
                    "  return Object.keys(object || {}).reduce((output, key) => {",
                    "    const apiOption = apiDetailedOptionMap[key];",
                    "    const cliKey = apiOption ? apiOption.name : key;",
                    "",
                    "    output[dashify(cliKey)] = object[key];",
                    "    return output;",
                    "  }, {});",
                    "}",
                    "",
                    "function diff(a, b) {",
                    "  return require(\"diff\").createTwoFilesPatch(\"\", \"\", a, b, \"\", \"\", {",
                    "    context: 2",
                    "  });",
                    "}",
                    "",
                    "function handleError(context, filename, error) {",
                    "  const isParseError = Boolean(error && error.loc);",
                    "  const isValidationError = /Validation Error/.test(error && error.message);",
                    "",
                    "  // For parse errors and validation errors, we only want to show the error",
                    "  // message formatted in a nice way. `String(error)` takes care of that. Other",
                    "  // (unexpected) errors are passed as-is as a separate argument to",
                    "  // `console.error`. That includes the stack trace (if any), and shows a nice",
                    "  // `util.inspect` of throws things that aren't `Error` objects. (The Flow",
                    "  // parser has mistakenly thrown arrays sometimes.)",
                    "  if (isParseError) {",
                    "    context.logger.error(`${filename}: ${String(error)}`);",
                    "  } else if (isValidationError || error instanceof errors.ConfigError) {",
                    "    context.logger.error(String(error));",
                    "    // If validation fails for one file, it will fail for all of them.",
                    "    process.exit(1);",
                    "  } else if (error instanceof errors.DebugError) {",
                    "    context.logger.error(`${filename}: ${error.message}`);",
                    "  } else {",
                    "    context.logger.error(filename + \": \" + (error.stack || error));",
                    "  }",
                    "",
                    "  // Don't exit the process if one file failed",
                    "  process.exitCode = 2;",
                    "}",
                    "",
                    "function logResolvedConfigPathOrDie(context, filePath) {",
                    "  const configFile = resolver.resolveConfigFile.sync(filePath);",
                    "  if (configFile) {",
                    "    context.logger.log(path.relative(process.cwd(), configFile));",
                    "  } else {",
                    "    process.exit(1);",
                    "  }",
                    "}",
                    "",
                    "function writeOutput(result, options) {",
                    "  // Don't use `console.log` here since it adds an extra newline at the end.",
                    "  process.stdout.write(result.formatted);",
                    "",
                    "  if (options.cursorOffset >= 0) {",
                    "    process.stderr.write(result.cursorOffset + \"\\n\");",
                    "  }",
                    "}",
                    "",
                    "function listDifferent(context, input, options, filename) {",
                    "  if (!context.argv[\"list-different\"]) {",
                    "    return;",
                    "  }",
                    "",
                    "  options = Object.assign({}, options, { filepath: filename });",
                    "",
                    "  if (!prettier.check(input, options)) {",
                    "    if (!context.argv[\"write\"]) {",
                    "      context.logger.log(filename);",
                    "    }",
                    "    process.exitCode = 1;",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function format(context, input, opt) {",
                    "  if (context.argv[\"debug-print-doc\"]) {",
                    "    const doc = prettier.__debug.printToDoc(input, opt);",
                    "    return { formatted: prettier.__debug.formatDoc(doc) };",
                    "  }",
                    "",
                    "  if (context.argv[\"debug-check\"]) {",
                    "    const pp = prettier.format(input, opt);",
                    "    const pppp = prettier.format(pp, opt);",
                    "    if (pp !== pppp) {",
                    "      throw new errors.DebugError(",
                    "        \"prettier(input) !== prettier(prettier(input))\\n\" + diff(pp, pppp)",
                    "      );",
                    "    } else {",
                    "      const normalizedOpts = optionsModule.normalize(opt);",
                    "      const ast = cleanAST(",
                    "        prettier.__debug.parse(input, opt).ast,",
                    "        normalizedOpts",
                    "      );",
                    "      const past = cleanAST(",
                    "        prettier.__debug.parse(pp, opt).ast,",
                    "        normalizedOpts",
                    "      );",
                    "",
                    "      if (ast !== past) {",
                    "        const MAX_AST_SIZE = 2097152; // 2MB",
                    "        const astDiff =",
                    "          ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE",
                    "            ? \"AST diff too large to render\"",
                    "            : diff(ast, past);",
                    "        throw new errors.DebugError(",
                    "          \"ast(input) !== ast(prettier(input))\\n\" +",
                    "            astDiff +",
                    "            \"\\n\" +",
                    "            diff(input, pp)",
                    "        );",
                    "      }",
                    "    }",
                    "    return { formatted: opt.filepath || \"(stdin)\\n\" };",
                    "  }",
                    "",
                    "  return prettier.formatWithCursor(input, opt);",
                    "}",
                    "",
                    "function getOptionsOrDie(context, filePath) {",
                    "  try {",
                    "    if (context.argv[\"config\"] === false) {",
                    "      context.logger.debug(",
                    "        \"'--no-config' option found, skip loading config file.\"",
                    "      );",
                    "      return null;",
                    "    }",
                    "",
                    "    context.logger.debug(",
                    "      context.argv[\"config\"]",
                    "        ? `load config file from '${context.argv[\"config\"]}'`",
                    "        : `resolve config from '${filePath}'`",
                    "    );",
                    "",
                    "    const options = resolver.resolveConfig.sync(filePath, {",
                    "      editorconfig: context.argv[\"editorconfig\"],",
                    "      config: context.argv[\"config\"]",
                    "    });",
                    "",
                    "    context.logger.debug(\"loaded options `\" + JSON.stringify(options) + \"`\");",
                    "    return options;",
                    "  } catch (error) {",
                    "    context.logger.error(\"Invalid configuration file: \" + error.message);",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "function getOptionsForFile(context, filepath) {",
                    "  const options = getOptionsOrDie(context, filepath);",
                    "",
                    "  const hasPlugins = options && options.plugins;",
                    "  if (hasPlugins) {",
                    "    pushContextPlugins(context, options.plugins);",
                    "  }",
                    "",
                    "  const appliedOptions = Object.assign(",
                    "    { filepath },",
                    "    applyConfigPrecedence(",
                    "      context,",
                    "      options &&",
                    "        optionsNormalizer.normalizeApiOptions(options, context.supportOptions, {",
                    "          logger: context.logger",
                    "        })",
                    "    )",
                    "  );",
                    "",
                    "  context.logger.debug(",
                    "    `applied config-precedence (${context.argv[\"config-precedence\"]}): ` +",
                    "      `${JSON.stringify(appliedOptions)}`",
                    "  );",
                    "",
                    "  if (hasPlugins) {",
                    "    popContextPlugins(context);",
                    "  }",
                    "",
                    "  return appliedOptions;",
                    "}",
                    "",
                    "function parseArgsToOptions(context, overrideDefaults) {",
                    "  const minimistOptions = createMinimistOptions(context.detailedOptions);",
                    "  const apiDetailedOptionMap = createApiDetailedOptionMap(",
                    "    context.detailedOptions",
                    "  );",
                    "  return getOptions(",
                    "    optionsNormalizer.normalizeCliOptions(",
                    "      minimist(",
                    "        context.args,",
                    "        Object.assign({",
                    "          string: minimistOptions.string,",
                    "          boolean: minimistOptions.boolean,",
                    "          default: cliifyOptions(overrideDefaults, apiDetailedOptionMap)",
                    "        })",
                    "      ),",
                    "      context.detailedOptions,",
                    "      { logger: false }",
                    "    ),",
                    "    context.detailedOptions",
                    "  );",
                    "}",
                    "",
                    "function applyConfigPrecedence(context, options) {",
                    "  try {",
                    "    switch (context.argv[\"config-precedence\"]) {",
                    "      case \"cli-override\":",
                    "        return parseArgsToOptions(context, options);",
                    "      case \"file-override\":",
                    "        return Object.assign({}, parseArgsToOptions(context), options);",
                    "      case \"prefer-file\":",
                    "        return options || parseArgsToOptions(context);",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.toString());",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "function formatStdin(context) {",
                    "  const filepath = context.argv[\"stdin-filepath\"]",
                    "    ? path.resolve(process.cwd(), context.argv[\"stdin-filepath\"])",
                    "    : process.cwd();",
                    "",
                    "  const ignorer = createIgnorer(context);",
                    "  const relativeFilepath = path.relative(process.cwd(), filepath);",
                    "",
                    "  thirdParty.getStream(process.stdin).then(input => {",
                    "    if (relativeFilepath && ignorer.filter([relativeFilepath]).length === 0) {",
                    "      writeOutput({ formatted: input }, {});",
                    "      return;",
                    "    }",
                    "",
                    "    const options = getOptionsForFile(context, filepath);",
                    "",
                    "    if (listDifferent(context, input, options, \"(stdin)\")) {",
                    "      return;",
                    "    }",
                    "",
                    "    try {",
                    "      writeOutput(format(context, input, options), options);",
                    "    } catch (error) {",
                    "      handleError(context, \"stdin\", error);",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function createIgnorer(context) {",
                    "  const ignoreFilePath = path.resolve(context.argv[\"ignore-path\"]);",
                    "  let ignoreText = \"\";",
                    "",
                    "  try {",
                    "    ignoreText = fs.readFileSync(ignoreFilePath, \"utf8\");",
                    "  } catch (readError) {",
                    "    if (readError.code !== \"ENOENT\") {",
                    "      context.logger.error(",
                    "        `Unable to read ${ignoreFilePath}: ` + readError.message",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "  }",
                    "",
                    "  return ignore().add(ignoreText);",
                    "}",
                    "",
                    "function eachFilename(context, patterns, callback) {",
                    "  const ignoreNodeModules = context.argv[\"with-node-modules\"] !== true;",
                    "  if (ignoreNodeModules) {",
                    "    patterns = patterns.concat([\"!**/node_modules/**\", \"!./node_modules/**\"]);",
                    "  }",
                    "",
                    "  try {",
                    "    const filePaths = globby",
                    "      .sync(patterns, { dot: true, nodir: true })",
                    "      .map(filePath => path.relative(process.cwd(), filePath));",
                    "",
                    "    if (filePaths.length === 0) {",
                    "      context.logger.error(",
                    "        `No matching files. Patterns tried: ${patterns.join(\" \")}`",
                    "      );",
                    "      process.exitCode = 2;",
                    "      return;",
                    "    }",
                    "    filePaths.forEach(filePath =>",
                    "      callback(filePath, getOptionsForFile(context, filePath))",
                    "    );",
                    "  } catch (error) {",
                    "    context.logger.error(",
                    "      `Unable to expand glob patterns: ${patterns.join(\" \")}\\n${error.message}`",
                    "    );",
                    "    // Don't exit the process if one pattern failed",
                    "    process.exitCode = 2;",
                    "  }",
                    "}",
                    "",
                    "function formatFiles(context) {",
                    "  // The ignorer will be used to filter file paths after the glob is checked,",
                    "  // before any files are actually written",
                    "  const ignorer = createIgnorer(context);",
                    "",
                    "  eachFilename(context, context.filePatterns, (filename, options) => {",
                    "    const fileIgnored = ignorer.filter([filename]).length === 0;",
                    "    if (",
                    "      fileIgnored &&",
                    "      (context.argv[\"debug-check\"] ||",
                    "        context.argv[\"write\"] ||",
                    "        context.argv[\"list-different\"])",
                    "    ) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (context.argv[\"write\"] && process.stdout.isTTY) {",
                    "      // Don't use `console.log` here since we need to replace this line.",
                    "      context.logger.log(filename, { newline: false });",
                    "    }",
                    "",
                    "    let input;",
                    "    try {",
                    "      input = fs.readFileSync(filename, \"utf8\");",
                    "    } catch (error) {",
                    "      // Add newline to split errors from filename line.",
                    "      context.logger.log(\"\");",
                    "",
                    "      context.logger.error(",
                    "        `Unable to read file: ${filename}\\n${error.message}`",
                    "      );",
                    "      // Don't exit the process if one file failed",
                    "      process.exitCode = 2;",
                    "      return;",
                    "    }",
                    "",
                    "    if (fileIgnored) {",
                    "      writeOutput({ formatted: input }, options);",
                    "      return;",
                    "    }",
                    "",
                    "    listDifferent(context, input, options, filename);",
                    "",
                    "    const start = Date.now();",
                    "",
                    "    let result;",
                    "    let output;",
                    "",
                    "    try {",
                    "      result = format(",
                    "        context,",
                    "        input,",
                    "        Object.assign({}, options, { filepath: filename })",
                    "      );",
                    "      output = result.formatted;",
                    "    } catch (error) {",
                    "      // Add newline to split errors from filename line.",
                    "      process.stdout.write(\"\\n\");",
                    "",
                    "      handleError(context, filename, error);",
                    "      return;",
                    "    }",
                    "",
                    "    if (context.argv[\"write\"]) {",
                    "      if (process.stdout.isTTY) {",
                    "        // Remove previously printed filename to log it with duration.",
                    "        readline.clearLine(process.stdout, 0);",
                    "        readline.cursorTo(process.stdout, 0, null);",
                    "      }",
                    "",
                    "      // Don't write the file if it won't change in order not to invalidate",
                    "      // mtime based caches.",
                    "      if (output === input) {",
                    "        if (!context.argv[\"list-different\"]) {",
                    "          context.logger.log(`${chalk.grey(filename)} ${Date.now() - start}ms`);",
                    "        }",
                    "      } else {",
                    "        if (context.argv[\"list-different\"]) {",
                    "          context.logger.log(filename);",
                    "        } else {",
                    "          context.logger.log(`${filename} ${Date.now() - start}ms`);",
                    "        }",
                    "",
                    "        try {",
                    "          fs.writeFileSync(filename, output, \"utf8\");",
                    "        } catch (error) {",
                    "          context.logger.error(",
                    "            `Unable to write file: ${filename}\\n${error.message}`",
                    "          );",
                    "          // Don't exit the process if one file failed",
                    "          process.exitCode = 2;",
                    "        }",
                    "      }",
                    "    } else if (context.argv[\"debug-check\"]) {",
                    "      if (output) {",
                    "        context.logger.log(output);",
                    "      } else {",
                    "        process.exitCode = 2;",
                    "      }",
                    "    } else if (!context.argv[\"list-different\"]) {",
                    "      writeOutput(result, options);",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function getOptionsWithOpposites(options) {",
                    "  // Add --no-foo after --foo.",
                    "  const optionsWithOpposites = options.map(option => [",
                    "    option.description ? option : null,",
                    "    option.oppositeDescription",
                    "      ? Object.assign({}, option, {",
                    "          name: `no-${option.name}`,",
                    "          type: \"boolean\",",
                    "          description: option.oppositeDescription",
                    "        })",
                    "      : null",
                    "  ]);",
                    "  return flattenArray(optionsWithOpposites).filter(Boolean);",
                    "}",
                    "",
                    "function createUsage(context) {",
                    "  const options = getOptionsWithOpposites(context.detailedOptions).filter(",
                    "    // remove unnecessary option (e.g. `semi`, `color`, etc.), which is only used for --help <flag>",
                    "    option =>",
                    "      !(",
                    "        option.type === \"boolean\" &&",
                    "        option.oppositeDescription &&",
                    "        !option.name.startsWith(\"no-\")",
                    "      )",
                    "  );",
                    "",
                    "  const groupedOptions = groupBy(options, option => option.category);",
                    "",
                    "  const firstCategories = constant.categoryOrder.slice(0, -1);",
                    "  const lastCategories = constant.categoryOrder.slice(-1);",
                    "  const restCategories = Object.keys(groupedOptions).filter(",
                    "    category =>",
                    "      firstCategories.indexOf(category) === -1 &&",
                    "      lastCategories.indexOf(category) === -1",
                    "  );",
                    "  const allCategories = firstCategories.concat(restCategories, lastCategories);",
                    "",
                    "  const optionsUsage = allCategories.map(category => {",
                    "    const categoryOptions = groupedOptions[category]",
                    "      .map(option => createOptionUsage(context, option, OPTION_USAGE_THRESHOLD))",
                    "      .join(\"\\n\");",
                    "    return `${category} options:\\n\\n${indent(categoryOptions, 2)}`;",
                    "  });",
                    "",
                    "  return [constant.usageSummary].concat(optionsUsage, [\"\"]).join(\"\\n\\n\");",
                    "}",
                    "",
                    "function createOptionUsage(context, option, threshold) {",
                    "  const header = createOptionUsageHeader(option);",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  return createOptionUsageRow(",
                    "    header,",
                    "    `${option.description}${",
                    "      optionDefaultValue === undefined",
                    "        ? \"\"",
                    "        : `\\nDefaults to ${createDefaultValueDisplay(optionDefaultValue)}.`",
                    "    }`,",
                    "    threshold",
                    "  );",
                    "}",
                    "",
                    "function createDefaultValueDisplay(value) {",
                    "  return Array.isArray(value)",
                    "    ? `[${value.map(createDefaultValueDisplay).join(\", \")}]`",
                    "    : value;",
                    "}",
                    "",
                    "function createOptionUsageHeader(option) {",
                    "  const name = `--${option.name}`;",
                    "  const alias = option.alias ? `-${option.alias},` : null;",
                    "  const type = createOptionUsageType(option);",
                    "  return [alias, name, type].filter(Boolean).join(\" \");",
                    "}",
                    "",
                    "function createOptionUsageRow(header, content, threshold) {",
                    "  const separator =",
                    "    header.length >= threshold",
                    "      ? `\\n${\" \".repeat(threshold)}`",
                    "      : \" \".repeat(threshold - header.length);",
                    "",
                    "  const description = content.replace(/\\n/g, `\\n${\" \".repeat(threshold)}`);",
                    "",
                    "  return `${header}${separator}${description}`;",
                    "}",
                    "",
                    "function createOptionUsageType(option) {",
                    "  switch (option.type) {",
                    "    case \"boolean\":",
                    "      return null;",
                    "    case \"choice\":",
                    "      return `<${option.choices",
                    "        .filter(choice => !choice.deprecated)",
                    "        .map(choice => choice.value)",
                    "        .join(\"|\")}>`;",
                    "    default:",
                    "      return `<${option.type}>`;",
                    "  }",
                    "}",
                    "",
                    "function flattenArray(array) {",
                    "  return [].concat.apply([], array);",
                    "}",
                    "",
                    "function getOptionWithLevenSuggestion(context, options, optionName) {",
                    "  // support aliases",
                    "  const optionNameContainers = flattenArray(",
                    "    options.map((option, index) => [",
                    "      { value: option.name, index },",
                    "      option.alias ? { value: option.alias, index } : null",
                    "    ])",
                    "  ).filter(Boolean);",
                    "",
                    "  const optionNameContainer = optionNameContainers.find(",
                    "    optionNameContainer => optionNameContainer.value === optionName",
                    "  );",
                    "",
                    "  if (optionNameContainer !== undefined) {",
                    "    return options[optionNameContainer.index];",
                    "  }",
                    "",
                    "  const suggestedOptionNameContainer = optionNameContainers.find(",
                    "    optionNameContainer => leven(optionNameContainer.value, optionName) < 3",
                    "  );",
                    "",
                    "  if (suggestedOptionNameContainer !== undefined) {",
                    "    const suggestedOptionName = suggestedOptionNameContainer.value;",
                    "    context.logger.warn(",
                    "      `Unknown option name \"${optionName}\", did you mean \"${suggestedOptionName}\"?`",
                    "    );",
                    "",
                    "    return options[suggestedOptionNameContainer.index];",
                    "  }",
                    "",
                    "  context.logger.warn(`Unknown option name \"${optionName}\"`);",
                    "  return options.find(option => option.name === \"help\");",
                    "}",
                    "",
                    "function createChoiceUsages(choices, margin, indentation) {",
                    "  const activeChoices = choices.filter(choice => !choice.deprecated);",
                    "  const threshold =",
                    "    activeChoices",
                    "      .map(choice => choice.value.length)",
                    "      .reduce((current, length) => Math.max(current, length), 0) + margin;",
                    "  return activeChoices.map(choice =>",
                    "    indent(",
                    "      createOptionUsageRow(choice.value, choice.description, threshold),",
                    "      indentation",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function createDetailedUsage(context, optionName) {",
                    "  const option = getOptionWithLevenSuggestion(",
                    "    context,",
                    "    getOptionsWithOpposites(context.detailedOptions),",
                    "    optionName",
                    "  );",
                    "",
                    "  const header = createOptionUsageHeader(option);",
                    "  const description = `\\n\\n${indent(option.description, 2)}`;",
                    "",
                    "  const choices =",
                    "    option.type !== \"choice\"",
                    "      ? \"\"",
                    "      : `\\n\\nValid options:\\n\\n${createChoiceUsages(",
                    "          option.choices,",
                    "          CHOICE_USAGE_MARGIN,",
                    "          CHOICE_USAGE_INDENTATION",
                    "        ).join(\"\\n\")}`;",
                    "",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  const defaults =",
                    "    optionDefaultValue !== undefined",
                    "      ? `\\n\\nDefault: ${createDefaultValueDisplay(optionDefaultValue)}`",
                    "      : \"\";",
                    "",
                    "  const pluginDefaults =",
                    "    option.pluginDefaults && Object.keys(option.pluginDefaults).length",
                    "      ? `\\nPlugin defaults:${Object.keys(option.pluginDefaults).map(",
                    "          key =>",
                    "            `\\n* ${key}: ${createDefaultValueDisplay(",
                    "              option.pluginDefaults[key]",
                    "            )}`",
                    "        )}`",
                    "      : \"\";",
                    "  return `${header}${description}${choices}${defaults}${pluginDefaults}`;",
                    "}",
                    "",
                    "function getOptionDefaultValue(context, optionName) {",
                    "  // --no-option",
                    "  if (!(optionName in context.detailedOptionMap)) {",
                    "    return undefined;",
                    "  }",
                    "",
                    "  const option = context.detailedOptionMap[optionName];",
                    "",
                    "  if (option.default !== undefined) {",
                    "    return option.default;",
                    "  }",
                    "",
                    "  const optionCamelName = camelCase(optionName);",
                    "  if (optionCamelName in context.apiDefaultOptions) {",
                    "    return context.apiDefaultOptions[optionCamelName];",
                    "  }",
                    "",
                    "  return undefined;",
                    "}",
                    "",
                    "function indent(str, spaces) {",
                    "  return str.replace(/^/gm, \" \".repeat(spaces));",
                    "}",
                    "",
                    "function groupBy(array, getKey) {",
                    "  return array.reduce((obj, item) => {",
                    "    const key = getKey(item);",
                    "    const previousItems = key in obj ? obj[key] : [];",
                    "    return Object.assign({}, obj, { [key]: previousItems.concat(item) });",
                    "  }, Object.create(null));",
                    "}",
                    "",
                    "function pick(object, keys) {",
                    "  return !keys",
                    "    ? object",
                    "    : keys.reduce(",
                    "        (reduced, key) => Object.assign(reduced, { [key]: object[key] }),",
                    "        {}",
                    "      );",
                    "}",
                    "",
                    "function createLogger(logLevel) {",
                    "  return {",
                    "    warn: createLogFunc(\"warn\", \"yellow\"),",
                    "    error: createLogFunc(\"error\", \"red\"),",
                    "    debug: createLogFunc(\"debug\", \"blue\"),",
                    "    log: createLogFunc(\"log\")",
                    "  };",
                    "",
                    "  function createLogFunc(loggerName, color) {",
                    "    if (!shouldLog(loggerName)) {",
                    "      return () => {};",
                    "    }",
                    "",
                    "    const prefix = color ? `[${chalk[color](loggerName)}] ` : \"\";",
                    "    return function(message, opts) {",
                    "      opts = Object.assign({ newline: true }, opts);",
                    "      const stream = process[loggerName === \"log\" ? \"stdout\" : \"stderr\"];",
                    "      stream.write(message.replace(/^/gm, prefix) + (opts.newline ? \"\\n\" : \"\"));",
                    "    };",
                    "  }",
                    "",
                    "  function shouldLog(loggerName) {",
                    "    switch (logLevel) {",
                    "      case \"silent\":",
                    "        return false;",
                    "      default:",
                    "        return true;",
                    "      case \"debug\":",
                    "        if (loggerName === \"debug\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"log\":",
                    "        if (loggerName === \"log\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"warn\":",
                    "        if (loggerName === \"warn\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"error\":",
                    "        return loggerName === \"error\";",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function normalizeDetailedOption(name, option) {",
                    "  return Object.assign({ category: constant.CATEGORY_OTHER }, option, {",
                    "    choices:",
                    "      option.choices &&",
                    "      option.choices.map(choice => {",
                    "        const newChoice = Object.assign(",
                    "          { description: \"\", deprecated: false },",
                    "          typeof choice === \"object\" ? choice : { value: choice }",
                    "        );",
                    "        if (newChoice.value === true) {",
                    "          newChoice.value = \"\"; // backward compability for original boolean option",
                    "        }",
                    "        return newChoice;",
                    "      })",
                    "  });",
                    "}",
                    "",
                    "function normalizeDetailedOptionMap(detailedOptionMap) {",
                    "  return Object.keys(detailedOptionMap)",
                    "    .sort()",
                    "    .reduce((normalized, name) => {",
                    "      const option = detailedOptionMap[name];",
                    "      return Object.assign(normalized, {",
                    "        [name]: normalizeDetailedOption(name, option)",
                    "      });",
                    "    }, {});",
                    "}",
                    "",
                    "function createMinimistOptions(detailedOptions) {",
                    "  return {",
                    "    boolean: detailedOptions",
                    "      .filter(option => option.type === \"boolean\")",
                    "      .map(option => option.name),",
                    "    string: detailedOptions",
                    "      .filter(option => option.type !== \"boolean\")",
                    "      .map(option => option.name),",
                    "    default: detailedOptions",
                    "      .filter(option => !option.deprecated)",
                    "      .filter(option => !option.forwardToApi || option.name === \"plugin\")",
                    "      .filter(option => option.default !== undefined)",
                    "      .reduce(",
                    "        (current, option) =>",
                    "          Object.assign({ [option.name]: option.default }, current),",
                    "        {}",
                    "      ),",
                    "    alias: detailedOptions",
                    "      .filter(option => option.alias !== undefined)",
                    "      .reduce(",
                    "        (current, option) =>",
                    "          Object.assign({ [option.name]: option.alias }, current),",
                    "        {}",
                    "      )",
                    "  };",
                    "}",
                    "",
                    "function createApiDetailedOptionMap(detailedOptions) {",
                    "  return detailedOptions.reduce(",
                    "    (current, option) =>",
                    "      option.forwardToApi && option.forwardToApi !== option.name",
                    "        ? Object.assign(current, { [option.forwardToApi]: option })",
                    "        : current,",
                    "    {}",
                    "  );",
                    "}",
                    "",
                    "function createDetailedOptionMap(supportOptions) {",
                    "  return supportOptions.reduce((reduced, option) => {",
                    "    const newOption = Object.assign({}, option, {",
                    "      name: option.cliName || dashify(option.name),",
                    "      description: option.cliDescription || option.description,",
                    "      category: option.cliCategory || constant.CATEGORY_FORMAT,",
                    "      forwardToApi: option.name",
                    "    });",
                    "",
                    "    if (option.deprecated) {",
                    "      delete newOption.forwardToApi;",
                    "      delete newOption.description;",
                    "      delete newOption.oppositeDescription;",
                    "      newOption.deprecated = true;",
                    "    }",
                    "",
                    "    return Object.assign(reduced, { [newOption.name]: newOption });",
                    "  }, {});",
                    "}",
                    "",
                    "//-----------------------------context-util-start-------------------------------",
                    "/**",
                    " * @typedef {Object} Context",
                    " * @property logger",
                    " * @property args",
                    " * @property argv",
                    " * @property filePatterns",
                    " * @property supportOptions",
                    " * @property detailedOptions",
                    " * @property detailedOptionMap",
                    " * @property apiDefaultOptions",
                    " */",
                    "function createContext(args) {",
                    "  const context = { args };",
                    "",
                    "  updateContextArgv(context);",
                    "  normalizeContextArgv(context, [\"loglevel\", \"plugin\"]);",
                    "",
                    "  context.logger = createLogger(context.argv[\"loglevel\"]);",
                    "",
                    "  updateContextArgv(context, context.argv[\"plugin\"]);",
                    "",
                    "  return context;",
                    "}",
                    "",
                    "function initContext(context) {",
                    "  // split into 2 step so that we could wrap this in a `try..catch` in cli/index.js",
                    "  normalizeContextArgv(context);",
                    "}",
                    "",
                    "function updateContextOptions(context, plugins) {",
                    "  const supportOptions = getSupportInfo(null, {",
                    "    showDeprecated: true,",
                    "    showUnreleased: true,",
                    "    showInternal: true,",
                    "    plugins",
                    "  }).options;",
                    "",
                    "  const detailedOptionMap = normalizeDetailedOptionMap(",
                    "    Object.assign({}, createDetailedOptionMap(supportOptions), constant.options)",
                    "  );",
                    "",
                    "  const detailedOptions = util.arrayify(detailedOptionMap, \"name\");",
                    "",
                    "  const apiDefaultOptions = supportOptions",
                    "    .filter(optionInfo => !optionInfo.deprecated)",
                    "    .reduce(",
                    "      (reduced, optionInfo) =>",
                    "        Object.assign(reduced, { [optionInfo.name]: optionInfo.default }),",
                    "      Object.assign({}, optionsModule.hiddenDefaults)",
                    "    );",
                    "",
                    "  context.supportOptions = supportOptions;",
                    "  context.detailedOptions = detailedOptions;",
                    "  context.detailedOptionMap = detailedOptionMap;",
                    "  context.apiDefaultOptions = apiDefaultOptions;",
                    "}",
                    "",
                    "function pushContextPlugins(context, plugins) {",
                    "  context._supportOptions = context.supportOptions;",
                    "  context._detailedOptions = context.detailedOptions;",
                    "  context._detailedOptionMap = context.detailedOptionMap;",
                    "  context._apiDefaultOptions = context.apiDefaultOptions;",
                    "  updateContextOptions(context, plugins);",
                    "}",
                    "",
                    "function popContextPlugins(context) {",
                    "  context.supportOptions = context._supportOptions;",
                    "  context.detailedOptions = context._detailedOptions;",
                    "  context.detailedOptionMap = context._detailedOptionMap;",
                    "  context.apiDefaultOptions = context._apiDefaultOptions;",
                    "}",
                    "",
                    "function updateContextArgv(context, plugins) {",
                    "  pushContextPlugins(context, plugins);",
                    "",
                    "  const minimistOptions = createMinimistOptions(context.detailedOptions);",
                    "  const argv = minimist(context.args, minimistOptions);",
                    "",
                    "  context.argv = argv;",
                    "  context.filePatterns = argv[\"_\"];",
                    "}",
                    "",
                    "function normalizeContextArgv(context, keys) {",
                    "  const detailedOptions = !keys",
                    "    ? context.detailedOptions",
                    "    : context.detailedOptions.filter(",
                    "        option => keys.indexOf(option.name) !== -1",
                    "      );",
                    "  const argv = !keys ? context.argv : pick(context.argv, keys);",
                    "",
                    "  context.argv = optionsNormalizer.normalizeCliOptions(argv, detailedOptions, {",
                    "    logger: context.logger",
                    "  });",
                    "}",
                    "//------------------------------context-util-end--------------------------------",
                    "",
                    "module.exports = {",
                    "  createContext,",
                    "  createDetailedOptionMap,",
                    "  createDetailedUsage,",
                    "  createUsage,",
                    "  format,",
                    "  formatFiles,",
                    "  formatStdin,",
                    "  initContext,",
                    "  logResolvedConfigPathOrDie,",
                    "  normalizeDetailedOptionMap",
                    "};"
                ]
            }
        },
        "common": {
            "clean-ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function cleanAST(ast, options) {",
                    "  return JSON.stringify(massageAST(ast, options), null, 2);",
                    "}",
                    "",
                    "function massageAST(ast, options, parent) {",
                    "  if (Array.isArray(ast)) {",
                    "    return ast.map(e => massageAST(e, options, parent)).filter(e => e);",
                    "  }",
                    "",
                    "  if (!ast || typeof ast !== \"object\") {",
                    "    return ast;",
                    "  }",
                    "",
                    "  const newObj = {};",
                    "  for (const key in ast) {",
                    "    if (typeof ast[key] !== \"function\") {",
                    "      newObj[key] = massageAST(ast[key], options, ast);",
                    "    }",
                    "  }",
                    "",
                    "  [",
                    "    \"loc\",",
                    "    \"range\",",
                    "    \"raw\",",
                    "    \"comments\",",
                    "    \"leadingComments\",",
                    "    \"trailingComments\",",
                    "    \"extra\",",
                    "    \"start\",",
                    "    \"end\",",
                    "    \"tokens\",",
                    "    \"flags\",",
                    "    \"raws\",",
                    "    \"sourceIndex\",",
                    "    \"id\",",
                    "    \"source\",",
                    "    \"before\",",
                    "    \"after\",",
                    "    \"trailingComma\",",
                    "    \"parent\",",
                    "    \"prev\",",
                    "    \"position\"",
                    "  ].forEach(name => {",
                    "    delete newObj[name];",
                    "  });",
                    "",
                    "  if (options.printer.massageAstNode) {",
                    "    const result = options.printer.massageAstNode(ast, newObj, parent);",
                    "    if (result === null) {",
                    "      return undefined;",
                    "    }",
                    "    if (result) {",
                    "      return result;",
                    "    }",
                    "  }",
                    "",
                    "  return newObj;",
                    "}",
                    "",
                    "module.exports = { cleanAST, massageAST };"
                ]
            },
            "errors.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "class ConfigError extends Error {}",
                    "class DebugError extends Error {}",
                    "",
                    "module.exports = {",
                    "  ConfigError,",
                    "  DebugError",
                    "};"
                ]
            },
            "fast-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "",
                    "function FastPath(value) {",
                    "  assert.ok(this instanceof FastPath);",
                    "  this.stack = [value];",
                    "}",
                    "",
                    "// The name of the current property is always the penultimate element of",
                    "// this.stack, and always a String.",
                    "FastPath.prototype.getName = function getName() {",
                    "  const s = this.stack;",
                    "  const len = s.length;",
                    "  if (len > 1) {",
                    "    return s[len - 2];",
                    "  }",
                    "  // Since the name is always a string, null is a safe sentinel value to",
                    "  // return if we do not know the name of the (root) value.",
                    "  /* istanbul ignore next */",
                    "  return null;",
                    "};",
                    "",
                    "// The value of the current property is always the final element of",
                    "// this.stack.",
                    "FastPath.prototype.getValue = function getValue() {",
                    "  const s = this.stack;",
                    "  return s[s.length - 1];",
                    "};",
                    "",
                    "function getNodeHelper(path, count) {",
                    "  const s = path.stack;",
                    "",
                    "  for (let i = s.length - 1; i >= 0; i -= 2) {",
                    "    const value = s[i];",
                    "",
                    "    if (value && !Array.isArray(value) && --count < 0) {",
                    "      return value;",
                    "    }",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "FastPath.prototype.getNode = function getNode(count) {",
                    "  return getNodeHelper(this, ~~count);",
                    "};",
                    "",
                    "FastPath.prototype.getParentNode = function getParentNode(count) {",
                    "  return getNodeHelper(this, ~~count + 1);",
                    "};",
                    "",
                    "// Temporarily push properties named by string arguments given after the",
                    "// callback function onto this.stack, then call the callback with a",
                    "// reference to this (modified) FastPath object. Note that the stack will",
                    "// be restored to its original state after the callback is finished, so it",
                    "// is probably a mistake to retain a reference to the path.",
                    "FastPath.prototype.call = function call(callback /*, name1, name2, ... */) {",
                    "  const s = this.stack;",
                    "  const origLen = s.length;",
                    "  let value = s[origLen - 1];",
                    "  const argc = arguments.length;",
                    "  for (let i = 1; i < argc; ++i) {",
                    "    const name = arguments[i];",
                    "    value = value[name];",
                    "    s.push(name, value);",
                    "  }",
                    "  const result = callback(this);",
                    "  s.length = origLen;",
                    "  return result;",
                    "};",
                    "",
                    "// Similar to FastPath.prototype.call, except that the value obtained by",
                    "// accessing this.getValue()[name1][name2]... should be array-like. The",
                    "// callback will be called with a reference to this path object for each",
                    "// element of the array.",
                    "FastPath.prototype.each = function each(callback /*, name1, name2, ... */) {",
                    "  const s = this.stack;",
                    "  const origLen = s.length;",
                    "  let value = s[origLen - 1];",
                    "  const argc = arguments.length;",
                    "",
                    "  for (let i = 1; i < argc; ++i) {",
                    "    const name = arguments[i];",
                    "    value = value[name];",
                    "    s.push(name, value);",
                    "  }",
                    "",
                    "  for (let i = 0; i < value.length; ++i) {",
                    "    if (i in value) {",
                    "      s.push(i, value[i]);",
                    "      // If the callback needs to know the value of i, call",
                    "      // path.getName(), assuming path is the parameter name.",
                    "      callback(this);",
                    "      s.length -= 2;",
                    "    }",
                    "  }",
                    "",
                    "  s.length = origLen;",
                    "};",
                    "",
                    "// Similar to FastPath.prototype.each, except that the results of the",
                    "// callback function invocations are stored in an array and returned at",
                    "// the end of the iteration.",
                    "FastPath.prototype.map = function map(callback /*, name1, name2, ... */) {",
                    "  const s = this.stack;",
                    "  const origLen = s.length;",
                    "  let value = s[origLen - 1];",
                    "  const argc = arguments.length;",
                    "",
                    "  for (let i = 1; i < argc; ++i) {",
                    "    const name = arguments[i];",
                    "    value = value[name];",
                    "    s.push(name, value);",
                    "  }",
                    "",
                    "  const result = new Array(value.length);",
                    "",
                    "  for (let i = 0; i < value.length; ++i) {",
                    "    if (i in value) {",
                    "      s.push(i, value[i]);",
                    "      result[i] = callback(this, i);",
                    "      s.length -= 2;",
                    "    }",
                    "  }",
                    "",
                    "  s.length = origLen;",
                    "",
                    "  return result;",
                    "};",
                    "",
                    "module.exports = FastPath;"
                ]
            },
            "load-plugins.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const resolve = require(\"resolve\");",
                    "const readPkgUp = require(\"read-pkg-up\");",
                    "",
                    "function loadPlugins(plugins) {",
                    "  plugins = plugins || [];",
                    "",
                    "  const internalPlugins = [",
                    "    require(\"../language-js\"),",
                    "    require(\"../language-css\"),",
                    "    require(\"../language-handlebars\"),",
                    "    require(\"../language-graphql\"),",
                    "    require(\"../language-markdown\"),",
                    "    require(\"../language-html\"),",
                    "    require(\"../language-vue\")",
                    "  ];",
                    "",
                    "  const externalPlugins = plugins",
                    "    .concat(",
                    "      getPluginsFromPackage(",
                    "        readPkgUp.sync({",
                    "          normalize: false",
                    "        }).pkg",
                    "      )",
                    "    )",
                    "    .map(plugin => {",
                    "      if (typeof plugin !== \"string\") {",
                    "        return plugin;",
                    "      }",
                    "",
                    "      const pluginPath = resolve.sync(plugin, { basedir: process.cwd() });",
                    "      return Object.assign({ name: plugin }, eval(\"require\")(pluginPath));",
                    "    });",
                    "",
                    "  return deduplicate(internalPlugins.concat(externalPlugins));",
                    "}",
                    "",
                    "function getPluginsFromPackage(pkg) {",
                    "  if (!pkg) {",
                    "    return [];",
                    "  }",
                    "  const deps = Object.assign({}, pkg.dependencies, pkg.devDependencies);",
                    "  return Object.keys(deps).filter(",
                    "    dep =>",
                    "      dep.startsWith(\"prettier-plugin-\") || dep.startsWith(\"@prettier/plugin-\")",
                    "  );",
                    "}",
                    "",
                    "function deduplicate(items) {",
                    "  const uniqItems = [];",
                    "  for (const item of items) {",
                    "    if (uniqItems.indexOf(item) < 0) {",
                    "      uniqItems.push(item);",
                    "    }",
                    "  }",
                    "  return uniqItems;",
                    "}",
                    "",
                    "module.exports = loadPlugins;"
                ]
            },
            "parser-create-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function createError(message, loc) {",
                    "  // Construct an error similar to the ones thrown by Babylon.",
                    "  const error = new SyntaxError(",
                    "    message + \" (\" + loc.start.line + \":\" + loc.start.column + \")\"",
                    "  );",
                    "  error.loc = loc;",
                    "  return error;",
                    "}",
                    "",
                    "module.exports = createError;"
                ]
            },
            "parser-include-shebang.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function includeShebang(text, ast) {",
                    "  if (!text.startsWith(\"#!\")) {",
                    "    return;",
                    "  }",
                    "",
                    "  const index = text.indexOf(\"\\n\");",
                    "  const shebang = text.slice(2, index);",
                    "  const comment = {",
                    "    type: \"Line\",",
                    "    value: shebang,",
                    "    range: [0, index],",
                    "    loc: {",
                    "      source: null,",
                    "      start: {",
                    "        line: 1,",
                    "        column: 0",
                    "      },",
                    "      end: {",
                    "        line: 1,",
                    "        column: index",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  ast.comments = [comment].concat(ast.comments);",
                    "}",
                    "",
                    "module.exports = includeShebang;"
                ]
            },
            "support.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const util = require(\"./util\");",
                    "const dedent = require(\"dedent\");",
                    "const semver = require(\"semver\");",
                    "const currentVersion = require(\"../../package.json\").version;",
                    "const loadPlugins = require(\"./load-plugins\");",
                    "const cliConstant = require(\"../cli/constant\");",
                    "",
                    "const CATEGORY_GLOBAL = \"Global\";",
                    "const CATEGORY_SPECIAL = \"Special\";",
                    "",
                    "/**",
                    " * @typedef {Object} OptionInfo",
                    " * @property {string} since - available since version",
                    " * @property {string} category",
                    " * @property {'int' | 'boolean' | 'choice' | 'path'} type",
                    " * @property {boolean} array - indicate it's an array of the specified type",
                    " * @property {boolean?} deprecated - deprecated since version",
                    " * @property {OptionRedirectInfo?} redirect - redirect deprecated option",
                    " * @property {string} description",
                    " * @property {string?} oppositeDescription - for `false` option",
                    " * @property {OptionValueInfo} default",
                    " * @property {OptionRangeInfo?} range - for type int",
                    " * @property {OptionChoiceInfo?} choices - for type choice",
                    " * @property {(value: any) => boolean} exception",
                    " *",
                    " * @typedef {number | boolean | string} OptionValue",
                    " * @typedef {OptionValue | [{ value: OptionValue[] }] | Array<{ since: string, value: OptionValue}>} OptionValueInfo",
                    " *",
                    " * @typedef {Object} OptionRedirectInfo",
                    " * @property {string} option",
                    " * @property {OptionValue} value",
                    " *",
                    " * @typedef {Object} OptionRangeInfo",
                    " * @property {number} start - recommended range start",
                    " * @property {number} end - recommended range end",
                    " * @property {number} step - recommended range step",
                    " *",
                    " * @typedef {Object} OptionChoiceInfo",
                    " * @property {boolean | string} value - boolean for the option that is originally boolean type",
                    " * @property {string?} description - undefined if redirect",
                    " * @property {string?} since - undefined if available since the first version of the option",
                    " * @property {string?} deprecated - deprecated since version",
                    " * @property {OptionValueInfo?} redirect - redirect deprecated value",
                    " *",
                    " * @property {string?} cliName",
                    " * @property {string?} cliCategory",
                    " * @property {string?} cliDescription",
                    " */",
                    "/** @type {{ [name: string]: OptionInfo } */",
                    "const supportOptions = {",
                    "  cursorOffset: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: -1,",
                    "    range: { start: -1, end: Infinity, step: 1 },",
                    "    description: dedent`",
                    "      Print (to stderr) where a cursor at the given position would move to after formatting.",
                    "      This option cannot be used with --range-start and --range-end.",
                    "    `,",
                    "    cliCategory: cliConstant.CATEGORY_EDITOR",
                    "  },",
                    "  filepath: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"path\",",
                    "    default: undefined,",
                    "    description:",
                    "      \"Specify the input filepath. This will be used to do parser inference.\",",
                    "    cliName: \"stdin-filepath\",",
                    "    cliCategory: cliConstant.CATEGORY_OTHER,",
                    "    cliDescription: \"Path to the file to pretend that stdin comes from.\"",
                    "  },",
                    "  insertPragma: {",
                    "    since: \"1.8.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Insert @format pragma into file's first docblock comment.\",",
                    "    cliCategory: cliConstant.CATEGORY_OTHER",
                    "  },",
                    "  parser: {",
                    "    since: \"0.0.10\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: \"babylon\",",
                    "    description: \"Which parser to use.\",",
                    "    exception: value =>",
                    "      typeof value === \"string\" || typeof value === \"function\",",
                    "    choices: [",
                    "      { value: \"flow\", description: \"Flow\" },",
                    "      { value: \"babylon\", description: \"JavaScript\" },",
                    "      { value: \"typescript\", since: \"1.4.0\", description: \"TypeScript\" },",
                    "      { value: \"css\", since: \"1.7.1\", description: \"CSS\" },",
                    "      {",
                    "        value: \"postcss\",",
                    "        since: \"1.4.0\",",
                    "        description: \"CSS/Less/SCSS\",",
                    "        deprecated: \"1.7.1\",",
                    "        redirect: \"css\"",
                    "      },",
                    "      { value: \"less\", since: \"1.7.1\", description: \"Less\" },",
                    "      { value: \"scss\", since: \"1.7.1\", description: \"SCSS\" },",
                    "      { value: \"json\", since: \"1.5.0\", description: \"JSON\" },",
                    "      { value: \"graphql\", since: \"1.5.0\", description: \"GraphQL\" },",
                    "      { value: \"markdown\", since: \"1.8.0\", description: \"Markdown\" },",
                    "      { value: \"vue\", since: \"1.10.0\", description: \"Vue\" }",
                    "    ]",
                    "  },",
                    "  plugins: {",
                    "    since: \"1.10.0\",",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description:",
                    "      \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",",
                    "    exception: value => typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin\",",
                    "    cliCategory: cliConstant.CATEGORY_CONFIG",
                    "  },",
                    "  printWidth: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"int\",",
                    "    default: 80,",
                    "    description: \"The line length where Prettier will try wrap.\",",
                    "    range: { start: 0, end: Infinity, step: 1 }",
                    "  },",
                    "  rangeEnd: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: Infinity,",
                    "    range: { start: 0, end: Infinity, step: 1 },",
                    "    description: dedent`",
                    "      Format code ending at a given character offset (exclusive).",
                    "      The range will extend forwards to the end of the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: cliConstant.CATEGORY_EDITOR",
                    "  },",
                    "  rangeStart: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: 0,",
                    "    range: { start: 0, end: Infinity, step: 1 },",
                    "    description: dedent`",
                    "      Format code starting at a given character offset.",
                    "      The range will extend backwards to the start of the first line containing the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: cliConstant.CATEGORY_EDITOR",
                    "  },",
                    "  requirePragma: {",
                    "    since: \"1.7.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: dedent`",
                    "      Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                    "      in order for it to be formatted.",
                    "    `,",
                    "    cliCategory: cliConstant.CATEGORY_OTHER",
                    "  },",
                    "  tabWidth: {",
                    "    type: \"int\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    default: 2,",
                    "    description: \"Number of spaces per indentation level.\",",
                    "    range: { start: 0, end: Infinity, step: 1 }",
                    "  },",
                    "  useFlowParser: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    deprecated: \"0.0.10\",",
                    "    description: \"Use flow parser.\",",
                    "    redirect: { option: \"parser\", value: \"flow\" },",
                    "    cliName: \"flow-parser\"",
                    "  },",
                    "  useTabs: {",
                    "    since: \"1.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent with tabs instead of spaces.\"",
                    "  }",
                    "};",
                    "",
                    "function getSupportInfo(version, opts) {",
                    "  opts = Object.assign(",
                    "    {",
                    "      plugins: [],",
                    "      pluginsLoaded: false,",
                    "      showUnreleased: false,",
                    "      showDeprecated: false,",
                    "      showInternal: false",
                    "    },",
                    "    opts",
                    "  );",
                    "",
                    "  if (!version) {",
                    "    version = currentVersion;",
                    "  }",
                    "",
                    "  const plugins = opts.pluginsLoaded ? opts.plugins : loadPlugins(opts.plugins);",
                    "",
                    "  const options = util",
                    "    .arrayify(",
                    "      Object.assign(",
                    "        plugins.reduce(",
                    "          (currentOptions, plugin) =>",
                    "            Object.assign(currentOptions, plugin.options),",
                    "          {}",
                    "        ),",
                    "        supportOptions",
                    "      ),",
                    "      \"name\"",
                    "    )",
                    "    .sort((a, b) => (a.name === b.name ? 0 : a.name < b.name ? -1 : 1))",
                    "    .filter(filterSince)",
                    "    .filter(filterDeprecated)",
                    "    .map(mapDeprecated)",
                    "    .map(mapInternal)",
                    "    .map(option => {",
                    "      const newOption = Object.assign({}, option);",
                    "",
                    "      if (Array.isArray(newOption.default)) {",
                    "        newOption.default =",
                    "          newOption.default.length === 1",
                    "            ? newOption.default[0].value",
                    "            : newOption.default",
                    "                .filter(filterSince)",
                    "                .sort((info1, info2) =>",
                    "                  semver.compare(info2.since, info1.since)",
                    "                )[0].value;",
                    "      }",
                    "",
                    "      if (Array.isArray(newOption.choices)) {",
                    "        newOption.choices = newOption.choices",
                    "          .filter(filterSince)",
                    "          .filter(filterDeprecated)",
                    "          .map(mapDeprecated);",
                    "      }",
                    "",
                    "      return newOption;",
                    "    })",
                    "    .map(option => {",
                    "      const filteredPlugins = plugins.filter(",
                    "        plugin => plugin.defaultOptions && plugin.defaultOptions[option.name]",
                    "      );",
                    "      const pluginDefaults = filteredPlugins.reduce((reduced, plugin) => {",
                    "        reduced[plugin.name] = plugin.defaultOptions[option.name];",
                    "        return reduced;",
                    "      }, {});",
                    "      return Object.assign(option, { pluginDefaults });",
                    "    });",
                    "",
                    "  const usePostCssParser = semver.lt(version, \"1.7.1\");",
                    "",
                    "  const languages = plugins",
                    "    .reduce((all, plugin) => all.concat(plugin.languages), [])",
                    "    .filter(",
                    "      language =>",
                    "        language.since",
                    "          ? semver.gte(version, language.since)",
                    "          : language.since !== null",
                    "    )",
                    "    .map(language => {",
                    "      // Prevent breaking changes",
                    "      if (language.name === \"Markdown\") {",
                    "        return Object.assign({}, language, {",
                    "          parsers: [\"markdown\"]",
                    "        });",
                    "      }",
                    "      if (language.name === \"TypeScript\") {",
                    "        return Object.assign({}, language, {",
                    "          parsers: [\"typescript\"]",
                    "        });",
                    "      }",
                    "",
                    "      if (usePostCssParser && language.group === \"CSS\") {",
                    "        return Object.assign({}, language, {",
                    "          parsers: [\"postcss\"]",
                    "        });",
                    "      }",
                    "      return language;",
                    "    });",
                    "",
                    "  return { languages, options };",
                    "",
                    "  function filterSince(object) {",
                    "    return (",
                    "      opts.showUnreleased ||",
                    "      !(\"since\" in object) ||",
                    "      (object.since && semver.gte(version, object.since))",
                    "    );",
                    "  }",
                    "  function filterDeprecated(object) {",
                    "    return (",
                    "      opts.showDeprecated ||",
                    "      !(\"deprecated\" in object) ||",
                    "      (object.deprecated && semver.lt(version, object.deprecated))",
                    "    );",
                    "  }",
                    "  function mapDeprecated(object) {",
                    "    if (!object.deprecated || opts.showDeprecated) {",
                    "      return object;",
                    "    }",
                    "    const newObject = Object.assign({}, object);",
                    "    delete newObject.deprecated;",
                    "    delete newObject.redirect;",
                    "    return newObject;",
                    "  }",
                    "  function mapInternal(object) {",
                    "    if (opts.showInternal) {",
                    "      return object;",
                    "    }",
                    "    const newObject = Object.assign({}, object);",
                    "    delete newObject.cliName;",
                    "    delete newObject.cliCategory;",
                    "    delete newObject.cliDescription;",
                    "    return newObject;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  getSupportInfo",
                    "};"
                ]
            },
            "third-party.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getStream = require(\"get-stream\");",
                    "const cosmiconfig = require(\"cosmiconfig\");",
                    "",
                    "module.exports = {",
                    "  getStream,",
                    "  cosmiconfig",
                    "};"
                ]
            },
            "util-shared.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const util = require(\"./util\");",
                    "",
                    "function isNextLineEmpty(text, node, options) {",
                    "  return util.isNextLineEmpty(text, node, options.locEnd);",
                    "}",
                    "",
                    "function getNextNonSpaceNonCommentCharacterIndex(text, node, options) {",
                    "  return util.getNextNonSpaceNonCommentCharacterIndex(",
                    "    text,",
                    "    node,",
                    "    options.locEnd",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  isNextLineEmpty,",
                    "  isNextLineEmptyAfterIndex: util.isNextLineEmptyAfterIndex,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  mapDoc: util.mapDoc,",
                    "  makeString: util.makeString,",
                    "  addLeadingComment: util.addLeadingComment,",
                    "  addDanglingComment: util.addDanglingComment,",
                    "  addTrailingComment: util.addTrailingComment",
                    "};"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const stringWidth = require(\"string-width\");",
                    "const emojiRegex = require(\"emoji-regex\")();",
                    "const escapeStringRegexp = require(\"escape-string-regexp\");",
                    "const getCjkRegex = require(\"cjk-regex\");",
                    "const getUnicodeRegex = require(\"unicode-regex\");",
                    "",
                    "const cjkPattern = getCjkRegex().source;",
                    "",
                    "// http://spec.commonmark.org/0.25/#ascii-punctuation-character",
                    "const asciiPunctuationCharRange = escapeStringRegexp(",
                    "  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"",
                    ");",
                    "",
                    "// http://spec.commonmark.org/0.25/#punctuation-character",
                    "const punctuationCharRange = `${asciiPunctuationCharRange}${getUnicodeRegex([",
                    "  \"Pc\",",
                    "  \"Pd\",",
                    "  \"Pe\",",
                    "  \"Pf\",",
                    "  \"Pi\",",
                    "  \"Po\",",
                    "  \"Ps\"",
                    "]).source.slice(1, -1)}`; // remove bracket expression `[` and `]`",
                    "",
                    "const punctuationRegex = new RegExp(`[${punctuationCharRange}]`);",
                    "",
                    "function isExportDeclaration(node) {",
                    "  if (node) {",
                    "    switch (node.type) {",
                    "      case \"ExportDefaultDeclaration\":",
                    "      case \"ExportDefaultSpecifier\":",
                    "      case \"DeclareExportDeclaration\":",
                    "      case \"ExportNamedDeclaration\":",
                    "      case \"ExportAllDeclaration\":",
                    "        return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function getParentExportDeclaration(path) {",
                    "  const parentNode = path.getParentNode();",
                    "  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {",
                    "    return parentNode;",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function getPenultimate(arr) {",
                    "  if (arr.length > 1) {",
                    "    return arr[arr.length - 2];",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function getLast(arr) {",
                    "  if (arr.length > 0) {",
                    "    return arr[arr.length - 1];",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function skip(chars) {",
                    "  return (text, index, opts) => {",
                    "    const backwards = opts && opts.backwards;",
                    "",
                    "    // Allow `skip` functions to be threaded together without having",
                    "    // to check for failures (did someone say monads?).",
                    "    if (index === false) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const length = text.length;",
                    "    let cursor = index;",
                    "    while (cursor >= 0 && cursor < length) {",
                    "      const c = text.charAt(cursor);",
                    "      if (chars instanceof RegExp) {",
                    "        if (!chars.test(c)) {",
                    "          return cursor;",
                    "        }",
                    "      } else if (chars.indexOf(c) === -1) {",
                    "        return cursor;",
                    "      }",
                    "",
                    "      backwards ? cursor-- : cursor++;",
                    "    }",
                    "",
                    "    if (cursor === -1 || cursor === length) {",
                    "      // If we reached the beginning or end of the file, return the",
                    "      // out-of-bounds cursor. It's up to the caller to handle this",
                    "      // correctly. We don't want to indicate `false` though if it",
                    "      // actually skipped valid characters.",
                    "      return cursor;",
                    "    }",
                    "    return false;",
                    "  };",
                    "}",
                    "",
                    "const skipWhitespace = skip(/\\s/);",
                    "const skipSpaces = skip(\" \\t\");",
                    "const skipToLineEnd = skip(\",; \\t\");",
                    "const skipEverythingButNewLine = skip(/[^\\r\\n]/);",
                    "",
                    "function skipInlineComment(text, index) {",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {",
                    "    for (let i = index + 2; i < text.length; ++i) {",
                    "      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {",
                    "        return i + 2;",
                    "      }",
                    "    }",
                    "  }",
                    "  return index;",
                    "}",
                    "",
                    "function skipTrailingComment(text, index) {",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {",
                    "    return skipEverythingButNewLine(text, index);",
                    "  }",
                    "  return index;",
                    "}",
                    "",
                    "// This one doesn't use the above helper function because it wants to",
                    "// test \\r\\n in order and `skip` doesn't support ordering and we only",
                    "// want to skip one newline. It's simple to implement.",
                    "function skipNewline(text, index, opts) {",
                    "  const backwards = opts && opts.backwards;",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const atIndex = text.charAt(index);",
                    "  if (backwards) {",
                    "    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {",
                    "      return index - 2;",
                    "    }",
                    "    if (",
                    "      atIndex === \"\\n\" ||",
                    "      atIndex === \"\\r\" ||",
                    "      atIndex === \"\\u2028\" ||",
                    "      atIndex === \"\\u2029\"",
                    "    ) {",
                    "      return index - 1;",
                    "    }",
                    "  } else {",
                    "    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {",
                    "      return index + 2;",
                    "    }",
                    "    if (",
                    "      atIndex === \"\\n\" ||",
                    "      atIndex === \"\\r\" ||",
                    "      atIndex === \"\\u2028\" ||",
                    "      atIndex === \"\\u2029\"",
                    "    ) {",
                    "      return index + 1;",
                    "    }",
                    "  }",
                    "",
                    "  return index;",
                    "}",
                    "",
                    "function hasNewline(text, index, opts) {",
                    "  opts = opts || {};",
                    "  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);",
                    "  const idx2 = skipNewline(text, idx, opts);",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "function hasNewlineInRange(text, start, end) {",
                    "  for (let i = start; i < end; ++i) {",
                    "    if (text.charAt(i) === \"\\n\") {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "// Note: this function doesn't ignore leading comments unlike isNextLineEmpty",
                    "function isPreviousLineEmpty(text, node, locStart) {",
                    "  let idx = locStart(node) - 1;",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  idx = skipNewline(text, idx, { backwards: true });",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  const idx2 = skipNewline(text, idx, { backwards: true });",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "function isNextLineEmptyAfterIndex(text, index) {",
                    "  let oldIdx = null;",
                    "  let idx = index;",
                    "  while (idx !== oldIdx) {",
                    "    // We need to skip all the potential trailing inline comments",
                    "    oldIdx = idx;",
                    "    idx = skipToLineEnd(text, idx);",
                    "    idx = skipInlineComment(text, idx);",
                    "    idx = skipSpaces(text, idx);",
                    "  }",
                    "  idx = skipTrailingComment(text, idx);",
                    "  idx = skipNewline(text, idx);",
                    "  return hasNewline(text, idx);",
                    "}",
                    "",
                    "function isNextLineEmpty(text, node, locEnd) {",
                    "  return isNextLineEmptyAfterIndex(text, locEnd(node));",
                    "}",
                    "",
                    "function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {",
                    "  let oldIdx = null;",
                    "  let idx = locEnd(node);",
                    "  while (idx !== oldIdx) {",
                    "    oldIdx = idx;",
                    "    idx = skipSpaces(text, idx);",
                    "    idx = skipInlineComment(text, idx);",
                    "    idx = skipTrailingComment(text, idx);",
                    "    idx = skipNewline(text, idx);",
                    "  }",
                    "  return idx;",
                    "}",
                    "",
                    "function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {",
                    "  return text.charAt(",
                    "    getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd)",
                    "  );",
                    "}",
                    "",
                    "function hasSpaces(text, index, opts) {",
                    "  opts = opts || {};",
                    "  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);",
                    "  return idx !== index;",
                    "}",
                    "",
                    "// Super inefficient, needs to be cached.",
                    "function lineColumnToIndex(lineColumn, text) {",
                    "  let index = 0;",
                    "  for (let i = 0; i < lineColumn.line - 1; ++i) {",
                    "    index = text.indexOf(\"\\n\", index) + 1;",
                    "    if (index === -1) {",
                    "      return -1;",
                    "    }",
                    "  }",
                    "  return index + lineColumn.column;",
                    "}",
                    "",
                    "function setLocStart(node, index) {",
                    "  if (node.range) {",
                    "    node.range[0] = index;",
                    "  } else {",
                    "    node.start = index;",
                    "  }",
                    "}",
                    "",
                    "function setLocEnd(node, index) {",
                    "  if (node.range) {",
                    "    node.range[1] = index;",
                    "  } else {",
                    "    node.end = index;",
                    "  }",
                    "}",
                    "",
                    "const PRECEDENCE = {};",
                    "[",
                    "  [\"|>\"],",
                    "  [\"||\", \"??\"],",
                    "  [\"&&\"],",
                    "  [\"|\"],",
                    "  [\"^\"],",
                    "  [\"&\"],",
                    "  [\"==\", \"===\", \"!=\", \"!==\"],",
                    "  [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],",
                    "  [\">>\", \"<<\", \">>>\"],",
                    "  [\"+\", \"-\"],",
                    "  [\"*\", \"/\", \"%\"],",
                    "  [\"**\"]",
                    "].forEach((tier, i) => {",
                    "  tier.forEach(op => {",
                    "    PRECEDENCE[op] = i;",
                    "  });",
                    "});",
                    "",
                    "function getPrecedence(op) {",
                    "  return PRECEDENCE[op];",
                    "}",
                    "",
                    "const equalityOperators = {",
                    "  \"==\": true,",
                    "  \"!=\": true,",
                    "  \"===\": true,",
                    "  \"!==\": true",
                    "};",
                    "const multiplicativeOperators = {",
                    "  \"*\": true,",
                    "  \"/\": true,",
                    "  \"%\": true",
                    "};",
                    "const bitshiftOperators = {",
                    "  \">>\": true,",
                    "  \">>>\": true,",
                    "  \"<<\": true",
                    "};",
                    "",
                    "function shouldFlatten(parentOp, nodeOp) {",
                    "  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // ** is right-associative",
                    "  // x ** y ** z --> x ** (y ** z)",
                    "  if (parentOp === \"**\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  // x == y == z --> (x == y) == z",
                    "  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // x * y % z --> (x * y) % z",
                    "  if (",
                    "    (nodeOp === \"%\" && multiplicativeOperators[parentOp]) ||",
                    "    (parentOp === \"%\" && multiplicativeOperators[nodeOp])",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // x << y << z --> (x << y) << z",
                    "  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function isBitwiseOperator(operator) {",
                    "  return (",
                    "    !!bitshiftOperators[operator] ||",
                    "    operator === \"|\" ||",
                    "    operator === \"^\" ||",
                    "    operator === \"&\"",
                    "  );",
                    "}",
                    "",
                    "// Tests if an expression starts with `{`, or (if forbidFunctionAndClass holds) `function` or `class`.",
                    "// Will be overzealous if there's already necessary grouping parentheses.",
                    "function startsWithNoLookaheadToken(node, forbidFunctionAndClass) {",
                    "  node = getLeftMost(node);",
                    "  switch (node.type) {",
                    "    // Hack. Remove after https://github.com/eslint/typescript-eslint-parser/issues/331",
                    "    case \"ObjectPattern\":",
                    "      return !forbidFunctionAndClass;",
                    "    case \"FunctionExpression\":",
                    "    case \"ClassExpression\":",
                    "      return forbidFunctionAndClass;",
                    "    case \"ObjectExpression\":",
                    "      return true;",
                    "    case \"MemberExpression\":",
                    "      return startsWithNoLookaheadToken(node.object, forbidFunctionAndClass);",
                    "    case \"TaggedTemplateExpression\":",
                    "      if (node.tag.type === \"FunctionExpression\") {",
                    "        // IIFEs are always already parenthesized",
                    "        return false;",
                    "      }",
                    "      return startsWithNoLookaheadToken(node.tag, forbidFunctionAndClass);",
                    "    case \"CallExpression\":",
                    "      if (node.callee.type === \"FunctionExpression\") {",
                    "        // IIFEs are always already parenthesized",
                    "        return false;",
                    "      }",
                    "      return startsWithNoLookaheadToken(node.callee, forbidFunctionAndClass);",
                    "    case \"ConditionalExpression\":",
                    "      return startsWithNoLookaheadToken(node.test, forbidFunctionAndClass);",
                    "    case \"UpdateExpression\":",
                    "      return (",
                    "        !node.prefix &&",
                    "        startsWithNoLookaheadToken(node.argument, forbidFunctionAndClass)",
                    "      );",
                    "    case \"BindExpression\":",
                    "      return (",
                    "        node.object &&",
                    "        startsWithNoLookaheadToken(node.object, forbidFunctionAndClass)",
                    "      );",
                    "    case \"SequenceExpression\":",
                    "      return startsWithNoLookaheadToken(",
                    "        node.expressions[0],",
                    "        forbidFunctionAndClass",
                    "      );",
                    "    case \"TSAsExpression\":",
                    "      return startsWithNoLookaheadToken(",
                    "        node.expression,",
                    "        forbidFunctionAndClass",
                    "      );",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function getLeftMost(node) {",
                    "  if (node.left) {",
                    "    return getLeftMost(node.left);",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function hasBlockComments(node) {",
                    "  return node.comments && node.comments.some(isBlockComment);",
                    "}",
                    "",
                    "function isBlockComment(comment) {",
                    "  return comment.type === \"Block\" || comment.type === \"CommentBlock\";",
                    "}",
                    "",
                    "function hasClosureCompilerTypeCastComment(text, node, locEnd) {",
                    "  // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts",
                    "  // Syntax example: var x = /** @type {string} */ (fruit);",
                    "  return (",
                    "    node.comments &&",
                    "    node.comments.some(",
                    "      comment =>",
                    "        comment.leading &&",
                    "        isBlockComment(comment) &&",
                    "        comment.value.match(/^\\*\\s*@type\\s*{[^}]+}\\s*$/) &&",
                    "        getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === \"(\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function getAlignmentSize(value, tabWidth, startIndex) {",
                    "  startIndex = startIndex || 0;",
                    "",
                    "  let size = 0;",
                    "  for (let i = startIndex; i < value.length; ++i) {",
                    "    if (value[i] === \"\\t\") {",
                    "      // Tabs behave in a way that they are aligned to the nearest",
                    "      // multiple of tabWidth:",
                    "      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4",
                    "      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...",
                    "      size = size + tabWidth - size % tabWidth;",
                    "    } else {",
                    "      size++;",
                    "    }",
                    "  }",
                    "",
                    "  return size;",
                    "}",
                    "",
                    "function getIndentSize(value, tabWidth) {",
                    "  const lastNewlineIndex = value.lastIndexOf(\"\\n\");",
                    "  if (lastNewlineIndex === -1) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return getAlignmentSize(",
                    "    // All the leading whitespaces",
                    "    value.slice(lastNewlineIndex + 1).match(/^[ \\t]*/)[0],",
                    "    tabWidth",
                    "  );",
                    "}",
                    "",
                    "function printString(raw, options, isDirectiveLiteral) {",
                    "  // `rawContent` is the string exactly like it appeared in the input source",
                    "  // code, without its enclosing quotes.",
                    "  const rawContent = raw.slice(1, -1);",
                    "",
                    "  const double = { quote: '\"', regex: /\"/g };",
                    "  const single = { quote: \"'\", regex: /'/g };",
                    "",
                    "  const preferred = options.singleQuote ? single : double;",
                    "  const alternate = preferred === single ? double : single;",
                    "",
                    "  let shouldUseAlternateQuote = false;",
                    "  let canChangeDirectiveQuotes = false;",
                    "",
                    "  // If `rawContent` contains at least one of the quote preferred for enclosing",
                    "  // the string, we might want to enclose with the alternate quote instead, to",
                    "  // minimize the number of escaped quotes.",
                    "  // Also check for the alternate quote, to determine if we're allowed to swap",
                    "  // the quotes on a DirectiveLiteral.",
                    "  if (",
                    "    rawContent.includes(preferred.quote) ||",
                    "    rawContent.includes(alternate.quote)",
                    "  ) {",
                    "    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;",
                    "    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;",
                    "",
                    "    shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;",
                    "  } else {",
                    "    canChangeDirectiveQuotes = true;",
                    "  }",
                    "",
                    "  const enclosingQuote =",
                    "    options.parser === \"json\"",
                    "      ? double.quote",
                    "      : shouldUseAlternateQuote ? alternate.quote : preferred.quote;",
                    "",
                    "  // Directives are exact code unit sequences, which means that you can't",
                    "  // change the escape sequences they use.",
                    "  // See https://github.com/prettier/prettier/issues/1555",
                    "  // and https://tc39.github.io/ecma262/#directive-prologue",
                    "  if (isDirectiveLiteral) {",
                    "    if (canChangeDirectiveQuotes) {",
                    "      return enclosingQuote + rawContent + enclosingQuote;",
                    "    }",
                    "    return raw;",
                    "  }",
                    "",
                    "  // It might sound unnecessary to use `makeString` even if the string already",
                    "  // is enclosed with `enclosingQuote`, but it isn't. The string could contain",
                    "  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes",
                    "  // sure that we consistently output the minimum amount of escaped quotes.",
                    "  return makeString(",
                    "    rawContent,",
                    "    enclosingQuote,",
                    "    !(",
                    "      options.parser === \"css\" ||",
                    "      options.parser === \"less\" ||",
                    "      options.parser === \"scss\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {",
                    "  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';",
                    "",
                    "  // Matches _any_ escape and unescaped quotes (both single and double).",
                    "  const regex = /\\\\([\\s\\S])|(['\"])/g;",
                    "",
                    "  // Escape and unescape single and double quotes as needed to be able to",
                    "  // enclose `rawContent` with `enclosingQuote`.",
                    "  const newContent = rawContent.replace(regex, (match, escaped, quote) => {",
                    "    // If we matched an escape, and the escaped character is a quote of the",
                    "    // other type than we intend to enclose the string with, there's no need for",
                    "    // it to be escaped, so return it _without_ the backslash.",
                    "    if (escaped === otherQuote) {",
                    "      return escaped;",
                    "    }",
                    "",
                    "    // If we matched an unescaped quote and it is of the _same_ type as we",
                    "    // intend to enclose the string with, it must be escaped, so return it with",
                    "    // a backslash.",
                    "    if (quote === enclosingQuote) {",
                    "      return \"\\\\\" + quote;",
                    "    }",
                    "",
                    "    if (quote) {",
                    "      return quote;",
                    "    }",
                    "",
                    "    // Unescape any unnecessarily escaped character.",
                    "    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27",
                    "    return unescapeUnnecessaryEscapes &&",
                    "      /^[^\\\\nrvtbfux\\r\\n\\u2028\\u2029\"'0-7]$/.test(escaped)",
                    "      ? escaped",
                    "      : \"\\\\\" + escaped;",
                    "  });",
                    "",
                    "  return enclosingQuote + newContent + enclosingQuote;",
                    "}",
                    "",
                    "function printNumber(rawNumber) {",
                    "  return (",
                    "    rawNumber",
                    "      .toLowerCase()",
                    "      // Remove unnecessary plus and zeroes from scientific notation.",
                    "      .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\")",
                    "      // Remove unnecessary scientific notation (1e0).",
                    "      .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\")",
                    "      // Make sure numbers always start with a digit.",
                    "      .replace(/^([+-])?\\./, \"$10.\")",
                    "      // Remove extraneous trailing decimal zeroes.",
                    "      .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\")",
                    "      // Remove trailing dot.",
                    "      .replace(/\\.(?=e|$)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "function getMaxContinuousCount(str, target) {",
                    "  const results = str.match(",
                    "    new RegExp(`(${escapeStringRegexp(target)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (results === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return results.reduce(",
                    "    (maxCount, result) => Math.max(maxCount, result.length / target.length),",
                    "    0",
                    "  );",
                    "}",
                    "",
                    "function mapDoc(doc, callback) {",
                    "  if (doc.parts) {",
                    "    const parts = doc.parts.map(part => mapDoc(part, callback));",
                    "    return callback(Object.assign({}, doc, { parts }));",
                    "  }",
                    "",
                    "  if (doc.contents) {",
                    "    const contents = mapDoc(doc.contents, callback);",
                    "    return callback(Object.assign({}, doc, { contents }));",
                    "  }",
                    "",
                    "  return callback(doc);",
                    "}",
                    "",
                    "/**",
                    " * split text into whitespaces and words",
                    " * @param {string} text",
                    " * @return {Array<{ type: \"whitespace\", value: \" \" | \"\\n\" | \"\" } | { type: \"word\", value: string }>}",
                    " */",
                    "function splitText(text) {",
                    "  const KIND_NON_CJK = \"non-cjk\";",
                    "  const KIND_CJK_CHARACTER = \"cjk-character\";",
                    "  const KIND_CJK_PUNCTUATION = \"cjk-punctuation\";",
                    "",
                    "  const nodes = [];",
                    "",
                    "  text",
                    "    .replace(new RegExp(`(${cjkPattern})\\n(${cjkPattern})`, \"g\"), \"$1$2\")",
                    "    .split(/([ \\t\\n]+)/)",
                    "    .forEach((token, index, tokens) => {",
                    "      // whitespace",
                    "      if (index % 2 === 1) {",
                    "        nodes.push({",
                    "          type: \"whitespace\",",
                    "          value: /\\n/.test(token) ? \"\\n\" : \" \"",
                    "        });",
                    "        return;",
                    "      }",
                    "",
                    "      // word separated by whitespace",
                    "",
                    "      if ((index === 0 || index === tokens.length - 1) && token === \"\") {",
                    "        return;",
                    "      }",
                    "",
                    "      token",
                    "        .split(new RegExp(`(${cjkPattern})`))",
                    "        .forEach((innerToken, innerIndex, innerTokens) => {",
                    "          if (",
                    "            (innerIndex === 0 || innerIndex === innerTokens.length - 1) &&",
                    "            innerToken === \"\"",
                    "          ) {",
                    "            return;",
                    "          }",
                    "",
                    "          // non-CJK word",
                    "          if (innerIndex % 2 === 0) {",
                    "            if (innerToken !== \"\") {",
                    "              appendNode({",
                    "                type: \"word\",",
                    "                value: innerToken,",
                    "                kind: KIND_NON_CJK,",
                    "                hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),",
                    "                hasTrailingPunctuation: punctuationRegex.test(",
                    "                  getLast(innerToken)",
                    "                )",
                    "              });",
                    "            }",
                    "            return;",
                    "          }",
                    "",
                    "          // CJK character",
                    "          appendNode(",
                    "            punctuationRegex.test(innerToken)",
                    "              ? {",
                    "                  type: \"word\",",
                    "                  value: innerToken,",
                    "                  kind: KIND_CJK_PUNCTUATION,",
                    "                  hasLeadingPunctuation: true,",
                    "                  hasTrailingPunctuation: true",
                    "                }",
                    "              : {",
                    "                  type: \"word\",",
                    "                  value: innerToken,",
                    "                  kind: KIND_CJK_CHARACTER,",
                    "                  hasLeadingPunctuation: false,",
                    "                  hasTrailingPunctuation: false",
                    "                }",
                    "          );",
                    "        });",
                    "    });",
                    "",
                    "  return nodes;",
                    "",
                    "  function appendNode(node) {",
                    "    const lastNode = getLast(nodes);",
                    "    if (lastNode && lastNode.type === \"word\") {",
                    "      if (",
                    "        (lastNode.kind === KIND_NON_CJK &&",
                    "          node.kind === KIND_CJK_CHARACTER &&",
                    "          !lastNode.hasTrailingPunctuation) ||",
                    "        (lastNode.kind === KIND_CJK_CHARACTER &&",
                    "          node.kind === KIND_NON_CJK &&",
                    "          !node.hasLeadingPunctuation)",
                    "      ) {",
                    "        nodes.push({ type: \"whitespace\", value: \" \" });",
                    "      } else if (",
                    "        !isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) &&",
                    "        // disallow leading/trailing full-width whitespace",
                    "        ![lastNode.value, node.value].some(value => /\\u3000/.test(value))",
                    "      ) {",
                    "        nodes.push({ type: \"whitespace\", value: \"\" });",
                    "      }",
                    "    }",
                    "    nodes.push(node);",
                    "",
                    "    function isBetween(kind1, kind2) {",
                    "      return (",
                    "        (lastNode.kind === kind1 && node.kind === kind2) ||",
                    "        (lastNode.kind === kind2 && node.kind === kind1)",
                    "      );",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getStringWidth(text) {",
                    "  if (!text) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  // emojis are considered 2-char width for consistency",
                    "  // see https://github.com/sindresorhus/string-width/issues/11",
                    "  // for the reason why not implemented in `string-width`",
                    "  return stringWidth(text.replace(emojiRegex, \"  \"));",
                    "}",
                    "",
                    "function hasIgnoreComment(path) {",
                    "  const node = path.getValue();",
                    "  return hasNodeIgnoreComment(node);",
                    "}",
                    "",
                    "function hasNodeIgnoreComment(node) {",
                    "  return (",
                    "    node &&",
                    "    node.comments &&",
                    "    node.comments.length > 0 &&",
                    "    node.comments.some(comment => comment.value.trim() === \"prettier-ignore\")",
                    "  );",
                    "}",
                    "",
                    "function arrayify(object, keyName) {",
                    "  return Object.keys(object).reduce(",
                    "    (array, key) =>",
                    "      array.concat(Object.assign({ [keyName]: key }, object[key])),",
                    "    []",
                    "  );",
                    "}",
                    "",
                    "function addCommentHelper(node, comment) {",
                    "  const comments = node.comments || (node.comments = []);",
                    "  comments.push(comment);",
                    "  comment.printed = false;",
                    "",
                    "  // For some reason, TypeScript parses `// x` inside of JSXText as a comment",
                    "  // We already \"print\" it via the raw text, we don't need to re-print it as a",
                    "  // comment",
                    "  if (node.type === \"JSXText\") {",
                    "    comment.printed = true;",
                    "  }",
                    "}",
                    "",
                    "function addLeadingComment(node, comment) {",
                    "  comment.leading = true;",
                    "  comment.trailing = false;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function addDanglingComment(node, comment) {",
                    "  comment.leading = false;",
                    "  comment.trailing = false;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function addTrailingComment(node, comment) {",
                    "  comment.leading = false;",
                    "  comment.trailing = true;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "module.exports = {",
                    "  arrayify,",
                    "  punctuationRegex,",
                    "  punctuationCharRange,",
                    "  getStringWidth,",
                    "  splitText,",
                    "  mapDoc,",
                    "  getMaxContinuousCount,",
                    "  getPrecedence,",
                    "  shouldFlatten,",
                    "  isBitwiseOperator,",
                    "  isExportDeclaration,",
                    "  getParentExportDeclaration,",
                    "  getPenultimate,",
                    "  getLast,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  getNextNonSpaceNonCommentCharacter,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipNewline,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isNextLineEmpty,",
                    "  isPreviousLineEmpty,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  setLocStart,",
                    "  setLocEnd,",
                    "  startsWithNoLookaheadToken,",
                    "  hasBlockComments,",
                    "  isBlockComment,",
                    "  hasClosureCompilerTypeCastComment,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  printString,",
                    "  printNumber,",
                    "  hasIgnoreComment,",
                    "  hasNodeIgnoreComment,",
                    "  lineColumnToIndex,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment",
                    "};"
                ]
            }
        },
        "config": {
            "resolve-config-editorconfig.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "",
                    "const editorconfig = require(\"editorconfig\");",
                    "const mem = require(\"mem\");",
                    "const editorConfigToPrettier = require(\"editorconfig-to-prettier\");",
                    "const findProjectRoot = require(\"find-project-root\");",
                    "",
                    "const maybeParse = (filePath, config, parse) => {",
                    "  const root = findProjectRoot(path.dirname(path.resolve(filePath)));",
                    "  return filePath && parse(filePath, { root });",
                    "};",
                    "",
                    "const editorconfigAsyncNoCache = (filePath, config) => {",
                    "  return Promise.resolve(maybeParse(filePath, config, editorconfig.parse)).then(",
                    "    editorConfigToPrettier",
                    "  );",
                    "};",
                    "const editorconfigAsyncWithCache = mem(editorconfigAsyncNoCache);",
                    "",
                    "const editorconfigSyncNoCache = (filePath, config) => {",
                    "  return editorConfigToPrettier(",
                    "    maybeParse(filePath, config, editorconfig.parseSync)",
                    "  );",
                    "};",
                    "const editorconfigSyncWithCache = mem(editorconfigSyncNoCache);",
                    "",
                    "function getLoadFunction(opts) {",
                    "  if (!opts.editorconfig) {",
                    "    return () => null;",
                    "  }",
                    "",
                    "  if (opts.sync) {",
                    "    return opts.cache ? editorconfigSyncWithCache : editorconfigSyncNoCache;",
                    "  }",
                    "",
                    "  return opts.cache ? editorconfigAsyncWithCache : editorconfigAsyncNoCache;",
                    "}",
                    "",
                    "function clearCache() {",
                    "  mem.clear(editorconfigSyncWithCache);",
                    "  mem.clear(editorconfigAsyncWithCache);",
                    "}",
                    "",
                    "module.exports = {",
                    "  getLoadFunction,",
                    "  clearCache",
                    "};"
                ]
            },
            "resolve-config.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const thirdParty = require(\"../common/third-party\");",
                    "const minimatch = require(\"minimatch\");",
                    "const path = require(\"path\");",
                    "const mem = require(\"mem\");",
                    "",
                    "const resolveEditorConfig = require(\"./resolve-config-editorconfig\");",
                    "",
                    "const getExplorerMemoized = mem(opts =>",
                    "  thirdParty.cosmiconfig(\"prettier\", {",
                    "    sync: opts.sync,",
                    "    cache: opts.cache,",
                    "    rcExtensions: true,",
                    "    transform: result => {",
                    "      if (result && result.config) {",
                    "        delete result.config.$schema;",
                    "      }",
                    "      return result;",
                    "    }",
                    "  })",
                    ");",
                    "",
                    "/** @param {{ cache: boolean, sync: boolean }} opts */",
                    "function getLoadFunction(opts) {",
                    "  // Normalize opts before passing to a memoized function",
                    "  opts = Object.assign({ sync: false, cache: false }, opts);",
                    "  return getExplorerMemoized(opts).load;",
                    "}",
                    "",
                    "function _resolveConfig(filePath, opts, sync) {",
                    "  opts = Object.assign({ useCache: true }, opts);",
                    "  const loadOpts = {",
                    "    cache: !!opts.useCache,",
                    "    sync: !!sync,",
                    "    editorconfig: !!opts.editorconfig",
                    "  };",
                    "  const load = getLoadFunction(loadOpts);",
                    "  const loadEditorConfig = resolveEditorConfig.getLoadFunction(loadOpts);",
                    "  const arr = [load, loadEditorConfig].map(l => l(filePath, opts.config));",
                    "",
                    "  const unwrapAndMerge = arr => {",
                    "    const result = arr[0];",
                    "    const editorConfigured = arr[1];",
                    "    const merged = Object.assign(",
                    "      {},",
                    "      editorConfigured,",
                    "      mergeOverrides(Object.assign({}, result), filePath)",
                    "    );",
                    "",
                    "    if (!result && !editorConfigured) {",
                    "      return null;",
                    "    }",
                    "",
                    "    return merged;",
                    "  };",
                    "",
                    "  if (loadOpts.sync) {",
                    "    return unwrapAndMerge(arr);",
                    "  }",
                    "",
                    "  return Promise.all(arr).then(unwrapAndMerge);",
                    "}",
                    "",
                    "const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);",
                    "",
                    "resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);",
                    "",
                    "function clearCache() {",
                    "  mem.clear(getExplorerMemoized);",
                    "  resolveEditorConfig.clearCache();",
                    "}",
                    "",
                    "function resolveConfigFile(filePath) {",
                    "  const load = getLoadFunction({ sync: false });",
                    "  return load(filePath).then(result => {",
                    "    return result ? result.filepath : null;",
                    "  });",
                    "}",
                    "",
                    "resolveConfigFile.sync = filePath => {",
                    "  const load = getLoadFunction({ sync: true });",
                    "  const result = load(filePath);",
                    "  return result ? result.filepath : null;",
                    "};",
                    "",
                    "function mergeOverrides(configResult, filePath) {",
                    "  const options = Object.assign({}, configResult.config);",
                    "  if (filePath && options.overrides) {",
                    "    const relativeFilePath = path.relative(",
                    "      path.dirname(configResult.filepath),",
                    "      filePath",
                    "    );",
                    "    for (const override of options.overrides) {",
                    "      if (",
                    "        pathMatchesGlobs(",
                    "          relativeFilePath,",
                    "          override.files,",
                    "          override.excludeFiles",
                    "        )",
                    "      ) {",
                    "        Object.assign(options, override.options);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  delete options.overrides;",
                    "  return options;",
                    "}",
                    "",
                    "// Based on eslint: https://github.com/eslint/eslint/blob/master/lib/config/config-ops.js",
                    "function pathMatchesGlobs(filePath, patterns, excludedPatterns) {",
                    "  const patternList = [].concat(patterns);",
                    "  const excludedPatternList = [].concat(excludedPatterns || []);",
                    "  const opts = { matchBase: true };",
                    "",
                    "  return (",
                    "    patternList.some(pattern => minimatch(filePath, pattern, opts)) &&",
                    "    !excludedPatternList.some(excludedPattern =>",
                    "      minimatch(filePath, excludedPattern, opts)",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  resolveConfig,",
                    "  resolveConfigFile,",
                    "  clearCache",
                    "};"
                ]
            }
        },
        "doc": {
            "doc-builders.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function assertDoc(val) {",
                    "  /* istanbul ignore if */",
                    "  if (",
                    "    !(typeof val === \"string\" || (val != null && typeof val.type === \"string\"))",
                    "  ) {",
                    "    throw new Error(",
                    "      \"Value \" + JSON.stringify(val) + \" is not a valid document\"",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function concat(parts) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    parts.forEach(assertDoc);",
                    "  }",
                    "",
                    "  // We cannot do this until we change `printJSXElement` to not",
                    "  // access the internals of a document directly.",
                    "  // if(parts.length === 1) {",
                    "  //   // If it's a single document, no need to concat it.",
                    "  //   return parts[0];",
                    "  // }",
                    "  return { type: \"concat\", parts };",
                    "}",
                    "",
                    "function indent(contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return { type: \"indent\", contents };",
                    "}",
                    "",
                    "function align(n, contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return { type: \"align\", contents, n };",
                    "}",
                    "",
                    "function group(contents, opts) {",
                    "  opts = opts || {};",
                    "",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return {",
                    "    type: \"group\",",
                    "    contents: contents,",
                    "    break: !!opts.shouldBreak,",
                    "    expandedStates: opts.expandedStates",
                    "  };",
                    "}",
                    "",
                    "function dedentToRoot(contents) {",
                    "  return align(-Infinity, contents);",
                    "}",
                    "",
                    "function markAsRoot(contents) {",
                    "  return align({ type: \"root\" }, contents);",
                    "}",
                    "",
                    "function dedent(contents) {",
                    "  return align(-1, contents);",
                    "}",
                    "",
                    "function conditionalGroup(states, opts) {",
                    "  return group(",
                    "    states[0],",
                    "    Object.assign(opts || {}, { expandedStates: states })",
                    "  );",
                    "}",
                    "",
                    "function fill(parts) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    parts.forEach(assertDoc);",
                    "  }",
                    "",
                    "  return { type: \"fill\", parts };",
                    "}",
                    "",
                    "function ifBreak(breakContents, flatContents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    if (breakContents) {",
                    "      assertDoc(breakContents);",
                    "    }",
                    "    if (flatContents) {",
                    "      assertDoc(flatContents);",
                    "    }",
                    "  }",
                    "",
                    "  return { type: \"if-break\", breakContents, flatContents };",
                    "}",
                    "",
                    "function lineSuffix(contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "  return { type: \"line-suffix\", contents };",
                    "}",
                    "",
                    "const lineSuffixBoundary = { type: \"line-suffix-boundary\" };",
                    "const breakParent = { type: \"break-parent\" };",
                    "const line = { type: \"line\" };",
                    "const softline = { type: \"line\", soft: true };",
                    "const hardline = concat([{ type: \"line\", hard: true }, breakParent]);",
                    "const literalline = concat([",
                    "  { type: \"line\", hard: true, literal: true },",
                    "  breakParent",
                    "]);",
                    "const cursor = { type: \"cursor\", placeholder: Symbol(\"cursor\") };",
                    "",
                    "function join(sep, arr) {",
                    "  const res = [];",
                    "",
                    "  for (let i = 0; i < arr.length; i++) {",
                    "    if (i !== 0) {",
                    "      res.push(sep);",
                    "    }",
                    "",
                    "    res.push(arr[i]);",
                    "  }",
                    "",
                    "  return concat(res);",
                    "}",
                    "",
                    "function addAlignmentToDoc(doc, size, tabWidth) {",
                    "  let aligned = doc;",
                    "  if (size > 0) {",
                    "    // Use indent to add tabs for all the levels of tabs we need",
                    "    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {",
                    "      aligned = indent(aligned);",
                    "    }",
                    "    // Use align for all the spaces that are needed",
                    "    aligned = align(size % tabWidth, aligned);",
                    "    // size is absolute from 0 and not relative to the current",
                    "    // indentation, so we use -Infinity to reset the indentation to 0",
                    "    aligned = align(-Infinity, aligned);",
                    "  }",
                    "  return aligned;",
                    "}",
                    "",
                    "module.exports = {",
                    "  concat,",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  indent,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent",
                    "};"
                ]
            },
            "doc-debug.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function flattenDoc(doc) {",
                    "  if (doc.type === \"concat\") {",
                    "    const res = [];",
                    "",
                    "    for (let i = 0; i < doc.parts.length; ++i) {",
                    "      const doc2 = doc.parts[i];",
                    "      if (typeof doc2 !== \"string\" && doc2.type === \"concat\") {",
                    "        [].push.apply(res, flattenDoc(doc2).parts);",
                    "      } else {",
                    "        const flattened = flattenDoc(doc2);",
                    "        if (flattened !== \"\") {",
                    "          res.push(flattened);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return Object.assign({}, doc, { parts: res });",
                    "  } else if (doc.type === \"if-break\") {",
                    "    return Object.assign({}, doc, {",
                    "      breakContents:",
                    "        doc.breakContents != null ? flattenDoc(doc.breakContents) : null,",
                    "      flatContents:",
                    "        doc.flatContents != null ? flattenDoc(doc.flatContents) : null",
                    "    });",
                    "  } else if (doc.type === \"group\") {",
                    "    return Object.assign({}, doc, {",
                    "      contents: flattenDoc(doc.contents),",
                    "      expandedStates: doc.expandedStates",
                    "        ? doc.expandedStates.map(flattenDoc)",
                    "        : doc.expandedStates",
                    "    });",
                    "  } else if (doc.contents) {",
                    "    return Object.assign({}, doc, { contents: flattenDoc(doc.contents) });",
                    "  }",
                    "  return doc;",
                    "}",
                    "",
                    "function printDoc(doc) {",
                    "  if (typeof doc === \"string\") {",
                    "    return JSON.stringify(doc);",
                    "  }",
                    "",
                    "  if (doc.type === \"line\") {",
                    "    if (doc.literalline) {",
                    "      return \"literalline\";",
                    "    }",
                    "    if (doc.hard) {",
                    "      return \"hardline\";",
                    "    }",
                    "    if (doc.soft) {",
                    "      return \"softline\";",
                    "    }",
                    "    return \"line\";",
                    "  }",
                    "",
                    "  if (doc.type === \"break-parent\") {",
                    "    return \"breakParent\";",
                    "  }",
                    "",
                    "  if (doc.type === \"concat\") {",
                    "    return \"[\" + doc.parts.map(printDoc).join(\", \") + \"]\";",
                    "  }",
                    "",
                    "  if (doc.type === \"indent\") {",
                    "    return \"indent(\" + printDoc(doc.contents) + \")\";",
                    "  }",
                    "",
                    "  if (doc.type === \"align\") {",
                    "    return doc.n === -Infinity",
                    "      ? \"dedentToRoot(\" + printDoc(doc.contents) + \")\"",
                    "      : doc.n < 0",
                    "        ? \"dedent(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n.type === \"root\"",
                    "          ? \"markAsRoot(\" + printDoc(doc.contents) + \")\"",
                    "          : \"align(\" +",
                    "            JSON.stringify(doc.n) +",
                    "            \", \" +",
                    "            printDoc(doc.contents) +",
                    "            \")\";",
                    "  }",
                    "",
                    "  if (doc.type === \"if-break\") {",
                    "    return (",
                    "      \"ifBreak(\" +",
                    "      printDoc(doc.breakContents) +",
                    "      (doc.flatContents ? \", \" + printDoc(doc.flatContents) : \"\") +",
                    "      \")\"",
                    "    );",
                    "  }",
                    "",
                    "  if (doc.type === \"group\") {",
                    "    if (doc.expandedStates) {",
                    "      return (",
                    "        \"conditionalGroup(\" +",
                    "        \"[\" +",
                    "        doc.expandedStates.map(printDoc).join(\",\") +",
                    "        \"])\"",
                    "      );",
                    "    }",
                    "",
                    "    return (",
                    "      (doc.break ? \"wrappedGroup\" : \"group\") +",
                    "      \"(\" +",
                    "      printDoc(doc.contents) +",
                    "      \")\"",
                    "    );",
                    "  }",
                    "",
                    "  if (doc.type === \"fill\") {",
                    "    return \"fill\" + \"(\" + doc.parts.map(printDoc).join(\", \") + \")\";",
                    "  }",
                    "",
                    "  if (doc.type === \"line-suffix\") {",
                    "    return \"lineSuffix(\" + printDoc(doc.contents) + \")\";",
                    "  }",
                    "",
                    "  if (doc.type === \"line-suffix-boundary\") {",
                    "    return \"lineSuffixBoundary\";",
                    "  }",
                    "",
                    "  throw new Error(\"Unknown doc type \" + doc.type);",
                    "}",
                    "",
                    "module.exports = {",
                    "  printDocToDebug: function(doc) {",
                    "    return printDoc(flattenDoc(doc));",
                    "  }",
                    "};"
                ]
            },
            "doc-printer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const util = require(\"../common/util\");",
                    "const docBuilders = require(\"./doc-builders\");",
                    "const concat = docBuilders.concat;",
                    "const fill = docBuilders.fill;",
                    "const cursor = docBuilders.cursor;",
                    "",
                    "const MODE_BREAK = 1;",
                    "const MODE_FLAT = 2;",
                    "",
                    "function rootIndent() {",
                    "  return { value: \"\", length: 0, queue: [] };",
                    "}",
                    "",
                    "function makeIndent(ind, options) {",
                    "  return generateInd(ind, { type: \"indent\" }, options);",
                    "}",
                    "",
                    "function makeAlign(ind, n, options) {",
                    "  return n === -Infinity",
                    "    ? ind.root || rootIndent()",
                    "    : n < 0",
                    "      ? generateInd(ind, { type: \"dedent\" }, options)",
                    "      : !n",
                    "        ? ind",
                    "        : n.type === \"root\"",
                    "          ? Object.assign({}, ind, { root: ind })",
                    "          : typeof n === \"string\"",
                    "            ? generateInd(ind, { type: \"stringAlign\", n }, options)",
                    "            : generateInd(ind, { type: \"numberAlign\", n }, options);",
                    "}",
                    "",
                    "function generateInd(ind, newPart, options) {",
                    "  const queue =",
                    "    newPart.type === \"dedent\"",
                    "      ? ind.queue.slice(0, -1)",
                    "      : ind.queue.concat(newPart);",
                    "",
                    "  let value = \"\";",
                    "  let length = 0;",
                    "  let lastTabs = 0;",
                    "  let lastSpaces = 0;",
                    "",
                    "  for (const part of queue) {",
                    "    switch (part.type) {",
                    "      case \"indent\":",
                    "        flush();",
                    "        if (options.useTabs) {",
                    "          addTabs(1);",
                    "        } else {",
                    "          addSpaces(options.tabWidth);",
                    "        }",
                    "        break;",
                    "      case \"stringAlign\":",
                    "        flush();",
                    "        value += part.n;",
                    "        length += part.n.length;",
                    "        break;",
                    "      case \"numberAlign\":",
                    "        lastTabs += 1;",
                    "        lastSpaces += part.n;",
                    "        break;",
                    "      /* istanbul ignore next */",
                    "      default:",
                    "        throw new Error(`Unexpected type '${part.type}'`);",
                    "    }",
                    "  }",
                    "",
                    "  flushSpaces();",
                    "",
                    "  return Object.assign({}, ind, { value, length, queue });",
                    "",
                    "  function addTabs(count) {",
                    "    value += \"\\t\".repeat(count);",
                    "    length += options.tabWidth * count;",
                    "  }",
                    "",
                    "  function addSpaces(count) {",
                    "    value += \" \".repeat(count);",
                    "    length += count;",
                    "  }",
                    "",
                    "  function flush() {",
                    "    if (options.useTabs) {",
                    "      flushTabs();",
                    "    } else {",
                    "      flushSpaces();",
                    "    }",
                    "  }",
                    "",
                    "  function flushTabs() {",
                    "    if (lastTabs > 0) {",
                    "      addTabs(lastTabs);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function flushSpaces() {",
                    "    if (lastSpaces > 0) {",
                    "      addSpaces(lastSpaces);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function resetLast() {",
                    "    lastTabs = 0;",
                    "    lastSpaces = 0;",
                    "  }",
                    "}",
                    "",
                    "function fits(next, restCommands, width, options, mustBeFlat) {",
                    "  let restIdx = restCommands.length;",
                    "  const cmds = [next];",
                    "  while (width >= 0) {",
                    "    if (cmds.length === 0) {",
                    "      if (restIdx === 0) {",
                    "        return true;",
                    "      }",
                    "      cmds.push(restCommands[restIdx - 1]);",
                    "",
                    "      restIdx--;",
                    "",
                    "      continue;",
                    "    }",
                    "",
                    "    const x = cmds.pop();",
                    "    const ind = x[0];",
                    "    const mode = x[1];",
                    "    const doc = x[2];",
                    "",
                    "    if (typeof doc === \"string\") {",
                    "      width -= util.getStringWidth(doc);",
                    "    } else {",
                    "      switch (doc.type) {",
                    "        case \"concat\":",
                    "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                    "            cmds.push([ind, mode, doc.parts[i]]);",
                    "          }",
                    "",
                    "          break;",
                    "        case \"indent\":",
                    "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"align\":",
                    "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"group\":",
                    "          if (mustBeFlat && doc.break) {",
                    "            return false;",
                    "          }",
                    "          cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"fill\":",
                    "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                    "            cmds.push([ind, mode, doc.parts[i]]);",
                    "          }",
                    "",
                    "          break;",
                    "        case \"if-break\":",
                    "          if (mode === MODE_BREAK) {",
                    "            if (doc.breakContents) {",
                    "              cmds.push([ind, mode, doc.breakContents]);",
                    "            }",
                    "          }",
                    "          if (mode === MODE_FLAT) {",
                    "            if (doc.flatContents) {",
                    "              cmds.push([ind, mode, doc.flatContents]);",
                    "            }",
                    "          }",
                    "",
                    "          break;",
                    "        case \"line\":",
                    "          switch (mode) {",
                    "            // fallthrough",
                    "            case MODE_FLAT:",
                    "              if (!doc.hard) {",
                    "                if (!doc.soft) {",
                    "                  width -= 1;",
                    "                }",
                    "",
                    "                break;",
                    "              }",
                    "              return true;",
                    "",
                    "            case MODE_BREAK:",
                    "              return true;",
                    "          }",
                    "          break;",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function printDocToString(doc, options) {",
                    "  const width = options.printWidth;",
                    "  const newLine = options.newLine || \"\\n\";",
                    "  let pos = 0;",
                    "  // cmds is basically a stack. We've turned a recursive call into a",
                    "  // while loop which is much faster. The while loop below adds new",
                    "  // cmds to the array instead of recursively calling `print`.",
                    "  const cmds = [[rootIndent(), MODE_BREAK, doc]];",
                    "  const out = [];",
                    "  let shouldRemeasure = false;",
                    "  let lineSuffix = [];",
                    "",
                    "  while (cmds.length !== 0) {",
                    "    const x = cmds.pop();",
                    "    const ind = x[0];",
                    "    const mode = x[1];",
                    "    const doc = x[2];",
                    "",
                    "    if (typeof doc === \"string\") {",
                    "      out.push(doc);",
                    "",
                    "      pos += util.getStringWidth(doc);",
                    "    } else {",
                    "      switch (doc.type) {",
                    "        case \"cursor\":",
                    "          out.push(cursor.placeholder);",
                    "",
                    "          break;",
                    "        case \"concat\":",
                    "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                    "            cmds.push([ind, mode, doc.parts[i]]);",
                    "          }",
                    "",
                    "          break;",
                    "        case \"indent\":",
                    "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"align\":",
                    "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"group\":",
                    "          switch (mode) {",
                    "            case MODE_FLAT:",
                    "              if (!shouldRemeasure) {",
                    "                cmds.push([",
                    "                  ind,",
                    "                  doc.break ? MODE_BREAK : MODE_FLAT,",
                    "                  doc.contents",
                    "                ]);",
                    "",
                    "                break;",
                    "              }",
                    "            // fallthrough",
                    "",
                    "            case MODE_BREAK: {",
                    "              shouldRemeasure = false;",
                    "",
                    "              const next = [ind, MODE_FLAT, doc.contents];",
                    "              const rem = width - pos;",
                    "",
                    "              if (!doc.break && fits(next, cmds, rem, options)) {",
                    "                cmds.push(next);",
                    "              } else {",
                    "                // Expanded states are a rare case where a document",
                    "                // can manually provide multiple representations of",
                    "                // itself. It provides an array of documents",
                    "                // going from the least expanded (most flattened)",
                    "                // representation first to the most expanded. If a",
                    "                // group has these, we need to manually go through",
                    "                // these states and find the first one that fits.",
                    "                if (doc.expandedStates) {",
                    "                  const mostExpanded =",
                    "                    doc.expandedStates[doc.expandedStates.length - 1];",
                    "",
                    "                  if (doc.break) {",
                    "                    cmds.push([ind, MODE_BREAK, mostExpanded]);",
                    "",
                    "                    break;",
                    "                  } else {",
                    "                    for (let i = 1; i < doc.expandedStates.length + 1; i++) {",
                    "                      if (i >= doc.expandedStates.length) {",
                    "                        cmds.push([ind, MODE_BREAK, mostExpanded]);",
                    "",
                    "                        break;",
                    "                      } else {",
                    "                        const state = doc.expandedStates[i];",
                    "                        const cmd = [ind, MODE_FLAT, state];",
                    "",
                    "                        if (fits(cmd, cmds, rem, options)) {",
                    "                          cmds.push(cmd);",
                    "",
                    "                          break;",
                    "                        }",
                    "                      }",
                    "                    }",
                    "                  }",
                    "                } else {",
                    "                  cmds.push([ind, MODE_BREAK, doc.contents]);",
                    "                }",
                    "              }",
                    "",
                    "              break;",
                    "            }",
                    "          }",
                    "          break;",
                    "        // Fills each line with as much code as possible before moving to a new",
                    "        // line with the same indentation.",
                    "        //",
                    "        // Expects doc.parts to be an array of alternating content and",
                    "        // whitespace. The whitespace contains the linebreaks.",
                    "        //",
                    "        // For example:",
                    "        //   [\"I\", line, \"love\", line, \"monkeys\"]",
                    "        // or",
                    "        //   [{ type: group, ... }, softline, { type: group, ... }]",
                    "        //",
                    "        // It uses this parts structure to handle three main layout cases:",
                    "        // * The first two content items fit on the same line without",
                    "        //   breaking",
                    "        //   -> output the first content item and the whitespace \"flat\".",
                    "        // * Only the first content item fits on the line without breaking",
                    "        //   -> output the first content item \"flat\" and the whitespace with",
                    "        //   \"break\".",
                    "        // * Neither content item fits on the line without breaking",
                    "        //   -> output the first content item and the whitespace with \"break\".",
                    "        case \"fill\": {",
                    "          const rem = width - pos;",
                    "",
                    "          const parts = doc.parts;",
                    "          if (parts.length === 0) {",
                    "            break;",
                    "          }",
                    "",
                    "          const content = parts[0];",
                    "          const contentFlatCmd = [ind, MODE_FLAT, content];",
                    "          const contentBreakCmd = [ind, MODE_BREAK, content];",
                    "          const contentFits = fits(contentFlatCmd, [], rem, options, true);",
                    "",
                    "          if (parts.length === 1) {",
                    "            if (contentFits) {",
                    "              cmds.push(contentFlatCmd);",
                    "            } else {",
                    "              cmds.push(contentBreakCmd);",
                    "            }",
                    "            break;",
                    "          }",
                    "",
                    "          const whitespace = parts[1];",
                    "          const whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];",
                    "          const whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];",
                    "",
                    "          if (parts.length === 2) {",
                    "            if (contentFits) {",
                    "              cmds.push(whitespaceFlatCmd);",
                    "              cmds.push(contentFlatCmd);",
                    "            } else {",
                    "              cmds.push(whitespaceBreakCmd);",
                    "              cmds.push(contentBreakCmd);",
                    "            }",
                    "            break;",
                    "          }",
                    "",
                    "          // At this point we've handled the first pair (context, separator)",
                    "          // and will create a new fill doc for the rest of the content.",
                    "          // Ideally we wouldn't mutate the array here but coping all the",
                    "          // elements to a new array would make this algorithm quadratic,",
                    "          // which is unusable for large arrays (e.g. large texts in JSX).",
                    "          parts.splice(0, 2);",
                    "          const remainingCmd = [ind, mode, fill(parts)];",
                    "",
                    "          const secondContent = parts[0];",
                    "",
                    "          const firstAndSecondContentFlatCmd = [",
                    "            ind,",
                    "            MODE_FLAT,",
                    "            concat([content, whitespace, secondContent])",
                    "          ];",
                    "          const firstAndSecondContentFits = fits(",
                    "            firstAndSecondContentFlatCmd,",
                    "            [],",
                    "            rem,",
                    "            options,",
                    "            true",
                    "          );",
                    "",
                    "          if (firstAndSecondContentFits) {",
                    "            cmds.push(remainingCmd);",
                    "            cmds.push(whitespaceFlatCmd);",
                    "            cmds.push(contentFlatCmd);",
                    "          } else if (contentFits) {",
                    "            cmds.push(remainingCmd);",
                    "            cmds.push(whitespaceBreakCmd);",
                    "            cmds.push(contentFlatCmd);",
                    "          } else {",
                    "            cmds.push(remainingCmd);",
                    "            cmds.push(whitespaceBreakCmd);",
                    "            cmds.push(contentBreakCmd);",
                    "          }",
                    "          break;",
                    "        }",
                    "        case \"if-break\":",
                    "          if (mode === MODE_BREAK) {",
                    "            if (doc.breakContents) {",
                    "              cmds.push([ind, mode, doc.breakContents]);",
                    "            }",
                    "          }",
                    "          if (mode === MODE_FLAT) {",
                    "            if (doc.flatContents) {",
                    "              cmds.push([ind, mode, doc.flatContents]);",
                    "            }",
                    "          }",
                    "",
                    "          break;",
                    "        case \"line-suffix\":",
                    "          lineSuffix.push([ind, mode, doc.contents]);",
                    "          break;",
                    "        case \"line-suffix-boundary\":",
                    "          if (lineSuffix.length > 0) {",
                    "            cmds.push([ind, mode, { type: \"line\", hard: true }]);",
                    "          }",
                    "          break;",
                    "        case \"line\":",
                    "          switch (mode) {",
                    "            case MODE_FLAT:",
                    "              if (!doc.hard) {",
                    "                if (!doc.soft) {",
                    "                  out.push(\" \");",
                    "",
                    "                  pos += 1;",
                    "                }",
                    "",
                    "                break;",
                    "              } else {",
                    "                // This line was forced into the output even if we",
                    "                // were in flattened mode, so we need to tell the next",
                    "                // group that no matter what, it needs to remeasure",
                    "                // because the previous measurement didn't accurately",
                    "                // capture the entire expression (this is necessary",
                    "                // for nested groups)",
                    "                shouldRemeasure = true;",
                    "              }",
                    "            // fallthrough",
                    "",
                    "            case MODE_BREAK:",
                    "              if (lineSuffix.length) {",
                    "                cmds.push([ind, mode, doc]);",
                    "                [].push.apply(cmds, lineSuffix.reverse());",
                    "                lineSuffix = [];",
                    "                break;",
                    "              }",
                    "",
                    "              if (doc.literal) {",
                    "                if (ind.root) {",
                    "                  out.push(newLine, ind.root.value);",
                    "                  pos = ind.root.length;",
                    "                } else {",
                    "                  out.push(newLine);",
                    "                  pos = 0;",
                    "                }",
                    "              } else {",
                    "                if (out.length > 0) {",
                    "                  // Trim whitespace at the end of line",
                    "                  while (",
                    "                    out.length > 0 &&",
                    "                    out[out.length - 1].match(/^[^\\S\\n]*$/)",
                    "                  ) {",
                    "                    out.pop();",
                    "                  }",
                    "",
                    "                  if (",
                    "                    out.length &&",
                    "                    (options.parser !== \"markdown\" ||",
                    "                      // preserve markdown's `break` node (two trailing spaces)",
                    "                      !/\\S {2}$/.test(out[out.length - 1]))",
                    "                  ) {",
                    "                    out[out.length - 1] = out[out.length - 1].replace(",
                    "                      /[^\\S\\n]*$/,",
                    "                      \"\"",
                    "                    );",
                    "                  }",
                    "                }",
                    "",
                    "                out.push(newLine + ind.value);",
                    "                pos = ind.length;",
                    "              }",
                    "              break;",
                    "          }",
                    "          break;",
                    "        default:",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);",
                    "  if (cursorPlaceholderIndex !== -1) {",
                    "    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");",
                    "    const afterCursor = out.slice(cursorPlaceholderIndex + 1).join(\"\");",
                    "",
                    "    return {",
                    "      formatted: beforeCursor + afterCursor,",
                    "      cursor: beforeCursor.length",
                    "    };",
                    "  }",
                    "",
                    "  return { formatted: out.join(\"\") };",
                    "}",
                    "",
                    "module.exports = { printDocToString };"
                ]
            },
            "doc-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {",
                    "  function traverseDocRec(doc) {",
                    "    let shouldRecurse = true;",
                    "    if (onEnter) {",
                    "      if (onEnter(doc) === false) {",
                    "        shouldRecurse = false;",
                    "      }",
                    "    }",
                    "",
                    "    if (shouldRecurse) {",
                    "      if (doc.type === \"concat\" || doc.type === \"fill\") {",
                    "        for (let i = 0; i < doc.parts.length; i++) {",
                    "          traverseDocRec(doc.parts[i]);",
                    "        }",
                    "      } else if (doc.type === \"if-break\") {",
                    "        if (doc.breakContents) {",
                    "          traverseDocRec(doc.breakContents);",
                    "        }",
                    "        if (doc.flatContents) {",
                    "          traverseDocRec(doc.flatContents);",
                    "        }",
                    "      } else if (doc.type === \"group\" && doc.expandedStates) {",
                    "        if (shouldTraverseConditionalGroups) {",
                    "          doc.expandedStates.forEach(traverseDocRec);",
                    "        } else {",
                    "          traverseDocRec(doc.contents);",
                    "        }",
                    "      } else if (doc.contents) {",
                    "        traverseDocRec(doc.contents);",
                    "      }",
                    "    }",
                    "",
                    "    if (onExit) {",
                    "      onExit(doc);",
                    "    }",
                    "  }",
                    "",
                    "  traverseDocRec(doc);",
                    "}",
                    "",
                    "function mapDoc(doc, func) {",
                    "  doc = func(doc);",
                    "",
                    "  if (doc.type === \"concat\" || doc.type === \"fill\") {",
                    "    return Object.assign({}, doc, {",
                    "      parts: doc.parts.map(d => mapDoc(d, func))",
                    "    });",
                    "  } else if (doc.type === \"if-break\") {",
                    "    return Object.assign({}, doc, {",
                    "      breakContents: doc.breakContents && mapDoc(doc.breakContents, func),",
                    "      flatContents: doc.flatContents && mapDoc(doc.flatContents, func)",
                    "    });",
                    "  } else if (doc.contents) {",
                    "    return Object.assign({}, doc, { contents: mapDoc(doc.contents, func) });",
                    "  }",
                    "  return doc;",
                    "}",
                    "",
                    "function findInDoc(doc, fn, defaultValue) {",
                    "  let result = defaultValue;",
                    "  let hasStopped = false;",
                    "  traverseDoc(doc, doc => {",
                    "    const maybeResult = fn(doc);",
                    "    if (maybeResult !== undefined) {",
                    "      hasStopped = true;",
                    "      result = maybeResult;",
                    "    }",
                    "    if (hasStopped) {",
                    "      return false;",
                    "    }",
                    "  });",
                    "  return result;",
                    "}",
                    "",
                    "function isEmpty(n) {",
                    "  return typeof n === \"string\" && n.length === 0;",
                    "}",
                    "",
                    "function isLineNext(doc) {",
                    "  return findInDoc(",
                    "    doc,",
                    "    doc => {",
                    "      if (typeof doc === \"string\") {",
                    "        return false;",
                    "      }",
                    "      if (doc.type === \"line\") {",
                    "        return true;",
                    "      }",
                    "    },",
                    "    false",
                    "  );",
                    "}",
                    "",
                    "function willBreak(doc) {",
                    "  return findInDoc(",
                    "    doc,",
                    "    doc => {",
                    "      if (doc.type === \"group\" && doc.break) {",
                    "        return true;",
                    "      }",
                    "      if (doc.type === \"line\" && doc.hard) {",
                    "        return true;",
                    "      }",
                    "      if (doc.type === \"break-parent\") {",
                    "        return true;",
                    "      }",
                    "    },",
                    "    false",
                    "  );",
                    "}",
                    "",
                    "function breakParentGroup(groupStack) {",
                    "  if (groupStack.length > 0) {",
                    "    const parentGroup = groupStack[groupStack.length - 1];",
                    "    // Breaks are not propagated through conditional groups because",
                    "    // the user is expected to manually handle what breaks.",
                    "    if (!parentGroup.expandedStates) {",
                    "      parentGroup.break = true;",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function propagateBreaks(doc) {",
                    "  const alreadyVisited = new Map();",
                    "  const groupStack = [];",
                    "  traverseDoc(",
                    "    doc,",
                    "    doc => {",
                    "      if (doc.type === \"break-parent\") {",
                    "        breakParentGroup(groupStack);",
                    "      }",
                    "      if (doc.type === \"group\") {",
                    "        groupStack.push(doc);",
                    "        if (alreadyVisited.has(doc)) {",
                    "          return false;",
                    "        }",
                    "        alreadyVisited.set(doc, true);",
                    "      }",
                    "    },",
                    "    doc => {",
                    "      if (doc.type === \"group\") {",
                    "        const group = groupStack.pop();",
                    "        if (group.break) {",
                    "          breakParentGroup(groupStack);",
                    "        }",
                    "      }",
                    "    },",
                    "    /* shouldTraverseConditionalGroups */ true",
                    "  );",
                    "}",
                    "",
                    "function removeLines(doc) {",
                    "  // Force this doc into flat mode by statically converting all",
                    "  // lines into spaces (or soft lines into nothing). Hard lines",
                    "  // should still output because there's too great of a chance",
                    "  // of breaking existing assumptions otherwise.",
                    "  return mapDoc(doc, d => {",
                    "    if (d.type === \"line\" && !d.hard) {",
                    "      return d.soft ? \"\" : \" \";",
                    "    } else if (d.type === \"if-break\") {",
                    "      return d.flatContents || \"\";",
                    "    }",
                    "    return d;",
                    "  });",
                    "}",
                    "",
                    "function stripTrailingHardline(doc) {",
                    "  // HACK remove ending hardline, original PR: #1984",
                    "  if (",
                    "    doc.type === \"concat\" &&",
                    "    doc.parts.length === 2 &&",
                    "    doc.parts[1].type === \"concat\" &&",
                    "    doc.parts[1].parts.length === 2 &&",
                    "    doc.parts[1].parts[0].hard &&",
                    "    doc.parts[1].parts[1].type === \"break-parent\"",
                    "  ) {",
                    "    return doc.parts[0];",
                    "  }",
                    "  return doc;",
                    "}",
                    "",
                    "function rawText(node) {",
                    "  return node.extra ? node.extra.raw : node.raw;",
                    "}",
                    "",
                    "module.exports = {",
                    "  isEmpty,",
                    "  willBreak,",
                    "  isLineNext,",
                    "  traverseDoc,",
                    "  mapDoc,",
                    "  propagateBreaks,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  rawText",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  builders: require(\"./doc-builders\"),",
                    "  printer: require(\"./doc-printer\"),",
                    "  utils: require(\"./doc-utils\"),",
                    "  debug: require(\"./doc-debug\")",
                    "};"
                ]
            }
        },
        "language-css": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const htmlTagNames = require(\"html-tag-names\");",
                    "",
                    "function clean(ast, newObj) {",
                    "  if (",
                    "    ast.type === \"media-query\" ||",
                    "    ast.type === \"media-query-list\" ||",
                    "    ast.type === \"media-feature-expression\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"css-rule\") {",
                    "    delete newObj.params;",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-combinator\") {",
                    "    newObj.value = newObj.value.replace(/\\s+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"media-feature\") {",
                    "    newObj.value = newObj.value.replace(/ /g, \"\");",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"value-word\" &&",
                    "      ((ast.isColor && ast.isHex) ||",
                    "        [\"initial\", \"inherit\", \"unset\", \"revert\"].indexOf(",
                    "          newObj.value.replace().toLowerCase()",
                    "        ) !== -1)) ||",
                    "    ast.type === \"media-feature\" ||",
                    "    ast.type === \"selector-root-invalid\" ||",
                    "    ast.type === \"selector-pseudo\"",
                    "  ) {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-decl\") {",
                    "    newObj.prop = newObj.prop.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-atrule\" || ast.type === \"css-import\") {",
                    "    newObj.name = newObj.name.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"value-number\") {",
                    "    newObj.unit = newObj.unit.toLowerCase();",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-feature\" ||",
                    "      ast.type === \"media-keyword\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"media-unknown\" ||",
                    "      ast.type === \"media-url\" ||",
                    "      ast.type === \"media-value\" ||",
                    "      ast.type === \"selector-root-invalid\" ||",
                    "      ast.type === \"selector-attribute\" ||",
                    "      ast.type === \"selector-string\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"value-string\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = cleanCSSStrings(newObj.value);",
                    "  }",
                    "",
                    "  if (ast.type === \"css-import\" && newObj.importPath) {",
                    "    newObj.importPath = cleanCSSStrings(newObj.importPath);",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-attribute\") {",
                    "    newObj.attribute = newObj.attribute.trim();",
                    "",
                    "    if (newObj.namespace) {",
                    "      if (typeof newObj.namespace === \"string\") {",
                    "        newObj.namespace = newObj.namespace.trim();",
                    "",
                    "        if (newObj.namespace.length === 0) {",
                    "          newObj.namespace = true;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newObj.value) {",
                    "      newObj.value = newObj.value.trim().replace(/^['\"]|['\"]$/g, \"\");",
                    "      delete newObj.quoted;",
                    "    }",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-value\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"value-number\" ||",
                    "      ast.type === \"selector-root-invalid\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"selector-tag\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = newObj.value.replace(",
                    "      /([\\d.eE+-]+)([a-zA-Z]*)/g,",
                    "      (match, numStr, unit) => {",
                    "        const num = Number(numStr);",
                    "        return isNaN(num) ? match : num + unit.toLowerCase();",
                    "      }",
                    "    );",
                    "  }",
                    "",
                    "  if (ast.type === \"media-url\") {",
                    "    newObj.value = newObj.value",
                    "      .replace(/^url\\(\\s+/gi, \"url(\")",
                    "      .replace(/\\s+\\)$/gi, \")\");",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-tag\") {",
                    "    const lowercasedValue = ast.value.toLowerCase();",
                    "",
                    "    if (htmlTagNames.indexOf(lowercasedValue) !== -1) {",
                    "      newObj.value = lowercasedValue;",
                    "    }",
                    "",
                    "    if ([\"from\", \"to\"].indexOf(lowercasedValue) !== -1) {",
                    "      newObj.value = lowercasedValue;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function cleanCSSStrings(value) {",
                    "  return value.replace(/'/g, '\"').replace(/\\\\([^a-fA-F\\d])/g, \"$1\");",
                    "}",
                    "",
                    "module.exports = clean;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-postcss\");",
                    "const options = require(\"./options\");",
                    "const privateUtil = require(\"../common/util\");",
                    "",
                    "const lineColumnToIndex = privateUtil.lineColumnToIndex;",
                    "const getLast = privateUtil.getLast;",
                    "",
                    "// Based on:",
                    "// https://github.com/github/linguist/blob/master/lib/linguist/languages.yml",
                    "",
                    "const languages = [",
                    "  {",
                    "    name: \"CSS\",",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"css\"],",
                    "    group: \"CSS\",",
                    "    tmScope: \"source.css\",",
                    "    aceMode: \"css\",",
                    "    codemirrorMode: \"css\",",
                    "    codemirrorMimeType: \"text/css\",",
                    "    extensions: [\".css\", \".pcss\", \".postcss\"],",
                    "    liguistLanguageId: 50,",
                    "    vscodeLanguageIds: [\"css\", \"postcss\"]",
                    "  },",
                    "  {",
                    "    name: \"Less\",",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"less\"],",
                    "    group: \"CSS\",",
                    "    extensions: [\".less\"],",
                    "    tmScope: \"source.css.less\",",
                    "    aceMode: \"less\",",
                    "    codemirrorMode: \"css\",",
                    "    codemirrorMimeType: \"text/css\",",
                    "    liguistLanguageId: 198,",
                    "    vscodeLanguageIds: [\"less\"]",
                    "  },",
                    "  {",
                    "    name: \"SCSS\",",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"scss\"],",
                    "    group: \"CSS\",",
                    "    tmScope: \"source.scss\",",
                    "    aceMode: \"scss\",",
                    "    codemirrorMode: \"css\",",
                    "    codemirrorMimeType: \"text/x-scss\",",
                    "    extensions: [\".scss\"],",
                    "    liguistLanguageId: 329,",
                    "    vscodeLanguageIds: [\"scss\"]",
                    "  }",
                    "];",
                    "",
                    "const postcss = {",
                    "  get parse() {",
                    "    return eval(\"require\")(\"./parser-postcss\");",
                    "  },",
                    "  astFormat: \"postcss\",",
                    "  locEnd: function(node) {",
                    "    const endNode = node.nodes && getLast(node.nodes);",
                    "    if (endNode && node.source && !node.source.end) {",
                    "      node = endNode;",
                    "    }",
                    "    if (node.source) {",
                    "      return lineColumnToIndex(node.source.end, node.source.input.css);",
                    "    }",
                    "    return null;",
                    "  },",
                    "  locStart: function(node) {",
                    "    if (node.source) {",
                    "      return lineColumnToIndex(node.source.start, node.source.input.css) - 1;",
                    "    }",
                    "    return null;",
                    "  }",
                    "};",
                    "",
                    "// TODO: switch these to just `postcss` and use `language` instead.",
                    "const parsers = {",
                    "  css: postcss,",
                    "  less: postcss,",
                    "  scss: postcss",
                    "};",
                    "",
                    "const printers = {",
                    "  postcss: printer",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  parsers,",
                    "  printers",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const jsOptions = require(\"../language-js/options\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/common/support.js",
                    "module.exports = {",
                    "  singleQuote: jsOptions.singleQuote",
                    "};"
                ]
            },
            "parser-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const grayMatter = require(\"gray-matter\");",
                    "",
                    "function parseSelector(selector) {",
                    "  // If there's a comment inside of a selector, the parser tries to parse",
                    "  // the content of the comment as selectors which turns it into complete",
                    "  // garbage. Better to print the whole selector as-is and not try to parse",
                    "  // and reformat it.",
                    "  if (selector.match(/\\/\\/|\\/\\*/)) {",
                    "    return {",
                    "      type: \"selector-comment\",",
                    "      value: selector.replace(/^ +/, \"\").replace(/ +$/, \"\")",
                    "    };",
                    "  }",
                    "  const selectorParser = require(\"postcss-selector-parser\");",
                    "  let result;",
                    "  selectorParser(result_ => {",
                    "    result = result_;",
                    "  }).process(selector);",
                    "  return addTypePrefix(result, \"selector-\");",
                    "}",
                    "",
                    "function parseValueNodes(nodes) {",
                    "  let parenGroup = {",
                    "    open: null,",
                    "    close: null,",
                    "    groups: [],",
                    "    type: \"paren_group\"",
                    "  };",
                    "  const parenGroupStack = [parenGroup];",
                    "  const rootParenGroup = parenGroup;",
                    "  let commaGroup = {",
                    "    groups: [],",
                    "    type: \"comma_group\"",
                    "  };",
                    "  const commaGroupStack = [commaGroup];",
                    "",
                    "  for (let i = 0; i < nodes.length; ++i) {",
                    "    const node = nodes[i];",
                    "    const isUnquotedDataURLCall =",
                    "      node.type === \"func\" &&",
                    "      node.value === \"url\" &&",
                    "      node.group &&",
                    "      node.group.groups &&",
                    "      node.group.groups[0] &&",
                    "      node.group.groups[0].groups &&",
                    "      node.group.groups[0].groups.length > 2 &&",
                    "      node.group.groups[0].groups[0].type === \"word\" &&",
                    "      node.group.groups[0].groups[0].value === \"data\" &&",
                    "      node.group.groups[0].groups[1].type === \"colon\" &&",
                    "      node.group.groups[0].groups[1].value === \":\";",
                    "",
                    "    if (isUnquotedDataURLCall) {",
                    "      node.group.groups = [stringifyGroup(node)];",
                    "",
                    "      return node;",
                    "    }",
                    "",
                    "    if (node.type === \"paren\" && node.value === \"(\") {",
                    "      parenGroup = {",
                    "        open: node,",
                    "        close: null,",
                    "        groups: [],",
                    "        type: \"paren_group\"",
                    "      };",
                    "      parenGroupStack.push(parenGroup);",
                    "",
                    "      commaGroup = {",
                    "        groups: [],",
                    "        type: \"comma_group\"",
                    "      };",
                    "      commaGroupStack.push(commaGroup);",
                    "    } else if (node.type === \"paren\" && node.value === \")\") {",
                    "      if (commaGroup.groups.length) {",
                    "        parenGroup.groups.push(commaGroup);",
                    "      }",
                    "      parenGroup.close = node;",
                    "",
                    "      if (commaGroupStack.length === 1) {",
                    "        throw new Error(\"Unbalanced parenthesis\");",
                    "      }",
                    "",
                    "      commaGroupStack.pop();",
                    "      commaGroup = commaGroupStack[commaGroupStack.length - 1];",
                    "      commaGroup.groups.push(parenGroup);",
                    "",
                    "      parenGroupStack.pop();",
                    "      parenGroup = parenGroupStack[parenGroupStack.length - 1];",
                    "    } else if (node.type === \"comma\") {",
                    "      parenGroup.groups.push(commaGroup);",
                    "      commaGroup = {",
                    "        groups: [],",
                    "        type: \"comma_group\"",
                    "      };",
                    "      commaGroupStack[commaGroupStack.length - 1] = commaGroup;",
                    "    } else {",
                    "      commaGroup.groups.push(node);",
                    "    }",
                    "  }",
                    "  if (commaGroup.groups.length > 0) {",
                    "    parenGroup.groups.push(commaGroup);",
                    "  }",
                    "  return rootParenGroup;",
                    "}",
                    "",
                    "function stringifyGroup(node) {",
                    "  if (node.group) {",
                    "    return stringifyGroup(node.group);",
                    "  }",
                    "",
                    "  if (node.groups) {",
                    "    return node.groups.reduce((previousValue, currentValue, index) => {",
                    "      return (",
                    "        previousValue +",
                    "        stringifyGroup(currentValue) +",
                    "        (currentValue.type === \"comma_group\" && index !== node.groups.length - 1",
                    "          ? \",\"",
                    "          : \"\")",
                    "      );",
                    "    }, \"\");",
                    "  }",
                    "",
                    "  const before = node.raws && node.raws.before ? node.raws.before : \"\";",
                    "  const value = node.value ? node.value : \"\";",
                    "  const unit = node.unit ? node.unit : \"\";",
                    "  const after = node.raws && node.raws.after ? node.raws.after : \"\";",
                    "",
                    "  return before + value + unit + after;",
                    "}",
                    "",
                    "function flattenGroups(node) {",
                    "  if (",
                    "    node.type === \"paren_group\" &&",
                    "    !node.open &&",
                    "    !node.close &&",
                    "    node.groups.length === 1",
                    "  ) {",
                    "    return flattenGroups(node.groups[0]);",
                    "  }",
                    "",
                    "  if (node.type === \"comma_group\" && node.groups.length === 1) {",
                    "    return flattenGroups(node.groups[0]);",
                    "  }",
                    "",
                    "  if (node.type === \"paren_group\" || node.type === \"comma_group\") {",
                    "    return Object.assign({}, node, { groups: node.groups.map(flattenGroups) });",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function addTypePrefix(node, prefix) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      addTypePrefix(node[key], prefix);",
                    "      if (key === \"type\" && typeof node[key] === \"string\") {",
                    "        if (!node[key].startsWith(prefix)) {",
                    "          node[key] = prefix + node[key];",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function addMissingType(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      addMissingType(node[key]);",
                    "    }",
                    "    if (!Array.isArray(node) && node.value && !node.type) {",
                    "      node.type = \"unknown\";",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parseNestedValue(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      parseNestedValue(node[key]);",
                    "      if (key === \"nodes\") {",
                    "        node.group = flattenGroups(parseValueNodes(node[key]));",
                    "        delete node[key];",
                    "      }",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parseValue(value) {",
                    "  const valueParser = require(\"postcss-values-parser\");",
                    "  const result = valueParser(value, { loose: true }).parse();",
                    "  const parsedResult = parseNestedValue(result);",
                    "  return addTypePrefix(parsedResult, \"value-\");",
                    "}",
                    "",
                    "function parseMediaQuery(value) {",
                    "  const mediaParser = require(\"postcss-media-query-parser\").default;",
                    "  const result = addMissingType(mediaParser(value));",
                    "  return addTypePrefix(result, \"media-\");",
                    "}",
                    "",
                    "const DEFAULT_SCSS_DIRECTIVE = /(\\s*?)(!default).*$/;",
                    "const GLOBAL_SCSS_DIRECTIVE = /(\\s*?)(!global).*$/;",
                    "",
                    "function parseNestedCSS(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "",
                    "    for (const key in node) {",
                    "      parseNestedCSS(node[key]);",
                    "    }",
                    "",
                    "    if (typeof node.selector === \"string\" && node.selector.trim().length > 0) {",
                    "      let selector = node.raws.selector",
                    "        ? node.raws.selector.raw",
                    "        : node.selector;",
                    "",
                    "      if (node.raws.between && node.raws.between.trim()) {",
                    "        selector += node.raws.between;",
                    "      }",
                    "",
                    "      if (selector.startsWith(\"@\") && selector.endsWith(\":\")) {",
                    "        return node;",
                    "      }",
                    "",
                    "      try {",
                    "        node.selector = parseSelector(selector);",
                    "        node.raws.selector = selector;",
                    "      } catch (e) {",
                    "        // Fail silently. It's better to print it as is than to try and parse it",
                    "        // Note: A common failure is for SCSS nested properties. `background:",
                    "        // none { color: red; }` is parsed as a NestedDeclaration by",
                    "        // postcss-scss, while `background: { color: red; }` is parsed as a Rule",
                    "        // with a selector ending with a colon. See:",
                    "        // https://github.com/postcss/postcss-scss/issues/39",
                    "        node.selector = {",
                    "          type: \"selector-root-invalid\",",
                    "          value: selector",
                    "        };",
                    "      }",
                    "",
                    "      return node;",
                    "    }",
                    "",
                    "    if (",
                    "      node.type &&",
                    "      node.type !== \"css-comment-yaml\" &&",
                    "      typeof node.value === \"string\" &&",
                    "      node.value.trim().length > 0",
                    "    ) {",
                    "      try {",
                    "        let value = node.raws.value ? node.raws.value.raw : node.value;",
                    "",
                    "        const defaultSCSSDirectiveIndex = value.match(DEFAULT_SCSS_DIRECTIVE);",
                    "",
                    "        if (defaultSCSSDirectiveIndex) {",
                    "          value = value.substring(0, defaultSCSSDirectiveIndex.index);",
                    "          node.scssDefault = true;",
                    "",
                    "          if (defaultSCSSDirectiveIndex[0].trim() !== \"!default\") {",
                    "            node.raws.scssDefault = defaultSCSSDirectiveIndex[0];",
                    "          }",
                    "        }",
                    "",
                    "        const globalSCSSDirectiveIndex = value.match(GLOBAL_SCSS_DIRECTIVE);",
                    "",
                    "        if (globalSCSSDirectiveIndex) {",
                    "          value = value.substring(0, globalSCSSDirectiveIndex.index);",
                    "          node.scssGlobal = true;",
                    "",
                    "          if (globalSCSSDirectiveIndex[0].trim() !== \"!global\") {",
                    "            node.raws.scssGlobal = globalSCSSDirectiveIndex[0];",
                    "          }",
                    "        }",
                    "",
                    "        if (value.startsWith(\"progid:\")) {",
                    "          return node;",
                    "        }",
                    "",
                    "        node.value = parseValue(value);",
                    "      } catch (e) {",
                    "        throw createError(",
                    "          \"(postcss-values-parser) \" + e.toString(),",
                    "          node.source",
                    "        );",
                    "      }",
                    "",
                    "      return node;",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\" && typeof node.params === \"string\") {",
                    "      let params =",
                    "        node.raws.params && node.raws.params.raw",
                    "          ? node.raws.params.raw",
                    "          : node.params;",
                    "",
                    "      if (node.raws.afterName.trim()) {",
                    "        params = node.raws.afterName + params;",
                    "      }",
                    "",
                    "      if (node.raws.between.trim()) {",
                    "        params = params + node.raws.between;",
                    "      }",
                    "",
                    "      params = params.trim();",
                    "",
                    "      if (params.length === 0) {",
                    "        return node;",
                    "      }",
                    "",
                    "      const name = node.name;",
                    "      const lowercasedName = node.name.toLowerCase();",
                    "",
                    "      if (name === \"warn\" || name === \"error\") {",
                    "        node.params = {",
                    "          type: \"media-unknown\",",
                    "          value: params",
                    "        };",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"extend\" || name === \"nest\") {",
                    "        node.selector = parseSelector(params);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"at-root\") {",
                    "        if (/^\\(\\s*(without|with)\\s*:[\\s\\S]+\\)$/.test(params)) {",
                    "          node.params = parseMediaQuery(params);",
                    "        } else {",
                    "          node.selector = parseSelector(params);",
                    "          delete node.params;",
                    "        }",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (",
                    "        [",
                    "          \"if\",",
                    "          \"else\",",
                    "          \"for\",",
                    "          \"each\",",
                    "          \"while\",",
                    "          \"debug\",",
                    "          \"mixin\",",
                    "          \"include\",",
                    "          \"function\",",
                    "          \"return\",",
                    "          \"define-mixin\",",
                    "          \"add-mixin\"",
                    "        ].indexOf(name) !== -1",
                    "      ) {",
                    "        // Remove unnecessary spaces in SCSS variable arguments",
                    "        params = params.replace(/(\\$\\S+?)\\s+?\\.\\.\\./, \"$1...\");",
                    "        // Remove unnecessary spaces before SCSS control, mixin and function directives",
                    "        params = params.replace(/^(?!if)(\\S+)\\s+\\(/, \"$1(\");",
                    "",
                    "        node.value = parseValue(params);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"custom-selector\") {",
                    "        const customSelector = params.match(/:--\\S+?\\s+/)[0].trim();",
                    "",
                    "        node.customSelector = customSelector;",
                    "        node.selector = parseSelector(params.substring(customSelector.length));",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (",
                    "        [\"namespace\", \"import\", \"media\", \"supports\", \"custom-media\"].indexOf(",
                    "          lowercasedName",
                    "        ) !== -1",
                    "      ) {",
                    "        if (params.includes(\"#{\")) {",
                    "          // Workaround for media at rule with scss interpolation",
                    "          return {",
                    "            type: \"media-unknown\",",
                    "            value: params",
                    "          };",
                    "        }",
                    "",
                    "        node.params = parseMediaQuery(params);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      node.params = params;",
                    "",
                    "      return node;",
                    "    }",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function parseWithParser(parser, text, frontMatter) {",
                    "  let result;",
                    "  try {",
                    "    result = parser.parse(text);",
                    "  } catch (e) {",
                    "    if (typeof e.line !== \"number\") {",
                    "      throw e;",
                    "    }",
                    "    throw createError(\"(postcss) \" + e.name + \" \" + e.reason, { start: e });",
                    "  }",
                    "",
                    "  if (Object.keys(frontMatter.data).length > 0) {",
                    "    result.nodes.unshift({",
                    "      type: \"comment-yaml\",",
                    "      value: grayMatter.stringify(\"\", frontMatter.data).replace(/\\s$/, \"\")",
                    "    });",
                    "  }",
                    "",
                    "  const prefixedResult = addTypePrefix(result, \"css-\");",
                    "  const parsedResult = parseNestedCSS(prefixedResult);",
                    "  return parsedResult;",
                    "}",
                    "",
                    "function requireParser(isSCSS) {",
                    "  if (isSCSS) {",
                    "    return require(\"postcss-scss\");",
                    "  }",
                    "",
                    "  // TODO: Remove this hack when this issue is fixed:",
                    "  // https://github.com/shellscape/postcss-less/issues/88",
                    "  const LessParser = require(\"postcss-less/dist/less-parser\");",
                    "  LessParser.prototype.atrule = function() {",
                    "    return Object.getPrototypeOf(LessParser.prototype).atrule.apply(",
                    "      this,",
                    "      arguments",
                    "    );",
                    "  };",
                    "",
                    "  return require(\"postcss-less\");",
                    "}",
                    "",
                    "const IS_POSSIBLY_SCSS = /(\\w\\s*: [^}:]+|#){|@import[^\\n]+(url|,)/;",
                    "",
                    "function parse(text, parsers, opts) {",
                    "  const hasExplicitParserChoice =",
                    "    opts.parser === \"less\" || opts.parser === \"scss\";",
                    "",
                    "  const isSCSS = hasExplicitParserChoice",
                    "    ? opts.parser === \"scss\"",
                    "    : IS_POSSIBLY_SCSS.test(text);",
                    "",
                    "  const frontMatter = grayMatter(text);",
                    "  const normalizedText = frontMatter.content;",
                    "",
                    "  try {",
                    "    return parseWithParser(requireParser(isSCSS), normalizedText, frontMatter);",
                    "  } catch (originalError) {",
                    "    if (hasExplicitParserChoice) {",
                    "      throw originalError;",
                    "    }",
                    "",
                    "    try {",
                    "      return parseWithParser(",
                    "        requireParser(!isSCSS),",
                    "        normalizedText,",
                    "        frontMatter",
                    "      );",
                    "    } catch (_secondError) {",
                    "      throw originalError;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = parse;"
                ]
            },
            "printer-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const htmlTagNames = require(\"html-tag-names\");",
                    "const clean = require(\"./clean\");",
                    "const privateUtil = require(\"../common/util\");",
                    "const sharedUtil = require(\"../common/util-shared\");",
                    "const doc = require(\"../doc\");",
                    "const docBuilders = doc.builders;",
                    "const concat = docBuilders.concat;",
                    "const join = docBuilders.join;",
                    "const line = docBuilders.line;",
                    "const hardline = docBuilders.hardline;",
                    "const softline = docBuilders.softline;",
                    "const group = docBuilders.group;",
                    "const fill = docBuilders.fill;",
                    "const indent = docBuilders.indent;",
                    "",
                    "const removeLines = doc.utils.removeLines;",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  /* istanbul ignore if */",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof node === \"string\") {",
                    "    return node;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"css-comment-yaml\":",
                    "      return node.value;",
                    "    case \"css-root\": {",
                    "      const nodes = printNodeSequence(path, options, print);",
                    "",
                    "      if (nodes.parts.length) {",
                    "        return concat([nodes, hardline]);",
                    "      }",
                    "",
                    "      return nodes;",
                    "    }",
                    "    case \"css-comment\": {",
                    "      if (node.raws.content) {",
                    "        return node.raws.content;",
                    "      }",
                    "      const text = options.originalText.slice(",
                    "        options.locStart(node),",
                    "        options.locEnd(node)",
                    "      );",
                    "      const rawText = node.raws.text || node.text;",
                    "      // Workaround a bug where the location is off.",
                    "      // https://github.com/postcss/postcss-scss/issues/63",
                    "      if (text.indexOf(rawText) === -1) {",
                    "        if (node.raws.inline) {",
                    "          return concat([\"// \", rawText]);",
                    "        }",
                    "        return concat([\"/* \", rawText, \" */\"]);",
                    "      }",
                    "      return text;",
                    "    }",
                    "    case \"css-rule\": {",
                    "      return concat([",
                    "        path.call(print, \"selector\"),",
                    "        node.important ? \" !important\" : \"\",",
                    "        node.nodes",
                    "          ? concat([",
                    "              \" {\",",
                    "              node.nodes.length > 0",
                    "                ? indent(",
                    "                    concat([hardline, printNodeSequence(path, options, print)])",
                    "                  )",
                    "                : \"\",",
                    "              hardline,",
                    "              \"}\",",
                    "              isDetachedRulesetDeclaration(node) ? \";\" : \"\"",
                    "            ])",
                    "          : \";\"",
                    "      ]);",
                    "    }",
                    "    case \"css-decl\": {",
                    "      // When the following less construct &:extend(.foo); is parsed with scss,",
                    "      // it will put a space after `:` and break it. Ideally we should parse",
                    "      // less files with less, but we can hardcode this to work with scss as",
                    "      // well.",
                    "      const isValueExtend =",
                    "        node.value.type === \"value-root\" &&",
                    "        node.value.group.type === \"value-value\" &&",
                    "        node.value.group.group.type === \"value-func\" &&",
                    "        node.value.group.group.value === \"extend\";",
                    "      const isComposed =",
                    "        node.value.type === \"value-root\" &&",
                    "        node.value.group.type === \"value-value\" &&",
                    "        node.prop === \"composes\";",
                    "      const ruleAncestorNode = getAncestorNode(path, \"css-rule\");",
                    "      const isiCSS =",
                    "        ruleAncestorNode &&",
                    "        ruleAncestorNode.raws.selector &&",
                    "        (ruleAncestorNode.raws.selector.startsWith(\":import\") ||",
                    "          ruleAncestorNode.raws.selector.startsWith(\":export\"));",
                    "",
                    "      return concat([",
                    "        node.raws.before.replace(/[\\s;]/g, \"\"),",
                    "        isiCSS ? node.prop : maybeToLowerCase(node.prop),",
                    "        node.raws.between.trim() === \":\" ? \":\" : node.raws.between.trim(),",
                    "        isValueExtend ? \"\" : \" \",",
                    "        isComposed",
                    "          ? removeLines(path.call(print, \"value\"))",
                    "          : path.call(print, \"value\"),",
                    "        node.raws.important",
                    "          ? node.raws.important.replace(/\\s*!\\s*important/i, \" !important\")",
                    "          : node.important ? \" !important\" : \"\",",
                    "        node.raws.scssDefault",
                    "          ? node.raws.scssDefault.replace(/\\s*!default/i, \" !default\")",
                    "          : node.scssDefault ? \" !default\" : \"\",",
                    "        node.raws.scssGlobal",
                    "          ? node.raws.scssGlobal.replace(/\\s*!global/i, \" !global\")",
                    "          : node.scssGlobal ? \" !global\" : \"\",",
                    "        node.nodes",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([softline, printNodeSequence(path, options, print)])",
                    "              ),",
                    "              softline,",
                    "              \"}\"",
                    "            ])",
                    "          : \";\"",
                    "      ]);",
                    "    }",
                    "    case \"css-atrule\": {",
                    "      const hasParams =",
                    "        node.params &&",
                    "        !(node.params.type === \"media-query-list\" && node.params.value === \"\");",
                    "      const isDetachedRulesetCall = hasParams && /^\\(\\s*\\)$/.test(node.params);",
                    "      const hasParensAround =",
                    "        node.value &&",
                    "        node.value.group.group.type === \"value-paren_group\" &&",
                    "        node.value.group.group.open !== null &&",
                    "        node.value.group.group.close !== null;",
                    "",
                    "      return concat([",
                    "        \"@\",",
                    "        // If a Less file ends up being parsed with the SCSS parser, Less",
                    "        // variable declarations will be parsed as atrules with names ending",
                    "        // with a colon, so keep the original case then.",
                    "        isDetachedRulesetCall || node.name.endsWith(\":\")",
                    "          ? node.name",
                    "          : maybeToLowerCase(node.name),",
                    "        hasParams",
                    "          ? concat([",
                    "              isDetachedRulesetCall ? \"\" : \" \",",
                    "              path.call(print, \"params\")",
                    "            ])",
                    "          : \"\",",
                    "        node.selector",
                    "          ? indent(concat([\" \", path.call(print, \"selector\")]))",
                    "          : \"\",",
                    "        node.value",
                    "          ? group(",
                    "              concat([",
                    "                \" \",",
                    "                path.call(print, \"value\"),",
                    "                isControlDirectiveNode(node)",
                    "                  ? hasParensAround ? \" \" : line",
                    "                  : \"\"",
                    "              ])",
                    "            )",
                    "          : node.name === \"else\" ? \" \" : \"\",",
                    "        node.nodes",
                    "          ? concat([",
                    "              isControlDirectiveNode(node) ? \"\" : \" \",",
                    "              \"{\",",
                    "              indent(",
                    "                concat([",
                    "                  node.nodes.length > 0 ? softline : \"\",",
                    "                  printNodeSequence(path, options, print)",
                    "                ])",
                    "              ),",
                    "              softline,",
                    "              \"}\"",
                    "            ])",
                    "          : \";\"",
                    "      ]);",
                    "    }",
                    "    case \"css-import\": {",
                    "      return concat([",
                    "        \"@\",",
                    "        maybeToLowerCase(node.name),",
                    "        \" \",",
                    "        node.directives ? concat([node.directives, \" \"]) : \"\",",
                    "        adjustStrings(node.importPath, options),",
                    "        node.nodes.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([softline, printNodeSequence(path, options, print)])",
                    "              ),",
                    "              softline,",
                    "              \"}\"",
                    "            ])",
                    "          : \";\"",
                    "      ]);",
                    "    }",
                    "    // postcss-media-query-parser",
                    "    case \"media-query-list\": {",
                    "      const parts = [];",
                    "      path.each(childPath => {",
                    "        const node = childPath.getValue();",
                    "        if (node.type === \"media-query\" && node.value === \"\") {",
                    "          return;",
                    "        }",
                    "        parts.push(childPath.call(print));",
                    "      }, \"nodes\");",
                    "",
                    "      return group(indent(join(line, parts)));",
                    "    }",
                    "    case \"media-query\": {",
                    "      return concat([",
                    "        join(\" \", path.map(print, \"nodes\")),",
                    "        isLastNode(path, node) ? \"\" : \",\"",
                    "      ]);",
                    "    }",
                    "    case \"media-type\": {",
                    "      const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "      if (",
                    "        atRuleAncestorNode &&",
                    "        atRuleAncestorNode.name.toLowerCase() === \"charset\"",
                    "      ) {",
                    "        return node.value;",
                    "      }",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "    }",
                    "    case \"media-feature-expression\": {",
                    "      if (!node.nodes) {",
                    "        return node.value;",
                    "      }",
                    "      return concat([\"(\", concat(path.map(print, \"nodes\")), \")\"]);",
                    "    }",
                    "    case \"media-feature\": {",
                    "      return maybeToLowerCase(",
                    "        adjustStrings(node.value.replace(/ +/g, \" \"), options)",
                    "      );",
                    "    }",
                    "    case \"media-colon\": {",
                    "      return concat([node.value, \" \"]);",
                    "    }",
                    "    case \"media-value\": {",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "    }",
                    "    case \"media-keyword\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    case \"media-url\": {",
                    "      return adjustStrings(",
                    "        node.value.replace(/^url\\(\\s+/gi, \"url(\").replace(/\\s+\\)$/gi, \")\"),",
                    "        options",
                    "      );",
                    "    }",
                    "    case \"media-unknown\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    // postcss-selector-parser",
                    "    case \"selector-root-invalid\": {",
                    "      // This is likely a SCSS nested property: `background: { color: red; }`.",
                    "      return adjustNumbers(",
                    "        adjustStrings(maybeToLowerCase(node.value), options)",
                    "      );",
                    "    }",
                    "    case \"selector-root\": {",
                    "      const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "      const insideAtRuleNode =",
                    "        atRuleAncestorNode &&",
                    "        [\"extend\", \"custom-selector\", \"nest\"].indexOf(",
                    "          atRuleAncestorNode.name",
                    "        ) !== -1;",
                    "",
                    "      return group(",
                    "        concat([",
                    "          atRuleAncestorNode && atRuleAncestorNode.name === \"custom-selector\"",
                    "            ? concat([atRuleAncestorNode.customSelector, line])",
                    "            : \"\",",
                    "          join(",
                    "            concat([\",\", insideAtRuleNode ? line : hardline]),",
                    "            path.map(print, \"nodes\")",
                    "          )",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"selector-comment\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"selector-string\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    case \"selector-tag\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode && parentNode.nodes.indexOf(node);",
                    "      const prevNode = index && parentNode.nodes[index - 1];",
                    "",
                    "      return concat([",
                    "        node.namespace",
                    "          ? concat([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"])",
                    "          : \"\",",
                    "        prevNode.type === \"selector-nesting\"",
                    "          ? node.value",
                    "          : adjustNumbers(",
                    "              isHTMLTag(node.value) ||",
                    "              isKeyframeAtRuleKeywords(path, node.value)",
                    "                ? node.value.toLowerCase()",
                    "                : node.value",
                    "            )",
                    "      ]);",
                    "    }",
                    "    case \"selector-id\": {",
                    "      return concat([\"#\", node.value]);",
                    "    }",
                    "    case \"selector-class\": {",
                    "      return concat([\".\", adjustNumbers(adjustStrings(node.value, options))]);",
                    "    }",
                    "    case \"selector-attribute\": {",
                    "      return concat([",
                    "        \"[\",",
                    "        node.namespace",
                    "          ? concat([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"])",
                    "          : \"\",",
                    "        node.attribute.trim(),",
                    "        node.operator ? node.operator : \"\",",
                    "        node.value",
                    "          ? quoteAttributeValue(",
                    "              adjustStrings(node.value.trim(), options),",
                    "              options",
                    "            )",
                    "          : \"\",",
                    "        node.insensitive ? \" i\" : \"\",",
                    "        \"]\"",
                    "      ]);",
                    "    }",
                    "    case \"selector-combinator\": {",
                    "      if (",
                    "        node.value === \"+\" ||",
                    "        node.value === \">\" ||",
                    "        node.value === \"~\" ||",
                    "        node.value === \">>>\"",
                    "      ) {",
                    "        const parentNode = path.getParentNode();",
                    "        const leading =",
                    "          parentNode.type === \"selector-selector\" &&",
                    "          parentNode.nodes[0] === node",
                    "            ? \"\"",
                    "            : line;",
                    "        return concat([leading, node.value, isLastNode(path, node) ? \"\" : \" \"]);",
                    "      }",
                    "      const leading = node.value.trim().startsWith(\"(\") ? line : \"\";",
                    "      const value =",
                    "        adjustNumbers(adjustStrings(node.value.trim(), options)) || line;",
                    "      return concat([leading, value]);",
                    "    }",
                    "    case \"selector-universal\": {",
                    "      return concat([",
                    "        node.namespace",
                    "          ? concat([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"])",
                    "          : \"\",",
                    "        adjustNumbers(node.value)",
                    "      ]);",
                    "    }",
                    "    case \"selector-selector\": {",
                    "      return group(indent(concat(path.map(print, \"nodes\"))));",
                    "    }",
                    "    case \"selector-pseudo\": {",
                    "      return concat([",
                    "        maybeToLowerCase(node.value),",
                    "        node.nodes && node.nodes.length > 0",
                    "          ? concat([\"(\", join(\", \", path.map(print, \"nodes\")), \")\"])",
                    "          : \"\"",
                    "      ]);",
                    "    }",
                    "    case \"selector-nesting\": {",
                    "      return node.value;",
                    "    }",
                    "    // postcss-values-parser",
                    "    case \"value-root\": {",
                    "      return path.call(print, \"group\");",
                    "    }",
                    "    case \"value-comment\": {",
                    "      return concat([\"/*\", node.value, \"*/\"]);",
                    "    }",
                    "    case \"value-comma_group\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const declAncestorNode = getAncestorNode(path, \"css-decl\");",
                    "      const declAncestorProp =",
                    "        declAncestorNode &&",
                    "        declAncestorNode.prop &&",
                    "        declAncestorNode.prop.toLowerCase();",
                    "      const isGridValue =",
                    "        declAncestorProp &&",
                    "        parentNode.type === \"value-value\" &&",
                    "        (declAncestorProp === \"grid\" ||",
                    "          declAncestorProp.startsWith(\"grid-template\"));",
                    "      const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "      const isControlDirective =",
                    "        atRuleAncestorNode && isControlDirectiveNode(atRuleAncestorNode);",
                    "",
                    "      const printed = path.map(print, \"groups\");",
                    "      const parts = [];",
                    "      const functionAncestorNode = getAncestorNode(path, \"value-func\");",
                    "      const insideInFunction =",
                    "        functionAncestorNode && functionAncestorNode.value;",
                    "      const insideURLFunction =",
                    "        insideInFunction && functionAncestorNode.value.toLowerCase() === \"url\";",
                    "",
                    "      let didBreak = false;",
                    "      for (let i = 0; i < node.groups.length; ++i) {",
                    "        parts.push(printed[i]);",
                    "",
                    "        // Ignore value inside `url()`",
                    "        if (insideURLFunction) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const iPrevNode = node.groups[i - 1];",
                    "        const iNode = node.groups[i];",
                    "        const iNextNode = node.groups[i + 1];",
                    "        const iNextNextNode = node.groups[i + 2];",
                    "",
                    "        // Ignore after latest node (i.e. before semicolon)",
                    "        if (!iNextNode) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore colon",
                    "        if (iNode.value === \":\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `@` in Less (i.e. `@@var;`)",
                    "        if (iNode.type === \"value-atword\" && iNode.value === \"\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `~` in Less (i.e. `content: ~\"^//* some horrible but needed css hack\";`)",
                    "        if (iNode.value === \"~\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        const isHash = iNode.type === \"value-word\" && iNode.value === \"#\";",
                    "        const isLeftCurlyBrace =",
                    "          iNode.type === \"value-word\" && iNode.value === \"{\";",
                    "        const isNextLeftCurlyBrace =",
                    "          iNextNode.type === \"value-word\" && iNextNode.value === \"{\";",
                    "        const isRightCurlyBrace =",
                    "          iNode.type === \"value-word\" && iNode.value === \"}\";",
                    "        const isNextRightCurlyBrace =",
                    "          iNextNode.type === \"value-word\" && iNextNode.value === \"}\";",
                    "",
                    "        // Ignore interpolation in SCSS (i.e. ``#{variable}``)",
                    "        if (",
                    "          isHash ||",
                    "          isLeftCurlyBrace ||",
                    "          isNextRightCurlyBrace ||",
                    "          (isNextLeftCurlyBrace &&",
                    "            iNextNode.raws &&",
                    "            iNextNode.raws.before === \"\") ||",
                    "          (isRightCurlyBrace && iNextNode.raws && iNextNode.raws.before === \"\")",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const isNextHash =",
                    "          iNextNode.type === \"value-word\" && iNextNode.value === \"#\";",
                    "",
                    "        const isMathOperator = isMathOperatorNode(iNode);",
                    "        const isNextMathOperator = isMathOperatorNode(iNextNode);",
                    "",
                    "        const isMultiplication =",
                    "          !isNextHash && isMathOperator && iNode.value === \"*\";",
                    "        const isNextMultiplication =",
                    "          !isRightCurlyBrace && isNextMathOperator && iNextNode.value === \"*\";",
                    "",
                    "        const isDivision = !isNextHash && isMathOperator && iNode.value === \"/\";",
                    "        const isNextDivision =",
                    "          !isRightCurlyBrace && isNextMathOperator && iNextNode.value === \"/\";",
                    "",
                    "        const isAddition = !isNextHash && isMathOperator && iNode.value === \"+\";",
                    "        const isNextAddition =",
                    "          !isRightCurlyBrace && isNextMathOperator && iNextNode.value === \"+\";",
                    "",
                    "        const isPrevFunction = iPrevNode && iPrevNode.type === \"value-func\";",
                    "        const isFunction = iNode.type === \"value-func\";",
                    "        const isNextFunction = iNextNode.type === \"value-func\";",
                    "        const isNextNextFunction =",
                    "          iNextNextNode && iNextNextNode.type === \"value-func\";",
                    "",
                    "        const isPrevWord =",
                    "          iPrevNode &&",
                    "          [\"value-word\", \"value-atword\"].indexOf(iPrevNode.type) !== -1;",
                    "        const isWord =",
                    "          [\"value-word\", \"value-atword\"].indexOf(iNode.type) !== -1;",
                    "        const isNextWord =",
                    "          [\"value-word\", \"value-atword\"].indexOf(iNextNode.type) !== -1;",
                    "        const isNextNextWord =",
                    "          iNextNextNode &&",
                    "          [\"value-word\", \"value-atword\"].indexOf(iNextNextNode.type) !== -1;",
                    "",
                    "        // Math operators",
                    "        const insideCalcFunction =",
                    "          insideInFunction &&",
                    "          functionAncestorNode.value.toLowerCase() === \"calc\";",
                    "",
                    "        const hasSpaceBeforeOperator =",
                    "          isNextNextFunction || isNextNextWord || isFunction || isWord;",
                    "",
                    "        const hasSpaceAfterOperator =",
                    "          isNextFunction || isNextWord || isPrevFunction || isPrevWord;",
                    "",
                    "        if (",
                    "          (isMathOperator || isNextMathOperator) &&",
                    "          // Multiplication",
                    "          !isMultiplication &&",
                    "          !isNextMultiplication &&",
                    "          // Division",
                    "          !(isNextDivision && (hasSpaceBeforeOperator || insideCalcFunction)) &&",
                    "          !(isDivision && (hasSpaceAfterOperator || insideCalcFunction)) &&",
                    "          // Addition",
                    "          !(isNextAddition && hasSpaceBeforeOperator) &&",
                    "          !(isAddition && hasSpaceAfterOperator)",
                    "        ) {",
                    "          const isNextParenGroup = isParenGroupNode(iNextNode);",
                    "          const isNextValueNumber = iNextNode.type === \"value-number\";",
                    "",
                    "          if (",
                    "            (iNextNode.raws && iNextNode.raws.before === \"\") ||",
                    "            (isMathOperator &&",
                    "              (isNextParenGroup ||",
                    "                isNextWord ||",
                    "                isNextValueNumber ||",
                    "                isMathOperatorNode(iNextNode)) &&",
                    "              (!iPrevNode || (iPrevNode && isMathOperatorNode(iPrevNode))))",
                    "          ) {",
                    "            continue;",
                    "          }",
                    "        }",
                    "",
                    "        const isEqualityOperator =",
                    "          isControlDirective && isEqualityOperatorNode(iNode);",
                    "        const isRelationalOperator =",
                    "          isControlDirective && isRelationalOperatorNode(iNode);",
                    "        const isNextEqualityOperator =",
                    "          isControlDirective && isEqualityOperatorNode(iNextNode);",
                    "        const isNextRelationalOperator =",
                    "          isControlDirective && isRelationalOperatorNode(iNextNode);",
                    "        const isNextIfElseKeyword =",
                    "          isControlDirective && isIfElseKeywordNode(iNextNode);",
                    "        const isEachKeyword = isControlDirective && isEachKeywordNode(iNode);",
                    "        const isNextEachKeyword =",
                    "          isControlDirective && isEachKeywordNode(iNextNode);",
                    "        const isForKeyword =",
                    "          atRuleAncestorNode &&",
                    "          atRuleAncestorNode.name === \"for\" &&",
                    "          isForKeywordNode(iNode);",
                    "        const isNextForKeyword =",
                    "          isControlDirective && isForKeywordNode(iNextNode);",
                    "        const IsNextColon = iNextNode.value === \":\";",
                    "",
                    "        if (isGridValue) {",
                    "          if (iNode.source.start.line !== iNextNode.source.start.line) {",
                    "            parts.push(hardline);",
                    "            didBreak = true;",
                    "          } else {",
                    "            parts.push(\" \");",
                    "          }",
                    "        } else if (",
                    "          isNextMathOperator ||",
                    "          isNextEqualityOperator ||",
                    "          isNextRelationalOperator ||",
                    "          isNextIfElseKeyword ||",
                    "          isForKeyword ||",
                    "          isEachKeyword",
                    "        ) {",
                    "          parts.push(\" \");",
                    "        } else if (",
                    "          !IsNextColon ||",
                    "          isEqualityOperator ||",
                    "          isRelationalOperator ||",
                    "          isNextForKeyword ||",
                    "          isNextEachKeyword",
                    "        ) {",
                    "          parts.push(line);",
                    "        }",
                    "      }",
                    "",
                    "      if (didBreak) {",
                    "        parts.unshift(hardline);",
                    "      }",
                    "",
                    "      if (isControlDirective) {",
                    "        return group(indent(concat(parts)));",
                    "      }",
                    "",
                    "      return group(indent(fill(parts)));",
                    "    }",
                    "    case \"value-paren_group\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const isURLCall =",
                    "        parentNode &&",
                    "        parentNode.type === \"value-func\" &&",
                    "        parentNode.value === \"url\";",
                    "",
                    "      if (",
                    "        isURLCall &&",
                    "        (node.groups.length === 1 ||",
                    "          (node.groups.length > 0 &&",
                    "            node.groups[0].type === \"value-comma_group\" &&",
                    "            node.groups[0].groups.length > 0 &&",
                    "            node.groups[0].groups[0].type === \"value-word\" &&",
                    "            node.groups[0].groups[0].value.startsWith(\"data:\")))",
                    "      ) {",
                    "        return concat([",
                    "          node.open ? path.call(print, \"open\") : \"\",",
                    "          join(\",\", path.map(print, \"groups\")),",
                    "          node.close ? path.call(print, \"close\") : \"\"",
                    "        ]);",
                    "      }",
                    "",
                    "      if (!node.open) {",
                    "        const printed = path.map(print, \"groups\");",
                    "        const res = [];",
                    "",
                    "        for (let i = 0; i < printed.length; i++) {",
                    "          if (i !== 0) {",
                    "            res.push(concat([\",\", line]));",
                    "          }",
                    "          res.push(printed[i]);",
                    "        }",
                    "        return group(indent(fill(res)));",
                    "      }",
                    "",
                    "      const declNode = path.getParentNode(2);",
                    "      const isMap =",
                    "        declNode &&",
                    "        declNode.type === \"css-decl\" &&",
                    "        declNode.prop.startsWith(\"$\");",
                    "",
                    "      return group(",
                    "        concat([",
                    "          node.open ? path.call(print, \"open\") : \"\",",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              join(",
                    "                concat([\",\", isMap ? hardline : line]),",
                    "                path.map(print, \"groups\")",
                    "              )",
                    "            ])",
                    "          ),",
                    "          softline,",
                    "          node.close ? path.call(print, \"close\") : \"\"",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"value-value\": {",
                    "      return path.call(print, \"group\");",
                    "    }",
                    "    case \"value-func\": {",
                    "      return concat([node.value, path.call(print, \"group\")]);",
                    "    }",
                    "    case \"value-paren\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-number\": {",
                    "      return concat([printNumber(node.value), maybeToLowerCase(node.unit)]);",
                    "    }",
                    "    case \"value-operator\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-word\": {",
                    "      if ((node.isColor && node.isHex) || isWideKeywords(node.value)) {",
                    "        return node.value.toLowerCase();",
                    "      }",
                    "      return node.value;",
                    "    }",
                    "    case \"value-colon\": {",
                    "      return concat([node.value, insideURLFunctionNode(path) ? \"\" : line]);",
                    "    }",
                    "    case \"value-comma\": {",
                    "      return concat([node.value, \" \"]);",
                    "    }",
                    "    case \"value-string\": {",
                    "      return privateUtil.printString(",
                    "        node.raws.quote + node.value + node.raws.quote,",
                    "        options",
                    "      );",
                    "    }",
                    "    case \"value-atword\": {",
                    "      return concat([\"@\", node.value]);",
                    "    }",
                    "    case \"value-unicode-range\": {",
                    "      return node.value;",
                    "    }",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unknown postcss type ${JSON.stringify(node.type)}`);",
                    "  }",
                    "}",
                    "",
                    "function isLastNode(path, node) {",
                    "  const parentNode = path.getParentNode();",
                    "  if (!parentNode) {",
                    "    return false;",
                    "  }",
                    "  const nodes = parentNode.nodes;",
                    "  return nodes && nodes.indexOf(node) === nodes.length - 1;",
                    "}",
                    "",
                    "function isDetachedRulesetDeclaration(node) {",
                    "  // If a Less file ends up being parsed with the SCSS parser, Less",
                    "  // variable declarations will be parsed as atrules with names ending",
                    "  // with a colon, so keep the original case then.",
                    "  return (",
                    "    node.selector &&",
                    "    node.selector.type !== \"selector-root-invalid\" &&",
                    "    ((typeof node.selector === \"string\" && /^@.+:.*$/.test(node.selector)) ||",
                    "      (node.selector.value && /^@.+:.*$/.test(node.selector.value)))",
                    "  );",
                    "}",
                    "",
                    "function isKeyframeAtRuleKeywords(path, value) {",
                    "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "  return (",
                    "    atRuleAncestorNode &&",
                    "    atRuleAncestorNode.name &&",
                    "    atRuleAncestorNode.name.toLowerCase().endsWith(\"keyframes\") &&",
                    "    [\"from\", \"to\"].indexOf(value.toLowerCase()) !== -1",
                    "  );",
                    "}",
                    "",
                    "function isHTMLTag(value) {",
                    "  return htmlTagNames.indexOf(value.toLowerCase()) !== -1;",
                    "}",
                    "",
                    "function insideURLFunctionNode(path) {",
                    "  const funcAncestorNode = getAncestorNode(path, \"value-func\");",
                    "  return (",
                    "    funcAncestorNode &&",
                    "    funcAncestorNode.value &&",
                    "    funcAncestorNode.value === \"url\"",
                    "  );",
                    "}",
                    "",
                    "function isParenGroupNode(node) {",
                    "  return node.type && node.type === \"value-paren_group\";",
                    "}",
                    "",
                    "function isForKeywordNode(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type === \"value-word\" &&",
                    "    node.value &&",
                    "    [\"from\", \"through\", \"end\"].indexOf(node.value) !== -1",
                    "  );",
                    "}",
                    "",
                    "function isIfElseKeywordNode(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type === \"value-word\" &&",
                    "    node.value &&",
                    "    [\"and\", \"or\", \"not\"].indexOf(node.value) !== -1",
                    "  );",
                    "}",
                    "",
                    "function isEachKeywordNode(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type === \"value-word\" &&",
                    "    node.value &&",
                    "    [\"in\"].indexOf(node.value) !== -1",
                    "  );",
                    "}",
                    "",
                    "function isMathOperatorNode(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type === \"value-operator\" &&",
                    "    node.value &&",
                    "    [\"+\", \"-\", \"/\", \"*\", \"%\"].indexOf(node.value) !== -1",
                    "  );",
                    "}",
                    "",
                    "function isEqualityOperatorNode(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type === \"value-word\" &&",
                    "    node.value &&",
                    "    [\"==\", \"!=\"].indexOf(node.value) !== -1",
                    "  );",
                    "}",
                    "",
                    "function isRelationalOperatorNode(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type === \"value-word\" &&",
                    "    node.value &&",
                    "    [\"<\", \">\", \"<=\", \">=\"].indexOf(node.value) !== -1",
                    "  );",
                    "}",
                    "",
                    "function isControlDirectiveNode(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type === \"css-atrule\" &&",
                    "    node.name &&",
                    "    (node.name === \"if\" ||",
                    "      node.name === \"else\" ||",
                    "      node.name === \"for\" ||",
                    "      node.name === \"each\" ||",
                    "      node.name === \"while\")",
                    "  );",
                    "}",
                    "",
                    "function getAncestorCounter(path, typeOrTypes) {",
                    "  const types = [].concat(typeOrTypes);",
                    "",
                    "  let counter = -1;",
                    "  let ancestorNode;",
                    "",
                    "  while ((ancestorNode = path.getParentNode(++counter))) {",
                    "    if (types.indexOf(ancestorNode.type) !== -1) {",
                    "      return counter;",
                    "    }",
                    "  }",
                    "",
                    "  return -1;",
                    "}",
                    "",
                    "function getAncestorNode(path, typeOrTypes) {",
                    "  const counter = getAncestorCounter(path, typeOrTypes);",
                    "  return counter === -1 ? null : path.getParentNode(counter);",
                    "}",
                    "",
                    "function printNodeSequence(path, options, print) {",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "  let i = 0;",
                    "  path.map(pathChild => {",
                    "    const prevNode = node.nodes[i - 1];",
                    "    if (",
                    "      prevNode &&",
                    "      prevNode.type === \"css-comment\" &&",
                    "      prevNode.text.trim() === \"prettier-ignore\"",
                    "    ) {",
                    "      const childNode = pathChild.getValue();",
                    "      parts.push(",
                    "        options.originalText.slice(",
                    "          options.locStart(childNode),",
                    "          options.locEnd(childNode)",
                    "        )",
                    "      );",
                    "    } else {",
                    "      parts.push(pathChild.call(print));",
                    "    }",
                    "",
                    "    if (i !== node.nodes.length - 1) {",
                    "      if (",
                    "        (node.nodes[i + 1].type === \"css-comment\" &&",
                    "          !privateUtil.hasNewline(",
                    "            options.originalText,",
                    "            options.locStart(node.nodes[i + 1]),",
                    "            { backwards: true }",
                    "          )) ||",
                    "        (node.nodes[i + 1].type === \"css-atrule\" &&",
                    "          node.nodes[i + 1].name === \"else\" &&",
                    "          node.nodes[i].type !== \"css-comment\")",
                    "      ) {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(hardline);",
                    "        if (",
                    "          sharedUtil.isNextLineEmpty(",
                    "            options.originalText,",
                    "            pathChild.getValue(),",
                    "            options",
                    "          )",
                    "        ) {",
                    "          parts.push(hardline);",
                    "        }",
                    "      }",
                    "    }",
                    "    i++;",
                    "  }, \"nodes\");",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "const STRING_REGEX = /(['\"])(?:(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/g;",
                    "const NUMBER_REGEX = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?/g;",
                    "const STANDARD_UNIT_REGEX = /[a-zA-Z]+/g;",
                    "const WORD_PART_REGEX = /[$@]?[a-zA-Z_\\u0080-\\uFFFF][\\w\\-\\u0080-\\uFFFF]*/g;",
                    "const ADJUST_NUMBERS_REGEX = RegExp(",
                    "  STRING_REGEX.source +",
                    "    `|` +",
                    "    `(${WORD_PART_REGEX.source})?` +",
                    "    `(${NUMBER_REGEX.source})` +",
                    "    `(${STANDARD_UNIT_REGEX.source})?`,",
                    "  \"g\"",
                    ");",
                    "",
                    "function adjustStrings(value, options) {",
                    "  return value.replace(STRING_REGEX, match =>",
                    "    privateUtil.printString(match, options)",
                    "  );",
                    "}",
                    "",
                    "function quoteAttributeValue(value, options) {",
                    "  const quote = options.singleQuote ? \"'\" : '\"';",
                    "  return value.includes('\"') || value.includes(\"'\")",
                    "    ? value",
                    "    : quote + value + quote;",
                    "}",
                    "",
                    "function adjustNumbers(value) {",
                    "  return value.replace(",
                    "    ADJUST_NUMBERS_REGEX,",
                    "    (match, quote, wordPart, number, unit) =>",
                    "      !wordPart && number",
                    "        ? (wordPart || \"\") + printNumber(number) + maybeToLowerCase(unit || \"\")",
                    "        : match",
                    "  );",
                    "}",
                    "",
                    "function printNumber(rawNumber) {",
                    "  return (",
                    "    privateUtil",
                    "      .printNumber(rawNumber)",
                    "      // Remove trailing `.0`.",
                    "      .replace(/\\.0(?=$|e)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "function maybeToLowerCase(value) {",
                    "  return value.includes(\"$\") ||",
                    "    value.includes(\"@\") ||",
                    "    value.includes(\"#\") ||",
                    "    value.startsWith(\"%\") ||",
                    "    value.startsWith(\"--\") ||",
                    "    (value.includes(\"(\") && value.includes(\")\"))",
                    "    ? value",
                    "    : value.toLowerCase();",
                    "}",
                    "",
                    "function isWideKeywords(value) {",
                    "  return (",
                    "    [\"initial\", \"inherit\", \"unset\", \"revert\"].indexOf(",
                    "      value.replace().toLowerCase()",
                    "    ) !== -1",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  hasPrettierIgnore: privateUtil.hasIgnoreComment,",
                    "  massageAstNode: clean",
                    "};"
                ]
            }
        },
        "language-graphql": {
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-graphql\");",
                    "const options = require(\"./options\");",
                    "",
                    "// Based on:",
                    "// https://github.com/github/linguist/blob/master/lib/linguist/languages.yml",
                    "",
                    "const languages = [",
                    "  {",
                    "    name: \"GraphQL\",",
                    "    since: \"1.5.0\",",
                    "    parsers: [\"graphql\"],",
                    "    extensions: [\".graphql\", \".gql\"],",
                    "    tmScope: \"source.graphql\",",
                    "    aceMode: \"text\",",
                    "    liguistLanguageId: 139,",
                    "    vscodeLanguageIds: [\"graphql\"]",
                    "  }",
                    "];",
                    "",
                    "const parsers = {",
                    "  graphql: {",
                    "    get parse() {",
                    "      return eval(\"require\")(\"./parser-graphql\");",
                    "    },",
                    "    astFormat: \"graphql\",",
                    "    locStart: function(node) {",
                    "      if (typeof node.start === \"number\") {",
                    "        return node.start;",
                    "      }",
                    "      return node.loc && node.loc.start;",
                    "    },",
                    "    locEnd: function(node) {",
                    "      if (typeof node.end === \"number\") {",
                    "        return node.end;",
                    "      }",
                    "      return node.loc && node.loc.end;",
                    "    }",
                    "  }",
                    "};",
                    "",
                    "const printers = {",
                    "  graphql: printer",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  parsers,",
                    "  printers",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const jsOptions = require(\"../language-js/options\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/common/support.js",
                    "module.exports = {",
                    "  bracketSpacing: jsOptions.bracketSpacing",
                    "};"
                ]
            },
            "parser-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "",
                    "function parseComments(ast) {",
                    "  const comments = [];",
                    "  const startToken = ast.loc.startToken;",
                    "  let next = startToken.next;",
                    "  while (next.kind !== \"<EOF>\") {",
                    "    if (next.kind === \"Comment\") {",
                    "      Object.assign(next, {",
                    "        // The Comment token's column starts _after_ the `#`,",
                    "        // but we need to make sure the node captures the `#`",
                    "        column: next.column - 1",
                    "      });",
                    "      comments.push(next);",
                    "    }",
                    "    next = next.next;",
                    "  }",
                    "",
                    "  return comments;",
                    "}",
                    "",
                    "function removeTokens(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.startToken;",
                    "    delete node.endToken;",
                    "    delete node.prev;",
                    "    delete node.next;",
                    "    for (const key in node) {",
                    "      removeTokens(node[key]);",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parse(text /*, parsers, opts*/) {",
                    "  // Inline the require to avoid loading all the JS if we don't use it",
                    "  const parser = require(\"graphql/language\");",
                    "  try {",
                    "    const ast = parser.parse(text);",
                    "    ast.comments = parseComments(ast);",
                    "    removeTokens(ast);",
                    "    return ast;",
                    "  } catch (error) {",
                    "    const GraphQLError = require(\"graphql/error\").GraphQLError;",
                    "    if (error instanceof GraphQLError) {",
                    "      throw createError(error.message, {",
                    "        start: {",
                    "          line: error.locations[0].line,",
                    "          column: error.locations[0].column",
                    "        }",
                    "      });",
                    "    } else {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = parse;"
                ]
            },
            "printer-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const docBuilders = require(\"../doc\").builders;",
                    "const concat = docBuilders.concat;",
                    "const join = docBuilders.join;",
                    "const hardline = docBuilders.hardline;",
                    "const line = docBuilders.line;",
                    "const softline = docBuilders.softline;",
                    "const group = docBuilders.group;",
                    "const indent = docBuilders.indent;",
                    "const ifBreak = docBuilders.ifBreak;",
                    "const privateUtil = require(\"../common/util\");",
                    "const sharedUtil = require(\"../common/util-shared\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const n = path.getValue();",
                    "  if (!n) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof n === \"string\") {",
                    "    return n;",
                    "  }",
                    "",
                    "  switch (n.kind) {",
                    "    case \"Document\": {",
                    "      return concat([",
                    "        join(concat([hardline, hardline]), path.map(print, \"definitions\")),",
                    "        hardline",
                    "      ]);",
                    "    }",
                    "    case \"OperationDefinition\": {",
                    "      const hasOperation = options.originalText[options.locStart(n)] !== \"{\";",
                    "      const hasName = !!n.name;",
                    "      return concat([",
                    "        hasOperation ? n.operation : \"\",",
                    "        hasOperation && hasName ? concat([\" \", path.call(print, \"name\")]) : \"\",",
                    "        n.variableDefinitions && n.variableDefinitions.length",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.map(print, \"variableDefinitions\")",
                    "                    )",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\"",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        printDirectives(path, print, n),",
                    "        n.selectionSet ? (!hasOperation && !hasName ? \"\" : \" \") : \"\",",
                    "        path.call(print, \"selectionSet\")",
                    "      ]);",
                    "    }",
                    "    case \"FragmentDefinition\": {",
                    "      return concat([",
                    "        \"fragment \",",
                    "        path.call(print, \"name\"),",
                    "        \" on \",",
                    "        path.call(print, \"typeCondition\"),",
                    "        printDirectives(path, print, n),",
                    "        \" \",",
                    "        path.call(print, \"selectionSet\")",
                    "      ]);",
                    "    }",
                    "    case \"SelectionSet\": {",
                    "      return concat([",
                    "        \"{\",",
                    "        indent(",
                    "          concat([",
                    "            hardline,",
                    "            join(",
                    "              hardline,",
                    "              path.call(",
                    "                selectionsPath => printSequence(selectionsPath, options, print),",
                    "                \"selections\"",
                    "              )",
                    "            )",
                    "          ])",
                    "        ),",
                    "        hardline,",
                    "        \"}\"",
                    "      ]);",
                    "    }",
                    "    case \"Field\": {",
                    "      return group(",
                    "        concat([",
                    "          n.alias ? concat([path.call(print, \"alias\"), \": \"]) : \"\",",
                    "          path.call(print, \"name\"),",
                    "          n.arguments.length > 0",
                    "            ? group(",
                    "                concat([",
                    "                  \"(\",",
                    "                  indent(",
                    "                    concat([",
                    "                      softline,",
                    "                      join(",
                    "                        concat([ifBreak(\"\", \", \"), softline]),",
                    "                        path.call(",
                    "                          argsPath => printSequence(argsPath, options, print),",
                    "                          \"arguments\"",
                    "                        )",
                    "                      )",
                    "                    ])",
                    "                  ),",
                    "                  softline,",
                    "                  \")\"",
                    "                ])",
                    "              )",
                    "            : \"\",",
                    "          printDirectives(path, print, n),",
                    "          n.selectionSet ? \" \" : \"\",",
                    "          path.call(print, \"selectionSet\")",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"Name\": {",
                    "      return n.value;",
                    "    }",
                    "    case \"StringValue\": {",
                    "      if (n.block) {",
                    "        return concat([",
                    "          '\"\"\"',",
                    "          hardline,",
                    "          join(hardline, n.value.replace(/\"\"\"/g, \"\\\\$&\").split(\"\\n\")),",
                    "          hardline,",
                    "          '\"\"\"'",
                    "        ]);",
                    "      }",
                    "      return concat(['\"', n.value.replace(/[\"\\\\]/g, \"\\\\$&\"), '\"']);",
                    "    }",
                    "    case \"IntValue\":",
                    "    case \"FloatValue\":",
                    "    case \"EnumValue\": {",
                    "      return n.value;",
                    "    }",
                    "    case \"BooleanValue\": {",
                    "      return n.value ? \"true\" : \"false\";",
                    "    }",
                    "    case \"NullValue\": {",
                    "      return \"null\";",
                    "    }",
                    "    case \"Variable\": {",
                    "      return concat([\"$\", path.call(print, \"name\")]);",
                    "    }",
                    "    case \"ListValue\": {",
                    "      return group(",
                    "        concat([",
                    "          \"[\",",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              join(",
                    "                concat([ifBreak(\"\", \", \"), softline]),",
                    "                path.map(print, \"values\")",
                    "              )",
                    "            ])",
                    "          ),",
                    "          softline,",
                    "          \"]\"",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"ObjectValue\": {",
                    "      return group(",
                    "        concat([",
                    "          \"{\",",
                    "          options.bracketSpacing && n.fields.length > 0 ? \" \" : \"\",",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              join(",
                    "                concat([ifBreak(\"\", \", \"), softline]),",
                    "                path.map(print, \"fields\")",
                    "              )",
                    "            ])",
                    "          ),",
                    "          softline,",
                    "          ifBreak(\"\", options.bracketSpacing && n.fields.length > 0 ? \" \" : \"\"),",
                    "          \"}\"",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"ObjectField\":",
                    "    case \"Argument\": {",
                    "      return concat([",
                    "        path.call(print, \"name\"),",
                    "        \": \",",
                    "        path.call(print, \"value\")",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"Directive\": {",
                    "      return concat([",
                    "        \"@\",",
                    "        path.call(print, \"name\"),",
                    "        n.arguments.length > 0",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.call(",
                    "                        argsPath => printSequence(argsPath, options, print),",
                    "                        \"arguments\"",
                    "                      )",
                    "                    )",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\"",
                    "              ])",
                    "            )",
                    "          : \"\"",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"NamedType\": {",
                    "      return path.call(print, \"name\");",
                    "    }",
                    "",
                    "    case \"VariableDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"variable\"),",
                    "        \": \",",
                    "        path.call(print, \"type\"),",
                    "        n.defaultValue ? concat([\" = \", path.call(print, \"defaultValue\")]) : \"\"",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"TypeExtensionDefinition\": {",
                    "      return concat([\"extend \", path.call(print, \"definition\")]);",
                    "    }",
                    "",
                    "    case \"ObjectTypeExtension\":",
                    "    case \"ObjectTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"ObjectTypeExtension\" ? \"extend \" : \"\",",
                    "        \"type \",",
                    "        path.call(print, \"name\"),",
                    "        n.interfaces.length > 0",
                    "          ? concat([\" implements \", join(\", \", path.map(print, \"interfaces\"))])",
                    "          : \"\",",
                    "        printDirectives(path, print, n),",
                    "        n.fields.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  join(",
                    "                    hardline,",
                    "                    path.call(",
                    "                      fieldsPath => printSequence(fieldsPath, options, print),",
                    "                      \"fields\"",
                    "                    )",
                    "                  )",
                    "                ])",
                    "              ),",
                    "              hardline,",
                    "              \"}\"",
                    "            ])",
                    "          : \"\"",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"FieldDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        path.call(print, \"name\"),",
                    "        n.arguments.length > 0",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.call(",
                    "                        argsPath => printSequence(argsPath, options, print),",
                    "                        \"arguments\"",
                    "                      )",
                    "                    )",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\"",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        \": \",",
                    "        path.call(print, \"type\"),",
                    "        printDirectives(path, print, n)",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"DirectiveDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        \"directive \",",
                    "        \"@\",",
                    "        path.call(print, \"name\"),",
                    "        n.arguments.length > 0",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.call(",
                    "                        argsPath => printSequence(argsPath, options, print),",
                    "                        \"arguments\"",
                    "                      )",
                    "                    )",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\"",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        concat([\" on \", join(\" | \", path.map(print, \"locations\"))])",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"EnumTypeExtension\":",
                    "    case \"EnumTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"EnumTypeExtension\" ? \"extend \" : \"\",",
                    "        \"enum \",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n),",
                    "",
                    "        n.values.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  join(",
                    "                    hardline,",
                    "                    path.call(",
                    "                      valuesPath => printSequence(valuesPath, options, print),",
                    "                      \"values\"",
                    "                    )",
                    "                  )",
                    "                ])",
                    "              ),",
                    "              hardline,",
                    "              \"}\"",
                    "            ])",
                    "          : \"\"",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"EnumValueDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n)",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"InputValueDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? (n.description.block ? hardline : line) : \"\",",
                    "        path.call(print, \"name\"),",
                    "        \": \",",
                    "        path.call(print, \"type\"),",
                    "        n.defaultValue ? concat([\" = \", path.call(print, \"defaultValue\")]) : \"\",",
                    "        printDirectives(path, print, n)",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"InputObjectTypeExtension\":",
                    "    case \"InputObjectTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"InputObjectTypeExtension\" ? \"extend \" : \"\",",
                    "        \"input \",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n),",
                    "        n.fields.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  join(",
                    "                    hardline,",
                    "                    path.call(",
                    "                      fieldsPath => printSequence(fieldsPath, options, print),",
                    "                      \"fields\"",
                    "                    )",
                    "                  )",
                    "                ])",
                    "              ),",
                    "              hardline,",
                    "              \"}\"",
                    "            ])",
                    "          : \"\"",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"SchemaDefinition\": {",
                    "      return concat([",
                    "        \"schema\",",
                    "        printDirectives(path, print, n),",
                    "        \" {\",",
                    "        n.operationTypes.length > 0",
                    "          ? indent(",
                    "              concat([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  path.call(",
                    "                    opsPath => printSequence(opsPath, options, print),",
                    "                    \"operationTypes\"",
                    "                  )",
                    "                )",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\"",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"OperationTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"operation\"),",
                    "        \": \",",
                    "        path.call(print, \"type\")",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"InterfaceTypeExtension\":",
                    "    case \"InterfaceTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"InterfaceTypeExtension\" ? \"extend \" : \"\",",
                    "        \"interface \",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n),",
                    "",
                    "        n.fields.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  join(",
                    "                    hardline,",
                    "                    path.call(",
                    "                      fieldsPath => printSequence(fieldsPath, options, print),",
                    "                      \"fields\"",
                    "                    )",
                    "                  )",
                    "                ])",
                    "              ),",
                    "              hardline,",
                    "              \"}\"",
                    "            ])",
                    "          : \"\"",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"FragmentSpread\": {",
                    "      return concat([",
                    "        \"...\",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n)",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"InlineFragment\": {",
                    "      return concat([",
                    "        \"...\",",
                    "        n.typeCondition",
                    "          ? concat([\" on \", path.call(print, \"typeCondition\")])",
                    "          : \"\",",
                    "        printDirectives(path, print, n),",
                    "        \" \",",
                    "        path.call(print, \"selectionSet\")",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"UnionTypeExtension\":",
                    "    case \"UnionTypeDefinition\": {",
                    "      return group(",
                    "        concat([",
                    "          path.call(print, \"description\"),",
                    "          n.description ? hardline : \"\",",
                    "          group(",
                    "            concat([",
                    "              n.kind === \"UnionTypeExtension\" ? \"extend \" : \"\",",
                    "              \"union \",",
                    "              path.call(print, \"name\"),",
                    "              printDirectives(path, print, n),",
                    "              n.types.length > 0",
                    "                ? concat([",
                    "                    \" =\",",
                    "                    ifBreak(\"\", \" \"),",
                    "                    indent(",
                    "                      concat([",
                    "                        ifBreak(concat([line, \"  \"])),",
                    "                        join(concat([line, \"| \"]), path.map(print, \"types\"))",
                    "                      ])",
                    "                    )",
                    "                  ])",
                    "                : \"\"",
                    "            ])",
                    "          )",
                    "        ])",
                    "      );",
                    "    }",
                    "",
                    "    case \"ScalarTypeExtension\":",
                    "    case \"ScalarTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\",",
                    "        \"scalar \",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n)",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"NonNullType\": {",
                    "      return concat([path.call(print, \"type\"), \"!\"]);",
                    "    }",
                    "",
                    "    case \"ListType\": {",
                    "      return concat([\"[\", path.call(print, \"type\"), \"]\"]);",
                    "    }",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown graphql type: \" + JSON.stringify(n.kind));",
                    "  }",
                    "}",
                    "",
                    "function printDirectives(path, print, n) {",
                    "  if (n.directives.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return concat([",
                    "    \" \",",
                    "    group(",
                    "      indent(",
                    "        concat([",
                    "          softline,",
                    "          join(",
                    "            concat([ifBreak(\"\", \" \"), softline]),",
                    "            path.map(print, \"directives\")",
                    "          )",
                    "        ])",
                    "      )",
                    "    )",
                    "  ]);",
                    "}",
                    "",
                    "function printSequence(sequencePath, options, print) {",
                    "  const count = sequencePath.getValue().length;",
                    "",
                    "  return sequencePath.map((path, i) => {",
                    "    const printed = print(path);",
                    "",
                    "    if (",
                    "      sharedUtil.isNextLineEmpty(",
                    "        options.originalText,",
                    "        path.getValue(),",
                    "        options",
                    "      ) &&",
                    "      i < count - 1",
                    "    ) {",
                    "      return concat([printed, hardline]);",
                    "    }",
                    "",
                    "    return printed;",
                    "  });",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return node.kind && node.kind !== \"Comment\";",
                    "}",
                    "",
                    "function printComment(commentPath) {",
                    "  const comment = commentPath.getValue();",
                    "",
                    "  switch (comment.kind) {",
                    "    case \"Comment\":",
                    "      return \"#\" + comment.value.trimRight();",
                    "    default:",
                    "      throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  hasPrettierIgnore: privateUtil.hasIgnoreComment,",
                    "  printComment,",
                    "  canAttachComment",
                    "};"
                ]
            }
        },
        "language-handlebars": {
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-glimmer\");",
                    "",
                    "// Based on:",
                    "// https://github.com/github/linguist/blob/master/lib/linguist/languages.yml",
                    "",
                    "const languages = [",
                    "  {",
                    "    type: \"markup\",",
                    "    group: \"HTML\",",
                    "    aliases: [\"hbs\", \"htmlbars\"],",
                    "    extensions: [\".handlebars\", \".hbs\"],",
                    "    tm_scope: \"text.html.handlebars\",",
                    "    ace_mode: \"handlebars\",",
                    "    language_id: 155,",
                    "    since: null // unreleased",
                    "  }",
                    "];",
                    "",
                    "const parsers = {",
                    "  glimmer: {",
                    "    get parse() {",
                    "      return eval(\"require\")(\"./parser-glimmer\");",
                    "    },",
                    "    astFormat: \"glimmer\",",
                    "    locEnd: function(node) {",
                    "      return node.loc && node.loc.end;",
                    "    },",
                    "    locStart: function(node) {",
                    "      return node.loc && node.loc.start;",
                    "    }",
                    "  }",
                    "};",
                    "",
                    "const printers = {",
                    "  glimmer: printer",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  parsers,",
                    "  printers",
                    "};"
                ]
            },
            "parser-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "function removeEmptyNodes(node) {",
                    "  return (",
                    "    node.type !== \"TextNode\" ||",
                    "    (node.type === \"TextNode\" &&",
                    "      node.chars.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\") !== \"\")",
                    "  );",
                    "}",
                    "function removeWhiteSpace() {",
                    "  return {",
                    "    visitor: {",
                    "      Program(node) {",
                    "        node.body = node.body.filter(removeEmptyNodes);",
                    "      },",
                    "      ElementNode(node) {",
                    "        node.children = node.children.filter(removeEmptyNodes);",
                    "      }",
                    "    }",
                    "  };",
                    "}",
                    "",
                    "function parse(text) {",
                    "  try {",
                    "    const glimmer = require(\"@glimmer/syntax\").preprocess;",
                    "    return glimmer(text, {",
                    "      plugins: {",
                    "        ast: [removeWhiteSpace]",
                    "      }",
                    "    });",
                    "    /* istanbul ignore next */",
                    "  } catch (error) {",
                    "    const matches = error.message.match(/on line (\\d+)/);",
                    "    if (matches) {",
                    "      throw createError(error.message, {",
                    "        start: { line: +matches[1], column: 0 },",
                    "        end: { line: +matches[1], column: 80 }",
                    "      });",
                    "    } else {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "module.exports = parse;"
                ]
            },
            "printer-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const docBuilders = require(\"../doc/doc-builders\");",
                    "const concat = docBuilders.concat;",
                    "const join = docBuilders.join;",
                    "const softline = docBuilders.softline;",
                    "const hardline = docBuilders.hardline;",
                    "const line = docBuilders.line;",
                    "const group = docBuilders.group;",
                    "const indent = docBuilders.indent;",
                    "const ifBreak = docBuilders.ifBreak;",
                    "",
                    "// http://w3c.github.io/html/single-page.html#void-elements",
                    "const voidTags = [",
                    "  \"area\",",
                    "  \"base\",",
                    "  \"br\",",
                    "  \"col\",",
                    "  \"embed\",",
                    "  \"hr\",",
                    "  \"img\",",
                    "  \"input\",",
                    "  \"link\",",
                    "  \"meta\",",
                    "  \"param\",",
                    "  \"source\",",
                    "  \"track\",",
                    "  \"wbr\"",
                    "];",
                    "",
                    "// Formatter based on @glimmerjs/syntax's built-in test formatter:",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts",
                    "",
                    "function print(path, options, print) {",
                    "  const n = path.getValue();",
                    "",
                    "  /* istanbul ignore if*/",
                    "  if (!n) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  switch (n.type) {",
                    "    case \"Program\": {",
                    "      return group(",
                    "        join(softline, path.map(print, \"body\").filter(text => text !== \"\"))",
                    "      );",
                    "    }",
                    "    case \"ElementNode\": {",
                    "      const isVoid = voidTags.indexOf(n.tag) !== -1;",
                    "      const closeTag = isVoid ? concat([\" />\", softline]) : \">\";",
                    "      const hasChildren = n.children.length > 0;",
                    "      const getParams = (path, print) =>",
                    "        indent(",
                    "          concat([",
                    "            n.attributes.length ? line : \"\",",
                    "            join(line, path.map(print, \"attributes\")),",
                    "",
                    "            n.modifiers.length ? line : \"\",",
                    "            join(line, path.map(print, \"modifiers\")),",
                    "",
                    "            n.comments.length ? line : \"\",",
                    "            join(line, path.map(print, \"comments\"))",
                    "          ])",
                    "        );",
                    "",
                    "      // The problem here is that I want to not break at all if the children",
                    "      // would not break but I need to force an indent, so I use a hardline.",
                    "      /**",
                    "       * What happens now:",
                    "       * <div>",
                    "       *   Hello",
                    "       * </div>",
                    "       * ==>",
                    "       * <div>Hello</div>",
                    "       * This is due to me using hasChildren to decide to put the hardline in.",
                    "       * I would rather use a {DOES THE WHOLE THING NEED TO BREAK}",
                    "       */",
                    "      return concat([",
                    "        group(",
                    "          concat([",
                    "            \"<\",",
                    "            n.tag,",
                    "            getParams(path, print),",
                    "            ifBreak(softline, \"\"),",
                    "            closeTag",
                    "          ])",
                    "        ),",
                    "        group(",
                    "          concat([",
                    "            indent(join(softline, [\"\"].concat(path.map(print, \"children\")))),",
                    "            ifBreak(hasChildren ? hardline : \"\", \"\"),",
                    "            !isVoid ? concat([\"</\", n.tag, \">\"]) : \"\"",
                    "          ])",
                    "        )",
                    "      ]);",
                    "    }",
                    "    case \"BlockStatement\": {",
                    "      const pp = path.getParentNode(1);",
                    "      const isElseIf = pp && pp.inverse && pp.inverse.body[0] === n;",
                    "      const hasElseIf =",
                    "        n.inverse &&",
                    "        n.inverse.body[0] &&",
                    "        n.inverse.body[0].type === \"BlockStatement\";",
                    "      const indentElse = hasElseIf ? a => a : indent;",
                    "      if (n.inverse) {",
                    "        return concat([",
                    "          isElseIf",
                    "            ? concat([\"{{else \", printPathParams(path, print), \"}}\"])",
                    "            : printOpenBlock(path, print),",
                    "          indent(concat([hardline, path.call(print, \"program\")])),",
                    "          n.inverse && !hasElseIf ? concat([hardline, \"{{else}}\"]) : \"\",",
                    "          n.inverse",
                    "            ? indentElse(concat([hardline, path.call(print, \"inverse\")]))",
                    "            : \"\",",
                    "          isElseIf ? \"\" : concat([hardline, printCloseBlock(path, print)])",
                    "        ]);",
                    "      }",
                    "      /**",
                    "       * I want this boolean to be: if params are going to cause a break,",
                    "       * not that it has params.",
                    "       */",
                    "      const hasParams = n.params.length > 0 || n.hash.pairs.length > 0;",
                    "      const hasChildren = n.program.body.length > 0;",
                    "      return concat([",
                    "        printOpenBlock(path, print),",
                    "        group(",
                    "          concat([",
                    "            indent(concat([softline, path.call(print, \"program\")])),",
                    "            hasParams && hasChildren ? hardline : \"\",",
                    "            printCloseBlock(path, print)",
                    "          ])",
                    "        )",
                    "      ]);",
                    "    }",
                    "    case \"ElementModifierStatement\":",
                    "    case \"MustacheStatement\": {",
                    "      const pp = path.getParentNode(1);",
                    "      const isConcat = pp && pp.type === \"ConcatStatement\";",
                    "      return group(",
                    "        concat([",
                    "          /*n.escaped ? \"{{{\" : */ \"{{\",",
                    "          printPathParams(path, print),",
                    "          isConcat ? \"\" : softline,",
                    "          /*.escaped ? \"}}}\" :*/ \"}}\"",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"SubExpression\": {",
                    "      return group(",
                    "        concat([",
                    "          \"(\",",
                    "          printPath(path, print),",
                    "          indent(concat([line, group(join(line, getParams(path, print)))])),",
                    "          softline,",
                    "          \")\"",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"AttrNode\": {",
                    "      const quote = n.value.type === \"TextNode\" ? '\"' : \"\";",
                    "      return concat([n.name, \"=\", quote, path.call(print, \"value\"), quote]);",
                    "    }",
                    "    case \"ConcatStatement\": {",
                    "      return concat([",
                    "        '\"',",
                    "        group(",
                    "          indent(",
                    "            join(",
                    "              softline,",
                    "              path",
                    "                .map(partPath => print(partPath), \"parts\")",
                    "                .filter(a => a !== \"\")",
                    "            )",
                    "          )",
                    "        ),",
                    "        '\"'",
                    "      ]);",
                    "    }",
                    "    case \"Hash\": {",
                    "      return concat([join(line, path.map(print, \"pairs\"))]);",
                    "    }",
                    "    case \"HashPair\": {",
                    "      return concat([n.key, \"=\", path.call(print, \"value\")]);",
                    "    }",
                    "    case \"TextNode\": {",
                    "      return n.chars.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");",
                    "    }",
                    "    case \"MustacheCommentStatement\": {",
                    "      const dashes = n.value.indexOf(\"}}\") > -1 ? \"--\" : \"\";",
                    "      return concat([\"{{!\", dashes, n.value, dashes, \"}}\"]);",
                    "    }",
                    "    case \"PathExpression\": {",
                    "      return n.original;",
                    "    }",
                    "    case \"BooleanLiteral\": {",
                    "      return String(n.value);",
                    "    }",
                    "    case \"CommentStatement\": {",
                    "      return concat([\"<!--\", n.value, \"-->\"]);",
                    "    }",
                    "    case \"StringLiteral\": {",
                    "      return `\"${n.value}\"`;",
                    "    }",
                    "    case \"NumberLiteral\": {",
                    "      return String(n.value);",
                    "    }",
                    "    case \"UndefinedLiteral\": {",
                    "      return \"undefined\";",
                    "    }",
                    "    case \"NullLiteral\": {",
                    "      return \"null\";",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    default:",
                    "      throw new Error(\"unknown glimmer type: \" + JSON.stringify(n.type));",
                    "  }",
                    "}",
                    "",
                    "function printPath(path, print) {",
                    "  return path.call(print, \"path\");",
                    "}",
                    "",
                    "function getParams(path, print) {",
                    "  const node = path.getValue();",
                    "  let parts = [];",
                    "",
                    "  if (node.params.length > 0) {",
                    "    parts = parts.concat(path.map(print, \"params\"));",
                    "  }",
                    "",
                    "  if (node.hash && node.hash.pairs.length > 0) {",
                    "    parts.push(path.call(print, \"hash\"));",
                    "  }",
                    "  return parts;",
                    "}",
                    "",
                    "function printPathParams(path, print) {",
                    "  let parts = [];",
                    "",
                    "  parts.push(printPath(path, print));",
                    "  parts = parts.concat(getParams(path, print));",
                    "",
                    "  return indent(group(join(line, parts)));",
                    "}",
                    "",
                    "function printBlockParams(path) {",
                    "  const block = path.getValue();",
                    "  if (!block.program || !block.program.blockParams.length) {",
                    "    return \"\";",
                    "  }",
                    "  return concat([\" as |\", block.program.blockParams.join(\" \"), \"|\"]);",
                    "}",
                    "",
                    "function printOpenBlock(path, print) {",
                    "  return group(",
                    "    concat([",
                    "      \"{{#\",",
                    "      printPathParams(path, print),",
                    "      printBlockParams(path, print),",
                    "      softline,",
                    "      \"}}\"",
                    "    ])",
                    "  );",
                    "}",
                    "",
                    "function printCloseBlock(path, print) {",
                    "  return concat([\"{{/\", path.call(print, \"path\"), \"}}\"]);",
                    "}",
                    "",
                    "function clean(ast, newObj) {",
                    "  // (Glimmer/HTML) ignore TextNode whitespace",
                    "  if (ast.type === \"TextNode\") {",
                    "    if (ast.chars.replace(/\\s+/, \"\") === \"\") {",
                    "      return null;",
                    "    }",
                    "    newObj.chars = ast.chars.replace(/^\\s+/, \"\").replace(/\\s+$/, \"\");",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  print,",
                    "  massageAstNode: clean",
                    "};"
                ]
            }
        },
        "language-html": {
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const privateUtil = require(\"../common/util\");",
                    "const doc = require(\"../doc\");",
                    "const docUtils = doc.utils;",
                    "const docBuilders = doc.builders;",
                    "const hardline = docBuilders.hardline;",
                    "const concat = docBuilders.concat;",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"text\": {",
                    "      const parent = path.getParentNode();",
                    "      // Inline JavaScript",
                    "      if (",
                    "        parent.type === \"script\" &&",
                    "        ((!parent.attribs.lang && !parent.attribs.lang) ||",
                    "          parent.attribs.type === \"text/javascript\" ||",
                    "          parent.attribs.type === \"application/javascript\")",
                    "      ) {",
                    "        const parser = options.parser === \"flow\" ? \"flow\" : \"babylon\";",
                    "        const doc = textToDoc(getText(options, node), { parser });",
                    "        return concat([hardline, doc]);",
                    "      }",
                    "",
                    "      // Inline TypeScript",
                    "      if (",
                    "        parent.type === \"script\" &&",
                    "        (parent.attribs.type === \"application/x-typescript\" ||",
                    "          parent.attribs.lang === \"ts\")",
                    "      ) {",
                    "        const doc = textToDoc(",
                    "          getText(options, node),",
                    "          { parser: \"typescript\" },",
                    "          options",
                    "        );",
                    "        return concat([hardline, doc]);",
                    "      }",
                    "",
                    "      // Inline Styles",
                    "      if (parent.type === \"style\") {",
                    "        const doc = textToDoc(getText(options, node), { parser: \"css\" });",
                    "        return concat([hardline, docUtils.stripTrailingHardline(doc)]);",
                    "      }",
                    "",
                    "      break;",
                    "    }",
                    "",
                    "    case \"attribute\": {",
                    "      /*",
                    "       * Vue binding sytax: JS expressions",
                    "       * :class=\"{ 'some-key': value }\"",
                    "       * v-bind:id=\"'list-' + id\"",
                    "       * v-if=\"foo && !bar\"",
                    "       * @click=\"someFunction()\"",
                    "       */",
                    "      if (/(^@)|(^v-)|:/.test(node.key) && !/^\\w+$/.test(node.value)) {",
                    "        const doc = textToDoc(node.value, {",
                    "          parser: parseJavaScriptExpression,",
                    "          // Use singleQuote since HTML attributes use double-quotes.",
                    "          // TODO(azz): We still need to do an entity escape on the attribute.",
                    "          singleQuote: true",
                    "        });",
                    "        return concat([",
                    "          node.key,",
                    "          '=\"',",
                    "          privateUtil.hasNewlineInRange(node.value, 0, node.value.length)",
                    "            ? doc",
                    "            : docUtils.removeLines(doc),",
                    "          '\"'",
                    "        ]);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function parseJavaScriptExpression(text, parsers) {",
                    "  // Force parsing as an expression",
                    "  const ast = parsers.babylon(`(${text})`);",
                    "  // Extract expression from the declaration",
                    "  return {",
                    "    type: \"File\",",
                    "    program: ast.program.body[0].expression",
                    "  };",
                    "}",
                    "",
                    "function getText(options, node) {",
                    "  return options.originalText.slice(",
                    "    options.locStart(node),",
                    "    options.locEnd(node)",
                    "  );",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-htmlparser2\");",
                    "",
                    "// Based on:",
                    "// https://github.com/github/linguist/blob/master/lib/linguist/languages.yml",
                    "",
                    "const languages = [",
                    "  {",
                    "    name: \"HTML\",",
                    "    since: null, // unreleased",
                    "    parsers: [\"parse5\"],",
                    "    group: \"HTML\",",
                    "    tmScope: \"text.html.basic\",",
                    "    aceMode: \"html\",",
                    "    codemirrorMode: \"htmlmixed\",",
                    "    codemirrorMimeType: \"text/html\",",
                    "    aliases: [\"xhtml\"],",
                    "    extensions: [\".html\", \".htm\", \".html.hl\", \".inc\", \".st\", \".xht\", \".xhtml\"],",
                    "    linguistLanguageId: 146,",
                    "    vscodeLanguageIds: [\"html\"]",
                    "  }",
                    "];",
                    "",
                    "const parsers = {",
                    "  parse5: {",
                    "    get parse() {",
                    "      return eval(\"require\")(\"./parser-parse5\");",
                    "    },",
                    "    astFormat: \"htmlparser2\",",
                    "    locEnd: function(node) {",
                    "      return node.__location && node.__location.endOffset;",
                    "    },",
                    "    locStart: function(node) {",
                    "      return node.__location && node.__location.startOffset;",
                    "    }",
                    "  }",
                    "};",
                    "",
                    "const printers = {",
                    "  htmlparser2: printer",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  parsers,",
                    "  printers",
                    "};"
                ]
            },
            "parser-parse5.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function parse(text /*, parsers, opts*/) {",
                    "  // Inline the require to avoid loading all the JS if we don't use it",
                    "  const parse5 = require(\"parse5\");",
                    "  try {",
                    "    const isFragment = !/^\\s*<(!doctype|html|head|body|!--)/i.test(text);",
                    "    const ast = (isFragment ? parse5.parseFragment : parse5.parse)(text, {",
                    "      treeAdapter: parse5.treeAdapters.htmlparser2,",
                    "      locationInfo: true",
                    "    });",
                    "    return extendAst(ast);",
                    "  } catch (error) {",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "function extendAst(ast) {",
                    "  if (!ast || !ast.children) {",
                    "    return ast;",
                    "  }",
                    "  for (const child of ast.children) {",
                    "    extendAst(child);",
                    "    if (child.attribs) {",
                    "      child.attributes = convertAttribs(child.attribs);",
                    "    }",
                    "  }",
                    "  return ast;",
                    "}",
                    "",
                    "function convertAttribs(attribs) {",
                    "  return Object.keys(attribs).map(attributeKey => {",
                    "    return {",
                    "      type: \"attribute\",",
                    "      key: attributeKey,",
                    "      value: attribs[attributeKey]",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "module.exports = parse;"
                ]
            },
            "printer-htmlparser2.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const embed = require(\"./embed\");",
                    "const privateUtil = require(\"../common/util\");",
                    "const docBuilders = require(\"../doc\").builders;",
                    "const concat = docBuilders.concat;",
                    "const join = docBuilders.join;",
                    "const hardline = docBuilders.hardline;",
                    "const line = docBuilders.line;",
                    "const softline = docBuilders.softline;",
                    "const group = docBuilders.group;",
                    "const indent = docBuilders.indent;",
                    "",
                    "// http://w3c.github.io/html/single-page.html#void-elements",
                    "const voidTags = {",
                    "  area: true,",
                    "  base: true,",
                    "  br: true,",
                    "  col: true,",
                    "  embed: true,",
                    "  hr: true,",
                    "  img: true,",
                    "  input: true,",
                    "  link: true,",
                    "  meta: true,",
                    "  param: true,",
                    "  source: true,",
                    "  track: true,",
                    "  wbr: true",
                    "};",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const n = path.getValue();",
                    "  if (!n) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof n === \"string\") {",
                    "    return n;",
                    "  }",
                    "",
                    "  switch (n.type) {",
                    "    case \"root\": {",
                    "      return printChildren(path, print);",
                    "    }",
                    "    case \"directive\": {",
                    "      return concat([\"<\", n.data, \">\", hardline]);",
                    "    }",
                    "    case \"text\": {",
                    "      return n.data.replace(/\\s+/g, \" \").trim();",
                    "    }",
                    "    case \"script\":",
                    "    case \"style\":",
                    "    case \"tag\": {",
                    "      const selfClose = voidTags[n.name] ? \">\" : \" />\";",
                    "      const children = printChildren(path, print);",
                    "",
                    "      const hasNewline = privateUtil.hasNewlineInRange(",
                    "        options.originalText,",
                    "        options.locStart(n),",
                    "        options.locEnd(n)",
                    "      );",
                    "",
                    "      return group(",
                    "        concat([",
                    "          hasNewline ? hardline : \"\",",
                    "          \"<\",",
                    "          n.name,",
                    "          printAttributes(path, print),",
                    "",
                    "          n.children.length ? \">\" : selfClose,",
                    "",
                    "          n.name.toLowerCase() === \"html\"",
                    "            ? concat([hardline, children])",
                    "            : indent(children),",
                    "          n.children.length ? concat([softline, \"</\", n.name, \">\"]) : hardline",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"comment\": {",
                    "      return concat([\"<!-- \", n.data.trim(), \" -->\"]);",
                    "    }",
                    "    case \"attribute\": {",
                    "      if (!n.value) {",
                    "        return n.key;",
                    "      }",
                    "      return concat([n.key, '=\"', n.value, '\"']);",
                    "    }",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown htmlparser2 type: \" + n.type);",
                    "  }",
                    "}",
                    "",
                    "function printAttributes(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  return concat([",
                    "    node.attributes.length ? \" \" : \"\",",
                    "    indent(join(line, path.map(print, \"attributes\")))",
                    "  ]);",
                    "}",
                    "",
                    "function printChildren(path, print) {",
                    "  const children = [];",
                    "  path.each(childPath => {",
                    "    const child = childPath.getValue();",
                    "    if (child.type !== \"text\") {",
                    "      children.push(hardline);",
                    "    }",
                    "    children.push(childPath.call(print));",
                    "  }, \"children\");",
                    "  return concat(children);",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  hasPrettierIgnore: privateUtil.hasIgnoreComment",
                    "};"
                ]
            }
        },
        "language-js": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  // We remove extra `;` and add them when needed",
                    "  if (ast.type === \"EmptyStatement\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We move text around, including whitespaces and add {\" \"}",
                    "  if (ast.type === \"JSXText\") {",
                    "    return null;",
                    "  }",
                    "  if (",
                    "    ast.type === \"JSXExpressionContainer\" &&",
                    "    ast.expression.type === \"Literal\" &&",
                    "    ast.expression.value === \" \"",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "",
                    "  // (TypeScript) Ignore `static` in `constructor(static p) {}`",
                    "  // and `export` in `constructor(export p) {}`",
                    "  if (",
                    "    ast.type === \"TSParameterProperty\" &&",
                    "    ast.accessibility === null &&",
                    "    !ast.readonly",
                    "  ) {",
                    "    return {",
                    "      type: \"Identifier\",",
                    "      name: ast.parameter.name,",
                    "      typeAnnotation: newObj.parameter.typeAnnotation,",
                    "      decorators: newObj.decorators",
                    "    };",
                    "  }",
                    "",
                    "  // (TypeScript) ignore empty `specifiers` array",
                    "  if (",
                    "    ast.type === \"TSNamespaceExportDeclaration\" &&",
                    "    ast.specifiers &&",
                    "    ast.specifiers.length === 0",
                    "  ) {",
                    "    delete newObj.specifiers;",
                    "  }",
                    "",
                    "  // (TypeScript) bypass TSParenthesizedType",
                    "  if (",
                    "    ast.type === \"TSParenthesizedType\" &&",
                    "    ast.typeAnnotation.type === \"TSTypeAnnotation\"",
                    "  ) {",
                    "    return newObj.typeAnnotation.typeAnnotation;",
                    "  }",
                    "",
                    "  // We convert <div></div> to <div />",
                    "  if (ast.type === \"JSXOpeningElement\") {",
                    "    delete newObj.selfClosing;",
                    "  }",
                    "  if (ast.type === \"JSXElement\") {",
                    "    delete newObj.closingElement;",
                    "  }",
                    "",
                    "  // We change {'key': value} into {key: value}",
                    "  if (",
                    "    (ast.type === \"Property\" ||",
                    "      ast.type === \"MethodDefinition\" ||",
                    "      ast.type === \"ClassProperty\" ||",
                    "      ast.type === \"TSPropertySignature\" ||",
                    "      ast.type === \"ObjectTypeProperty\") &&",
                    "    typeof ast.key === \"object\" &&",
                    "    ast.key &&",
                    "    (ast.key.type === \"Literal\" || ast.key.type === \"Identifier\")",
                    "  ) {",
                    "    delete newObj.key;",
                    "  }",
                    "",
                    "  // Remove raw and cooked values from TemplateElement when it's CSS",
                    "  // styled-jsx",
                    "  if (",
                    "    ast.type === \"JSXElement\" &&",
                    "    ast.openingElement.name.name === \"style\" &&",
                    "    ast.openingElement.attributes.some(attr => attr.name.name === \"jsx\")",
                    "  ) {",
                    "    const templateLiterals = newObj.children",
                    "      .filter(",
                    "        child =>",
                    "          child.type === \"JSXExpressionContainer\" &&",
                    "          child.expression.type === \"TemplateLiteral\"",
                    "      )",
                    "      .map(container => container.expression);",
                    "",
                    "    const quasis = templateLiterals.reduce(",
                    "      (quasis, templateLiteral) => quasis.concat(templateLiteral.quasis),",
                    "      []",
                    "    );",
                    "",
                    "    quasis.forEach(q => delete q.value);",
                    "  }",
                    "",
                    "  // CSS template literals in css prop",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.name.name === \"css\" &&",
                    "    ast.value.type === \"JSXExpressionContainer\" &&",
                    "    ast.value.expression.type === \"TemplateLiteral\"",
                    "  ) {",
                    "    newObj.value.expression.quasis.forEach(q => delete q.value);",
                    "  }",
                    "",
                    "  // styled-components, graphql, markdown",
                    "  if (",
                    "    ast.type === \"TaggedTemplateExpression\" &&",
                    "    (ast.tag.type === \"MemberExpression\" ||",
                    "      (ast.tag.type === \"Identifier\" &&",
                    "        (ast.tag.name === \"gql\" ||",
                    "          ast.tag.name === \"graphql\" ||",
                    "          ast.tag.name === \"css\" ||",
                    "          ast.tag.name === \"md\" ||",
                    "          ast.tag.name === \"markdown\")) ||",
                    "      ast.tag.type === \"CallExpression\")",
                    "  ) {",
                    "    newObj.quasi.quasis.forEach(quasi => delete quasi.value);",
                    "  }",
                    "  if (",
                    "    ast.type === \"TemplateLiteral\" &&",
                    "    parent.type === \"CallExpression\" &&",
                    "    parent.callee.name === \"graphql\"",
                    "  ) {",
                    "    newObj.quasis.forEach(quasi => delete quasi.value);",
                    "  }",
                    "}",
                    "",
                    "module.exports = clean;"
                ]
            },
            "comments.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const privateUtil = require(\"../common/util\");",
                    "const sharedUtil = require(\"../common/util-shared\");",
                    "",
                    "const addLeadingComment = sharedUtil.addLeadingComment;",
                    "const addTrailingComment = sharedUtil.addTrailingComment;",
                    "const addDanglingComment = sharedUtil.addDanglingComment;",
                    "",
                    "function handleOwnLineComment(comment, text, options, ast, isLastComment) {",
                    "  const precedingNode = comment.precedingNode;",
                    "  const enclosingNode = comment.enclosingNode;",
                    "  const followingNode = comment.followingNode;",
                    "  if (",
                    "    handleLastFunctionArgComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleMemberExpressionComments(enclosingNode, followingNode, comment) ||",
                    "    handleIfStatementComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleTryStatementComments(enclosingNode, followingNode, comment) ||",
                    "    handleClassComments(enclosingNode, precedingNode, followingNode, comment) ||",
                    "    handleImportSpecifierComments(enclosingNode, comment) ||",
                    "    handleForComments(enclosingNode, precedingNode, comment) ||",
                    "    handleUnionTypeComments(",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment",
                    "    ) ||",
                    "    handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||",
                    "    handleImportDeclarationComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleAssignmentPatternComments(enclosingNode, comment) ||",
                    "    handleMethodNameComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      comment,",
                    "      options",
                    "    )",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleEndOfLineComment(comment, text, options, ast, isLastComment) {",
                    "  const precedingNode = comment.precedingNode;",
                    "  const enclosingNode = comment.enclosingNode;",
                    "  const followingNode = comment.followingNode;",
                    "  if (",
                    "    handleLastFunctionArgComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleConditionalExpressionComments(",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      text,",
                    "      options",
                    "    ) ||",
                    "    handleImportSpecifierComments(enclosingNode, comment) ||",
                    "    handleIfStatementComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleClassComments(enclosingNode, precedingNode, followingNode, comment) ||",
                    "    handleLabeledStatementComments(enclosingNode, comment) ||",
                    "    handleCallExpressionComments(precedingNode, enclosingNode, comment) ||",
                    "    handlePropertyComments(enclosingNode, comment) ||",
                    "    handleExportNamedDeclarationComments(enclosingNode, comment) ||",
                    "    handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||",
                    "    handleTypeAliasComments(enclosingNode, followingNode, comment) ||",
                    "    handleVariableDeclaratorComments(enclosingNode, followingNode, comment)",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleRemainingComment(comment, text, options, ast, isLastComment) {",
                    "  const precedingNode = comment.precedingNode;",
                    "  const enclosingNode = comment.enclosingNode;",
                    "  const followingNode = comment.followingNode;",
                    "  if (",
                    "    handleIfStatementComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) ||",
                    "    handleCommentInEmptyParens(text, enclosingNode, comment, options) ||",
                    "    handleMethodNameComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||",
                    "    handleCommentAfterArrowParams(text, enclosingNode, comment, options) ||",
                    "    handleFunctionNameComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      comment,",
                    "      options",
                    "    )",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function addBlockStatementFirstComment(node, comment) {",
                    "  const body = node.body.filter(n => n.type !== \"EmptyStatement\");",
                    "  if (body.length === 0) {",
                    "    addDanglingComment(node, comment);",
                    "  } else {",
                    "    addLeadingComment(body[0], comment);",
                    "  }",
                    "}",
                    "",
                    "function addBlockOrNotComment(node, comment) {",
                    "  if (node.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(node, comment);",
                    "  } else {",
                    "    addLeadingComment(node, comment);",
                    "  }",
                    "}",
                    "",
                    "// There are often comments before the else clause of if statements like",
                    "//",
                    "//   if (1) { ... }",
                    "//   // comment",
                    "//   else { ... }",
                    "//",
                    "// They are being attached as leading comments of the BlockExpression which",
                    "// is not well printed. What we want is to instead move the comment inside",
                    "// of the block and make it leadingComment of the first element of the block",
                    "// or dangling comment of the block if there is nothing inside",
                    "//",
                    "//   if (1) { ... }",
                    "//   else {",
                    "//     // comment",
                    "//     ...",
                    "//   }",
                    "function handleIfStatementComments(",
                    "  text,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    enclosingNode.type !== \"IfStatement\" ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // We unfortunately have no way using the AST or location of nodes to know",
                    "  // if the comment is positioned before the condition parenthesis:",
                    "  //   if (a /* comment */) {}",
                    "  // The only workaround I found is to look at the next character to see if",
                    "  // it is a ).",
                    "  const nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "    text,",
                    "    comment,",
                    "    options.locEnd",
                    "  );",
                    "  if (nextCharacter === \")\") {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"IfStatement\") {",
                    "    addBlockOrNotComment(followingNode.consequent, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // For comments positioned after the condition parenthesis in an if statement",
                    "  // before the consequent with or without brackets on, such as",
                    "  // if (a) /* comment */ {} or if (a) /* comment */ true,",
                    "  // we look at the next character to see if it is a { or if the following node",
                    "  // is the consequent for the if statement",
                    "  if (nextCharacter === \"{\" || enclosingNode.consequent === followingNode) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "// Same as IfStatement but for TryStatement",
                    "function handleTryStatementComments(enclosingNode, followingNode, comment) {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    enclosingNode.type !== \"TryStatement\" ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"TryStatement\") {",
                    "    addBlockOrNotComment(followingNode.finalizer, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"CatchClause\") {",
                    "    addBlockOrNotComment(followingNode.body, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleMemberExpressionComments(enclosingNode, followingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"MemberExpression\" &&",
                    "    followingNode &&",
                    "    followingNode.type === \"Identifier\"",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleConditionalExpressionComments(",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  followingNode,",
                    "  comment,",
                    "  text,",
                    "  options",
                    ") {",
                    "  const isSameLineAsPrecedingNode =",
                    "    precedingNode &&",
                    "    !privateUtil.hasNewlineInRange(",
                    "      text,",
                    "      options.locEnd(precedingNode),",
                    "      options.locStart(comment)",
                    "    );",
                    "",
                    "  if (",
                    "    (!precedingNode || !isSameLineAsPrecedingNode) &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"ConditionalExpression\" &&",
                    "    followingNode",
                    "  ) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ObjectProperty\" ||",
                    "      enclosingNode.type === \"Property\") &&",
                    "    enclosingNode.shorthand &&",
                    "    enclosingNode.key === precedingNode &&",
                    "    enclosingNode.value.type === \"AssignmentPattern\"",
                    "  ) {",
                    "    addTrailingComment(enclosingNode.value.left, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleClassComments(",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  followingNode,",
                    "  comment",
                    ") {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ClassDeclaration\" ||",
                    "      enclosingNode.type === \"ClassExpression\") &&",
                    "    (enclosingNode.decorators && enclosingNode.decorators.length > 0) &&",
                    "    !(followingNode && followingNode.type === \"Decorator\")",
                    "  ) {",
                    "    if (!enclosingNode.decorators || enclosingNode.decorators.length === 0) {",
                    "      addLeadingComment(enclosingNode, comment);",
                    "    } else {",
                    "      addTrailingComment(",
                    "        enclosingNode.decorators[enclosingNode.decorators.length - 1],",
                    "        comment",
                    "      );",
                    "    }",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleMethodNameComments(",
                    "  text,",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  // This is only needed for estree parsers (flow, typescript) to attach",
                    "  // after a method name:",
                    "  // obj = { fn /*comment*/() {} };",
                    "  if (",
                    "    enclosingNode &&",
                    "    precedingNode &&",
                    "    (enclosingNode.type === \"Property\" ||",
                    "      enclosingNode.type === \"MethodDefinition\") &&",
                    "    precedingNode.type === \"Identifier\" &&",
                    "    enclosingNode.key === precedingNode &&",
                    "    // special Property case: { key: /*comment*/(value) };",
                    "    // comment should be attached to value instead of key",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      precedingNode,",
                    "      options.locEnd",
                    "    ) !== \":\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Print comments between decorators and class methods as a trailing comment",
                    "  // on the decorator node instead of the method node",
                    "  if (",
                    "    precedingNode &&",
                    "    enclosingNode &&",
                    "    precedingNode.type === \"Decorator\" &&",
                    "    (enclosingNode.type === \"ClassMethod\" ||",
                    "      enclosingNode.type === \"ClassProperty\" ||",
                    "      enclosingNode.type === \"TSAbstractClassProperty\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\" ||",
                    "      enclosingNode.type === \"MethodDefinition\")",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleFunctionNameComments(",
                    "  text,",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  if (",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      comment,",
                    "      options.locEnd",
                    "    ) !== \"(\"",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    precedingNode &&",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"FunctionDeclaration\" ||",
                    "      enclosingNode.type === \"FunctionExpression\" ||",
                    "      enclosingNode.type === \"ClassMethod\" ||",
                    "      enclosingNode.type === \"MethodDefinition\" ||",
                    "      enclosingNode.type === \"ObjectMethod\")",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleCommentAfterArrowParams(text, enclosingNode, comment, options) {",
                    "  if (!(enclosingNode && enclosingNode.type === \"ArrowFunctionExpression\")) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const index = sharedUtil.getNextNonSpaceNonCommentCharacterIndex(",
                    "    text,",
                    "    comment,",
                    "    options",
                    "  );",
                    "  if (text.substr(index, 2) === \"=>\") {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleCommentInEmptyParens(text, enclosingNode, comment, options) {",
                    "  if (",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      comment,",
                    "      options.locEnd",
                    "    ) !== \")\"",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Only add dangling comments to fix the case when no params are present,",
                    "  // i.e. a function without any argument.",
                    "  if (",
                    "    enclosingNode &&",
                    "    (((enclosingNode.type === \"FunctionDeclaration\" ||",
                    "      enclosingNode.type === \"FunctionExpression\" ||",
                    "      (enclosingNode.type === \"ArrowFunctionExpression\" &&",
                    "        (enclosingNode.body.type !== \"CallExpression\" ||",
                    "          enclosingNode.body.arguments.length === 0)) ||",
                    "      enclosingNode.type === \"ClassMethod\" ||",
                    "      enclosingNode.type === \"ObjectMethod\") &&",
                    "      enclosingNode.params.length === 0) ||",
                    "      (enclosingNode.type === \"CallExpression\" &&",
                    "        enclosingNode.arguments.length === 0))",
                    "  ) {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"MethodDefinition\" &&",
                    "      enclosingNode.value.params.length === 0)",
                    "  ) {",
                    "    addDanglingComment(enclosingNode.value, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleLastFunctionArgComments(",
                    "  text,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  // Type definitions functions",
                    "  if (",
                    "    precedingNode &&",
                    "    precedingNode.type === \"FunctionTypeParam\" &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"FunctionTypeAnnotation\" &&",
                    "    followingNode &&",
                    "    followingNode.type !== \"FunctionTypeParam\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Real functions",
                    "  if (",
                    "    precedingNode &&",
                    "    (precedingNode.type === \"Identifier\" ||",
                    "      precedingNode.type === \"AssignmentPattern\") &&",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ArrowFunctionExpression\" ||",
                    "      enclosingNode.type === \"FunctionExpression\" ||",
                    "      enclosingNode.type === \"FunctionDeclaration\" ||",
                    "      enclosingNode.type === \"ObjectMethod\" ||",
                    "      enclosingNode.type === \"ClassMethod\") &&",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      comment,",
                    "      options.locEnd",
                    "    ) === \")\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleImportSpecifierComments(enclosingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"ImportSpecifier\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleLabeledStatementComments(enclosingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"LabeledStatement\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleCallExpressionComments(precedingNode, enclosingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"CallExpression\" &&",
                    "    precedingNode &&",
                    "    enclosingNode.callee === precedingNode &&",
                    "    enclosingNode.arguments.length > 0",
                    "  ) {",
                    "    addLeadingComment(enclosingNode.arguments[0], comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleUnionTypeComments(",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment",
                    ") {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"UnionTypeAnnotation\" ||",
                    "      enclosingNode.type === \"TSUnionType\")",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handlePropertyComments(enclosingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"Property\" ||",
                    "      enclosingNode.type === \"ObjectProperty\")",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleExportNamedDeclarationComments(enclosingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"ExportNamedDeclaration\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleOnlyComments(enclosingNode, ast, comment, isLastComment) {",
                    "  // With Flow the enclosingNode is undefined so use the AST instead.",
                    "  if (ast && ast.body && ast.body.length === 0) {",
                    "    if (isLastComment) {",
                    "      addDanglingComment(ast, comment);",
                    "    } else {",
                    "      addLeadingComment(ast, comment);",
                    "    }",
                    "    return true;",
                    "  } else if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"Program\" &&",
                    "    enclosingNode.body.length === 0 &&",
                    "    enclosingNode.directives &&",
                    "    enclosingNode.directives.length === 0",
                    "  ) {",
                    "    if (isLastComment) {",
                    "      addDanglingComment(enclosingNode, comment);",
                    "    } else {",
                    "      addLeadingComment(enclosingNode, comment);",
                    "    }",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleForComments(enclosingNode, precedingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ForInStatement\" ||",
                    "      enclosingNode.type === \"ForOfStatement\")",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleImportDeclarationComments(",
                    "  text,",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  if (",
                    "    precedingNode &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"ImportDeclaration\" &&",
                    "    privateUtil.hasNewline(text, options.locEnd(comment))",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleAssignmentPatternComments(enclosingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"AssignmentPattern\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleTypeAliasComments(enclosingNode, followingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"TypeAlias\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleVariableDeclaratorComments(",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment",
                    ") {",
                    "  if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"VariableDeclarator\" &&",
                    "    followingNode &&",
                    "    (followingNode.type === \"ObjectExpression\" ||",
                    "      followingNode.type === \"ArrayExpression\")",
                    "  ) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "module.exports = {",
                    "  handleOwnLineComment,",
                    "  handleEndOfLineComment,",
                    "  handleRemainingComment",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const util = require(\"../common/util\");",
                    "const doc = require(\"../doc\");",
                    "const docUtils = doc.utils;",
                    "const docBuilders = doc.builders;",
                    "const indent = docBuilders.indent;",
                    "const join = docBuilders.join;",
                    "const hardline = docBuilders.hardline;",
                    "const softline = docBuilders.softline;",
                    "const literalline = docBuilders.literalline;",
                    "const concat = docBuilders.concat;",
                    "const dedentToRoot = docBuilders.dedentToRoot;",
                    "",
                    "function embed(path, print, textToDoc /*, options */) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "",
                    "  switch (node.type) {",
                    "    case \"TemplateLiteral\": {",
                    "      const isCss = [isStyledJsx, isStyledComponents, isCssProp].some(isIt =>",
                    "        isIt(path)",
                    "      );",
                    "",
                    "      if (isCss) {",
                    "        // Get full template literal with expressions replaced by placeholders",
                    "        const rawQuasis = node.quasis.map(q => q.value.raw);",
                    "        const text = rawQuasis.join(\"@prettier-placeholder\");",
                    "        const doc = textToDoc(text, { parser: \"css\" });",
                    "        return transformCssDoc(doc, path, print);",
                    "      }",
                    "",
                    "      /*",
                    "       * react-relay and graphql-tag",
                    "       * graphql`...`",
                    "       * graphql.experimental`...`",
                    "       * gql`...`",
                    "       *",
                    "       * This intentionally excludes Relay Classic tags, as Prettier does not",
                    "       * support Relay Classic formatting.",
                    "       */",
                    "      if (",
                    "        parent &&",
                    "        ((parent.type === \"TaggedTemplateExpression\" &&",
                    "          ((parent.tag.type === \"MemberExpression\" &&",
                    "            parent.tag.object.name === \"graphql\" &&",
                    "            parent.tag.property.name === \"experimental\") ||",
                    "            (parent.tag.type === \"Identifier\" &&",
                    "              (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")))) ||",
                    "          (parent.type === \"CallExpression\" &&",
                    "            parent.callee.type === \"Identifier\" &&",
                    "            parent.callee.name === \"graphql\"))",
                    "      ) {",
                    "        const expressionDocs = node.expressions",
                    "          ? path.map(print, \"expressions\")",
                    "          : [];",
                    "",
                    "        const numQuasis = node.quasis.length;",
                    "",
                    "        if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {",
                    "          return \"``\";",
                    "        }",
                    "",
                    "        const parts = [];",
                    "",
                    "        for (let i = 0; i < numQuasis; i++) {",
                    "          const templateElement = node.quasis[i];",
                    "          const isFirst = i === 0;",
                    "          const isLast = i === numQuasis - 1;",
                    "          const text = templateElement.value.raw;",
                    "          const lines = text.split(\"\\n\");",
                    "          const numLines = lines.length;",
                    "          const expressionDoc = expressionDocs[i];",
                    "",
                    "          const startsWithBlankLine =",
                    "            numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";",
                    "          const endsWithBlankLine =",
                    "            numLines > 2 &&",
                    "            lines[numLines - 1].trim() === \"\" &&",
                    "            lines[numLines - 2].trim() === \"\";",
                    "",
                    "          const commentsAndWhitespaceOnly = lines.every(line =>",
                    "            /^\\s*(?:#[^\\r\\n]*)?$/.test(line)",
                    "          );",
                    "",
                    "          // Bail out if an interpolation occurs within a comment.",
                    "          if (!isLast && /#[^\\r\\n]*$/.test(lines[numLines - 1])) {",
                    "            return null;",
                    "          }",
                    "",
                    "          let doc = null;",
                    "",
                    "          if (commentsAndWhitespaceOnly) {",
                    "            doc = printGraphqlComments(lines);",
                    "          } else {",
                    "            try {",
                    "              doc = docUtils.stripTrailingHardline(",
                    "                textToDoc(text, { parser: \"graphql\" })",
                    "              );",
                    "            } catch (_error) {",
                    "              // Bail if any part fails to parse.",
                    "              return null;",
                    "            }",
                    "          }",
                    "",
                    "          if (doc) {",
                    "            if (!isFirst && startsWithBlankLine) {",
                    "              parts.push(\"\");",
                    "            }",
                    "            parts.push(doc);",
                    "            if (!isLast && endsWithBlankLine) {",
                    "              parts.push(\"\");",
                    "            }",
                    "          } else if (!isFirst && !isLast && startsWithBlankLine) {",
                    "            parts.push(\"\");",
                    "          }",
                    "",
                    "          if (expressionDoc) {",
                    "            parts.push(concat([\"${\", expressionDoc, \"}\"]));",
                    "          }",
                    "        }",
                    "",
                    "        return concat([",
                    "          \"`\",",
                    "          indent(concat([hardline, join(hardline, parts)])),",
                    "          hardline,",
                    "          \"`\"",
                    "        ]);",
                    "      }",
                    "",
                    "      break;",
                    "    }",
                    "",
                    "    case \"TemplateElement\": {",
                    "      /**",
                    "       * md`...`",
                    "       * markdown`...`",
                    "       */",
                    "      if (",
                    "        parentParent &&",
                    "        (parentParent.type === \"TaggedTemplateExpression\" &&",
                    "          parent.quasis.length === 1 &&",
                    "          (parentParent.tag.type === \"Identifier\" &&",
                    "            (parentParent.tag.name === \"md\" ||",
                    "              parentParent.tag.name === \"markdown\")))",
                    "      ) {",
                    "        const text = parent.quasis[0].value.cooked;",
                    "        const indentation = getIndentation(text);",
                    "        const hasIndent = indentation !== \"\";",
                    "        return concat([",
                    "          hasIndent",
                    "            ? indent(",
                    "                concat([",
                    "                  softline,",
                    "                  printMarkdown(",
                    "                    text.replace(new RegExp(`^${indentation}`, \"gm\"), \"\")",
                    "                  )",
                    "                ])",
                    "              )",
                    "            : concat([literalline, dedentToRoot(printMarkdown(text))]),",
                    "          softline",
                    "        ]);",
                    "      }",
                    "",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  function printMarkdown(text) {",
                    "    const doc = textToDoc(text, { parser: \"markdown\", __inJsTemplate: true });",
                    "    return docUtils.stripTrailingHardline(escapeBackticks(doc));",
                    "  }",
                    "}",
                    "",
                    "function getIndentation(str) {",
                    "  const firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);",
                    "  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];",
                    "}",
                    "",
                    "function escapeBackticks(doc) {",
                    "  return util.mapDoc(doc, currentDoc => {",
                    "    if (!currentDoc.parts) {",
                    "      return currentDoc;",
                    "    }",
                    "",
                    "    const parts = [];",
                    "",
                    "    currentDoc.parts.forEach(part => {",
                    "      if (typeof part === \"string\") {",
                    "        parts.push(part.replace(/`/g, \"\\\\`\"));",
                    "      } else {",
                    "        parts.push(part);",
                    "      }",
                    "    });",
                    "",
                    "    return Object.assign({}, currentDoc, { parts });",
                    "  });",
                    "}",
                    "",
                    "function transformCssDoc(quasisDoc, path, print) {",
                    "  const parentNode = path.getValue();",
                    "",
                    "  const isEmpty =",
                    "    parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();",
                    "  if (isEmpty) {",
                    "    return \"``\";",
                    "  }",
                    "",
                    "  const expressionDocs = parentNode.expressions",
                    "    ? path.map(print, \"expressions\")",
                    "    : [];",
                    "  const newDoc = replacePlaceholders(quasisDoc, expressionDocs);",
                    "  /* istanbul ignore if */",
                    "  if (!newDoc) {",
                    "    throw new Error(\"Couldn't insert all the expressions\");",
                    "  }",
                    "  return concat([",
                    "    \"`\",",
                    "    indent(concat([hardline, docUtils.stripTrailingHardline(newDoc)])),",
                    "    softline,",
                    "    \"`\"",
                    "  ]);",
                    "}",
                    "",
                    "// Search all the placeholders in the quasisDoc tree",
                    "// and replace them with the expression docs one by one",
                    "// returns a new doc with all the placeholders replaced,",
                    "// or null if it couldn't replace any expression",
                    "function replacePlaceholders(quasisDoc, expressionDocs) {",
                    "  if (!expressionDocs || !expressionDocs.length) {",
                    "    return quasisDoc;",
                    "  }",
                    "",
                    "  const expressions = expressionDocs.slice();",
                    "  const newDoc = docUtils.mapDoc(quasisDoc, doc => {",
                    "    if (!doc || !doc.parts || !doc.parts.length) {",
                    "      return doc;",
                    "    }",
                    "    let parts = doc.parts;",
                    "    const atIndex = parts.indexOf(\"@\");",
                    "    const placeholderIndex = atIndex + 1;",
                    "    if (",
                    "      atIndex > -1 &&",
                    "      typeof parts[placeholderIndex] === \"string\" &&",
                    "      parts[placeholderIndex].startsWith(\"prettier-placeholder\")",
                    "    ) {",
                    "      // If placeholder is split, join it",
                    "      const at = parts[atIndex];",
                    "      const placeholder = parts[placeholderIndex];",
                    "      const rest = parts.slice(placeholderIndex + 1);",
                    "      parts = parts",
                    "        .slice(0, atIndex)",
                    "        .concat([at + placeholder])",
                    "        .concat(rest);",
                    "    }",
                    "    const atPlaceholderIndex = parts.findIndex(",
                    "      part =>",
                    "        typeof part === \"string\" && part.startsWith(\"@prettier-placeholder\")",
                    "    );",
                    "    if (atPlaceholderIndex > -1) {",
                    "      const placeholder = parts[atPlaceholderIndex];",
                    "      const rest = parts.slice(atPlaceholderIndex + 1);",
                    "",
                    "      // When the expression has a suffix appended, like:",
                    "      // animation: linear ${time}s ease-out;",
                    "      const suffix = placeholder.slice(\"@prettier-placeholder\".length);",
                    "",
                    "      const expression = expressions.shift();",
                    "      parts = parts",
                    "        .slice(0, atPlaceholderIndex)",
                    "        .concat([\"${\", expression, \"}\" + suffix])",
                    "        .concat(rest);",
                    "    }",
                    "    return Object.assign({}, doc, {",
                    "      parts: parts",
                    "    });",
                    "  });",
                    "",
                    "  return expressions.length === 0 ? newDoc : null;",
                    "}",
                    "",
                    "function printGraphqlComments(lines) {",
                    "  const parts = [];",
                    "  let seenComment = false;",
                    "",
                    "  lines.map(textLine => textLine.trim()).forEach((textLine, i, array) => {",
                    "    // Lines are either whitespace only, or a comment (with poential whitespace",
                    "    // around it). Drop whitespace-only lines.",
                    "    if (textLine === \"\") {",
                    "      return;",
                    "    }",
                    "",
                    "    if (array[i - 1] === \"\" && seenComment) {",
                    "      // If a non-first comment is preceded by a blank (whitespace only) line,",
                    "      // add in a blank line.",
                    "      parts.push(concat([hardline, textLine]));",
                    "    } else {",
                    "      parts.push(textLine);",
                    "    }",
                    "",
                    "    seenComment = true;",
                    "  });",
                    "",
                    "  // If `lines` was whitespace only, return `null`.",
                    "  return parts.length === 0 ? null : join(hardline, parts);",
                    "}",
                    "",
                    "/**",
                    " * Template literal in this context:",
                    " * <style jsx>{`div{color:red}`}</style>",
                    " */",
                    "function isStyledJsx(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "  return (",
                    "    parentParent &&",
                    "    node.quasis &&",
                    "    parent.type === \"JSXExpressionContainer\" &&",
                    "    parentParent.type === \"JSXElement\" &&",
                    "    parentParent.openingElement.name.name === \"style\" &&",
                    "    parentParent.openingElement.attributes.some(",
                    "      attribute => attribute.name.name === \"jsx\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * styled-components template literals",
                    " */",
                    "function isStyledComponents(path) {",
                    "  const parent = path.getParentNode();",
                    "",
                    "  if (!parent || parent.type !== \"TaggedTemplateExpression\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  const tag = parent.tag;",
                    "",
                    "  switch (tag.type) {",
                    "    case \"MemberExpression\":",
                    "      return (",
                    "        // styled.foo``",
                    "        isStyledIdentifier(tag.object) ||",
                    "        // Component.extend``",
                    "        (/^[A-Z]/.test(tag.object.name) && tag.property.name === \"extend\")",
                    "      );",
                    "",
                    "    case \"CallExpression\":",
                    "      return (",
                    "        // styled(Component)``",
                    "        isStyledIdentifier(tag.callee) ||",
                    "        (tag.callee.type === \"MemberExpression\" &&",
                    "          // styled.foo.attr({})``",
                    "          ((tag.callee.object.type === \"MemberExpression\" &&",
                    "            isStyledIdentifier(tag.callee.object.object)) ||",
                    "            // styled(Component).attr({})``",
                    "            (tag.callee.object.type === \"CallExpression\" &&",
                    "              isStyledIdentifier(tag.callee.object.callee))))",
                    "      );",
                    "",
                    "    case \"Identifier\":",
                    "      // css``",
                    "      return tag.name === \"css\";",
                    "",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * JSX element with CSS prop",
                    " */",
                    "function isCssProp(path) {",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "  return (",
                    "    parentParent &&",
                    "    parent.type === \"JSXExpressionContainer\" &&",
                    "    parentParent.type === \"JSXAttribute\" &&",
                    "    parentParent.name.type === \"JSXIdentifier\" &&",
                    "    parentParent.name.name === \"css\"",
                    "  );",
                    "}",
                    "",
                    "function isStyledIdentifier(node) {",
                    "  return node.type === \"Identifier\" && node.name === \"styled\";",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-estree\");",
                    "const hasPragma = require(\"./pragma\").hasPragma;",
                    "const options = require(\"./options\");",
                    "const privateUtil = require(\"../common/util\");",
                    "",
                    "// Based on:",
                    "// https://github.com/github/linguist/blob/master/lib/linguist/languages.yml",
                    "",
                    "const locStart = function(node) {",
                    "  // Handle nodes with decorators. They should start at the first decorator",
                    "  if (",
                    "    node.declaration &&",
                    "    node.declaration.decorators &&",
                    "    node.declaration.decorators.length > 0",
                    "  ) {",
                    "    return locStart(node.declaration.decorators[0]);",
                    "  }",
                    "  if (node.decorators && node.decorators.length > 0) {",
                    "    return locStart(node.decorators[0]);",
                    "  }",
                    "",
                    "  if (node.__location) {",
                    "    return node.__location.startOffset;",
                    "  }",
                    "  if (node.range) {",
                    "    return node.range[0];",
                    "  }",
                    "  if (typeof node.start === \"number\") {",
                    "    return node.start;",
                    "  }",
                    "  if (node.loc) {",
                    "    return node.loc.start;",
                    "  }",
                    "  return null;",
                    "};",
                    "",
                    "const locEnd = function(node) {",
                    "  const endNode = node.nodes && privateUtil.getLast(node.nodes);",
                    "  if (endNode && node.source && !node.source.end) {",
                    "    node = endNode;",
                    "  }",
                    "",
                    "  let loc;",
                    "  if (node.range) {",
                    "    loc = node.range[1];",
                    "  } else if (typeof node.end === \"number\") {",
                    "    loc = node.end;",
                    "  }",
                    "",
                    "  if (node.__location) {",
                    "    return node.__location.endOffset;",
                    "  }",
                    "  if (node.typeAnnotation) {",
                    "    return Math.max(loc, locEnd(node.typeAnnotation));",
                    "  }",
                    "",
                    "  if (node.loc && !loc) {",
                    "    return node.loc.end;",
                    "  }",
                    "",
                    "  return loc;",
                    "};",
                    "",
                    "const languages = [",
                    "  {",
                    "    name: \"JavaScript\",",
                    "    since: \"0.0.0\",",
                    "    parsers: [\"babylon\", \"flow\"],",
                    "    group: \"JavaScript\",",
                    "    tmScope: \"source.js\",",
                    "    aceMode: \"javascript\",",
                    "    codemirrorMode: \"javascript\",",
                    "    codemirrorMimeType: \"text/javascript\",",
                    "    aliases: [\"js\", \"node\"],",
                    "    extensions: [",
                    "      \".js\",",
                    "      \"._js\",",
                    "      \".bones\",",
                    "      \".es\",",
                    "      \".es6\",",
                    "      \".frag\",",
                    "      \".gs\",",
                    "      \".jake\",",
                    "      \".jsb\",",
                    "      \".jscad\",",
                    "      \".jsfl\",",
                    "      \".jsm\",",
                    "      \".jss\",",
                    "      \".mjs\",",
                    "      \".njs\",",
                    "      \".pac\",",
                    "      \".sjs\",",
                    "      \".ssjs\",",
                    "      \".xsjs\",",
                    "      \".xsjslib\"",
                    "    ],",
                    "    filenames: [\"Jakefile\"],",
                    "    linguistLanguageId: 183,",
                    "    vscodeLanguageIds: [\"javascript\"]",
                    "  },",
                    "  {",
                    "    name: \"JSX\",",
                    "    since: \"0.0.0\",",
                    "    parsers: [\"babylon\", \"flow\"],",
                    "    group: \"JavaScript\",",
                    "    extensions: [\".jsx\"],",
                    "    tmScope: \"source.js.jsx\",",
                    "    aceMode: \"javascript\",",
                    "    codemirrorMode: \"jsx\",",
                    "    codemirrorMimeType: \"text/jsx\",",
                    "    liguistLanguageId: 178,",
                    "    vscodeLanguageIds: [\"javascriptreact\"]",
                    "  },",
                    "  {",
                    "    name: \"TypeScript\",",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"typescript-eslint\"],",
                    "    group: \"JavaScript\",",
                    "    aliases: [\"ts\"],",
                    "    extensions: [\".ts\", \".tsx\"],",
                    "    tmScope: \"source.ts\",",
                    "    aceMode: \"typescript\",",
                    "    codemirrorMode: \"javascript\",",
                    "    codemirrorMimeType: \"application/typescript\",",
                    "    liguistLanguageId: 378,",
                    "    vscodeLanguageIds: [\"typescript\", \"typescriptreact\"]",
                    "  },",
                    "  {",
                    "    name: \"JSON\",",
                    "    since: \"1.5.0\",",
                    "    parsers: [\"json\"],",
                    "    group: \"JavaScript\",",
                    "    tmScope: \"source.json\",",
                    "    aceMode: \"json\",",
                    "    codemirrorMode: \"javascript\",",
                    "    codemirrorMimeType: \"application/json\",",
                    "    extensions: [",
                    "      \".json\",",
                    "      \".json5\",",
                    "      \".geojson\",",
                    "      \".JSON-tmLanguage\",",
                    "      \".topojson\"",
                    "    ],",
                    "    filenames: [",
                    "      \".arcconfig\",",
                    "      \".jshintrc\",",
                    "      \".babelrc\",",
                    "      \".eslintrc\",",
                    "      \".prettierrc\",",
                    "      \"composer.lock\",",
                    "      \"mcmod.info\"",
                    "    ],",
                    "    linguistLanguageId: 174,",
                    "    vscodeLanguageIds: [\"json\", \"jsonc\"]",
                    "  }",
                    "];",
                    "",
                    "const typescript = {",
                    "  get parse() {",
                    "    return eval(\"require\")(\"./parser-typescript\");",
                    "  },",
                    "  astFormat: \"estree\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd",
                    "};",
                    "",
                    "const babylon = {",
                    "  get parse() {",
                    "    return eval(\"require\")(\"./parser-babylon\");",
                    "  },",
                    "  astFormat: \"estree\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd",
                    "};",
                    "",
                    "const parsers = {",
                    "  babylon,",
                    "  json: Object.assign({}, babylon, {",
                    "    hasPragma() {",
                    "      return false;",
                    "    }",
                    "  }),",
                    "  flow: {",
                    "    get parse() {",
                    "      return eval(\"require\")(\"./parser-flow\");",
                    "    },",
                    "    astFormat: \"estree\",",
                    "    hasPragma,",
                    "    locStart,",
                    "    locEnd",
                    "  },",
                    "  \"typescript-eslint\": typescript,",
                    "  // TODO: Delete this in 2.0",
                    "  typescript",
                    "};",
                    "",
                    "const printers = {",
                    "  estree: printer",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  parsers,",
                    "  printers,",
                    "  locStart,",
                    "  locEnd",
                    "};"
                ]
            },
            "needs-parens.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "",
                    "const util = require(\"../common/util\");",
                    "",
                    "function needsParens(path, options) {",
                    "  const parent = path.getParentNode();",
                    "  if (!parent) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const name = path.getName();",
                    "  const node = path.getNode();",
                    "",
                    "  // If the value of this path is some child of a Node and not a Node",
                    "  // itself, then it doesn't need parentheses. Only Node objects (in",
                    "  // fact, only Expression nodes) need parentheses.",
                    "  if (path.getValue() !== node) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Only statements don't need parentheses.",
                    "  if (isStatement(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Closure compiler requires that type casted expressions to be surrounded by",
                    "  // parentheses.",
                    "  if (",
                    "    util.hasClosureCompilerTypeCastComment(",
                    "      options.originalText,",
                    "      node,",
                    "      options.locEnd",
                    "    )",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Identifiers never need parentheses.",
                    "  if (node.type === \"Identifier\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (parent.type === \"ParenthesizedExpression\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Add parens around the extends clause of a class. It is needed for almost",
                    "  // all expressions.",
                    "  if (",
                    "    (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") &&",
                    "    parent.superClass === node &&",
                    "    (node.type === \"ArrowFunctionExpression\" ||",
                    "      node.type === \"AssignmentExpression\" ||",
                    "      node.type === \"AwaitExpression\" ||",
                    "      node.type === \"BinaryExpression\" ||",
                    "      node.type === \"ConditionalExpression\" ||",
                    "      node.type === \"LogicalExpression\" ||",
                    "      node.type === \"NewExpression\" ||",
                    "      node.type === \"ObjectExpression\" ||",
                    "      node.type === \"ParenthesizedExpression\" ||",
                    "      node.type === \"SequenceExpression\" ||",
                    "      node.type === \"TaggedTemplateExpression\" ||",
                    "      node.type === \"UnaryExpression\" ||",
                    "      node.type === \"UpdateExpression\" ||",
                    "      node.type === \"YieldExpression\")",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    (parent.type === \"ArrowFunctionExpression\" &&",
                    "    parent.body === node &&",
                    "    node.type !== \"SequenceExpression\" && // these have parens added anyway",
                    "      util.startsWithNoLookaheadToken(",
                    "        node,",
                    "        /* forbidFunctionAndClass */ false",
                    "      )) ||",
                    "    (parent.type === \"ExpressionStatement\" &&",
                    "      util.startsWithNoLookaheadToken(node, /* forbidFunctionAndClass */ true))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"CallExpression\": {",
                    "      let firstParentNotMemberExpression = parent;",
                    "      let i = 0;",
                    "      while (",
                    "        firstParentNotMemberExpression &&",
                    "        firstParentNotMemberExpression.type === \"MemberExpression\"",
                    "      ) {",
                    "        firstParentNotMemberExpression = path.getParentNode(++i);",
                    "      }",
                    "",
                    "      if (",
                    "        firstParentNotMemberExpression.type === \"NewExpression\" &&",
                    "        firstParentNotMemberExpression.callee === path.getParentNode(i - 1)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      return false;",
                    "    }",
                    "",
                    "    case \"SpreadElement\":",
                    "    case \"SpreadProperty\":",
                    "      return (",
                    "        parent.type === \"MemberExpression\" &&",
                    "        name === \"object\" &&",
                    "        parent.object === node",
                    "      );",
                    "",
                    "    case \"UpdateExpression\":",
                    "      if (parent.type === \"UnaryExpression\") {",
                    "        return (",
                    "          node.prefix &&",
                    "          ((node.operator === \"++\" && parent.operator === \"+\") ||",
                    "            (node.operator === \"--\" && parent.operator === \"-\"))",
                    "        );",
                    "      }",
                    "    // else fallthrough",
                    "    case \"UnaryExpression\":",
                    "      switch (parent.type) {",
                    "        case \"UnaryExpression\":",
                    "          return (",
                    "            node.operator === parent.operator &&",
                    "            (node.operator === \"+\" || node.operator === \"-\")",
                    "          );",
                    "",
                    "        case \"MemberExpression\":",
                    "          return name === \"object\" && parent.object === node;",
                    "",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "          return name === \"callee\" && parent.callee === node;",
                    "",
                    "        case \"BinaryExpression\":",
                    "          return parent.operator === \"**\" && name === \"left\";",
                    "",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"BinaryExpression\": {",
                    "      if (parent.type === \"UpdateExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      const isLeftOfAForStatement = node => {",
                    "        let i = 0;",
                    "        while (node) {",
                    "          const parent = path.getParentNode(i++);",
                    "          if (!parent) {",
                    "            return false;",
                    "          }",
                    "          if (parent.type === \"ForStatement\" && parent.init === node) {",
                    "            return true;",
                    "          }",
                    "          node = parent;",
                    "        }",
                    "        return false;",
                    "      };",
                    "      if (node.operator === \"in\" && isLeftOfAForStatement(node)) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "    // fallthrough",
                    "    case \"TSTypeAssertionExpression\":",
                    "    case \"TSAsExpression\":",
                    "    case \"LogicalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"ConditionalExpression\":",
                    "          return node.type === \"TSAsExpression\";",
                    "",
                    "        case \"CallExpression\":",
                    "        case \"NewExpression\":",
                    "          return name === \"callee\" && parent.callee === node;",
                    "",
                    "        case \"ClassDeclaration\":",
                    "        case \"TSAbstractClassDeclaration\":",
                    "          return name === \"superClass\" && parent.superClass === node;",
                    "        case \"TSTypeAssertionExpression\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"ExperimentalSpreadProperty\":",
                    "        case \"BindExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"UpdateExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "          return name === \"object\" && parent.object === node;",
                    "",
                    "        case \"AssignmentExpression\":",
                    "          return (",
                    "            parent.left === node &&",
                    "            (node.type === \"TSTypeAssertionExpression\" ||",
                    "              node.type === \"TSAsExpression\")",
                    "          );",
                    "        case \"Decorator\":",
                    "          return (",
                    "            parent.expression === node &&",
                    "            (node.type === \"TSTypeAssertionExpression\" ||",
                    "              node.type === \"TSAsExpression\")",
                    "          );",
                    "",
                    "        case \"BinaryExpression\":",
                    "        case \"LogicalExpression\": {",
                    "          if (!node.operator && node.type !== \"TSTypeAssertionExpression\") {",
                    "            return true;",
                    "          }",
                    "",
                    "          const po = parent.operator;",
                    "          const pp = util.getPrecedence(po);",
                    "          const no = node.operator;",
                    "          const np = util.getPrecedence(no);",
                    "",
                    "          if (pp > np) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if ((po === \"||\" || po === \"??\") && no === \"&&\") {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (pp === np && name === \"right\") {",
                    "            assert.strictEqual(parent.right, node);",
                    "            return true;",
                    "          }",
                    "",
                    "          if (pp === np && !util.shouldFlatten(po, no)) {",
                    "            return true;",
                    "          }",
                    "",
                    "          // Add parenthesis when working with binary operators",
                    "          // It's not stricly needed but helps with code understanding",
                    "          if (util.isBitwiseOperator(po)) {",
                    "            return true;",
                    "          }",
                    "",
                    "          return false;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"TSParenthesizedType\": {",
                    "      const grandParent = path.getParentNode(1);",
                    "      if (",
                    "        (parent.type === \"TSTypeParameter\" ||",
                    "          parent.type === \"TypeParameter\" ||",
                    "          parent.type === \"VariableDeclarator\" ||",
                    "          parent.type === \"TSTypeAnnotation\" ||",
                    "          parent.type === \"GenericTypeAnnotation\" ||",
                    "          parent.type === \"TSTypeReference\") &&",
                    "        (node.typeAnnotation.type === \"TSTypeAnnotation\" &&",
                    "          node.typeAnnotation.typeAnnotation.type !== \"TSFunctionType\" &&",
                    "          grandParent.type !== \"TSTypeOperator\")",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "      // Delegate to inner TSParenthesizedType",
                    "      if (node.typeAnnotation.type === \"TSParenthesizedType\") {",
                    "        return false;",
                    "      }",
                    "      return true;",
                    "    }",
                    "",
                    "    case \"SequenceExpression\":",
                    "      switch (parent.type) {",
                    "        case \"ReturnStatement\":",
                    "          return false;",
                    "",
                    "        case \"ForStatement\":",
                    "          // Although parentheses wouldn't hurt around sequence",
                    "          // expressions in the head of for loops, traditional style",
                    "          // dictates that e.g. i++, j++ should not be wrapped with",
                    "          // parentheses.",
                    "          return false;",
                    "",
                    "        case \"ExpressionStatement\":",
                    "          return name !== \"expression\";",
                    "",
                    "        case \"ArrowFunctionExpression\":",
                    "          // We do need parentheses, but SequenceExpressions are handled",
                    "          // specially when printing bodies of arrow functions.",
                    "          return name !== \"body\";",
                    "",
                    "        default:",
                    "          // Otherwise err on the side of overparenthesization, adding",
                    "          // explicit exceptions above if this proves overzealous.",
                    "          return true;",
                    "      }",
                    "",
                    "    case \"YieldExpression\":",
                    "      if (",
                    "        parent.type === \"UnaryExpression\" ||",
                    "        parent.type === \"AwaitExpression\" ||",
                    "        parent.type === \"TSAsExpression\" ||",
                    "        parent.type === \"TSNonNullExpression\"",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // else fallthrough",
                    "    case \"AwaitExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"BinaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"ExperimentalSpreadProperty\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "          return parent.object === node;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "          return parent.callee === node;",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return parent.test === node;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ArrayTypeAnnotation\":",
                    "      return parent.type === \"NullableTypeAnnotation\";",
                    "",
                    "    case \"IntersectionTypeAnnotation\":",
                    "    case \"UnionTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        parent.type === \"NullableTypeAnnotation\" ||",
                    "        parent.type === \"IntersectionTypeAnnotation\" ||",
                    "        parent.type === \"UnionTypeAnnotation\"",
                    "      );",
                    "",
                    "    case \"NullableTypeAnnotation\":",
                    "      return parent.type === \"ArrayTypeAnnotation\";",
                    "",
                    "    case \"FunctionTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"UnionTypeAnnotation\" ||",
                    "        parent.type === \"IntersectionTypeAnnotation\" ||",
                    "        parent.type === \"ArrayTypeAnnotation\"",
                    "      );",
                    "",
                    "    case \"StringLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"Literal\":",
                    "      if (",
                    "        typeof node.value === \"string\" &&",
                    "        parent.type === \"ExpressionStatement\" &&",
                    "        // TypeScript workaround for eslint/typescript-eslint-parser#267",
                    "        // See corresponding workaround in printer.js case: \"Literal\"",
                    "        ((options.parser !== \"typescript\" && !parent.directive) ||",
                    "          (options.parser === \"typescript\" &&",
                    "            options.originalText.substr(options.locStart(node) - 1, 1) === \"(\"))",
                    "      ) {",
                    "        // To avoid becoming a directive",
                    "        const grandParent = path.getParentNode(1);",
                    "",
                    "        return (",
                    "          grandParent.type === \"Program\" ||",
                    "          grandParent.type === \"BlockStatement\"",
                    "        );",
                    "      }",
                    "",
                    "      return (",
                    "        parent.type === \"MemberExpression\" &&",
                    "        typeof node.value === \"number\" &&",
                    "        name === \"object\" &&",
                    "        parent.object === node",
                    "      );",
                    "",
                    "    case \"AssignmentExpression\": {",
                    "      const grandParent = path.getParentNode(1);",
                    "",
                    "      if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {",
                    "        return true;",
                    "      } else if (",
                    "        parent.type === \"ClassProperty\" &&",
                    "        parent.key === node &&",
                    "        parent.computed",
                    "      ) {",
                    "        return false;",
                    "      } else if (",
                    "        parent.type === \"TSPropertySignature\" &&",
                    "        parent.name === node",
                    "      ) {",
                    "        return false;",
                    "      } else if (",
                    "        parent.type === \"ForStatement\" &&",
                    "        (parent.init === node || parent.update === node)",
                    "      ) {",
                    "        return false;",
                    "      } else if (parent.type === \"ExpressionStatement\") {",
                    "        return node.left.type === \"ObjectPattern\";",
                    "      } else if (parent.type === \"TSPropertySignature\" && parent.key === node) {",
                    "        return false;",
                    "      } else if (parent.type === \"AssignmentExpression\") {",
                    "        return false;",
                    "      } else if (",
                    "        parent.type === \"SequenceExpression\" &&",
                    "        grandParent &&",
                    "        grandParent.type === \"ForStatement\" &&",
                    "        (grandParent.init === parent || grandParent.update === parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "      return true;",
                    "    }",
                    "    case \"ConditionalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"ExperimentalSpreadProperty\":",
                    "        case \"BinaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"ExportDefaultDeclaration\":",
                    "        case \"AwaitExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"TSTypeAssertionExpression\":",
                    "        case \"TypeCastExpression\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "          return name === \"callee\" && parent.callee === node;",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\" && parent.test === node;",
                    "",
                    "        case \"MemberExpression\":",
                    "          return name === \"object\" && parent.object === node;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"FunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"CallExpression\":",
                    "          return name === \"callee\"; // Not strictly necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true; // This is basically a kind of IIFE.",
                    "        case \"ExportDefaultDeclaration\":",
                    "          return true;",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ArrowFunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"CallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"NewExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"MemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"TSAsExpression\":",
                    "        case \"BindExpression\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"BinaryExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSTypeAssertionExpression\":",
                    "          return true;",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ClassExpression\":",
                    "      return parent.type === \"ExportDefaultDeclaration\";",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isStatement(node) {",
                    "  return (",
                    "    node.type === \"BlockStatement\" ||",
                    "    node.type === \"BreakStatement\" ||",
                    "    node.type === \"ClassBody\" ||",
                    "    node.type === \"ClassDeclaration\" ||",
                    "    node.type === \"ClassMethod\" ||",
                    "    node.type === \"ClassProperty\" ||",
                    "    node.type === \"ClassPrivateProperty\" ||",
                    "    node.type === \"ContinueStatement\" ||",
                    "    node.type === \"DebuggerStatement\" ||",
                    "    node.type === \"DeclareClass\" ||",
                    "    node.type === \"DeclareExportAllDeclaration\" ||",
                    "    node.type === \"DeclareExportDeclaration\" ||",
                    "    node.type === \"DeclareFunction\" ||",
                    "    node.type === \"DeclareInterface\" ||",
                    "    node.type === \"DeclareModule\" ||",
                    "    node.type === \"DeclareModuleExports\" ||",
                    "    node.type === \"DeclareVariable\" ||",
                    "    node.type === \"DoWhileStatement\" ||",
                    "    node.type === \"ExportAllDeclaration\" ||",
                    "    node.type === \"ExportDefaultDeclaration\" ||",
                    "    node.type === \"ExportNamedDeclaration\" ||",
                    "    node.type === \"ExpressionStatement\" ||",
                    "    node.type === \"ForAwaitStatement\" ||",
                    "    node.type === \"ForInStatement\" ||",
                    "    node.type === \"ForOfStatement\" ||",
                    "    node.type === \"ForStatement\" ||",
                    "    node.type === \"FunctionDeclaration\" ||",
                    "    node.type === \"IfStatement\" ||",
                    "    node.type === \"ImportDeclaration\" ||",
                    "    node.type === \"InterfaceDeclaration\" ||",
                    "    node.type === \"LabeledStatement\" ||",
                    "    node.type === \"MethodDefinition\" ||",
                    "    node.type === \"ReturnStatement\" ||",
                    "    node.type === \"SwitchStatement\" ||",
                    "    node.type === \"ThrowStatement\" ||",
                    "    node.type === \"TryStatement\" ||",
                    "    node.type === \"TSAbstractClassDeclaration\" ||",
                    "    node.type === \"TSEnumDeclaration\" ||",
                    "    node.type === \"TSImportEqualsDeclaration\" ||",
                    "    node.type === \"TSInterfaceDeclaration\" ||",
                    "    node.type === \"TSModuleDeclaration\" ||",
                    "    node.type === \"TSNamespaceExportDeclaration\" ||",
                    "    node.type === \"TypeAlias\" ||",
                    "    node.type === \"VariableDeclaration\" ||",
                    "    node.type === \"WhileStatement\" ||",
                    "    node.type === \"WithStatement\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = needsParens;"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const CATEGORY_JAVASCRIPT = \"JavaScript\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/common/support.js",
                    "module.exports = {",
                    "  arrowParens: {",
                    "    since: \"1.9.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"avoid\",",
                    "    description: \"Include parentheses around a sole arrow function parameter.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"avoid\",",
                    "        description: \"Omit parens when possible. Example: `x => x`\"",
                    "      },",
                    "      {",
                    "        value: \"always\",",
                    "        description: \"Always include parens. Example: `(x) => x`\"",
                    "      }",
                    "    ]",
                    "  },",
                    "  bracketSpacing: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print spaces between brackets.\",",
                    "    oppositeDescription: \"Do not print spaces between brackets.\"",
                    "  },",
                    "  jsxBracketSameLine: {",
                    "    since: \"0.17.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Put > on the last line instead of at a new line.\"",
                    "  },",
                    "  semi: {",
                    "    since: \"1.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print semicolons.\",",
                    "    oppositeDescription:",
                    "      \"Do not print semicolons, except at the beginning of lines which may need them.\"",
                    "  },",
                    "  singleQuote: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes instead of double quotes.\"",
                    "  },",
                    "  trailingComma: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"0.0.0\", value: false },",
                    "      { since: \"0.19.0\", value: \"none\" }",
                    "    ],",
                    "    description: \"Print trailing commas wherever possible when multi-line.\",",
                    "    choices: [",
                    "      { value: \"none\", description: \"No trailing commas.\" },",
                    "      {",
                    "        value: \"es5\",",
                    "        description:",
                    "          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\"",
                    "      },",
                    "      {",
                    "        value: \"all\",",
                    "        description:",
                    "          \"Trailing commas wherever possible (including function arguments).\"",
                    "      },",
                    "      { value: true, deprecated: \"0.19.0\", redirect: \"es5\" },",
                    "      { value: false, deprecated: \"0.19.0\", redirect: \"none\" }",
                    "    ]",
                    "  }",
                    "};"
                ]
            },
            "parser-babylon.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "",
                    "function parse(text, parsers, opts) {",
                    "  // Inline the require to avoid loading all the JS if we don't use it",
                    "  const babylon = require(\"babylon\");",
                    "",
                    "  const babylonOptions = {",
                    "    sourceType: \"module\",",
                    "    allowImportExportEverywhere: true,",
                    "    allowReturnOutsideFunction: true,",
                    "    plugins: [",
                    "      \"jsx\",",
                    "      \"flow\",",
                    "      \"doExpressions\",",
                    "      \"objectRestSpread\",",
                    "      \"decorators\",",
                    "      \"classProperties\",",
                    "      \"exportDefaultFrom\",",
                    "      \"exportNamespaceFrom\",",
                    "      \"asyncGenerators\",",
                    "      \"functionBind\",",
                    "      \"functionSent\",",
                    "      \"dynamicImport\",",
                    "      \"numericSeparator\",",
                    "      \"importMeta\",",
                    "      \"optionalCatchBinding\",",
                    "      \"optionalChaining\",",
                    "      \"classPrivateProperties\",",
                    "      \"pipelineOperator\",",
                    "      \"nullishCoalescingOperator\"",
                    "    ]",
                    "  };",
                    "",
                    "  const parseMethod =",
                    "    opts && opts.parser === \"json\" ? \"parseExpression\" : \"parse\";",
                    "",
                    "  let ast;",
                    "  try {",
                    "    ast = babylon[parseMethod](text, babylonOptions);",
                    "  } catch (originalError) {",
                    "    try {",
                    "      ast = babylon[parseMethod](",
                    "        text,",
                    "        Object.assign({}, babylonOptions, { strictMode: false })",
                    "      );",
                    "    } catch (nonStrictError) {",
                    "      throw createError(",
                    "        // babel error prints (l:c) with cols that are zero indexed",
                    "        // so we need our custom error",
                    "        originalError.message.replace(/ \\(.*\\)/, \"\"),",
                    "        {",
                    "          start: {",
                    "            line: originalError.loc.line,",
                    "            column: originalError.loc.column + 1",
                    "          }",
                    "        }",
                    "      );",
                    "    }",
                    "  }",
                    "  delete ast.tokens;",
                    "  return ast;",
                    "}",
                    "",
                    "module.exports = parse;"
                ]
            },
            "parser-flow.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const includeShebang = require(\"../common/parser-include-shebang\");",
                    "",
                    "function parse(text /*, parsers, opts*/) {",
                    "  // Fixes Node 4 issue (#1986)",
                    "  \"use strict\"; // eslint-disable-line",
                    "  // Inline the require to avoid loading all the JS if we don't use it",
                    "  const flowParser = require(\"flow-parser\");",
                    "",
                    "  const ast = flowParser.parse(text, {",
                    "    esproposal_class_instance_fields: true,",
                    "    esproposal_class_static_fields: true,",
                    "    esproposal_export_star_as: true",
                    "  });",
                    "",
                    "  if (ast.errors.length > 0) {",
                    "    const loc = ast.errors[0].loc;",
                    "    throw createError(ast.errors[0].message, {",
                    "      start: { line: loc.start.line, column: loc.start.column + 1 },",
                    "      end: { line: loc.end.line, column: loc.end.column + 1 }",
                    "    });",
                    "  }",
                    "",
                    "  includeShebang(text, ast);",
                    "  return ast;",
                    "}",
                    "module.exports = parse;"
                ]
            },
            "parser-typescript.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const includeShebang = require(\"../common/parser-include-shebang\");",
                    "",
                    "function parse(text /*, parsers, opts*/) {",
                    "  const jsx = isProbablyJsx(text);",
                    "  let ast;",
                    "  try {",
                    "    try {",
                    "      // Try passing with our best guess first.",
                    "      ast = tryParseTypeScript(text, jsx);",
                    "    } catch (e) {",
                    "      // But if we get it wrong, try the opposite.",
                    "      /* istanbul ignore next */",
                    "      ast = tryParseTypeScript(text, !jsx);",
                    "    }",
                    "  } catch (e) /* istanbul ignore next */ {",
                    "    if (typeof e.lineNumber === \"undefined\") {",
                    "      throw e;",
                    "    }",
                    "",
                    "    throw createError(e.message, {",
                    "      start: { line: e.lineNumber, column: e.column + 1 }",
                    "    });",
                    "  }",
                    "",
                    "  delete ast.tokens;",
                    "  includeShebang(text, ast);",
                    "  return ast;",
                    "}",
                    "",
                    "function tryParseTypeScript(text, jsx) {",
                    "  const parser = require(\"typescript-eslint-parser\");",
                    "  return parser.parse(text, {",
                    "    loc: true,",
                    "    range: true,",
                    "    tokens: true,",
                    "    comment: true,",
                    "    useJSXTextNode: true,",
                    "    ecmaFeatures: { jsx },",
                    "    // Override logger function with noop,",
                    "    // to avoid unsupported version errors being logged",
                    "    loggerFn: () => {}",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * Use a naive regular expression to detect JSX",
                    " */",
                    "function isProbablyJsx(text) {",
                    "  return new RegExp(",
                    "    [",
                    "      \"(^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string",
                    "      \"|\",",
                    "      \"(^[^/]{2}.*/>)\" // Contains \"/>\" on line not starting with \"//\"",
                    "    ].join(\"\"),",
                    "    \"m\"",
                    "  ).test(text);",
                    "}",
                    "",
                    "module.exports = parse;"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const docblock = require(\"jest-docblock\");",
                    "",
                    "function hasPragma(text) {",
                    "  const pragmas = Object.keys(docblock.parse(docblock.extract(text)));",
                    "  return pragmas.indexOf(\"prettier\") !== -1 || pragmas.indexOf(\"format\") !== -1;",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  const parsedDocblock = docblock.parseWithComments(docblock.extract(text));",
                    "  const pragmas = Object.assign({ format: \"\" }, parsedDocblock.pragmas);",
                    "  const newDocblock = docblock.print({",
                    "    pragmas,",
                    "    comments: parsedDocblock.comments.replace(/^(\\s+?\\r?\\n)+/, \"\") // remove leading newlines",
                    "  });",
                    "  const strippedText = docblock.strip(text);",
                    "  const separatingNewlines = strippedText.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\";",
                    "  return newDocblock + separatingNewlines + strippedText;",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma",
                    "};"
                ]
            },
            "printer-estree.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
                    "const comments = require(\"../main/comments\");",
                    "const privateUtil = require(\"../common/util\");",
                    "const sharedUtil = require(\"../common/util-shared\");",
                    "const isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES6;",
                    "const embed = require(\"./embed\");",
                    "const clean = require(\"./clean\");",
                    "const insertPragma = require(\"./pragma\").insertPragma;",
                    "const handleComments = require(\"./comments\");",
                    "const pathNeedsParens = require(\"./needs-parens\");",
                    "",
                    "const doc = require(\"../doc\");",
                    "const docBuilders = doc.builders;",
                    "const concat = docBuilders.concat;",
                    "const join = docBuilders.join;",
                    "const line = docBuilders.line;",
                    "const hardline = docBuilders.hardline;",
                    "const softline = docBuilders.softline;",
                    "const literalline = docBuilders.literalline;",
                    "const group = docBuilders.group;",
                    "const indent = docBuilders.indent;",
                    "const align = docBuilders.align;",
                    "const conditionalGroup = docBuilders.conditionalGroup;",
                    "const fill = docBuilders.fill;",
                    "const ifBreak = docBuilders.ifBreak;",
                    "const breakParent = docBuilders.breakParent;",
                    "const lineSuffixBoundary = docBuilders.lineSuffixBoundary;",
                    "const addAlignmentToDoc = docBuilders.addAlignmentToDoc;",
                    "const dedent = docBuilders.dedent;",
                    "",
                    "const docUtils = doc.utils;",
                    "const willBreak = docUtils.willBreak;",
                    "const isLineNext = docUtils.isLineNext;",
                    "const isEmpty = docUtils.isEmpty;",
                    "const rawText = docUtils.rawText;",
                    "",
                    "function shouldPrintComma(options, level) {",
                    "  level = level || \"es5\";",
                    "",
                    "  switch (options.trailingComma) {",
                    "    case \"all\":",
                    "      if (level === \"all\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"es5\":",
                    "      if (level === \"es5\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"none\":",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function genericPrint(path, options, printPath, args) {",
                    "  const node = path.getValue();",
                    "  let needsParens = false;",
                    "  const linesWithoutParens = printPathNoParens(path, options, printPath, args);",
                    "",
                    "  if (!node || isEmpty(linesWithoutParens)) {",
                    "    return linesWithoutParens;",
                    "  }",
                    "",
                    "  const decorators = [];",
                    "  if (",
                    "    node.decorators &&",
                    "    node.decorators.length > 0 &&",
                    "    // If the parent node is an export declaration, it will be",
                    "    // responsible for printing node.decorators.",
                    "    !privateUtil.getParentExportDeclaration(path)",
                    "  ) {",
                    "    let separator = hardline;",
                    "    path.each(decoratorPath => {",
                    "      let prefix = \"@\";",
                    "      let decorator = decoratorPath.getValue();",
                    "      if (decorator.expression) {",
                    "        decorator = decorator.expression;",
                    "        prefix = \"\";",
                    "      }",
                    "",
                    "      if (",
                    "        node.decorators.length === 1 &&",
                    "        node.type !== \"ClassDeclaration\" &&",
                    "        node.type !== \"MethodDefinition\" &&",
                    "        node.type !== \"ClassMethod\" &&",
                    "        (decorator.type === \"Identifier\" ||",
                    "          decorator.type === \"MemberExpression\" ||",
                    "          (decorator.type === \"CallExpression\" &&",
                    "            (decorator.arguments.length === 0 ||",
                    "              (decorator.arguments.length === 1 &&",
                    "                (isStringLiteral(decorator.arguments[0]) ||",
                    "                  decorator.arguments[0].type === \"Identifier\" ||",
                    "                  decorator.arguments[0].type === \"MemberExpression\")))))",
                    "      ) {",
                    "        separator = line;",
                    "      }",
                    "",
                    "      decorators.push(prefix, printPath(decoratorPath), separator);",
                    "    }, \"decorators\");",
                    "  } else if (",
                    "    privateUtil.isExportDeclaration(node) &&",
                    "    node.declaration &&",
                    "    node.declaration.decorators",
                    "  ) {",
                    "    // Export declarations are responsible for printing any decorators",
                    "    // that logically apply to node.declaration.",
                    "    path.each(",
                    "      decoratorPath => {",
                    "        const decorator = decoratorPath.getValue();",
                    "        const prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";",
                    "        decorators.push(prefix, printPath(decoratorPath), hardline);",
                    "      },",
                    "      \"declaration\",",
                    "      \"decorators\"",
                    "    );",
                    "  } else {",
                    "    // Nodes with decorators can't have parentheses, so we can avoid",
                    "    // computing pathNeedsParens() except in this case.",
                    "    needsParens = pathNeedsParens(path, options);",
                    "  }",
                    "",
                    "  const parts = [];",
                    "  if (needsParens) {",
                    "    parts.unshift(\"(\");",
                    "  }",
                    "",
                    "  parts.push(linesWithoutParens);",
                    "",
                    "  if (needsParens) {",
                    "    parts.push(\")\");",
                    "  }",
                    "",
                    "  if (decorators.length > 0) {",
                    "    return group(concat(decorators.concat(parts)));",
                    "  }",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  return privateUtil.hasIgnoreComment(path) || hasJsxIgnoreComment(path);",
                    "}",
                    "",
                    "function hasJsxIgnoreComment(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Lookup the previous sibling, ignoring any empty JSXText elements",
                    "  const index = parent.children.indexOf(node);",
                    "  let prevSibling = null;",
                    "  for (let i = index; i > 0; i--) {",
                    "    const candidate = parent.children[i - 1];",
                    "    if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {",
                    "      continue;",
                    "    }",
                    "    prevSibling = candidate;",
                    "    break;",
                    "  }",
                    "",
                    "  return (",
                    "    prevSibling &&",
                    "    prevSibling.type === \"JSXExpressionContainer\" &&",
                    "    prevSibling.expression.type === \"JSXEmptyExpression\" &&",
                    "    prevSibling.expression.comments &&",
                    "    prevSibling.expression.comments.find(",
                    "      comment => comment.value.trim() === \"prettier-ignore\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "// The following is the shared logic for",
                    "// ternary operators, namely ConditionalExpression",
                    "// and TSConditionalType",
                    "function formatTernaryOperator(path, options, print, operatorOptions) {",
                    "  const n = path.getValue();",
                    "  const parts = [];",
                    "  const operatorOpts = Object.assign(",
                    "    {",
                    "      beforeParts: () => [\"\"],",
                    "      afterParts: () => [\"\"],",
                    "      shouldCheckJsx: true,",
                    "      operatorName: \"ConditionalExpression\",",
                    "      consequentNode: \"consequent\",",
                    "      alternateNode: \"alternate\",",
                    "      testNode: \"test\"",
                    "    },",
                    "    operatorOptions || {}",
                    "  );",
                    "",
                    "  // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".",
                    "  // See tests/jsx/conditional-expression.js for more info.",
                    "  let jsxMode = false;",
                    "  const parent = path.getParentNode();",
                    "  let forceNoIndent = parent.type === operatorOpts.operatorName;",
                    "",
                    "  // Find the outermost non-ConditionalExpression parent, and the outermost",
                    "  // ConditionalExpression parent. We'll use these to determine if we should",
                    "  // print in JSX mode.",
                    "  let currentParent;",
                    "  let previousParent;",
                    "  let i = 0;",
                    "  do {",
                    "    previousParent = currentParent || n;",
                    "    currentParent = path.getParentNode(i);",
                    "    i++;",
                    "  } while (currentParent && currentParent.type === operatorOpts.operatorName);",
                    "  const firstNonConditionalParent = currentParent || parent;",
                    "  const lastConditionalParent = previousParent;",
                    "",
                    "  if (",
                    "    (operatorOpts.shouldCheckJsx && isJSXNode(n[operatorOpts.testNode])) ||",
                    "    isJSXNode(n[operatorOpts.consequentNode]) ||",
                    "    isJSXNode(n[operatorOpts.alternateNode]) ||",
                    "    conditionalExpressionChainContainsJSX(lastConditionalParent)",
                    "  ) {",
                    "    jsxMode = true;",
                    "    forceNoIndent = true;",
                    "",
                    "    // Even though they don't need parens, we wrap (almost) everything in",
                    "    // parens when using ?: within JSX, because the parens are analogous to",
                    "    // curly braces in an if statement.",
                    "    const wrap = doc =>",
                    "      concat([",
                    "        ifBreak(\"(\", \"\"),",
                    "        indent(concat([softline, doc])),",
                    "        softline,",
                    "        ifBreak(\")\", \"\")",
                    "      ]);",
                    "",
                    "    // The only things we don't wrap are:",
                    "    // * Nested conditional expressions in alternates",
                    "    // * null",
                    "    const isNull = node =>",
                    "      node.type === \"NullLiteral\" ||",
                    "      (node.type === \"Literal\" && node.value === null);",
                    "",
                    "    parts.push(",
                    "      \" ? \",",
                    "      isNull(n[operatorOpts.consequentNode])",
                    "        ? path.call(print, operatorOpts.consequentNode)",
                    "        : wrap(path.call(print, operatorOpts.consequentNode)),",
                    "      \" : \",",
                    "      n[operatorOpts.alternateNode].type === operatorOpts.operatorName ||",
                    "      isNull(n[operatorOpts.alternateNode])",
                    "        ? path.call(print, operatorOpts.alternateNode)",
                    "        : wrap(path.call(print, operatorOpts.alternateNode))",
                    "    );",
                    "  } else {",
                    "    // normal mode",
                    "    const part = concat([",
                    "      line,",
                    "      \"? \",",
                    "      n[operatorOpts.consequentNode].type === operatorOpts.operatorName",
                    "        ? ifBreak(\"\", \"(\")",
                    "        : \"\",",
                    "      align(2, path.call(print, operatorOpts.consequentNode)),",
                    "      n[operatorOpts.consequentNode].type === operatorOpts.operatorName",
                    "        ? ifBreak(\"\", \")\")",
                    "        : \"\",",
                    "      line,",
                    "      \": \",",
                    "      align(2, path.call(print, operatorOpts.alternateNode))",
                    "    ]);",
                    "    parts.push(",
                    "      parent.type === operatorOpts.operatorName",
                    "        ? options.useTabs",
                    "          ? dedent(indent(part))",
                    "          : align(Math.max(0, options.tabWidth - 2), part)",
                    "        : part",
                    "    );",
                    "  }",
                    "",
                    "  // In JSX mode, we want a whole chain of ConditionalExpressions to all",
                    "  // break if any of them break. That means we should only group around the",
                    "  // outer-most ConditionalExpression.",
                    "  const maybeGroup = doc =>",
                    "    jsxMode",
                    "      ? parent === firstNonConditionalParent ? group(doc) : doc",
                    "      : group(doc); // Always group in normal mode.",
                    "",
                    "  // Break the closing paren to keep the chain right after it:",
                    "  // (a",
                    "  //   ? b",
                    "  //   : c",
                    "  // ).call()",
                    "  const breakClosingParen =",
                    "    !jsxMode && parent.type === \"MemberExpression\" && !parent.computed;",
                    "",
                    "  return maybeGroup(",
                    "    concat(",
                    "      [].concat(",
                    "        operatorOpts.beforeParts(),",
                    "        forceNoIndent ? concat(parts) : indent(concat(parts)),",
                    "        operatorOpts.afterParts(breakClosingParen)",
                    "      )",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function getTypeScriptMappedTypeModifier(tokenNode, keyword) {",
                    "  if (tokenNode.type === \"TSPlusToken\") {",
                    "    return \"+\" + keyword;",
                    "  } else if (tokenNode.type === \"TSMinusToken\") {",
                    "    return \"-\" + keyword;",
                    "  }",
                    "  return keyword;",
                    "}",
                    "",
                    "function printPathNoParens(path, options, print, args) {",
                    "  const n = path.getValue();",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "",
                    "  if (!n) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof n === \"string\") {",
                    "    return n;",
                    "  }",
                    "",
                    "  let parts = [];",
                    "  switch (n.type) {",
                    "    case \"File\":",
                    "      return path.call(print, \"program\");",
                    "    case \"Program\":",
                    "      // Babel 6",
                    "      if (n.directives) {",
                    "        path.each(childPath => {",
                    "          parts.push(print(childPath), semi, hardline);",
                    "          if (",
                    "            sharedUtil.isNextLineEmpty(",
                    "              options.originalText,",
                    "              childPath.getValue(),",
                    "              options",
                    "            )",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }, \"directives\");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        path.call(bodyPath => {",
                    "          return printStatementSequence(bodyPath, options, print);",
                    "        }, \"body\")",
                    "      );",
                    "",
                    "      parts.push(",
                    "        comments.printDanglingComments(path, options, /* sameIndent */ true)",
                    "      );",
                    "",
                    "      // Only force a trailing newline if there were any contents.",
                    "      if (n.body.length || n.comments) {",
                    "        parts.push(hardline);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    // Babel extension.",
                    "    case \"EmptyStatement\":",
                    "      return \"\";",
                    "    case \"ExpressionStatement\":",
                    "      // Detect Flow-parsed directives",
                    "      if (n.directive) {",
                    "        return concat([nodeStr(n.expression, options, true), semi]);",
                    "      }",
                    "      // Do not append semicolon after the only JSX element in a program",
                    "      return concat([",
                    "        path.call(print, \"expression\"),",
                    "        isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi",
                    "      ]); // Babel extension.",
                    "    case \"ParenthesizedExpression\":",
                    "      return concat([\"(\", path.call(print, \"expression\"), \")\"]);",
                    "    case \"AssignmentExpression\":",
                    "      return printAssignment(",
                    "        n.left,",
                    "        path.call(print, \"left\"),",
                    "        concat([\" \", n.operator]),",
                    "        n.right,",
                    "        path.call(print, \"right\"),",
                    "        options",
                    "      );",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\": {",
                    "      const parent = path.getParentNode();",
                    "      const parentParent = path.getParentNode(1);",
                    "      const isInsideParenthesis =",
                    "        n !== parent.body &&",
                    "        (parent.type === \"IfStatement\" ||",
                    "          parent.type === \"WhileStatement\" ||",
                    "          parent.type === \"DoWhileStatement\");",
                    "",
                    "      const parts = printBinaryishExpressions(",
                    "        path,",
                    "        print,",
                    "        options,",
                    "        /* isNested */ false,",
                    "        isInsideParenthesis",
                    "      );",
                    "",
                    "      //   if (",
                    "      //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft",
                    "      //   ) {",
                    "      //",
                    "      // looks super weird, we want to break the children if the parent breaks",
                    "      //",
                    "      //   if (",
                    "      //     this.hasPlugin(\"dynamicImports\") &&",
                    "      //     this.lookahead().type === tt.parenLeft",
                    "      //   ) {",
                    "      if (isInsideParenthesis) {",
                    "        return concat(parts);",
                    "      }",
                    "",
                    "      // Break between the parens in unaries or in a member expression, i.e.",
                    "      //",
                    "      //   (",
                    "      //     a &&",
                    "      //     b &&",
                    "      //     c",
                    "      //   ).call()",
                    "      if (",
                    "        parent.type === \"UnaryExpression\" ||",
                    "        (parent.type === \"MemberExpression\" && !parent.computed)",
                    "      ) {",
                    "        return group(",
                    "          concat([indent(concat([softline, concat(parts)])), softline])",
                    "        );",
                    "      }",
                    "",
                    "      // Avoid indenting sub-expressions in some cases where the first sub-expression is already",
                    "      // indented accordingly. We should indent sub-expressions where the first case isn't indented.",
                    "      const shouldNotIndent =",
                    "        parent.type === \"ReturnStatement\" ||",
                    "        (parent.type === \"JSXExpressionContainer\" &&",
                    "          parentParent.type === \"JSXAttribute\") ||",
                    "        (n === parent.body && parent.type === \"ArrowFunctionExpression\") ||",
                    "        (n !== parent.body && parent.type === \"ForStatement\") ||",
                    "        (parent.type === \"ConditionalExpression\" &&",
                    "          parentParent.type !== \"ReturnStatement\");",
                    "",
                    "      const shouldIndentIfInlining =",
                    "        parent.type === \"AssignmentExpression\" ||",
                    "        parent.type === \"VariableDeclarator\" ||",
                    "        parent.type === \"ClassProperty\" ||",
                    "        parent.type === \"TSAbstractClassProperty\" ||",
                    "        parent.type === \"ClassPrivateProperty\" ||",
                    "        parent.type === \"ObjectProperty\" ||",
                    "        parent.type === \"Property\";",
                    "",
                    "      const samePrecedenceSubExpression =",
                    "        isBinaryish(n.left) &&",
                    "        privateUtil.shouldFlatten(n.operator, n.left.operator);",
                    "",
                    "      if (",
                    "        shouldNotIndent ||",
                    "        (shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression) ||",
                    "        (!shouldInlineLogicalExpression(n) && shouldIndentIfInlining)",
                    "      ) {",
                    "        return group(concat(parts));",
                    "      }",
                    "",
                    "      const rest = concat(parts.slice(1));",
                    "",
                    "      return group(",
                    "        concat([",
                    "          // Don't include the initial expression in the indentation",
                    "          // level. The first item is guaranteed to be the first",
                    "          // left-most expression.",
                    "          parts.length > 0 ? parts[0] : \"\",",
                    "          indent(rest)",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"AssignmentPattern\":",
                    "      return concat([",
                    "        path.call(print, \"left\"),",
                    "        \" = \",",
                    "        path.call(print, \"right\")",
                    "      ]);",
                    "    case \"TSTypeAssertionExpression\":",
                    "      return concat([",
                    "        \"<\",",
                    "        path.call(print, \"typeAnnotation\"),",
                    "        \">\",",
                    "        path.call(print, \"expression\")",
                    "      ]);",
                    "    case \"MemberExpression\": {",
                    "      const parent = path.getParentNode();",
                    "      let firstNonMemberParent;",
                    "      let i = 0;",
                    "      do {",
                    "        firstNonMemberParent = path.getParentNode(i);",
                    "        i++;",
                    "      } while (",
                    "        firstNonMemberParent &&",
                    "        (firstNonMemberParent.type === \"MemberExpression\" ||",
                    "          firstNonMemberParent.type === \"TSNonNullExpression\")",
                    "      );",
                    "",
                    "      const shouldInline =",
                    "        (firstNonMemberParent &&",
                    "          (firstNonMemberParent.type === \"NewExpression\" ||",
                    "            (firstNonMemberParent.type === \"VariableDeclarator\" &&",
                    "              firstNonMemberParent.id.type !== \"Identifier\") ||",
                    "            (firstNonMemberParent.type === \"AssignmentExpression\" &&",
                    "              firstNonMemberParent.left.type !== \"Identifier\"))) ||",
                    "        n.computed ||",
                    "        (n.object.type === \"Identifier\" &&",
                    "          n.property.type === \"Identifier\" &&",
                    "          parent.type !== \"MemberExpression\");",
                    "",
                    "      return concat([",
                    "        path.call(print, \"object\"),",
                    "        shouldInline",
                    "          ? printMemberLookup(path, options, print)",
                    "          : group(",
                    "              indent(",
                    "                concat([softline, printMemberLookup(path, options, print)])",
                    "              )",
                    "            )",
                    "      ]);",
                    "    }",
                    "    case \"MetaProperty\":",
                    "      return concat([",
                    "        path.call(print, \"meta\"),",
                    "        \".\",",
                    "        path.call(print, \"property\")",
                    "      ]);",
                    "    case \"BindExpression\":",
                    "      if (n.object) {",
                    "        parts.push(path.call(print, \"object\"));",
                    "      }",
                    "",
                    "      parts.push(printBindExpressionCallee(path, options, print));",
                    "",
                    "      return concat(parts);",
                    "    case \"Identifier\": {",
                    "      return concat([",
                    "        n.name,",
                    "        printOptionalToken(path),",
                    "        printTypeAnnotation(path, options, print)",
                    "      ]);",
                    "    }",
                    "    case \"SpreadElement\":",
                    "    case \"SpreadElementPattern\":",
                    "    case \"RestProperty\":",
                    "    case \"ExperimentalRestProperty\":",
                    "    case \"ExperimentalSpreadProperty\":",
                    "    case \"SpreadProperty\":",
                    "    case \"SpreadPropertyPattern\":",
                    "    case \"RestElement\":",
                    "    case \"ObjectTypeSpreadProperty\":",
                    "      return concat([",
                    "        \"...\",",
                    "        path.call(print, \"argument\"),",
                    "        printTypeAnnotation(path, options, print)",
                    "      ]);",
                    "    case \"FunctionDeclaration\":",
                    "    case \"FunctionExpression\":",
                    "      if (isNodeStartingWithDeclare(n, options)) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "      parts.push(printFunctionDeclaration(path, print, options));",
                    "      if (!n.body) {",
                    "        parts.push(semi);",
                    "      }",
                    "      return concat(parts);",
                    "    case \"ArrowFunctionExpression\": {",
                    "      if (n.async) {",
                    "        parts.push(\"async \");",
                    "      }",
                    "",
                    "      if (shouldPrintParamsWithoutParens(path, options)) {",
                    "        parts.push(path.call(print, \"params\", 0));",
                    "      } else {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              printFunctionParams(",
                    "                path,",
                    "                print,",
                    "                options,",
                    "                /* expandLast */ args &&",
                    "                  (args.expandLastArg || args.expandFirstArg),",
                    "                /* printTypeParams */ true",
                    "              ),",
                    "              printReturnType(path, print, options)",
                    "            ])",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      const dangling = comments.printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameIndent */ true,",
                    "        comment => {",
                    "          const nextCharacter = sharedUtil.getNextNonSpaceNonCommentCharacterIndex(",
                    "            options.originalText,",
                    "            comment,",
                    "            options",
                    "          );",
                    "          return options.originalText.substr(nextCharacter, 2) === \"=>\";",
                    "        }",
                    "      );",
                    "      if (dangling) {",
                    "        parts.push(\" \", dangling);",
                    "      }",
                    "",
                    "      parts.push(\" =>\");",
                    "",
                    "      const body = path.call(bodyPath => print(bodyPath, args), \"body\");",
                    "",
                    "      // We want to always keep these types of nodes on the same line",
                    "      // as the arrow.",
                    "      if (",
                    "        !hasLeadingOwnLineComment(options.originalText, n.body, options) &&",
                    "        (n.body.type === \"ArrayExpression\" ||",
                    "          n.body.type === \"ObjectExpression\" ||",
                    "          n.body.type === \"BlockStatement\" ||",
                    "          isJSXNode(n.body) ||",
                    "          isTemplateOnItsOwnLine(n.body, options.originalText, options) ||",
                    "          n.body.type === \"ArrowFunctionExpression\")",
                    "      ) {",
                    "        return group(concat([concat(parts), \" \", body]));",
                    "      }",
                    "",
                    "      // We handle sequence expressions as the body of arrows specially,",
                    "      // so that the required parentheses end up on their own lines.",
                    "      if (n.body.type === \"SequenceExpression\") {",
                    "        return group(",
                    "          concat([",
                    "            concat(parts),",
                    "            group(",
                    "              concat([\" (\", indent(concat([softline, body])), softline, \")\"])",
                    "            )",
                    "          ])",
                    "        );",
                    "      }",
                    "",
                    "      // if the arrow function is expanded as last argument, we are adding a",
                    "      // level of indentation and need to add a softline to align the closing )",
                    "      // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)",
                    "      // we should align the expression's closing } with the line with the opening {.",
                    "      const shouldAddSoftLine =",
                    "        ((args && args.expandLastArg) ||",
                    "          path.getParentNode().type === \"JSXExpressionContainer\") &&",
                    "        !(n.comments && n.comments.length);",
                    "",
                    "      const printTrailingComma =",
                    "        args && args.expandLastArg && shouldPrintComma(options, \"all\");",
                    "",
                    "      // In order to avoid confusion between",
                    "      // a => a ? a : a",
                    "      // a <= a ? a : a",
                    "      const shouldAddParens =",
                    "        n.body.type === \"ConditionalExpression\" &&",
                    "        !privateUtil.startsWithNoLookaheadToken(",
                    "          n.body,",
                    "          /* forbidFunctionAndClass */ false",
                    "        );",
                    "",
                    "      return group(",
                    "        concat([",
                    "          concat(parts),",
                    "          group(",
                    "            concat([",
                    "              indent(",
                    "                concat([",
                    "                  line,",
                    "                  shouldAddParens ? ifBreak(\"\", \"(\") : \"\",",
                    "                  body,",
                    "                  shouldAddParens ? ifBreak(\"\", \")\") : \"\"",
                    "                ])",
                    "              ),",
                    "              shouldAddSoftLine",
                    "                ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline])",
                    "                : \"\"",
                    "            ])",
                    "          )",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"MethodDefinition\":",
                    "    case \"TSAbstractMethodDefinition\":",
                    "      if (n.accessibility) {",
                    "        parts.push(n.accessibility + \" \");",
                    "      }",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "      if (n.type === \"TSAbstractMethodDefinition\") {",
                    "        parts.push(\"abstract \");",
                    "      }",
                    "",
                    "      parts.push(printMethod(path, options, print));",
                    "",
                    "      return concat(parts);",
                    "    case \"YieldExpression\":",
                    "      parts.push(\"yield\");",
                    "",
                    "      if (n.delegate) {",
                    "        parts.push(\"*\");",
                    "      }",
                    "      if (n.argument) {",
                    "        parts.push(\" \", path.call(print, \"argument\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"AwaitExpression\":",
                    "      return concat([\"await \", path.call(print, \"argument\")]);",
                    "    case \"ImportSpecifier\":",
                    "      if (n.importKind) {",
                    "        parts.push(path.call(print, \"importKind\"), \" \");",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"imported\"));",
                    "",
                    "      if (n.local && n.local.name !== n.imported.name) {",
                    "        parts.push(\" as \", path.call(print, \"local\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"ExportSpecifier\":",
                    "      parts.push(path.call(print, \"local\"));",
                    "",
                    "      if (n.exported && n.exported.name !== n.local.name) {",
                    "        parts.push(\" as \", path.call(print, \"exported\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"ImportNamespaceSpecifier\":",
                    "      parts.push(\"* as \");",
                    "",
                    "      if (n.local) {",
                    "        parts.push(path.call(print, \"local\"));",
                    "      } else if (n.id) {",
                    "        parts.push(path.call(print, \"id\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"ImportDefaultSpecifier\":",
                    "      if (n.local) {",
                    "        return path.call(print, \"local\");",
                    "      }",
                    "",
                    "      return path.call(print, \"id\");",
                    "    case \"TSExportAssignment\":",
                    "      return concat([\"export = \", path.call(print, \"expression\"), semi]);",
                    "    case \"ExportDefaultDeclaration\":",
                    "    case \"ExportNamedDeclaration\":",
                    "      return printExportDeclaration(path, options, print);",
                    "    case \"ExportAllDeclaration\":",
                    "      parts.push(\"export \");",
                    "",
                    "      if (n.exportKind === \"type\") {",
                    "        parts.push(\"type \");",
                    "      }",
                    "",
                    "      parts.push(\"* from \", path.call(print, \"source\"), semi);",
                    "",
                    "      return concat(parts);",
                    "",
                    "    case \"ExportNamespaceSpecifier\":",
                    "    case \"ExportDefaultSpecifier\":",
                    "      return path.call(print, \"exported\");",
                    "    case \"ImportDeclaration\": {",
                    "      parts.push(\"import \");",
                    "",
                    "      if (n.importKind && n.importKind !== \"value\") {",
                    "        parts.push(n.importKind + \" \");",
                    "      }",
                    "",
                    "      const standalones = [];",
                    "      const grouped = [];",
                    "      if (n.specifiers && n.specifiers.length > 0) {",
                    "        path.each(specifierPath => {",
                    "          const value = specifierPath.getValue();",
                    "          if (",
                    "            value.type === \"ImportDefaultSpecifier\" ||",
                    "            value.type === \"ImportNamespaceSpecifier\"",
                    "          ) {",
                    "            standalones.push(print(specifierPath));",
                    "          } else {",
                    "            grouped.push(print(specifierPath));",
                    "          }",
                    "        }, \"specifiers\");",
                    "",
                    "        if (standalones.length > 0) {",
                    "          parts.push(join(\", \", standalones));",
                    "        }",
                    "",
                    "        if (standalones.length > 0 && grouped.length > 0) {",
                    "          parts.push(\", \");",
                    "        }",
                    "",
                    "        if (",
                    "          grouped.length === 1 &&",
                    "          standalones.length === 0 &&",
                    "          n.specifiers &&",
                    "          !n.specifiers.some(node => node.comments)",
                    "        ) {",
                    "          parts.push(",
                    "            concat([",
                    "              \"{\",",
                    "              options.bracketSpacing ? \" \" : \"\",",
                    "              concat(grouped),",
                    "              options.bracketSpacing ? \" \" : \"\",",
                    "              \"}\"",
                    "            ])",
                    "          );",
                    "        } else if (grouped.length >= 1) {",
                    "          parts.push(",
                    "            group(",
                    "              concat([",
                    "                \"{\",",
                    "                indent(",
                    "                  concat([",
                    "                    options.bracketSpacing ? line : softline,",
                    "                    join(concat([\",\", line]), grouped)",
                    "                  ])",
                    "                ),",
                    "                ifBreak(shouldPrintComma(options) ? \",\" : \"\"),",
                    "                options.bracketSpacing ? line : softline,",
                    "                \"}\"",
                    "              ])",
                    "            )",
                    "          );",
                    "        }",
                    "",
                    "        parts.push(\" from \");",
                    "      } else if (",
                    "        (n.importKind && n.importKind === \"type\") ||",
                    "        // import {} from 'x'",
                    "        /{\\s*}/.test(",
                    "          options.originalText.slice(",
                    "            options.locStart(n),",
                    "            options.locStart(n.source)",
                    "          )",
                    "        )",
                    "      ) {",
                    "        parts.push(\"{} from \");",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"source\"), semi);",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "",
                    "    case \"Import\":",
                    "      return \"import\";",
                    "    case \"BlockStatement\": {",
                    "      const naked = path.call(bodyPath => {",
                    "        return printStatementSequence(bodyPath, options, print);",
                    "      }, \"body\");",
                    "",
                    "      const hasContent = n.body.find(node => node.type !== \"EmptyStatement\");",
                    "      const hasDirectives = n.directives && n.directives.length > 0;",
                    "",
                    "      const parent = path.getParentNode();",
                    "      const parentParent = path.getParentNode(1);",
                    "      if (",
                    "        !hasContent &&",
                    "        !hasDirectives &&",
                    "        !hasDanglingComments(n) &&",
                    "        (parent.type === \"ArrowFunctionExpression\" ||",
                    "          parent.type === \"FunctionExpression\" ||",
                    "          parent.type === \"FunctionDeclaration\" ||",
                    "          parent.type === \"ObjectMethod\" ||",
                    "          parent.type === \"ClassMethod\" ||",
                    "          parent.type === \"ForStatement\" ||",
                    "          parent.type === \"WhileStatement\" ||",
                    "          parent.type === \"DoWhileStatement\" ||",
                    "          (parent.type === \"CatchClause\" && !parentParent.finalizer))",
                    "      ) {",
                    "        return \"{}\";",
                    "      }",
                    "",
                    "      parts.push(\"{\");",
                    "",
                    "      // Babel 6",
                    "      if (hasDirectives) {",
                    "        path.each(childPath => {",
                    "          parts.push(indent(concat([hardline, print(childPath), semi])));",
                    "          if (",
                    "            sharedUtil.isNextLineEmpty(",
                    "              options.originalText,",
                    "              childPath.getValue(),",
                    "              options",
                    "            )",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }, \"directives\");",
                    "      }",
                    "",
                    "      if (hasContent) {",
                    "        parts.push(indent(concat([hardline, naked])));",
                    "      }",
                    "",
                    "      parts.push(comments.printDanglingComments(path, options));",
                    "      parts.push(hardline, \"}\");",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"ReturnStatement\":",
                    "      parts.push(\"return\");",
                    "",
                    "      if (n.argument) {",
                    "        if (returnArgumentHasLeadingComment(options, n.argument)) {",
                    "          parts.push(",
                    "            concat([",
                    "              \" (\",",
                    "              indent(concat([hardline, path.call(print, \"argument\")])),",
                    "              hardline,",
                    "              \")\"",
                    "            ])",
                    "          );",
                    "        } else if (",
                    "          n.argument.type === \"LogicalExpression\" ||",
                    "          n.argument.type === \"BinaryExpression\" ||",
                    "          n.argument.type === \"SequenceExpression\"",
                    "        ) {",
                    "          parts.push(",
                    "            group(",
                    "              concat([",
                    "                ifBreak(\" (\", \" \"),",
                    "                indent(concat([softline, path.call(print, \"argument\")])),",
                    "                softline,",
                    "                ifBreak(\")\")",
                    "              ])",
                    "            )",
                    "          );",
                    "        } else {",
                    "          parts.push(\" \", path.call(print, \"argument\"));",
                    "        }",
                    "      }",
                    "",
                    "      if (hasDanglingComments(n)) {",
                    "        parts.push(",
                    "          \" \",",
                    "          comments.printDanglingComments(path, options, /* sameIndent */ true)",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return concat(parts);",
                    "    case \"NewExpression\":",
                    "    case \"CallExpression\": {",
                    "      const isNew = n.type === \"NewExpression\";",
                    "",
                    "      const optional = printOptionalToken(path);",
                    "      if (",
                    "        // We want to keep CommonJS- and AMD-style require calls, and AMD-style",
                    "        // define calls, as a unit.",
                    "        // e.g. `define([\"some/lib\", (lib) => {`",
                    "        (!isNew &&",
                    "          n.callee.type === \"Identifier\" &&",
                    "          (n.callee.name === \"require\" || n.callee.name === \"define\")) ||",
                    "        n.callee.type === \"Import\" ||",
                    "        // Template literals as single arguments",
                    "        (n.arguments.length === 1 &&",
                    "          isTemplateOnItsOwnLine(",
                    "            n.arguments[0],",
                    "            options.originalText,",
                    "            options",
                    "          )) ||",
                    "        // Keep test declarations on a single line",
                    "        // e.g. `it('long name', () => {`",
                    "        (!isNew && isTestCall(n))",
                    "      ) {",
                    "        return concat([",
                    "          isNew ? \"new \" : \"\",",
                    "          path.call(print, \"callee\"),",
                    "          optional,",
                    "          path.call(print, \"typeParameters\"),",
                    "          concat([\"(\", join(\", \", path.map(print, \"arguments\")), \")\"])",
                    "        ]);",
                    "      }",
                    "",
                    "      // We detect calls on member lookups and possibly print them in a",
                    "      // special chain format. See `printMemberChain` for more info.",
                    "      if (!isNew && isMemberish(n.callee)) {",
                    "        return printMemberChain(path, options, print);",
                    "      }",
                    "",
                    "      return concat([",
                    "        isNew ? \"new \" : \"\",",
                    "        path.call(print, \"callee\"),",
                    "        optional,",
                    "        printFunctionTypeParameters(path, options, print),",
                    "        printArgumentsList(path, options, print)",
                    "      ]);",
                    "    }",
                    "    case \"TSInterfaceDeclaration\":",
                    "      if (isNodeStartingWithDeclare(n, options)) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        n.abstract ? \"abstract \" : \"\",",
                    "        printTypeScriptModifiers(path, options, print),",
                    "        \"interface \",",
                    "        path.call(print, \"id\"),",
                    "        n.typeParameters ? path.call(print, \"typeParameters\") : \"\",",
                    "        \" \"",
                    "      );",
                    "",
                    "      if (n.heritage.length) {",
                    "        parts.push(",
                    "          group(",
                    "            indent(",
                    "              concat([",
                    "                softline,",
                    "                \"extends \",",
                    "                indent(join(concat([\",\", line]), path.map(print, \"heritage\"))),",
                    "                \" \"",
                    "              ])",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"body\"));",
                    "",
                    "      return concat(parts);",
                    "    case \"ObjectExpression\":",
                    "    case \"ObjectPattern\":",
                    "    case \"ObjectTypeAnnotation\":",
                    "    case \"TSInterfaceBody\":",
                    "    case \"TSTypeLiteral\": {",
                    "      const isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";",
                    "      const shouldBreak =",
                    "        n.type === \"TSInterfaceBody\" ||",
                    "        (n.type !== \"ObjectPattern\" &&",
                    "          privateUtil.hasNewlineInRange(",
                    "            options.originalText,",
                    "            options.locStart(n),",
                    "            options.locEnd(n)",
                    "          ));",
                    "      const parent = path.getParentNode(0);",
                    "      const isFlowInterfaceLikeBody =",
                    "        isTypeAnnotation &&",
                    "        parent &&",
                    "        (parent.type === \"InterfaceDeclaration\" ||",
                    "          parent.type === \"DeclareInterface\" ||",
                    "          parent.type === \"DeclareClass\") &&",
                    "        path.getName() === \"body\";",
                    "      const separator = isFlowInterfaceLikeBody",
                    "        ? \";\"",
                    "        : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\"",
                    "          ? ifBreak(semi, \";\")",
                    "          : \",\";",
                    "      const fields = [];",
                    "      const leftBrace = n.exact ? \"{|\" : \"{\";",
                    "      const rightBrace = n.exact ? \"|}\" : \"}\";",
                    "",
                    "      let propertiesField;",
                    "",
                    "      if (n.type === \"TSTypeLiteral\") {",
                    "        propertiesField = \"members\";",
                    "      } else if (n.type === \"TSInterfaceBody\") {",
                    "        propertiesField = \"body\";",
                    "      } else {",
                    "        propertiesField = \"properties\";",
                    "      }",
                    "",
                    "      if (isTypeAnnotation) {",
                    "        fields.push(\"indexers\", \"callProperties\");",
                    "      }",
                    "      fields.push(propertiesField);",
                    "",
                    "      // Unfortunately, things are grouped together in the ast can be",
                    "      // interleaved in the source code. So we need to reorder them before",
                    "      // printing them.",
                    "      const propsAndLoc = [];",
                    "      fields.forEach(field => {",
                    "        path.each(childPath => {",
                    "          const node = childPath.getValue();",
                    "          propsAndLoc.push({",
                    "            node: node,",
                    "            printed: print(childPath),",
                    "            loc: options.locStart(node)",
                    "          });",
                    "        }, field);",
                    "      });",
                    "",
                    "      let separatorParts = [];",
                    "      const props = propsAndLoc.sort((a, b) => a.loc - b.loc).map(prop => {",
                    "        const result = concat(separatorParts.concat(group(prop.printed)));",
                    "        separatorParts = [separator, line];",
                    "        if (",
                    "          prop.node.type === \"TSPropertySignature\" &&",
                    "          privateUtil.hasNodeIgnoreComment(prop.node)",
                    "        ) {",
                    "          separatorParts.shift();",
                    "        }",
                    "        if (",
                    "          sharedUtil.isNextLineEmpty(options.originalText, prop.node, options)",
                    "        ) {",
                    "          separatorParts.push(hardline);",
                    "        }",
                    "        return result;",
                    "      });",
                    "",
                    "      const lastElem = privateUtil.getLast(n[propertiesField]);",
                    "",
                    "      const canHaveTrailingSeparator = !(",
                    "        lastElem &&",
                    "        (lastElem.type === \"RestProperty\" ||",
                    "          lastElem.type === \"RestElement\" ||",
                    "          lastElem.type === \"ExperimentalRestProperty\" ||",
                    "          privateUtil.hasNodeIgnoreComment(lastElem))",
                    "      );",
                    "",
                    "      let content;",
                    "      if (props.length === 0 && !n.typeAnnotation) {",
                    "        if (!hasDanglingComments(n)) {",
                    "          return concat([leftBrace, rightBrace]);",
                    "        }",
                    "",
                    "        content = group(",
                    "          concat([",
                    "            leftBrace,",
                    "            comments.printDanglingComments(path, options),",
                    "            softline,",
                    "            rightBrace,",
                    "            printOptionalToken(path)",
                    "          ])",
                    "        );",
                    "      } else {",
                    "        content = concat([",
                    "          leftBrace,",
                    "          indent(",
                    "            concat([options.bracketSpacing ? line : softline, concat(props)])",
                    "          ),",
                    "          ifBreak(",
                    "            canHaveTrailingSeparator &&",
                    "            (separator !== \",\" || shouldPrintComma(options))",
                    "              ? separator",
                    "              : \"\"",
                    "          ),",
                    "          concat([options.bracketSpacing ? line : softline, rightBrace]),",
                    "          printOptionalToken(path),",
                    "          printTypeAnnotation(path, options, print)",
                    "        ]);",
                    "      }",
                    "",
                    "      // If we inline the object as first argument of the parent, we don't want",
                    "      // to create another group so that the object breaks before the return",
                    "      // type",
                    "      const parentParentParent = path.getParentNode(2);",
                    "      if (",
                    "        (n.type === \"ObjectPattern\" &&",
                    "          parent &&",
                    "          shouldHugArguments(parent) &&",
                    "          parent.params[0] === n) ||",
                    "        (shouldHugType(n) &&",
                    "          parentParentParent &&",
                    "          shouldHugArguments(parentParentParent) &&",
                    "          parentParentParent.params[0].typeAnnotation &&",
                    "          parentParentParent.params[0].typeAnnotation.typeAnnotation === n)",
                    "      ) {",
                    "        return content;",
                    "      }",
                    "",
                    "      return group(content, { shouldBreak });",
                    "    }",
                    "    // Babel 6",
                    "    case \"ObjectProperty\": // Non-standard AST node type.",
                    "    case \"Property\":",
                    "      if (n.method || n.kind === \"get\" || n.kind === \"set\") {",
                    "        return printMethod(path, options, print);",
                    "      }",
                    "",
                    "      if (n.shorthand) {",
                    "        parts.push(path.call(print, \"value\"));",
                    "      } else {",
                    "        let printedLeft;",
                    "        if (n.computed) {",
                    "          printedLeft = concat([\"[\", path.call(print, \"key\"), \"]\"]);",
                    "        } else {",
                    "          printedLeft = printPropertyKey(path, options, print);",
                    "        }",
                    "        parts.push(",
                    "          printAssignment(",
                    "            n.key,",
                    "            printedLeft,",
                    "            \":\",",
                    "            n.value,",
                    "            path.call(print, \"value\"),",
                    "            options",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts); // Babel 6",
                    "    case \"ClassMethod\":",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "",
                    "      parts = parts.concat(printObjectMethod(path, options, print));",
                    "",
                    "      return concat(parts); // Babel 6",
                    "    case \"ObjectMethod\":",
                    "      return printObjectMethod(path, options, print);",
                    "    case \"Decorator\":",
                    "      return concat([\"@\", path.call(print, \"expression\")]);",
                    "    case \"ArrayExpression\":",
                    "    case \"ArrayPattern\":",
                    "      if (n.elements.length === 0) {",
                    "        if (!hasDanglingComments(n)) {",
                    "          parts.push(\"[]\");",
                    "        } else {",
                    "          parts.push(",
                    "            group(",
                    "              concat([",
                    "                \"[\",",
                    "                comments.printDanglingComments(path, options),",
                    "                softline,",
                    "                \"]\"",
                    "              ])",
                    "            )",
                    "          );",
                    "        }",
                    "      } else {",
                    "        const lastElem = privateUtil.getLast(n.elements);",
                    "        const canHaveTrailingComma = !(",
                    "          lastElem && lastElem.type === \"RestElement\"",
                    "        );",
                    "",
                    "        // JavaScript allows you to have empty elements in an array which",
                    "        // changes its length based on the number of commas. The algorithm",
                    "        // is that if the last argument is null, we need to force insert",
                    "        // a comma to ensure JavaScript recognizes it.",
                    "        //   [,].length === 1",
                    "        //   [1,].length === 1",
                    "        //   [1,,].length === 2",
                    "        //",
                    "        // Note that privateUtil.getLast returns null if the array is empty, but",
                    "        // we already check for an empty array just above so we are safe",
                    "        const needsForcedTrailingComma =",
                    "          canHaveTrailingComma && lastElem === null;",
                    "",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              \"[\",",
                    "              indent(",
                    "                concat([",
                    "                  softline,",
                    "                  printArrayItems(path, options, \"elements\", print)",
                    "                ])",
                    "              ),",
                    "              needsForcedTrailingComma ? \",\" : \"\",",
                    "              ifBreak(",
                    "                canHaveTrailingComma &&",
                    "                !needsForcedTrailingComma &&",
                    "                shouldPrintComma(options)",
                    "                  ? \",\"",
                    "                  : \"\"",
                    "              ),",
                    "              comments.printDanglingComments(",
                    "                path,",
                    "                options,",
                    "                /* sameIndent */ true",
                    "              ),",
                    "              softline,",
                    "              \"]\"",
                    "            ])",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(",
                    "        printOptionalToken(path),",
                    "        printTypeAnnotation(path, options, print)",
                    "      );",
                    "",
                    "      return concat(parts);",
                    "    case \"SequenceExpression\": {",
                    "      const parent = path.getParentNode(0);",
                    "      if (",
                    "        parent.type === \"ExpressionStatement\" ||",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        // For ExpressionStatements and for-loop heads, which are among",
                    "        // the few places a SequenceExpression appears unparenthesized, we want",
                    "        // to indent expressions after the first.",
                    "        const parts = [];",
                    "        path.each(p => {",
                    "          if (p.getName() === 0) {",
                    "            parts.push(print(p));",
                    "          } else {",
                    "            parts.push(\",\", indent(concat([line, print(p)])));",
                    "          }",
                    "        }, \"expressions\");",
                    "        return group(concat(parts));",
                    "      }",
                    "      return group(",
                    "        concat([join(concat([\",\", line]), path.map(print, \"expressions\"))])",
                    "      );",
                    "    }",
                    "    case \"ThisExpression\":",
                    "      return \"this\";",
                    "    case \"Super\":",
                    "      return \"super\";",
                    "    case \"NullLiteral\": // Babel 6 Literal split",
                    "      return \"null\";",
                    "    case \"RegExpLiteral\": // Babel 6 Literal split",
                    "      return printRegex(n);",
                    "    case \"NumericLiteral\": // Babel 6 Literal split",
                    "      return privateUtil.printNumber(n.extra.raw);",
                    "    case \"BooleanLiteral\": // Babel 6 Literal split",
                    "    case \"StringLiteral\": // Babel 6 Literal split",
                    "    case \"Literal\": {",
                    "      if (n.regex) {",
                    "        return printRegex(n.regex);",
                    "      }",
                    "      if (typeof n.value === \"number\") {",
                    "        return privateUtil.printNumber(n.raw);",
                    "      }",
                    "      if (typeof n.value !== \"string\") {",
                    "        return \"\" + n.value;",
                    "      }",
                    "      // TypeScript workaround for eslint/typescript-eslint-parser#267",
                    "      // See corresponding workaround in needs-parens.js",
                    "      const grandParent = path.getParentNode(1);",
                    "      const isTypeScriptDirective =",
                    "        options.parser === \"typescript\" &&",
                    "        typeof n.value === \"string\" &&",
                    "        grandParent &&",
                    "        (grandParent.type === \"Program\" ||",
                    "          grandParent.type === \"BlockStatement\");",
                    "",
                    "      return nodeStr(n, options, isTypeScriptDirective);",
                    "    }",
                    "    case \"Directive\":",
                    "      return path.call(print, \"value\"); // Babel 6",
                    "    case \"DirectiveLiteral\":",
                    "      return nodeStr(n, options);",
                    "    case \"UnaryExpression\":",
                    "      parts.push(n.operator);",
                    "",
                    "      if (/[a-z]$/.test(n.operator)) {",
                    "        parts.push(\" \");",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"argument\"));",
                    "",
                    "      return concat(parts);",
                    "    case \"UpdateExpression\":",
                    "      parts.push(path.call(print, \"argument\"), n.operator);",
                    "",
                    "      if (n.prefix) {",
                    "        parts.reverse();",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"ConditionalExpression\":",
                    "      return formatTernaryOperator(path, options, print, {",
                    "        beforeParts: () => [path.call(print, \"test\")],",
                    "        afterParts: breakClosingParen => [breakClosingParen ? softline : \"\"]",
                    "      });",
                    "    case \"VariableDeclaration\": {",
                    "      const printed = path.map(childPath => {",
                    "        return print(childPath);",
                    "      }, \"declarations\");",
                    "",
                    "      // We generally want to terminate all variable declarations with a",
                    "      // semicolon, except when they in the () part of for loops.",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      const isParentForLoop =",
                    "        parentNode.type === \"ForStatement\" ||",
                    "        parentNode.type === \"ForInStatement\" ||",
                    "        parentNode.type === \"ForOfStatement\" ||",
                    "        parentNode.type === \"ForAwaitStatement\";",
                    "",
                    "      const hasValue = n.declarations.some(decl => decl.init);",
                    "",
                    "      let firstVariable;",
                    "      if (printed.length === 1) {",
                    "        firstVariable = printed[0];",
                    "      } else if (printed.length > 1) {",
                    "        // Indent first var to comply with eslint one-var rule",
                    "        firstVariable = indent(printed[0]);",
                    "      }",
                    "",
                    "      parts = [",
                    "        isNodeStartingWithDeclare(n, options) ? \"declare \" : \"\",",
                    "        n.kind,",
                    "        firstVariable ? concat([\" \", firstVariable]) : \"\",",
                    "        indent(",
                    "          concat(",
                    "            printed",
                    "              .slice(1)",
                    "              .map(p =>",
                    "                concat([\",\", hasValue && !isParentForLoop ? hardline : line, p])",
                    "              )",
                    "          )",
                    "        )",
                    "      ];",
                    "",
                    "      if (!(isParentForLoop && parentNode.body !== n)) {",
                    "        parts.push(semi);",
                    "      }",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"VariableDeclarator\":",
                    "      return printAssignment(",
                    "        n.id,",
                    "        concat([path.call(print, \"id\"), path.call(print, \"typeParameters\")]),",
                    "        \" =\",",
                    "        n.init,",
                    "        n.init && path.call(print, \"init\"),",
                    "        options",
                    "      );",
                    "    case \"WithStatement\":",
                    "      return group(",
                    "        concat([",
                    "          \"with (\",",
                    "          path.call(print, \"object\"),",
                    "          \")\",",
                    "          adjustClause(n.body, path.call(print, \"body\"))",
                    "        ])",
                    "      );",
                    "    case \"IfStatement\": {",
                    "      const con = adjustClause(n.consequent, path.call(print, \"consequent\"));",
                    "      const opening = group(",
                    "        concat([",
                    "          \"if (\",",
                    "          group(",
                    "            concat([",
                    "              indent(concat([softline, path.call(print, \"test\")])),",
                    "              softline",
                    "            ])",
                    "          ),",
                    "          \")\",",
                    "          con",
                    "        ])",
                    "      );",
                    "",
                    "      parts.push(opening);",
                    "",
                    "      if (n.alternate) {",
                    "        if (n.consequent.type === \"BlockStatement\") {",
                    "          parts.push(\" else\");",
                    "        } else {",
                    "          parts.push(hardline, \"else\");",
                    "        }",
                    "",
                    "        parts.push(",
                    "          group(",
                    "            adjustClause(",
                    "              n.alternate,",
                    "              path.call(print, \"alternate\"),",
                    "              n.alternate.type === \"IfStatement\"",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"ForStatement\": {",
                    "      const body = adjustClause(n.body, path.call(print, \"body\"));",
                    "",
                    "      // We want to keep dangling comments above the loop to stay consistent.",
                    "      // Any comment positioned between the for statement and the parentheses",
                    "      // is going to be printed before the statement.",
                    "      const dangling = comments.printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameLine */ true",
                    "      );",
                    "      const printedComments = dangling ? concat([dangling, softline]) : \"\";",
                    "",
                    "      if (!n.init && !n.test && !n.update) {",
                    "        return concat([printedComments, group(concat([\"for (;;)\", body]))]);",
                    "      }",
                    "",
                    "      return concat([",
                    "        printedComments,",
                    "        group(",
                    "          concat([",
                    "            \"for (\",",
                    "            group(",
                    "              concat([",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    path.call(print, \"init\"),",
                    "                    \";\",",
                    "                    line,",
                    "                    path.call(print, \"test\"),",
                    "                    \";\",",
                    "                    line,",
                    "                    path.call(print, \"update\")",
                    "                  ])",
                    "                ),",
                    "                softline",
                    "              ])",
                    "            ),",
                    "            \")\",",
                    "            body",
                    "          ])",
                    "        )",
                    "      ]);",
                    "    }",
                    "    case \"WhileStatement\":",
                    "      return group(",
                    "        concat([",
                    "          \"while (\",",
                    "          group(",
                    "            concat([",
                    "              indent(concat([softline, path.call(print, \"test\")])),",
                    "              softline",
                    "            ])",
                    "          ),",
                    "          \")\",",
                    "          adjustClause(n.body, path.call(print, \"body\"))",
                    "        ])",
                    "      );",
                    "    case \"ForInStatement\":",
                    "      // Note: esprima can't actually parse \"for each (\".",
                    "      return group(",
                    "        concat([",
                    "          n.each ? \"for each (\" : \"for (\",",
                    "          path.call(print, \"left\"),",
                    "          \" in \",",
                    "          path.call(print, \"right\"),",
                    "          \")\",",
                    "          adjustClause(n.body, path.call(print, \"body\"))",
                    "        ])",
                    "      );",
                    "",
                    "    case \"ForOfStatement\":",
                    "    case \"ForAwaitStatement\": {",
                    "      // Babylon 7 removed ForAwaitStatement in favor of ForOfStatement",
                    "      // with `\"await\": true`:",
                    "      // https://github.com/estree/estree/pull/138",
                    "      const isAwait = n.type === \"ForAwaitStatement\" || n.await;",
                    "",
                    "      return group(",
                    "        concat([",
                    "          \"for\",",
                    "          isAwait ? \" await\" : \"\",",
                    "          \" (\",",
                    "          path.call(print, \"left\"),",
                    "          \" of \",",
                    "          path.call(print, \"right\"),",
                    "          \")\",",
                    "          adjustClause(n.body, path.call(print, \"body\"))",
                    "        ])",
                    "      );",
                    "    }",
                    "",
                    "    case \"DoWhileStatement\": {",
                    "      const clause = adjustClause(n.body, path.call(print, \"body\"));",
                    "      const doBody = group(concat([\"do\", clause]));",
                    "      parts = [doBody];",
                    "",
                    "      if (n.body.type === \"BlockStatement\") {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(hardline);",
                    "      }",
                    "      parts.push(\"while (\");",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          concat([",
                    "            indent(concat([softline, path.call(print, \"test\")])),",
                    "            softline",
                    "          ])",
                    "        ),",
                    "        \")\",",
                    "        semi",
                    "      );",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"DoExpression\":",
                    "      return concat([\"do \", path.call(print, \"body\")]);",
                    "    case \"BreakStatement\":",
                    "      parts.push(\"break\");",
                    "",
                    "      if (n.label) {",
                    "        parts.push(\" \", path.call(print, \"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return concat(parts);",
                    "    case \"ContinueStatement\":",
                    "      parts.push(\"continue\");",
                    "",
                    "      if (n.label) {",
                    "        parts.push(\" \", path.call(print, \"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return concat(parts);",
                    "    case \"LabeledStatement\":",
                    "      if (n.body.type === \"EmptyStatement\") {",
                    "        return concat([path.call(print, \"label\"), \":;\"]);",
                    "      }",
                    "",
                    "      return concat([",
                    "        path.call(print, \"label\"),",
                    "        \": \",",
                    "        path.call(print, \"body\")",
                    "      ]);",
                    "    case \"TryStatement\":",
                    "      return concat([",
                    "        \"try \",",
                    "        path.call(print, \"block\"),",
                    "        n.handler ? concat([\" \", path.call(print, \"handler\")]) : \"\",",
                    "        n.finalizer ? concat([\" finally \", path.call(print, \"finalizer\")]) : \"\"",
                    "      ]);",
                    "    case \"CatchClause\":",
                    "      return concat([",
                    "        \"catch \",",
                    "        n.param ? concat([\"(\", path.call(print, \"param\"), \") \"]) : \"\",",
                    "        path.call(print, \"body\")",
                    "      ]);",
                    "    case \"ThrowStatement\":",
                    "      return concat([\"throw \", path.call(print, \"argument\"), semi]);",
                    "    // Note: ignoring n.lexical because it has no printing consequences.",
                    "    case \"SwitchStatement\":",
                    "      return concat([",
                    "        group(",
                    "          concat([",
                    "            \"switch (\",",
                    "            indent(concat([softline, path.call(print, \"discriminant\")])),",
                    "            softline,",
                    "            \")\"",
                    "          ])",
                    "        ),",
                    "        \" {\",",
                    "        n.cases.length > 0",
                    "          ? indent(",
                    "              concat([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  path.map(casePath => {",
                    "                    const caseNode = casePath.getValue();",
                    "                    return concat([",
                    "                      casePath.call(print),",
                    "                      n.cases.indexOf(caseNode) !== n.cases.length - 1 &&",
                    "                      sharedUtil.isNextLineEmpty(",
                    "                        options.originalText,",
                    "                        caseNode,",
                    "                        options",
                    "                      )",
                    "                        ? hardline",
                    "                        : \"\"",
                    "                    ]);",
                    "                  }, \"cases\")",
                    "                )",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\"",
                    "      ]);",
                    "    case \"SwitchCase\": {",
                    "      if (n.test) {",
                    "        parts.push(\"case \", path.call(print, \"test\"), \":\");",
                    "      } else {",
                    "        parts.push(\"default:\");",
                    "      }",
                    "",
                    "      const consequent = n.consequent.filter(",
                    "        node => node.type !== \"EmptyStatement\"",
                    "      );",
                    "",
                    "      if (consequent.length > 0) {",
                    "        const cons = path.call(consequentPath => {",
                    "          return printStatementSequence(consequentPath, options, print);",
                    "        }, \"consequent\");",
                    "",
                    "        parts.push(",
                    "          consequent.length === 1 && consequent[0].type === \"BlockStatement\"",
                    "            ? concat([\" \", cons])",
                    "            : indent(concat([hardline, cons]))",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    // JSX extensions below.",
                    "    case \"DebuggerStatement\":",
                    "      return concat([\"debugger\", semi]);",
                    "    case \"JSXAttribute\":",
                    "      parts.push(path.call(print, \"name\"));",
                    "",
                    "      if (n.value) {",
                    "        let res;",
                    "        if (isStringLiteral(n.value)) {",
                    "          const value = rawText(n.value);",
                    "          res = '\"' + value.slice(1, -1).replace(/\"/g, \"&quot;\") + '\"';",
                    "        } else {",
                    "          res = path.call(print, \"value\");",
                    "        }",
                    "        parts.push(\"=\", res);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"JSXIdentifier\":",
                    "      // Can be removed when this is fixed:",
                    "      // https://github.com/eslint/typescript-eslint-parser/issues/337",
                    "      if (!n.name) {",
                    "        return \"this\";",
                    "      }",
                    "      return \"\" + n.name;",
                    "    case \"JSXNamespacedName\":",
                    "      return join(\":\", [",
                    "        path.call(print, \"namespace\"),",
                    "        path.call(print, \"name\")",
                    "      ]);",
                    "    case \"JSXMemberExpression\":",
                    "      return join(\".\", [",
                    "        path.call(print, \"object\"),",
                    "        path.call(print, \"property\")",
                    "      ]);",
                    "    case \"TSQualifiedName\":",
                    "      return join(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);",
                    "    case \"JSXSpreadAttribute\":",
                    "    case \"JSXSpreadChild\": {",
                    "      return concat([",
                    "        \"{\",",
                    "        path.call(p => {",
                    "          const printed = concat([\"...\", print(p)]);",
                    "          const n = p.getValue();",
                    "          if (!n.comments || !n.comments.length) {",
                    "            return printed;",
                    "          }",
                    "          return concat([",
                    "            indent(",
                    "              concat([",
                    "                softline,",
                    "                comments.printComments(p, () => printed, options)",
                    "              ])",
                    "            ),",
                    "            softline",
                    "          ]);",
                    "        }, n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"),",
                    "        \"}\"",
                    "      ]);",
                    "    }",
                    "    case \"JSXExpressionContainer\": {",
                    "      const parent = path.getParentNode(0);",
                    "",
                    "      const preventInline =",
                    "        parent.type === \"JSXAttribute\" &&",
                    "        n.expression.comments &&",
                    "        n.expression.comments.length > 0;",
                    "",
                    "      const shouldInline =",
                    "        !preventInline &&",
                    "        (n.expression.type === \"ArrayExpression\" ||",
                    "          n.expression.type === \"ObjectExpression\" ||",
                    "          n.expression.type === \"ArrowFunctionExpression\" ||",
                    "          n.expression.type === \"CallExpression\" ||",
                    "          n.expression.type === \"FunctionExpression\" ||",
                    "          n.expression.type === \"JSXEmptyExpression\" ||",
                    "          n.expression.type === \"TemplateLiteral\" ||",
                    "          n.expression.type === \"TaggedTemplateExpression\" ||",
                    "          n.expression.type === \"DoExpression\" ||",
                    "          (isJSXNode(parent) &&",
                    "            (n.expression.type === \"ConditionalExpression\" ||",
                    "              isBinaryish(n.expression))));",
                    "",
                    "      if (shouldInline) {",
                    "        return group(",
                    "          concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"])",
                    "        );",
                    "      }",
                    "",
                    "      return group(",
                    "        concat([",
                    "          \"{\",",
                    "          indent(concat([softline, path.call(print, \"expression\")])),",
                    "          softline,",
                    "          lineSuffixBoundary,",
                    "          \"}\"",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"JSXFragment\":",
                    "    case \"TSJsxFragment\":",
                    "    case \"JSXElement\": {",
                    "      const elem = comments.printComments(",
                    "        path,",
                    "        () => printJSXElement(path, options, print),",
                    "        options",
                    "      );",
                    "      return maybeWrapJSXElementInParens(path, elem);",
                    "    }",
                    "    case \"JSXOpeningElement\": {",
                    "      const n = path.getValue();",
                    "",
                    "      const nameHasComments =",
                    "        n.name && n.name.comments && n.name.comments.length > 0;",
                    "",
                    "      // Don't break self-closing elements with no attributes and no comments",
                    "      if (n.selfClosing && !n.attributes.length && !nameHasComments) {",
                    "        return concat([\"<\", path.call(print, \"name\"), \" />\"]);",
                    "      }",
                    "",
                    "      // don't break up opening elements with a single long text attribute",
                    "      if (",
                    "        n.attributes &&",
                    "        n.attributes.length === 1 &&",
                    "        n.attributes[0].value &&",
                    "        isStringLiteral(n.attributes[0].value) &&",
                    "        !n.attributes[0].value.value.includes(\"\\n\") &&",
                    "        // We should break for the following cases:",
                    "        // <div",
                    "        //   // comment",
                    "        //   attr=\"value\"",
                    "        // >",
                    "        // <div",
                    "        //   attr=\"value\"",
                    "        //   // comment",
                    "        // >",
                    "        !nameHasComments &&",
                    "        (!n.attributes[0].comments || !n.attributes[0].comments.length)",
                    "      ) {",
                    "        return group(",
                    "          concat([",
                    "            \"<\",",
                    "            path.call(print, \"name\"),",
                    "            \" \",",
                    "            concat(path.map(print, \"attributes\")),",
                    "            n.selfClosing ? \" />\" : \">\"",
                    "          ])",
                    "        );",
                    "      }",
                    "",
                    "      const lastAttrHasTrailingComments =",
                    "        n.attributes.length &&",
                    "        hasTrailingComment(privateUtil.getLast(n.attributes));",
                    "",
                    "      const bracketSameLine =",
                    "        options.jsxBracketSameLine &&",
                    "        // We should print the bracket in a new line for the following cases:",
                    "        // <div",
                    "        //   // comment",
                    "        // >",
                    "        // <div",
                    "        //   attr // comment",
                    "        // >",
                    "        (!nameHasComments || n.attributes.length) &&",
                    "        !lastAttrHasTrailingComments;",
                    "",
                    "      // We should print the opening element expanded if any prop value is a",
                    "      // string literal with newlines",
                    "      const shouldBreak =",
                    "        n.attributes &&",
                    "        n.attributes.some(",
                    "          attr =>",
                    "            attr.value &&",
                    "            isStringLiteral(attr.value) &&",
                    "            attr.value.value.includes(\"\\n\")",
                    "        );",
                    "",
                    "      return group(",
                    "        concat([",
                    "          \"<\",",
                    "          path.call(print, \"name\"),",
                    "          concat([",
                    "            indent(",
                    "              concat(",
                    "                path.map(attr => concat([line, print(attr)]), \"attributes\")",
                    "              )",
                    "            ),",
                    "            n.selfClosing ? line : bracketSameLine ? \">\" : softline",
                    "          ]),",
                    "          n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\"",
                    "        ]),",
                    "        { shouldBreak }",
                    "      );",
                    "    }",
                    "    case \"JSXClosingElement\":",
                    "      return concat([\"</\", path.call(print, \"name\"), \">\"]);",
                    "    case \"JSXOpeningFragment\":",
                    "    case \"JSXClosingFragment\":",
                    "    case \"TSJsxOpeningFragment\":",
                    "    case \"TSJsxClosingFragment\": {",
                    "      const hasComment = n.comments && n.comments.length;",
                    "      const hasOwnLineComment =",
                    "        hasComment && !n.comments.every(privateUtil.isBlockComment);",
                    "      const isOpeningFragment =",
                    "        n.type === \"JSXOpeningFragment\" || n.type === \"TSJsxOpeningFragment\";",
                    "      return concat([",
                    "        isOpeningFragment ? \"<\" : \"</\",",
                    "        indent(",
                    "          concat([",
                    "            hasOwnLineComment",
                    "              ? hardline",
                    "              : hasComment && !isOpeningFragment ? \" \" : \"\",",
                    "            comments.printDanglingComments(path, options, true)",
                    "          ])",
                    "        ),",
                    "        hasOwnLineComment ? hardline : \"\",",
                    "        \">\"",
                    "      ]);",
                    "    }",
                    "    case \"JSXText\":",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"JSXTest should be handled by JSXElement\");",
                    "    case \"JSXEmptyExpression\": {",
                    "      const requiresHardline =",
                    "        n.comments && !n.comments.every(privateUtil.isBlockComment);",
                    "",
                    "      return concat([",
                    "        comments.printDanglingComments(",
                    "          path,",
                    "          options,",
                    "          /* sameIndent */ !requiresHardline",
                    "        ),",
                    "        requiresHardline ? hardline : \"\"",
                    "      ]);",
                    "    }",
                    "    case \"ClassBody\":",
                    "      if (!n.comments && n.body.length === 0) {",
                    "        return \"{}\";",
                    "      }",
                    "",
                    "      return concat([",
                    "        \"{\",",
                    "        n.body.length > 0",
                    "          ? indent(",
                    "              concat([",
                    "                hardline,",
                    "                path.call(bodyPath => {",
                    "                  return printStatementSequence(bodyPath, options, print);",
                    "                }, \"body\")",
                    "              ])",
                    "            )",
                    "          : comments.printDanglingComments(path, options),",
                    "        hardline,",
                    "        \"}\"",
                    "      ]);",
                    "    case \"ClassProperty\":",
                    "    case \"TSAbstractClassProperty\":",
                    "    case \"ClassPrivateProperty\": {",
                    "      if (n.accessibility) {",
                    "        parts.push(n.accessibility + \" \");",
                    "      }",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "      if (n.type === \"TSAbstractClassProperty\") {",
                    "        parts.push(\"abstract \");",
                    "      }",
                    "      if (n.readonly) {",
                    "        parts.push(\"readonly \");",
                    "      }",
                    "      const variance = getFlowVariance(n);",
                    "      if (variance) {",
                    "        parts.push(variance);",
                    "      }",
                    "      if (n.computed) {",
                    "        parts.push(\"[\", path.call(print, \"key\"), \"]\");",
                    "      } else {",
                    "        parts.push(printPropertyKey(path, options, print));",
                    "      }",
                    "      parts.push(printTypeAnnotation(path, options, print));",
                    "      if (n.value) {",
                    "        parts.push(",
                    "          \" =\",",
                    "          printAssignmentRight(",
                    "            n.value,",
                    "            path.call(print, \"value\"),",
                    "            false, // canBreak",
                    "            options",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\":",
                    "    case \"TSAbstractClassDeclaration\":",
                    "      if (isNodeStartingWithDeclare(n, options)) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "      parts.push(concat(printClass(path, options, print)));",
                    "      return concat(parts);",
                    "    case \"TSInterfaceHeritage\":",
                    "      parts.push(path.call(print, \"id\"));",
                    "",
                    "      if (n.typeParameters) {",
                    "        parts.push(path.call(print, \"typeParameters\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"TemplateElement\":",
                    "      return join(literalline, n.value.raw.split(/\\r?\\n/g));",
                    "    case \"TemplateLiteral\": {",
                    "      const expressions = path.map(print, \"expressions\");",
                    "",
                    "      parts.push(\"`\");",
                    "",
                    "      path.each(childPath => {",
                    "        const i = childPath.getName();",
                    "",
                    "        parts.push(print(childPath));",
                    "",
                    "        if (i < expressions.length) {",
                    "          // For a template literal of the following form:",
                    "          //   `someQuery {",
                    "          //     ${call({",
                    "          //       a,",
                    "          //       b,",
                    "          //     })}",
                    "          //   }`",
                    "          // the expression is on its own line (there is a \\n in the previous",
                    "          // quasi literal), therefore we want to indent the JavaScript",
                    "          // expression inside at the beginning of ${ instead of the beginning",
                    "          // of the `.",
                    "          const tabWidth = options.tabWidth;",
                    "          const indentSize = privateUtil.getIndentSize(",
                    "            childPath.getValue().value.raw,",
                    "            tabWidth",
                    "          );",
                    "",
                    "          let printed = expressions[i];",
                    "",
                    "          if (",
                    "            (n.expressions[i].comments && n.expressions[i].comments.length) ||",
                    "            n.expressions[i].type === \"MemberExpression\" ||",
                    "            n.expressions[i].type === \"ConditionalExpression\"",
                    "          ) {",
                    "            printed = concat([indent(concat([softline, printed])), softline]);",
                    "          }",
                    "",
                    "          const aligned = addAlignmentToDoc(printed, indentSize, tabWidth);",
                    "",
                    "          parts.push(group(concat([\"${\", aligned, lineSuffixBoundary, \"}\"])));",
                    "        }",
                    "      }, \"quasis\");",
                    "",
                    "      parts.push(\"`\");",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    // These types are unprintable because they serve as abstract",
                    "    // supertypes for other (printable) types.",
                    "    case \"TaggedTemplateExpression\":",
                    "      return concat([path.call(print, \"tag\"), path.call(print, \"quasi\")]);",
                    "    case \"Node\":",
                    "    case \"Printable\":",
                    "    case \"SourceLocation\":",
                    "    case \"Position\":",
                    "    case \"Statement\":",
                    "    case \"Function\":",
                    "    case \"Pattern\":",
                    "    case \"Expression\":",
                    "    case \"Declaration\":",
                    "    case \"Specifier\":",
                    "    case \"NamedSpecifier\":",
                    "    case \"Comment\":",
                    "    case \"MemberTypeAnnotation\": // Flow",
                    "    case \"Type\":",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));",
                    "    // Type Annotations for Facebook Flow, typically stripped out or",
                    "    // transformed away before printing.",
                    "    case \"TypeAnnotation\":",
                    "    case \"TSTypeAnnotation\":",
                    "      if (n.typeAnnotation) {",
                    "        return path.call(print, \"typeAnnotation\");",
                    "      }",
                    "",
                    "      /* istanbul ignore next */",
                    "      return \"\";",
                    "    case \"TSTupleType\":",
                    "    case \"TupleTypeAnnotation\": {",
                    "      const typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";",
                    "      return group(",
                    "        concat([",
                    "          \"[\",",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              printArrayItems(path, options, typesField, print)",
                    "            ])",
                    "          ),",
                    "          // TypeScript doesn't support trailing commas in tuple types",
                    "          n.type === \"TSTupleType\"",
                    "            ? \"\"",
                    "            : ifBreak(shouldPrintComma(options) ? \",\" : \"\"),",
                    "          comments.printDanglingComments(path, options, /* sameIndent */ true),",
                    "          softline,",
                    "          \"]\"",
                    "        ])",
                    "      );",
                    "    }",
                    "",
                    "    case \"ExistsTypeAnnotation\":",
                    "      return \"*\";",
                    "    case \"EmptyTypeAnnotation\":",
                    "      return \"empty\";",
                    "    case \"AnyTypeAnnotation\":",
                    "      return \"any\";",
                    "    case \"MixedTypeAnnotation\":",
                    "      return \"mixed\";",
                    "    case \"ArrayTypeAnnotation\":",
                    "      return concat([path.call(print, \"elementType\"), \"[]\"]);",
                    "    case \"BooleanTypeAnnotation\":",
                    "      return \"boolean\";",
                    "    case \"BooleanLiteralTypeAnnotation\":",
                    "      return \"\" + n.value;",
                    "    case \"DeclareClass\":",
                    "      return printFlowDeclaration(path, printClass(path, options, print));",
                    "    case \"DeclareFunction\":",
                    "      // For TypeScript the DeclareFunction node shares the AST",
                    "      // structure with FunctionDeclaration",
                    "      if (n.params) {",
                    "        return concat([",
                    "          \"declare \",",
                    "          printFunctionDeclaration(path, print, options),",
                    "          semi",
                    "        ]);",
                    "      }",
                    "      return printFlowDeclaration(path, [",
                    "        \"function \",",
                    "        path.call(print, \"id\"),",
                    "        n.predicate ? \" \" : \"\",",
                    "        path.call(print, \"predicate\"),",
                    "        semi",
                    "      ]);",
                    "    case \"DeclareModule\":",
                    "      return printFlowDeclaration(path, [",
                    "        \"module \",",
                    "        path.call(print, \"id\"),",
                    "        \" \",",
                    "        path.call(print, \"body\")",
                    "      ]);",
                    "    case \"DeclareModuleExports\":",
                    "      return printFlowDeclaration(path, [",
                    "        \"module.exports\",",
                    "        \": \",",
                    "        path.call(print, \"typeAnnotation\"),",
                    "        semi",
                    "      ]);",
                    "    case \"DeclareVariable\":",
                    "      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);",
                    "    case \"DeclareExportAllDeclaration\":",
                    "      return concat([\"declare export * from \", path.call(print, \"source\")]);",
                    "    case \"DeclareExportDeclaration\":",
                    "      return concat([\"declare \", printExportDeclaration(path, options, print)]);",
                    "    case \"DeclareOpaqueType\":",
                    "    case \"OpaqueType\": {",
                    "      parts.push(",
                    "        \"opaque type \",",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\")",
                    "      );",
                    "",
                    "      if (n.supertype) {",
                    "        parts.push(\": \", path.call(print, \"supertype\"));",
                    "      }",
                    "",
                    "      if (n.impltype) {",
                    "        parts.push(\" = \", path.call(print, \"impltype\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      if (n.type === \"DeclareOpaqueType\") {",
                    "        return printFlowDeclaration(path, parts);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "",
                    "    case \"FunctionTypeAnnotation\":",
                    "    case \"TSFunctionType\": {",
                    "      // FunctionTypeAnnotation is ambiguous:",
                    "      // declare function foo(a: B): void; OR",
                    "      // var A: (a: B) => void;",
                    "      const parent = path.getParentNode(0);",
                    "      const parentParent = path.getParentNode(1);",
                    "      const parentParentParent = path.getParentNode(2);",
                    "      let isArrowFunctionTypeAnnotation =",
                    "        n.type === \"TSFunctionType\" ||",
                    "        !(",
                    "          (parent.type === \"ObjectTypeProperty\" &&",
                    "            !getFlowVariance(parent) &&",
                    "            !parent.optional &&",
                    "            options.locStart(parent) === options.locStart(n)) ||",
                    "          parent.type === \"ObjectTypeCallProperty\" ||",
                    "          (parentParentParent && parentParentParent.type === \"DeclareFunction\")",
                    "        );",
                    "",
                    "      let needsColon =",
                    "        isArrowFunctionTypeAnnotation &&",
                    "        (parent.type === \"TypeAnnotation\" ||",
                    "          parent.type === \"TSTypeAnnotation\");",
                    "",
                    "      // Sadly we can't put it inside of FastPath::needsColon because we are",
                    "      // printing \":\" as part of the expression and it would put parenthesis",
                    "      // around :(",
                    "      const needsParens =",
                    "        needsColon &&",
                    "        isArrowFunctionTypeAnnotation &&",
                    "        (parent.type === \"TypeAnnotation\" ||",
                    "          parent.type === \"TSTypeAnnotation\") &&",
                    "        parentParent.type === \"ArrowFunctionExpression\";",
                    "",
                    "      if (isObjectTypePropertyAFunction(parent, options)) {",
                    "        isArrowFunctionTypeAnnotation = true;",
                    "        needsColon = true;",
                    "      }",
                    "",
                    "      if (needsParens) {",
                    "        parts.push(\"(\");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        printFunctionParams(",
                    "          path,",
                    "          print,",
                    "          options,",
                    "          /* expandArg */ false,",
                    "          /* printTypeParams */ true",
                    "        )",
                    "      );",
                    "",
                    "      // The returnType is not wrapped in a TypeAnnotation, so the colon",
                    "      // needs to be added separately.",
                    "      if (n.returnType || n.predicate || n.typeAnnotation) {",
                    "        parts.push(",
                    "          isArrowFunctionTypeAnnotation ? \" => \" : \": \",",
                    "          path.call(print, \"returnType\"),",
                    "          path.call(print, \"predicate\"),",
                    "          path.call(print, \"typeAnnotation\")",
                    "        );",
                    "      }",
                    "      if (needsParens) {",
                    "        parts.push(\")\");",
                    "      }",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"FunctionTypeParam\":",
                    "      return concat([",
                    "        path.call(print, \"name\"),",
                    "        printOptionalToken(path),",
                    "        n.name ? \": \" : \"\",",
                    "        path.call(print, \"typeAnnotation\")",
                    "      ]);",
                    "    case \"GenericTypeAnnotation\":",
                    "      return concat([",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\")",
                    "      ]);",
                    "    case \"DeclareInterface\":",
                    "    case \"InterfaceDeclaration\": {",
                    "      if (",
                    "        n.type === \"DeclareInterface\" ||",
                    "        isNodeStartingWithDeclare(n, options)",
                    "      ) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        \"interface \",",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\")",
                    "      );",
                    "",
                    "      if (n[\"extends\"].length > 0) {",
                    "        parts.push(",
                    "          group(",
                    "            indent(",
                    "              concat([line, \"extends \", join(\", \", path.map(print, \"extends\"))])",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(\" \");",
                    "      parts.push(path.call(print, \"body\"));",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"ClassImplements\":",
                    "    case \"InterfaceExtends\":",
                    "      return concat([",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\")",
                    "      ]);",
                    "    case \"TSIntersectionType\":",
                    "    case \"IntersectionTypeAnnotation\": {",
                    "      const types = path.map(print, \"types\");",
                    "      const result = [];",
                    "      let wasIndented = false;",
                    "      for (let i = 0; i < types.length; ++i) {",
                    "        if (i === 0) {",
                    "          result.push(types[i]);",
                    "        } else if (isObjectType(n.types[i - 1]) && isObjectType(n.types[i])) {",
                    "          // If both are objects, don't indent",
                    "          result.push(",
                    "            concat([\" & \", wasIndented ? indent(types[i]) : types[i]])",
                    "          );",
                    "        } else if (!isObjectType(n.types[i - 1]) && !isObjectType(n.types[i])) {",
                    "          // If no object is involved, go to the next line if it breaks",
                    "          result.push(indent(concat([\" &\", line, types[i]])));",
                    "        } else {",
                    "          // If you go from object to non-object or vis-versa, then inline it",
                    "          if (i > 1) {",
                    "            wasIndented = true;",
                    "          }",
                    "          result.push(\" & \", i > 1 ? indent(types[i]) : types[i]);",
                    "        }",
                    "      }",
                    "      return group(concat(result));",
                    "    }",
                    "    case \"TSUnionType\":",
                    "    case \"UnionTypeAnnotation\": {",
                    "      // single-line variation",
                    "      // A | B | C",
                    "",
                    "      // multi-line variation",
                    "      // | A",
                    "      // | B",
                    "      // | C",
                    "",
                    "      const parent = path.getParentNode();",
                    "",
                    "      // If there's a leading comment, the parent is doing the indentation",
                    "      const shouldIndent =",
                    "        parent.type !== \"TypeParameterInstantiation\" &&",
                    "        parent.type !== \"TSTypeParameterInstantiation\" &&",
                    "        parent.type !== \"GenericTypeAnnotation\" &&",
                    "        parent.type !== \"TSTypeReference\" &&",
                    "        parent.type !== \"FunctionTypeParam\" &&",
                    "        !(",
                    "          (parent.type === \"TypeAlias\" ||",
                    "            parent.type === \"VariableDeclarator\") &&",
                    "          hasLeadingOwnLineComment(options.originalText, n, options)",
                    "        );",
                    "",
                    "      // {",
                    "      //   a: string",
                    "      // } | null | void",
                    "      // should be inlined and not be printed in the multi-line variant",
                    "      const shouldHug = shouldHugType(n);",
                    "",
                    "      // We want to align the children but without its comment, so it looks like",
                    "      // | child1",
                    "      // // comment",
                    "      // | child2",
                    "      const printed = path.map(typePath => {",
                    "        let printedType = typePath.call(print);",
                    "        if (!shouldHug) {",
                    "          printedType = align(2, printedType);",
                    "        }",
                    "        return comments.printComments(typePath, () => printedType, options);",
                    "      }, \"types\");",
                    "",
                    "      if (shouldHug) {",
                    "        return join(\" | \", printed);",
                    "      }",
                    "",
                    "      const code = concat([",
                    "        ifBreak(concat([shouldIndent ? line : \"\", \"| \"])),",
                    "        join(concat([line, \"| \"]), printed)",
                    "      ]);",
                    "",
                    "      let hasParens;",
                    "",
                    "      if (n.type === \"TSUnionType\") {",
                    "        const greatGrandParent = path.getParentNode(2);",
                    "        const greatGreatGrandParent = path.getParentNode(3);",
                    "",
                    "        hasParens =",
                    "          greatGrandParent &&",
                    "          greatGrandParent.type === \"TSParenthesizedType\" &&",
                    "          greatGreatGrandParent &&",
                    "          (greatGreatGrandParent.type === \"TSUnionType\" ||",
                    "            greatGreatGrandParent.type === \"TSIntersectionType\");",
                    "      } else {",
                    "        hasParens = pathNeedsParens(path, options);",
                    "      }",
                    "",
                    "      if (hasParens) {",
                    "        return group(concat([indent(code), softline]));",
                    "      }",
                    "",
                    "      return group(shouldIndent ? indent(code) : code);",
                    "    }",
                    "    case \"NullableTypeAnnotation\":",
                    "      return concat([\"?\", path.call(print, \"typeAnnotation\")]);",
                    "    case \"TSNullKeyword\":",
                    "    case \"NullLiteralTypeAnnotation\":",
                    "      return \"null\";",
                    "    case \"ThisTypeAnnotation\":",
                    "      return \"this\";",
                    "    case \"NumberTypeAnnotation\":",
                    "      return \"number\";",
                    "    case \"ObjectTypeCallProperty\":",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"value\"));",
                    "",
                    "      return concat(parts);",
                    "    case \"ObjectTypeIndexer\": {",
                    "      const variance = getFlowVariance(n);",
                    "      return concat([",
                    "        variance || \"\",",
                    "        \"[\",",
                    "        path.call(print, \"id\"),",
                    "        n.id ? \": \" : \"\",",
                    "        path.call(print, \"key\"),",
                    "        \"]: \",",
                    "        path.call(print, \"value\")",
                    "      ]);",
                    "    }",
                    "    case \"ObjectTypeProperty\": {",
                    "      const variance = getFlowVariance(n);",
                    "",
                    "      return concat([",
                    "        n.static ? \"static \" : \"\",",
                    "        isGetterOrSetter(n) ? n.kind + \" \" : \"\",",
                    "        variance || \"\",",
                    "        printPropertyKey(path, options, print),",
                    "        printOptionalToken(path),",
                    "        isFunctionNotation(n, options) ? \"\" : \": \",",
                    "        path.call(print, \"value\")",
                    "      ]);",
                    "    }",
                    "    case \"QualifiedTypeIdentifier\":",
                    "      return concat([",
                    "        path.call(print, \"qualification\"),",
                    "        \".\",",
                    "        path.call(print, \"id\")",
                    "      ]);",
                    "    case \"StringLiteralTypeAnnotation\":",
                    "      return nodeStr(n, options);",
                    "    case \"NumberLiteralTypeAnnotation\":",
                    "      assert.strictEqual(typeof n.value, \"number\");",
                    "",
                    "      if (n.extra != null) {",
                    "        return privateUtil.printNumber(n.extra.raw);",
                    "      }",
                    "      return privateUtil.printNumber(n.raw);",
                    "",
                    "    case \"StringTypeAnnotation\":",
                    "      return \"string\";",
                    "    case \"DeclareTypeAlias\":",
                    "    case \"TypeAlias\": {",
                    "      if (",
                    "        n.type === \"DeclareTypeAlias\" ||",
                    "        isNodeStartingWithDeclare(n, options)",
                    "      ) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "",
                    "      const canBreak = n.right.type === \"StringLiteralTypeAnnotation\";",
                    "",
                    "      const printed = printAssignmentRight(",
                    "        n.right,",
                    "        path.call(print, \"right\"),",
                    "        canBreak,",
                    "        options",
                    "      );",
                    "",
                    "      parts.push(",
                    "        \"type \",",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\"),",
                    "        \" =\",",
                    "        printed,",
                    "        semi",
                    "      );",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"TypeCastExpression\":",
                    "      return concat([",
                    "        \"(\",",
                    "        path.call(print, \"expression\"),",
                    "        \": \",",
                    "        path.call(print, \"typeAnnotation\"),",
                    "        \")\"",
                    "      ]);",
                    "    case \"TypeParameterDeclaration\":",
                    "    case \"TypeParameterInstantiation\":",
                    "    case \"TSTypeParameterDeclaration\":",
                    "    case \"TSTypeParameterInstantiation\":",
                    "      return printTypeParameters(path, options, print, \"params\");",
                    "",
                    "    case \"TSTypeParameter\":",
                    "    case \"TypeParameter\": {",
                    "      const parent = path.getParentNode();",
                    "      if (parent.type === \"TSMappedType\") {",
                    "        parts.push(path.call(print, \"name\"));",
                    "        if (n.constraint) {",
                    "          parts.push(\" in \", path.call(print, \"constraint\"));",
                    "        }",
                    "        return concat(parts);",
                    "      }",
                    "",
                    "      const variance = getFlowVariance(n);",
                    "",
                    "      if (variance) {",
                    "        parts.push(variance);",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"name\"));",
                    "",
                    "      if (n.bound) {",
                    "        parts.push(\": \");",
                    "        parts.push(path.call(print, \"bound\"));",
                    "      }",
                    "",
                    "      if (n.constraint) {",
                    "        parts.push(\" extends \", path.call(print, \"constraint\"));",
                    "      }",
                    "",
                    "      if (n[\"default\"]) {",
                    "        parts.push(\" = \", path.call(print, \"default\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"TypeofTypeAnnotation\":",
                    "      return concat([\"typeof \", path.call(print, \"argument\")]);",
                    "    case \"VoidTypeAnnotation\":",
                    "      return \"void\";",
                    "    case \"InferredPredicate\":",
                    "      return \"%checks\";",
                    "    // Unhandled types below. If encountered, nodes of these types should",
                    "    // be either left alone or desugared into AST types that are fully",
                    "    // supported by the pretty-printer.",
                    "    case \"DeclaredPredicate\":",
                    "      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);",
                    "    case \"TSAbstractKeyword\":",
                    "      return \"abstract\";",
                    "    case \"TSAnyKeyword\":",
                    "      return \"any\";",
                    "    case \"TSAsyncKeyword\":",
                    "      return \"async\";",
                    "    case \"TSBooleanKeyword\":",
                    "      return \"boolean\";",
                    "    case \"TSConstKeyword\":",
                    "      return \"const\";",
                    "    case \"TSDeclareKeyword\":",
                    "      return \"declare\";",
                    "    case \"TSExportKeyword\":",
                    "      return \"export\";",
                    "    case \"TSNeverKeyword\":",
                    "      return \"never\";",
                    "    case \"TSNumberKeyword\":",
                    "      return \"number\";",
                    "    case \"TSObjectKeyword\":",
                    "      return \"object\";",
                    "    case \"TSProtectedKeyword\":",
                    "      return \"protected\";",
                    "    case \"TSPrivateKeyword\":",
                    "      return \"private\";",
                    "    case \"TSPublicKeyword\":",
                    "      return \"public\";",
                    "    case \"TSReadonlyKeyword\":",
                    "      return \"readonly\";",
                    "    case \"TSSymbolKeyword\":",
                    "      return \"symbol\";",
                    "    case \"TSStaticKeyword\":",
                    "      return \"static\";",
                    "    case \"TSStringKeyword\":",
                    "      return \"string\";",
                    "    case \"TSUndefinedKeyword\":",
                    "      return \"undefined\";",
                    "    case \"TSVoidKeyword\":",
                    "      return \"void\";",
                    "    case \"TSAsExpression\":",
                    "      return concat([",
                    "        path.call(print, \"expression\"),",
                    "        \" as \",",
                    "        path.call(print, \"typeAnnotation\")",
                    "      ]);",
                    "    case \"TSArrayType\":",
                    "      return concat([path.call(print, \"elementType\"), \"[]\"]);",
                    "    case \"TSPropertySignature\": {",
                    "      if (n.export) {",
                    "        parts.push(\"export \");",
                    "      }",
                    "      if (n.accessibility) {",
                    "        parts.push(n.accessibility + \" \");",
                    "      }",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "      if (n.readonly) {",
                    "        parts.push(\"readonly \");",
                    "      }",
                    "      if (n.computed) {",
                    "        parts.push(\"[\");",
                    "      }",
                    "",
                    "      parts.push(printPropertyKey(path, options, print));",
                    "",
                    "      if (n.computed) {",
                    "        parts.push(\"]\");",
                    "      }",
                    "",
                    "      parts.push(printOptionalToken(path));",
                    "",
                    "      if (n.typeAnnotation) {",
                    "        parts.push(\": \");",
                    "        parts.push(path.call(print, \"typeAnnotation\"));",
                    "      }",
                    "",
                    "      // This isn't valid semantically, but it's in the AST so we can print it.",
                    "      if (n.initializer) {",
                    "        parts.push(\" = \", path.call(print, \"initializer\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"TSParameterProperty\":",
                    "      if (n.accessibility) {",
                    "        parts.push(n.accessibility + \" \");",
                    "      }",
                    "      if (n.export) {",
                    "        parts.push(\"export \");",
                    "      }",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "      if (n.readonly) {",
                    "        parts.push(\"readonly \");",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"parameter\"));",
                    "",
                    "      return concat(parts);",
                    "    case \"TSTypeReference\":",
                    "      return concat([",
                    "        path.call(print, \"typeName\"),",
                    "        printTypeParameters(path, options, print, \"typeParameters\")",
                    "      ]);",
                    "    case \"TSTypeQuery\":",
                    "      return concat([\"typeof \", path.call(print, \"exprName\")]);",
                    "    case \"TSParenthesizedType\": {",
                    "      return path.call(print, \"typeAnnotation\");",
                    "    }",
                    "    case \"TSIndexSignature\": {",
                    "      const parent = path.getParentNode();",
                    "",
                    "      return concat([",
                    "        n.export ? \"export \" : \"\",",
                    "        n.accessibility ? concat([n.accessibility, \" \"]) : \"\",",
                    "        n.static ? \"static \" : \"\",",
                    "        n.readonly ? \"readonly \" : \"\",",
                    "        \"[\",",
                    "        path.call(print, \"index\"),",
                    "        \"]: \",",
                    "        path.call(print, \"typeAnnotation\"),",
                    "        parent.type === \"ClassBody\" ? semi : \"\"",
                    "      ]);",
                    "    }",
                    "    case \"TSTypePredicate\":",
                    "      return concat([",
                    "        path.call(print, \"parameterName\"),",
                    "        \" is \",",
                    "        path.call(print, \"typeAnnotation\")",
                    "      ]);",
                    "    case \"TSNonNullExpression\":",
                    "      return concat([path.call(print, \"expression\"), \"!\"]);",
                    "    case \"TSThisType\":",
                    "      return \"this\";",
                    "    case \"TSLastTypeNode\":",
                    "      return path.call(print, \"literal\");",
                    "    case \"TSIndexedAccessType\":",
                    "      return concat([",
                    "        path.call(print, \"objectType\"),",
                    "        \"[\",",
                    "        path.call(print, \"indexType\"),",
                    "        \"]\"",
                    "      ]);",
                    "    case \"TSConstructSignature\":",
                    "    case \"TSConstructorType\":",
                    "    case \"TSCallSignature\": {",
                    "      if (n.type !== \"TSCallSignature\") {",
                    "        parts.push(\"new \");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          printFunctionParams(",
                    "            path,",
                    "            print,",
                    "            options,",
                    "            /* expandArg */ false,",
                    "            /* printTypeParams */ true",
                    "          )",
                    "        )",
                    "      );",
                    "",
                    "      if (n.typeAnnotation) {",
                    "        const isType = n.type === \"TSConstructorType\";",
                    "        parts.push(isType ? \" => \" : \": \", path.call(print, \"typeAnnotation\"));",
                    "      }",
                    "      return concat(parts);",
                    "    }",
                    "    case \"TSTypeOperator\":",
                    "      return concat([n.operator, \" \", path.call(print, \"typeAnnotation\")]);",
                    "    case \"TSMappedType\":",
                    "      return group(",
                    "        concat([",
                    "          \"{\",",
                    "          indent(",
                    "            concat([",
                    "              options.bracketSpacing ? line : softline,",
                    "              n.readonlyToken",
                    "                ? concat([",
                    "                    getTypeScriptMappedTypeModifier(",
                    "                      n.readonlyToken,",
                    "                      \"readonly\"",
                    "                    ),",
                    "                    \" \"",
                    "                  ])",
                    "                : \"\",",
                    "              printTypeScriptModifiers(path, options, print),",
                    "              \"[\",",
                    "              path.call(print, \"typeParameter\"),",
                    "              \"]\",",
                    "              n.questionToken",
                    "                ? getTypeScriptMappedTypeModifier(n.questionToken, \"?\")",
                    "                : \"\",",
                    "              \": \",",
                    "              path.call(print, \"typeAnnotation\")",
                    "            ])",
                    "          ),",
                    "          comments.printDanglingComments(path, options, /* sameIndent */ true),",
                    "          options.bracketSpacing ? line : softline,",
                    "          \"}\"",
                    "        ])",
                    "      );",
                    "    case \"TSMethodSignature\":",
                    "      parts.push(",
                    "        n.accessibility ? concat([n.accessibility, \" \"]) : \"\",",
                    "        n.export ? \"export \" : \"\",",
                    "        n.static ? \"static \" : \"\",",
                    "        n.readonly ? \"readonly \" : \"\",",
                    "        n.computed ? \"[\" : \"\",",
                    "        path.call(print, \"key\"),",
                    "        n.computed ? \"]\" : \"\",",
                    "        printOptionalToken(path),",
                    "        printFunctionParams(",
                    "          path,",
                    "          print,",
                    "          options,",
                    "          /* expandArg */ false,",
                    "          /* printTypeParams */ true",
                    "        )",
                    "      );",
                    "",
                    "      if (n.typeAnnotation) {",
                    "        parts.push(\": \", path.call(print, \"typeAnnotation\"));",
                    "      }",
                    "      return group(concat(parts));",
                    "    case \"TSNamespaceExportDeclaration\":",
                    "      parts.push(\"export as namespace \", path.call(print, \"name\"));",
                    "",
                    "      if (options.semi) {",
                    "        parts.push(\";\");",
                    "      }",
                    "",
                    "      return group(concat(parts));",
                    "    case \"TSEnumDeclaration\":",
                    "      if (isNodeStartingWithDeclare(n, options)) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "",
                    "      if (n.modifiers) {",
                    "        parts.push(printTypeScriptModifiers(path, options, print));",
                    "      }",
                    "      if (n.const) {",
                    "        parts.push(\"const \");",
                    "      }",
                    "",
                    "      parts.push(\"enum \", path.call(print, \"id\"), \" \");",
                    "",
                    "      if (n.members.length === 0) {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              \"{\",",
                    "              comments.printDanglingComments(path, options),",
                    "              softline,",
                    "              \"}\"",
                    "            ])",
                    "          )",
                    "        );",
                    "      } else {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              \"{\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  printArrayItems(path, options, \"members\", print),",
                    "                  shouldPrintComma(options, \"es5\") ? \",\" : \"\"",
                    "                ])",
                    "              ),",
                    "              comments.printDanglingComments(",
                    "                path,",
                    "                options,",
                    "                /* sameIndent */ true",
                    "              ),",
                    "              hardline,",
                    "              \"}\"",
                    "            ])",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"TSEnumMember\":",
                    "      parts.push(path.call(print, \"id\"));",
                    "      if (n.initializer) {",
                    "        parts.push(\" = \", path.call(print, \"initializer\"));",
                    "      }",
                    "      return concat(parts);",
                    "    case \"TSImportEqualsDeclaration\":",
                    "      parts.push(",
                    "        printTypeScriptModifiers(path, options, print),",
                    "        \"import \",",
                    "        path.call(print, \"name\"),",
                    "        \" = \",",
                    "        path.call(print, \"moduleReference\")",
                    "      );",
                    "",
                    "      if (options.semi) {",
                    "        parts.push(\";\");",
                    "      }",
                    "",
                    "      return group(concat(parts));",
                    "    case \"TSExternalModuleReference\":",
                    "      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);",
                    "    case \"TSModuleDeclaration\": {",
                    "      const parent = path.getParentNode();",
                    "      const isExternalModule = isLiteral(n.id);",
                    "      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";",
                    "      const bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";",
                    "",
                    "      if (parentIsDeclaration) {",
                    "        parts.push(\".\");",
                    "      } else {",
                    "        if (n.declare === true) {",
                    "          parts.push(\"declare \");",
                    "        }",
                    "        parts.push(printTypeScriptModifiers(path, options, print));",
                    "",
                    "        // Global declaration looks like this:",
                    "        // (declare)? global { ... }",
                    "        const isGlobalDeclaration =",
                    "          n.id.type === \"Identifier\" &&",
                    "          n.id.name === \"global\" &&",
                    "          !/namespace|module/.test(",
                    "            options.originalText.slice(",
                    "              options.locStart(n),",
                    "              options.locStart(n.id)",
                    "            )",
                    "          );",
                    "",
                    "        if (!isGlobalDeclaration) {",
                    "          parts.push(isExternalModule ? \"module \" : \"namespace \");",
                    "        }",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"id\"));",
                    "",
                    "      if (bodyIsDeclaration) {",
                    "        parts.push(path.call(print, \"body\"));",
                    "      } else if (n.body) {",
                    "        parts.push(",
                    "          \" {\",",
                    "          indent(",
                    "            concat([",
                    "              line,",
                    "              path.call(",
                    "                bodyPath =>",
                    "                  comments.printDanglingComments(bodyPath, options, true),",
                    "                \"body\"",
                    "              ),",
                    "              group(path.call(print, \"body\"))",
                    "            ])",
                    "          ),",
                    "          line,",
                    "          \"}\"",
                    "        );",
                    "      } else {",
                    "        parts.push(semi);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"TSModuleBlock\":",
                    "      return path.call(bodyPath => {",
                    "        return printStatementSequence(bodyPath, options, print);",
                    "      }, \"body\");",
                    "",
                    "    case \"PrivateName\":",
                    "      return concat([\"#\", path.call(print, \"id\")]);",
                    "",
                    "    case \"TSConditionalType\":",
                    "      return formatTernaryOperator(path, options, print, {",
                    "        beforeParts: () => [",
                    "          path.call(print, \"checkType\"),",
                    "          \" \",",
                    "          \"extends\",",
                    "          \" \",",
                    "          path.call(print, \"extendsType\")",
                    "        ],",
                    "        shouldCheckJsx: false,",
                    "        operatorName: \"TSConditionalType\",",
                    "        consequentNode: \"trueType\",",
                    "        alternateNode: \"falseType\",",
                    "        testNode: \"checkType\"",
                    "      });",
                    "",
                    "    case \"TSInferType\":",
                    "      return concat([\"infer\", \" \", path.call(print, \"typeParameter\")]);",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown type: \" + JSON.stringify(n.type));",
                    "  }",
                    "}",
                    "",
                    "function printStatementSequence(path, options, print) {",
                    "  const printed = [];",
                    "",
                    "  const bodyNode = path.getNode();",
                    "  const isClass = bodyNode.type === \"ClassBody\";",
                    "",
                    "  path.map((stmtPath, i) => {",
                    "    const stmt = stmtPath.getValue();",
                    "",
                    "    // Just in case the AST has been modified to contain falsy",
                    "    // \"statements,\" it's safer simply to skip them.",
                    "    /* istanbul ignore if */",
                    "    if (!stmt) {",
                    "      return;",
                    "    }",
                    "",
                    "    // Skip printing EmptyStatement nodes to avoid leaving stray",
                    "    // semicolons lying around.",
                    "    if (stmt.type === \"EmptyStatement\") {",
                    "      return;",
                    "    }",
                    "",
                    "    const stmtPrinted = print(stmtPath);",
                    "    const text = options.originalText;",
                    "    const parts = [];",
                    "",
                    "    // in no-semi mode, prepend statement with semicolon if it might break ASI",
                    "    // don't prepend the only JSX element in a program with semicolon",
                    "    if (",
                    "      !options.semi &&",
                    "      !isClass &&",
                    "      !isTheOnlyJSXElementInMarkdown(options, stmtPath) &&",
                    "      stmtNeedsASIProtection(stmtPath, options)",
                    "    ) {",
                    "      if (stmt.comments && stmt.comments.some(comment => comment.leading)) {",
                    "        parts.push(print(stmtPath, { needsSemi: true }));",
                    "      } else {",
                    "        parts.push(\";\", stmtPrinted);",
                    "      }",
                    "    } else {",
                    "      parts.push(stmtPrinted);",
                    "    }",
                    "",
                    "    if (!options.semi && isClass) {",
                    "      if (classPropMayCauseASIProblems(stmtPath)) {",
                    "        parts.push(\";\");",
                    "      } else if (stmt.type === \"ClassProperty\") {",
                    "        const nextChild = bodyNode.body[i + 1];",
                    "        if (classChildNeedsASIProtection(nextChild)) {",
                    "          parts.push(\";\");",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (",
                    "      sharedUtil.isNextLineEmpty(text, stmt, options) &&",
                    "      !isLastStatement(stmtPath)",
                    "    ) {",
                    "      parts.push(hardline);",
                    "    }",
                    "",
                    "    printed.push(concat(parts));",
                    "  });",
                    "",
                    "  return join(hardline, printed);",
                    "}",
                    "",
                    "function printPropertyKey(path, options, print) {",
                    "  const node = path.getNode();",
                    "  const key = node.key;",
                    "",
                    "  if (",
                    "    isStringLiteral(key) &&",
                    "    isIdentifierName(key.value) &&",
                    "    !node.computed &&",
                    "    options.parser !== \"json\"",
                    "  ) {",
                    "    // 'a' -> a",
                    "    return path.call(",
                    "      keyPath => comments.printComments(keyPath, () => key.value, options),",
                    "      \"key\"",
                    "    );",
                    "  }",
                    "  return path.call(print, \"key\");",
                    "}",
                    "",
                    "function printMethod(path, options, print) {",
                    "  const node = path.getNode();",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "  const kind = node.kind;",
                    "  const parts = [];",
                    "",
                    "  if (node.type === \"ObjectMethod\" || node.type === \"ClassMethod\") {",
                    "    node.value = node;",
                    "  }",
                    "",
                    "  if (node.value.async) {",
                    "    parts.push(\"async \");",
                    "  }",
                    "",
                    "  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {",
                    "    if (node.value.generator) {",
                    "      parts.push(\"*\");",
                    "    }",
                    "  } else {",
                    "    assert.ok(kind === \"get\" || kind === \"set\");",
                    "",
                    "    parts.push(kind, \" \");",
                    "  }",
                    "",
                    "  let key = printPropertyKey(path, options, print);",
                    "",
                    "  if (node.computed) {",
                    "    key = concat([\"[\", key, \"]\"]);",
                    "  }",
                    "",
                    "  parts.push(",
                    "    key,",
                    "    concat(",
                    "      path.call(",
                    "        valuePath => [",
                    "          printFunctionTypeParameters(valuePath, options, print),",
                    "          group(",
                    "            concat([",
                    "              printFunctionParams(valuePath, print, options),",
                    "              printReturnType(valuePath, print, options)",
                    "            ])",
                    "          )",
                    "        ],",
                    "        \"value\"",
                    "      )",
                    "    )",
                    "  );",
                    "",
                    "  if (!node.value.body || node.value.body.length === 0) {",
                    "    parts.push(semi);",
                    "  } else {",
                    "    parts.push(\" \", path.call(print, \"value\", \"body\"));",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function couldGroupArg(arg) {",
                    "  return (",
                    "    (arg.type === \"ObjectExpression\" &&",
                    "      (arg.properties.length > 0 || arg.comments)) ||",
                    "    (arg.type === \"ArrayExpression\" &&",
                    "      (arg.elements.length > 0 || arg.comments)) ||",
                    "    arg.type === \"TSTypeAssertionExpression\" ||",
                    "    arg.type === \"TSAsExpression\" ||",
                    "    arg.type === \"FunctionExpression\" ||",
                    "    (arg.type === \"ArrowFunctionExpression\" &&",
                    "      (arg.body.type === \"BlockStatement\" ||",
                    "        arg.body.type === \"ArrowFunctionExpression\" ||",
                    "        arg.body.type === \"ObjectExpression\" ||",
                    "        arg.body.type === \"ArrayExpression\" ||",
                    "        arg.body.type === \"CallExpression\" ||",
                    "        isJSXNode(arg.body)))",
                    "  );",
                    "}",
                    "",
                    "function shouldGroupLastArg(args) {",
                    "  const lastArg = privateUtil.getLast(args);",
                    "  const penultimateArg = privateUtil.getPenultimate(args);",
                    "  return (",
                    "    !hasLeadingComment(lastArg) &&",
                    "    !hasTrailingComment(lastArg) &&",
                    "    couldGroupArg(lastArg) &&",
                    "    // If the last two arguments are of the same type,",
                    "    // disable last element expansion.",
                    "    (!penultimateArg || penultimateArg.type !== lastArg.type)",
                    "  );",
                    "}",
                    "",
                    "function shouldGroupFirstArg(args) {",
                    "  if (args.length !== 2) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const firstArg = args[0];",
                    "  const secondArg = args[1];",
                    "  return (",
                    "    (!firstArg.comments || !firstArg.comments.length) &&",
                    "    (firstArg.type === \"FunctionExpression\" ||",
                    "      (firstArg.type === \"ArrowFunctionExpression\" &&",
                    "        firstArg.body.type === \"BlockStatement\")) &&",
                    "    !couldGroupArg(secondArg)",
                    "  );",
                    "}",
                    "",
                    "function printArgumentsList(path, options, print) {",
                    "  const args = path.getValue().arguments;",
                    "",
                    "  if (args.length === 0) {",
                    "    return concat([",
                    "      \"(\",",
                    "      comments.printDanglingComments(path, options, /* sameIndent */ true),",
                    "      \")\"",
                    "    ]);",
                    "  }",
                    "",
                    "  let anyArgEmptyLine = false;",
                    "  let hasEmptyLineFollowingFirstArg = false;",
                    "  const lastArgIndex = args.length - 1;",
                    "  const printedArguments = path.map((argPath, index) => {",
                    "    const arg = argPath.getNode();",
                    "    const parts = [print(argPath)];",
                    "",
                    "    if (index === lastArgIndex) {",
                    "      // do nothing",
                    "    } else if (sharedUtil.isNextLineEmpty(options.originalText, arg, options)) {",
                    "      if (index === 0) {",
                    "        hasEmptyLineFollowingFirstArg = true;",
                    "      }",
                    "",
                    "      anyArgEmptyLine = true;",
                    "      parts.push(\",\", hardline, hardline);",
                    "    } else {",
                    "      parts.push(\",\", line);",
                    "    }",
                    "",
                    "    return concat(parts);",
                    "  }, \"arguments\");",
                    "",
                    "  const shouldGroupFirst = shouldGroupFirstArg(args);",
                    "  const shouldGroupLast = shouldGroupLastArg(args);",
                    "  if (shouldGroupFirst || shouldGroupLast) {",
                    "    const shouldBreak =",
                    "      (shouldGroupFirst",
                    "        ? printedArguments.slice(1).some(willBreak)",
                    "        : printedArguments.slice(0, -1).some(willBreak)) || anyArgEmptyLine;",
                    "",
                    "    // We want to print the last argument with a special flag",
                    "    let printedExpanded;",
                    "    let i = 0;",
                    "    path.each(argPath => {",
                    "      if (shouldGroupFirst && i === 0) {",
                    "        printedExpanded = [",
                    "          concat([",
                    "            argPath.call(p => print(p, { expandFirstArg: true })),",
                    "            printedArguments.length > 1 ? \",\" : \"\",",
                    "            hasEmptyLineFollowingFirstArg ? hardline : line,",
                    "            hasEmptyLineFollowingFirstArg ? hardline : \"\"",
                    "          ])",
                    "        ].concat(printedArguments.slice(1));",
                    "      }",
                    "      if (shouldGroupLast && i === args.length - 1) {",
                    "        printedExpanded = printedArguments",
                    "          .slice(0, -1)",
                    "          .concat(argPath.call(p => print(p, { expandLastArg: true })));",
                    "      }",
                    "      i++;",
                    "    }, \"arguments\");",
                    "",
                    "    const somePrintedArgumentsWillBreak = printedArguments.some(willBreak);",
                    "",
                    "    const maybeTrailingComma = shouldPrintComma(options, \"all\") ? \",\" : \"\";",
                    "",
                    "    return concat([",
                    "      somePrintedArgumentsWillBreak ? breakParent : \"\",",
                    "      conditionalGroup(",
                    "        [",
                    "          concat([",
                    "            ifBreak(",
                    "              indent(concat([\"(\", softline, concat(printedExpanded)])),",
                    "              concat([\"(\", concat(printedExpanded)])",
                    "            ),",
                    "            somePrintedArgumentsWillBreak",
                    "              ? concat([ifBreak(maybeTrailingComma), softline])",
                    "              : \"\",",
                    "            \")\"",
                    "          ]),",
                    "          shouldGroupFirst",
                    "            ? concat([",
                    "                \"(\",",
                    "                group(printedExpanded[0], { shouldBreak: true }),",
                    "                concat(printedExpanded.slice(1)),",
                    "                \")\"",
                    "              ])",
                    "            : concat([",
                    "                \"(\",",
                    "                concat(printedArguments.slice(0, -1)),",
                    "                group(privateUtil.getLast(printedExpanded), {",
                    "                  shouldBreak: true",
                    "                }),",
                    "                \")\"",
                    "              ]),",
                    "          group(",
                    "            concat([",
                    "              \"(\",",
                    "              indent(concat([line, concat(printedArguments)])),",
                    "              maybeTrailingComma,",
                    "              line,",
                    "              \")\"",
                    "            ]),",
                    "            { shouldBreak: true }",
                    "          )",
                    "        ],",
                    "        { shouldBreak }",
                    "      )",
                    "    ]);",
                    "  }",
                    "",
                    "  return group(",
                    "    concat([",
                    "      \"(\",",
                    "      indent(concat([softline, concat(printedArguments)])),",
                    "      ifBreak(shouldPrintComma(options, \"all\") ? \",\" : \"\"),",
                    "      softline,",
                    "      \")\"",
                    "    ]),",
                    "    { shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine }",
                    "  );",
                    "}",
                    "",
                    "function printTypeAnnotation(path, options, print) {",
                    "  const node = path.getValue();",
                    "  if (!node.typeAnnotation) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const parentNode = path.getParentNode();",
                    "  const isDefinite =",
                    "    node.definite ||",
                    "    (parentNode &&",
                    "      parentNode.type === \"VariableDeclarator\" &&",
                    "      parentNode.definite);",
                    "",
                    "  const isFunctionDeclarationIdentifier =",
                    "    parentNode.type === \"DeclareFunction\" && parentNode.id === node;",
                    "",
                    "  if (",
                    "    isFlowAnnotationComment(options.originalText, node.typeAnnotation, options)",
                    "  ) {",
                    "    return concat([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);",
                    "  }",
                    "",
                    "  return concat([",
                    "    isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \",",
                    "    path.call(print, \"typeAnnotation\")",
                    "  ]);",
                    "}",
                    "",
                    "function printFunctionTypeParameters(path, options, print) {",
                    "  const fun = path.getValue();",
                    "  if (fun.typeParameters) {",
                    "    return path.call(print, \"typeParameters\");",
                    "  }",
                    "  return \"\";",
                    "}",
                    "",
                    "function printFunctionParams(path, print, options, expandArg, printTypeParams) {",
                    "  const fun = path.getValue();",
                    "  const paramsField = fun.parameters ? \"parameters\" : \"params\";",
                    "",
                    "  const typeParams = printTypeParams",
                    "    ? printFunctionTypeParameters(path, options, print)",
                    "    : \"\";",
                    "",
                    "  let printed = [];",
                    "  if (fun[paramsField]) {",
                    "    printed = path.map(print, paramsField);",
                    "  }",
                    "",
                    "  if (fun.rest) {",
                    "    printed.push(concat([\"...\", path.call(print, \"rest\")]));",
                    "  }",
                    "",
                    "  if (printed.length === 0) {",
                    "    return concat([",
                    "      typeParams,",
                    "      \"(\",",
                    "      comments.printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameIndent */ true,",
                    "        comment =>",
                    "          privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "            options.originalText,",
                    "            comment,",
                    "            options.locEnd",
                    "          ) === \")\"",
                    "      ),",
                    "      \")\"",
                    "    ]);",
                    "  }",
                    "",
                    "  const lastParam = privateUtil.getLast(fun[paramsField]);",
                    "",
                    "  // If the parent is a call with the first/last argument expansion and this is the",
                    "  // params of the first/last argument, we dont want the arguments to break and instead",
                    "  // want the whole expression to be on a new line.",
                    "  //",
                    "  // Good:                 Bad:",
                    "  //   verylongcall(         verylongcall((",
                    "  //     (a, b) => {           a,",
                    "  //     }                     b,",
                    "  //   })                    ) => {",
                    "  //                         })",
                    "  if (",
                    "    expandArg &&",
                    "    !(fun[paramsField] && fun[paramsField].some(n => n.comments))",
                    "  ) {",
                    "    return group(",
                    "      concat([",
                    "        docUtils.removeLines(typeParams),",
                    "        \"(\",",
                    "        join(\", \", printed.map(docUtils.removeLines)),",
                    "        \")\"",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  // Single object destructuring should hug",
                    "  //",
                    "  // function({",
                    "  //   a,",
                    "  //   b,",
                    "  //   c",
                    "  // }) {}",
                    "  if (shouldHugArguments(fun)) {",
                    "    return concat([typeParams, \"(\", join(\", \", printed), \")\"]);",
                    "  }",
                    "",
                    "  const parent = path.getParentNode();",
                    "",
                    "  // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`",
                    "  if (parent.type === \"CallExpression\" && isTestCall(parent)) {",
                    "    return concat([typeParams, \"(\", join(\", \", printed), \")\"]);",
                    "  }",
                    "",
                    "  const flowTypeAnnotations = [",
                    "    \"AnyTypeAnnotation\",",
                    "    \"NullLiteralTypeAnnotation\",",
                    "    \"GenericTypeAnnotation\",",
                    "    \"ThisTypeAnnotation\",",
                    "    \"NumberTypeAnnotation\",",
                    "    \"VoidTypeAnnotation\",",
                    "    \"EmptyTypeAnnotation\",",
                    "    \"MixedTypeAnnotation\",",
                    "    \"BooleanTypeAnnotation\",",
                    "    \"BooleanLiteralTypeAnnotation\",",
                    "    \"StringTypeAnnotation\"",
                    "  ];",
                    "",
                    "  const isFlowShorthandWithOneArg =",
                    "    (isObjectTypePropertyAFunction(parent, options) ||",
                    "      isTypeAnnotationAFunction(parent, options) ||",
                    "      parent.type === \"TypeAlias\" ||",
                    "      parent.type === \"UnionTypeAnnotation\" ||",
                    "      parent.type === \"TSUnionType\" ||",
                    "      parent.type === \"IntersectionTypeAnnotation\" ||",
                    "      (parent.type === \"FunctionTypeAnnotation\" &&",
                    "        parent.returnType === fun)) &&",
                    "    fun[paramsField].length === 1 &&",
                    "    fun[paramsField][0].name === null &&",
                    "    fun[paramsField][0].typeAnnotation &&",
                    "    fun.typeParameters === null &&",
                    "    flowTypeAnnotations.indexOf(fun[paramsField][0].typeAnnotation.type) !==",
                    "      -1 &&",
                    "    !(",
                    "      fun[paramsField][0].typeAnnotation.type === \"GenericTypeAnnotation\" &&",
                    "      fun[paramsField][0].typeAnnotation.typeParameters",
                    "    ) &&",
                    "    !fun.rest;",
                    "",
                    "  if (isFlowShorthandWithOneArg) {",
                    "    if (options.arrowParens === \"always\") {",
                    "      return concat([\"(\", concat(printed), \")\"]);",
                    "    }",
                    "    return concat(printed);",
                    "  }",
                    "",
                    "  const canHaveTrailingComma =",
                    "    !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;",
                    "",
                    "  return concat([",
                    "    typeParams,",
                    "    \"(\",",
                    "    indent(concat([softline, join(concat([\",\", line]), printed)])),",
                    "    ifBreak(",
                    "      canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"",
                    "    ),",
                    "    softline,",
                    "    \")\"",
                    "  ]);",
                    "}",
                    "",
                    "function shouldPrintParamsWithoutParens(path, options) {",
                    "  if (options.arrowParens === \"always\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (options.arrowParens === \"avoid\") {",
                    "    const node = path.getValue();",
                    "    return canPrintParamsWithoutParens(node);",
                    "  }",
                    "",
                    "  // Fallback default; should be unreachable",
                    "  return false;",
                    "}",
                    "",
                    "function canPrintParamsWithoutParens(node) {",
                    "  return (",
                    "    node.params.length === 1 &&",
                    "    !node.rest &&",
                    "    !node.typeParameters &&",
                    "    !hasDanglingComments(node) &&",
                    "    node.params[0].type === \"Identifier\" &&",
                    "    !node.params[0].typeAnnotation &&",
                    "    !node.params[0].comments &&",
                    "    !node.params[0].optional &&",
                    "    !node.predicate &&",
                    "    !node.returnType",
                    "  );",
                    "}",
                    "",
                    "function printFunctionDeclaration(path, print, options) {",
                    "  const n = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  if (n.async) {",
                    "    parts.push(\"async \");",
                    "  }",
                    "",
                    "  parts.push(\"function\");",
                    "",
                    "  if (n.generator) {",
                    "    parts.push(\"*\");",
                    "  }",
                    "  if (n.id) {",
                    "    parts.push(\" \", path.call(print, \"id\"));",
                    "  }",
                    "",
                    "  parts.push(",
                    "    printFunctionTypeParameters(path, options, print),",
                    "    group(",
                    "      concat([",
                    "        printFunctionParams(path, print, options),",
                    "        printReturnType(path, print, options)",
                    "      ])",
                    "    ),",
                    "    n.body ? \" \" : \"\",",
                    "    path.call(print, \"body\")",
                    "  );",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printObjectMethod(path, options, print) {",
                    "  const objMethod = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  if (objMethod.async) {",
                    "    parts.push(\"async \");",
                    "  }",
                    "  if (objMethod.generator) {",
                    "    parts.push(\"*\");",
                    "  }",
                    "  if (",
                    "    objMethod.method ||",
                    "    objMethod.kind === \"get\" ||",
                    "    objMethod.kind === \"set\"",
                    "  ) {",
                    "    return printMethod(path, options, print);",
                    "  }",
                    "",
                    "  const key = printPropertyKey(path, options, print);",
                    "",
                    "  if (objMethod.computed) {",
                    "    parts.push(\"[\", key, \"]\");",
                    "  } else {",
                    "    parts.push(key);",
                    "  }",
                    "",
                    "  parts.push(",
                    "    printFunctionTypeParameters(path, options, print),",
                    "    group(",
                    "      concat([",
                    "        printFunctionParams(path, print, options),",
                    "        printReturnType(path, print, options)",
                    "      ])",
                    "    ),",
                    "    \" \",",
                    "    path.call(print, \"body\")",
                    "  );",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printReturnType(path, print, options) {",
                    "  const n = path.getValue();",
                    "  const returnType = path.call(print, \"returnType\");",
                    "",
                    "  if (",
                    "    n.returnType &&",
                    "    isFlowAnnotationComment(options.originalText, n.returnType, options)",
                    "  ) {",
                    "    return concat([\" /*: \", returnType, \" */\"]);",
                    "  }",
                    "",
                    "  const parts = [returnType];",
                    "",
                    "  // prepend colon to TypeScript type annotation",
                    "  if (n.returnType && n.returnType.typeAnnotation) {",
                    "    parts.unshift(\": \");",
                    "  }",
                    "",
                    "  if (n.predicate) {",
                    "    // The return type will already add the colon, but otherwise we",
                    "    // need to do it ourselves",
                    "    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printExportDeclaration(path, options, print) {",
                    "  const decl = path.getValue();",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "  const parts = [\"export \"];",
                    "",
                    "  const isDefault = decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\";",
                    "",
                    "  if (isDefault) {",
                    "    parts.push(\"default \");",
                    "  }",
                    "",
                    "  parts.push(",
                    "    comments.printDanglingComments(path, options, /* sameIndent */ true)",
                    "  );",
                    "",
                    "  if (decl.declaration) {",
                    "    parts.push(path.call(print, \"declaration\"));",
                    "",
                    "    if (",
                    "      isDefault &&",
                    "      (decl.declaration.type !== \"ClassDeclaration\" &&",
                    "        decl.declaration.type !== \"FunctionDeclaration\" &&",
                    "        decl.declaration.type !== \"TSAbstractClassDeclaration\" &&",
                    "        decl.declaration.type !== \"DeclareClass\" &&",
                    "        decl.declaration.type !== \"DeclareFunction\")",
                    "    ) {",
                    "      parts.push(semi);",
                    "    }",
                    "  } else {",
                    "    if (decl.specifiers && decl.specifiers.length > 0) {",
                    "      const specifiers = [];",
                    "      const defaultSpecifiers = [];",
                    "      const namespaceSpecifiers = [];",
                    "      path.each(specifierPath => {",
                    "        const specifierType = path.getValue().type;",
                    "        if (specifierType === \"ExportSpecifier\") {",
                    "          specifiers.push(print(specifierPath));",
                    "        } else if (specifierType === \"ExportDefaultSpecifier\") {",
                    "          defaultSpecifiers.push(print(specifierPath));",
                    "        } else if (specifierType === \"ExportNamespaceSpecifier\") {",
                    "          namespaceSpecifiers.push(concat([\"* as \", print(specifierPath)]));",
                    "        }",
                    "      }, \"specifiers\");",
                    "",
                    "      const isNamespaceFollowed =",
                    "        namespaceSpecifiers.length !== 0 && specifiers.length !== 0;",
                    "",
                    "      const isDefaultFollowed =",
                    "        defaultSpecifiers.length !== 0 &&",
                    "        (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);",
                    "",
                    "      parts.push(",
                    "        decl.exportKind === \"type\" ? \"type \" : \"\",",
                    "        concat(defaultSpecifiers),",
                    "        concat([isDefaultFollowed ? \", \" : \"\"]),",
                    "        concat(namespaceSpecifiers),",
                    "        concat([isNamespaceFollowed ? \", \" : \"\"]),",
                    "        specifiers.length !== 0",
                    "          ? group(",
                    "              concat([",
                    "                \"{\",",
                    "                indent(",
                    "                  concat([",
                    "                    options.bracketSpacing ? line : softline,",
                    "                    join(concat([\",\", line]), specifiers)",
                    "                  ])",
                    "                ),",
                    "                ifBreak(shouldPrintComma(options) ? \",\" : \"\"),",
                    "                options.bracketSpacing ? line : softline,",
                    "                \"}\"",
                    "              ])",
                    "            )",
                    "          : \"\"",
                    "      );",
                    "    } else {",
                    "      parts.push(\"{}\");",
                    "    }",
                    "",
                    "    if (decl.source) {",
                    "      parts.push(\" from \", path.call(print, \"source\"));",
                    "    }",
                    "",
                    "    parts.push(semi);",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printFlowDeclaration(path, parts) {",
                    "  const parentExportDecl = privateUtil.getParentExportDeclaration(path);",
                    "",
                    "  if (parentExportDecl) {",
                    "    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");",
                    "  } else {",
                    "    // If the parent node has type DeclareExportDeclaration, then it",
                    "    // will be responsible for printing the \"declare\" token. Otherwise",
                    "    // it needs to be printed with this non-exported declaration node.",
                    "    parts.unshift(\"declare \");",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function getFlowVariance(path) {",
                    "  if (!path.variance) {",
                    "    return null;",
                    "  }",
                    "",
                    "  // Babylon 7.0 currently uses variance node type, and flow should",
                    "  // follow suit soon:",
                    "  // https://github.com/babel/babel/issues/4722",
                    "  const variance = path.variance.kind || path.variance;",
                    "",
                    "  switch (variance) {",
                    "    case \"plus\":",
                    "      return \"+\";",
                    "    case \"minus\":",
                    "      return \"-\";",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      return variance;",
                    "  }",
                    "}",
                    "",
                    "function printTypeScriptModifiers(path, options, print) {",
                    "  const n = path.getValue();",
                    "  if (!n.modifiers || !n.modifiers.length) {",
                    "    return \"\";",
                    "  }",
                    "  return concat([join(\" \", path.map(print, \"modifiers\")), \" \"]);",
                    "}",
                    "",
                    "function printTypeParameters(path, options, print, paramsKey) {",
                    "  const n = path.getValue();",
                    "",
                    "  if (!n[paramsKey]) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  // for TypeParameterDeclaration typeParameters is a single node",
                    "  if (!Array.isArray(n[paramsKey])) {",
                    "    return path.call(print, paramsKey);",
                    "  }",
                    "",
                    "  const grandparent = path.getNode(2);",
                    "",
                    "  const isParameterInTestCall =",
                    "    grandparent != null &&",
                    "    grandparent.type === \"CallExpression\" &&",
                    "    isTestCall(grandparent);",
                    "",
                    "  const shouldInline =",
                    "    isParameterInTestCall ||",
                    "    n[paramsKey].length === 0 ||",
                    "    (n[paramsKey].length === 1 &&",
                    "      (shouldHugType(n[paramsKey][0]) ||",
                    "        (n[paramsKey][0].type === \"GenericTypeAnnotation\" &&",
                    "          shouldHugType(n[paramsKey][0].id)) ||",
                    "        (n[paramsKey][0].type === \"TSTypeReference\" &&",
                    "          shouldHugType(n[paramsKey][0].typeName)) ||",
                    "        n[paramsKey][0].type === \"NullableTypeAnnotation\"));",
                    "",
                    "  if (shouldInline) {",
                    "    return concat([\"<\", join(\", \", path.map(print, paramsKey)), \">\"]);",
                    "  }",
                    "",
                    "  return group(",
                    "    concat([",
                    "      \"<\",",
                    "      indent(",
                    "        concat([",
                    "          softline,",
                    "          join(concat([\",\", line]), path.map(print, paramsKey))",
                    "        ])",
                    "      ),",
                    "      ifBreak(",
                    "        options.parser !== \"typescript\" && shouldPrintComma(options, \"all\")",
                    "          ? \",\"",
                    "          : \"\"",
                    "      ),",
                    "      softline,",
                    "      \">\"",
                    "    ])",
                    "  );",
                    "}",
                    "",
                    "function printClass(path, options, print) {",
                    "  const n = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  if (n.type === \"TSAbstractClassDeclaration\") {",
                    "    parts.push(\"abstract \");",
                    "  }",
                    "",
                    "  parts.push(\"class\");",
                    "",
                    "  if (n.id) {",
                    "    parts.push(\" \", path.call(print, \"id\"));",
                    "  }",
                    "",
                    "  parts.push(path.call(print, \"typeParameters\"));",
                    "",
                    "  const partsGroup = [];",
                    "  if (n.superClass) {",
                    "    const printed = concat([",
                    "      \"extends \",",
                    "      path.call(print, \"superClass\"),",
                    "      path.call(print, \"superTypeParameters\")",
                    "    ]);",
                    "    // Keep old behaviour of extends in same line",
                    "    // If there is only on extends and there are not comments",
                    "    if (",
                    "      (!n.implements || n.implements.length === 0) &&",
                    "      (!n.superClass.comments || n.superClass.comments.length === 0)",
                    "    ) {",
                    "      parts.push(",
                    "        concat([",
                    "          \" \",",
                    "          path.call(",
                    "            superClass =>",
                    "              comments.printComments(superClass, () => printed, options),",
                    "            \"superClass\"",
                    "          )",
                    "        ])",
                    "      );",
                    "    } else {",
                    "      partsGroup.push(",
                    "        group(",
                    "          concat([",
                    "            line,",
                    "            path.call(",
                    "              superClass =>",
                    "                comments.printComments(superClass, () => printed, options),",
                    "              \"superClass\"",
                    "            )",
                    "          ])",
                    "        )",
                    "      );",
                    "    }",
                    "  } else if (n.extends && n.extends.length > 0) {",
                    "    parts.push(\" extends \", join(\", \", path.map(print, \"extends\")));",
                    "  }",
                    "",
                    "  if (n[\"implements\"] && n[\"implements\"].length > 0) {",
                    "    partsGroup.push(",
                    "      line,",
                    "      \"implements\",",
                    "      group(",
                    "        indent(",
                    "          concat([",
                    "            line,",
                    "            join(concat([\",\", line]), path.map(print, \"implements\"))",
                    "          ])",
                    "        )",
                    "      )",
                    "    );",
                    "  }",
                    "",
                    "  if (n[\"mixins\"] && n[\"mixins\"].length > 0) {",
                    "    partsGroup.push(",
                    "      line,",
                    "      \"mixins \",",
                    "      group(indent(join(concat([\",\", line]), path.map(print, \"mixins\"))))",
                    "    );",
                    "  }",
                    "",
                    "  if (partsGroup.length > 0) {",
                    "    parts.push(group(indent(concat(partsGroup))));",
                    "  }",
                    "",
                    "  if (",
                    "    n.body &&",
                    "    n.body.comments &&",
                    "    hasLeadingOwnLineComment(options.originalText, n.body, options)",
                    "  ) {",
                    "    parts.push(hardline);",
                    "  } else {",
                    "    parts.push(\" \");",
                    "  }",
                    "  parts.push(path.call(print, \"body\"));",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printOptionalToken(path) {",
                    "  const node = path.getValue();",
                    "  if (!node.optional) {",
                    "    return \"\";",
                    "  }",
                    "  if (",
                    "    node.type === \"CallExpression\" ||",
                    "    (node.type === \"MemberExpression\" && node.computed)",
                    "  ) {",
                    "    return \"?.\";",
                    "  }",
                    "  return \"?\";",
                    "}",
                    "",
                    "function printMemberLookup(path, options, print) {",
                    "  const property = path.call(print, \"property\");",
                    "  const n = path.getValue();",
                    "  const optional = printOptionalToken(path);",
                    "",
                    "  if (!n.computed) {",
                    "    return concat([optional, \".\", property]);",
                    "  }",
                    "",
                    "  if (!n.property || isNumericLiteral(n.property)) {",
                    "    return concat([optional, \"[\", property, \"]\"]);",
                    "  }",
                    "",
                    "  return group(",
                    "    concat([optional, \"[\", indent(concat([softline, property])), softline, \"]\"])",
                    "  );",
                    "}",
                    "",
                    "function printBindExpressionCallee(path, options, print) {",
                    "  return concat([\"::\", path.call(print, \"callee\")]);",
                    "}",
                    "",
                    "// We detect calls on member expressions specially to format a",
                    "// common pattern better. The pattern we are looking for is this:",
                    "//",
                    "// arr",
                    "//   .map(x => x + 1)",
                    "//   .filter(x => x > 10)",
                    "//   .some(x => x % 2)",
                    "//",
                    "// The way it is structured in the AST is via a nested sequence of",
                    "// MemberExpression and CallExpression. We need to traverse the AST",
                    "// and make groups out of it to print it in the desired way.",
                    "function printMemberChain(path, options, print) {",
                    "  // The first phase is to linearize the AST by traversing it down.",
                    "  //",
                    "  //   a().b()",
                    "  // has the following AST structure:",
                    "  //   CallExpression(MemberExpression(CallExpression(Identifier)))",
                    "  // and we transform it into",
                    "  //   [Identifier, CallExpression, MemberExpression, CallExpression]",
                    "  const printedNodes = [];",
                    "",
                    "  // Here we try to retain one typed empty line after each call expression or",
                    "  // the first group whether it is in parentheses or not",
                    "  function shouldInsertEmptyLineAfter(node) {",
                    "    const originalText = options.originalText;",
                    "    const nextCharIndex = sharedUtil.getNextNonSpaceNonCommentCharacterIndex(",
                    "      originalText,",
                    "      node,",
                    "      options",
                    "    );",
                    "    const nextChar = originalText.charAt(nextCharIndex);",
                    "",
                    "    // if it is cut off by a parenthesis, we only account for one typed empty",
                    "    // line after that parenthesis",
                    "    if (nextChar == \")\") {",
                    "      return sharedUtil.isNextLineEmptyAfterIndex(",
                    "        originalText,",
                    "        nextCharIndex + 1,",
                    "        options",
                    "      );",
                    "    }",
                    "",
                    "    return sharedUtil.isNextLineEmpty(originalText, node, options);",
                    "  }",
                    "",
                    "  function rec(path) {",
                    "    const node = path.getValue();",
                    "    if (",
                    "      node.type === \"CallExpression\" &&",
                    "      (isMemberish(node.callee) || node.callee.type === \"CallExpression\")",
                    "    ) {",
                    "      printedNodes.unshift({",
                    "        node: node,",
                    "        printed: concat([",
                    "          comments.printComments(",
                    "            path,",
                    "            () =>",
                    "              concat([",
                    "                printOptionalToken(path),",
                    "                printFunctionTypeParameters(path, options, print),",
                    "                printArgumentsList(path, options, print)",
                    "              ]),",
                    "            options",
                    "          ),",
                    "          shouldInsertEmptyLineAfter(node) ? hardline : \"\"",
                    "        ])",
                    "      });",
                    "      path.call(callee => rec(callee), \"callee\");",
                    "    } else if (isMemberish(node)) {",
                    "      printedNodes.unshift({",
                    "        node: node,",
                    "        printed: comments.printComments(",
                    "          path,",
                    "          () =>",
                    "            node.type === \"MemberExpression\"",
                    "              ? printMemberLookup(path, options, print)",
                    "              : printBindExpressionCallee(path, options, print),",
                    "          options",
                    "        )",
                    "      });",
                    "      path.call(object => rec(object), \"object\");",
                    "    } else if (node.type === \"TSNonNullExpression\") {",
                    "      printedNodes.unshift({",
                    "        node: node,",
                    "        printed: comments.printComments(path, () => \"!\", options)",
                    "      });",
                    "      path.call(expression => rec(expression), \"expression\");",
                    "    } else {",
                    "      printedNodes.unshift({",
                    "        node: node,",
                    "        printed: path.call(print)",
                    "      });",
                    "    }",
                    "  }",
                    "  // Note: the comments of the root node have already been printed, so we",
                    "  // need to extract this first call without printing them as they would",
                    "  // if handled inside of the recursive call.",
                    "  const node = path.getValue();",
                    "  printedNodes.unshift({",
                    "    node,",
                    "    printed: concat([",
                    "      printOptionalToken(path),",
                    "      printFunctionTypeParameters(path, options, print),",
                    "      printArgumentsList(path, options, print)",
                    "    ])",
                    "  });",
                    "  path.call(callee => rec(callee), \"callee\");",
                    "",
                    "  // Once we have a linear list of printed nodes, we want to create groups out",
                    "  // of it.",
                    "  //",
                    "  //   a().b.c().d().e",
                    "  // will be grouped as",
                    "  //   [",
                    "  //     [Identifier, CallExpression],",
                    "  //     [MemberExpression, MemberExpression, CallExpression],",
                    "  //     [MemberExpression, CallExpression],",
                    "  //     [MemberExpression],",
                    "  //   ]",
                    "  // so that we can print it as",
                    "  //   a()",
                    "  //     .b.c()",
                    "  //     .d()",
                    "  //     .e",
                    "",
                    "  // The first group is the first node followed by",
                    "  //   - as many CallExpression as possible",
                    "  //       < fn()()() >.something()",
                    "  //   - as many array acessors as possible",
                    "  //       < fn()[0][1][2] >.something()",
                    "  //   - then, as many MemberExpression as possible but the last one",
                    "  //       < this.items >.something()",
                    "  const groups = [];",
                    "  let currentGroup = [printedNodes[0]];",
                    "  let i = 1;",
                    "  for (; i < printedNodes.length; ++i) {",
                    "    if (",
                    "      printedNodes[i].node.type === \"TSNonNullExpression\" ||",
                    "      printedNodes[i].node.type === \"CallExpression\" ||",
                    "      (printedNodes[i].node.type === \"MemberExpression\" &&",
                    "        printedNodes[i].node.computed &&",
                    "        isNumericLiteral(printedNodes[i].node.property))",
                    "    ) {",
                    "      currentGroup.push(printedNodes[i]);",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "  if (printedNodes[0].node.type !== \"CallExpression\") {",
                    "    for (; i + 1 < printedNodes.length; ++i) {",
                    "      if (",
                    "        isMemberish(printedNodes[i].node) &&",
                    "        isMemberish(printedNodes[i + 1].node)",
                    "      ) {",
                    "        currentGroup.push(printedNodes[i]);",
                    "      } else {",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "  groups.push(currentGroup);",
                    "  currentGroup = [];",
                    "",
                    "  // Then, each following group is a sequence of MemberExpression followed by",
                    "  // a sequence of CallExpression. To compute it, we keep adding things to the",
                    "  // group until we has seen a CallExpression in the past and reach a",
                    "  // MemberExpression",
                    "  let hasSeenCallExpression = false;",
                    "  for (; i < printedNodes.length; ++i) {",
                    "    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {",
                    "      // [0] should be appended at the end of the group instead of the",
                    "      // beginning of the next one",
                    "      if (",
                    "        printedNodes[i].node.computed &&",
                    "        isNumericLiteral(printedNodes[i].node.property)",
                    "      ) {",
                    "        currentGroup.push(printedNodes[i]);",
                    "        continue;",
                    "      }",
                    "",
                    "      groups.push(currentGroup);",
                    "      currentGroup = [];",
                    "      hasSeenCallExpression = false;",
                    "    }",
                    "",
                    "    if (printedNodes[i].node.type === \"CallExpression\") {",
                    "      hasSeenCallExpression = true;",
                    "    }",
                    "    currentGroup.push(printedNodes[i]);",
                    "",
                    "    if (",
                    "      printedNodes[i].node.comments &&",
                    "      printedNodes[i].node.comments.some(comment => comment.trailing)",
                    "    ) {",
                    "      groups.push(currentGroup);",
                    "      currentGroup = [];",
                    "      hasSeenCallExpression = false;",
                    "    }",
                    "  }",
                    "  if (currentGroup.length > 0) {",
                    "    groups.push(currentGroup);",
                    "  }",
                    "",
                    "  // There are cases like Object.keys(), Observable.of(), _.values() where",
                    "  // they are the subject of all the chained calls and therefore should",
                    "  // be kept on the same line:",
                    "  //",
                    "  //   Object.keys(items)",
                    "  //     .filter(x => x)",
                    "  //     .map(x => x)",
                    "  //",
                    "  // In order to detect those cases, we use an heuristic: if the first",
                    "  // node is just an identifier with the name starting with a capital",
                    "  // letter, just a sequence of _$ or this. The rationale is that they are",
                    "  // likely to be factories.",
                    "  function isFactory(name) {",
                    "    return name.match(/(^[A-Z])|^[_$]+$/);",
                    "  }",
                    "  const shouldMerge =",
                    "    groups.length >= 2 &&",
                    "    !groups[1][0].node.comments &&",
                    "    ((groups[0].length === 1 &&",
                    "      (groups[0][0].node.type === \"ThisExpression\" ||",
                    "        (groups[0][0].node.type === \"Identifier\" &&",
                    "          (isFactory(groups[0][0].node.name) ||",
                    "            (groups[1].length && groups[1][0].node.computed))))) ||",
                    "      (groups[0].length > 1 &&",
                    "        groups[0][groups[0].length - 1].node.type === \"MemberExpression\" &&",
                    "        groups[0][groups[0].length - 1].node.property.type === \"Identifier\" &&",
                    "        (isFactory(groups[0][groups[0].length - 1].node.property.name) ||",
                    "          (groups[1].length && groups[1][0].node.computed))));",
                    "",
                    "  function printGroup(printedGroup) {",
                    "    return concat(printedGroup.map(tuple => tuple.printed));",
                    "  }",
                    "",
                    "  function printIndentedGroup(groups) {",
                    "    if (groups.length === 0) {",
                    "      return \"\";",
                    "    }",
                    "    return indent(",
                    "      group(concat([hardline, join(hardline, groups.map(printGroup))]))",
                    "    );",
                    "  }",
                    "",
                    "  const printedGroups = groups.map(printGroup);",
                    "  const oneLine = concat(printedGroups);",
                    "",
                    "  const cutoff = shouldMerge ? 3 : 2;",
                    "  const flatGroups = groups",
                    "    .slice(0, cutoff)",
                    "    .reduce((res, group) => res.concat(group), []);",
                    "",
                    "  const hasComment =",
                    "    flatGroups.slice(1, -1).some(node => hasLeadingComment(node.node)) ||",
                    "    flatGroups.slice(0, -1).some(node => hasTrailingComment(node.node)) ||",
                    "    (groups[cutoff] && hasLeadingComment(groups[cutoff][0].node));",
                    "",
                    "  // If we only have a single `.`, we shouldn't do anything fancy and just",
                    "  // render everything concatenated together.",
                    "  if (groups.length <= cutoff && !hasComment) {",
                    "    return group(oneLine);",
                    "  }",
                    "",
                    "  // Find out the last node in the first group and check if it has an",
                    "  // empty line after",
                    "  const lastNodeBeforeIndent = privateUtil.getLast(",
                    "    shouldMerge ? groups.slice(1, 2)[0] : groups[0]",
                    "  ).node;",
                    "  const shouldHaveEmptyLineBeforeIndent =",
                    "    lastNodeBeforeIndent.type !== \"CallExpression\" &&",
                    "    shouldInsertEmptyLineAfter(lastNodeBeforeIndent);",
                    "",
                    "  const expanded = concat([",
                    "    printGroup(groups[0]),",
                    "    shouldMerge ? concat(groups.slice(1, 2).map(printGroup)) : \"\",",
                    "    shouldHaveEmptyLineBeforeIndent ? hardline : \"\",",
                    "    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))",
                    "  ]);",
                    "",
                    "  const callExpressionCount = printedNodes.filter(",
                    "    tuple => tuple.node.type === \"CallExpression\"",
                    "  ).length;",
                    "",
                    "  // We don't want to print in one line if there's:",
                    "  //  * A comment.",
                    "  //  * 3 or more chained calls.",
                    "  //  * Any group but the last one has a hard line.",
                    "  // If the last group is a function it's okay to inline if it fits.",
                    "  if (",
                    "    hasComment ||",
                    "    callExpressionCount >= 3 ||",
                    "    printedGroups.slice(0, -1).some(willBreak)",
                    "  ) {",
                    "    return group(expanded);",
                    "  }",
                    "",
                    "  return concat([",
                    "    // We only need to check `oneLine` because if `expanded` is chosen",
                    "    // that means that the parent group has already been broken",
                    "    // naturally",
                    "    willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\",",
                    "    conditionalGroup([oneLine, expanded])",
                    "  ]);",
                    "}",
                    "",
                    "function isJSXNode(node) {",
                    "  return (",
                    "    node.type === \"JSXElement\" ||",
                    "    node.type === \"JSXFragment\" ||",
                    "    node.type === \"TSJsxFragment\"",
                    "  );",
                    "}",
                    "",
                    "function isEmptyJSXElement(node) {",
                    "  if (node.children.length === 0) {",
                    "    return true;",
                    "  }",
                    "  if (node.children.length > 1) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // if there is one text child and does not contain any meaningful text",
                    "  // we can treat the element as empty.",
                    "  const child = node.children[0];",
                    "  return isLiteral(child) && !isMeaningfulJSXText(child);",
                    "}",
                    "",
                    "// Only space, newline, carriage return, and tab are treated as whitespace",
                    "// inside JSX.",
                    "const jsxWhitespaceChars = \" \\n\\r\\t\";",
                    "const containsNonJsxWhitespaceRegex = new RegExp(",
                    "  \"[^\" + jsxWhitespaceChars + \"]\"",
                    ");",
                    "const matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\");",
                    "",
                    "// Meaningful if it contains non-whitespace characters,",
                    "// or it contains whitespace without a new line.",
                    "function isMeaningfulJSXText(node) {",
                    "  return (",
                    "    isLiteral(node) &&",
                    "    (containsNonJsxWhitespaceRegex.test(rawText(node)) ||",
                    "      !/\\n/.test(rawText(node)))",
                    "  );",
                    "}",
                    "",
                    "function conditionalExpressionChainContainsJSX(node) {",
                    "  return Boolean(getConditionalChainContents(node).find(isJSXNode));",
                    "}",
                    "",
                    "// If we have nested conditional expressions, we want to print them in JSX mode",
                    "// if there's at least one JSXElement somewhere in the tree.",
                    "//",
                    "// A conditional expression chain like this should be printed in normal mode,",
                    "// because there aren't JSXElements anywhere in it:",
                    "//",
                    "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";",
                    "//",
                    "// But a conditional expression chain like this should be printed in JSX mode,",
                    "// because there is a JSXElement in the last ConditionalExpression:",
                    "//",
                    "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;",
                    "//",
                    "// This type of ConditionalExpression chain is structured like this in the AST:",
                    "//",
                    "// ConditionalExpression {",
                    "//   test: ...,",
                    "//   consequent: ...,",
                    "//   alternate: ConditionalExpression {",
                    "//     test: ...,",
                    "//     consequent: ...,",
                    "//     alternate: ConditionalExpression {",
                    "//       test: ...,",
                    "//       consequent: ...,",
                    "//       alternate: ...,",
                    "//     }",
                    "//   }",
                    "// }",
                    "//",
                    "// We want to traverse over that shape and convert it into a flat structure so",
                    "// that we can find if there's a JSXElement somewhere inside.",
                    "function getConditionalChainContents(node) {",
                    "  // Given this code:",
                    "  //",
                    "  // // Using a ConditionalExpression as the consequent is uncommon, but should",
                    "  // // be handled.",
                    "  // A ? B : C ? D : E ? F ? G : H : I",
                    "  //",
                    "  // which has this AST:",
                    "  //",
                    "  // ConditionalExpression {",
                    "  //   test: Identifier(A),",
                    "  //   consequent: Identifier(B),",
                    "  //   alternate: ConditionalExpression {",
                    "  //     test: Identifier(C),",
                    "  //     consequent: Identifier(D),",
                    "  //     alternate: ConditionalExpression {",
                    "  //       test: Identifier(E),",
                    "  //       consequent: ConditionalExpression {",
                    "  //         test: Identifier(F),",
                    "  //         consequent: Identifier(G),",
                    "  //         alternate: Identifier(H),",
                    "  //       },",
                    "  //       alternate: Identifier(I),",
                    "  //     }",
                    "  //   }",
                    "  // }",
                    "  //",
                    "  // we should return this Array:",
                    "  //",
                    "  // [",
                    "  //   Identifier(A),",
                    "  //   Identifier(B),",
                    "  //   Identifier(C),",
                    "  //   Identifier(D),",
                    "  //   Identifier(E),",
                    "  //   Identifier(F),",
                    "  //   Identifier(G),",
                    "  //   Identifier(H),",
                    "  //   Identifier(I)",
                    "  // ];",
                    "  //",
                    "  // This loses the information about whether each node was the test,",
                    "  // consequent, or alternate, but we don't care about that here- we are only",
                    "  // flattening this structure to find if there's any JSXElements inside.",
                    "  const nonConditionalExpressions = [];",
                    "",
                    "  function recurse(node) {",
                    "    if (node.type === \"ConditionalExpression\") {",
                    "      recurse(node.test);",
                    "      recurse(node.consequent);",
                    "      recurse(node.alternate);",
                    "    } else {",
                    "      nonConditionalExpressions.push(node);",
                    "    }",
                    "  }",
                    "  recurse(node);",
                    "",
                    "  return nonConditionalExpressions;",
                    "}",
                    "",
                    "// Detect an expression node representing `{\" \"}`",
                    "function isJSXWhitespaceExpression(node) {",
                    "  return (",
                    "    node.type === \"JSXExpressionContainer\" &&",
                    "    isLiteral(node.expression) &&",
                    "    node.expression.value === \" \" &&",
                    "    !node.expression.comments",
                    "  );",
                    "}",
                    "",
                    "// JSX Children are strange, mostly for two reasons:",
                    "// 1. JSX reads newlines into string values, instead of skipping them like JS",
                    "// 2. up to one whitespace between elements within a line is significant,",
                    "//    but not between lines.",
                    "//",
                    "// Leading, trailing, and lone whitespace all need to",
                    "// turn themselves into the rather ugly `{' '}` when breaking.",
                    "//",
                    "// We print JSX using the `fill` doc primitive.",
                    "// This requires that we give it an array of alternating",
                    "// content and whitespace elements.",
                    "// To ensure this we add dummy `\"\"` content elements as needed.",
                    "function printJSXChildren(path, options, print, jsxWhitespace) {",
                    "  const n = path.getValue();",
                    "  const children = [];",
                    "",
                    "  // using `map` instead of `each` because it provides `i`",
                    "  path.map((childPath, i) => {",
                    "    const child = childPath.getValue();",
                    "    if (isLiteral(child)) {",
                    "      const text = rawText(child);",
                    "",
                    "      // Contains a non-whitespace character",
                    "      if (isMeaningfulJSXText(child)) {",
                    "        const words = text.split(matchJsxWhitespaceRegex);",
                    "",
                    "        // Starts with whitespace",
                    "        if (words[0] === \"\") {",
                    "          children.push(\"\");",
                    "          words.shift();",
                    "          if (/\\n/.test(words[0])) {",
                    "            children.push(hardline);",
                    "          } else {",
                    "            children.push(jsxWhitespace);",
                    "          }",
                    "          words.shift();",
                    "        }",
                    "",
                    "        let endWhitespace;",
                    "        // Ends with whitespace",
                    "        if (privateUtil.getLast(words) === \"\") {",
                    "          words.pop();",
                    "          endWhitespace = words.pop();",
                    "        }",
                    "",
                    "        // This was whitespace only without a new line.",
                    "        if (words.length === 0) {",
                    "          return;",
                    "        }",
                    "",
                    "        words.forEach((word, i) => {",
                    "          if (i % 2 === 1) {",
                    "            children.push(line);",
                    "          } else {",
                    "            children.push(word);",
                    "          }",
                    "        });",
                    "",
                    "        if (endWhitespace !== undefined) {",
                    "          if (/\\n/.test(endWhitespace)) {",
                    "            children.push(hardline);",
                    "          } else {",
                    "            children.push(jsxWhitespace);",
                    "          }",
                    "        } else {",
                    "          // Ideally this would be a `hardline` to allow a break between",
                    "          // tags and text.",
                    "          // Unfortunately Facebook have a custom translation pipeline",
                    "          // (https://github.com/prettier/prettier/issues/1581#issuecomment-300975032)",
                    "          // that uses the JSX syntax, but does not follow the React whitespace",
                    "          // rules.",
                    "          // Ensuring that we never have a break between tags and text in JSX",
                    "          // will allow Facebook to adopt Prettier without too much of an",
                    "          // adverse effect on formatting algorithm.",
                    "          children.push(\"\");",
                    "        }",
                    "      } else if (/\\n/.test(text)) {",
                    "        // Keep (up to one) blank line between tags/expressions/text.",
                    "        // Note: We don't keep blank lines between text elements.",
                    "        if (text.match(/\\n/g).length > 1) {",
                    "          children.push(\"\");",
                    "          children.push(hardline);",
                    "        }",
                    "      } else {",
                    "        children.push(\"\");",
                    "        children.push(jsxWhitespace);",
                    "      }",
                    "    } else {",
                    "      const printedChild = print(childPath);",
                    "      children.push(printedChild);",
                    "",
                    "      const next = n.children[i + 1];",
                    "      const directlyFollowedByMeaningfulText =",
                    "        next && isMeaningfulJSXText(next) && !/^[ \\n\\r\\t]/.test(rawText(next));",
                    "      if (directlyFollowedByMeaningfulText) {",
                    "        // Potentially this could be a hardline as well.",
                    "        // See the comment above about the Facebook translation pipeline as",
                    "        // to why this is an empty string.",
                    "        children.push(\"\");",
                    "      } else {",
                    "        children.push(hardline);",
                    "      }",
                    "    }",
                    "  }, \"children\");",
                    "",
                    "  return children;",
                    "}",
                    "",
                    "// JSX expands children from the inside-out, instead of the outside-in.",
                    "// This is both to break children before attributes,",
                    "// and to ensure that when children break, their parents do as well.",
                    "//",
                    "// Any element that is written without any newlines and fits on a single line",
                    "// is left that way.",
                    "// Not only that, any user-written-line containing multiple JSX siblings",
                    "// should also be kept on one line if possible,",
                    "// so each user-written-line is wrapped in its own group.",
                    "//",
                    "// Elements that contain newlines or don't fit on a single line (recursively)",
                    "// are fully-split, using hardline and shouldBreak: true.",
                    "//",
                    "// To support that case properly, all leading and trailing spaces",
                    "// are stripped from the list of children, and replaced with a single hardline.",
                    "function printJSXElement(path, options, print) {",
                    "  const n = path.getValue();",
                    "",
                    "  // Turn <div></div> into <div />",
                    "  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {",
                    "    n.openingElement.selfClosing = true;",
                    "    return path.call(print, \"openingElement\");",
                    "  }",
                    "",
                    "  const openingLines =",
                    "    n.type === \"JSXElement\"",
                    "      ? path.call(print, \"openingElement\")",
                    "      : path.call(print, \"openingFragment\");",
                    "  const closingLines =",
                    "    n.type === \"JSXElement\"",
                    "      ? path.call(print, \"closingElement\")",
                    "      : path.call(print, \"closingFragment\");",
                    "",
                    "  if (",
                    "    n.children.length === 1 &&",
                    "    n.children[0].type === \"JSXExpressionContainer\" &&",
                    "    (n.children[0].expression.type === \"TemplateLiteral\" ||",
                    "      n.children[0].expression.type === \"TaggedTemplateExpression\")",
                    "  ) {",
                    "    return concat([",
                    "      openingLines,",
                    "      concat(path.map(print, \"children\")),",
                    "      closingLines",
                    "    ]);",
                    "  }",
                    "",
                    "  // Convert `{\" \"}` to text nodes containing a space.",
                    "  // This makes it easy to turn them into `jsxWhitespace` which",
                    "  // can then print as either a space or `{\" \"}` when breaking.",
                    "  n.children = n.children.map(child => {",
                    "    if (isJSXWhitespaceExpression(child)) {",
                    "      return {",
                    "        type: \"JSXText\",",
                    "        value: \" \",",
                    "        raw: \" \"",
                    "      };",
                    "    }",
                    "    return child;",
                    "  });",
                    "",
                    "  const containsTag = n.children.filter(isJSXNode).length > 0;",
                    "  const containsMultipleExpressions =",
                    "    n.children.filter(child => child.type === \"JSXExpressionContainer\").length >",
                    "    1;",
                    "  const containsMultipleAttributes =",
                    "    n.type === \"JSXElement\" && n.openingElement.attributes.length > 1;",
                    "",
                    "  // Record any breaks. Should never go from true to false, only false to true.",
                    "  let forcedBreak =",
                    "    willBreak(openingLines) ||",
                    "    containsTag ||",
                    "    containsMultipleAttributes ||",
                    "    containsMultipleExpressions;",
                    "",
                    "  const rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';",
                    "  const jsxWhitespace = ifBreak(concat([rawJsxWhitespace, softline]), \" \");",
                    "",
                    "  const children = printJSXChildren(path, options, print, jsxWhitespace);",
                    "",
                    "  const containsText =",
                    "    n.children.filter(child => isMeaningfulJSXText(child)).length > 0;",
                    "",
                    "  // We can end up we multiple whitespace elements with empty string",
                    "  // content between them.",
                    "  // We need to remove empty whitespace and softlines before JSX whitespace",
                    "  // to get the correct output.",
                    "  for (let i = children.length - 2; i >= 0; i--) {",
                    "    const isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";",
                    "    const isPairOfHardlines =",
                    "      children[i] === hardline &&",
                    "      children[i + 1] === \"\" &&",
                    "      children[i + 2] === hardline;",
                    "    const isLineFollowedByJSXWhitespace =",
                    "      (children[i] === softline || children[i] === hardline) &&",
                    "      children[i + 1] === \"\" &&",
                    "      children[i + 2] === jsxWhitespace;",
                    "    const isJSXWhitespaceFollowedByLine =",
                    "      children[i] === jsxWhitespace &&",
                    "      children[i + 1] === \"\" &&",
                    "      (children[i + 2] === softline || children[i + 2] === hardline);",
                    "    const isDoubleJSXWhitespace =",
                    "      children[i] === jsxWhitespace &&",
                    "      children[i + 1] === \"\" &&",
                    "      children[i + 2] === jsxWhitespace;",
                    "",
                    "    if (",
                    "      (isPairOfHardlines && containsText) ||",
                    "      isPairOfEmptyStrings ||",
                    "      isLineFollowedByJSXWhitespace ||",
                    "      isDoubleJSXWhitespace",
                    "    ) {",
                    "      children.splice(i, 2);",
                    "    } else if (isJSXWhitespaceFollowedByLine) {",
                    "      children.splice(i + 1, 2);",
                    "    }",
                    "  }",
                    "",
                    "  // Trim trailing lines (or empty strings)",
                    "  while (",
                    "    children.length &&",
                    "    (isLineNext(privateUtil.getLast(children)) ||",
                    "      isEmpty(privateUtil.getLast(children)))",
                    "  ) {",
                    "    children.pop();",
                    "  }",
                    "",
                    "  // Trim leading lines (or empty strings)",
                    "  while (",
                    "    children.length &&",
                    "    (isLineNext(children[0]) || isEmpty(children[0])) &&",
                    "    (isLineNext(children[1]) || isEmpty(children[1]))",
                    "  ) {",
                    "    children.shift();",
                    "    children.shift();",
                    "  }",
                    "",
                    "  // Tweak how we format children if outputting this element over multiple lines.",
                    "  // Also detect whether we will force this element to output over multiple lines.",
                    "  const multilineChildren = [];",
                    "  children.forEach((child, i) => {",
                    "    // There are a number of situations where we need to ensure we display",
                    "    // whitespace as `{\" \"}` when outputting this element over multiple lines.",
                    "    if (child === jsxWhitespace) {",
                    "      if (i === 1 && children[i - 1] === \"\") {",
                    "        if (children.length === 2) {",
                    "          // Solitary whitespace",
                    "          multilineChildren.push(rawJsxWhitespace);",
                    "          return;",
                    "        }",
                    "        // Leading whitespace",
                    "        multilineChildren.push(concat([rawJsxWhitespace, hardline]));",
                    "        return;",
                    "      } else if (i === children.length - 1) {",
                    "        // Trailing whitespace",
                    "        multilineChildren.push(rawJsxWhitespace);",
                    "        return;",
                    "      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {",
                    "        // Whitespace after line break",
                    "        multilineChildren.push(rawJsxWhitespace);",
                    "        return;",
                    "      }",
                    "    }",
                    "",
                    "    multilineChildren.push(child);",
                    "",
                    "    if (willBreak(child)) {",
                    "      forcedBreak = true;",
                    "    }",
                    "  });",
                    "",
                    "  // If there is text we use `fill` to fit as much onto each line as possible.",
                    "  // When there is no text (just tags and expressions) we use `group`",
                    "  // to output each on a separate line.",
                    "  const content = containsText",
                    "    ? fill(multilineChildren)",
                    "    : group(concat(multilineChildren), { shouldBreak: true });",
                    "",
                    "  const multiLineElem = group(",
                    "    concat([",
                    "      openingLines,",
                    "      indent(concat([hardline, content])),",
                    "      hardline,",
                    "      closingLines",
                    "    ])",
                    "  );",
                    "",
                    "  if (forcedBreak) {",
                    "    return multiLineElem;",
                    "  }",
                    "",
                    "  return conditionalGroup([",
                    "    group(concat([openingLines, concat(children), closingLines])),",
                    "    multiLineElem",
                    "  ]);",
                    "}",
                    "",
                    "function maybeWrapJSXElementInParens(path, elem) {",
                    "  const parent = path.getParentNode();",
                    "  if (!parent) {",
                    "    return elem;",
                    "  }",
                    "",
                    "  const NO_WRAP_PARENTS = {",
                    "    ArrayExpression: true,",
                    "    JSXAttribute: true,",
                    "    JSXElement: true,",
                    "    JSXExpressionContainer: true,",
                    "    JSXFragment: true,",
                    "    TSJsxFragment: true,",
                    "    ExpressionStatement: true,",
                    "    CallExpression: true,",
                    "    ConditionalExpression: true",
                    "  };",
                    "  if (NO_WRAP_PARENTS[parent.type]) {",
                    "    return elem;",
                    "  }",
                    "",
                    "  return group(",
                    "    concat([",
                    "      ifBreak(\"(\"),",
                    "      indent(concat([softline, elem])),",
                    "      softline,",
                    "      ifBreak(\")\")",
                    "    ])",
                    "  );",
                    "}",
                    "",
                    "function isBinaryish(node) {",
                    "  return node.type === \"BinaryExpression\" || node.type === \"LogicalExpression\";",
                    "}",
                    "",
                    "function isMemberish(node) {",
                    "  return (",
                    "    node.type === \"MemberExpression\" ||",
                    "    (node.type === \"BindExpression\" && node.object)",
                    "  );",
                    "}",
                    "",
                    "function shouldInlineLogicalExpression(node) {",
                    "  if (node.type !== \"LogicalExpression\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.right.type === \"ObjectExpression\" &&",
                    "    node.right.properties.length !== 0",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    node.right.type === \"ArrayExpression\" &&",
                    "    node.right.elements.length !== 0",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (isJSXNode(node.right)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "// For binary expressions to be consistent, we need to group",
                    "// subsequent operators with the same precedence level under a single",
                    "// group. Otherwise they will be nested such that some of them break",
                    "// onto new lines but not all. Operators with the same precedence",
                    "// level should either all break or not. Because we group them by",
                    "// precedence level and the AST is structured based on precedence",
                    "// level, things are naturally broken up correctly, i.e. `&&` is",
                    "// broken before `+`.",
                    "function printBinaryishExpressions(",
                    "  path,",
                    "  print,",
                    "  options,",
                    "  isNested,",
                    "  isInsideParenthesis",
                    ") {",
                    "  let parts = [];",
                    "  const node = path.getValue();",
                    "",
                    "  // We treat BinaryExpression and LogicalExpression nodes the same.",
                    "  if (isBinaryish(node)) {",
                    "    // Put all operators with the same precedence level in the same",
                    "    // group. The reason we only need to do this with the `left`",
                    "    // expression is because given an expression like `1 + 2 - 3`, it",
                    "    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side",
                    "    // is where the rest of the expression will exist. Binary",
                    "    // expressions on the right side mean they have a difference",
                    "    // precedence level and should be treated as a separate group, so",
                    "    // print them normally. (This doesn't hold for the `**` operator,",
                    "    // which is unique in that it is right-associative.)",
                    "    if (privateUtil.shouldFlatten(node.operator, node.left.operator)) {",
                    "      // Flatten them out by recursively calling this function.",
                    "      parts = parts.concat(",
                    "        path.call(",
                    "          left =>",
                    "            printBinaryishExpressions(",
                    "              left,",
                    "              print,",
                    "              options,",
                    "              /* isNested */ true,",
                    "              isInsideParenthesis",
                    "            ),",
                    "          \"left\"",
                    "        )",
                    "      );",
                    "    } else {",
                    "      parts.push(path.call(print, \"left\"));",
                    "    }",
                    "",
                    "    const shouldInline = shouldInlineLogicalExpression(node);",
                    "    const lineBeforeOperator = node.operator === \"|>\";",
                    "",
                    "    const right = shouldInline",
                    "      ? concat([node.operator, \" \", path.call(print, \"right\")])",
                    "      : concat([",
                    "          lineBeforeOperator ? softline : \"\",",
                    "          node.operator,",
                    "          lineBeforeOperator ? \" \" : line,",
                    "          path.call(print, \"right\")",
                    "        ]);",
                    "",
                    "    // If there's only a single binary expression, we want to create a group",
                    "    // in order to avoid having a small right part like -1 be on its own line.",
                    "    const parent = path.getParentNode();",
                    "    const shouldGroup =",
                    "      !(isInsideParenthesis && node.type === \"LogicalExpression\") &&",
                    "      parent.type !== node.type &&",
                    "      node.left.type !== node.type &&",
                    "      node.right.type !== node.type;",
                    "",
                    "    parts.push(\" \", shouldGroup ? group(right) : right);",
                    "",
                    "    // The root comments are already printed, but we need to manually print",
                    "    // the other ones since we don't call the normal print on BinaryExpression,",
                    "    // only for the left and right parts",
                    "    if (isNested && node.comments) {",
                    "      parts = comments.printComments(path, () => concat(parts), options);",
                    "    }",
                    "  } else {",
                    "    // Our stopping case. Simply print the node normally.",
                    "    parts.push(path.call(print));",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printAssignmentRight(rightNode, printedRight, canBreak, options) {",
                    "  if (hasLeadingOwnLineComment(options.originalText, rightNode, options)) {",
                    "    return indent(concat([hardline, printedRight]));",
                    "  }",
                    "",
                    "  if (canBreak) {",
                    "    return indent(concat([line, printedRight]));",
                    "  }",
                    "",
                    "  return concat([\" \", printedRight]);",
                    "}",
                    "",
                    "function printAssignment(",
                    "  leftNode,",
                    "  printedLeft,",
                    "  operator,",
                    "  rightNode,",
                    "  printedRight,",
                    "  options",
                    ") {",
                    "  if (!rightNode) {",
                    "    return printedLeft;",
                    "  }",
                    "",
                    "  const canBreak =",
                    "    (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) ||",
                    "    (rightNode.type === \"ConditionalExpression\" &&",
                    "      isBinaryish(rightNode.test) &&",
                    "      !shouldInlineLogicalExpression(rightNode.test)) ||",
                    "    ((leftNode.type === \"Identifier\" ||",
                    "      isStringLiteral(leftNode) ||",
                    "      leftNode.type === \"MemberExpression\") &&",
                    "      (isStringLiteral(rightNode) || isMemberExpressionChain(rightNode)));",
                    "",
                    "  const printed = printAssignmentRight(",
                    "    rightNode,",
                    "    printedRight,",
                    "    canBreak,",
                    "    options",
                    "  );",
                    "",
                    "  return group(concat([printedLeft, operator, printed]));",
                    "}",
                    "",
                    "function adjustClause(node, clause, forceSpace) {",
                    "  if (node.type === \"EmptyStatement\") {",
                    "    return \";\";",
                    "  }",
                    "",
                    "  if (node.type === \"BlockStatement\" || forceSpace) {",
                    "    return concat([\" \", clause]);",
                    "  }",
                    "",
                    "  return indent(concat([line, clause]));",
                    "}",
                    "",
                    "function nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {",
                    "  const raw = rawText(node);",
                    "  const isDirectiveLiteral =",
                    "    isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";",
                    "  return privateUtil.printString(raw, options, isDirectiveLiteral);",
                    "}",
                    "",
                    "function printRegex(node) {",
                    "  const flags = node.flags",
                    "    .split(\"\")",
                    "    .sort()",
                    "    .join(\"\");",
                    "  return `/${node.pattern}/${flags}`;",
                    "}",
                    "",
                    "function isLastStatement(path) {",
                    "  const parent = path.getParentNode();",
                    "  if (!parent) {",
                    "    return true;",
                    "  }",
                    "  const node = path.getValue();",
                    "  const body = (parent.body || parent.consequent).filter(",
                    "    stmt => stmt.type !== \"EmptyStatement\"",
                    "  );",
                    "  return body && body[body.length - 1] === node;",
                    "}",
                    "",
                    "function hasLeadingComment(node) {",
                    "  return node.comments && node.comments.some(comment => comment.leading);",
                    "}",
                    "",
                    "function hasTrailingComment(node) {",
                    "  return node.comments && node.comments.some(comment => comment.trailing);",
                    "}",
                    "",
                    "function hasLeadingOwnLineComment(text, node, options) {",
                    "  if (isJSXNode(node)) {",
                    "    return privateUtil.hasNodeIgnoreComment(node);",
                    "  }",
                    "",
                    "  const res =",
                    "    node.comments &&",
                    "    node.comments.some(",
                    "      comment =>",
                    "        comment.leading && privateUtil.hasNewline(text, options.locEnd(comment))",
                    "    );",
                    "  return res;",
                    "}",
                    "",
                    "function hasNakedLeftSide(node) {",
                    "  return (",
                    "    node.type === \"AssignmentExpression\" ||",
                    "    node.type === \"BinaryExpression\" ||",
                    "    node.type === \"LogicalExpression\" ||",
                    "    node.type === \"ConditionalExpression\" ||",
                    "    node.type === \"CallExpression\" ||",
                    "    node.type === \"MemberExpression\" ||",
                    "    node.type === \"SequenceExpression\" ||",
                    "    node.type === \"TaggedTemplateExpression\" ||",
                    "    (node.type === \"BindExpression\" && !node.object) ||",
                    "    (node.type === \"UpdateExpression\" && !node.prefix)",
                    "  );",
                    "}",
                    "",
                    "function isFlowAnnotationComment(text, typeAnnotation, options) {",
                    "  const start = options.locStart(typeAnnotation);",
                    "  const end = privateUtil.skipWhitespace(text, options.locEnd(typeAnnotation));",
                    "  return text.substr(start, 2) === \"/*\" && text.substr(end, 2) === \"*/\";",
                    "}",
                    "",
                    "function getLeftSide(node) {",
                    "  if (node.expressions) {",
                    "    return node.expressions[0];",
                    "  }",
                    "  return (",
                    "    node.left ||",
                    "    node.test ||",
                    "    node.callee ||",
                    "    node.object ||",
                    "    node.tag ||",
                    "    node.argument ||",
                    "    node.expression",
                    "  );",
                    "}",
                    "",
                    "function getLeftSidePathName(path, node) {",
                    "  if (node.expressions) {",
                    "    return [\"expressions\", 0];",
                    "  }",
                    "  if (node.left) {",
                    "    return [\"left\"];",
                    "  }",
                    "  if (node.test) {",
                    "    return [\"test\"];",
                    "  }",
                    "  if (node.callee) {",
                    "    return [\"callee\"];",
                    "  }",
                    "  if (node.object) {",
                    "    return [\"object\"];",
                    "  }",
                    "  if (node.tag) {",
                    "    return [\"tag\"];",
                    "  }",
                    "  if (node.argument) {",
                    "    return [\"argument\"];",
                    "  }",
                    "  if (node.expression) {",
                    "    return [\"expression\"];",
                    "  }",
                    "  throw new Error(\"Unexpected node has no left side\", node);",
                    "}",
                    "",
                    "function exprNeedsASIProtection(path, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  const maybeASIProblem =",
                    "    pathNeedsParens(path, options) ||",
                    "    node.type === \"ParenthesizedExpression\" ||",
                    "    node.type === \"TypeCastExpression\" ||",
                    "    (node.type === \"ArrowFunctionExpression\" &&",
                    "      !shouldPrintParamsWithoutParens(path, options)) ||",
                    "    node.type === \"ArrayExpression\" ||",
                    "    node.type === \"ArrayPattern\" ||",
                    "    (node.type === \"UnaryExpression\" &&",
                    "      node.prefix &&",
                    "      (node.operator === \"+\" || node.operator === \"-\")) ||",
                    "    node.type === \"TemplateLiteral\" ||",
                    "    node.type === \"TemplateElement\" ||",
                    "    isJSXNode(node) ||",
                    "    node.type === \"BindExpression\" ||",
                    "    node.type === \"RegExpLiteral\" ||",
                    "    (node.type === \"Literal\" && node.pattern) ||",
                    "    (node.type === \"Literal\" && node.regex);",
                    "",
                    "  if (maybeASIProblem) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (!hasNakedLeftSide(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call.apply(",
                    "    path,",
                    "    [childPath => exprNeedsASIProtection(childPath, options)].concat(",
                    "      getLeftSidePathName(path, node)",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function stmtNeedsASIProtection(path, options) {",
                    "  const node = path.getNode();",
                    "",
                    "  if (node.type !== \"ExpressionStatement\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call(",
                    "    childPath => exprNeedsASIProtection(childPath, options),",
                    "    \"expression\"",
                    "  );",
                    "}",
                    "",
                    "function classPropMayCauseASIProblems(path) {",
                    "  const node = path.getNode();",
                    "",
                    "  if (node.type !== \"ClassProperty\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  const name = node.key && node.key.name;",
                    "",
                    "  // this isn't actually possible yet with most parsers available today",
                    "  // so isn't properly tested yet.",
                    "  if (",
                    "    (name === \"static\" || name === \"get\" || name === \"set\") &&",
                    "    !node.value &&",
                    "    !node.typeAnnotation",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function classChildNeedsASIProtection(node) {",
                    "  if (!node) {",
                    "    return;",
                    "  }",
                    "",
                    "  if (!node.computed) {",
                    "    const name = node.key && node.key.name;",
                    "    if (name === \"in\" || name === \"instanceof\") {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  switch (node.type) {",
                    "    case \"ClassProperty\":",
                    "    case \"TSAbstractClassProperty\":",
                    "      return node.computed;",
                    "    case \"MethodDefinition\": // Flow",
                    "    case \"TSAbstractMethodDefinition\": // TypeScript",
                    "    case \"ClassMethod\": {",
                    "      // Babylon",
                    "      const isAsync = node.value ? node.value.async : node.async;",
                    "      const isGenerator = node.value ? node.value.generator : node.generator;",
                    "      if (",
                    "        isAsync ||",
                    "        node.static ||",
                    "        node.kind === \"get\" ||",
                    "        node.kind === \"set\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "      if (node.computed || isGenerator) {",
                    "        return true;",
                    "      }",
                    "      return false;",
                    "    }",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "// This recurses the return argument, looking for the first token",
                    "// (the leftmost leaf node) and, if it (or its parents) has any",
                    "// leadingComments, returns true (so it can be wrapped in parens).",
                    "function returnArgumentHasLeadingComment(options, argument) {",
                    "  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (hasNakedLeftSide(argument)) {",
                    "    let leftMost = argument;",
                    "    let newLeftMost;",
                    "    while ((newLeftMost = getLeftSide(leftMost))) {",
                    "      leftMost = newLeftMost;",
                    "",
                    "      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isMemberExpressionChain(node) {",
                    "  if (node.type !== \"MemberExpression\") {",
                    "    return false;",
                    "  }",
                    "  if (node.object.type === \"Identifier\") {",
                    "    return true;",
                    "  }",
                    "  return isMemberExpressionChain(node.object);",
                    "}",
                    "",
                    "// Hack to differentiate between the following two which have the same ast",
                    "// type T = { method: () => void };",
                    "// type T = { method(): void };",
                    "function isObjectTypePropertyAFunction(node, options) {",
                    "  return (",
                    "    node.type === \"ObjectTypeProperty\" &&",
                    "    node.value.type === \"FunctionTypeAnnotation\" &&",
                    "    !node.static &&",
                    "    !isFunctionNotation(node, options)",
                    "  );",
                    "}",
                    "",
                    "// TODO: This is a bad hack and we need a better way to distinguish between",
                    "// arrow functions and otherwise",
                    "function isFunctionNotation(node, options) {",
                    "  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);",
                    "}",
                    "",
                    "function isGetterOrSetter(node) {",
                    "  return node.kind === \"get\" || node.kind === \"set\";",
                    "}",
                    "",
                    "function sameLocStart(nodeA, nodeB, options) {",
                    "  return options.locStart(nodeA) === options.locStart(nodeB);",
                    "}",
                    "",
                    "// Hack to differentiate between the following two which have the same ast",
                    "// declare function f(a): void;",
                    "// var f: (a) => void;",
                    "function isTypeAnnotationAFunction(node, options) {",
                    "  return (",
                    "    (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") &&",
                    "    node.typeAnnotation.type === \"FunctionTypeAnnotation\" &&",
                    "    !node.static &&",
                    "    !sameLocStart(node, node.typeAnnotation, options)",
                    "  );",
                    "}",
                    "",
                    "function isNodeStartingWithDeclare(node, options) {",
                    "  if (!(options.parser === \"flow\" || options.parser === \"typescript\")) {",
                    "    return false;",
                    "  }",
                    "  return (",
                    "    options.originalText",
                    "      .slice(0, options.locStart(node))",
                    "      .match(/declare[ \\t]*$/) ||",
                    "    options.originalText",
                    "      .slice(node.range[0], node.range[1])",
                    "      .startsWith(\"declare \")",
                    "  );",
                    "}",
                    "",
                    "function shouldHugType(node) {",
                    "  if (isObjectType(node)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {",
                    "    const voidCount = node.types.filter(",
                    "      n =>",
                    "        n.type === \"VoidTypeAnnotation\" ||",
                    "        n.type === \"TSVoidKeyword\" ||",
                    "        n.type === \"NullLiteralTypeAnnotation\" ||",
                    "        n.type === \"TSNullKeyword\"",
                    "    ).length;",
                    "",
                    "    const objectCount = node.types.filter(",
                    "      n =>",
                    "        n.type === \"ObjectTypeAnnotation\" ||",
                    "        n.type === \"TSTypeLiteral\" ||",
                    "        // This is a bit aggressive but captures Array<{x}>",
                    "        n.type === \"GenericTypeAnnotation\" ||",
                    "        n.type === \"TSTypeReference\"",
                    "    ).length;",
                    "",
                    "    if (node.types.length - 1 === voidCount && objectCount > 0) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function shouldHugArguments(fun) {",
                    "  return (",
                    "    fun &&",
                    "    fun.params &&",
                    "    fun.params.length === 1 &&",
                    "    !fun.params[0].comments &&",
                    "    (fun.params[0].type === \"ObjectPattern\" ||",
                    "      fun.params[0].type === \"ArrayPattern\" ||",
                    "      (fun.params[0].type === \"Identifier\" &&",
                    "        fun.params[0].typeAnnotation &&",
                    "        (fun.params[0].typeAnnotation.type === \"TypeAnnotation\" ||",
                    "          fun.params[0].typeAnnotation.type === \"TSTypeAnnotation\") &&",
                    "        isObjectType(fun.params[0].typeAnnotation.typeAnnotation)) ||",
                    "      (fun.params[0].type === \"FunctionTypeParam\" &&",
                    "        isObjectType(fun.params[0].typeAnnotation)) ||",
                    "      (fun.params[0].type === \"AssignmentPattern\" &&",
                    "        (fun.params[0].left.type === \"ObjectPattern\" ||",
                    "          fun.params[0].left.type === \"ArrayPattern\") &&",
                    "        (fun.params[0].right.type === \"Identifier\" ||",
                    "          (fun.params[0].right.type === \"ObjectExpression\" &&",
                    "            fun.params[0].right.properties.length === 0) ||",
                    "          (fun.params[0].right.type === \"ArrayExpression\" &&",
                    "            fun.params[0].right.elements.length === 0)))) &&",
                    "    !fun.rest",
                    "  );",
                    "}",
                    "",
                    "function templateLiteralHasNewLines(template) {",
                    "  return template.quasis.some(quasi => quasi.value.raw.includes(\"\\n\"));",
                    "}",
                    "",
                    "function isTemplateOnItsOwnLine(n, text, options) {",
                    "  return (",
                    "    ((n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n)) ||",
                    "      (n.type === \"TaggedTemplateExpression\" &&",
                    "        templateLiteralHasNewLines(n.quasi))) &&",
                    "    !privateUtil.hasNewline(text, options.locStart(n), { backwards: true })",
                    "  );",
                    "}",
                    "",
                    "function printArrayItems(path, options, printPath, print) {",
                    "  const printedElements = [];",
                    "  let separatorParts = [];",
                    "",
                    "  path.each(childPath => {",
                    "    printedElements.push(concat(separatorParts));",
                    "    printedElements.push(group(print(childPath)));",
                    "",
                    "    separatorParts = [\",\", line];",
                    "    if (",
                    "      childPath.getValue() &&",
                    "      sharedUtil.isNextLineEmpty(",
                    "        options.originalText,",
                    "        childPath.getValue(),",
                    "        options",
                    "      )",
                    "    ) {",
                    "      separatorParts.push(softline);",
                    "    }",
                    "  }, printPath);",
                    "",
                    "  return concat(printedElements);",
                    "}",
                    "",
                    "function hasDanglingComments(node) {",
                    "  return (",
                    "    node.comments &&",
                    "    node.comments.some(comment => !comment.leading && !comment.trailing)",
                    "  );",
                    "}",
                    "",
                    "function isLiteral(node) {",
                    "  return (",
                    "    node.type === \"BooleanLiteral\" ||",
                    "    node.type === \"DirectiveLiteral\" ||",
                    "    node.type === \"Literal\" ||",
                    "    node.type === \"NullLiteral\" ||",
                    "    node.type === \"NumericLiteral\" ||",
                    "    node.type === \"RegExpLiteral\" ||",
                    "    node.type === \"StringLiteral\" ||",
                    "    node.type === \"TemplateLiteral\" ||",
                    "    node.type === \"TSTypeLiteral\" ||",
                    "    node.type === \"JSXText\"",
                    "  );",
                    "}",
                    "",
                    "function isNumericLiteral(node) {",
                    "  return (",
                    "    node.type === \"NumericLiteral\" ||",
                    "    (node.type === \"Literal\" && typeof node.value === \"number\")",
                    "  );",
                    "}",
                    "",
                    "function isStringLiteral(node) {",
                    "  return (",
                    "    node.type === \"StringLiteral\" ||",
                    "    (node.type === \"Literal\" && typeof node.value === \"string\")",
                    "  );",
                    "}",
                    "",
                    "function isObjectType(n) {",
                    "  return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";",
                    "}",
                    "",
                    "// eg; `describe(\"some string\", (done) => {})`",
                    "function isTestCall(n) {",
                    "  const unitTestRe = /^(skip|(f|x)?(it|describe|test))$/;",
                    "  return (",
                    "    ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name)) ||",
                    "      (n.callee.type === \"MemberExpression\" &&",
                    "        n.callee.object.type === \"Identifier\" &&",
                    "        n.callee.property.type === \"Identifier\" &&",
                    "        unitTestRe.test(n.callee.object.name) &&",
                    "        (n.callee.property.name === \"only\" ||",
                    "          n.callee.property.name === \"skip\"))) &&",
                    "    n.arguments.length === 2 &&",
                    "    (n.arguments[0].type === \"StringLiteral\" ||",
                    "      n.arguments[0].type === \"TemplateLiteral\" ||",
                    "      (n.arguments[0].type === \"Literal\" &&",
                    "        typeof n.arguments[0].value === \"string\")) &&",
                    "    (n.arguments[1].type === \"FunctionExpression\" ||",
                    "      n.arguments[1].type === \"ArrowFunctionExpression\") &&",
                    "    n.arguments[1].params.length <= 1",
                    "  );",
                    "}",
                    "",
                    "function isTheOnlyJSXElementInMarkdown(options, path) {",
                    "  if (options.parentParser !== \"markdown\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  const node = path.getNode();",
                    "",
                    "  if (!node.expression || !isJSXNode(node.expression)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const parent = path.getParentNode();",
                    "",
                    "  return parent.type === \"Program\" && parent.body.length == 1;",
                    "}",
                    "",
                    "function willPrintOwnComments(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  return (",
                    "    ((node && isJSXNode(node)) ||",
                    "      (parent &&",
                    "        (parent.type === \"JSXSpreadAttribute\" ||",
                    "          parent.type === \"JSXSpreadChild\" ||",
                    "          parent.type === \"UnionTypeAnnotation\" ||",
                    "          parent.type === \"TSUnionType\" ||",
                    "          ((parent.type === \"ClassDeclaration\" ||",
                    "            parent.type === \"ClassExpression\") &&",
                    "            parent.superClass === node)))) &&",
                    "    !privateUtil.hasIgnoreComment(path)",
                    "  );",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type !== \"CommentBlock\" &&",
                    "    node.type !== \"CommentLine\" &&",
                    "    node.type !== \"Line\" &&",
                    "    node.type !== \"Block\" &&",
                    "    node.type !== \"EmptyStatement\" &&",
                    "    node.type !== \"TemplateElement\" &&",
                    "    node.type !== \"Import\" &&",
                    "    !(node.callee && node.callee.type === \"Import\")",
                    "  );",
                    "}",
                    "",
                    "function printComment(commentPath, options) {",
                    "  const comment = commentPath.getValue();",
                    "",
                    "  switch (comment.type) {",
                    "    case \"CommentBlock\":",
                    "    case \"Block\": {",
                    "      if (isJsDocComment(comment)) {",
                    "        return printJsDocComment(comment);",
                    "      }",
                    "",
                    "      const isInsideFlowComment =",
                    "        options.originalText.substr(options.locEnd(comment) - 3, 3) === \"*-/\";",
                    "",
                    "      return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");",
                    "    }",
                    "    case \"CommentLine\":",
                    "    case \"Line\":",
                    "      // Print shebangs with the proper comment characters",
                    "      if (",
                    "        options.originalText.slice(options.locStart(comment)).startsWith(\"#!\")",
                    "      ) {",
                    "        return \"#!\" + comment.value.trimRight();",
                    "      }",
                    "      return \"//\" + comment.value.trimRight();",
                    "    default:",
                    "      throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                    "  }",
                    "}",
                    "",
                    "function isJsDocComment(comment) {",
                    "  const lines = comment.value.split(\"\\n\");",
                    "  return (",
                    "    lines.length > 1 &&",
                    "    lines.slice(0, lines.length - 1).every(line => line.trim()[0] === \"*\")",
                    "  );",
                    "}",
                    "",
                    "function printJsDocComment(comment) {",
                    "  const lines = comment.value.split(\"\\n\");",
                    "",
                    "  return concat([",
                    "    \"/*\",",
                    "    join(",
                    "      hardline,",
                    "      lines.map(",
                    "        (line, index) =>",
                    "          (index > 0 ? \" \" : \"\") +",
                    "          (index < lines.length - 1 ? line.trim() : line.trimLeft())",
                    "      )",
                    "    ),",
                    "    \"*/\"",
                    "  ]);",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  willPrintOwnComments,",
                    "  canAttachComment,",
                    "  printComment,",
                    "  handleComments: {",
                    "    ownLine: handleComments.handleOwnLineComment,",
                    "    endOfLine: handleComments.handleEndOfLineComment,",
                    "    remaining: handleComments.handleRemainingComment",
                    "  }",
                    "};"
                ]
            }
        },
        "language-markdown": {
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const util = require(\"../common/util\");",
                    "const support = require(\"../common/support\");",
                    "const doc = require(\"../doc\");",
                    "const docBuilders = doc.builders;",
                    "const hardline = docBuilders.hardline;",
                    "const literalline = docBuilders.literalline;",
                    "const concat = docBuilders.concat;",
                    "const markAsRoot = docBuilders.markAsRoot;",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"code\") {",
                    "    // only look for the first string so as to support [markdown-preview-enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/code-chunk)",
                    "    const lang = node.lang.split(/\\s/, 1)[0];",
                    "    const parser = getParserName(lang);",
                    "    if (parser) {",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "      );",
                    "      const doc = textToDoc(node.value, { parser });",
                    "      return markAsRoot(",
                    "        concat([",
                    "          style,",
                    "          node.lang,",
                    "          hardline,",
                    "          replaceNewlinesWithLiterallines(doc),",
                    "          style",
                    "        ])",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return null;",
                    "",
                    "  function getParserName(lang) {",
                    "    const supportInfo = support.getSupportInfo(null, {",
                    "      plugins: options.plugins,",
                    "      pluginsLoaded: true",
                    "    });",
                    "    const language = supportInfo.languages.find(",
                    "      language =>",
                    "        language.name.toLowerCase() === lang ||",
                    "        (language.extensions &&",
                    "          language.extensions.find(ext => ext.substring(1) === lang))",
                    "    );",
                    "    if (language) {",
                    "      return language.parsers[0];",
                    "    }",
                    "",
                    "    return null;",
                    "  }",
                    "",
                    "  function replaceNewlinesWithLiterallines(doc) {",
                    "    return util.mapDoc(",
                    "      doc,",
                    "      currentDoc =>",
                    "        typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\")",
                    "          ? concat(",
                    "              currentDoc",
                    "                .split(/(\\n)/g)",
                    "                .map((v, i) => (i % 2 === 0 ? v : literalline))",
                    "            )",
                    "          : currentDoc",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-markdown\");",
                    "const options = require(\"./options\");",
                    "",
                    "// Based on:",
                    "// https://github.com/github/linguist/blob/master/lib/linguist/languages.yml",
                    "",
                    "const languages = [",
                    "  {",
                    "    name: \"Markdown\",",
                    "    since: \"1.8.0\",",
                    "    parsers: [\"remark\"],",
                    "    aliases: [\"pandoc\"],",
                    "    aceMode: \"markdown\",",
                    "    codemirrorMode: \"gfm\",",
                    "    codemirrorMimeType: \"text/x-gfm\",",
                    "    wrap: true,",
                    "    extensions: [",
                    "      \".md\",",
                    "      \".markdown\",",
                    "      \".mdown\",",
                    "      \".mdwn\",",
                    "      \".mkd\",",
                    "      \".mkdn\",",
                    "      \".mkdown\",",
                    "      \".ron\",",
                    "      \".workbook\"",
                    "    ],",
                    "    filenames: [\"README\"],",
                    "    tmScope: \"source.gfm\",",
                    "    linguistLanguageId: 222,",
                    "    vscodeLanguageIds: [\"markdown\"]",
                    "  }",
                    "];",
                    "",
                    "const remark = {",
                    "  get parse() {",
                    "    return eval(\"require\")(\"./parser-markdown\");",
                    "  },",
                    "  astFormat: \"mdast\"",
                    "};",
                    "",
                    "const parsers = {",
                    "  remark,",
                    "  // TODO: Delete this in 2.0",
                    "  markdown: remark",
                    "};",
                    "",
                    "const printers = {",
                    "  mdast: printer",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  parsers,",
                    "  printers",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const jsOptions = require(\"../language-js/options\");",
                    "",
                    "const CATEGORY_MARKDOWN = \"Markdown\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/common/support.js",
                    "module.exports = {",
                    "  proseWrap: {",
                    "    since: \"1.8.2\",",
                    "    category: CATEGORY_MARKDOWN,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.8.2\", value: true },",
                    "      { since: \"1.9.0\", value: \"preserve\" }",
                    "    ],",
                    "    description: \"How to wrap prose. (markdown)\",",
                    "    choices: [",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"always\",",
                    "        description: \"Wrap prose if it exceeds the print width.\"",
                    "      },",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"never\",",
                    "        description: \"Do not wrap prose.\"",
                    "      },",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"preserve\",",
                    "        description: \"Wrap prose as-is.\"",
                    "      },",
                    "      { value: false, deprecated: \"1.9.0\", redirect: \"never\" },",
                    "      { value: true, deprecated: \"1.9.0\", redirect: \"always\" }",
                    "    ]",
                    "  },",
                    "  singleQuote: jsOptions.singleQuote",
                    "};"
                ]
            },
            "parser-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const remarkFrontmatter = require(\"remark-frontmatter\");",
                    "const remarkParse = require(\"remark-parse\");",
                    "const unified = require(\"unified\");",
                    "const util = require(\"../common/util\");",
                    "",
                    "/**",
                    " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                    " *",
                    " * 1. restore unescaped character (Text)",
                    " * 2. merge continuous Texts",
                    " * 3. replace whitespaces in InlineCode#value with one whitespace",
                    " *    reference: http://spec.commonmark.org/0.25/#example-605",
                    " * 4. split Text into Sentence",
                    " *",
                    " * interface Word { value: string }",
                    " * interface Whitespace { value: string }",
                    " * interface Sentence { children: Array<Word | Whitespace> }",
                    " * interface InlineCode { children: Array<Sentence> }",
                    " */",
                    "function parse(text /*, parsers, opts*/) {",
                    "  const processor = unified()",
                    "    .use(remarkParse, { footnotes: true, commonmark: true })",
                    "    .use(remarkFrontmatter, [\"yaml\", \"toml\"])",
                    "    .use(restoreUnescapedCharacter(text))",
                    "    .use(mergeContinuousTexts)",
                    "    .use(transformInlineCode)",
                    "    .use(splitText);",
                    "  return processor.runSync(processor.parse(text));",
                    "}",
                    "",
                    "function map(ast, handler) {",
                    "  return (function preorder(node, index, parentNode) {",
                    "    const newNode = Object.assign({}, handler(node, index, parentNode));",
                    "    if (newNode.children) {",
                    "      newNode.children = newNode.children.map((child, index) => {",
                    "        return preorder(child, index, newNode);",
                    "      });",
                    "    }",
                    "    return newNode;",
                    "  })(ast, null, null);",
                    "}",
                    "",
                    "function transformInlineCode() {",
                    "  return ast =>",
                    "    map(ast, node => {",
                    "      if (node.type !== \"inlineCode\") {",
                    "        return node;",
                    "      }",
                    "",
                    "      return Object.assign({}, node, {",
                    "        value: node.value.replace(/\\s+/g, \" \")",
                    "      });",
                    "    });",
                    "}",
                    "",
                    "function restoreUnescapedCharacter(originalText) {",
                    "  return () => ast =>",
                    "    map(ast, node => {",
                    "      return node.type !== \"text\"",
                    "        ? node",
                    "        : Object.assign({}, node, {",
                    "            value:",
                    "              node.value !== \"*\" &&",
                    "              node.value !== \"_\" && // handle these two cases in printer",
                    "              node.value.length === 1 &&",
                    "              node.position.end.offset - node.position.start.offset > 1",
                    "                ? originalText.slice(",
                    "                    node.position.start.offset,",
                    "                    node.position.end.offset",
                    "                  )",
                    "                : node.value",
                    "          });",
                    "    });",
                    "}",
                    "",
                    "function mergeContinuousTexts() {",
                    "  return ast =>",
                    "    map(ast, node => {",
                    "      if (!node.children) {",
                    "        return node;",
                    "      }",
                    "      const children = node.children.reduce((current, child) => {",
                    "        const lastChild = current[current.length - 1];",
                    "        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {",
                    "          current.splice(-1, 1, {",
                    "            type: \"text\",",
                    "            value: lastChild.value + child.value,",
                    "            position: {",
                    "              start: lastChild.position.start,",
                    "              end: child.position.end",
                    "            }",
                    "          });",
                    "        } else {",
                    "          current.push(child);",
                    "        }",
                    "        return current;",
                    "      }, []);",
                    "      return Object.assign({}, node, { children });",
                    "    });",
                    "}",
                    "",
                    "function splitText() {",
                    "  return ast =>",
                    "    map(ast, (node, index, parentNode) => {",
                    "      if (node.type !== \"text\") {",
                    "        return node;",
                    "      }",
                    "",
                    "      let value = node.value;",
                    "",
                    "      if (parentNode.type === \"paragraph\") {",
                    "        if (index === 0) {",
                    "          value = value.trimLeft();",
                    "        }",
                    "        if (index === parentNode.children.length - 1) {",
                    "          value = value.trimRight();",
                    "        }",
                    "      }",
                    "",
                    "      return {",
                    "        type: \"sentence\",",
                    "        position: node.position,",
                    "        children: util.splitText(value)",
                    "      };",
                    "    });",
                    "}",
                    "",
                    "module.exports = parse;"
                ]
            },
            "printer-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const privateUtil = require(\"../common/util\");",
                    "const embed = require(\"./embed\");",
                    "const doc = require(\"../doc\");",
                    "const docBuilders = doc.builders;",
                    "const concat = docBuilders.concat;",
                    "const join = docBuilders.join;",
                    "const line = docBuilders.line;",
                    "const hardline = docBuilders.hardline;",
                    "const softline = docBuilders.softline;",
                    "const fill = docBuilders.fill;",
                    "const align = docBuilders.align;",
                    "const group = docBuilders.group;",
                    "const printDocToString = doc.printer.printDocToString;",
                    "",
                    "const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\"];",
                    "",
                    "const SIBLING_NODE_TYPES = [\"listItem\", \"definition\", \"footnoteDefinition\"];",
                    "",
                    "const INLINE_NODE_TYPES = [",
                    "  \"inlineCode\",",
                    "  \"emphasis\",",
                    "  \"strong\",",
                    "  \"delete\",",
                    "  \"link\",",
                    "  \"linkReference\",",
                    "  \"image\",",
                    "  \"imageReference\",",
                    "  \"footnote\",",
                    "  \"footnoteReference\",",
                    "  \"sentence\",",
                    "  \"whitespace\",",
                    "  \"word\",",
                    "  \"break\"",
                    "];",
                    "",
                    "const INLINE_NODE_WRAPPER_TYPES = INLINE_NODE_TYPES.concat([",
                    "  \"tableCell\",",
                    "  \"paragraph\",",
                    "  \"heading\"",
                    "]);",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (shouldRemainTheSameContent(path)) {",
                    "    return concat(",
                    "      privateUtil",
                    "        .splitText(",
                    "          options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          )",
                    "        )",
                    "        .map(",
                    "          node =>",
                    "            node.type === \"word\"",
                    "              ? node.value",
                    "              : node.value === \"\" ? \"\" : printLine(path, node.value, options)",
                    "        )",
                    "    );",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"root\":",
                    "      return concat([",
                    "        normalizeDoc(printChildren(path, options, print)),",
                    "        hardline",
                    "      ]);",
                    "    case \"paragraph\":",
                    "      return printChildren(path, options, print, {",
                    "        postprocessor: fill",
                    "      });",
                    "    case \"sentence\":",
                    "      return printChildren(path, options, print);",
                    "    case \"word\":",
                    "      return node.value",
                    "        .replace(/[*]/g, \"\\\\*\") // escape all `*`",
                    "        .replace(",
                    "          new RegExp(",
                    "            [",
                    "              `(^|[${privateUtil.punctuationCharRange}])(_+)`,",
                    "              `(_+)([${privateUtil.punctuationCharRange}]|$)`",
                    "            ].join(\"|\"),",
                    "            \"g\"",
                    "          ),",
                    "          (_, text1, underscore1, underscore2, text2) =>",
                    "            (underscore1",
                    "              ? `${text1}${underscore1}`",
                    "              : `${underscore2}${text2}`",
                    "            ).replace(/_/g, \"\\\\_\")",
                    "        ); // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis",
                    "    case \"whitespace\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode.children.indexOf(node);",
                    "      const nextNode = parentNode.children[index + 1];",
                    "",
                    "      const proseWrap =",
                    "        // leading char that may cause different syntax",
                    "        nextNode && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(nextNode.value)",
                    "          ? \"never\"",
                    "          : options.proseWrap;",
                    "",
                    "      return printLine(path, node.value, { proseWrap });",
                    "    }",
                    "    case \"emphasis\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode.children.indexOf(node);",
                    "      const prevNode = parentNode.children[index - 1];",
                    "      const nextNode = parentNode.children[index + 1];",
                    "      const hasPrevOrNextWord = // `1*2*3` is considered emphais but `1_2_3` is not",
                    "        (prevNode &&",
                    "          prevNode.type === \"sentence\" &&",
                    "          prevNode.children.length > 0 &&",
                    "          privateUtil.getLast(prevNode.children).type === \"word\" &&",
                    "          !privateUtil.getLast(prevNode.children).hasTrailingPunctuation) ||",
                    "        (nextNode &&",
                    "          nextNode.type === \"sentence\" &&",
                    "          nextNode.children.length > 0 &&",
                    "          nextNode.children[0].type === \"word\" &&",
                    "          !nextNode.children[0].hasLeadingPunctuation);",
                    "      const style =",
                    "        hasPrevOrNextWord || getAncestorNode(path, \"emphasis\") ? \"*\" : \"_\";",
                    "      return concat([style, printChildren(path, options, print), style]);",
                    "    }",
                    "    case \"strong\":",
                    "      return concat([\"**\", printChildren(path, options, print), \"**\"]);",
                    "    case \"delete\":",
                    "      return concat([\"~~\", printChildren(path, options, print), \"~~\"]);",
                    "    case \"inlineCode\": {",
                    "      const backtickCount = privateUtil.getMaxContinuousCount(node.value, \"`\");",
                    "      const style = backtickCount === 1 ? \"``\" : \"`\";",
                    "      const gap = backtickCount ? \" \" : \"\";",
                    "      return concat([style, gap, node.value, gap, style]);",
                    "    }",
                    "    case \"link\":",
                    "      switch (options.originalText[node.position.start.offset]) {",
                    "        case \"<\":",
                    "          return concat([\"<\", node.url, \">\"]);",
                    "        case \"[\":",
                    "          return concat([",
                    "            \"[\",",
                    "            printChildren(path, options, print),",
                    "            \"](\",",
                    "            printUrl(node.url, \")\"),",
                    "            printTitle(node.title, options),",
                    "            \")\"",
                    "          ]);",
                    "        default:",
                    "          return options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          );",
                    "      }",
                    "    case \"image\":",
                    "      return concat([",
                    "        \"![\",",
                    "        node.alt || \"\",",
                    "        \"](\",",
                    "        printUrl(node.url, \")\"),",
                    "        printTitle(node.title, options),",
                    "        \")\"",
                    "      ]);",
                    "    case \"blockquote\":",
                    "      return concat([\"> \", align(\"> \", printChildren(path, options, print))]);",
                    "    case \"heading\":",
                    "      return concat([",
                    "        \"#\".repeat(node.depth) + \" \",",
                    "        printChildren(path, options, print)",
                    "      ]);",
                    "    case \"code\": {",
                    "      if (",
                    "        // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it",
                    "        /^\\n?( {4,}|\\t)/.test(",
                    "          options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          )",
                    "        )",
                    "      ) {",
                    "        // indented code block",
                    "        const alignment = \" \".repeat(4);",
                    "        return align(",
                    "          alignment,",
                    "          concat([alignment, join(hardline, node.value.split(\"\\n\"))])",
                    "        );",
                    "      }",
                    "",
                    "      // fenced code block",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(",
                    "          3,",
                    "          privateUtil.getMaxContinuousCount(node.value, styleUnit) + 1",
                    "        )",
                    "      );",
                    "      return concat([",
                    "        style,",
                    "        node.lang || \"\",",
                    "        hardline,",
                    "        join(hardline, node.value.split(\"\\n\")),",
                    "        hardline,",
                    "        style",
                    "      ]);",
                    "    }",
                    "    case \"yaml\":",
                    "      return concat([\"---\", hardline, node.value, hardline, \"---\"]);",
                    "    case \"toml\":",
                    "      return concat([\"+++\", hardline, node.value, hardline, \"+++\"]);",
                    "    case \"html\": {",
                    "      const parentNode = path.getParentNode();",
                    "      return replaceNewlinesWithHardlines(",
                    "        parentNode.type === \"root\" &&",
                    "        privateUtil.getLast(parentNode.children) === node",
                    "          ? node.value.trimRight()",
                    "          : node.value",
                    "      );",
                    "    }",
                    "    case \"list\": {",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        node,",
                    "        path.getParentNode()",
                    "      );",
                    "",
                    "      const isGitDiffFriendlyOrderedList =",
                    "        node.ordered &&",
                    "        node.children.length > 1 &&",
                    "        /^\\s*1(\\.|\\))/.test(",
                    "          options.originalText.slice(",
                    "            node.children[1].position.start.offset,",
                    "            node.children[1].position.end.offset",
                    "          )",
                    "        );",
                    "",
                    "      return printChildren(path, options, print, {",
                    "        processor: (childPath, index) => {",
                    "          const prefix = getPrefix();",
                    "          return concat([",
                    "            prefix,",
                    "            align(",
                    "              \" \".repeat(prefix.length),",
                    "              printListItem(childPath, options, print, prefix)",
                    "            )",
                    "          ]);",
                    "",
                    "          function getPrefix() {",
                    "            const rawPrefix = node.ordered",
                    "              ? (index === 0",
                    "                  ? node.start",
                    "                  : isGitDiffFriendlyOrderedList ? 1 : node.start + index) +",
                    "                (nthSiblingIndex % 2 === 0 ? \". \" : \") \")",
                    "              : nthSiblingIndex % 2 === 0 ? \"* \" : \"- \";",
                    "",
                    "            // do not print trailing spaces for empty list item since it might be treated as `break` node",
                    "            // by [doc-printer](https://github.com/prettier/prettier/blob/1.10.2/src/doc/doc-printer.js#L395-L405),",
                    "            // we don't want to preserve unnecessary trailing spaces.",
                    "            const listItem = childPath.getValue();",
                    "            return listItem.children.length",
                    "              ? alignListPrefix(rawPrefix, options)",
                    "              : rawPrefix;",
                    "          }",
                    "        }",
                    "      });",
                    "    }",
                    "    case \"thematicBreak\": {",
                    "      const counter = getAncestorCounter(path, \"list\");",
                    "      if (counter === -1) {",
                    "        return \"---\";",
                    "      }",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        path.getParentNode(counter),",
                    "        path.getParentNode(counter + 1)",
                    "      );",
                    "      return nthSiblingIndex % 2 === 0 ? \"---\" : \"***\";",
                    "    }",
                    "    case \"linkReference\":",
                    "      return concat([",
                    "        \"[\",",
                    "        printChildren(path, options, print),",
                    "        \"]\",",
                    "        node.referenceType === \"full\"",
                    "          ? concat([\"[\", node.identifier, \"]\"])",
                    "          : node.referenceType === \"collapsed\" ? \"[]\" : \"\"",
                    "      ]);",
                    "    case \"imageReference\":",
                    "      switch (node.referenceType) {",
                    "        case \"full\":",
                    "          return concat([\"![\", node.alt || \"\", \"][\", node.identifier, \"]\"]);",
                    "        default:",
                    "          return concat([",
                    "            \"![\",",
                    "            node.alt,",
                    "            \"]\",",
                    "            node.referenceType === \"collapsed\" ? \"[]\" : \"\"",
                    "          ]);",
                    "      }",
                    "    case \"definition\":",
                    "      return concat([",
                    "        \"[\",",
                    "        node.identifier,",
                    "        \"]: \",",
                    "        printUrl(node.url),",
                    "        printTitle(node.title, options)",
                    "      ]);",
                    "    case \"footnote\":",
                    "      return concat([\"[^\", printChildren(path, options, print), \"]\"]);",
                    "    case \"footnoteReference\":",
                    "      return concat([\"[^\", node.identifier, \"]\"]);",
                    "    case \"footnoteDefinition\": {",
                    "      const nextNode = path.getParentNode().children[path.getName() + 1];",
                    "      return concat([",
                    "        \"[^\",",
                    "        node.identifier,",
                    "        \"]: \",",
                    "        group(",
                    "          concat([",
                    "            align(",
                    "              \" \".repeat(options.tabWidth),",
                    "              printChildren(path, options, print, {",
                    "                processor: (childPath, index) =>",
                    "                  index === 0",
                    "                    ? group(concat([softline, softline, childPath.call(print)]))",
                    "                    : childPath.call(print)",
                    "              })",
                    "            ),",
                    "            nextNode && nextNode.type === \"footnoteDefinition\" ? softline : \"\"",
                    "          ])",
                    "        )",
                    "      ]);",
                    "    }",
                    "    case \"table\":",
                    "      return printTable(path, options, print);",
                    "    case \"tableCell\":",
                    "      return printChildren(path, options, print);",
                    "    case \"break\":",
                    "      return concat([",
                    "        /\\s/.test(options.originalText[node.position.start.offset])",
                    "          ? \"  \"",
                    "          : \"\\\\\",",
                    "        hardline",
                    "      ]);",
                    "    case \"tableRow\": // handled in \"table\"",
                    "    case \"listItem\": // handled in \"list\"",
                    "    default:",
                    "      throw new Error(`Unknown markdown type ${JSON.stringify(node.type)}`);",
                    "  }",
                    "}",
                    "",
                    "function printListItem(path, options, print, listPrefix) {",
                    "  const node = path.getValue();",
                    "  const prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";",
                    "  return concat([",
                    "    prefix,",
                    "    printChildren(path, options, print, {",
                    "      processor: (childPath, index) => {",
                    "        if (index === 0 && childPath.getValue().type !== \"list\") {",
                    "          return align(\" \".repeat(prefix.length), childPath.call(print));",
                    "        }",
                    "",
                    "        const alignment = \" \".repeat(",
                    "          clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block",
                    "        );",
                    "        return concat([alignment, align(alignment, childPath.call(print))]);",
                    "      }",
                    "    })",
                    "  ]);",
                    "}",
                    "",
                    "function alignListPrefix(prefix, options) {",
                    "  const additionalSpaces = getAdditionalSpaces();",
                    "  return (",
                    "    prefix +",
                    "    \" \".repeat(",
                    "      additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block",
                    "    )",
                    "  );",
                    "",
                    "  function getAdditionalSpaces() {",
                    "    const restSpaces = prefix.length % options.tabWidth;",
                    "    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;",
                    "  }",
                    "}",
                    "",
                    "function getNthListSiblingIndex(node, parentNode) {",
                    "  return getNthSiblingIndex(",
                    "    node,",
                    "    parentNode,",
                    "    siblingNode => siblingNode.ordered === node.ordered",
                    "  );",
                    "}",
                    "",
                    "function replaceNewlinesWithHardlines(str) {",
                    "  return join(hardline, str.split(\"\\n\"));",
                    "}",
                    "",
                    "function getNthSiblingIndex(node, parentNode, condition) {",
                    "  condition = condition || (() => true);",
                    "",
                    "  let index = -1;",
                    "",
                    "  for (const childNode of parentNode.children) {",
                    "    if (childNode.type === node.type && condition(childNode)) {",
                    "      index++;",
                    "    } else {",
                    "      index = -1;",
                    "    }",
                    "",
                    "    if (childNode === node) {",
                    "      return index;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getAncestorCounter(path, typeOrTypes) {",
                    "  const types = [].concat(typeOrTypes);",
                    "",
                    "  let counter = -1;",
                    "  let ancestorNode;",
                    "",
                    "  while ((ancestorNode = path.getParentNode(++counter))) {",
                    "    if (types.indexOf(ancestorNode.type) !== -1) {",
                    "      return counter;",
                    "    }",
                    "  }",
                    "",
                    "  return -1;",
                    "}",
                    "",
                    "function getAncestorNode(path, typeOrTypes) {",
                    "  const counter = getAncestorCounter(path, typeOrTypes);",
                    "  return counter === -1 ? null : path.getParentNode(counter);",
                    "}",
                    "",
                    "function printLine(path, value, options) {",
                    "  if (options.proseWrap === \"preserve\" && value === \"\\n\") {",
                    "    return hardline;",
                    "  }",
                    "",
                    "  const isBreakable =",
                    "    options.proseWrap === \"always\" &&",
                    "    !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);",
                    "  return value !== \"\"",
                    "    ? isBreakable ? line : \" \"",
                    "    : isBreakable ? softline : \"\";",
                    "}",
                    "",
                    "function printTable(path, options, print) {",
                    "  const node = path.getValue();",
                    "  const contents = []; // { [rowIndex: number]: { [columnIndex: number]: string } }",
                    "",
                    "  path.map(rowPath => {",
                    "    const rowContents = [];",
                    "",
                    "    rowPath.map(cellPath => {",
                    "      rowContents.push(",
                    "        printDocToString(cellPath.call(print), options).formatted",
                    "      );",
                    "    }, \"children\");",
                    "",
                    "    contents.push(rowContents);",
                    "  }, \"children\");",
                    "",
                    "  const columnMaxWidths = contents.reduce(",
                    "    (currentWidths, rowContents) =>",
                    "      currentWidths.map((width, columnIndex) =>",
                    "        Math.max(width, privateUtil.getStringWidth(rowContents[columnIndex]))",
                    "      ),",
                    "    contents[0].map(() => 3) // minimum width = 3 (---, :--, :-:, --:)",
                    "  );",
                    "",
                    "  return join(hardline, [",
                    "    printRow(contents[0]),",
                    "    printSeparator(),",
                    "    join(hardline, contents.slice(1).map(printRow))",
                    "  ]);",
                    "",
                    "  function printSeparator() {",
                    "    return concat([",
                    "      \"| \",",
                    "      join(",
                    "        \" | \",",
                    "        columnMaxWidths.map((width, index) => {",
                    "          switch (node.align[index]) {",
                    "            case \"left\":",
                    "              return \":\" + \"-\".repeat(width - 1);",
                    "            case \"right\":",
                    "              return \"-\".repeat(width - 1) + \":\";",
                    "            case \"center\":",
                    "              return \":\" + \"-\".repeat(width - 2) + \":\";",
                    "            default:",
                    "              return \"-\".repeat(width);",
                    "          }",
                    "        })",
                    "      ),",
                    "      \" |\"",
                    "    ]);",
                    "  }",
                    "",
                    "  function printRow(rowContents) {",
                    "    return concat([",
                    "      \"| \",",
                    "      join(",
                    "        \" | \",",
                    "        rowContents.map((rowContent, columnIndex) => {",
                    "          switch (node.align[columnIndex]) {",
                    "            case \"right\":",
                    "              return alignRight(rowContent, columnMaxWidths[columnIndex]);",
                    "            case \"center\":",
                    "              return alignCenter(rowContent, columnMaxWidths[columnIndex]);",
                    "            default:",
                    "              return alignLeft(rowContent, columnMaxWidths[columnIndex]);",
                    "          }",
                    "        })",
                    "      ),",
                    "      \" |\"",
                    "    ]);",
                    "  }",
                    "",
                    "  function alignLeft(text, width) {",
                    "    return concat([text, \" \".repeat(width - privateUtil.getStringWidth(text))]);",
                    "  }",
                    "",
                    "  function alignRight(text, width) {",
                    "    return concat([\" \".repeat(width - privateUtil.getStringWidth(text)), text]);",
                    "  }",
                    "",
                    "  function alignCenter(text, width) {",
                    "    const spaces = width - privateUtil.getStringWidth(text);",
                    "    const left = Math.floor(spaces / 2);",
                    "    const right = spaces - left;",
                    "    return concat([\" \".repeat(left), text, \" \".repeat(right)]);",
                    "  }",
                    "}",
                    "",
                    "function printChildren(path, options, print, events) {",
                    "  events = events || {};",
                    "",
                    "  const postprocessor = events.postprocessor || concat;",
                    "  const processor = events.processor || (childPath => childPath.call(print));",
                    "",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  let counter = 0;",
                    "  let lastChildNode;",
                    "  let prettierIgnore = false;",
                    "",
                    "  path.map((childPath, index) => {",
                    "    const childNode = childPath.getValue();",
                    "",
                    "    const result = prettierIgnore",
                    "      ? options.originalText.slice(",
                    "          childNode.position.start.offset,",
                    "          childNode.position.end.offset",
                    "        )",
                    "      : processor(childPath, index);",
                    "",
                    "    prettierIgnore = false;",
                    "",
                    "    if (result !== false) {",
                    "      prettierIgnore = isPrettierIgnore(childNode);",
                    "",
                    "      const data = {",
                    "        parts,",
                    "        index: counter++,",
                    "        prevNode: lastChildNode,",
                    "        parentNode: node,",
                    "        options",
                    "      };",
                    "",
                    "      if (!shouldNotPrePrintHardline(childNode, data)) {",
                    "        parts.push(hardline);",
                    "",
                    "        if (",
                    "          shouldPrePrintDoubleHardline(childNode, data) ||",
                    "          shouldPrePrintTripleHardline(childNode, data)",
                    "        ) {",
                    "          parts.push(hardline);",
                    "        }",
                    "",
                    "        if (shouldPrePrintTripleHardline(childNode, data)) {",
                    "          parts.push(hardline);",
                    "        }",
                    "      }",
                    "",
                    "      parts.push(result);",
                    "",
                    "      lastChildNode = childNode;",
                    "    }",
                    "  }, \"children\");",
                    "",
                    "  return postprocessor(parts);",
                    "}",
                    "",
                    "function isPrettierIgnore(node) {",
                    "  return (",
                    "    node.type === \"html\" && /^<!--\\s*prettier-ignore\\s*-->$/.test(node.value)",
                    "  );",
                    "}",
                    "",
                    "function shouldNotPrePrintHardline(node, data) {",
                    "  const isFirstNode = data.parts.length === 0;",
                    "  const isInlineNode = INLINE_NODE_TYPES.indexOf(node.type) !== -1;",
                    "",
                    "  const isInlineHTML =",
                    "    node.type === \"html\" &&",
                    "    INLINE_NODE_WRAPPER_TYPES.indexOf(data.parentNode.type) !== -1;",
                    "",
                    "  return isFirstNode || isInlineNode || isInlineHTML;",
                    "}",
                    "",
                    "function shouldPrePrintDoubleHardline(node, data) {",
                    "  const isSequence = (data.prevNode && data.prevNode.type) === node.type;",
                    "  const isSiblingNode =",
                    "    isSequence && SIBLING_NODE_TYPES.indexOf(node.type) !== -1;",
                    "",
                    "  const isInTightListItem =",
                    "    data.parentNode.type === \"listItem\" && !data.parentNode.loose;",
                    "",
                    "  const isPrevNodeLooseListItem =",
                    "    data.prevNode && data.prevNode.type === \"listItem\" && data.prevNode.loose;",
                    "",
                    "  const isPrevNodePrettierIgnore = isPrettierIgnore(data.prevNode);",
                    "",
                    "  return (",
                    "    isPrevNodeLooseListItem ||",
                    "    !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore)",
                    "  );",
                    "}",
                    "",
                    "function shouldPrePrintTripleHardline(node, data) {",
                    "  const isPrevNodeList = data.prevNode && data.prevNode.type === \"list\";",
                    "  const isIndentedCode =",
                    "    node.type === \"code\" &&",
                    "    /\\s/.test(data.options.originalText[node.position.start.offset]);",
                    "",
                    "  return isPrevNodeList && isIndentedCode;",
                    "}",
                    "",
                    "function shouldRemainTheSameContent(path) {",
                    "  const ancestorNode = getAncestorNode(path, [",
                    "    \"linkReference\",",
                    "    \"imageReference\"",
                    "  ]);",
                    "",
                    "  return (",
                    "    ancestorNode &&",
                    "    (ancestorNode.type !== \"linkReference\" ||",
                    "      ancestorNode.referenceType !== \"full\")",
                    "  );",
                    "}",
                    "",
                    "function normalizeDoc(doc) {",
                    "  return privateUtil.mapDoc(doc, currentDoc => {",
                    "    if (!currentDoc.parts) {",
                    "      return currentDoc;",
                    "    }",
                    "",
                    "    if (currentDoc.type === \"concat\" && currentDoc.parts.length === 1) {",
                    "      return currentDoc.parts[0];",
                    "    }",
                    "",
                    "    const parts = [];",
                    "",
                    "    currentDoc.parts.forEach(part => {",
                    "      if (part.type === \"concat\") {",
                    "        parts.push.apply(parts, part.parts);",
                    "      } else if (part !== \"\") {",
                    "        parts.push(part);",
                    "      }",
                    "    });",
                    "",
                    "    return Object.assign({}, currentDoc, {",
                    "      parts: normalizeParts(parts)",
                    "    });",
                    "  });",
                    "}",
                    "",
                    "function printUrl(url, dangerousCharOrChars) {",
                    "  const dangerousChars = [\" \"].concat(dangerousCharOrChars || []);",
                    "  return new RegExp(dangerousChars.map(x => `\\\\${x}`).join(\"|\")).test(url)",
                    "    ? `<${url}>`",
                    "    : url;",
                    "}",
                    "",
                    "function printTitle(title, options) {",
                    "  if (!title) {",
                    "    return \"\";",
                    "  }",
                    "  if (title.includes('\"') && title.includes(\"'\") && !title.includes(\")\")) {",
                    "    return ` (${title})`; // avoid escaped quotes",
                    "  }",
                    "  // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split",
                    "  const singleCount = title.split(\"'\").length - 1;",
                    "  const doubleCount = title.split('\"').length - 1;",
                    "  const quote =",
                    "    singleCount > doubleCount",
                    "      ? '\"'",
                    "      : doubleCount > singleCount ? \"'\" : options.singleQuote ? \"'\" : '\"';",
                    "  title = title.replace(new RegExp(`(${quote})`, \"g\"), \"\\\\$1\");",
                    "  return ` ${quote}${title}${quote}`;",
                    "}",
                    "",
                    "function normalizeParts(parts) {",
                    "  return parts.reduce((current, part) => {",
                    "    const lastPart = privateUtil.getLast(current);",
                    "",
                    "    if (typeof lastPart === \"string\" && typeof part === \"string\") {",
                    "      current.splice(-1, 1, lastPart + part);",
                    "    } else {",
                    "      current.push(part);",
                    "    }",
                    "",
                    "    return current;",
                    "  }, []);",
                    "}",
                    "",
                    "function clamp(value, min, max) {",
                    "  return value < min ? min : value > max ? max : value;",
                    "}",
                    "",
                    "function clean(ast, newObj) {",
                    "  // for markdown codeblock",
                    "  if (ast.type === \"code\") {",
                    "    delete newObj.value;",
                    "  }",
                    "  // for markdown whitespace: \"\\n\" and \" \" are considered the same",
                    "  if (ast.type === \"whitespace\" && ast.value === \"\\n\") {",
                    "    newObj.value = \" \";",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore: privateUtil.hasIgnoreComment",
                    "};"
                ]
            }
        },
        "language-vue": {
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const docBuilders = require(\"../doc\").builders;",
                    "const concat = docBuilders.concat;",
                    "const hardline = docBuilders.hardline;",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  if (!parent || parent.tag !== \"root\" || node.unary) {",
                    "    return null;",
                    "  }",
                    "",
                    "  let parser;",
                    "",
                    "  if (node.tag === \"style\") {",
                    "    const langAttr = node.attrs.find(attr => attr.name === \"lang\");",
                    "    if (!langAttr || langAttr.value === \"postcss\") {",
                    "      parser = \"css\";",
                    "    } else if (langAttr.value === \"scss\") {",
                    "      parser = \"scss\";",
                    "    } else if (langAttr.value === \"less\") {",
                    "      parser = \"less\";",
                    "    }",
                    "  }",
                    "",
                    "  if (node.tag === \"script\") {",
                    "    const langAttr = node.attrs.find(attr => attr.name === \"lang\");",
                    "    if (!langAttr) {",
                    "      parser = \"babylon\";",
                    "    } else if (langAttr.value === \"ts\" || langAttr.value === \"tsx\") {",
                    "      parser = \"typescript\";",
                    "    }",
                    "  }",
                    "",
                    "  if (!parser) {",
                    "    return null;",
                    "  }",
                    "",
                    "  return concat([",
                    "    options.originalText.slice(node.start, node.contentStart),",
                    "    hardline,",
                    "    textToDoc(options.originalText.slice(node.contentStart, node.contentEnd), {",
                    "      parser",
                    "    }),",
                    "    options.originalText.slice(node.contentEnd, node.end)",
                    "  ]);",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-vue\");",
                    "",
                    "// Based on:",
                    "// https://github.com/github/linguist/blob/master/lib/linguist/languages.yml",
                    "",
                    "const languages = [",
                    "  {",
                    "    name: \"Vue\",",
                    "    since: \"1.10.0\",",
                    "    parsers: [\"vue\"],",
                    "    group: \"HTML\",",
                    "    tmScope: \"text.html.vue\",",
                    "    aceMode: \"html\",",
                    "    codemirrorMode: \"htmlmixed\",",
                    "    codemirrorMimeType: \"text/html\",",
                    "    extensions: [\".vue\"],",
                    "    linguistLanguageId: 146,",
                    "    vscodeLanguageIds: [\"vue\"]",
                    "  }",
                    "];",
                    "",
                    "const parsers = {",
                    "  vue: {",
                    "    get parse() {",
                    "      return eval(\"require\")(\"./parser-vue\");",
                    "    },",
                    "    astFormat: \"vue\"",
                    "  }",
                    "};",
                    "",
                    "const printers = {",
                    "  vue: printer",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  parsers,",
                    "  printers",
                    "};"
                ]
            },
            "parser-vue.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/*!",
                    " * Extracted from vue codebase",
                    " * https://github.com/vuejs/vue/blob/cfd73c2386623341fdbb3ac636c4baf84ea89c2c/src/compiler/parser/html-parser.js",
                    " * HTML Parser By John Resig (ejohn.org)",
                    " * Modified by Juriy \"kangax\" Zaytsev",
                    " * Original code by Erik Arvidsson, Mozilla Public License",
                    " * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js",
                    " */",
                    "",
                    "/**",
                    " * Make a map and return a function for checking if a key",
                    " * is in that map.",
                    " */",
                    "function makeMap(str, expectsLowerCase) {",
                    "  const map = Object.create(null);",
                    "  const list = str.split(\",\");",
                    "  for (let i = 0; i < list.length; i++) {",
                    "    map[list[i]] = true;",
                    "  }",
                    "  return expectsLowerCase ? val => map[val.toLowerCase()] : val => map[val];",
                    "}",
                    "",
                    "/**",
                    " * Always return false.",
                    " */",
                    "const no = () => false;",
                    "",
                    "// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3",
                    "// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content",
                    "const isNonPhrasingTag = makeMap(",
                    "  \"address,article,aside,base,blockquote,body,caption,col,colgroup,dd,\" +",
                    "    \"details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,\" +",
                    "    \"h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,\" +",
                    "    \"optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,\" +",
                    "    \"title,tr,track\"",
                    ");",
                    "",
                    "// Regular Expressions for parsing tags and attributes",
                    "const attribute = /^\\s*([^\\s\"'<>/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;",
                    "// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName",
                    "// but for Vue templates we can enforce a simple charset",
                    "const ncname = \"[a-zA-Z_][\\\\w\\\\-\\\\.]*\";",
                    "const qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;",
                    "const startTagOpen = new RegExp(`^<${qnameCapture}`);",
                    "const startTagClose = /^\\s*(\\/?)>/;",
                    "const endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);",
                    "const doctype = /^<!DOCTYPE [^>]+>/i;",
                    "const comment = /^<!--/;",
                    "const conditionalComment = /^<!\\[/;",
                    "",
                    "let IS_REGEX_CAPTURING_BROKEN = false;",
                    "\"x\".replace(/x(.)?/g, (m, g) => {",
                    "  IS_REGEX_CAPTURING_BROKEN = g === \"\";",
                    "});",
                    "",
                    "// Special Elements (can contain anything)",
                    "const isPlainTextElement = makeMap(\"script,style,textarea\", true);",
                    "const reCache = {};",
                    "",
                    "const decodingMap = {",
                    "  \"&lt;\": \"<\",",
                    "  \"&gt;\": \">\",",
                    "  \"&quot;\": '\"',",
                    "  \"&amp;\": \"&\",",
                    "  \"&#10;\": \"\\n\",",
                    "  \"&#9;\": \"\\t\"",
                    "};",
                    "const encodedAttr = /&(?:lt|gt|quot|amp);/g;",
                    "const encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;",
                    "",
                    "// #5992",
                    "const isIgnoreNewlineTag = makeMap(\"pre,textarea\", true);",
                    "const shouldIgnoreFirstNewline = (tag, html) =>",
                    "  tag && isIgnoreNewlineTag(tag) && html[0] === \"\\n\";",
                    "",
                    "function decodeAttr(value, shouldDecodeNewlines) {",
                    "  const re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;",
                    "  return value.replace(re, match => decodingMap[match]);",
                    "}",
                    "",
                    "function parseHTML(html, options) {",
                    "  const stack = [];",
                    "  const expectHTML = options.expectHTML;",
                    "  const isUnaryTag = options.isUnaryTag || no;",
                    "  const canBeLeftOpenTag = options.canBeLeftOpenTag || no;",
                    "  let index = 0;",
                    "  let last;",
                    "  let lastTag;",
                    "  while (html) {",
                    "    last = html;",
                    "    // Make sure we're not in a plaintext content element like script/style",
                    "    if (!lastTag || !isPlainTextElement(lastTag)) {",
                    "      let textEnd = html.indexOf(\"<\");",
                    "      if (textEnd === 0) {",
                    "        // Comment:",
                    "        if (comment.test(html)) {",
                    "          const commentEnd = html.indexOf(\"-->\");",
                    "",
                    "          if (commentEnd >= 0) {",
                    "            if (options.shouldKeepComment) {",
                    "              options.comment(html.substring(4, commentEnd));",
                    "            }",
                    "            advance(commentEnd + 3);",
                    "            continue;",
                    "          }",
                    "        }",
                    "",
                    "        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment",
                    "        if (conditionalComment.test(html)) {",
                    "          const conditionalEnd = html.indexOf(\"]>\");",
                    "",
                    "          if (conditionalEnd >= 0) {",
                    "            advance(conditionalEnd + 2);",
                    "            continue;",
                    "          }",
                    "        }",
                    "",
                    "        // Doctype:",
                    "        const doctypeMatch = html.match(doctype);",
                    "        if (doctypeMatch) {",
                    "          advance(doctypeMatch[0].length);",
                    "          continue;",
                    "        }",
                    "",
                    "        // End tag:",
                    "        const endTagMatch = html.match(endTag);",
                    "        if (endTagMatch) {",
                    "          const curIndex = index;",
                    "          advance(endTagMatch[0].length);",
                    "          parseEndTag(endTagMatch[1], curIndex, index);",
                    "          continue;",
                    "        }",
                    "",
                    "        // Start tag:",
                    "        const startTagMatch = parseStartTag();",
                    "        if (startTagMatch) {",
                    "          handleStartTag(startTagMatch);",
                    "          if (shouldIgnoreFirstNewline(lastTag, html)) {",
                    "            advance(1);",
                    "          }",
                    "          continue;",
                    "        }",
                    "      }",
                    "",
                    "      let text;",
                    "      let rest;",
                    "      let next;",
                    "      if (textEnd >= 0) {",
                    "        rest = html.slice(textEnd);",
                    "        while (",
                    "          !endTag.test(rest) &&",
                    "          !startTagOpen.test(rest) &&",
                    "          !comment.test(rest) &&",
                    "          !conditionalComment.test(rest)",
                    "        ) {",
                    "          // < in plain text, be forgiving and treat it as text",
                    "          next = rest.indexOf(\"<\", 1);",
                    "          if (next < 0) {",
                    "            break;",
                    "          }",
                    "          textEnd += next;",
                    "          rest = html.slice(textEnd);",
                    "        }",
                    "        text = html.substring(0, textEnd);",
                    "        advance(textEnd);",
                    "      }",
                    "",
                    "      if (textEnd < 0) {",
                    "        text = html;",
                    "        html = \"\";",
                    "      }",
                    "",
                    "      if (options.chars && text) {",
                    "        options.chars(text);",
                    "      }",
                    "    } else {",
                    "      let endTagLength = 0;",
                    "      const stackedTag = lastTag.toLowerCase();",
                    "      const reStackedTag =",
                    "        reCache[stackedTag] ||",
                    "        (reCache[stackedTag] = new RegExp(",
                    "          \"([\\\\s\\\\S]*?)(</\" + stackedTag + \"[^>]*>)\",",
                    "          \"i\"",
                    "        ));",
                    "      const rest = html.replace(reStackedTag, (all, text, endTag) => {",
                    "        endTagLength = endTag.length;",
                    "        if (!isPlainTextElement(stackedTag) && stackedTag !== \"noscript\") {",
                    "          text = text",
                    "            .replace(/<!--([\\s\\S]*?)-->/g, \"$1\")",
                    "            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, \"$1\");",
                    "        }",
                    "        if (shouldIgnoreFirstNewline(stackedTag, text)) {",
                    "          text = text.slice(1);",
                    "        }",
                    "        if (options.chars) {",
                    "          options.chars(text);",
                    "        }",
                    "        return \"\";",
                    "      });",
                    "      index += html.length - rest.length;",
                    "      html = rest;",
                    "      parseEndTag(stackedTag, index - endTagLength, index);",
                    "    }",
                    "",
                    "    if (html === last) {",
                    "      options.chars && options.chars(html);",
                    "      if (",
                    "        process.env.NODE_ENV !== \"production\" &&",
                    "        !stack.length &&",
                    "        options.warn",
                    "      ) {",
                    "        options.warn(`Mal-formatted tag at end of template: \"${html}\"`);",
                    "      }",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  // Clean up any remaining tags",
                    "  parseEndTag();",
                    "",
                    "  function advance(n) {",
                    "    index += n;",
                    "    html = html.substring(n);",
                    "  }",
                    "",
                    "  function parseStartTag() {",
                    "    const start = html.match(startTagOpen);",
                    "    if (start) {",
                    "      const match = {",
                    "        tagName: start[1],",
                    "        attrs: [],",
                    "        start: index",
                    "      };",
                    "      advance(start[0].length);",
                    "      let end;",
                    "      let attr;",
                    "      while (",
                    "        !(end = html.match(startTagClose)) &&",
                    "        (attr = html.match(attribute))",
                    "      ) {",
                    "        advance(attr[0].length);",
                    "        match.attrs.push(attr);",
                    "      }",
                    "      if (end) {",
                    "        match.unarySlash = end[1];",
                    "        advance(end[0].length);",
                    "        match.end = index;",
                    "        return match;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  function handleStartTag(match) {",
                    "    const tagName = match.tagName;",
                    "    const unarySlash = match.unarySlash;",
                    "",
                    "    if (expectHTML) {",
                    "      if (lastTag === \"p\" && isNonPhrasingTag(tagName)) {",
                    "        parseEndTag(lastTag);",
                    "      }",
                    "      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {",
                    "        parseEndTag(tagName);",
                    "      }",
                    "    }",
                    "",
                    "    const unary = isUnaryTag(tagName) || !!unarySlash;",
                    "",
                    "    const l = match.attrs.length;",
                    "    const attrs = new Array(l);",
                    "    for (let i = 0; i < l; i++) {",
                    "      const args = match.attrs[i];",
                    "      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778",
                    "      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {",
                    "        if (args[3] === \"\") {",
                    "          delete args[3];",
                    "        }",
                    "        if (args[4] === \"\") {",
                    "          delete args[4];",
                    "        }",
                    "        if (args[5] === \"\") {",
                    "          delete args[5];",
                    "        }",
                    "      }",
                    "      const value = args[3] || args[4] || args[5] || \"\";",
                    "      const shouldDecodeNewlines =",
                    "        tagName === \"a\" && args[1] === \"href\"",
                    "          ? options.shouldDecodeNewlinesForHref",
                    "          : options.shouldDecodeNewlines;",
                    "      attrs[i] = {",
                    "        name: args[1],",
                    "        value: decodeAttr(value, shouldDecodeNewlines)",
                    "      };",
                    "    }",
                    "",
                    "    if (!unary) {",
                    "      stack.push({",
                    "        tag: tagName,",
                    "        lowerCasedTag: tagName.toLowerCase(),",
                    "        attrs: attrs",
                    "      });",
                    "      lastTag = tagName;",
                    "    }",
                    "",
                    "    if (options.start) {",
                    "      options.start(tagName, attrs, unary, match.start, match.end);",
                    "    }",
                    "  }",
                    "",
                    "  function parseEndTag(tagName, start, end) {",
                    "    let pos;",
                    "    let lowerCasedTagName;",
                    "    if (start == null) {",
                    "      start = index;",
                    "    }",
                    "    if (end == null) {",
                    "      end = index;",
                    "    }",
                    "",
                    "    if (tagName) {",
                    "      lowerCasedTagName = tagName.toLowerCase();",
                    "    }",
                    "",
                    "    // Find the closest opened tag of the same type",
                    "    if (tagName) {",
                    "      for (pos = stack.length - 1; pos >= 0; pos--) {",
                    "        if (stack[pos].lowerCasedTag === lowerCasedTagName) {",
                    "          break;",
                    "        }",
                    "      }",
                    "    } else {",
                    "      // If no tag name is provided, clean shop",
                    "      pos = 0;",
                    "    }",
                    "",
                    "    if (pos >= 0) {",
                    "      // Close all the open elements, up the stack",
                    "      for (let i = stack.length - 1; i >= pos; i--) {",
                    "        if (",
                    "          process.env.NODE_ENV !== \"production\" &&",
                    "          (i > pos || !tagName) &&",
                    "          options.warn",
                    "        ) {",
                    "          options.warn(`tag <${stack[i].tag}> has no matching end tag.`);",
                    "        }",
                    "        if (options.end) {",
                    "          options.end(stack[i].tag, start, end);",
                    "        }",
                    "      }",
                    "",
                    "      // Remove the open elements from the stack",
                    "      stack.length = pos;",
                    "      lastTag = pos && stack[pos - 1].tag;",
                    "    } else if (lowerCasedTagName === \"br\") {",
                    "      if (options.start) {",
                    "        options.start(tagName, [], true, start, end);",
                    "      }",
                    "    } else if (lowerCasedTagName === \"p\") {",
                    "      if (options.start) {",
                    "        options.start(tagName, [], false, start, end);",
                    "      }",
                    "      if (options.end) {",
                    "        options.end(tagName, start, end);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function parse(text /*, parsers, opts*/) {",
                    "  const rootObj = {",
                    "    tag: \"root\",",
                    "    attrs: [],",
                    "    unary: false,",
                    "    start: 0,",
                    "    contentStart: 0,",
                    "    contentEnd: text.length,",
                    "    end: text.length,",
                    "    children: [],",
                    "    comments: []",
                    "  };",
                    "  const objStack = [rootObj];",
                    "  let obj = rootObj;",
                    "  parseHTML(text, {",
                    "    start: function(tag, attrs, unary, start, end) {",
                    "      const newObj = {",
                    "        tag,",
                    "        attrs,",
                    "        unary,",
                    "        start,",
                    "        children: []",
                    "      };",
                    "      obj.children.push(newObj);",
                    "      if (unary) {",
                    "        newObj.end = end;",
                    "      } else {",
                    "        newObj.contentStart = end;",
                    "        objStack.push(newObj);",
                    "        obj = newObj;",
                    "      }",
                    "    },",
                    "    end: function(tag, start, end) {",
                    "      objStack.pop();",
                    "      obj.contentEnd = start;",
                    "      obj.end = end;",
                    "      obj = objStack[objStack.length - 1];",
                    "    }",
                    "  });",
                    "  return rootObj;",
                    "}",
                    "",
                    "module.exports = parse;"
                ]
            },
            "printer-vue.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const embed = require(\"./embed\");",
                    "const docBuilders = require(\"../doc\").builders;",
                    "const concat = docBuilders.concat;",
                    "const hardline = docBuilders.hardline;",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const n = path.getValue();",
                    "  const res = [];",
                    "  let index = n.start;",
                    "",
                    "  path.each(childPath => {",
                    "    const child = childPath.getValue();",
                    "    res.push(options.originalText.slice(index, child.start));",
                    "    res.push(childPath.call(print));",
                    "    index = child.end;",
                    "  }, \"children\");",
                    "",
                    "  // If there are no children, we just print the node from start to end.",
                    "  // Otherwise, index should point to the end of the last child, and we",
                    "  // need to print the closing tag.",
                    "  res.push(options.originalText.slice(index, n.end));",
                    "",
                    "  // Only force a trailing newline if there were any contents.",
                    "  if (n.tag === \"root\" && n.children.length) {",
                    "    res.push(hardline);",
                    "  }",
                    "",
                    "  return concat(res);",
                    "}",
                    "",
                    "const clean = (ast, newObj) => {",
                    "  delete newObj.contentStart;",
                    "  delete newObj.contentEnd;",
                    "};",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  massageAstNode: clean",
                    "};"
                ]
            }
        },
        "main": {
            "ast-to-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "const comments = require(\"./comments\");",
                    "const FastPath = require(\"../common/fast-path\");",
                    "const multiparser = require(\"./multiparser\");",
                    "",
                    "const doc = require(\"../doc\");",
                    "const docBuilders = doc.builders;",
                    "const concat = docBuilders.concat;",
                    "const hardline = docBuilders.hardline;",
                    "const addAlignmentToDoc = docBuilders.addAlignmentToDoc;",
                    "const docUtils = doc.utils;",
                    "",
                    "function printAstToDoc(ast, options, addAlignmentSize) {",
                    "  addAlignmentSize = addAlignmentSize || 0;",
                    "",
                    "  const printer = options.printer;",
                    "  const cache = new Map();",
                    "",
                    "  function printGenerically(path, args) {",
                    "    const node = path.getValue();",
                    "",
                    "    const shouldCache = node && typeof node === \"object\" && args === undefined;",
                    "    if (shouldCache && cache.has(node)) {",
                    "      return cache.get(node);",
                    "    }",
                    "",
                    "    // We let JSXElement print its comments itself because it adds () around",
                    "    // UnionTypeAnnotation has to align the child without the comments",
                    "    let res;",
                    "    if (printer.willPrintOwnComments && printer.willPrintOwnComments(path)) {",
                    "      res = genericPrint(path, options, printGenerically, args);",
                    "    } else {",
                    "      res = comments.printComments(",
                    "        path,",
                    "        p => genericPrint(p, options, printGenerically, args),",
                    "        options,",
                    "        args && args.needsSemi",
                    "      );",
                    "    }",
                    "",
                    "    if (shouldCache) {",
                    "      cache.set(node, res);",
                    "    }",
                    "",
                    "    return res;",
                    "  }",
                    "",
                    "  let doc = printGenerically(new FastPath(ast));",
                    "  if (addAlignmentSize > 0) {",
                    "    // Add a hardline to make the indents take effect",
                    "    // It should be removed in index.js format()",
                    "    doc = addAlignmentToDoc(",
                    "      docUtils.removeLines(concat([hardline, doc])),",
                    "      addAlignmentSize,",
                    "      options.tabWidth",
                    "    );",
                    "  }",
                    "  docUtils.propagateBreaks(doc);",
                    "",
                    "  if (options.parser === \"json\") {",
                    "    doc = concat([doc, hardline]);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function genericPrint(path, options, printPath, args) {",
                    "  assert.ok(path instanceof FastPath);",
                    "",
                    "  const node = path.getValue();",
                    "  const printer = options.printer;",
                    "",
                    "  // Escape hatch",
                    "  if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {",
                    "    return options.originalText.slice(",
                    "      options.locStart(node),",
                    "      options.locEnd(node)",
                    "    );",
                    "  }",
                    "",
                    "  if (node) {",
                    "    try {",
                    "      // Potentially switch to a different parser",
                    "      const sub = multiparser.printSubtree(path, printPath, options);",
                    "      if (sub) {",
                    "        return sub;",
                    "      }",
                    "    } catch (error) {",
                    "      /* istanbul ignore if */",
                    "      if (process.env.PRETTIER_DEBUG) {",
                    "        throw error;",
                    "      }",
                    "      // Continue with current parser",
                    "    }",
                    "  }",
                    "",
                    "  return printer.print(path, options, printPath, args);",
                    "}",
                    "",
                    "module.exports = printAstToDoc;"
                ]
            },
            "comments.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "const docBuilders = require(\"../doc\").builders;",
                    "const concat = docBuilders.concat;",
                    "const hardline = docBuilders.hardline;",
                    "const breakParent = docBuilders.breakParent;",
                    "const indent = docBuilders.indent;",
                    "const lineSuffix = docBuilders.lineSuffix;",
                    "const join = docBuilders.join;",
                    "const cursor = docBuilders.cursor;",
                    "const privateUtil = require(\"../common/util\");",
                    "const sharedUtil = require(\"../common/util-shared\");",
                    "const childNodesCacheKey = Symbol(\"child-nodes\");",
                    "",
                    "const addLeadingComment = sharedUtil.addLeadingComment;",
                    "const addTrailingComment = sharedUtil.addTrailingComment;",
                    "const addDanglingComment = sharedUtil.addDanglingComment;",
                    "",
                    "function getSortedChildNodes(node, text, options, resultArray) {",
                    "  if (!node) {",
                    "    return;",
                    "  }",
                    "  const printer = options.printer;",
                    "  const locStart = options.locStart;",
                    "  const locEnd = options.locEnd;",
                    "",
                    "  if (resultArray) {",
                    "    if (node && printer.canAttachComment && printer.canAttachComment(node)) {",
                    "      // This reverse insertion sort almost always takes constant",
                    "      // time because we almost always (maybe always?) append the",
                    "      // nodes in order anyway.",
                    "      let i;",
                    "      for (i = resultArray.length - 1; i >= 0; --i) {",
                    "        if (",
                    "          locStart(resultArray[i]) <= locStart(node) &&",
                    "          locEnd(resultArray[i]) <= locEnd(node)",
                    "        ) {",
                    "          break;",
                    "        }",
                    "      }",
                    "      resultArray.splice(i + 1, 0, node);",
                    "      return;",
                    "    }",
                    "  } else if (node[childNodesCacheKey]) {",
                    "    return node[childNodesCacheKey];",
                    "  }",
                    "",
                    "  let childNodes;",
                    "",
                    "  if (printer.getCommentChildNodes) {",
                    "    childNodes = printer.getCommentChildNodes(node);",
                    "  } else if (node && typeof node === \"object\") {",
                    "    childNodes = Object.keys(node)",
                    "      .filter(",
                    "        n =>",
                    "          n !== \"enclosingNode\" &&",
                    "          n !== \"precedingNode\" &&",
                    "          n !== \"followingNode\"",
                    "      )",
                    "      .map(n => node[n]);",
                    "  }",
                    "",
                    "  if (!childNodes) {",
                    "    return;",
                    "  }",
                    "",
                    "  if (!resultArray) {",
                    "    Object.defineProperty(node, childNodesCacheKey, {",
                    "      value: (resultArray = []),",
                    "      enumerable: false",
                    "    });",
                    "  }",
                    "",
                    "  childNodes.forEach(childNode => {",
                    "    getSortedChildNodes(childNode, text, options, resultArray);",
                    "  });",
                    "",
                    "  return resultArray;",
                    "}",
                    "",
                    "// As efficiently as possible, decorate the comment object with",
                    "// .precedingNode, .enclosingNode, and/or .followingNode properties, at",
                    "// least one of which is guaranteed to be defined.",
                    "function decorateComment(node, comment, text, options) {",
                    "  const locStart = options.locStart;",
                    "  const locEnd = options.locEnd;",
                    "  const childNodes = getSortedChildNodes(node, text, options);",
                    "  let precedingNode;",
                    "  let followingNode;",
                    "  // Time to dust off the old binary search robes and wizard hat.",
                    "  let left = 0;",
                    "  let right = childNodes.length;",
                    "  while (left < right) {",
                    "    const middle = (left + right) >> 1;",
                    "    const child = childNodes[middle];",
                    "",
                    "    if (",
                    "      locStart(child) - locStart(comment) <= 0 &&",
                    "      locEnd(comment) - locEnd(child) <= 0",
                    "    ) {",
                    "      // The comment is completely contained by this child node.",
                    "      comment.enclosingNode = child;",
                    "",
                    "      decorateComment(child, comment, text, options);",
                    "      return; // Abandon the binary search at this level.",
                    "    }",
                    "",
                    "    if (locEnd(child) - locStart(comment) <= 0) {",
                    "      // This child node falls completely before the comment.",
                    "      // Because we will never consider this node or any nodes",
                    "      // before it again, this node must be the closest preceding",
                    "      // node we have encountered so far.",
                    "      precedingNode = child;",
                    "      left = middle + 1;",
                    "      continue;",
                    "    }",
                    "",
                    "    if (locEnd(comment) - locStart(child) <= 0) {",
                    "      // This child node falls completely after the comment.",
                    "      // Because we will never consider this node or any nodes after",
                    "      // it again, this node must be the closest following node we",
                    "      // have encountered so far.",
                    "      followingNode = child;",
                    "      right = middle;",
                    "      continue;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw new Error(\"Comment location overlaps with node location\");",
                    "  }",
                    "",
                    "  // We don't want comments inside of different expressions inside of the same",
                    "  // template literal to move to another expression.",
                    "  if (",
                    "    comment.enclosingNode &&",
                    "    comment.enclosingNode.type === \"TemplateLiteral\"",
                    "  ) {",
                    "    const quasis = comment.enclosingNode.quasis;",
                    "    const commentIndex = findExpressionIndexForComment(",
                    "      quasis,",
                    "      comment,",
                    "      options",
                    "    );",
                    "",
                    "    if (",
                    "      precedingNode &&",
                    "      findExpressionIndexForComment(quasis, precedingNode, options) !==",
                    "        commentIndex",
                    "    ) {",
                    "      precedingNode = null;",
                    "    }",
                    "    if (",
                    "      followingNode &&",
                    "      findExpressionIndexForComment(quasis, followingNode, options) !==",
                    "        commentIndex",
                    "    ) {",
                    "      followingNode = null;",
                    "    }",
                    "  }",
                    "",
                    "  if (precedingNode) {",
                    "    comment.precedingNode = precedingNode;",
                    "  }",
                    "",
                    "  if (followingNode) {",
                    "    comment.followingNode = followingNode;",
                    "  }",
                    "}",
                    "",
                    "function attach(comments, ast, text, options) {",
                    "  if (!Array.isArray(comments)) {",
                    "    return;",
                    "  }",
                    "",
                    "  const tiesToBreak = [];",
                    "  const locStart = options.locStart;",
                    "  const locEnd = options.locEnd;",
                    "",
                    "  comments.forEach((comment, i) => {",
                    "    if (options.parser === \"json\" && locStart(comment) - locStart(ast) <= 0) {",
                    "      addLeadingComment(ast, comment);",
                    "      return;",
                    "    }",
                    "",
                    "    decorateComment(ast, comment, text, options);",
                    "",
                    "    const precedingNode = comment.precedingNode;",
                    "    const enclosingNode = comment.enclosingNode;",
                    "    const followingNode = comment.followingNode;",
                    "",
                    "    const pluginHandleOwnLineComment =",
                    "      options.printer.handleComments && options.printer.handleComments.ownLine",
                    "        ? options.printer.handleComments.ownLine",
                    "        : () => false;",
                    "    const pluginHandleEndOfLineComment =",
                    "      options.printer.handleComments && options.printer.handleComments.endOfLine",
                    "        ? options.printer.handleComments.endOfLine",
                    "        : () => false;",
                    "    const pluginHandleRemainingComment =",
                    "      options.printer.handleComments && options.printer.handleComments.remaining",
                    "        ? options.printer.handleComments.remaining",
                    "        : () => false;",
                    "",
                    "    const isLastComment = comments.length - 1 === i;",
                    "",
                    "    if (privateUtil.hasNewline(text, locStart(comment), { backwards: true })) {",
                    "      // If a comment exists on its own line, prefer a leading comment.",
                    "      // We also need to check if it's the first line of the file.",
                    "      if (",
                    "        pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)",
                    "      ) {",
                    "        // We're good",
                    "      } else if (followingNode) {",
                    "        // Always a leading comment.",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (precedingNode) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    } else if (privateUtil.hasNewline(text, locEnd(comment))) {",
                    "      if (",
                    "        pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)",
                    "      ) {",
                    "        // We're good",
                    "      } else if (precedingNode) {",
                    "        // There is content before this comment on the same line, but",
                    "        // none after it, so prefer a trailing comment of the previous node.",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (followingNode) {",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    } else {",
                    "      if (",
                    "        pluginHandleRemainingComment(comment, text, options, ast, isLastComment)",
                    "      ) {",
                    "        // We're good",
                    "      } else if (precedingNode && followingNode) {",
                    "        // Otherwise, text exists both before and after the comment on",
                    "        // the same line. If there is both a preceding and following",
                    "        // node, use a tie-breaking algorithm to determine if it should",
                    "        // be attached to the next or previous node. In the last case,",
                    "        // simply attach the right node;",
                    "        const tieCount = tiesToBreak.length;",
                    "        if (tieCount > 0) {",
                    "          const lastTie = tiesToBreak[tieCount - 1];",
                    "          if (lastTie.followingNode !== comment.followingNode) {",
                    "            breakTies(tiesToBreak, text, options);",
                    "          }",
                    "        }",
                    "        tiesToBreak.push(comment);",
                    "      } else if (precedingNode) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (followingNode) {",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    }",
                    "  });",
                    "",
                    "  breakTies(tiesToBreak, text, options);",
                    "",
                    "  comments.forEach(comment => {",
                    "    // These node references were useful for breaking ties, but we",
                    "    // don't need them anymore, and they create cycles in the AST that",
                    "    // may lead to infinite recursion if we don't delete them here.",
                    "    delete comment.precedingNode;",
                    "    delete comment.enclosingNode;",
                    "    delete comment.followingNode;",
                    "  });",
                    "}",
                    "",
                    "function breakTies(tiesToBreak, text, options) {",
                    "  const tieCount = tiesToBreak.length;",
                    "  if (tieCount === 0) {",
                    "    return;",
                    "  }",
                    "",
                    "  const precedingNode = tiesToBreak[0].precedingNode;",
                    "  const followingNode = tiesToBreak[0].followingNode;",
                    "  let gapEndPos = options.locStart(followingNode);",
                    "",
                    "  // Iterate backwards through tiesToBreak, examining the gaps",
                    "  // between the tied comments. In order to qualify as leading, a",
                    "  // comment must be separated from followingNode by an unbroken series of",
                    "  // gaps (or other comments). Gaps should only contain whitespace or open",
                    "  // parentheses.",
                    "  let indexOfFirstLeadingComment;",
                    "  for (",
                    "    indexOfFirstLeadingComment = tieCount;",
                    "    indexOfFirstLeadingComment > 0;",
                    "    --indexOfFirstLeadingComment",
                    "  ) {",
                    "    const comment = tiesToBreak[indexOfFirstLeadingComment - 1];",
                    "    assert.strictEqual(comment.precedingNode, precedingNode);",
                    "    assert.strictEqual(comment.followingNode, followingNode);",
                    "",
                    "    const gap = text.slice(options.locEnd(comment), gapEndPos).trim();",
                    "    if (gap === \"\" || /^\\(+$/.test(gap)) {",
                    "      gapEndPos = options.locStart(comment);",
                    "    } else {",
                    "      // The gap string contained something other than whitespace or open",
                    "      // parentheses.",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  tiesToBreak.forEach((comment, i) => {",
                    "    if (i < indexOfFirstLeadingComment) {",
                    "      addTrailingComment(precedingNode, comment);",
                    "    } else {",
                    "      addLeadingComment(followingNode, comment);",
                    "    }",
                    "  });",
                    "",
                    "  tiesToBreak.length = 0;",
                    "}",
                    "",
                    "function printComment(commentPath, options) {",
                    "  const comment = commentPath.getValue();",
                    "  comment.printed = true;",
                    "  return options.printer.printComment(commentPath, options);",
                    "}",
                    "",
                    "function findExpressionIndexForComment(quasis, comment, options) {",
                    "  const startPos = options.locStart(comment) - 1;",
                    "",
                    "  for (let i = 1; i < quasis.length; ++i) {",
                    "    if (startPos < getQuasiRange(quasis[i]).start) {",
                    "      return i - 1;",
                    "    }",
                    "  }",
                    "",
                    "  // We haven't found it, it probably means that some of the locations are off.",
                    "  // Let's just return the first one.",
                    "  /* istanbul ignore next */",
                    "  return 0;",
                    "}",
                    "",
                    "function getQuasiRange(expr) {",
                    "  if (expr.start !== undefined) {",
                    "    // Babylon",
                    "    return { start: expr.start, end: expr.end };",
                    "  }",
                    "  // Flow",
                    "  return { start: expr.range[0], end: expr.range[1] };",
                    "}",
                    "",
                    "function printLeadingComment(commentPath, print, options) {",
                    "  const comment = commentPath.getValue();",
                    "  const contents = printComment(commentPath, options);",
                    "  if (!contents) {",
                    "    return \"\";",
                    "  }",
                    "  const isBlock = privateUtil.isBlockComment(comment);",
                    "",
                    "  // Leading block comments should see if they need to stay on the",
                    "  // same line or not.",
                    "  if (isBlock) {",
                    "    return concat([",
                    "      contents,",
                    "      privateUtil.hasNewline(options.originalText, options.locEnd(comment))",
                    "        ? hardline",
                    "        : \" \"",
                    "    ]);",
                    "  }",
                    "",
                    "  return concat([contents, hardline]);",
                    "}",
                    "",
                    "function printTrailingComment(commentPath, print, options) {",
                    "  const comment = commentPath.getValue();",
                    "  const contents = printComment(commentPath, options);",
                    "  if (!contents) {",
                    "    return \"\";",
                    "  }",
                    "  const isBlock = privateUtil.isBlockComment(comment);",
                    "",
                    "  // We don't want the line to break",
                    "  // when the parentParentNode is a ClassDeclaration/-Expression",
                    "  // And the parentNode is in the superClass property",
                    "  const parentNode = commentPath.getNode(1);",
                    "  const parentParentNode = commentPath.getNode(2);",
                    "  const isParentSuperClass =",
                    "    parentParentNode &&",
                    "    (parentParentNode.type === \"ClassDeclaration\" ||",
                    "      parentParentNode.type === \"ClassExpression\") &&",
                    "    parentParentNode.superClass === parentNode;",
                    "",
                    "  if (",
                    "    privateUtil.hasNewline(options.originalText, options.locStart(comment), {",
                    "      backwards: true",
                    "    })",
                    "  ) {",
                    "    // This allows comments at the end of nested structures:",
                    "    // {",
                    "    //   x: 1,",
                    "    //   y: 2",
                    "    //   // A comment",
                    "    // }",
                    "    // Those kinds of comments are almost always leading comments, but",
                    "    // here it doesn't go \"outside\" the block and turns it into a",
                    "    // trailing comment for `2`. We can simulate the above by checking",
                    "    // if this a comment on its own line; normal trailing comments are",
                    "    // always at the end of another expression.",
                    "",
                    "    const isLineBeforeEmpty = privateUtil.isPreviousLineEmpty(",
                    "      options.originalText,",
                    "      comment,",
                    "      options.locStart",
                    "    );",
                    "",
                    "    return lineSuffix(",
                    "      concat([hardline, isLineBeforeEmpty ? hardline : \"\", contents])",
                    "    );",
                    "  } else if (isBlock || isParentSuperClass) {",
                    "    // Trailing block comments never need a newline",
                    "    return concat([\" \", contents]);",
                    "  }",
                    "",
                    "  return concat([lineSuffix(\" \" + contents), !isBlock ? breakParent : \"\"]);",
                    "}",
                    "",
                    "function printDanglingComments(path, options, sameIndent, filter) {",
                    "  const parts = [];",
                    "  const node = path.getValue();",
                    "",
                    "  if (!node || !node.comments) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  path.each(commentPath => {",
                    "    const comment = commentPath.getValue();",
                    "    if (",
                    "      comment &&",
                    "      !comment.leading &&",
                    "      !comment.trailing &&",
                    "      (!filter || filter(comment))",
                    "    ) {",
                    "      parts.push(printComment(commentPath, options));",
                    "    }",
                    "  }, \"comments\");",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (sameIndent) {",
                    "    return join(hardline, parts);",
                    "  }",
                    "  return indent(concat([hardline, join(hardline, parts)]));",
                    "}",
                    "",
                    "function prependCursorPlaceholder(path, options, printed) {",
                    "  if (path.getNode() === options.cursorNode && path.getValue()) {",
                    "    return concat([cursor, printed]);",
                    "  }",
                    "  return printed;",
                    "}",
                    "",
                    "function printComments(path, print, options, needsSemi) {",
                    "  const value = path.getValue();",
                    "  const printed = print(path);",
                    "  const comments = value && value.comments;",
                    "",
                    "  if (!comments || comments.length === 0) {",
                    "    return prependCursorPlaceholder(path, options, printed);",
                    "  }",
                    "",
                    "  const leadingParts = [];",
                    "  const trailingParts = [needsSemi ? \";\" : \"\", printed];",
                    "",
                    "  path.each(commentPath => {",
                    "    const comment = commentPath.getValue();",
                    "    const leading = comment.leading;",
                    "    const trailing = comment.trailing;",
                    "",
                    "    if (leading) {",
                    "      const contents = printLeadingComment(commentPath, print, options);",
                    "      if (!contents) {",
                    "        return;",
                    "      }",
                    "      leadingParts.push(contents);",
                    "",
                    "      const text = options.originalText;",
                    "      if (",
                    "        privateUtil.hasNewline(",
                    "          text,",
                    "          privateUtil.skipNewline(text, options.locEnd(comment))",
                    "        )",
                    "      ) {",
                    "        leadingParts.push(hardline);",
                    "      }",
                    "    } else if (trailing) {",
                    "      trailingParts.push(printTrailingComment(commentPath, print, options));",
                    "    }",
                    "  }, \"comments\");",
                    "",
                    "  return prependCursorPlaceholder(",
                    "    path,",
                    "    options,",
                    "    concat(leadingParts.concat(trailingParts))",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  attach,",
                    "  printComments,",
                    "  printDanglingComments,",
                    "  getSortedChildNodes",
                    "};"
                ]
            },
            "deprecated.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const deprecated = {",
                    "  useFlowParser: config =>",
                    "    `  The ${'\"useFlowParser\"'} option is deprecated. Use ${'\"parser\"'} instead.",
                    "",
                    "  Prettier now treats your configuration as:",
                    "  {",
                    "    ${'\"parser\"'}: ${config.useFlowParser ? '\"flow\"' : '\"babylon\"'}",
                    "  }`",
                    "};",
                    "",
                    "module.exports = deprecated;"
                ]
            },
            "get-plugin.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function getPlugin(options) {",
                    "  const astFormat = options.astFormat;",
                    "",
                    "  if (!astFormat) {",
                    "    throw new Error(\"getPlugin() requires astFormat to be set\");",
                    "  }",
                    "  const printerPlugin = options.plugins.find(",
                    "    plugin => plugin.printers[astFormat]",
                    "  );",
                    "  if (!printerPlugin) {",
                    "    throw new Error(`Couldn't find plugin for AST format \"${astFormat}\"`);",
                    "  }",
                    "",
                    "  return printerPlugin;",
                    "}",
                    "",
                    "module.exports = getPlugin;"
                ]
            },
            "multiparser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const normalize = require(\"./options\").normalize;",
                    "const comments = require(\"./comments\");",
                    "",
                    "function printSubtree(path, print, options) {",
                    "  if (options.printer.embed) {",
                    "    return options.printer.embed(",
                    "      path,",
                    "      print,",
                    "      (text, partialNextOptions) =>",
                    "        textToDoc(text, partialNextOptions, options),",
                    "      options",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function textToDoc(text, partialNextOptions, parentOptions) {",
                    "  const nextOptions = normalize(",
                    "    Object.assign({}, parentOptions, partialNextOptions, {",
                    "      parentParser: parentOptions.parser,",
                    "      originalText: text",
                    "    }),",
                    "    { passThrough: true, inferParser: false }",
                    "  );",
                    "",
                    "  const result = require(\"./parser\").parse(text, nextOptions);",
                    "  const ast = result.ast;",
                    "  text = result.text;",
                    "",
                    "  const astComments = ast.comments;",
                    "  delete ast.comments;",
                    "  comments.attach(astComments, ast, text, nextOptions);",
                    "  return require(\"./ast-to-doc\")(ast, nextOptions);",
                    "}",
                    "",
                    "module.exports = {",
                    "  printSubtree",
                    "};"
                ]
            },
            "options-descriptor.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function apiDescriptor(name, value) {",
                    "  return arguments.length === 1",
                    "    ? JSON.stringify(name)",
                    "    : `\\`{ ${apiDescriptor(name)}: ${JSON.stringify(value)} }\\``;",
                    "}",
                    "",
                    "function cliDescriptor(name, value) {",
                    "  return value === false",
                    "    ? `\\`--no-${name}\\``",
                    "    : value === true || arguments.length === 1",
                    "      ? `\\`--${name}\\``",
                    "      : value === \"\"",
                    "        ? `\\`--${name}\\` without an argument`",
                    "        : `\\`--${name}=${value}\\``;",
                    "}",
                    "",
                    "module.exports = {",
                    "  apiDescriptor,",
                    "  cliDescriptor",
                    "};"
                ]
            },
            "options-normalizer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const leven = require(\"leven\");",
                    "const validator = require(\"./options-validator\");",
                    "const descriptors = require(\"./options-descriptor\");",
                    "",
                    "function normalizeOptions(options, optionInfos, opts) {",
                    "  opts = opts || {};",
                    "  const logger =",
                    "    opts.logger === false",
                    "      ? { warn() {} }",
                    "      : opts.logger !== undefined ? opts.logger : console;",
                    "  const descriptor = opts.descriptor || descriptors.apiDescriptor;",
                    "  const passThrough = opts.passThrough || [];",
                    "",
                    "  const optionInfoMap = optionInfos.reduce(",
                    "    (reduced, optionInfo) =>",
                    "      Object.assign(reduced, { [optionInfo.name]: optionInfo }),",
                    "    {}",
                    "  );",
                    "  const normalizedOptions = Object.keys(options).reduce((newOptions, key) => {",
                    "    const optionInfo = optionInfoMap[key];",
                    "",
                    "    let optionName = key;",
                    "    let optionValue = options[key];",
                    "",
                    "    if (!optionInfo) {",
                    "      if (passThrough === true || passThrough.indexOf(optionName) !== -1) {",
                    "        newOptions[optionName] = optionValue;",
                    "      } else {",
                    "        logger.warn(",
                    "          createUnknownOptionMessage(",
                    "            optionName,",
                    "            optionValue,",
                    "            optionInfos,",
                    "            descriptor",
                    "          )",
                    "        );",
                    "      }",
                    "      return newOptions;",
                    "    }",
                    "",
                    "    if (!optionInfo.deprecated) {",
                    "      optionValue = normalizeOption(optionValue, optionInfo);",
                    "    } else if (typeof optionInfo.redirect === \"string\") {",
                    "      logger.warn(createRedirectOptionMessage(optionInfo, descriptor));",
                    "      optionName = optionInfo.redirect;",
                    "    } else if (optionValue) {",
                    "      logger.warn(createRedirectOptionMessage(optionInfo, descriptor));",
                    "      optionValue = optionInfo.redirect.value;",
                    "      optionName = optionInfo.redirect.option;",
                    "    }",
                    "",
                    "    if (optionInfo.choices) {",
                    "      const choiceInfo = optionInfo.choices.find(",
                    "        choice => choice.value === optionValue",
                    "      );",
                    "      if (choiceInfo && choiceInfo.deprecated) {",
                    "        logger.warn(",
                    "          createRedirectChoiceMessage(optionInfo, choiceInfo, descriptor)",
                    "        );",
                    "        optionValue = choiceInfo.redirect;",
                    "      }",
                    "    }",
                    "",
                    "    if (optionInfo.array && !Array.isArray(optionValue)) {",
                    "      optionValue = [optionValue];",
                    "    }",
                    "",
                    "    if (optionValue !== optionInfo.default) {",
                    "      validator.validateOption(optionValue, optionInfoMap[optionName], {",
                    "        descriptor",
                    "      });",
                    "    }",
                    "",
                    "    newOptions[optionName] = optionValue;",
                    "    return newOptions;",
                    "  }, {});",
                    "",
                    "  return normalizedOptions;",
                    "}",
                    "",
                    "function normalizeOption(option, optionInfo) {",
                    "  return optionInfo.type === \"int\" ? Number(option) : option;",
                    "}",
                    "",
                    "function createUnknownOptionMessage(key, value, optionInfos, descriptor) {",
                    "  const messages = [`Ignored unknown option ${descriptor(key, value)}.`];",
                    "",
                    "  const suggestedOptionInfo = optionInfos.find(",
                    "    optionInfo => leven(optionInfo.name, key) < 3",
                    "  );",
                    "  if (suggestedOptionInfo) {",
                    "    messages.push(`Did you mean ${JSON.stringify(suggestedOptionInfo.name)}?`);",
                    "  }",
                    "",
                    "  return messages.join(\" \");",
                    "}",
                    "",
                    "function createRedirectOptionMessage(optionInfo, descriptor) {",
                    "  return `${descriptor(",
                    "    optionInfo.name",
                    "  )} is deprecated. Prettier now treats it as ${",
                    "    typeof optionInfo.redirect === \"string\"",
                    "      ? descriptor(optionInfo.redirect)",
                    "      : descriptor(optionInfo.redirect.option, optionInfo.redirect.value)",
                    "  }.`;",
                    "}",
                    "",
                    "function createRedirectChoiceMessage(optionInfo, choiceInfo, descriptor) {",
                    "  return `${descriptor(",
                    "    optionInfo.name,",
                    "    choiceInfo.value",
                    "  )} is deprecated. Prettier now treats it as ${descriptor(",
                    "    optionInfo.name,",
                    "    choiceInfo.redirect",
                    "  )}.`;",
                    "}",
                    "",
                    "function normalizeApiOptions(options, optionInfos, opts) {",
                    "  return normalizeOptions(",
                    "    options,",
                    "    optionInfos,",
                    "    Object.assign({ descriptor: descriptors.apiDescriptor }, opts)",
                    "  );",
                    "}",
                    "",
                    "function normalizeCliOptions(options, optionInfos, opts) {",
                    "  const args = options[\"_\"] || [];",
                    "",
                    "  const newOptions = normalizeOptions(",
                    "    Object.keys(options).reduce(",
                    "      (reduced, key) =>",
                    "        Object.assign(",
                    "          reduced,",
                    "          key.length === 1 // omit alias",
                    "            ? null",
                    "            : { [key]: options[key] }",
                    "        ),",
                    "      {}",
                    "    ),",
                    "    optionInfos,",
                    "    Object.assign({ descriptor: descriptors.cliDescriptor }, opts)",
                    "  );",
                    "  newOptions[\"_\"] = args;",
                    "",
                    "  return newOptions;",
                    "}",
                    "",
                    "module.exports = {",
                    "  normalizeApiOptions,",
                    "  normalizeCliOptions",
                    "};"
                ]
            },
            "options-validator.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const descriptors = require(\"./options-descriptor\");",
                    "",
                    "function validateOption(value, optionInfo, opts) {",
                    "  opts = opts || {};",
                    "  const descriptor = opts.descriptor || descriptors.apiDescriptor;",
                    "",
                    "  if (",
                    "    typeof optionInfo.exception === \"function\" &&",
                    "    optionInfo.exception(value)",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  try {",
                    "    validateOptionType(value, optionInfo);",
                    "  } catch (error) {",
                    "    throw new Error(",
                    "      `Invalid \\`${descriptor(optionInfo.name)}\\` value. ${",
                    "        error.message",
                    "      }, but received \\`${JSON.stringify(value)}\\`.`",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function validateOptionType(value, optionInfo) {",
                    "  if (optionInfo.array) {",
                    "    if (!Array.isArray(value)) {",
                    "      throw new Error(`Expected an array`);",
                    "    }",
                    "    value.forEach(v =>",
                    "      validateOptionType(v, Object.assign({}, optionInfo, { array: false }))",
                    "    );",
                    "  } else {",
                    "    switch (optionInfo.type) {",
                    "      case \"int\":",
                    "        validateIntOption(value);",
                    "        break;",
                    "      case \"boolean\":",
                    "        validateBooleanOption(value);",
                    "        break;",
                    "      case \"choice\":",
                    "        validateChoiceOption(value, optionInfo.choices);",
                    "        break;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function validateBooleanOption(value) {",
                    "  if (typeof value !== \"boolean\") {",
                    "    throw new Error(`Expected a boolean`);",
                    "  }",
                    "}",
                    "",
                    "function validateIntOption(value) {",
                    "  if (",
                    "    !(",
                    "      typeof value === \"number\" &&",
                    "      Math.floor(value) === value &&",
                    "      value >= 0 &&",
                    "      value !== Infinity",
                    "    )",
                    "  ) {",
                    "    throw new Error(`Expected an integer`);",
                    "  }",
                    "}",
                    "",
                    "function validateChoiceOption(value, choiceInfos) {",
                    "  if (!choiceInfos.some(choiceInfo => choiceInfo.value === value)) {",
                    "    const choices = choiceInfos",
                    "      .filter(choiceInfo => !choiceInfo.deprecated)",
                    "      .map(choiceInfo => JSON.stringify(choiceInfo.value))",
                    "      .sort();",
                    "    const head = choices.slice(0, -2);",
                    "    const tail = choices.slice(-2);",
                    "    throw new Error(`Expected ${head.concat(tail.join(\" or \")).join(\", \")}`);",
                    "  }",
                    "}",
                    "",
                    "module.exports = { validateOption };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const getSupportInfo = require(\"../common/support\").getSupportInfo;",
                    "const normalizer = require(\"./options-normalizer\");",
                    "const loadPlugins = require(\"../common/load-plugins\");",
                    "const resolveParser = require(\"./parser\").resolveParser;",
                    "const getPlugin = require(\"./get-plugin\");",
                    "",
                    "const hiddenDefaults = {",
                    "  astFormat: \"estree\",",
                    "  printer: {},",
                    "  locStart: null,",
                    "  locEnd: null",
                    "};",
                    "",
                    "// Copy options and fill in default values.",
                    "function normalize(options, opts) {",
                    "  opts = opts || {};",
                    "",
                    "  const rawOptions = Object.assign({}, options);",
                    "",
                    "  const plugins = loadPlugins(rawOptions.plugins);",
                    "  rawOptions.plugins = plugins;",
                    "",
                    "  const supportOptions = getSupportInfo(null, {",
                    "    plugins,",
                    "    pluginsLoaded: true,",
                    "    showUnreleased: true,",
                    "    showDeprecated: true",
                    "  }).options;",
                    "  const defaults = supportOptions.reduce(",
                    "    (reduced, optionInfo) =>",
                    "      Object.assign(reduced, { [optionInfo.name]: optionInfo.default }),",
                    "    Object.assign({}, hiddenDefaults)",
                    "  );",
                    "",
                    "  if (opts.inferParser !== false) {",
                    "    if (",
                    "      rawOptions.filepath &&",
                    "      (!rawOptions.parser || rawOptions.parser === defaults.parser)",
                    "    ) {",
                    "      const inferredParser = inferParser(",
                    "        rawOptions.filepath,",
                    "        rawOptions.plugins",
                    "      );",
                    "      if (inferredParser) {",
                    "        rawOptions.parser = inferredParser;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const parser = resolveParser(",
                    "    !rawOptions.parser",
                    "      ? rawOptions",
                    "      : // handle deprecated parsers",
                    "        normalizer.normalizeApiOptions(",
                    "          rawOptions,",
                    "          [supportOptions.find(x => x.name === \"parser\")],",
                    "          { passThrough: true, logger: false }",
                    "        )",
                    "  );",
                    "  rawOptions.astFormat = parser.astFormat;",
                    "  rawOptions.locEnd = parser.locEnd;",
                    "  rawOptions.locStart = parser.locStart;",
                    "",
                    "  const plugin = getPlugin(rawOptions);",
                    "  rawOptions.printer = plugin.printers[rawOptions.astFormat];",
                    "",
                    "  const pluginDefaults = supportOptions",
                    "    .filter(",
                    "      optionInfo =>",
                    "        optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name]",
                    "    )",
                    "    .reduce(",
                    "      (reduced, optionInfo) =>",
                    "        Object.assign(reduced, {",
                    "          [optionInfo.name]: optionInfo.pluginDefaults[plugin.name]",
                    "        }),",
                    "      {}",
                    "    );",
                    "",
                    "  const mixedDefaults = Object.assign({}, defaults, pluginDefaults);",
                    "",
                    "  Object.keys(mixedDefaults).forEach(k => {",
                    "    if (rawOptions[k] == null) {",
                    "      rawOptions[k] = mixedDefaults[k];",
                    "    }",
                    "  });",
                    "",
                    "  if (rawOptions.parser === \"json\") {",
                    "    rawOptions.trailingComma = \"none\";",
                    "  }",
                    "",
                    "  return normalizer.normalizeApiOptions(",
                    "    rawOptions,",
                    "    supportOptions,",
                    "    Object.assign({ passThrough: Object.keys(hiddenDefaults) }, opts)",
                    "  );",
                    "}",
                    "",
                    "function inferParser(filepath, plugins) {",
                    "  const extension = path.extname(filepath);",
                    "  const filename = path.basename(filepath).toLowerCase();",
                    "",
                    "  const language = getSupportInfo(null, {",
                    "    plugins,",
                    "    pluginsLoaded: true",
                    "  }).languages.find(",
                    "    language =>",
                    "      language.since !== null &&",
                    "      (language.extensions.indexOf(extension) > -1 ||",
                    "        (language.filenames &&",
                    "          language.filenames.find(name => name.toLowerCase() === filename)))",
                    "  );",
                    "",
                    "  return language && language.parsers[0];",
                    "}",
                    "",
                    "module.exports = { normalize, hiddenDefaults };"
                ]
            },
            "parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const ConfigError = require(\"../common/errors\").ConfigError;",
                    "const js = require(\"../language-js/index.js\");",
                    "",
                    "const locStart = js.locStart;",
                    "const locEnd = js.locEnd;",
                    "",
                    "function getParsers(options) {",
                    "  return options.plugins.reduce(",
                    "    (parsers, plugin) => Object.assign({}, parsers, plugin.parsers),",
                    "    {}",
                    "  );",
                    "}",
                    "",
                    "function resolveParser(opts, parsers) {",
                    "  parsers = parsers || getParsers(opts);",
                    "",
                    "  if (typeof opts.parser === \"function\") {",
                    "    // Custom parser API always works with JavaScript.",
                    "    return {",
                    "      parse: opts.parser,",
                    "      astFormat: \"estree\",",
                    "      locStart,",
                    "      locEnd",
                    "    };",
                    "  }",
                    "",
                    "  if (typeof opts.parser === \"string\") {",
                    "    if (parsers.hasOwnProperty(opts.parser)) {",
                    "      return parsers[opts.parser];",
                    "    }",
                    "    try {",
                    "      return {",
                    "        parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),",
                    "        astFormat: \"estree\",",
                    "        locStart,",
                    "        locEnd",
                    "      };",
                    "    } catch (err) {",
                    "      /* istanbul ignore next */",
                    "      throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);",
                    "    }",
                    "  }",
                    "  /* istanbul ignore next */",
                    "  return parsers.babylon;",
                    "}",
                    "",
                    "function parse(text, opts) {",
                    "  const parsers = getParsers(opts);",
                    "",
                    "  // Copy the \"parse\" function from parser to a new object whose values are",
                    "  // functions. Use defineProperty()/getOwnPropertyDescriptor() such that we",
                    "  // don't invoke the parser.parse getters.",
                    "  const parsersForCustomParserApi = Object.keys(parsers).reduce(",
                    "    (object, parserName) =>",
                    "      Object.defineProperty(",
                    "        object,",
                    "        parserName,",
                    "        Object.getOwnPropertyDescriptor(parsers[parserName], \"parse\")",
                    "      ),",
                    "    {}",
                    "  );",
                    "",
                    "  const parser = resolveParser(opts, parsers);",
                    "",
                    "  try {",
                    "    if (parser.preprocess) {",
                    "      text = parser.preprocess(text, opts);",
                    "    }",
                    "",
                    "    return {",
                    "      text,",
                    "      ast: parser.parse(text, parsersForCustomParserApi, opts)",
                    "    };",
                    "  } catch (error) {",
                    "    const loc = error.loc;",
                    "",
                    "    if (loc) {",
                    "      const codeFrame = require(\"@babel/code-frame\");",
                    "      error.codeFrame = codeFrame.codeFrameColumns(text, loc, {",
                    "        highlightCode: true",
                    "      });",
                    "      error.message += \"\\n\" + error.codeFrame;",
                    "      throw error;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw error.stack;",
                    "  }",
                    "}",
                    "",
                    "module.exports = { parse, resolveParser };"
                ]
            }
        }
    },
    "tests_config": {
        ".eslintrc.yml": {},
        "fs.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "module.exports = require(\"fs\");"
            ]
        },
        "raw-serializer.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const RAW = Symbol.for(\"raw\");",
                "",
                "module.exports = {",
                "  print(val) {",
                "    return val[RAW];",
                "  },",
                "  test(val) {",
                "    return (",
                "      val &&",
                "      Object.prototype.hasOwnProperty.call(val, RAW) &&",
                "      typeof val[RAW] === \"string\"",
                "    );",
                "  }",
                "};"
            ]
        },
        "require_prettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const isProduction = process.env.NODE_ENV === \"production\";",
                "const prettierRootDir = isProduction ? process.env.PRETTIER_DIR : \"../\";",
                "",
                "const prettier = require(prettierRootDir);",
                "",
                "module.exports = prettier;"
            ]
        },
        "run_spec.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const fs = require(\"fs\");",
                "const extname = require(\"path\").extname;",
                "const prettier = require(\"./require_prettier\");",
                "const massageAST = require(\"../src/common/clean-ast.js\").massageAST;",
                "const normalizeOptions = require(\"../src/main/options\").normalize;",
                "",
                "const AST_COMPARE = process.env[\"AST_COMPARE\"];",
                "",
                "function run_spec(dirname, parsers, options) {",
                "  /* instabul ignore if */",
                "  if (!parsers || !parsers.length) {",
                "    throw new Error(`No parsers were specified for ${dirname}`);",
                "  }",
                "",
                "  fs.readdirSync(dirname).forEach(filename => {",
                "    const path = dirname + \"/\" + filename;",
                "    if (",
                "      extname(filename) !== \".snap\" &&",
                "      fs.lstatSync(path).isFile() &&",
                "      filename[0] !== \".\" &&",
                "      filename !== \"jsfmt.spec.js\"",
                "    ) {",
                "      let rangeStart = 0;",
                "      let rangeEnd = Infinity;",
                "      const source = read(path)",
                "        .replace(/\\r\\n/g, \"\\n\")",
                "        .replace(\"<<<PRETTIER_RANGE_START>>>\", (match, offset) => {",
                "          rangeStart = offset;",
                "          return \"\";",
                "        })",
                "        .replace(\"<<<PRETTIER_RANGE_END>>>\", (match, offset) => {",
                "          rangeEnd = offset;",
                "          return \"\";",
                "        });",
                "",
                "      const mergedOptions = Object.assign(mergeDefaultOptions(options || {}), {",
                "        parser: parsers[0],",
                "        rangeStart: rangeStart,",
                "        rangeEnd: rangeEnd",
                "      });",
                "      const output = prettyprint(source, path, mergedOptions);",
                "      test(`${filename} - ${mergedOptions.parser}-verify`, () => {",
                "        expect(",
                "          raw(source + \"~\".repeat(mergedOptions.printWidth) + \"\\n\" + output)",
                "        ).toMatchSnapshot(filename);",
                "      });",
                "",
                "      parsers.slice(1).forEach(parserName => {",
                "        test(`${filename} - ${parserName}-verify`, () => {",
                "          const verifyOptions = Object.assign(mergedOptions, {",
                "            parser: parserName",
                "          });",
                "          const verifyOutput = prettyprint(source, path, verifyOptions);",
                "          expect(output).toEqual(verifyOutput);",
                "        });",
                "      });",
                "",
                "      if (AST_COMPARE) {",
                "        const normalizedOptions = normalizeOptions(mergedOptions);",
                "        const ast = parse(source, mergedOptions);",
                "        const astMassaged = massageAST(ast, normalizedOptions);",
                "        let ppastMassaged;",
                "        let pperr = null;",
                "        try {",
                "          const ppast = parse(",
                "            prettyprint(source, path, mergedOptions),",
                "            mergedOptions",
                "          );",
                "          ppastMassaged = massageAST(ppast, normalizedOptions);",
                "        } catch (e) {",
                "          pperr = e.stack;",
                "        }",
                "",
                "        test(path + \" parse\", () => {",
                "          expect(pperr).toBe(null);",
                "          expect(ppastMassaged).toBeDefined();",
                "          if (!ast.errors || ast.errors.length === 0) {",
                "            expect(astMassaged).toEqual(ppastMassaged);",
                "          }",
                "        });",
                "      }",
                "    }",
                "  });",
                "}",
                "",
                "global.run_spec = run_spec;",
                "",
                "function stripLocation(ast) {",
                "  if (Array.isArray(ast)) {",
                "    return ast.map(e => stripLocation(e));",
                "  }",
                "  if (typeof ast === \"object\") {",
                "    const newObj = {};",
                "    for (const key in ast) {",
                "      if (",
                "        key === \"loc\" ||",
                "        key === \"range\" ||",
                "        key === \"raw\" ||",
                "        key === \"comments\" ||",
                "        key === \"parent\" ||",
                "        key === \"prev\"",
                "      ) {",
                "        continue;",
                "      }",
                "      newObj[key] = stripLocation(ast[key]);",
                "    }",
                "    return newObj;",
                "  }",
                "  return ast;",
                "}",
                "",
                "function parse(string, opts) {",
                "  return stripLocation(prettier.__debug.parse(string, opts).ast);",
                "}",
                "",
                "function prettyprint(src, filename, options) {",
                "  return prettier.format(",
                "    src,",
                "    Object.assign(",
                "      {",
                "        filepath: filename",
                "      },",
                "      options",
                "    )",
                "  );",
                "}",
                "",
                "function read(filename) {",
                "  return fs.readFileSync(filename, \"utf8\");",
                "}",
                "",
                "/**",
                " * Wraps a string in a marker object that is used by `./raw-serializer.js` to",
                " * directly print that string in a snapshot without escaping all double quotes.",
                " * Backticks will still be escaped.",
                " */",
                "function raw(string) {",
                "  if (typeof string !== \"string\") {",
                "    throw new Error(\"Raw snapshots have to be strings.\");",
                "  }",
                "  return { [Symbol.for(\"raw\")]: string };",
                "}",
                "",
                "function mergeDefaultOptions(parserConfig) {",
                "  return Object.assign(",
                "    {",
                "      printWidth: 80",
                "    },",
                "    parserConfig",
                "  );",
                "}"
            ]
        }
    },
    "tests_integration": {
        ".eslintrc.yml": {},
        "path-serializer.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "module.exports = {",
                "  test: value =>",
                "    typeof value === \"string\" &&",
                "    (value.indexOf(\"\\\\\") > -1 || value.indexOf(process.cwd()) > -1),",
                "  print: (value, serializer) =>",
                "    serializer(value.replace(process.cwd(), \"<cwd>\").replace(/\\\\/g, \"/\"))",
                "};"
            ]
        },
        "runPrettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const fs = require(\"fs\");",
                "const path = require(\"path\");",
                "const stripAnsi = require(\"strip-ansi\");",
                "",
                "const isProduction = process.env.NODE_ENV === \"production\";",
                "const prettierRootDir = isProduction ? process.env.PRETTIER_DIR : \"../\";",
                "const prettierPkg = require(path.join(prettierRootDir, \"package.json\"));",
                "const prettierCli = path.join(prettierRootDir, prettierPkg.bin.prettier);",
                "",
                "const thirdParty = isProduction",
                "  ? path.join(prettierRootDir, \"./third-party\")",
                "  : path.join(prettierRootDir, \"./src/common/third-party\");",
                "",
                "function runPrettier(dir, args, options) {",
                "  args = args || [];",
                "  options = options || {};",
                "",
                "  let status;",
                "  let stdout = \"\";",
                "  let stderr = \"\";",
                "",
                "  jest.spyOn(process, \"exit\").mockImplementation(exitCode => {",
                "    if (status === undefined) {",
                "      status = exitCode || 0;",
                "    }",
                "  });",
                "",
                "  jest",
                "    .spyOn(process.stdout, \"write\")",
                "    .mockImplementation(text => appendStdout(text));",
                "",
                "  jest",
                "    .spyOn(process.stderr, \"write\")",
                "    .mockImplementation(text => appendStderr(text));",
                "",
                "  jest",
                "    .spyOn(console, \"log\")",
                "    .mockImplementation(text => appendStdout(text + \"\\n\"));",
                "",
                "  jest",
                "    .spyOn(console, \"warn\")",
                "    .mockImplementation(text => appendStderr(text + \"\\n\"));",
                "",
                "  jest",
                "    .spyOn(console, \"error\")",
                "    .mockImplementation(text => appendStderr(text + \"\\n\"));",
                "",
                "  jest.spyOn(Date, \"now\").mockImplementation(() => 0);",
                "",
                "  const write = [];",
                "",
                "  jest.spyOn(fs, \"writeFileSync\").mockImplementation((filename, content) => {",
                "    write.push({ filename, content });",
                "  });",
                "",
                "  const originalCwd = process.cwd();",
                "  const originalArgv = process.argv;",
                "  const originalExitCode = process.exitCode;",
                "  const originalStdinIsTTY = process.stdin.isTTY;",
                "  const originalStdoutIsTTY = process.stdout.isTTY;",
                "",
                "  process.chdir(normalizeDir(dir));",
                "  process.stdin.isTTY = !!options.isTTY;",
                "  process.stdout.isTTY = !!options.stdoutIsTTY;",
                "  process.argv = [\"path/to/node\", \"path/to/prettier/bin\"].concat(args);",
                "",
                "  jest.resetModules();",
                "",
                "  // We cannot use `jest.setMock(\"get-stream\", impl)` here, because in the",
                "  // production build everything is bundled into one file so there is no",
                "  // \"get-stream\" module to mock.",
                "  jest.spyOn(require(thirdParty), \"getStream\").mockImplementation(() => ({",
                "    then: handler => handler(options.input || \"\")",
                "  }));",
                "  jest",
                "    .spyOn(require(thirdParty), \"cosmiconfig\")",
                "    .mockImplementation((moduleName, options) =>",
                "      require(\"cosmiconfig\")(",
                "        moduleName,",
                "        Object.assign({}, options, { stopDir: __dirname })",
                "      )",
                "    );",
                "",
                "  try {",
                "    require(prettierCli);",
                "    status = (status === undefined ? process.exitCode : status) || 0;",
                "  } catch (error) {",
                "    status = 1;",
                "    stderr += error.message;",
                "  } finally {",
                "    process.chdir(originalCwd);",
                "    process.argv = originalArgv;",
                "    process.exitCode = originalExitCode;",
                "    process.stdin.isTTY = originalStdinIsTTY;",
                "    process.stdout.isTTY = originalStdoutIsTTY;",
                "    jest.restoreAllMocks();",
                "  }",
                "",
                "  const result = { status, stdout, stderr, write };",
                "",
                "  const testResult = testOptions => {",
                "    testOptions = testOptions || {};",
                "",
                "    Object.keys(result).forEach(name => {",
                "      test(`(${name})`, () => {",
                "        const value =",
                "          typeof result[name] === \"string\"",
                "            ? stripAnsi(result[name])",
                "            : result[name];",
                "        if (name in testOptions) {",
                "          if (name === \"status\" && testOptions[name] === \"non-zero\") {",
                "            expect(value).not.toEqual(0);",
                "          } else {",
                "            expect(value).toEqual(testOptions[name]);",
                "          }",
                "        } else {",
                "          expect(value).toMatchSnapshot();",
                "        }",
                "      });",
                "    });",
                "",
                "    return result;",
                "  };",
                "",
                "  return Object.assign({ test: testResult }, result);",
                "",
                "  function appendStdout(text) {",
                "    if (status === undefined) {",
                "      stdout += text;",
                "    }",
                "  }",
                "  function appendStderr(text) {",
                "    if (status === undefined) {",
                "      stderr += text;",
                "    }",
                "  }",
                "}",
                "",
                "function normalizeDir(dir) {",
                "  const isRelative = dir[0] !== \"/\";",
                "  return isRelative ? path.resolve(__dirname, dir) : dir;",
                "}",
                "",
                "module.exports = runPrettier;"
            ]
        },
        "__tests__": {
            "arg-parsing.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"boolean flags do not swallow the next argument\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [\"--single-quote\", \"file.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"negated options work\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [\"--no-semi\", \"file.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"unknown options are warned\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [\"file.js\", \"--unknown\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"unknown negated options are warned\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [\"file.js\", \"--no-unknown\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"deprecated options are warned\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [\"file.js\", \"--flow-parser\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"deprecated option values are warned\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [\"file.js\", \"--trailing-comma\"]).test({",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "config-invalid.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"throw error with invalid config format\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [\"--config\", \"file/.prettierrc\"]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config target (directory)\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [",
                    "    \"--config\",",
                    "    \"folder/.prettierrc\" // this is a directory",
                    "  ]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config option (int)\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [\"--config\", \"option/int\"]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config option (trailingComma)\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [\"--config\", \"option/trailingComma\"]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config precedence option (configPrecedence)\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [",
                    "    \"--config-precedence\",",
                    "    \"option/configPrecedence\"",
                    "  ]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"show warning with unknown option\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [\"--config\", \"option/unknown\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"show warning with kebab-case option key\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [\"--config\", \"option/kebab-case\"]).test({",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "config-resolution.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const prettier = require(\"../../tests_config/require_prettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"resolves configuration from external files\", () => {",
                    "  runPrettier(\"cli/config/\", [\"**/*.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves configuration from external files and overrides by extname\", () => {",
                    "  runPrettier(\"cli/config/\", [\"**/*.ts\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"accepts configuration from --config\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--config\", \".prettierrc\", \"./js/file.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves configuration file with --find-config-path file\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--find-config-path\", \"no-config/file.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves json configuration file with --find-config-path file\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--find-config-path\", \"rc-json/file.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves yaml configuration file with --find-config-path file\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--find-config-path\", \"rc-yaml/file.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"prints nothing when no file found with --find-config-path\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--find-config-path\", \"..\"]).test({",
                    "    stdout: \"\",",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides take precedence\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--print-width\", \"1\", \"**/*.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with no args\", () => {",
                    "  return prettier.resolveConfig().then(result => {",
                    "    expect(result).toBeNull();",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with no args\", () => {",
                    "  expect(prettier.resolveConfig.sync()).toBeNull();",
                    "});",
                    "",
                    "test(\"API resolveConfig with file arg\", () => {",
                    "  const file = path.resolve(path.join(__dirname, \"../cli/config/js/file.js\"));",
                    "  return prettier.resolveConfig(file).then(result => {",
                    "    expect(result).toMatchObject({",
                    "      tabWidth: 8",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with file arg\", () => {",
                    "  const file = path.resolve(path.join(__dirname, \"../cli/config/js/file.js\"));",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    tabWidth: 8",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with file arg and extension override\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/no-config/file.ts\")",
                    "  );",
                    "  return prettier.resolveConfig(file).then(result => {",
                    "    expect(result).toMatchObject({",
                    "      semi: true",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with file arg and extension override\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/no-config/file.ts\")",
                    "  );",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    semi: true",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with file arg and .editorconfig\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/file.js\")",
                    "  );",
                    "  return prettier.resolveConfig(file, { editorconfig: true }).then(result => {",
                    "    expect(result).toMatchObject({",
                    "      useTabs: true,",
                    "      tabWidth: 8,",
                    "      printWidth: 100",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with file arg and .editorconfig\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/file.js\")",
                    "  );",
                    "",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    semi: false",
                    "  });",
                    "",
                    "  expect(",
                    "    prettier.resolveConfig.sync(file, { editorconfig: true })",
                    "  ).toMatchObject({",
                    "    useTabs: true,",
                    "    tabWidth: 8,",
                    "    printWidth: 100",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with nested file arg and .editorconfig\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/lib/file.js\")",
                    "  );",
                    "  return prettier.resolveConfig(file, { editorconfig: true }).then(result => {",
                    "    expect(result).toMatchObject({",
                    "      useTabs: false,",
                    "      tabWidth: 2,",
                    "      printWidth: 100",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with nested file arg and .editorconfig\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/lib/file.js\")",
                    "  );",
                    "",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    semi: false",
                    "  });",
                    "",
                    "  expect(",
                    "    prettier.resolveConfig.sync(file, { editorconfig: true })",
                    "  ).toMatchObject({",
                    "    useTabs: false,",
                    "    tabWidth: 2,",
                    "    printWidth: 100",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with nested file arg and .editorconfig and indent_size = tab\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/lib/indent_size=tab.js\")",
                    "  );",
                    "  return prettier.resolveConfig(file, { editorconfig: true }).then(result => {",
                    "    expect(result).toMatchObject({",
                    "      useTabs: false,",
                    "      tabWidth: 8,",
                    "      printWidth: 100",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with nested file arg and .editorconfig and indent_size = tab\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/lib/indent_size=tab.js\")",
                    "  );",
                    "",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    semi: false",
                    "  });",
                    "",
                    "  expect(",
                    "    prettier.resolveConfig.sync(file, { editorconfig: true })",
                    "  ).toMatchObject({",
                    "    useTabs: false,",
                    "    tabWidth: 8,",
                    "    printWidth: 100",
                    "  });",
                    "});",
                    "",
                    "test(\"API clearConfigCache\", () => {",
                    "  expect(() => prettier.clearConfigCache()).not.toThrowError();",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync overrides work with absolute paths\", () => {",
                    "  // Absolute path",
                    "  const file = path.join(__dirname, \"../cli/config/filepath/subfolder/file.js\");",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    tabWidth: 6",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig removes $schema option\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/$schema/index.js\")",
                    "  );",
                    "  return prettier.resolveConfig(file).then(result => {",
                    "    expect(result).toEqual({",
                    "      tabWidth: 42",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync removes $schema option\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/$schema/index.js\")",
                    "  );",
                    "  expect(prettier.resolveConfig.sync(file)).toEqual({",
                    "    tabWidth: 42",
                    "  });",
                    "});"
                ]
            },
            "cursor-offset.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"write cursorOffset to stderr with --cursor-offset <int>\", () => {",
                    "  runPrettier(\"cli\", [\"--cursor-offset\", \"2\"], { input: \" 1\" }).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"cursorOffset should not be affected by full-width character\", () => {",
                    "  runPrettier(\"cli\", [\"--cursor-offset\", \"21\"], {",
                    "    input: `const x = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];`",
                    "    //                              ^ offset = 21                              ^ width = 80",
                    "  }).test({",
                    "    /**",
                    "     * const x = [",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *        ^ offset = 26",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\"",
                    "     * ];",
                    "     */",
                    "    stderr: \"26\\n\",",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "debug-check.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"doesn't crash when --debug-check is passed\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"issue1890.js\", \"--debug-check\"]).test({",
                    "    stdout: \"issue1890.js\\n\",",
                    "    stderr: \"\",",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"checks stdin with --debug-check\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--debug-check\"], {",
                    "    input: \"0\"",
                    "  }).test({",
                    "    stdout: \"(stdin)\\n\",",
                    "    stderr: \"\",",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"show diff for 2+ error files with --debug-check\", () => {",
                    "  runPrettier(\"cli/debug-check\", [\"*.js\", \"--debug-check\"]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});"
                ]
            },
            "debug-print-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"prints doc with --debug-print-doc\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--debug-print-doc\"], {",
                    "    input: \"0\"",
                    "  }).test({",
                    "    stdout: '[\"0\", \";\", hardline, breakParent];\\n',",
                    "    stderr: \"\",",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "deprecated-parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"../../tests_config/require_prettier\");",
                    "",
                    "let warnings = \"\";",
                    "",
                    "beforeAll(() => {",
                    "  jest",
                    "    .spyOn(console, \"warn\")",
                    "    .mockImplementation(text => (warnings += text + \"\\n\"));",
                    "});",
                    "",
                    "beforeEach(() => {",
                    "  warnings = \"\";",
                    "});",
                    "",
                    "afterAll(() => {",
                    "  jest.restoreAllMocks();",
                    "});",
                    "",
                    "test(\"API format with deprecated parser should work\", () => {",
                    "  expect(() =>",
                    "    prettier.format(\"body { color: #131313; }\", { parser: \"postcss\" })",
                    "  ).not.toThrowError();",
                    "  expect(warnings).toMatchSnapshot();",
                    "});"
                ]
            },
            "early-exit.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"../../tests_config/require_prettier\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const constant = require(\"../../src/cli/constant\");",
                    "const util = require(\"../../src/cli/util\");",
                    "const commonUtil = require(\"../../src/common/util\");",
                    "const getSupportInfo = require(\"../../src/common/support\").getSupportInfo;",
                    "",
                    "describe(\"show version with --version\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--version\"]).test({",
                    "    stdout: prettier.version + \"\\n\",",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"show usage with --help\", () => {",
                    "  runPrettier(\"cli\", [\"--help\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(`show detailed usage with --help l (alias)`, () => {",
                    "  runPrettier(\"cli\", [\"--help\", \"l\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(`show detailed usage with plugin options (automatic resolution)`, () => {",
                    "  runPrettier(\"plugins/automatic\", [",
                    "    \"--help\",",
                    "    \"tab-width\",",
                    "    \"--parser=bar\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(`show detailed usage with plugin options (manual resolution)`, () => {",
                    "  runPrettier(\"cli\", [",
                    "    \"--help\",",
                    "    \"tab-width\",",
                    "    \"--plugin=../plugins/automatic/node_modules/prettier-plugin-bar\",",
                    "    \"--parser=bar\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "commonUtil",
                    "  .arrayify(",
                    "    Object.assign(",
                    "      {},",
                    "      util.createDetailedOptionMap(",
                    "        getSupportInfo(null, {",
                    "          showDeprecated: true,",
                    "          showUnreleased: true,",
                    "          showInternal: true",
                    "        }).options",
                    "      ),",
                    "      util.normalizeDetailedOptionMap(constant.options)",
                    "    ),",
                    "    \"name\"",
                    "  )",
                    "  .forEach(option => {",
                    "    const optionNames = [",
                    "      option.description ? option.name : null,",
                    "      option.oppositeDescription ? `no-${option.name}` : null",
                    "    ].filter(Boolean);",
                    "",
                    "    optionNames.forEach(optionName => {",
                    "      describe(`show detailed usage with --help ${optionName}`, () => {",
                    "        runPrettier(\"cli\", [\"--help\", optionName]).test({",
                    "          status: 0",
                    "        });",
                    "      });",
                    "    });",
                    "  });",
                    "",
                    "describe(\"show warning with --help not-found\", () => {",
                    "  runPrettier(\"cli\", [\"--help\", \"not-found\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"show warning with --help not-found (typo)\", () => {",
                    "  runPrettier(\"cli\", [\"--help\", \"parserr\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with --write + --debug-check\", () => {",
                    "  runPrettier(\"cli\", [\"--write\", \"--debug-check\"]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with --find-config-path + multiple files\", () => {",
                    "  runPrettier(\"cli\", [\"--find-config-path\", \"abc.js\", \"def.js\"]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error and show usage with something unexpected\", () => {",
                    "  runPrettier(\"cli\", [], { isTTY: true }).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});"
                ]
            },
            "ignore-absolute-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"support absolute filename\", () => {",
                    "  runPrettier(\"cli/ignore-absolute-path\", [",
                    "    path.resolve(__dirname, \"../cli/ignore-absolute-path/ignored/module.js\"),",
                    "    path.resolve(__dirname, \"../cli/ignore-absolute-path/depth1/ignored/*.js\"),",
                    "    path.resolve(__dirname, \"../cli/ignore-absolute-path/regular-module.js\"),",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});"
                ]
            },
            "ignore-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"ignore path\", () => {",
                    "  runPrettier(\"cli/ignore-path\", [",
                    "    \"**/*.js\",",
                    "    \"--ignore-path\",",
                    "    \".gitignore\",",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"support .prettierignore\", () => {",
                    "  runPrettier(\"cli/ignore-path\", [\"**/*.js\", \"-l\"]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"ignore file when using --debug-check\", () => {",
                    "  runPrettier(\"cli/ignore-path\", [\"**/*.js\", \"--debug-check\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"outputs files as-is if no --write\", () => {",
                    "  runPrettier(\"cli/ignore-path\", [\"regular-module.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "ignore-relative-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"support relative paths\", () => {",
                    "  runPrettier(\"cli/ignore-relative-path\", [",
                    "    \"./shouldNotBeIgnored.js\",",
                    "    \"./level1/level2/level3/shouldNotBeFormat.js\",",
                    "    \"level1-glob/level2-glob/level3-glob/shouldNotBeFormat.js\",",
                    "    \"./level1-glob/level2-glob/level3-glob/shouldNotBeIgnored.scss\",",
                    "    \"level1-glob/shouldNotBeIgnored.js\",",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});"
                ]
            },
            "invalid-ignore.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"throw error with invalid ignore\", () => {",
                    "  runPrettier(\"cli/invalid-ignore\", [\"something.js\"]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});"
                ]
            },
            "list-different.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"checks stdin with --list-different\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--list-different\"], {",
                    "    input: \"0\"",
                    "  }).test({",
                    "    stdout: \"(stdin)\\n\",",
                    "    stderr: \"\",",
                    "    status: \"non-zero\"",
                    "  });",
                    "});"
                ]
            },
            "loglevel.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "test(\"do not show logs with --loglevel silent\", () => {",
                    "  runPrettierWithLogLevel(\"silent\", null);",
                    "});",
                    "",
                    "test(\"do not show warnings with --loglevel error\", () => {",
                    "  runPrettierWithLogLevel(\"error\", [\"[error]\"]);",
                    "});",
                    "",
                    "test(\"show errors and warnings with --loglevel warn\", () => {",
                    "  runPrettierWithLogLevel(\"warn\", [\"[error]\", \"[warn]\"]);",
                    "});",
                    "",
                    "test(\"show all logs with --loglevel debug\", () => {",
                    "  runPrettierWithLogLevel(\"debug\", [\"[error]\", \"[warn]\", \"[debug]\"]);",
                    "});",
                    "",
                    "describe(\"--write with --loglevel=silent doesn't log filenames\", () => {",
                    "  runPrettier(\"cli/write\", [",
                    "    \"--write\",",
                    "    \"unformatted.js\",",
                    "    \"--loglevel=silent\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "function runPrettierWithLogLevel(logLevel, patterns) {",
                    "  const result = runPrettier(\"cli/loglevel\", [",
                    "    \"--loglevel\",",
                    "    logLevel,",
                    "    \"--unknown-option\",",
                    "    \"--parser\",",
                    "    \"unknown-parser\",",
                    "    \"not-found.js\"",
                    "  ]);",
                    "",
                    "  expect(result).not.toEqual(0);",
                    "",
                    "  if (patterns) {",
                    "    patterns.forEach(pattern => {",
                    "      expect(result.stderr).toMatch(pattern);",
                    "    });",
                    "  } else {",
                    "    expect(result.stderr).toMatch(/^\\s*$/);",
                    "  }",
                    "}"
                ]
            },
            "multiple-patterns.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"multiple patterns\", () => {",
                    "  runPrettier(\"cli/multiple-patterns\", [",
                    "    \"directory/**/*.js\",",
                    "    \"other-directory/**/*.js\",",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns with non exists pattern\", () => {",
                    "  runPrettier(\"cli/multiple-patterns\", [",
                    "    \"directory/**/*.js\",",
                    "    \"non-existent.js\",",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns with ignore nested directories pattern\", () => {",
                    "  runPrettier(\"cli/multiple-patterns\", [",
                    "    \"**/*.js\",",
                    "    \"!**/nested-directory/**\",",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns by with ignore pattern, ignores node_modules by default\", () => {",
                    "  runPrettier(\"cli/multiple-patterns\", [\"**/*.js\", \"!directory/**\", \"-l\"]).test(",
                    "    {",
                    "      status: 1",
                    "    }",
                    "  );",
                    "});",
                    "",
                    "describe(\"multiple patterns by with ignore pattern, ignores node_modules by with ./**/*.js\", () => {",
                    "  runPrettier(\"cli/multiple-patterns\", [",
                    "    \"./**/*.js\",",
                    "    \"!./directory/**\",",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns by with ignore pattern, doesn't ignore node_modules with --with-node-modules flag\", () => {",
                    "  runPrettier(\"cli/multiple-patterns\", [",
                    "    \"**/*.js\",",
                    "    \"!directory/**\",",
                    "    \"-l\",",
                    "    \"--with-node-modules\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"no errors on empty patterns\", () => {",
                    "  runPrettier(\"cli/multiple-patterns\").test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns, throw error and exit with non zero code on non existing files\", () => {",
                    "  runPrettier(\"cli/multiple-patterns\", [",
                    "    \"non-existent.js\",",
                    "    \"other-non-existent.js\",",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 2",
                    "  });",
                    "});"
                ]
            },
            "parser-api.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"../../tests_config/require_prettier\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "test(\"allows custom parser provided as object\", () => {",
                    "  const output = prettier.format(\"1\", {",
                    "    parser(text) {",
                    "      expect(text).toEqual(\"1\");",
                    "      return {",
                    "        type: \"Literal\",",
                    "        value: 2,",
                    "        raw: \"2\"",
                    "      };",
                    "    }",
                    "  });",
                    "  expect(output).toEqual(\"2\");",
                    "});",
                    "",
                    "test(\"allows usage of prettier's supported parsers\", () => {",
                    "  const output = prettier.format(\"foo ( )\", {",
                    "    parser(text, parsers) {",
                    "      expect(typeof parsers.babylon).toEqual(\"function\");",
                    "      const ast = parsers.babylon(text);",
                    "      ast.program.body[0].expression.callee.name = \"bar\";",
                    "      return ast;",
                    "    }",
                    "  });",
                    "  expect(output).toEqual(\"bar();\\n\");",
                    "});",
                    "",
                    "describe(\"allows passing a string to resolve a parser\", () => {",
                    "  runPrettier(\"./custom-parsers/\", [",
                    "    \"./custom-rename-input.js\",",
                    "    \"--parser\",",
                    "    \"./custom-rename-parser\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "piped-output.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"output with --list-different + unformatted differs when piped\", () => {",
                    "  const result0 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--list-different\", \"--no-color\", \"unformatted.js\"],",
                    "    { stdoutIsTTY: true }",
                    "  ).test({",
                    "    status: 1",
                    "  });",
                    "",
                    "  const result1 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--list-different\", \"--no-color\", \"unformatted.js\"],",
                    "    { stdoutIsTTY: false }",
                    "  ).test({",
                    "    status: 1",
                    "  });",
                    "",
                    "  expect(result0.stdout.length).toBeGreaterThan(result1.stdout.length);",
                    "  expect(result0.write).toEqual(result1.write);",
                    "});",
                    "",
                    "describe(\"no file diffs with --list-different + formatted file\", () => {",
                    "  const result0 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--list-different\", \"--no-color\", \"formatted.js\"],",
                    "    { stdoutIsTTY: true }",
                    "  ).test({",
                    "    status: 0",
                    "  });",
                    "",
                    "  const result1 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--list-different\", \"--no-color\", \"formatted.js\"],",
                    "    { stdoutIsTTY: false }",
                    "  ).test({",
                    "    status: 0",
                    "  });",
                    "",
                    "  expect(result0.stdout).not.toEqual(result1.stdout);",
                    "  expect(result0.stdout.length).toBeGreaterThan(result1.stdout.length);",
                    "  expect(result0.write).toEqual(result1.write);",
                    "});"
                ]
            },
            "plugin-default-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"plugin default options should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/defaultOptions\",",
                    "    [\"--stdin-filepath\", \"example.foo\", \"--plugin=./plugin\"],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: \"tabWidth:8\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: []",
                    "  });",
                    "});",
                    "",
                    "describe(\"overriding plugin default options should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/defaultOptions\",",
                    "    [\"--stdin-filepath\", \"example.foo\", \"--plugin=./plugin\", \"--tab-width=4\"],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: \"tabWidth:4\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: []",
                    "  });",
                    "});"
                ]
            },
            "plugin-extensions.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const EOL = require(\"os\").EOL;",
                    "",
                    "describe(\"uses 'extensions' from languages to determine parser\", () => {",
                    "  runPrettier(\"plugins/extensions\", [\"*.foo\", \"--plugin=./plugin\"]).test({",
                    "    stdout: \"!contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: []",
                    "  });",
                    "});"
                ]
            },
            "plugin-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const snapshotDiff = require(\"snapshot-diff\");",
                    "",
                    "describe(\"show external options with `--help`\", () => {",
                    "  const originalStdout = runPrettier(\"plugins/options\", [\"--help\"]).stdout;",
                    "  const pluggedStdout = runPrettier(\"plugins/options\", [",
                    "    \"--help\",",
                    "    \"--plugin=./plugin\"",
                    "  ]).stdout;",
                    "  expect(snapshotDiff(originalStdout, pluggedStdout)).toMatchSnapshot();",
                    "});",
                    "",
                    "describe(\"show detailed external option with `--help foo-option`\", () => {",
                    "  runPrettier(\"plugins/options\", [",
                    "    \"--plugin=./plugin\",",
                    "    \"--help\",",
                    "    \"foo-option\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"external options from CLI should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/options\",",
                    "    [",
                    "      \"--plugin=./plugin\",",
                    "      \"--stdin-filepath\",",
                    "      \"example.foo\",",
                    "      \"--foo-option\",",
                    "      \"baz\"",
                    "    ],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: \"foo:baz\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: []",
                    "  });",
                    "});",
                    "",
                    "describe(\"external options from config file should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/options\",",
                    "    [\"--config=./config.json\", \"--stdin-filepath\", \"example.foo\"],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: \"foo:baz\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: []",
                    "  });",
                    "});"
                ]
            },
            "plugin-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const EOL = require(\"os\").EOL;",
                    "",
                    "describe(\"parser preprocess function is used to reshape input text\", () => {",
                    "  runPrettier(\"plugins/preprocess\", [\"*.foo\", \"--plugin=./plugin\"]).test({",
                    "    stdout: \"preprocessed:contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: []",
                    "  });",
                    "});"
                ]
            },
            "plugin-resolution.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const EOL = require(\"os\").EOL;",
                    "",
                    "describe(\"automatically loads 'prettier-plugin-*' from package.json devDependencies\", () => {",
                    "  runPrettier(\"plugins/automatic\", [\"file.txt\", \"--parser=foo\"]).test({",
                    "    stdout: \"foo+contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: []",
                    "  });",
                    "});",
                    "",
                    "describe(\"automatically loads '@prettier/plugin-*' from package.json dependencies\", () => {",
                    "  runPrettier(\"plugins/automatic\", [\"file.txt\", \"--parser=bar\"]).test({",
                    "    stdout: \"bar+contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: []",
                    "  });",
                    "});"
                ]
            },
            "skip-folders.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"skips folders in glob\", () => {",
                    "  runPrettier(\"cli/skip-folders\", [\"**/*\", \"-l\"]).test({",
                    "    status: 1,",
                    "    stderr: \"\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"skip folders passed specifically\", () => {",
                    "  runPrettier(\"cli/skip-folders\", [",
                    "    \"a\",",
                    "    \"a/file.js\",",
                    "    \"b\",",
                    "    \"b/file.js\",",
                    "    \"-l\"",
                    "  ]).test({ status: 1, stderr: \"\" });",
                    "});"
                ]
            },
            "stdin-filepath.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"format correctly if stdin content compatible with stdin-filepath\", () => {",
                    "  runPrettier(",
                    "    \"cli\",",
                    "    [\"--stdin-filepath\", \"abc.css\"],",
                    "    { input: \".name { display: none; }\" } // css",
                    "  ).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error if stdin content incompatible with stdin-filepath\", () => {",
                    "  runPrettier(",
                    "    \"cli\",",
                    "    [\"--stdin-filepath\", \"abc.js\"],",
                    "    { input: \".name { display: none; }\" } // css",
                    "  ).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"output file as-is if stdin-filepath matched patterns in ignore-path\", () => {",
                    "  runPrettier(\"cli/stdin-ignore\", [\"--stdin-filepath\", \"ignore/example.js\"], {",
                    "    input: \"hello_world( );\"",
                    "  }).test({",
                    "    stdout: \"hello_world( );\",",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "support-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"../../tests_config/require_prettier\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const snapshotDiff = require(\"snapshot-diff\");",
                    "",
                    "describe(\"API getSupportInfo()\", () => {",
                    "  const testVersions = [",
                    "    \"0.0.0\",",
                    "    \"1.0.0\",",
                    "    \"1.4.0\",",
                    "    \"1.5.0\",",
                    "    \"1.7.1\",",
                    "    \"1.8.0\",",
                    "    \"1.8.2\",",
                    "    undefined",
                    "  ];",
                    "",
                    "  testVersions.forEach((version, index) => {",
                    "    const info = getCoreInfo(version);",
                    "    if (index === 0) {",
                    "      test(`with version ${version}`, () => {",
                    "        expect(info).toMatchSnapshot();",
                    "      });",
                    "    } else {",
                    "      const previousVersion = testVersions[index - 1];",
                    "      const previousInfo = getCoreInfo(previousVersion);",
                    "      test(`with version ${previousVersion} -> ${version}`, () => {",
                    "        expect(snapshotDiff(previousInfo, info)).toMatchSnapshot();",
                    "      });",
                    "    }",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI --support-info\", () => {",
                    "  runPrettier(\"cli\", \"--support-info\").test({ status: 0 });",
                    "});",
                    "",
                    "function getCoreInfo(version) {",
                    "  const supportInfo = prettier.getSupportInfo(version);",
                    "  const languages = supportInfo.languages.reduce(",
                    "    (obj, language) =>",
                    "      Object.assign({ [language.name]: language.parsers }, obj),",
                    "    {}",
                    "  );",
                    "  const options = supportInfo.options.reduce(",
                    "    (obj, option) =>",
                    "      Object.assign(",
                    "        {",
                    "          [option.name]: Object.assign(",
                    "            {",
                    "              type: option.type,",
                    "              default: option.default",
                    "            },",
                    "            option.type === \"int\"",
                    "              ? { range: option.range }",
                    "              : option.type === \"choice\"",
                    "                ? { choices: option.choices.map(choice => choice.value) }",
                    "                : null",
                    "          )",
                    "        },",
                    "        obj",
                    "      ),",
                    "    {}",
                    "  );",
                    "  return { languages, options };",
                    "}"
                ]
            },
            "syntax-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"exits with non-zero code when input has a syntax error\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--stdin\"], {",
                    "    input: \"a.2\"",
                    "  }).test({",
                    "    status: 2",
                    "  });",
                    "});"
                ]
            },
            "util-shared.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const sharedUtil = require(\"../../src/common/util-shared\");",
                    "",
                    "test(\"shared util has correct structure\", () => {",
                    "  expect(typeof sharedUtil.isNextLineEmpty).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.isNextLineEmptyAfterIndex).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.getNextNonSpaceNonCommentCharacterIndex).toEqual(",
                    "    \"function\"",
                    "  );",
                    "  expect(typeof sharedUtil.mapDoc).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.makeString).toEqual(\"function\");",
                    "});"
                ]
            },
            "with-config-precedence.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"CLI overrides take precedence without --config-precedence\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--print-width\", \"1\", \"**/*.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides take precedence with --config-precedence cli-override\", () => {",
                    "  runPrettier(\"cli/config/\", [",
                    "    \"--print-width\",",
                    "    \"1\",",
                    "    \"--config-precedence\",",
                    "    \"cli-override\",",
                    "    \"**/*.js\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides take lower precedence with --config-precedence file-override\", () => {",
                    "  runPrettier(\"cli/config/js/\", [",
                    "    \"--tab-width\",",
                    "    \"1\",",
                    "    \"--config-precedence\",",
                    "    \"file-override\",",
                    "    \"**/*.js\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides are still applied when no config is found with --config-precedence file-override\", () => {",
                    "  runPrettier(\"cli/config/no-config/\", [",
                    "    \"--tab-width\",",
                    "    \"6\",",
                    "    \"--config-precedence\",",
                    "    \"file-override\",",
                    "    \"**/*.js\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides gets ignored when config exists with --config-precedence prefer-file\", () => {",
                    "  runPrettier(\"cli/config/js/\", [",
                    "    \"--print-width\",",
                    "    \"1\",",
                    "    \"--tab-width\",",
                    "    \"1\",",
                    "    \"--config-precedence\",",
                    "    \"prefer-file\",",
                    "    \"**/*.js\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides gets applied when no config exists with --config-precedence prefer-file\", () => {",
                    "  runPrettier(\"cli/config/no-config/\", [",
                    "    \"--print-width\",",
                    "    \"1\",",
                    "    \"--tab-width\",",
                    "    \"7\",",
                    "    \"--no-config\",",
                    "    \"--config-precedence\",",
                    "    \"prefer-file\",",
                    "    \"**/*.js\"",
                    "  ]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI validate options with --config-precedence cli-override\", () => {",
                    "  runPrettier(\"cli/config-precedence\", [",
                    "    \"--config-precedence\",",
                    "    \"cli-override\"",
                    "  ]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI validate options with --config-precedence file-override\", () => {",
                    "  runPrettier(\"cli/config-precedence\", [",
                    "    \"--config-precedence\",",
                    "    \"file-override\"",
                    "  ]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI validate options with --config-precedence prefer-file\", () => {",
                    "  runPrettier(\"cli/config-precedence\", [",
                    "    \"--config-precedence\",",
                    "    \"prefer-file\"",
                    "  ]).test({",
                    "    status: \"non-zero\"",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI --stdin-filepath works with --config-precedence prefer-file\", () => {",
                    "  runPrettier(",
                    "    \"cli/config/\",",
                    "    [",
                    "      \"--stdin\",",
                    "      \"--stdin-filepath=abc.ts\",",
                    "      \"--no-semi\",",
                    "      \"--config-precedence=prefer-file\"",
                    "    ],",
                    "    { input: \"let x: keyof Y = foo<typeof X>()\" } // typescript",
                    "  ).test({",
                    "    stderr: \"\",",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI --stdin-filepath works with --config-precedence file-override\", () => {",
                    "  runPrettier(",
                    "    \"cli/config/\",",
                    "    [",
                    "      \"--stdin\",",
                    "      \"--stdin-filepath=abc.ts\",",
                    "      \"--no-semi\",",
                    "      \"--config-precedence=file-override\"",
                    "    ],",
                    "    { input: \"let x: keyof Y = foo<typeof X>()\" } // typescript",
                    "  ).test({",
                    "    stderr: \"\",",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI --stdin-filepath works with --config-precedence cli-override\", () => {",
                    "  runPrettier(",
                    "    \"cli/config/\",",
                    "    [",
                    "      \"--stdin\",",
                    "      \"--stdin-filepath=abc.ts\",",
                    "      \"--no-semi\",",
                    "      \"--config-precedence=cli-override\"",
                    "    ],",
                    "    { input: \"let x: keyof Y = foo<typeof X>()\" } // typescript",
                    "  ).test({",
                    "    stderr: \"\",",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "with-node-modules.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"ignores node_modules by default\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [\"**/*.js\", \"-l\"]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"ignores node_modules by with ./**/*.js\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [\"./**/*.js\", \"-l\"]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"doesn't ignore node_modules with --with-node-modules flag\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [",
                    "    \"**/*.js\",",
                    "    \"-l\",",
                    "    \"--with-node-modules\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"ignores node_modules by default for file list\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [",
                    "    \"node_modules/node-module.js\",",
                    "    \"not_node_modules/file.js\",",
                    "    \"regular-module.js\",",
                    "    \"-l\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});",
                    "",
                    "describe(\"doesn't ignore node_modules with --with-node-modules flag for file list\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [",
                    "    \"node_modules/node-module.js\",",
                    "    \"not_node_modules/file.js\",",
                    "    \"regular-module.js\",",
                    "    \"-l\",",
                    "    \"--with-node-modules\"",
                    "  ]).test({",
                    "    status: 1",
                    "  });",
                    "});"
                ]
            },
            "with-parser-inference.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const prettier = require(\"../../tests_config/require_prettier\");",
                    "",
                    "describe(\"infers postcss parser\", () => {",
                    "  runPrettier(\"cli/with-parser-inference\", [\"*\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"infers postcss parser with --list-different\", () => {",
                    "  runPrettier(\"cli/with-parser-inference\", [\"--list-different\", \"*\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"infers parser from filename\", () => {",
                    "  test(\"json from .prettierrc\", () => {",
                    "    expect(",
                    "      prettier.format(\"  {   }  \", { filepath: \"x/y/.prettierrc\" })",
                    "    ).toEqual(\"{}\\n\");",
                    "  });",
                    "",
                    "  test(\"babylon from Jakefile\", () => {",
                    "    expect(",
                    "      prettier.format(\"let foo = ( x = 1 ) => x\", { filepath: \"x/y/Jakefile\" })",
                    "    ).toEqual(\"let foo = (x = 1) => x;\\n\");",
                    "  });",
                    "});"
                ]
            },
            "with-shebang.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"preserves shebang\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"issue1890.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});"
                ]
            },
            "write.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"write file with --write + unformatted file\", () => {",
                    "  runPrettier(\"cli/write\", [\"--write\", \"unformatted.js\"]).test({",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"do not write file with --write + formatted file\", () => {",
                    "  runPrettier(\"cli/write\", [\"--write\", \"formatted.js\"]).test({",
                    "    write: [],",
                    "    status: 0",
                    "  });",
                    "});",
                    "",
                    "describe(\"do not write file with --write + invalid file\", () => {",
                    "  runPrettier(\"cli/write\", [\"--write\", \"invalid.js\"]).test({",
                    "    write: [],",
                    "    status: \"non-zero\"",
                    "  });",
                    "});"
                ]
            },
            "__snapshots__": {
                "arg-parsing.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`boolean flags do not swallow the next argument (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`boolean flags do not swallow the next argument (stdout) 1`] = `",
                        "\"console.log('could be single quote and without semi');",
                        "\"",
                        "`;",
                        "",
                        "exports[`boolean flags do not swallow the next argument (write) 1`] = `Array []`;",
                        "",
                        "exports[`deprecated option values are warned (stderr) 1`] = `",
                        "\"[warn] \\`--trailing-comma\\` without an argument is deprecated. Prettier now treats it as \\`--trailing-comma=es5\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`deprecated option values are warned (stdout) 1`] = `",
                        "\"console.log(\\\\\"could be single quote and without semi\\\\\");",
                        "\"",
                        "`;",
                        "",
                        "exports[`deprecated option values are warned (write) 1`] = `Array []`;",
                        "",
                        "exports[`deprecated options are warned (stderr) 1`] = `",
                        "\"[warn] \\`--flow-parser\\` is deprecated. Prettier now treats it as \\`--parser=flow\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`deprecated options are warned (stdout) 1`] = `",
                        "\"console.log(\\\\\"could be single quote and without semi\\\\\");",
                        "\"",
                        "`;",
                        "",
                        "exports[`deprecated options are warned (write) 1`] = `Array []`;",
                        "",
                        "exports[`negated options work (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`negated options work (stdout) 1`] = `",
                        "\"console.log(\\\\\"could be single quote and without semi\\\\\")",
                        "\"",
                        "`;",
                        "",
                        "exports[`negated options work (write) 1`] = `Array []`;",
                        "",
                        "exports[`unknown negated options are warned (stderr) 1`] = `",
                        "\"[warn] Ignored unknown option \\`--no-unknown\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown negated options are warned (stdout) 1`] = `",
                        "\"console.log(\\\\\"could be single quote and without semi\\\\\");",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown negated options are warned (write) 1`] = `Array []`;",
                        "",
                        "exports[`unknown options are warned (stderr) 1`] = `",
                        "\"[warn] Ignored unknown option \\`--unknown\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown options are warned (stdout) 1`] = `",
                        "\"console.log(\\\\\"could be single quote and without semi\\\\\");",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown options are warned (write) 1`] = `Array []`;"
                    ]
                },
                "config-invalid.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`show warning with kebab-case option key (stderr) 1`] = `",
                        "\"[warn] Ignored unknown option \\`{ \\\\\"print-width\\\\\": 3 }\\`. Did you mean \\\\\"printWidth\\\\\"?",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with kebab-case option key (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`show warning with kebab-case option key (write) 1`] = `Array []`;",
                        "",
                        "exports[`show warning with unknown option (stderr) 1`] = `",
                        "\"[warn] Ignored unknown option \\`{ \\\\\"hello\\\\\": \\\\\"world\\\\\" }\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with unknown option (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`show warning with unknown option (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config format (stderr) 1`] = `",
                        "\"[error] Invalid configuration file: Failed to parse \\\\\"<cwd>/tests_integration/cli/config/invalid/file/.prettierrc\\\\\" as JSON, JS, or YAML.",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config format (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config format (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config option (int) (stderr) 1`] = `",
                        "\"[error] Invalid \\`\\\\\"tabWidth\\\\\"\\` value. Expected an integer, but received \\`0.5\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config option (int) (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config option (int) (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config option (trailingComma) (stderr) 1`] = `",
                        "\"[error] Invalid \\`\\\\\"trailingComma\\\\\"\\` value. Expected \\\\\"all\\\\\", \\\\\"es5\\\\\" or \\\\\"none\\\\\", but received \\`\\\\\"wow\\\\\"\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config option (trailingComma) (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config option (trailingComma) (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config precedence option (configPrecedence) (stderr) 1`] = `",
                        "\"[error] Invalid \\`\\`--config-precedence\\`\\` value. Expected \\\\\"cli-override\\\\\", \\\\\"file-override\\\\\" or \\\\\"prefer-file\\\\\", but received \\`\\\\\"option/configPrecedence\\\\\"\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config precedence option (configPrecedence) (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config precedence option (configPrecedence) (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config target (directory) (stderr) 1`] = `",
                        "\"[error] Invalid configuration file: EISDIR: illegal operation on a directory, read",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config target (directory) (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config target (directory) (write) 1`] = `Array []`;"
                    ]
                },
                "config-resolution.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`CLI overrides take precedence (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides take precedence (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(",
                        "\t\t\\\\\"should have tab width 8\\\\\"",
                        "\t)",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2\\\\\"",
                        "  )",
                        "}",
                        "function f() {",
                        "        console.log(",
                        "                \\\\\"should have space width 8\\\\\"",
                        "        )",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\\\\\"",
                        "  )",
                        "}",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/Component.js should not have semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/Component.test.js should have semi\\\\\"",
                        ");",
                        "function js() {",
                        "        console.log(",
                        "                \\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\"",
                        "        );",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        tabWidth: 8",
                        "};",
                        "function noConfigJs() {",
                        "  console.log(",
                        "    \\\\\"no-config/file.js should have no semicolons\\\\\"",
                        "  )",
                        "}",
                        "function packageJs() {",
                        "   console.log(",
                        "      \\\\\"package/file.js should have tab width 3\\\\\"",
                        "   );",
                        "}",
                        "function rcJson() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-json/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcYaml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-yaml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides take precedence (write) 1`] = `Array []`;",
                        "",
                        "exports[`accepts configuration from --config (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`accepts configuration from --config (stdout) 1`] = `",
                        "\"function js() {",
                        " console.log(\\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\")",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`accepts configuration from --config (write) 1`] = `Array []`;",
                        "",
                        "exports[`prints nothing when no file found with --find-config-path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`prints nothing when no file found with --find-config-path (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves configuration file with --find-config-path file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves configuration file with --find-config-path file (stdout) 1`] = `",
                        "\".prettierrc",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves configuration file with --find-config-path file (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves configuration from external files (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves configuration from external files (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(\\\\\"should have tab width 8\\\\\")",
                        "}",
                        "function f() {",
                        "  console.log(\\\\\"should have space width 2\\\\\")",
                        "}",
                        "function f() {",
                        "        console.log(\\\\\"should have space width 8\\\\\")",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\\\\\"",
                        "  )",
                        "}",
                        "console.log(\\\\\"jest/__best-tests__/file.js should have semi\\\\\");",
                        "console.log(\\\\\"jest/Component.js should not have semi\\\\\")",
                        "console.log(\\\\\"jest/Component.test.js should have semi\\\\\");",
                        "function js() {",
                        "        console.log(\\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\");",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        tabWidth: 8",
                        "};",
                        "function noConfigJs() {",
                        "  console.log(\\\\\"no-config/file.js should have no semicolons\\\\\")",
                        "}",
                        "function packageJs() {",
                        "   console.log(\\\\\"package/file.js should have tab width 3\\\\\");",
                        "}",
                        "function rcJson() {",
                        "  console.log.apply(null, [",
                        "    'rc-json/file.js',",
                        "    'should have trailing comma',",
                        "    'and single quotes',",
                        "  ]);",
                        "}",
                        "function rcYaml() {",
                        "  console.log.apply(null, [",
                        "    'rc-yaml/file.js',",
                        "    'should have trailing comma',",
                        "    'and single quotes',",
                        "  ]);",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves configuration from external files (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves configuration from external files and overrides by extname (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves configuration from external files and overrides by extname (stdout) 1`] = `",
                        "\"function noConfigTs() {",
                        "  console.log(",
                        "    \\\\\"no-config/file.ts should have semicolons because it has a .ts extension\\\\\"",
                        "  );",
                        "}",
                        "function packageTs() {",
                        "     console.log(",
                        "          \\\\\"package/file.ts should have tab width 5 because it has .ts extension\\\\\"",
                        "     );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves configuration from external files and overrides by extname (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves json configuration file with --find-config-path file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves json configuration file with --find-config-path file (stdout) 1`] = `",
                        "\"rc-json/.prettierrc.json",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves json configuration file with --find-config-path file (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves yaml configuration file with --find-config-path file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves yaml configuration file with --find-config-path file (stdout) 1`] = `",
                        "\"rc-yaml/.prettierrc.yaml",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves yaml configuration file with --find-config-path file (write) 1`] = `Array []`;"
                    ]
                },
                "cursor-offset.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`cursorOffset should not be affected by full-width character (stdout) 1`] = `",
                        "\"const x = [",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\"",
                        "];",
                        "\"",
                        "`;",
                        "",
                        "exports[`cursorOffset should not be affected by full-width character (write) 1`] = `Array []`;",
                        "",
                        "exports[`write cursorOffset to stderr with --cursor-offset <int> (stderr) 1`] = `",
                        "\"1",
                        "\"",
                        "`;",
                        "",
                        "exports[`write cursorOffset to stderr with --cursor-offset <int> (stdout) 1`] = `",
                        "\"1;",
                        "\"",
                        "`;",
                        "",
                        "exports[`write cursorOffset to stderr with --cursor-offset <int> (write) 1`] = `Array []`;"
                    ]
                },
                "debug-check.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`checks stdin with --debug-check (write) 1`] = `Array []`;",
                        "",
                        "exports[`doesn't crash when --debug-check is passed (write) 1`] = `Array []`;",
                        "",
                        "exports[`show diff for 2+ error files with --debug-check (stderr) 1`] = `",
                        "\"[error] a.js: ast(input) !== ast(prettier(input))",
                        "[error] Index: ",
                        "[error] ===================================================================",
                        "[error] --- \t",
                        "[error] +++ \t",
                        "[error] @@ -17,6 +17,6 @@",
                        "[error]                    \\\\\"method\\\\\": false,",
                        "[error]                    \\\\\"key\\\\\": {",
                        "[error] -                    \\\\\"type\\\\\": \\\\\"StringLiteral\\\\\",",
                        "[error] -                    \\\\\"value\\\\\": \\\\\"a\\\\\"",
                        "[error] +                    \\\\\"type\\\\\": \\\\\"Identifier\\\\\",",
                        "[error] +                    \\\\\"name\\\\\": \\\\\"a\\\\\"",
                        "[error]                    },",
                        "[error]                    \\\\\"computed\\\\\": false,",
                        "[error] ",
                        "[error] Index: ",
                        "[error] ===================================================================",
                        "[error] --- \t",
                        "[error] +++ \t",
                        "[error] @@ -1,3 +1,3 @@",
                        "[error]  const a = {",
                        "[error] -    'a': 1",
                        "[error] +  a: 1",
                        "[error]  };",
                        "[error] ",
                        "[error] b.js: ast(input) !== ast(prettier(input))",
                        "[error] Index: ",
                        "[error] ===================================================================",
                        "[error] --- \t",
                        "[error] +++ \t",
                        "[error] @@ -17,6 +17,6 @@",
                        "[error]                    \\\\\"method\\\\\": false,",
                        "[error]                    \\\\\"key\\\\\": {",
                        "[error] -                    \\\\\"type\\\\\": \\\\\"StringLiteral\\\\\",",
                        "[error] -                    \\\\\"value\\\\\": \\\\\"b\\\\\"",
                        "[error] +                    \\\\\"type\\\\\": \\\\\"Identifier\\\\\",",
                        "[error] +                    \\\\\"name\\\\\": \\\\\"b\\\\\"",
                        "[error]                    },",
                        "[error]                    \\\\\"computed\\\\\": false,",
                        "[error] ",
                        "[error] Index: ",
                        "[error] ===================================================================",
                        "[error] --- \t",
                        "[error] +++ \t",
                        "[error] @@ -1,3 +1,3 @@",
                        "[error]  const b = {",
                        "[error] -    'b': 2",
                        "[error] +  b: 2",
                        "[error]  };",
                        "[error] ",
                        "\"",
                        "`;",
                        "",
                        "exports[`show diff for 2+ error files with --debug-check (stdout) 1`] = `",
                        "\"",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`show diff for 2+ error files with --debug-check (write) 1`] = `Array []`;"
                    ]
                },
                "debug-print-doc.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`prints doc with --debug-print-doc (write) 1`] = `Array []`;"
                    ]
                },
                "deprecated-parser.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`API format with deprecated parser should work 1`] = `",
                        "\"\\`{ \\\\\"parser\\\\\": \\\\\"postcss\\\\\" }\\` is deprecated. Prettier now treats it as \\`{ \\\\\"parser\\\\\": \\\\\"css\\\\\" }\\`.",
                        "\"",
                        "`;"
                    ]
                },
                "early-exit.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`show detailed usage with --help arrow-parens (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help arrow-parens (stdout) 1`] = `",
                        "\"--arrow-parens <avoid|always>",
                        "",
                        "  Include parentheses around a sole arrow function parameter.",
                        "",
                        "Valid options:",
                        "",
                        "  avoid    Omit parens when possible. Example: \\`x => x\\`",
                        "  always   Always include parens. Example: \\`(x) => x\\`",
                        "",
                        "Default: avoid",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help arrow-parens (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help bracket-spacing (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help bracket-spacing (stdout) 1`] = `",
                        "\"--bracket-spacing",
                        "",
                        "  Print spaces between brackets.",
                        "",
                        "Default: true",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help bracket-spacing (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help color (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help color (stdout) 1`] = `",
                        "\"--color",
                        "",
                        "  Colorize error messages.",
                        "",
                        "Default: true",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help color (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help config (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help config (stdout) 1`] = `",
                        "\"--config <path>",
                        "",
                        "  Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help config (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help config-precedence (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help config-precedence (stdout) 1`] = `",
                        "\"--config-precedence <cli-override|file-override|prefer-file>",
                        "",
                        "  Define in which order config files and CLI options should be evaluated.",
                        "",
                        "Valid options:",
                        "",
                        "  cli-override    CLI options take precedence over config file",
                        "  file-override   Config file take precedence over CLI options",
                        "  prefer-file     If a config file is found will evaluate it and ignore other CLI options.",
                        "                  If no config file is found CLI options will evaluate as normal.",
                        "",
                        "Default: cli-override",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help config-precedence (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help cursor-offset (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help cursor-offset (stdout) 1`] = `",
                        "\"--cursor-offset <int>",
                        "",
                        "  Print (to stderr) where a cursor at the given position would move to after formatting.",
                        "  This option cannot be used with --range-start and --range-end.",
                        "",
                        "Default: -1",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help cursor-offset (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help editorconfig (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help editorconfig (stdout) 1`] = `",
                        "\"--editorconfig",
                        "",
                        "  Take .editorconfig into account when parsing configuration.",
                        "",
                        "Default: true",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help editorconfig (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help find-config-path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help find-config-path (stdout) 1`] = `",
                        "\"--find-config-path <path>",
                        "",
                        "  Find and print the path to a configuration file for the given input file.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help find-config-path (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help help (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help help (stdout) 1`] = `",
                        "\"-h, --help <flag>",
                        "",
                        "  Show CLI usage, or details about the given flag.",
                        "  Example: --help write",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help help (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help ignore-path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help ignore-path (stdout) 1`] = `",
                        "\"--ignore-path <path>",
                        "",
                        "  Path to a file with patterns describing files to ignore.",
                        "",
                        "Default: .prettierignore",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help ignore-path (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help insert-pragma (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help insert-pragma (stdout) 1`] = `",
                        "\"--insert-pragma",
                        "",
                        "  Insert @format pragma into file's first docblock comment.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help insert-pragma (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help jsx-bracket-same-line (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help jsx-bracket-same-line (stdout) 1`] = `",
                        "\"--jsx-bracket-same-line",
                        "",
                        "  Put > on the last line instead of at a new line.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help jsx-bracket-same-line (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help l (alias) (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help l (alias) (stdout) 1`] = `",
                        "\"-l, --list-different",
                        "",
                        "  Print the names of files that are different from Prettier's formatting.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help l (alias) (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help list-different (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help list-different (stdout) 1`] = `",
                        "\"-l, --list-different",
                        "",
                        "  Print the names of files that are different from Prettier's formatting.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help list-different (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help loglevel (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help loglevel (stdout) 1`] = `",
                        "\"--loglevel <silent|error|warn|log|debug>",
                        "",
                        "  What level of logs to report.",
                        "",
                        "Valid options:",
                        "",
                        "  silent   ",
                        "  error    ",
                        "  warn     ",
                        "  log      ",
                        "  debug    ",
                        "",
                        "Default: log",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help loglevel (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-bracket-spacing (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-bracket-spacing (stdout) 1`] = `",
                        "\"--no-bracket-spacing",
                        "",
                        "  Do not print spaces between brackets.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-bracket-spacing (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-color (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-color (stdout) 1`] = `",
                        "\"--no-color",
                        "",
                        "  Do not colorize error messages.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-color (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-config (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-config (stdout) 1`] = `",
                        "\"--no-config",
                        "",
                        "  Do not look for a configuration file.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-config (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-editorconfig (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-editorconfig (stdout) 1`] = `",
                        "\"--no-editorconfig",
                        "",
                        "  Don't take .editorconfig into account when parsing configuration.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-editorconfig (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-semi (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-semi (stdout) 1`] = `",
                        "\"--no-semi",
                        "",
                        "  Do not print semicolons, except at the beginning of lines which may need them.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-semi (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help parser (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help parser (stdout) 1`] = `",
                        "\"--parser <flow|babylon|typescript|css|less|scss|json|graphql|markdown|vue>",
                        "",
                        "  Which parser to use.",
                        "",
                        "Valid options:",
                        "",
                        "  flow         Flow",
                        "  babylon      JavaScript",
                        "  typescript   TypeScript",
                        "  css          CSS",
                        "  less         Less",
                        "  scss         SCSS",
                        "  json         JSON",
                        "  graphql      GraphQL",
                        "  markdown     Markdown",
                        "  vue          Vue",
                        "",
                        "Default: babylon",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help parser (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help plugin (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help plugin (stdout) 1`] = `",
                        "\"--plugin <path>",
                        "",
                        "  Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.",
                        "",
                        "Default: []",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help plugin (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help print-width (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help print-width (stdout) 1`] = `",
                        "\"--print-width <int>",
                        "",
                        "  The line length where Prettier will try wrap.",
                        "",
                        "Default: 80",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help print-width (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help prose-wrap (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help prose-wrap (stdout) 1`] = `",
                        "\"--prose-wrap <always|never|preserve>",
                        "",
                        "  How to wrap prose. (markdown)",
                        "",
                        "Valid options:",
                        "",
                        "  always     Wrap prose if it exceeds the print width.",
                        "  never      Do not wrap prose.",
                        "  preserve   Wrap prose as-is.",
                        "",
                        "Default: preserve",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help prose-wrap (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help range-end (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help range-end (stdout) 1`] = `",
                        "\"--range-end <int>",
                        "",
                        "  Format code ending at a given character offset (exclusive).",
                        "  The range will extend forwards to the end of the selected statement.",
                        "  This option cannot be used with --cursor-offset.",
                        "",
                        "Default: Infinity",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help range-end (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help range-start (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help range-start (stdout) 1`] = `",
                        "\"--range-start <int>",
                        "",
                        "  Format code starting at a given character offset.",
                        "  The range will extend backwards to the start of the first line containing the selected statement.",
                        "  This option cannot be used with --cursor-offset.",
                        "",
                        "Default: 0",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help range-start (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help require-pragma (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help require-pragma (stdout) 1`] = `",
                        "\"--require-pragma",
                        "",
                        "  Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                        "  in order for it to be formatted.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help require-pragma (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help semi (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help semi (stdout) 1`] = `",
                        "\"--semi",
                        "",
                        "  Print semicolons.",
                        "",
                        "Default: true",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help semi (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help single-quote (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help single-quote (stdout) 1`] = `",
                        "\"--single-quote",
                        "",
                        "  Use single quotes instead of double quotes.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help single-quote (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help stdin (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help stdin (stdout) 1`] = `",
                        "\"--stdin",
                        "",
                        "  Force reading input from stdin.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help stdin (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help stdin-filepath (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help stdin-filepath (stdout) 1`] = `",
                        "\"--stdin-filepath <path>",
                        "",
                        "  Path to the file to pretend that stdin comes from.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help stdin-filepath (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help support-info (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help support-info (stdout) 1`] = `",
                        "\"--support-info",
                        "",
                        "  Print support information as JSON.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help support-info (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help tab-width (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help tab-width (stdout) 1`] = `",
                        "\"--tab-width <int>",
                        "",
                        "  Number of spaces per indentation level.",
                        "",
                        "Default: 2",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help tab-width (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help trailing-comma (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help trailing-comma (stdout) 1`] = `",
                        "\"--trailing-comma <none|es5|all>",
                        "",
                        "  Print trailing commas wherever possible when multi-line.",
                        "",
                        "Valid options:",
                        "",
                        "  none   No trailing commas.",
                        "  es5    Trailing commas where valid in ES5 (objects, arrays, etc.)",
                        "  all    Trailing commas wherever possible (including function arguments).",
                        "",
                        "Default: none",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help trailing-comma (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help use-tabs (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help use-tabs (stdout) 1`] = `",
                        "\"--use-tabs",
                        "",
                        "  Indent with tabs instead of spaces.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help use-tabs (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help version (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help version (stdout) 1`] = `",
                        "\"-v, --version",
                        "",
                        "  Print Prettier version.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help version (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help with-node-modules (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help with-node-modules (stdout) 1`] = `",
                        "\"--with-node-modules",
                        "",
                        "  Process files inside 'node_modules' directory.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help with-node-modules (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help write (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help write (stdout) 1`] = `",
                        "\"--write",
                        "",
                        "  Edit files in-place. (Beware!)",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help write (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with plugin options (automatic resolution) (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with plugin options (automatic resolution) (stdout) 1`] = `",
                        "\"--tab-width <int>",
                        "",
                        "  Number of spaces per indentation level.",
                        "",
                        "Default: 2",
                        "Plugin defaults:",
                        "* prettier-plugin-bar: 4",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with plugin options (automatic resolution) (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with plugin options (manual resolution) (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with plugin options (manual resolution) (stdout) 1`] = `",
                        "\"--tab-width <int>",
                        "",
                        "  Number of spaces per indentation level.",
                        "",
                        "Default: 2",
                        "Plugin defaults:",
                        "* ../plugins/automatic/node_modules/prettier-plugin-bar: 4",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with plugin options (manual resolution) (write) 1`] = `Array []`;",
                        "",
                        "exports[`show usage with --help (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show usage with --help (stdout) 1`] = `",
                        "\"Usage: prettier [options] [file/glob ...]",
                        "",
                        "By default, output is written to stdout.",
                        "Stdin is read if it is piped to Prettier and no files are given.",
                        "",
                        "Output options:",
                        "",
                        "  -l, --list-different     Print the names of files that are different from Prettier's formatting.",
                        "  --write                  Edit files in-place. (Beware!)",
                        "",
                        "Format options:",
                        "",
                        "  --arrow-parens <avoid|always>",
                        "                           Include parentheses around a sole arrow function parameter.",
                        "                           Defaults to avoid.",
                        "  --no-bracket-spacing     Do not print spaces between brackets.",
                        "  --jsx-bracket-same-line  Put > on the last line instead of at a new line.",
                        "                           Defaults to false.",
                        "  --parser <flow|babylon|typescript|css|less|scss|json|graphql|markdown|vue>",
                        "                           Which parser to use.",
                        "                           Defaults to babylon.",
                        "  --print-width <int>      The line length where Prettier will try wrap.",
                        "                           Defaults to 80.",
                        "  --prose-wrap <always|never|preserve>",
                        "                           How to wrap prose. (markdown)",
                        "                           Defaults to preserve.",
                        "  --no-semi                Do not print semicolons, except at the beginning of lines which may need them.",
                        "  --single-quote           Use single quotes instead of double quotes.",
                        "                           Defaults to false.",
                        "  --tab-width <int>        Number of spaces per indentation level.",
                        "                           Defaults to 2.",
                        "  --trailing-comma <none|es5|all>",
                        "                           Print trailing commas wherever possible when multi-line.",
                        "                           Defaults to none.",
                        "  --use-tabs               Indent with tabs instead of spaces.",
                        "                           Defaults to false.",
                        "",
                        "Config options:",
                        "",
                        "  --config <path>          Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).",
                        "  --no-config              Do not look for a configuration file.",
                        "  --config-precedence <cli-override|file-override|prefer-file>",
                        "                           Define in which order config files and CLI options should be evaluated.",
                        "                           Defaults to cli-override.",
                        "  --no-editorconfig        Don't take .editorconfig into account when parsing configuration.",
                        "  --find-config-path <path>",
                        "                           Find and print the path to a configuration file for the given input file.",
                        "  --ignore-path <path>     Path to a file with patterns describing files to ignore.",
                        "                           Defaults to .prettierignore.",
                        "  --plugin <path>          Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.",
                        "                           Defaults to [].",
                        "  --with-node-modules      Process files inside 'node_modules' directory.",
                        "",
                        "Editor options:",
                        "",
                        "  --cursor-offset <int>    Print (to stderr) where a cursor at the given position would move to after formatting.",
                        "                           This option cannot be used with --range-start and --range-end.",
                        "                           Defaults to -1.",
                        "  --range-end <int>        Format code ending at a given character offset (exclusive).",
                        "                           The range will extend forwards to the end of the selected statement.",
                        "                           This option cannot be used with --cursor-offset.",
                        "                           Defaults to Infinity.",
                        "  --range-start <int>      Format code starting at a given character offset.",
                        "                           The range will extend backwards to the start of the first line containing the selected statement.",
                        "                           This option cannot be used with --cursor-offset.",
                        "                           Defaults to 0.",
                        "",
                        "Other options:",
                        "",
                        "  --no-color               Do not colorize error messages.",
                        "  -h, --help <flag>        Show CLI usage, or details about the given flag.",
                        "                           Example: --help write",
                        "  --insert-pragma          Insert @format pragma into file's first docblock comment.",
                        "                           Defaults to false.",
                        "  --loglevel <silent|error|warn|log|debug>",
                        "                           What level of logs to report.",
                        "                           Defaults to log.",
                        "  --require-pragma         Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                        "                           in order for it to be formatted.",
                        "                           Defaults to false.",
                        "  --stdin                  Force reading input from stdin.",
                        "  --stdin-filepath <path>  Path to the file to pretend that stdin comes from.",
                        "  --support-info           Print support information as JSON.",
                        "  -v, --version            Print Prettier version.",
                        "",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`show usage with --help (write) 1`] = `Array []`;",
                        "",
                        "exports[`show version with --version (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show version with --version (write) 1`] = `Array []`;",
                        "",
                        "exports[`show warning with --help not-found (stderr) 1`] = `",
                        "\"[warn] Unknown option name \\\\\"not-found\\\\\"",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with --help not-found (stdout) 1`] = `",
                        "\"-h, --help <flag>",
                        "",
                        "  Show CLI usage, or details about the given flag.",
                        "  Example: --help write",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with --help not-found (typo) (stderr) 1`] = `",
                        "\"[warn] Unknown option name \\\\\"parserr\\\\\", did you mean \\\\\"parser\\\\\"?",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with --help not-found (typo) (stdout) 1`] = `",
                        "\"--parser <flow|babylon|typescript|css|less|scss|json|graphql|markdown|vue>",
                        "",
                        "  Which parser to use.",
                        "",
                        "Valid options:",
                        "",
                        "  flow         Flow",
                        "  babylon      JavaScript",
                        "  typescript   TypeScript",
                        "  css          CSS",
                        "  less         Less",
                        "  scss         SCSS",
                        "  json         JSON",
                        "  graphql      GraphQL",
                        "  markdown     Markdown",
                        "  vue          Vue",
                        "",
                        "Default: babylon",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with --help not-found (typo) (write) 1`] = `Array []`;",
                        "",
                        "exports[`show warning with --help not-found (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error and show usage with something unexpected (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error and show usage with something unexpected (stdout) 1`] = `",
                        "\"Usage: prettier [options] [file/glob ...]",
                        "",
                        "By default, output is written to stdout.",
                        "Stdin is read if it is piped to Prettier and no files are given.",
                        "",
                        "Output options:",
                        "",
                        "  -l, --list-different     Print the names of files that are different from Prettier's formatting.",
                        "  --write                  Edit files in-place. (Beware!)",
                        "",
                        "Format options:",
                        "",
                        "  --arrow-parens <avoid|always>",
                        "                           Include parentheses around a sole arrow function parameter.",
                        "                           Defaults to avoid.",
                        "  --no-bracket-spacing     Do not print spaces between brackets.",
                        "  --jsx-bracket-same-line  Put > on the last line instead of at a new line.",
                        "                           Defaults to false.",
                        "  --parser <flow|babylon|typescript|css|less|scss|json|graphql|markdown|vue>",
                        "                           Which parser to use.",
                        "                           Defaults to babylon.",
                        "  --print-width <int>      The line length where Prettier will try wrap.",
                        "                           Defaults to 80.",
                        "  --prose-wrap <always|never|preserve>",
                        "                           How to wrap prose. (markdown)",
                        "                           Defaults to preserve.",
                        "  --no-semi                Do not print semicolons, except at the beginning of lines which may need them.",
                        "  --single-quote           Use single quotes instead of double quotes.",
                        "                           Defaults to false.",
                        "  --tab-width <int>        Number of spaces per indentation level.",
                        "                           Defaults to 2.",
                        "  --trailing-comma <none|es5|all>",
                        "                           Print trailing commas wherever possible when multi-line.",
                        "                           Defaults to none.",
                        "  --use-tabs               Indent with tabs instead of spaces.",
                        "                           Defaults to false.",
                        "",
                        "Config options:",
                        "",
                        "  --config <path>          Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).",
                        "  --no-config              Do not look for a configuration file.",
                        "  --config-precedence <cli-override|file-override|prefer-file>",
                        "                           Define in which order config files and CLI options should be evaluated.",
                        "                           Defaults to cli-override.",
                        "  --no-editorconfig        Don't take .editorconfig into account when parsing configuration.",
                        "  --find-config-path <path>",
                        "                           Find and print the path to a configuration file for the given input file.",
                        "  --ignore-path <path>     Path to a file with patterns describing files to ignore.",
                        "                           Defaults to .prettierignore.",
                        "  --plugin <path>          Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.",
                        "                           Defaults to [].",
                        "  --with-node-modules      Process files inside 'node_modules' directory.",
                        "",
                        "Editor options:",
                        "",
                        "  --cursor-offset <int>    Print (to stderr) where a cursor at the given position would move to after formatting.",
                        "                           This option cannot be used with --range-start and --range-end.",
                        "                           Defaults to -1.",
                        "  --range-end <int>        Format code ending at a given character offset (exclusive).",
                        "                           The range will extend forwards to the end of the selected statement.",
                        "                           This option cannot be used with --cursor-offset.",
                        "                           Defaults to Infinity.",
                        "  --range-start <int>      Format code starting at a given character offset.",
                        "                           The range will extend backwards to the start of the first line containing the selected statement.",
                        "                           This option cannot be used with --cursor-offset.",
                        "                           Defaults to 0.",
                        "",
                        "Other options:",
                        "",
                        "  --no-color               Do not colorize error messages.",
                        "  -h, --help <flag>        Show CLI usage, or details about the given flag.",
                        "                           Example: --help write",
                        "  --insert-pragma          Insert @format pragma into file's first docblock comment.",
                        "                           Defaults to false.",
                        "  --loglevel <silent|error|warn|log|debug>",
                        "                           What level of logs to report.",
                        "                           Defaults to log.",
                        "  --require-pragma         Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                        "                           in order for it to be formatted.",
                        "                           Defaults to false.",
                        "  --stdin                  Force reading input from stdin.",
                        "  --stdin-filepath <path>  Path to the file to pretend that stdin comes from.",
                        "  --support-info           Print support information as JSON.",
                        "  -v, --version            Print Prettier version.",
                        "",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error and show usage with something unexpected (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with --find-config-path + multiple files (stderr) 1`] = `",
                        "\"[error] Cannot use --find-config-path with multiple files",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with --find-config-path + multiple files (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with --find-config-path + multiple files (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with --write + --debug-check (stderr) 1`] = `",
                        "\"[error] Cannot use --write and --debug-check together.",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with --write + --debug-check (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with --write + --debug-check (write) 1`] = `Array []`;"
                    ]
                },
                "ignore-absolute-path.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`support absolute filename (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`support absolute filename (stdout) 1`] = `",
                        "\"regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`support absolute filename (write) 1`] = `Array []`;"
                    ]
                },
                "ignore-path.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`ignore file when using --debug-check (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignore file when using --debug-check (stdout) 1`] = `",
                        "\"other-regular-modules.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignore file when using --debug-check (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignore path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignore path (stdout) 1`] = `",
                        "\"regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignore path (write) 1`] = `Array []`;",
                        "",
                        "exports[`outputs files as-is if no --write (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`outputs files as-is if no --write (stdout) 1`] = `",
                        "\"'use strict';",
                        "\"",
                        "`;",
                        "",
                        "exports[`outputs files as-is if no --write (write) 1`] = `Array []`;",
                        "",
                        "exports[`support .prettierignore (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`support .prettierignore (stdout) 1`] = `",
                        "\"other-regular-modules.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`support .prettierignore (write) 1`] = `Array []`;"
                    ]
                },
                "ignore-relative-path.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`support relative paths (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`support relative paths (stdout) 1`] = `",
                        "\"shouldNotBeIgnored.js",
                        "level1-glob/level2-glob/level3-glob/shouldNotBeIgnored.scss",
                        "level1-glob/shouldNotBeIgnored.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`support relative paths (write) 1`] = `Array []`;"
                    ]
                },
                "invalid-ignore.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`throw error with invalid ignore (stderr) 1`] = `",
                        "\"[error] Unable to read <cwd>/tests_integration/cli/invalid-ignore/.prettierignore: EISDIR: illegal operation on a directory, read",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid ignore (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid ignore (write) 1`] = `Array []`;"
                    ]
                },
                "list-different.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`checks stdin with --list-different (write) 1`] = `Array []`;"
                    ]
                },
                "loglevel.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`--write with --loglevel=silent doesn't log filenames (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`--write with --loglevel=silent doesn't log filenames (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`--write with --loglevel=silent doesn't log filenames (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;"
                    ]
                },
                "multiple-patterns.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`multiple patterns (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns (stdout) 1`] = `",
                        "\"directory/file.js",
                        "directory/nested-directory/nested-directory-file.js",
                        "other-directory/file.js",
                        "other-directory/nested-directory/nested-directory-file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, doesn't ignore node_modules with --with-node-modules flag (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, doesn't ignore node_modules with --with-node-modules flag (stdout) 1`] = `",
                        "\"node_modules/node-module.js",
                        "other-directory/file.js",
                        "other-directory/nested-directory/nested-directory-file.js",
                        "other-regular-modules.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, doesn't ignore node_modules with --with-node-modules flag (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by default (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by default (stdout) 1`] = `",
                        "\"other-directory/file.js",
                        "other-directory/nested-directory/nested-directory-file.js",
                        "other-regular-modules.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by default (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by with ./**/*.js (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by with ./**/*.js (stdout) 1`] = `",
                        "\"other-directory/file.js",
                        "other-directory/nested-directory/nested-directory-file.js",
                        "other-regular-modules.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by with ./**/*.js (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns with ignore nested directories pattern (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns with ignore nested directories pattern (stdout) 1`] = `",
                        "\"directory/file.js",
                        "other-directory/file.js",
                        "other-regular-modules.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns with ignore nested directories pattern (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns with non exists pattern (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns with non exists pattern (stdout) 1`] = `",
                        "\"directory/file.js",
                        "directory/nested-directory/nested-directory-file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns with non exists pattern (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns, throw error and exit with non zero code on non existing files (stderr) 1`] = `",
                        "\"[error] No matching files. Patterns tried: non-existent.js other-non-existent.js !**/node_modules/** !./node_modules/**",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns, throw error and exit with non zero code on non existing files (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns, throw error and exit with non zero code on non existing files (write) 1`] = `Array []`;",
                        "",
                        "exports[`no errors on empty patterns (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`no errors on empty patterns (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`no errors on empty patterns (write) 1`] = `Array []`;"
                    ]
                },
                "parser-api.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`allows passing a string to resolve a parser (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`allows passing a string to resolve a parser (stdout) 1`] = `",
                        "\"/* eslint-disable */",
                        "bar();",
                        "\"",
                        "`;",
                        "",
                        "exports[`allows passing a string to resolve a parser (write) 1`] = `Array []`;"
                    ]
                },
                "piped-output.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (stdout) 1`] = `\"formatted.js\"`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (stdout) 2`] = `\"\"`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (write) 1`] = `Array []`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (write) 2`] = `Array []`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (stdout) 1`] = `",
                        "\"unformatted.jsunformatted.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (stdout) 2`] = `",
                        "\"unformatted.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (write) 2`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;"
                    ]
                },
                "plugin-options.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[` 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -12,10 +12,12 @@",
                        "  ",
                        "    --arrow-parens <avoid|always>",
                        "                             Include parentheses around a sole arrow function parameter.",
                        "                             Defaults to avoid.",
                        "    --no-bracket-spacing     Do not print spaces between brackets.",
                        "+   --foo-option <bar|baz>   foo description",
                        "+                            Defaults to bar.",
                        "    --jsx-bracket-same-line  Put > on the last line instead of at a new line.",
                        "                             Defaults to false.",
                        "    --parser <flow|babylon|typescript|css|less|scss|json|graphql|markdown|vue>",
                        "                             Which parser to use.",
                        "                             Defaults to babylon.\"",
                        "`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-option\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-option\\` (stdout) 1`] = `",
                        "\"--foo-option <bar|baz>",
                        "",
                        "  foo description",
                        "",
                        "Valid options:",
                        "",
                        "  bar   bar description",
                        "  baz   baz description",
                        "",
                        "Default: bar",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-option\\` (write) 1`] = `Array []`;"
                    ]
                },
                "skip-folders.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`skip folders passed specifically (stdout) 1`] = `",
                        "\"a/file.js",
                        "b/file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`skip folders passed specifically (write) 1`] = `Array []`;",
                        "",
                        "exports[`skips folders in glob (stdout) 1`] = `",
                        "\"a/file.js",
                        "b/file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`skips folders in glob (write) 1`] = `Array []`;"
                    ]
                },
                "stdin-filepath.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`format correctly if stdin content compatible with stdin-filepath (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`format correctly if stdin content compatible with stdin-filepath (stdout) 1`] = `",
                        "\".name {",
                        "  display: none;",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`format correctly if stdin content compatible with stdin-filepath (write) 1`] = `Array []`;",
                        "",
                        "exports[`output file as-is if stdin-filepath matched patterns in ignore-path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`output file as-is if stdin-filepath matched patterns in ignore-path (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error if stdin content incompatible with stdin-filepath (stderr) 1`] = `",
                        "\"[error] stdin: SyntaxError: Unexpected token (1:1)",
                        "[error] > 1 | .name { display: none; }",
                        "[error]     | ^",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error if stdin content incompatible with stdin-filepath (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error if stdin content incompatible with stdin-filepath (write) 1`] = `Array []`;"
                    ]
                },
                "support-info.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`API getSupportInfo() with version 0.0.0 -> 1.0.0 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -12,19 +12,35 @@",
                        "    \\\\\"options\\\\\": Object {",
                        "      \\\\\"bracketSpacing\\\\\": Object {",
                        "        \\\\\"default\\\\\": true,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "+     \\\\\"jsxBracketSameLine\\\\\": Object {",
                        "+       \\\\\"default\\\\\": false,",
                        "+       \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "+     },",
                        "+     \\\\\"parser\\\\\": Object {",
                        "+       \\\\\"choices\\\\\": Array [",
                        "+         \\\\\"flow\\\\\",",
                        "+         \\\\\"babylon\\\\\",",
                        "+       ],",
                        "+       \\\\\"default\\\\\": \\\\\"babylon\\\\\",",
                        "+       \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "+     },",
                        "      \\\\\"printWidth\\\\\": Object {",
                        "        \\\\\"default\\\\\": 80,",
                        "        \\\\\"range\\\\\": Object {",
                        "          \\\\\"end\\\\\": Infinity,",
                        "          \\\\\"start\\\\\": 0,",
                        "          \\\\\"step\\\\\": 1,",
                        "        },",
                        "        \\\\\"type\\\\\": \\\\\"int\\\\\",",
                        "      },",
                        "+     \\\\\"semi\\\\\": Object {",
                        "+       \\\\\"default\\\\\": true,",
                        "+       \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "+     },",
                        "      \\\\\"singleQuote\\\\\": Object {",
                        "        \\\\\"default\\\\\": false,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "      \\\\\"tabWidth\\\\\": Object {",
                        "@@ -39,17 +55,15 @@",
                        "      \\\\\"trailingComma\\\\\": Object {",
                        "        \\\\\"choices\\\\\": Array [",
                        "          \\\\\"none\\\\\",",
                        "          \\\\\"es5\\\\\",",
                        "          \\\\\"all\\\\\",",
                        "-         true,",
                        "-         false,",
                        "        ],",
                        "-       \\\\\"default\\\\\": false,",
                        "+       \\\\\"default\\\\\": \\\\\"none\\\\\",",
                        "        \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "      },",
                        "-     \\\\\"useFlowParser\\\\\": Object {",
                        "+     \\\\\"useTabs\\\\\": Object {",
                        "        \\\\\"default\\\\\": false,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "    },",
                        "  }\"",
                        "`;",
                        "",
                        "exports[`API getSupportInfo() with version 0.0.0 1`] = `",
                        "Object {",
                        "  \"languages\": Object {",
                        "    \"JSX\": Array [",
                        "      \"babylon\",",
                        "      \"flow\",",
                        "    ],",
                        "    \"JavaScript\": Array [",
                        "      \"babylon\",",
                        "      \"flow\",",
                        "    ],",
                        "  },",
                        "  \"options\": Object {",
                        "    \"bracketSpacing\": Object {",
                        "      \"default\": true,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"printWidth\": Object {",
                        "      \"default\": 80,",
                        "      \"range\": Object {",
                        "        \"end\": Infinity,",
                        "        \"start\": 0,",
                        "        \"step\": 1,",
                        "      },",
                        "      \"type\": \"int\",",
                        "    },",
                        "    \"singleQuote\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"tabWidth\": Object {",
                        "      \"default\": 2,",
                        "      \"range\": Object {",
                        "        \"end\": Infinity,",
                        "        \"start\": 0,",
                        "        \"step\": 1,",
                        "      },",
                        "      \"type\": \"int\",",
                        "    },",
                        "    \"trailingComma\": Object {",
                        "      \"choices\": Array [",
                        "        \"none\",",
                        "        \"es5\",",
                        "        \"all\",",
                        "        true,",
                        "        false,",
                        "      ],",
                        "      \"default\": false,",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"useFlowParser\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "  },",
                        "}",
                        "`;",
                        "",
                        "exports[`API getSupportInfo() with version 1.0.0 -> 1.4.0 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -1,29 +1,56 @@",
                        "  Object {",
                        "    \\\\\"languages\\\\\": Object {",
                        "+     \\\\\"CSS\\\\\": Array [",
                        "+       \\\\\"postcss\\\\\",",
                        "+     ],",
                        "      \\\\\"JSX\\\\\": Array [",
                        "        \\\\\"babylon\\\\\",",
                        "        \\\\\"flow\\\\\",",
                        "      ],",
                        "      \\\\\"JavaScript\\\\\": Array [",
                        "        \\\\\"babylon\\\\\",",
                        "        \\\\\"flow\\\\\",",
                        "      ],",
                        "+     \\\\\"Less\\\\\": Array [",
                        "+       \\\\\"postcss\\\\\",",
                        "+     ],",
                        "+     \\\\\"SCSS\\\\\": Array [",
                        "+       \\\\\"postcss\\\\\",",
                        "+     ],",
                        "+     \\\\\"TypeScript\\\\\": Array [",
                        "+       \\\\\"typescript\\\\\",",
                        "+     ],",
                        "    },",
                        "    \\\\\"options\\\\\": Object {",
                        "      \\\\\"bracketSpacing\\\\\": Object {",
                        "        \\\\\"default\\\\\": true,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "+     \\\\\"cursorOffset\\\\\": Object {",
                        "+       \\\\\"default\\\\\": -1,",
                        "+       \\\\\"range\\\\\": Object {",
                        "+         \\\\\"end\\\\\": Infinity,",
                        "+         \\\\\"start\\\\\": -1,",
                        "+         \\\\\"step\\\\\": 1,",
                        "+       },",
                        "+       \\\\\"type\\\\\": \\\\\"int\\\\\",",
                        "+     },",
                        "+     \\\\\"filepath\\\\\": Object {",
                        "+       \\\\\"default\\\\\": undefined,",
                        "+       \\\\\"type\\\\\": \\\\\"path\\\\\",",
                        "+     },",
                        "      \\\\\"jsxBracketSameLine\\\\\": Object {",
                        "        \\\\\"default\\\\\": false,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "      \\\\\"parser\\\\\": Object {",
                        "        \\\\\"choices\\\\\": Array [",
                        "          \\\\\"flow\\\\\",",
                        "          \\\\\"babylon\\\\\",",
                        "+         \\\\\"typescript\\\\\",",
                        "+         \\\\\"postcss\\\\\",",
                        "        ],",
                        "        \\\\\"default\\\\\": \\\\\"babylon\\\\\",",
                        "        \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "      },",
                        "      \\\\\"printWidth\\\\\": Object {",
                        "@@ -33,10 +60,28 @@",
                        "          \\\\\"start\\\\\": 0,",
                        "          \\\\\"step\\\\\": 1,",
                        "        },",
                        "        \\\\\"type\\\\\": \\\\\"int\\\\\",",
                        "      },",
                        "+     \\\\\"rangeEnd\\\\\": Object {",
                        "+       \\\\\"default\\\\\": Infinity,",
                        "+       \\\\\"range\\\\\": Object {",
                        "+         \\\\\"end\\\\\": Infinity,",
                        "+         \\\\\"start\\\\\": 0,",
                        "+         \\\\\"step\\\\\": 1,",
                        "+       },",
                        "+       \\\\\"type\\\\\": \\\\\"int\\\\\",",
                        "+     },",
                        "+     \\\\\"rangeStart\\\\\": Object {",
                        "+       \\\\\"default\\\\\": 0,",
                        "+       \\\\\"range\\\\\": Object {",
                        "+         \\\\\"end\\\\\": Infinity,",
                        "+         \\\\\"start\\\\\": 0,",
                        "+         \\\\\"step\\\\\": 1,",
                        "+       },",
                        "+       \\\\\"type\\\\\": \\\\\"int\\\\\",",
                        "+     },",
                        "      \\\\\"semi\\\\\": Object {",
                        "        \\\\\"default\\\\\": true,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "      \\\\\"singleQuote\\\\\": Object {\"",
                        "`;",
                        "",
                        "exports[`API getSupportInfo() with version 1.4.0 -> 1.5.0 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -1,10 +1,16 @@",
                        "  Object {",
                        "    \\\\\"languages\\\\\": Object {",
                        "      \\\\\"CSS\\\\\": Array [",
                        "        \\\\\"postcss\\\\\",",
                        "      ],",
                        "+     \\\\\"GraphQL\\\\\": Array [",
                        "+       \\\\\"graphql\\\\\",",
                        "+     ],",
                        "+     \\\\\"JSON\\\\\": Array [",
                        "+       \\\\\"json\\\\\",",
                        "+     ],",
                        "      \\\\\"JSX\\\\\": Array [",
                        "        \\\\\"babylon\\\\\",",
                        "        \\\\\"flow\\\\\",",
                        "      ],",
                        "      \\\\\"JavaScript\\\\\": Array [",
                        "@@ -47,10 +53,12 @@",
                        "        \\\\\"choices\\\\\": Array [",
                        "          \\\\\"flow\\\\\",",
                        "          \\\\\"babylon\\\\\",",
                        "          \\\\\"typescript\\\\\",",
                        "          \\\\\"postcss\\\\\",",
                        "+         \\\\\"json\\\\\",",
                        "+         \\\\\"graphql\\\\\",",
                        "        ],",
                        "        \\\\\"default\\\\\": \\\\\"babylon\\\\\",",
                        "        \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "      },",
                        "      \\\\\"printWidth\\\\\": Object {\"",
                        "`;",
                        "",
                        "exports[`API getSupportInfo() with version 1.5.0 -> 1.7.1 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -1,9 +1,9 @@",
                        "  Object {",
                        "    \\\\\"languages\\\\\": Object {",
                        "      \\\\\"CSS\\\\\": Array [",
                        "-       \\\\\"postcss\\\\\",",
                        "+       \\\\\"css\\\\\",",
                        "      ],",
                        "      \\\\\"GraphQL\\\\\": Array [",
                        "        \\\\\"graphql\\\\\",",
                        "      ],",
                        "      \\\\\"JSON\\\\\": Array [",
                        "@@ -16,14 +16,14 @@",
                        "      \\\\\"JavaScript\\\\\": Array [",
                        "        \\\\\"babylon\\\\\",",
                        "        \\\\\"flow\\\\\",",
                        "      ],",
                        "      \\\\\"Less\\\\\": Array [",
                        "-       \\\\\"postcss\\\\\",",
                        "+       \\\\\"less\\\\\",",
                        "      ],",
                        "      \\\\\"SCSS\\\\\": Array [",
                        "-       \\\\\"postcss\\\\\",",
                        "+       \\\\\"scss\\\\\",",
                        "      ],",
                        "      \\\\\"TypeScript\\\\\": Array [",
                        "        \\\\\"typescript\\\\\",",
                        "      ],",
                        "    },",
                        "@@ -52,11 +52,13 @@",
                        "      \\\\\"parser\\\\\": Object {",
                        "        \\\\\"choices\\\\\": Array [",
                        "          \\\\\"flow\\\\\",",
                        "          \\\\\"babylon\\\\\",",
                        "          \\\\\"typescript\\\\\",",
                        "-         \\\\\"postcss\\\\\",",
                        "+         \\\\\"css\\\\\",",
                        "+         \\\\\"less\\\\\",",
                        "+         \\\\\"scss\\\\\",",
                        "          \\\\\"json\\\\\",",
                        "          \\\\\"graphql\\\\\",",
                        "        ],",
                        "        \\\\\"default\\\\\": \\\\\"babylon\\\\\",",
                        "        \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "@@ -86,10 +88,14 @@",
                        "          \\\\\"start\\\\\": 0,",
                        "          \\\\\"step\\\\\": 1,",
                        "        },",
                        "        \\\\\"type\\\\\": \\\\\"int\\\\\",",
                        "      },",
                        "+     \\\\\"requirePragma\\\\\": Object {",
                        "+       \\\\\"default\\\\\": false,",
                        "+       \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "+     },",
                        "      \\\\\"semi\\\\\": Object {",
                        "        \\\\\"default\\\\\": true,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "      \\\\\"singleQuote\\\\\": Object {\"",
                        "`;",
                        "",
                        "exports[`API getSupportInfo() with version 1.7.1 -> 1.8.0 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -18,10 +18,13 @@",
                        "        \\\\\"flow\\\\\",",
                        "      ],",
                        "      \\\\\"Less\\\\\": Array [",
                        "        \\\\\"less\\\\\",",
                        "      ],",
                        "+     \\\\\"Markdown\\\\\": Array [",
                        "+       \\\\\"markdown\\\\\",",
                        "+     ],",
                        "      \\\\\"SCSS\\\\\": Array [",
                        "        \\\\\"scss\\\\\",",
                        "      ],",
                        "      \\\\\"TypeScript\\\\\": Array [",
                        "        \\\\\"typescript\\\\\",",
                        "@@ -43,10 +46,14 @@",
                        "      },",
                        "      \\\\\"filepath\\\\\": Object {",
                        "        \\\\\"default\\\\\": undefined,",
                        "        \\\\\"type\\\\\": \\\\\"path\\\\\",",
                        "      },",
                        "+     \\\\\"insertPragma\\\\\": Object {",
                        "+       \\\\\"default\\\\\": false,",
                        "+       \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "+     },",
                        "      \\\\\"jsxBracketSameLine\\\\\": Object {",
                        "        \\\\\"default\\\\\": false,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "      \\\\\"parser\\\\\": Object {",
                        "@@ -57,10 +64,11 @@",
                        "          \\\\\"css\\\\\",",
                        "          \\\\\"less\\\\\",",
                        "          \\\\\"scss\\\\\",",
                        "          \\\\\"json\\\\\",",
                        "          \\\\\"graphql\\\\\",",
                        "+         \\\\\"markdown\\\\\",",
                        "        ],",
                        "        \\\\\"default\\\\\": \\\\\"babylon\\\\\",",
                        "        \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "      },",
                        "      \\\\\"printWidth\\\\\": Object {\"",
                        "`;",
                        "",
                        "exports[`API getSupportInfo() with version 1.8.0 -> 1.8.2 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -78,10 +78,18 @@",
                        "          \\\\\"start\\\\\": 0,",
                        "          \\\\\"step\\\\\": 1,",
                        "        },",
                        "        \\\\\"type\\\\\": \\\\\"int\\\\\",",
                        "      },",
                        "+     \\\\\"proseWrap\\\\\": Object {",
                        "+       \\\\\"choices\\\\\": Array [",
                        "+         false,",
                        "+         true,",
                        "+       ],",
                        "+       \\\\\"default\\\\\": true,",
                        "+       \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "+     },",
                        "      \\\\\"rangeEnd\\\\\": Object {",
                        "        \\\\\"default\\\\\": Infinity,",
                        "        \\\\\"range\\\\\": Object {",
                        "          \\\\\"end\\\\\": Infinity,",
                        "          \\\\\"start\\\\\": 0,\"",
                        "`;",
                        "",
                        "exports[`API getSupportInfo() with version 1.8.2 -> undefined 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -27,12 +27,23 @@",
                        "        \\\\\"scss\\\\\",",
                        "      ],",
                        "      \\\\\"TypeScript\\\\\": Array [",
                        "        \\\\\"typescript\\\\\",",
                        "      ],",
                        "+     \\\\\"Vue\\\\\": Array [",
                        "+       \\\\\"vue\\\\\",",
                        "+     ],",
                        "    },",
                        "    \\\\\"options\\\\\": Object {",
                        "+     \\\\\"arrowParens\\\\\": Object {",
                        "+       \\\\\"choices\\\\\": Array [",
                        "+         \\\\\"avoid\\\\\",",
                        "+         \\\\\"always\\\\\",",
                        "+       ],",
                        "+       \\\\\"default\\\\\": \\\\\"avoid\\\\\",",
                        "+       \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "+     },",
                        "      \\\\\"bracketSpacing\\\\\": Object {",
                        "        \\\\\"default\\\\\": true,",
                        "        \\\\\"type\\\\\": \\\\\"boolean\\\\\",",
                        "      },",
                        "      \\\\\"cursorOffset\\\\\": Object {",
                        "@@ -65,14 +76,19 @@",
                        "          \\\\\"less\\\\\",",
                        "          \\\\\"scss\\\\\",",
                        "          \\\\\"json\\\\\",",
                        "          \\\\\"graphql\\\\\",",
                        "          \\\\\"markdown\\\\\",",
                        "+         \\\\\"vue\\\\\",",
                        "        ],",
                        "        \\\\\"default\\\\\": \\\\\"babylon\\\\\",",
                        "        \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "      },",
                        "+     \\\\\"plugins\\\\\": Object {",
                        "+       \\\\\"default\\\\\": Array [],",
                        "+       \\\\\"type\\\\\": \\\\\"path\\\\\",",
                        "+     },",
                        "      \\\\\"printWidth\\\\\": Object {",
                        "        \\\\\"default\\\\\": 80,",
                        "        \\\\\"range\\\\\": Object {",
                        "          \\\\\"end\\\\\": Infinity,",
                        "          \\\\\"start\\\\\": 0,",
                        "@@ -80,14 +96,15 @@",
                        "        },",
                        "        \\\\\"type\\\\\": \\\\\"int\\\\\",",
                        "      },",
                        "      \\\\\"proseWrap\\\\\": Object {",
                        "        \\\\\"choices\\\\\": Array [",
                        "-         false,",
                        "-         true,",
                        "+         \\\\\"always\\\\\",",
                        "+         \\\\\"never\\\\\",",
                        "+         \\\\\"preserve\\\\\",",
                        "        ],",
                        "-       \\\\\"default\\\\\": true,",
                        "+       \\\\\"default\\\\\": \\\\\"preserve\\\\\",",
                        "        \\\\\"type\\\\\": \\\\\"choice\\\\\",",
                        "      },",
                        "      \\\\\"rangeEnd\\\\\": Object {",
                        "        \\\\\"default\\\\\": Infinity,",
                        "        \\\\\"range\\\\\": Object {\"",
                        "`;",
                        "",
                        "exports[`CLI --support-info (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI --support-info (stdout) 1`] = `",
                        "\"{",
                        "  \\\\\"languages\\\\\": [",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"js\\\\\", \\\\\"node\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/javascript\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".js\\\\\",",
                        "        \\\\\"._js\\\\\",",
                        "        \\\\\".bones\\\\\",",
                        "        \\\\\".es\\\\\",",
                        "        \\\\\".es6\\\\\",",
                        "        \\\\\".frag\\\\\",",
                        "        \\\\\".gs\\\\\",",
                        "        \\\\\".jake\\\\\",",
                        "        \\\\\".jsb\\\\\",",
                        "        \\\\\".jscad\\\\\",",
                        "        \\\\\".jsfl\\\\\",",
                        "        \\\\\".jsm\\\\\",",
                        "        \\\\\".jss\\\\\",",
                        "        \\\\\".mjs\\\\\",",
                        "        \\\\\".njs\\\\\",",
                        "        \\\\\".pac\\\\\",",
                        "        \\\\\".sjs\\\\\",",
                        "        \\\\\".ssjs\\\\\",",
                        "        \\\\\".xsjs\\\\\",",
                        "        \\\\\".xsjslib\\\\\"",
                        "      ],",
                        "      \\\\\"filenames\\\\\": [\\\\\"Jakefile\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 183,",
                        "      \\\\\"name\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"babylon\\\\\", \\\\\"flow\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.js\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"javascript\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/jsx\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"jsx\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".jsx\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"liguistLanguageId\\\\\": 178,",
                        "      \\\\\"name\\\\\": \\\\\"JSX\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"babylon\\\\\", \\\\\"flow\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.js.jsx\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"javascriptreact\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"typescript\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"ts\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"application/typescript\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".ts\\\\\", \\\\\".tsx\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"liguistLanguageId\\\\\": 378,",
                        "      \\\\\"name\\\\\": \\\\\"TypeScript\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"typescript\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.ts\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"typescript\\\\\", \\\\\"typescriptreact\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"json\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"application/json\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".json\\\\\",",
                        "        \\\\\".json5\\\\\",",
                        "        \\\\\".geojson\\\\\",",
                        "        \\\\\".JSON-tmLanguage\\\\\",",
                        "        \\\\\".topojson\\\\\"",
                        "      ],",
                        "      \\\\\"filenames\\\\\": [",
                        "        \\\\\".arcconfig\\\\\",",
                        "        \\\\\".jshintrc\\\\\",",
                        "        \\\\\".babelrc\\\\\",",
                        "        \\\\\".eslintrc\\\\\",",
                        "        \\\\\".prettierrc\\\\\",",
                        "        \\\\\"composer.lock\\\\\",",
                        "        \\\\\"mcmod.info\\\\\"",
                        "      ],",
                        "      \\\\\"group\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 174,",
                        "      \\\\\"name\\\\\": \\\\\"JSON\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"json\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.5.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.json\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"json\\\\\", \\\\\"jsonc\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/css\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".css\\\\\", \\\\\".pcss\\\\\", \\\\\".postcss\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"CSS\\\\\",",
                        "      \\\\\"liguistLanguageId\\\\\": 50,",
                        "      \\\\\"name\\\\\": \\\\\"CSS\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"css\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.css\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"css\\\\\", \\\\\"postcss\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"less\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/css\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".less\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"CSS\\\\\",",
                        "      \\\\\"liguistLanguageId\\\\\": 198,",
                        "      \\\\\"name\\\\\": \\\\\"Less\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"less\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.css.less\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"less\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"scss\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/x-scss\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".scss\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"CSS\\\\\",",
                        "      \\\\\"liguistLanguageId\\\\\": 329,",
                        "      \\\\\"name\\\\\": \\\\\"SCSS\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"scss\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.scss\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"scss\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"text\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".graphql\\\\\", \\\\\".gql\\\\\"],",
                        "      \\\\\"liguistLanguageId\\\\\": 139,",
                        "      \\\\\"name\\\\\": \\\\\"GraphQL\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"graphql\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.5.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.graphql\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"graphql\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"markdown\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"pandoc\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/x-gfm\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"gfm\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".md\\\\\",",
                        "        \\\\\".markdown\\\\\",",
                        "        \\\\\".mdown\\\\\",",
                        "        \\\\\".mdwn\\\\\",",
                        "        \\\\\".mkd\\\\\",",
                        "        \\\\\".mkdn\\\\\",",
                        "        \\\\\".mkdown\\\\\",",
                        "        \\\\\".ron\\\\\",",
                        "        \\\\\".workbook\\\\\"",
                        "      ],",
                        "      \\\\\"filenames\\\\\": [\\\\\"README\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 222,",
                        "      \\\\\"name\\\\\": \\\\\"Markdown\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"markdown\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.8.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.gfm\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"markdown\\\\\"],",
                        "      \\\\\"wrap\\\\\": true",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"html\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/html\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"htmlmixed\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".vue\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"HTML\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 146,",
                        "      \\\\\"name\\\\\": \\\\\"Vue\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"vue\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.10.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"text.html.vue\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"vue\\\\\"]",
                        "    }",
                        "  ],",
                        "  \\\\\"options\\\\\": [",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Omit parens when possible. Example: \\`x => x\\`\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"avoid\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Always include parens. Example: \\`(x) => x\\`\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"always\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"avoid\\\\\",",
                        "      \\\\\"description\\\\\":",
                        "        \\\\\"Include parentheses around a sole arrow function parameter.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"arrowParens\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.9.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"default\\\\\": true,",
                        "      \\\\\"description\\\\\": \\\\\"Print spaces between brackets.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"bracketSpacing\\\\\",",
                        "      \\\\\"oppositeDescription\\\\\": \\\\\"Do not print spaces between brackets.\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": -1,",
                        "      \\\\\"description\\\\\":",
                        "        \\\\\"Print (to stderr) where a cursor at the given position would move to after formatting.\\\\\\\\nThis option cannot be used with --range-start and --range-end.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"cursorOffset\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": -1, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"description\\\\\":",
                        "        \\\\\"Specify the input filepath. This will be used to do parser inference.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"filepath\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"path\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\":",
                        "        \\\\\"Insert @format pragma into file's first docblock comment.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"insertPragma\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.8.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Put > on the last line instead of at a new line.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"jsxBracketSameLine\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.17.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        { \\\\\"description\\\\\": \\\\\"Flow\\\\\", \\\\\"value\\\\\": \\\\\"flow\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"JavaScript\\\\\", \\\\\"value\\\\\": \\\\\"babylon\\\\\" },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"TypeScript\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"typescript\\\\\"",
                        "        },",
                        "        { \\\\\"description\\\\\": \\\\\"CSS\\\\\", \\\\\"since\\\\\": \\\\\"1.7.1\\\\\", \\\\\"value\\\\\": \\\\\"css\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"Less\\\\\", \\\\\"since\\\\\": \\\\\"1.7.1\\\\\", \\\\\"value\\\\\": \\\\\"less\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"SCSS\\\\\", \\\\\"since\\\\\": \\\\\"1.7.1\\\\\", \\\\\"value\\\\\": \\\\\"scss\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"JSON\\\\\", \\\\\"since\\\\\": \\\\\"1.5.0\\\\\", \\\\\"value\\\\\": \\\\\"json\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"GraphQL\\\\\", \\\\\"since\\\\\": \\\\\"1.5.0\\\\\", \\\\\"value\\\\\": \\\\\"graphql\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"Markdown\\\\\", \\\\\"since\\\\\": \\\\\"1.8.0\\\\\", \\\\\"value\\\\\": \\\\\"markdown\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"Vue\\\\\", \\\\\"since\\\\\": \\\\\"1.10.0\\\\\", \\\\\"value\\\\\": \\\\\"vue\\\\\" }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"babylon\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"Which parser to use.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"parser\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.0.10\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"array\\\\\": true,",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": [],",
                        "      \\\\\"description\\\\\":",
                        "        \\\\\"Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"plugins\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.10.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"path\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": 80,",
                        "      \\\\\"description\\\\\": \\\\\"The line length where Prettier will try wrap.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"printWidth\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": 0, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Markdown\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Wrap prose if it exceeds the print width.\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.9.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"always\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Do not wrap prose.\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.9.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"never\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Wrap prose as-is.\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.9.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"preserve\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"preserve\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"How to wrap prose. (markdown)\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"proseWrap\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.8.2\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": null,",
                        "      \\\\\"description\\\\\":",
                        "        \\\\\"Format code ending at a given character offset (exclusive).\\\\\\\\nThe range will extend forwards to the end of the selected statement.\\\\\\\\nThis option cannot be used with --cursor-offset.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"rangeEnd\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": 0, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": 0,",
                        "      \\\\\"description\\\\\":",
                        "        \\\\\"Format code starting at a given character offset.\\\\\\\\nThe range will extend backwards to the start of the first line containing the selected statement.\\\\\\\\nThis option cannot be used with --cursor-offset.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"rangeStart\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": 0, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\":",
                        "        \\\\\"Require either '@prettier' or '@format' to be present in the file's first docblock comment\\\\\\\\nin order for it to be formatted.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"requirePragma\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.7.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"default\\\\\": true,",
                        "      \\\\\"description\\\\\": \\\\\"Print semicolons.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"semi\\\\\",",
                        "      \\\\\"oppositeDescription\\\\\":",
                        "        \\\\\"Do not print semicolons, except at the beginning of lines which may need them.\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Use single quotes instead of double quotes.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"singleQuote\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": 2,",
                        "      \\\\\"description\\\\\": \\\\\"Number of spaces per indentation level.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"tabWidth\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": 0, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        { \\\\\"description\\\\\": \\\\\"No trailing commas.\\\\\", \\\\\"value\\\\\": \\\\\"none\\\\\" },",
                        "        {",
                        "          \\\\\"description\\\\\":",
                        "            \\\\\"Trailing commas where valid in ES5 (objects, arrays, etc.)\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"es5\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\":",
                        "            \\\\\"Trailing commas wherever possible (including function arguments).\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"all\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"none\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"Print trailing commas wherever possible when multi-line.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"trailingComma\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Indent with tabs instead of spaces.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"useTabs\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    }",
                        "  ]",
                        "}",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI --support-info (write) 1`] = `Array []`;"
                    ]
                },
                "syntax-error.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`exits with non-zero code when input has a syntax error (stderr) 1`] = `",
                        "\"[error] stdin: SyntaxError: Unexpected token, expected \\\\\";\\\\\" (1:2)",
                        "[error] > 1 | a.2",
                        "[error]     |  ^",
                        "\"",
                        "`;",
                        "",
                        "exports[`exits with non-zero code when input has a syntax error (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`exits with non-zero code when input has a syntax error (write) 1`] = `Array []`;"
                    ]
                },
                "with-config-precedence.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence cli-override (stdout) 1`] = `",
                        "\"let x: keyof Y = foo<typeof X>()",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence cli-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence file-override (stdout) 1`] = `",
                        "\"let x: keyof Y = foo<typeof X>();",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence file-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence prefer-file (stdout) 1`] = `",
                        "\"let x: keyof Y = foo<typeof X>();",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence prefer-file (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides are still applied when no config is found with --config-precedence file-override (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides are still applied when no config is found with --config-precedence file-override (stdout) 1`] = `",
                        "\"function noConfigJs() {",
                        "      console.log(\\\\\"no-config/file.js should have no semicolons\\\\\")",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides are still applied when no config is found with --config-precedence file-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides gets applied when no config exists with --config-precedence prefer-file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides gets applied when no config exists with --config-precedence prefer-file (stdout) 1`] = `",
                        "\"function noConfigJs() {",
                        "       console.log(",
                        "              \\\\\"no-config/file.js should have no semicolons\\\\\"",
                        "       );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides gets applied when no config exists with --config-precedence prefer-file (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides gets ignored when config exists with --config-precedence prefer-file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides gets ignored when config exists with --config-precedence prefer-file (stdout) 1`] = `",
                        "\"function js() {",
                        "        console.log(\\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\");",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        tabWidth: 8",
                        "};",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides gets ignored when config exists with --config-precedence prefer-file (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides take lower precedence with --config-precedence file-override (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides take lower precedence with --config-precedence file-override (stdout) 1`] = `",
                        "\"function js() {",
                        "        console.log(\\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\");",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        tabWidth: 8",
                        "};",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides take lower precedence with --config-precedence file-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides take precedence with --config-precedence cli-override (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides take precedence with --config-precedence cli-override (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(",
                        "\t\t\\\\\"should have tab width 8\\\\\"",
                        "\t)",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2\\\\\"",
                        "  )",
                        "}",
                        "function f() {",
                        "        console.log(",
                        "                \\\\\"should have space width 8\\\\\"",
                        "        )",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\\\\\"",
                        "  )",
                        "}",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/Component.js should not have semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/Component.test.js should have semi\\\\\"",
                        ");",
                        "function js() {",
                        "        console.log(",
                        "                \\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\"",
                        "        );",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        tabWidth: 8",
                        "};",
                        "function noConfigJs() {",
                        "  console.log(",
                        "    \\\\\"no-config/file.js should have no semicolons\\\\\"",
                        "  )",
                        "}",
                        "function packageJs() {",
                        "   console.log(",
                        "      \\\\\"package/file.js should have tab width 3\\\\\"",
                        "   );",
                        "}",
                        "function rcJson() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-json/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcYaml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-yaml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides take precedence with --config-precedence cli-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides take precedence without --config-precedence (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides take precedence without --config-precedence (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(",
                        "\t\t\\\\\"should have tab width 8\\\\\"",
                        "\t)",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2\\\\\"",
                        "  )",
                        "}",
                        "function f() {",
                        "        console.log(",
                        "                \\\\\"should have space width 8\\\\\"",
                        "        )",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\\\\\"",
                        "  )",
                        "}",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/Component.js should not have semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/Component.test.js should have semi\\\\\"",
                        ");",
                        "function js() {",
                        "        console.log(",
                        "                \\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\"",
                        "        );",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        tabWidth: 8",
                        "};",
                        "function noConfigJs() {",
                        "  console.log(",
                        "    \\\\\"no-config/file.js should have no semicolons\\\\\"",
                        "  )",
                        "}",
                        "function packageJs() {",
                        "   console.log(",
                        "      \\\\\"package/file.js should have tab width 3\\\\\"",
                        "   );",
                        "}",
                        "function rcJson() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-json/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcYaml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-yaml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides take precedence without --config-precedence (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI validate options with --config-precedence cli-override (stderr) 1`] = `",
                        "\"[error] Invalid \\`\\\\\"printWidth\\\\\"\\` value. Expected an integer, but received \\`0.5\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI validate options with --config-precedence cli-override (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI validate options with --config-precedence cli-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI validate options with --config-precedence file-override (stderr) 1`] = `",
                        "\"[error] Invalid \\`\\\\\"printWidth\\\\\"\\` value. Expected an integer, but received \\`0.5\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI validate options with --config-precedence file-override (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI validate options with --config-precedence file-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI validate options with --config-precedence prefer-file (stderr) 1`] = `",
                        "\"[error] Invalid \\`\\\\\"printWidth\\\\\"\\` value. Expected an integer, but received \\`0.5\\`.",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI validate options with --config-precedence prefer-file (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI validate options with --config-precedence prefer-file (write) 1`] = `Array []`;"
                    ]
                },
                "with-node-modules.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag (stdout) 1`] = `",
                        "\"node_modules/node-module.js",
                        "not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag (write) 1`] = `Array []`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag for file list (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag for file list (stdout) 1`] = `",
                        "\"node_modules/node-module.js",
                        "not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag for file list (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignores node_modules by default (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores node_modules by default (stdout) 1`] = `",
                        "\"not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignores node_modules by default (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignores node_modules by default for file list (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores node_modules by default for file list (stdout) 1`] = `",
                        "\"not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignores node_modules by default for file list (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignores node_modules by with ./**/*.js (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores node_modules by with ./**/*.js (stdout) 1`] = `",
                        "\"not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignores node_modules by with ./**/*.js (write) 1`] = `Array []`;"
                    ]
                },
                "with-parser-inference.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`infers postcss parser (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`infers postcss parser (stdout) 1`] = `",
                        "\"/* JavaScript */",
                        "\\\\\"use strict\\\\\";",
                        "/* Stylesheet */",
                        "* {",
                        "  outline: none;",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`infers postcss parser (write) 1`] = `Array []`;",
                        "",
                        "exports[`infers postcss parser with --list-different (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`infers postcss parser with --list-different (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`infers postcss parser with --list-different (write) 1`] = `Array []`;"
                    ]
                },
                "with-shebang.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`preserves shebang (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`preserves shebang (stdout) 1`] = `",
                        "\"#!/usr/bin/env node",
                        "\\\\\"use strict\\\\\";",
                        "\"",
                        "`;",
                        "",
                        "exports[`preserves shebang (write) 1`] = `Array []`;"
                    ]
                },
                "write.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`do not write file with --write + formatted file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`do not write file with --write + formatted file (stdout) 1`] = `",
                        "\"formatted.js 0ms",
                        "\"",
                        "`;",
                        "",
                        "exports[`do not write file with --write + invalid file (stderr) 1`] = `",
                        "\"[error] invalid.js: SyntaxError: Unexpected token, expected \\\\\";\\\\\" (1:6)",
                        "[error] > 1 | this is invalid!",
                        "[error]     |      ^",
                        "\"",
                        "`;",
                        "",
                        "exports[`do not write file with --write + invalid file (stdout) 1`] = `",
                        "\"",
                        "\"",
                        "`;",
                        "",
                        "exports[`write file with --write + unformatted file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`write file with --write + unformatted file (stdout) 1`] = `",
                        "\"unformatted.js 0ms",
                        "\"",
                        "`;",
                        "",
                        "exports[`write file with --write + unformatted file (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;"
                    ]
                }
            }
        },
        "cli": {
            "arg-parsing": {
                "file.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "console.log(\"could be single quote and without semi\")"
                    ]
                }
            },
            "config": {
                ".prettierrc": {},
                "$schema": {
                    ".prettierrc": {},
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": []
                    }
                },
                "editorconfig": {
                    ".editorconfig": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function f() {",
                            "  console.log(\"should have tab width 8\");",
                            "}"
                        ]
                    },
                    "lib": {
                        "file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "function f() {",
                                "  console.log(\"should have space width 2\");",
                                "}"
                            ]
                        },
                        "indent_size=tab.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "function f() {",
                                "  console.log(\"should have space width 8\");",
                                "}"
                            ]
                        }
                    },
                    "repo-root": {
                        ".hg": {},
                        "file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "function f() {",
                                "  console.log(\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\");",
                                "}"
                            ]
                        }
                    }
                },
                "filepath": {
                    ".prettierrc": {},
                    "subfolder": {
                        "file.js": {
                            "classes": [],
                            "functions": [],
                            "text": []
                        }
                    }
                },
                "invalid": {
                    "file": {
                        ".prettierrc": {}
                    },
                    "folder": {
                        ".prettierrc": {
                            "placeholder": {}
                        }
                    },
                    "option": {
                        "configPrecedence": {},
                        "int": {},
                        "kebab-case": {},
                        "trailingComma": {},
                        "unknown": {}
                    }
                },
                "jest": {
                    ".prettierrc": {},
                    "Component.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "console.log(\"jest/Component.js should not have semi\")"
                        ]
                    },
                    "Component.test.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "console.log(\"jest/Component.test.js should have semi\");"
                        ]
                    },
                    "__best-tests__": {
                        "file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "console.log(\"jest/__best-tests__/file.js should have semi\");"
                            ]
                        }
                    }
                },
                "js": {
                    ".editorconfig": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function js() {",
                            "  console.log(\"js/file.js should have tab width 8 (1 if CLI)\");",
                            "}"
                        ]
                    },
                    "prettier.config.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "module.exports = {",
                            "  tabWidth: 8",
                            "};"
                        ]
                    }
                },
                "no-config": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function noConfigJs() {",
                            "  console.log(\"no-config/file.js should have no semicolons\");",
                            "}"
                        ]
                    },
                    "file.ts": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function noConfigTs() {",
                            "  console.log(\"no-config/file.ts should have semicolons because it has a .ts extension\");",
                            "}"
                        ]
                    }
                },
                "package": {
                    ".editorconfig": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function packageJs() {",
                            "  console.log(\"package/file.js should have tab width 3\");",
                            "}"
                        ]
                    },
                    "file.ts": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function packageTs() {",
                            "  console.log(\"package/file.ts should have tab width 5 because it has .ts extension\");",
                            "}"
                        ]
                    },
                    "package.json": {}
                },
                "rc-json": {
                    ".prettierrc.json": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function rcJson() {",
                            "  console.log.apply(null, [",
                            "    \"rc-json/file.js\",",
                            "    \"should have trailing comma\",",
                            "    \"and single quotes\"",
                            "  ]);",
                            "}"
                        ]
                    }
                },
                "rc-yaml": {
                    ".prettierrc.yaml": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function rcYaml() {",
                            "  console.log.apply(null, [",
                            "    \"rc-yaml/file.js\",",
                            "    \"should have trailing comma\",",
                            "    \"and single quotes\"",
                            "  ]);",
                            "}"
                        ]
                    }
                }
            },
            "config-precedence": {
                ".prettierrc": {}
            },
            "debug-check": {
                "a.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const a = {",
                        "    'a': 1",
                        "};"
                    ]
                },
                "b.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const b = {",
                        "    'b': 2",
                        "};"
                    ]
                }
            },
            "ignore-absolute-path": {
                ".prettierignore": {},
                "regular-module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "depth1": {
                    "ignored": {
                        "module.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        }
                    }
                },
                "ignored": {
                    "module.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    }
                }
            },
            "ignore-path": {
                ".gitignore": {},
                ".prettierignore": {},
                "other-regular-modules.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "regular-module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                }
            },
            "ignore-relative-path": {
                ".prettierignore": {},
                "shouldNotBeIgnored.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "var x = 'this should be formatterd';",
                        ""
                    ]
                },
                "level1": {
                    "level2": {
                        "level3": {
                            "shouldNotBeFormat.js": {
                                "classes": [],
                                "functions": [],
                                "text": [
                                    "var x = 'this should not be formatterd';"
                                ]
                            }
                        }
                    }
                },
                "level1-glob": {
                    "shouldNotBeIgnored.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "var x = 'this should be formatterd';",
                            ""
                        ]
                    },
                    "level2-glob": {
                        "level3-glob": {
                            "shouldNotBeFormat.js": {
                                "classes": [],
                                "functions": [],
                                "text": [
                                    "var x = 'this should not be formatterd';"
                                ]
                            },
                            "shouldNotBeIgnored.scss": {}
                        }
                    }
                }
            },
            "invalid-ignore": {
                "something.js": {
                    "classes": [],
                    "functions": [],
                    "text": []
                },
                ".prettierignore": {
                    "placeholder": {}
                }
            },
            "loglevel": {
                ".prettierrc": {}
            },
            "multiple-patterns": {
                "other-regular-modules.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "regular-module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "directory": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    },
                    "nested-directory": {
                        "nested-directory-file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        }
                    }
                },
                "other-directory": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    },
                    "nested-directory": {
                        "nested-directory-file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        }
                    }
                }
            },
            "skip-folders": {
                "a": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "fooA(     )"
                        ]
                    }
                },
                "b": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "fooB(   )"
                        ]
                    }
                }
            },
            "stdin-ignore": {
                ".prettierignore": {}
            },
            "with-node-modules": {
                "regular-module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "not_node_modules": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    }
                }
            },
            "with-parser-inference": {
                "javascript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/* JavaScript */",
                        "\"use strict\";"
                    ]
                },
                "stylesheet.css": {}
            },
            "with-shebang": {
                "issue1890.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "#!/usr/bin/env node",
                        "\"use strict\";"
                    ]
                }
            },
            "write": {
                "formatted.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "var x = 1;"
                    ]
                },
                "invalid.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "this is invalid!"
                    ]
                },
                "unformatted.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "var x      =      1;"
                    ]
                }
            }
        },
        "custom-parsers": {
            "custom-rename-input.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* eslint-disable */",
                    "foo ( )"
                ]
            },
            "custom-rename-parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = function(text, parsers) {",
                    "  const ast = parsers.babylon(text);",
                    "  ast.program.body[0].expression.callee.name = \"bar\";",
                    "  return ast;",
                    "};"
                ]
            }
        },
        "plugins": {
            "automatic": {
                "file.txt": {},
                "package.json": {}
            },
            "defaultOptions": {
                ".config.json.swp": {},
                "config.json": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"]",
                        "    }",
                        "  ],",
                        "  defaultOptions: {",
                        "    tabWidth: 8",
                        "  },",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: (path, options) =>",
                        "        options.tabWidth ? `tabWidth:${options.tabWidth}` : path.getValue().text",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "extensions": {
                "file.foo": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const concat = require(\"../../../src/doc\").builders.concat;",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"]",
                        "    }",
                        "  ],",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: path => concat([\"!\", path.getValue().text])",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "options": {
                "config.json": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"],",
                        "      since: \"1.0.0\"",
                        "    }",
                        "  ],",
                        "  options: {",
                        "    fooOption: {",
                        "      type: \"choice\",",
                        "      default: \"bar\",",
                        "      description: \"foo description\",",
                        "      choices: [",
                        "        {",
                        "          value: \"bar\",",
                        "          description: \"bar description\"",
                        "        },",
                        "        {",
                        "          value: \"baz\",",
                        "          description: \"baz description\"",
                        "        }",
                        "      ]",
                        "    }",
                        "  },",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: (path, options) =>",
                        "        options.fooOption ? `foo:${options.fooOption}` : path.getValue().text",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "preprocess": {
                "file.foo": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"],",
                        "      since: \"1.0.0\"",
                        "    }",
                        "  ],",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      preprocess: text => `preprocessed:${text}`,",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: path => path.getValue().text",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            }
        }
    },
    "website": {
        ".eslintrc.yml": {},
        "README.md": {},
        "deploy.sh": {},
        "package.json": {},
        "sidebars.json": {},
        "siteConfig.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "// Docs: https://docusaurus.io/docs/en/site-config.html",
                "",
                "const parseYaml = require(\"js-yaml\").safeLoad;",
                "const path = require(\"path\");",
                "const fs = require(\"fs\");",
                "",
                "const PACKAGE = require(\"../package\");",
                "const GITHUB_URL = `https://github.com/${PACKAGE.repository}`;",
                "",
                "function loadYaml(fsPath) {",
                "  return parseYaml(fs.readFileSync(path.join(__dirname, fsPath), \"utf8\"));",
                "}",
                "",
                "const users = loadYaml(\"./data/users.yml\");",
                "const editors = loadYaml(\"./data/editors.yml\");",
                "const supportedLanguages = loadYaml(\"./data/languages.yml\");",
                "",
                "const siteConfig = {",
                "  title: \"Prettier\",",
                "  tagline: \"Opinionated Code Formatter\",",
                "  githubUrl: GITHUB_URL,",
                "  url: PACKAGE.homepage,",
                "  baseUrl: \"/\",",
                "  projectName: PACKAGE.name,",
                "  repo: PACKAGE.repository,",
                "  cname: \"prettier.io\",",
                "  users,",
                "  editors,",
                "  supportedLanguages,",
                "  /* base url for editing docs, usage example: editUrl + 'en/doc1.md' */",
                "  editUrl: `${GITHUB_URL}/edit/master/docs/`,",
                "  headerLinks: [",
                "    { href: \"/playground/\", label: \"Playground\" },",
                "    { doc: \"index\", label: \"About\" },",
                "    { doc: \"install\", label: \"Usage\" },",
                "    { blog: true, label: \"Blog\" },",
                "    { search: true },",
                "    { href: GITHUB_URL, label: \"GitHub\" }",
                "  ],",
                "  /* path to images for header/footer */",
                "  headerIcon: \"icon.png\",",
                "  footerIcon: \"icon.png\",",
                "  favicon: \"icon.png\",",
                "  /* colors for website */",
                "  colors: {",
                "    primaryColor: \"#1A2B34\",",
                "    secondaryColor: \"#808080\"",
                "  },",
                "  highlight: {",
                "    theme: \"default\"",
                "  },",
                "  useEnglishUrl: true,",
                "  scripts: [\"https://buttons.github.io/buttons.js\"],",
                "  algolia: {",
                "    apiKey: process.env.ALGOLIA_PRETTIER_API_KEY,",
                "    indexName: \"prettier\"",
                "  },",
                "  markdownPlugins: [",
                "    // ignore `<!-- prettier-ignore -->` before passing into Docusaurus to avoid mis-parsing (#3322)",
                "    md => {",
                "      md.block.ruler.before(",
                "        \"htmlblock\",",
                "        \"prettierignore\",",
                "        (state, startLine) => {",
                "          const pos = state.bMarks[startLine];",
                "          const max = state.eMarks[startLine];",
                "          if (/<!-- prettier-ignore -->/.test(state.src.slice(pos, max))) {",
                "            state.line += 1;",
                "            return true;",
                "          }",
                "          return false;",
                "        }",
                "      );",
                "    }",
                "  ],",
                "  separateCss: [\"static/separate-css\"],",
                "  gaTrackingId: \"UA-111350464-1\",",
                "  twitter: true",
                "};",
                "",
                "module.exports = siteConfig;"
            ]
        },
        "svgo.yml": {},
        "yarn.lock": {},
        "blog": {
            "2017-04-13-1.0.0.md": {},
            "2017-04-20-1.2.0.md": {},
            "2017-05-03-1.3.0.md": {},
            "2017-06-03-1.4.0.md": {},
            "2017-06-28-1.5.0.md": {},
            "2017-08-29-1.6.0.md": {},
            "2017-09-15-1.7.0.md": {},
            "2017-11-07-1.8.0.md": {},
            "2017-12-05-1.9.0.md": {},
            "2018-01-10-1.10.0.md": {},
            "2018-02-26-1.11.0.md": {}
        },
        "core": {
            "Footer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const React = require(\"react\");",
                    "",
                    "const GithubButton = props => (",
                    "  <a",
                    "    className=\"github-button\"",
                    "    href={props.config.githubUrl}",
                    "    data-icon=\"octicon-star\"",
                    "    data-show-count=\"true\"",
                    "    aria-label=\"Star this project on GitHub\"",
                    "  >",
                    "    Star",
                    "  </a>",
                    ");",
                    "",
                    "GithubButton.propTypes = {",
                    "  config: React.PropTypes.object",
                    "};",
                    "",
                    "class Footer extends React.Component {",
                    "  url(path) {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}docs/${language}${path}`;",
                    "  }",
                    "",
                    "  usersUrl() {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}${language}/users`;",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <footer className=\"footerSection nav-footer\" id=\"footer\">",
                    "        <section className=\"sitemap\">",
                    "          <a href={this.props.config.baseUrl} className=\"nav-home\">",
                    "            <img",
                    "              src={this.props.config.baseUrl + this.props.config.footerIcon}",
                    "              alt={this.props.config.title}",
                    "            />",
                    "          </a>",
                    "          <div>",
                    "            <h5>Docs</h5>",
                    "            <a href={this.url(\"/index.html\")}>About</a>",
                    "            <a href={this.url(\"/install.html\")}>Usage</a>",
                    "          </div>",
                    "          <div>",
                    "            <h5>Community</h5>",
                    "            <a href={this.usersUrl()}>User Showcase</a>",
                    "            <a",
                    "              href=\"http://stackoverflow.com/questions/tagged/prettier\"",
                    "              target=\"_blank\"",
                    "              rel=\"noopener noreferrer\"",
                    "            >",
                    "              Stack Overflow",
                    "            </a>",
                    "            <a href=\"https://gitter.im/jlongster/prettier\">Chat on Gitter</a>",
                    "            <a href=\"https://twitter.com/PrettierCode\">",
                    "              @PrettierCode on Twitter",
                    "            </a>",
                    "            <object",
                    "              type=\"image/svg+xml\"",
                    "              data=\"https://img.shields.io/twitter/follow/prettiercode.svg?label=Follow+Prettier&style=social\"",
                    "            >",
                    "              <a href=\"https://twitter.com/intent/follow?screen_name=prettiercode\">",
                    "                <img",
                    "                  alt=\"Follow Prettier on Twitter\"",
                    "                  src=\"https://img.shields.io/twitter/follow/prettiercode.png?label=Follow+Prettier&style=social\"",
                    "                />",
                    "              </a>",
                    "            </object>",
                    "          </div>",
                    "          <div>",
                    "            <h5>More</h5>",
                    "            <a href={this.props.config.baseUrl + \"blog\"}>Blog</a>",
                    "            <a href={this.props.config.githubUrl}>GitHub</a>",
                    "            <a href={this.props.config.githubUrl + \"/issues\"}>Issues</a>",
                    "            <GithubButton config={this.props.config} />",
                    "          </div>",
                    "        </section>",
                    "      </footer>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "Footer.propTypes = {",
                    "  language: React.PropTypes.string,",
                    "  config: React.PropTypes.object",
                    "};",
                    "",
                    "module.exports = Footer;"
                ]
            }
        },
        "data": {
            "editors.yml": {},
            "languages.yml": {},
            "users.yml": {}
        },
        "pages": {
            "googlefe164a33bda4034b.html": {},
            "en": {
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const React = require(\"react\");",
                        "",
                        "const CompLibrary = require(\"../../core/CompLibrary.js\");",
                        "const MarkdownBlock = CompLibrary.MarkdownBlock;",
                        "const Container = CompLibrary.Container;",
                        "const AnimatedLogo = require(\"@sandhose/prettier-animated-logo\");",
                        "",
                        "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                        "",
                        "const ButtonGroup = props => (",
                        "  <div className=\"buttonGroup buttonWrapper\">{props.children}</div>",
                        ");",
                        "",
                        "ButtonGroup.propTypes = {",
                        "  children: React.PropTypes.node",
                        "};",
                        "",
                        "class Button extends React.Component {",
                        "  render() {",
                        "    return (",
                        "      <div className=\"pluginWrapper buttonWrapper\">",
                        "        <a className=\"button\" href={this.props.href} target={this.props.target}>",
                        "          {this.props.children}",
                        "        </a>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Button.defaultProps = {",
                        "  target: \"_self\"",
                        "};",
                        "",
                        "Button.propTypes = {",
                        "  href: React.PropTypes.string,",
                        "  target: React.PropTypes.string,",
                        "  children: React.PropTypes.any",
                        "};",
                        "",
                        "const HomeSplash = props => {",
                        "  return (",
                        "    <div className=\"homeContainer\">",
                        "      <div className=\"homeSplashFade\">",
                        "        <div className=\"wrapper homeWrapper\">",
                        "          <div className=\"animatedLogoWrapper\">",
                        "            <AnimatedLogo version=\"wide\" />",
                        "          </div>",
                        "          <div className=\"inner\">",
                        "            <div className=\"section promoSection\">",
                        "              <div className=\"promoRow\">",
                        "                <div className=\"pluginRowBlock\">",
                        "                  <Button href=\"/playground/\">Try It Out</Button>",
                        "                  <Button href={\"/docs/\" + props.language + \"/install.html\"}>",
                        "                    Get Started",
                        "                  </Button>",
                        "                  <Button href={\"/docs/\" + props.language + \"/options.html\"}>",
                        "                    Options",
                        "                  </Button>",
                        "                </div>",
                        "              </div>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </div>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "HomeSplash.propTypes = {",
                        "  language: React.PropTypes.string",
                        "};",
                        "",
                        "const TldrSection = ({ language }) => (",
                        "  <div className=\"tldrSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-evenly\"",
                        "        }}",
                        "      >",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>What is Prettier?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>An opinionated code formatter</li>",
                        "            <li>Supports many languages</li>",
                        "            <li>Integrates with most editors</li>",
                        "            <li>Has few options</li>",
                        "          </ul>",
                        "        </div>",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>Why?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>You press save and code is formatted</li>",
                        "            <li>No need to discuss style in code review</li>",
                        "            <li>Saves you time and energy</li>",
                        "            <li>",
                        "              <a href={\"/docs/\" + language + \"/why-prettier.html\"}>And more</a>",
                        "            </li>",
                        "          </ul>",
                        "        </div>",
                        "      </div>",
                        "    </Container>",
                        "  </div>",
                        ");",
                        "",
                        "TldrSection.propTypes = {",
                        "  language: React.PropTypes.string",
                        "};",
                        "",
                        "const Language = ({ name, showName, image, variants }) => (",
                        "  <div",
                        "    className=\"languageCategory\"",
                        "    style={{",
                        "      display: \"flex\",",
                        "      alignItems: \"flex-start\",",
                        "      paddingBottom: \"1em\"",
                        "    }}",
                        "  >",
                        "    <img src={image} style={{ width: \"50px\", padding: \"0 20px\" }} />",
                        "    <div>",
                        "      {showName && <p className=\"accented\">{name}</p>}",
                        "      {variants.map(variant => (",
                        "        <code key={variant}>",
                        "          <MarkdownBlock>{variant}</MarkdownBlock>",
                        "        </code>",
                        "      ))}",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "Language.propTypes = {",
                        "  name: React.PropTypes.string,",
                        "  showName: React.PropTypes.boolean,",
                        "  image: React.PropTypes.string,",
                        "  variants: React.PropTypes.array",
                        "};",
                        "",
                        "const LanguagesSection = () => {",
                        "  const languageChunks = siteConfig.supportedLanguages.reduce(",
                        "    (acc, language) => {",
                        "      const last = acc[acc.length - 1];",
                        "      if (",
                        "        last &&",
                        "        last.length < 2 &&",
                        "        last.reduce((sum, lang) => sum + lang.variants.length, 0) +",
                        "          language.variants.length <",
                        "          5",
                        "      ) {",
                        "        last.push(language);",
                        "      } else {",
                        "        acc.push([language]);",
                        "      }",
                        "      return acc;",
                        "    },",
                        "    []",
                        "  );",
                        "",
                        "  return (",
                        "    <div",
                        "      className=\"languagesSection productShowcaseSection\"",
                        "      style={{ textAlign: \"center\" }}",
                        "    >",
                        "      <Container>",
                        "        <h2>Works with the Tools You Use</h2>",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\"",
                        "          }}",
                        "        >",
                        "          {languageChunks.map((languageChunk, index) => (",
                        "            <div key={index} style={{ flex: \"1 1 auto\" }}>",
                        "              {languageChunk.map(language => (",
                        "                <Language key={language.name} {...language} />",
                        "              ))}",
                        "            </div>",
                        "          ))}",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "const Editor = ({ content = \"\", image, name }) => (",
                        "  <div className=\"editor\">",
                        "    <img className=\"editorImage\" src={image} />",
                        "    <div className=\"editorInfo\">",
                        "      <h3 style={{ marginBottom: \"-16px\" }}>{name}</h3>",
                        "      <MarkdownBlock>{content.replace(/\\n/g, \"  \\n\")}</MarkdownBlock>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "Editor.propTypes = {",
                        "  content: React.PropTypes.string,",
                        "  image: React.PropTypes.string.isRequired,",
                        "  name: React.PropTypes.string.isRequired",
                        "};",
                        "",
                        "const EditorSupportSection = () => (",
                        "  <div className=\"editorSupportSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <h2>Editor Support</h2>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-around\"",
                        "        }}",
                        "      >",
                        "        {siteConfig.editors.map(editor => (",
                        "          <Editor key={editor.name} {...editor} />",
                        "        ))}",
                        "      </div>",
                        "    </Container>",
                        "",
                        "    <div style={{ float: \"right\" }}>",
                        "      <span>Got more? </span>",
                        "      <a",
                        "        href={`${siteConfig.githubUrl}/edit/master/website/data/editors.yml`}",
                        "        className=\"button\"",
                        "      >",
                        "        Send a PR",
                        "      </a>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "const bash = (...args) => `~~~bash\\n${String.raw(...args)}\\n~~~`;",
                        "",
                        "const json = object => `~~~json\\n${JSON.stringify(object, null, 2)}\\n~~~`;",
                        "",
                        "class GetStartedSection extends React.Component {",
                        "  constructor(props) {",
                        "    super(props);",
                        "    this.state = {",
                        "      npmClient: \"yarn\"",
                        "    };",
                        "  }",
                        "",
                        "  render() {",
                        "    return (",
                        "      <div className=\"getStartedSection productShowcaseSection\">",
                        "        <Container>",
                        "          <div",
                        "            className=\"getStartedFlexContainer\"",
                        "            style={{",
                        "              display: \"flex\",",
                        "              flexFlow: \"row\",",
                        "              alignItems: \"baseline\",",
                        "              justifyContent: \"space-between\"",
                        "            }}",
                        "          >",
                        "            <div className=\"getStartedSteps\">",
                        "              <h2>Get Started</h2>",
                        "              <ol>",
                        "                <li>",
                        "                  Add prettier to your project:",
                        "                  <div className=\"yarnOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`yarn add prettier --dev --exact`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                  <div className=\"npmOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`npm install prettier --save-dev --save-exact`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                </li>",
                        "                <li>",
                        "                  Verify by running against a file:",
                        "                  <div className=\"yarnOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`yarn prettier --write src/index.js`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                  <div className=\"npmOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`npx prettier --write src/index.js`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                </li>",
                        "                <li>",
                        "                  Run prettier when commiting files:",
                        "                  <div className=\"yarnOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`yarn add pretty-quick husky --dev`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                  <div className=\"npmOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`npm install pretty-quick husky --save-dev`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                  Then edit <code>package.json</code>:",
                        "                  <MarkdownBlock>",
                        "                    {json({",
                        "                      scripts: {",
                        "                        precommit: \"pretty-quick --staged\"",
                        "                      }",
                        "                    })}",
                        "                  </MarkdownBlock>",
                        "                </li>",
                        "              </ol>",
                        "            </div>",
                        "            <div",
                        "              style={{",
                        "                display: \"flex\",",
                        "                flexDirection: \"column\",",
                        "                alignItems: \"flex-end\",",
                        "                flexGrow: 1,",
                        "                marginLeft: \"-75px\"",
                        "              }}",
                        "            >",
                        "              <ButtonGroup>",
                        "                <a className=\"button active showYarnButton\" href=\"#\">",
                        "                  yarn",
                        "                </a>",
                        "                <a className=\"button showNpmButton\" href=\"#\">",
                        "                  npm",
                        "                </a>",
                        "              </ButtonGroup>",
                        "              <img",
                        "                className=\"decorativeRects\"",
                        "                style={{",
                        "                  marginTop: \"32px\"",
                        "                }}",
                        "                src=\"/images/get_started_rects.svg\"",
                        "              />",
                        "            </div>",
                        "          </div>",
                        "        </Container>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "const UsersSection = ({ language }) => {",
                        "  const showcase = siteConfig.users",
                        "    .filter(user => {",
                        "      return user.pinned;",
                        "    })",
                        "    .map((user, i) => {",
                        "      return (",
                        "        <a key={i} className=\"growOnHover\" href={user.infoLink}>",
                        "          <img className=\"user\" src={user.greyImage} title={user.caption} />",
                        "        </a>",
                        "      );",
                        "    });",
                        "",
                        "  return (",
                        "    <div className=\"usersSection productShowcaseSection lightBackground\">",
                        "      <Container>",
                        "        <h2>Used By People You Rely On</h2>",
                        "        <div style={{ textAlign: \"right\" }} />",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\"",
                        "          }}",
                        "        >",
                        "          {showcase}",
                        "        </div>",
                        "        <div className=\"more-users\">",
                        "          <a",
                        "            className=\"button\"",
                        "            href={siteConfig.baseUrl + language + \"/users/\"}",
                        "            target=\"_self\"",
                        "          >",
                        "            See All Others",
                        "          </a>",
                        "          <a",
                        "            className=\"button\"",
                        "            href={`${siteConfig.githubUrl}/edit/master/website/data/users.yml`}",
                        "          >",
                        "            Add Your Project",
                        "          </a>",
                        "        </div>",
                        "",
                        "        <h2 className=\"ecosystemSubHeader\">Established in the Ecosystem</h2>",
                        "        <div",
                        "          className=\"ecosystemSubSection\"",
                        "          style={{",
                        "            display: \"flex\",",
                        "            justifyContent: \"space-around\",",
                        "            flexFlow: \"row wrap\"",
                        "          }}",
                        "        >",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://npmjs.com/package/prettier\"",
                        "              className=\"growOnHover\"",
                        "            >",
                        "              <img src=\"/images/npm_grey.svg\" style={{ height: \"100px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>More than 500 tools and integrations on npm</p>",
                        "              <Button href=\"https://www.npmjs.com/browse/depended/prettier\">",
                        "                Install Them",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://github.com/prettier/prettier\"",
                        "              className=\"growOnHover\"",
                        "            >",
                        "              <img src=\"/images/github_grey.svg\" style={{ height: \"100px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>More than 80,000 dependent repositories on GitHub</p>",
                        "              <Button href=\"https://github.com/prettier/prettier/network/dependents\">",
                        "                Check Them Out",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "UsersSection.propTypes = {",
                        "  language: React.PropTypes.string",
                        "};",
                        "",
                        "class Index extends React.Component {",
                        "  render() {",
                        "    const language = this.props.language || \"en\";",
                        "",
                        "    return (",
                        "      <div>",
                        "        <script src=\"landing.js\" />",
                        "        <HomeSplash language={language} />",
                        "        <div className=\"mainContainer\">",
                        "          <TldrSection language={language} />",
                        "          <LanguagesSection />",
                        "          <EditorSupportSection />",
                        "          <GetStartedSection />",
                        "          <UsersSection language={language} />",
                        "        </div>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Index.propTypes = {",
                        "  language: React.PropTypes.string",
                        "};",
                        "",
                        "module.exports = Index;"
                    ]
                },
                "help": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "",
                            "const CompLibrary = require(\"../../../core/CompLibrary.js\");",
                            "const Container = CompLibrary.Container;",
                            "const GridBlock = CompLibrary.GridBlock;",
                            "",
                            "class Help extends React.Component {",
                            "  render() {",
                            "    const supportLinks = [",
                            "      {",
                            "        content:",
                            "          \"Learn more using the [documentation on this site.](/docs/en/why-prettier.html)\\n\",",
                            "        title: \"Browse Docs\"",
                            "      },",
                            "      {",
                            "        content: \"Ask questions about the documentation and project\\n\",",
                            "        title: \"Join the community\"",
                            "      },",
                            "      {",
                            "        content: \"Find out what's new with this project\\n\",",
                            "        title: \"Stay up to date\"",
                            "      }",
                            "    ];",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"docMainWrapper wrapper\">",
                            "          <Container className=\"mainContainer documentContainer postContainer\">",
                            "            <div className=\"post\">",
                            "              <header className=\"postHeader\">",
                            "                <h2>Need help?</h2>",
                            "              </header>",
                            "              <p>This project is maintained by a dedicated group of people;</p>",
                            "              <GridBlock contents={supportLinks} layout=\"threeColumn\" />",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Help.defaultProps = {",
                            "  language: \"en\"",
                            "};",
                            "",
                            "module.exports = Help;"
                        ]
                    }
                },
                "users": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "",
                            "const CompLibrary = require(\"../../../core/CompLibrary.js\");",
                            "const Container = CompLibrary.Container;",
                            "",
                            "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                            "",
                            "class Users extends React.Component {",
                            "  render() {",
                            "    const showcase = siteConfig.users.map((user, i) => {",
                            "      return (",
                            "        <a key={i} href={user.infoLink}>",
                            "          <img src={user.image} title={user.caption} />",
                            "        </a>",
                            "      );",
                            "    });",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"mainContainer\">",
                            "          <Container padding={[\"bottom\", \"top\"]}>",
                            "            <div className=\"showcaseSection\">",
                            "              <div className=\"prose\">",
                            "                <h1>Who{\"'\"}s Using This?</h1>",
                            "                <p>",
                            "                  A few of the{\" \"}",
                            "                  <a href=\"https://www.npmjs.com/browse/depended/prettier\">",
                            "                    many projects",
                            "                  </a>{\" \"}",
                            "                  using Prettier",
                            "                </p>",
                            "              </div>",
                            "              <div className=\"logos\">{showcase}</div>",
                            "              <div className=\"prose\">",
                            "                <p>Are you using this project?</p>",
                            "              </div>",
                            "              <a",
                            "                href={`${",
                            "                  siteConfig.githubUrl",
                            "                }/edit/master/website/data/users.yml`}",
                            "                className=\"button\"",
                            "              >",
                            "                Add your company",
                            "              </a>",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Users.defaultProps = {",
                            "  language: \"en\"",
                            "};",
                            "",
                            "module.exports = Users;"
                        ]
                    }
                }
            },
            "playground": {
                "index.html": {}
            }
        },
        "static": {
            "icon.png": {},
            "install-service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/* eslint-env browser */",
                    "",
                    "if (\"serviceWorker\" in navigator) {",
                    "  navigator.serviceWorker.register(\"/service-worker.js\", {",
                    "    scope: \"/playground/\"",
                    "  });",
                    "}"
                ]
            },
            "landing.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/* eslint-disable */",
                    "",
                    "if (location.hash.substring(1).startsWith(encodeURIComponent(\"{\"))) {",
                    "  location.pathname = \"/playground/\";",
                    "}",
                    "",
                    "window.addEventListener(\"load\", function() {",
                    "  // We don't have access to a unique body css attribute for just the homepage",
                    "  // so instead it is set on load. It's only really visible on a vertical overscroll",
                    "  document.body.style.backgroundColor = \"rgb(24, 32, 37)\";",
                    "",
                    "  var logoWrapper = document.querySelector(\".animatedLogoWrapper\");",
                    "  var logo = document.querySelector(\".prettier-logo-wide\");",
                    "  var lastDash = logo.querySelector(\"g:last-of-type path:last-of-type\");",
                    "",
                    "  function handleLogoDrag(event) {",
                    "    logo.classList.add(\"rolling\");",
                    "    event.preventDefault();",
                    "  }",
                    "",
                    "  logoWrapper.setAttribute(\"draggable\", \"true\");",
                    "  logoWrapper.addEventListener(\"touchstart\", handleLogoDrag);",
                    "  logoWrapper.addEventListener(\"dragstart\", handleLogoDrag);",
                    "",
                    "  lastDash.addEventListener(\"animationend\", function(event) {",
                    "    if (event.animationName.match(/roll/)) {",
                    "      logo.classList.remove(\"rolling\");",
                    "    }",
                    "  });",
                    "",
                    "  var yarnButton = document.querySelector(\".showYarnButton\");",
                    "  var npmButton = document.querySelector(\".showNpmButton\");",
                    "  var getStartedSection = document.querySelector(\".getStartedSection\");",
                    "",
                    "  npmButton.addEventListener(\"click\", function(event) {",
                    "    event.preventDefault();",
                    "    npmButton.classList.add(\"active\");",
                    "    yarnButton.classList.remove(\"active\");",
                    "    getStartedSection.classList.add(\"getStartedSection--npm\");",
                    "  });",
                    "  yarnButton.addEventListener(\"click\", function(event) {",
                    "    event.preventDefault();",
                    "    yarnButton.classList.add(\"active\");",
                    "    npmButton.classList.remove(\"active\");",
                    "    getStartedSection.classList.remove(\"getStartedSection--npm\");",
                    "  });",
                    "});"
                ]
            },
            "manifest.json": {},
            "markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* eslint-env browser */",
                    "/* eslint no-var: off, strict: off, prefer-arrow-callback: off */",
                    "",
                    "// NOTE: This file must work both in the playground, and in the build scripts to",
                    "// generate the issue template.",
                    "",
                    "(function() {",
                    "  function formatMarkdown(",
                    "    input,",
                    "    output,",
                    "    output2,",
                    "    version,",
                    "    url,",
                    "    options,",
                    "    cliOptions,",
                    "    full",
                    "  ) {",
                    "    var syntax = getMarkdownSyntax(options);",
                    "    var optionsString = formatCLIOptions(cliOptions);",
                    "    var isIdempotent = output2 === \"\" || output === output2;",
                    "",
                    "    return [",
                    "      \"**Prettier \" + version + \"**\",",
                    "      \"[Playground link](\" + url + \")\",",
                    "      optionsString === \"\" ? null : codeBlock(optionsString, \"sh\"),",
                    "      \"\",",
                    "      \"**Input:**\",",
                    "      codeBlock(input, syntax),",
                    "      \"\",",
                    "      \"**Output:**\",",
                    "      codeBlock(output, syntax)",
                    "    ]",
                    "      .concat(",
                    "        isIdempotent",
                    "          ? []",
                    "          : [\"\", \"**Second Output:**\", codeBlock(output2, syntax)]",
                    "      )",
                    "      .concat(full ? [\"\", \"**Expected behavior:**\", \"\"] : [])",
                    "      .filter(function(part) {",
                    "        return part != null;",
                    "      })",
                    "      .join(\"\\n\");",
                    "  }",
                    "",
                    "  function getMarkdownSyntax(options) {",
                    "    switch (options.parser) {",
                    "      case \"babylon\":",
                    "      case \"flow\":",
                    "        return \"jsx\";",
                    "      case \"typescript\":",
                    "        return \"tsx\";",
                    "      default:",
                    "        return options.parser;",
                    "    }",
                    "  }",
                    "",
                    "  function formatCLIOptions(cliOptions) {",
                    "    return cliOptions",
                    "      .map(function(option) {",
                    "        var name = option[0];",
                    "        var value = option[1];",
                    "        return value === true ? name : name + \" \" + value;",
                    "      })",
                    "      .join(\"\\n\");",
                    "  }",
                    "",
                    "  function codeBlock(content, syntax) {",
                    "    var backtickSequences = content.match(/`+/g) || [];",
                    "    var longestBacktickSequenceLength = Math.max.apply(",
                    "      null,",
                    "      backtickSequences.map(function(backticks) {",
                    "        return backticks.length;",
                    "      })",
                    "    );",
                    "    var fenceLength = Math.max(3, longestBacktickSequenceLength + 1);",
                    "    var fence = Array(fenceLength + 1).join(\"`\");",
                    "    return [fence + (syntax || \"\"), content, fence].join(\"\\n\");",
                    "  }",
                    "",
                    "  if (typeof module !== \"undefined\" && module.exports) {",
                    "    module.exports = formatMarkdown;",
                    "  } else {",
                    "    window.formatMarkdown = formatMarkdown;",
                    "  }",
                    "})();"
                ]
            },
            "overrides.css": {},
            "playground.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* eslint-env browser */",
                    "/* eslint no-var: off, strict: off, prefer-arrow-callback: off */",
                    "/* global Clipboard CodeMirror formatMarkdown LZString */",
                    "",
                    "var prettierVersion = \"?\";",
                    "var inputEditor;",
                    "var docEditor;",
                    "var astEditor;",
                    "var outputEditor;",
                    "var output2Editor;",
                    "",
                    "var OPTIONS = [",
                    "  \"printWidth\",",
                    "  \"tabWidth\",",
                    "  \"singleQuote\",",
                    "  \"trailingComma\",",
                    "  \"bracketSpacing\",",
                    "  \"jsxBracketSameLine\",",
                    "  \"parser\",",
                    "  \"semi\",",
                    "  \"useTabs\",",
                    "  \"insertPragma\",",
                    "  \"requirePragma\",",
                    "  \"proseWrap\",",
                    "  \"arrowParens\",",
                    "  \"doc\",",
                    "  \"ast\",",
                    "  \"output2\"",
                    "];",
                    "",
                    "var IDEMPOTENT_MESSAGE = \" Second format is unchanged.\";",
                    "",
                    "var worker = new Worker(\"/worker.js\");",
                    "",
                    "const DEFAULT_OPTIONS = {",
                    "  options: undefined,",
                    "  content: \"\"",
                    "};",
                    "",
                    "window.onload = function() {",
                    "  var state = (function loadState(hash) {",
                    "    var parsed;",
                    "    try {",
                    "      // providing backwards support for old json encoded URIComponent",
                    "      if (hash.indexOf(\"%7B%22\") !== -1) {",
                    "        parsed = JSON.parse(decodeURIComponent(hash));",
                    "      } else {",
                    "        parsed = JSON.parse(LZString.decompressFromEncodedURIComponent(hash));",
                    "      }",
                    "    } catch (error) {",
                    "      return DEFAULT_OPTIONS;",
                    "    }",
                    "    // Support old links with the deprecated \"postcss\" value for the parser option.",
                    "    if (parsed && parsed.options && parsed.options.parser === \"postcss\") {",
                    "      parsed.options.parser = \"css\";",
                    "    }",
                    "",
                    "    return parsed || DEFAULT_OPTIONS;",
                    "  })(location.hash.slice(1));",
                    "",
                    "  worker.onmessage = function(message) {",
                    "    if (prettierVersion === \"?\") {",
                    "      prettierVersion = message.data.version;",
                    "",
                    "      var link = document.createElement(\"a\");",
                    "      var match = prettierVersion.match(/^\\d+\\.\\d+\\.\\d+-pr.(\\d+)$/);",
                    "      if (match) {",
                    "        link.href = \"https://github.com/prettier/prettier/pull/\" + match[1];",
                    "        link.textContent = \"PR #\" + match[1];",
                    "        prettierVersion = \"pr-\" + match[1];",
                    "      } else {",
                    "        if (prettierVersion.match(/\\.0$/)) {",
                    "          link.href =",
                    "            \"https://github.com/prettier/prettier/releases/tag/\" +",
                    "            prettierVersion;",
                    "        } else {",
                    "          link.href =",
                    "            \"https://github.com/prettier/prettier/blob/master/CHANGELOG.md#\" +",
                    "            prettierVersion.replace(/\\./g, \"\");",
                    "        }",
                    "        link.textContent = \"v\" + prettierVersion;",
                    "      }",
                    "      document.getElementById(\"version\").appendChild(link);",
                    "    }",
                    "    if (outputEditor && docEditor && astEditor) {",
                    "      outputEditor.setValue(message.data.formatted);",
                    "      docEditor.setValue(message.data.doc || \"\");",
                    "      astEditor.setValue(message.data.ast || \"\");",
                    "      output2Editor.setValue(",
                    "        message.data.formatted === \"\"",
                    "          ? \"\"",
                    "          : message.data.formatted2 === message.data.formatted",
                    "            ? IDEMPOTENT_MESSAGE",
                    "            : message.data.formatted2 || \"\"",
                    "      );",
                    "      document.getElementById(\"button-report-issue\").search =",
                    "        \"body=\" + encodeURIComponent(createMarkdown(true));",
                    "    }",
                    "  };",
                    "",
                    "  // Warm up the worker (load the current parser while CodeMirror loads)",
                    "  worker.postMessage({ text: \"\", options: state.options });",
                    "",
                    "  state.options && setOptions(state.options);",
                    "",
                    "  var editorOptions = {",
                    "    lineNumbers: true,",
                    "    keyMap: \"sublime\",",
                    "    autoCloseBrackets: true,",
                    "    matchBrackets: true,",
                    "    showCursorWhenSelecting: true,",
                    "    tabWidth: 2,",
                    "    mode: \"jsx\"",
                    "  };",
                    "  inputEditor = CodeMirror.fromTextArea(",
                    "    document.getElementById(\"input-editor\"),",
                    "    editorOptions",
                    "  );",
                    "  docEditor = CodeMirror.fromTextArea(document.getElementById(\"doc-editor\"), {",
                    "    readOnly: true,",
                    "    lineNumbers: false,",
                    "    mode: \"jsx\"",
                    "  });",
                    "  astEditor = CodeMirror.fromTextArea(document.getElementById(\"ast-editor\"), {",
                    "    readOnly: true,",
                    "    lineNumbers: false,",
                    "    mode: \"jsx\"",
                    "  });",
                    "  outputEditor = CodeMirror.fromTextArea(",
                    "    document.getElementById(\"output-editor\"),",
                    "    {",
                    "      readOnly: true,",
                    "      lineNumbers: true,",
                    "      mode: \"jsx\"",
                    "    }",
                    "  );",
                    "  output2Editor = CodeMirror.fromTextArea(",
                    "    document.getElementById(\"output2-editor\"),",
                    "    {",
                    "      readOnly: true,",
                    "      lineNumbers: true,",
                    "      mode: \"jsx\"",
                    "    }",
                    "  );",
                    "",
                    "  var editors = document.querySelectorAll(\".editor\");",
                    "  for (var i = 0; i < editors.length; i++) {",
                    "    editors[i].classList.remove(\"loading\");",
                    "  }",
                    "",
                    "  setEditorStyles();",
                    "",
                    "  inputEditor.setValue(state.content);",
                    "  inputEditor.on(\"change\", formatAsync);",
                    "  formatAsync();",
                    "",
                    "  document.querySelector(\".options-container\").onchange = formatAsync;",
                    "",
                    "  document.getElementById(\"button-clear\").onclick = function() {",
                    "    inputEditor.setValue(\"\");",
                    "  };",
                    "",
                    "  var optionsElement = document.getElementById(\"options-details\");",
                    "  document.getElementById(\"button-options\").onclick = function() {",
                    "    var classes = optionsElement.classList;",
                    "    if (classes.contains(\"open\")) {",
                    "      classes.remove(\"open\");",
                    "      this.innerHTML = \"Show options\";",
                    "    } else {",
                    "      classes.add(\"open\");",
                    "      this.innerHTML = \"Hide options\";",
                    "    }",
                    "  };",
                    "",
                    "  var clipboard = new Clipboard(\"#button-copy-link, #button-copy-markdown\", {",
                    "    text: function(trigger) {",
                    "      switch (trigger.id) {",
                    "        case \"button-copy-link\":",
                    "          return window.location.href;",
                    "        case \"button-copy-markdown\":",
                    "          return createMarkdown();",
                    "        default:",
                    "          return \"\";",
                    "      }",
                    "    }",
                    "  });",
                    "  clipboard.on(\"success\", function(e) {",
                    "    showTooltip(e.trigger, \"Copied!\");",
                    "  });",
                    "  clipboard.on(\"error\", function(e) {",
                    "    showTooltip(e.trigger, \"Press ctrl+c to copy\");",
                    "  });",
                    "};",
                    "",
                    "function setOptions(options) {",
                    "  OPTIONS.forEach(function(option) {",
                    "    var elem = document.getElementById(option);",
                    "    if (elem.tagName === \"SELECT\") {",
                    "      elem.value = options[option];",
                    "    } else if (elem.type === \"number\") {",
                    "      elem.value = options[option];",
                    "    } else {",
                    "      var isInverted = elem.hasAttribute(\"data-inverted\");",
                    "      elem.checked = isInverted ? !options[option] : options[option];",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function getOptions() {",
                    "  var options = {};",
                    "  OPTIONS.forEach(function(option) {",
                    "    var elem = document.getElementById(option);",
                    "    if (elem.tagName === \"SELECT\") {",
                    "      options[option] = elem.value;",
                    "    } else if (elem.type === \"number\") {",
                    "      options[option] = Number(elem.value);",
                    "    } else {",
                    "      var isInverted = elem.hasAttribute(\"data-inverted\");",
                    "      options[option] = isInverted ? !elem.checked : elem.checked;",
                    "    }",
                    "  });",
                    "  return options;",
                    "}",
                    "",
                    "function getCLIOptions() {",
                    "  return OPTIONS.sort()",
                    "    .map(function(option) {",
                    "      var elem = document.getElementById(option);",
                    "      var match = elem.parentNode.textContent.match(/--\\S+/);",
                    "      if (!match) {",
                    "        return null;",
                    "      }",
                    "      var name = match[0];",
                    "      if (elem.tagName === \"SELECT\") {",
                    "        if (elem.value === elem.options[0].value) {",
                    "          return null;",
                    "        }",
                    "        return [name, elem.value];",
                    "      } else if (elem.type === \"number\") {",
                    "        if (elem.value === elem.getAttribute(\"value\")) {",
                    "          return null;",
                    "        }",
                    "        return [name, elem.value];",
                    "      } else if (elem.type === \"checkbox\") {",
                    "        if (!elem.checked) {",
                    "          return null;",
                    "        }",
                    "        return [name, true];",
                    "      }",
                    "      return null;",
                    "    })",
                    "    .filter(Boolean);",
                    "}",
                    "",
                    "function replaceHash(hash) {",
                    "  if (",
                    "    typeof URL === \"function\" &&",
                    "    typeof history === \"object\" &&",
                    "    typeof history.replaceState === \"function\"",
                    "  ) {",
                    "    var url = new URL(location);",
                    "    url.hash = hash;",
                    "    history.replaceState(null, null, url);",
                    "  } else {",
                    "    location.hash = hash;",
                    "  }",
                    "}",
                    "",
                    "function getCodemirrorMode(options) {",
                    "  switch (options.parser) {",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return \"css\";",
                    "    case \"markdown\":",
                    "      return \"markdown\";",
                    "    default:",
                    "      return \"jsx\";",
                    "  }",
                    "}",
                    "",
                    "function formatAsync() {",
                    "  var options = getOptions();",
                    "  setEditorStyles();",
                    "",
                    "  var value = LZString.compressToEncodedURIComponent(",
                    "    JSON.stringify(",
                    "      Object.assign({ content: inputEditor.getValue(), options: options })",
                    "    )",
                    "  );",
                    "  replaceHash(value);",
                    "  worker.postMessage({",
                    "    text: inputEditor.getValue() || getExample(options.parser),",
                    "    options: options,",
                    "    ast: options.ast,",
                    "    doc: options.doc,",
                    "    formatted2: options.output2",
                    "  });",
                    "}",
                    "",
                    "function setEditorStyles() {",
                    "  var options = getOptions();",
                    "",
                    "  inputEditor.setOption(\"placeholder\", getExample(options.parser));",
                    "",
                    "  var mode = getCodemirrorMode(options);",
                    "  inputEditor.setOption(\"mode\", mode);",
                    "  outputEditor.setOption(\"mode\", mode);",
                    "  output2Editor.setOption(\"mode\", mode);",
                    "",
                    "  inputEditor.setOption(\"rulers\", [",
                    "    { column: options.printWidth, color: \"#eeeeee\" }",
                    "  ]);",
                    "",
                    "  [outputEditor, output2Editor].forEach(function(editor) {",
                    "    editor.setOption(\"rulers\", [",
                    "      { column: options.printWidth, color: \"#444444\" }",
                    "    ]);",
                    "  });",
                    "  document.querySelector(\".ast\").style.display = options.ast ? \"\" : \"none\";",
                    "  document.querySelector(\".doc\").style.display = options.doc ? \"\" : \"none\";",
                    "  document.querySelector(\".output2\").style.display = options.output2",
                    "    ? \"\"",
                    "    : \"none\";",
                    "}",
                    "",
                    "function createMarkdown(full) {",
                    "  var output = outputEditor.getValue();",
                    "  var output2 = output2Editor.getValue();",
                    "  var options = getOptions();",
                    "  var input = inputEditor.getValue() || getExample(options.parser);",
                    "  var cliOptions = getCLIOptions();",
                    "  var markdown = formatMarkdown(",
                    "    input,",
                    "    output,",
                    "    output2 === IDEMPOTENT_MESSAGE ? \"\" : output2,",
                    "    prettierVersion,",
                    "    window.location.href,",
                    "    options,",
                    "    cliOptions,",
                    "    full",
                    "  );",
                    "  return markdown;",
                    "}",
                    "",
                    "function showTooltip(elem, text) {",
                    "  var tooltip = document.createElement(\"span\");",
                    "  tooltip.className = \"tooltip\";",
                    "  tooltip.textContent = text;",
                    "  elem.appendChild(tooltip);",
                    "  window.setTimeout(function() {",
                    "    elem.removeChild(tooltip);",
                    "  }, 2000);",
                    "}",
                    "",
                    "function getExample(parser) {",
                    "  switch (parser) {",
                    "    case \"babylon\":",
                    "      return [",
                    "        'function HelloWorld({greeting = \"hello\", greeted = \\'\"World\"\\', silent = false, onMouseOver,}) {',",
                    "        \"\",",
                    "        \"  if(!greeting){return null};\",",
                    "        \"\",",
                    "        \"     // TODO: Don't use random in render\",",
                    "        '  let num = Math.floor (Math.random() * 1E+7).toString().replace(/\\\\.\\\\d+/ig, \"\")',",
                    "        \"\",",
                    "        \"  return <div className='HelloWorld' title={`You are visitor number ${ num }`} onMouseOver={onMouseOver}>\",",
                    "        \"\",",
                    "        \"    <strong>{ greeting.slice( 0, 1 ).toUpperCase() + greeting.slice(1).toLowerCase() }</strong>\",",
                    "        '    {greeting.endsWith(\",\") ? \" \" : <span style={{color: \\'\\\\grey\\'}}>\", \"</span> }',",
                    "        \"    <em>\",",
                    "        \"\\t{ greeted }\",",
                    "        \"\\t</em>\",",
                    "        \"    { (silent)\",",
                    "        '      ? \".\"',",
                    "        '      : \"!\"}',",
                    "        \"\",",
                    "        \"    </div>;\",",
                    "        \"\",",
                    "        \"}\"",
                    "      ].join(\"\\n\");",
                    "    case \"flow\":",
                    "      return [",
                    "        \"declare export function graphql<Props, Variables, Component: React$ComponentType<Props>>\",",
                    "        \"  (query: GQLDocument, config?: Config<Props, QueryConfigOptions<Variables>>):\",",
                    "        \"  (Component: Component) => React$ComponentType<$Diff<React$ElementConfig<Component>, {\",",
                    "        \"    data: Object|void,\",",
                    "        \"    mutate: Function|void\",",
                    "        \"  }>>\",",
                    "        \"\",",
                    "        'declare type FetchPolicy = \"cache-first\" | \"cache-and-network\" | \"network-only\" | \"cache-only\"'",
                    "      ].join(\"\\n\");",
                    "    case \"typescript\":",
                    "      return [",
                    "        \"interface MyInterface {\",",
                    "        \"  foo(): string,\",",
                    "        \"  bar: Array<number>,\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"export abstract class Foo implements MyInterface {\",",
                    "        \"  foo() {\",",
                    "        \"            // TODO: return an actual value here\",",
                    "        \"        return 'hello'\",",
                    "        \"      }\",",
                    "        \"  get bar() {\",",
                    "        \"    return [  1,\",",
                    "        \"\",",
                    "        \"      2, 3,\",",
                    "        \"    ]\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"type RequestType = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'OPTIONS' | 'CONNECT' | 'DELETE' | 'TRACE'\"",
                    "      ].join(\"\\n\");",
                    "    case \"css\":",
                    "      // Excerpted from the Bootstrap source, which is licensed under the MIT license:",
                    "      // https://github.com/twbs/bootstrap/blob/v4.0.0-beta.3/LICENSE",
                    "      return [",
                    "        \"@media (max-width: 480px) {\",",
                    "        \"  .bd-examples {margin-right: -.75rem;margin-left: -.75rem\",",
                    "        \"  }\",",
                    "        \"  \",",
                    "        ' .bd-examples>[class^=\"col-\"]  {',",
                    "        \"    padding-right: .75rem;\",",
                    "        \"    padding-left: .75rem;\",",
                    "        \"  \",",
                    "        \"  }\",",
                    "        \"}\"",
                    "      ].join(\"\\n\");",
                    "    case \"scss\":",
                    "      // Excerpted from the Bootstrap source, which is licensed under the MIT license:",
                    "      // https://github.com/twbs/bootstrap/blob/v4.0.0-beta.3/LICENSE",
                    "      return [",
                    "        \"@function color-yiq($color) {\",",
                    "        \"  $r: red($color);$g: green($color);$b: blue($color);\",",
                    "        \"\",",
                    "        \"  $yiq: (($r * 299) + ($g * 587) + ($b * 114)) / 1000;\",",
                    "        \"\",",
                    "        \"  @if ($yiq >= $yiq-contrasted-threshold) {\",",
                    "        \"    @return $yiq-text-dark;\",",
                    "        \"} @else {\",",
                    "        \"    @return $yiq-text-light;\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"@each $color, $value in $colors {\",",
                    "        \"  .swatch-#{$color} {\",",
                    "        \"    color: color-yiq($value);\",",
                    "        \"    background-color: #{$value};\",",
                    "        \"  }\",",
                    "        \"}\"",
                    "      ].join(\"\\n\");",
                    "    case \"less\":",
                    "      // Copied from http://lesscss.org/features/#detached-rulesets-feature",
                    "      return [",
                    "        \"@my-ruleset: {\",",
                    "        \"    .my-selector {\",",
                    "        \"      @media tv {\",",
                    "        \"        background-color: black;\",",
                    "        \"      }\",",
                    "        \"    }\",",
                    "        \"  };\",",
                    "        \"@media (orientation:portrait) {\",",
                    "        \"    @my-ruleset();\",",
                    "        \"}\"",
                    "      ].join(\"\\n\");",
                    "    case \"json\":",
                    "      // Excerpted & adapted from Wikipedia, under the Creative Commons Attribution-ShareAlike License",
                    "      // https://en.wikipedia.org/wiki/JSON#Example",
                    "      return [",
                    "        '{\"allOn\": \"Single\", \"Line\": \"example\",',",
                    "        '\"noSpace\":true,',",
                    "        '  \"quote\": {',",
                    "        \"    'singleQuote': 'example',\",",
                    "        '                  \"indented\": true,',",
                    "        \"  },\",",
                    "        '  \"phoneNumbers\": [',",
                    "        '    {\"type\": \"home\",',",
                    "        '      \"number\": \"212 555-1234\"},',",
                    "        '    {\"type\": \"office\",',",
                    "        '      \"trailing\": \"commas by accident\"},',",
                    "        \"  ],\",",
                    "        \"}\"",
                    "      ].join(\"\\n\");",
                    "    case \"graphql\":",
                    "      return [",
                    "        \"query Browse($offset: Int, $limit: Int, $categories: [String!], $search: String) {\",",
                    "        \"  browse(limit: $limit, offset: $offset, categories: $categories, search: $search) {\",",
                    "        \"    total,\",",
                    "        \"    results {\",",
                    "        \"        title\",",
                    "        \"        price\",",
                    "        \"    }\",",
                    "        \"  }\",",
                    "        \"}\"",
                    "      ].join(\"\\n\");",
                    "    case \"markdown\":",
                    "      return [",
                    "        \"Header\",",
                    "        \"======\",",
                    "        \"\",",
                    "        \"_Look,_ code blocks are formatted *too!*\",",
                    "        \"\",",
                    "        \"``` js\",",
                    "        \"function identity(x) { return x }\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"Pilot|Airport|Hours\",",
                    "        \"--|:--:|--:\",",
                    "        \"John Doe|SKG|1338\",",
                    "        \"Jane Roe|JFK|314\",",
                    "        \"\",",
                    "        \"- - - - - - - - - - - - - - -\",",
                    "        \"\",",
                    "        \"+ List\",",
                    "        \" + with a [link] (/to/somewhere)\",",
                    "        \"+ and [another one]\",",
                    "        \"\",",
                    "        \"\",",
                    "        \"  [another one]:  http://example.com 'Example title'\",",
                    "        \"\",",
                    "        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",",
                    "        \"Curabitur consectetur maximus risus, sed maximus tellus tincidunt et.\"",
                    "      ].join(\"\\n\");",
                    "    case \"vue\":",
                    "      return [",
                    "        \"<template>\",",
                    "        \"  <p>Templates are not formatted yet ...\",",
                    "        \"    </p>\",",
                    "        \"</template>\",",
                    "        \"\",",
                    "        \"<script>\",",
                    "        \"let Prettier = format => { your.js('though') }\",",
                    "        \"</script>\",",
                    "        \"\",",
                    "        \"<style>\",",
                    "        \".and { css: too! important }\",",
                    "        \"</style>\"",
                    "      ].join(\"\\n\");",
                    "    default:",
                    "      return \"\";",
                    "  }",
                    "}"
                ]
            },
            "prettier-centered-logo-static.svg": {},
            "prettier.png": {},
            "service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* eslint-env serviceworker */",
                    "/* global toolbox */",
                    "",
                    "\"use strict\";",
                    "",
                    "importScripts(\"lib/sw-toolbox.js\");",
                    "",
                    "toolbox.precache([",
                    "  // Scripts",
                    "  \"lib/index.js\",",
                    "  \"lib/parser-babylon.js\",",
                    "  \"lib/parser-typescript.js\",",
                    "  \"lib/parser-postcss.js\",",
                    "  \"lib/parser-flow.js\",",
                    "  \"lib/parser-glimmer.js\",",
                    "  \"lib/parser-graphql.js\",",
                    "  \"lib/parser-markdown.js\",",
                    "  \"markdown.js\",",
                    "  \"playground.js\",",
                    "  \"lib/sw-toolbox.js\",",
                    "",
                    "  // CodeMirror",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/codemirror.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/codemirror.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/mode/javascript/javascript.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/mode/xml/xml.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/mode/jsx/jsx.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/mode/css/css.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/mode/markdown/markdown.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/addon/display/placeholder.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/addon/display/rulers.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/addon/search/searchcursor.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/addon/edit/matchbrackets.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/addon/edit/closebrackets.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/addon/comment/comment.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/addon/wrap/hardwrap.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.26.0/keymap/sublime.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js\",",
                    "",
                    "  // Images",
                    "  \"/prettier.png\"",
                    "]);",
                    "",
                    "// Default to hit the cache only if there's a network error",
                    "toolbox.router.default = toolbox.networkFirst;",
                    "",
                    "// For scripts, stylesheets and images, we can use the \"fastest\" strategy",
                    "// This means you need to reload twice to get new changes",
                    "toolbox.router.get(/\\.(js|css|png|svg)$/, toolbox.fastest);"
                ]
            },
            "worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* eslint-env worker */",
                    "/* eslint no-var: off, strict: off */",
                    "",
                    "var parsersLoaded = {};",
                    "",
                    "// \"Polyfills\" in order for all the code to run",
                    "/* eslint-disable */",
                    "self.global = self;",
                    "self.util = {};",
                    "self.path = {};",
                    "self.path.resolve = self.path.join = self.path.dirname = function() {",
                    "  return \"\";",
                    "};",
                    "self.path.parse = function() {",
                    "  return { root: \"\" };",
                    "};",
                    "self.Buffer = {",
                    "  isBuffer: function() {",
                    "    return false;",
                    "  }",
                    "};",
                    "self.constants = {};",
                    "module$1 = module = os = crypto = {};",
                    "self.fs = { readFile: function() {} };",
                    "os.homedir = function() {",
                    "  return \"/home/prettier\";",
                    "};",
                    "os.EOL = '\\n';",
                    "self.process = {",
                    "  argv: [],",
                    "  env: { PRETTIER_DEBUG: true },",
                    "  version: \"v8.5.0\",",
                    "  binding: function() {",
                    "    return {};",
                    "  },",
                    "  cwd: function() {",
                    "    return \"\";",
                    "  }",
                    "};",
                    "self.assert = { ok: function() {}, strictEqual: function() {} };",
                    "self.require = function require(path) {",
                    "  if (path === \"stream\") {",
                    "    return { PassThrough() {} };",
                    "  }",
                    "  if (path === \"./third-party\") {",
                    "    return {};",
                    "  }",
                    "",
                    "  if (~path.indexOf(\"parser-\")) {",
                    "    var parser = path.replace(/.+-/, \"\");",
                    "    if (!parsersLoaded[parser]) {",
                    "      importScripts(\"lib/parser-\" + parser + \".js\");",
                    "      parsersLoaded[parser] = true;",
                    "    }",
                    "    return self[parser];",
                    "  }",
                    "",
                    "  return self[path];",
                    "};",
                    "",
                    "/* eslint-enable */",
                    "",
                    "var prettier;",
                    "importScripts(\"lib/index.js\");",
                    "if (typeof prettier === \"undefined\") {",
                    "  prettier = module.exports; // eslint-disable-line",
                    "}",
                    "if (typeof prettier === \"undefined\") {",
                    "  prettier = index; // eslint-disable-line",
                    "}",
                    "",
                    "self.onmessage = function(message) {",
                    "  var options = message.data.options || {};",
                    "  options.parser = options.parser || \"babylon\";",
                    "",
                    "  delete options.ast;",
                    "  delete options.doc;",
                    "  delete options.output2;",
                    "",
                    "  var formatted = formatCode(message.data.text, options);",
                    "  var doc;",
                    "  var ast;",
                    "  var formatted2;",
                    "",
                    "  if (message.data.ast) {",
                    "    var actualAst;",
                    "    var errored = false;",
                    "    try {",
                    "      actualAst = prettier.__debug.parse(message.data.text, options).ast;",
                    "      ast = JSON.stringify(actualAst);",
                    "    } catch (e) {",
                    "      errored = true;",
                    "      ast = String(e);",
                    "    }",
                    "    if (!errored) {",
                    "      try {",
                    "        ast = formatCode(ast, { parser: \"json\" });",
                    "      } catch (e) {",
                    "        ast = JSON.stringify(actualAst, null, 2);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  if (message.data.doc) {",
                    "    try {",
                    "      doc = prettier.__debug.formatDoc(",
                    "        prettier.__debug.printToDoc(message.data.text, options),",
                    "        { parser: \"babylon\" }",
                    "      );",
                    "    } catch (e) {",
                    "      doc = String(e);",
                    "    }",
                    "  }",
                    "",
                    "  if (message.data.formatted2) {",
                    "    formatted2 = formatCode(formatted, options);",
                    "  }",
                    "",
                    "  self.postMessage({",
                    "    formatted: formatted,",
                    "    doc: doc,",
                    "    ast: ast,",
                    "    formatted2: formatted2,",
                    "    version: prettier.version",
                    "  });",
                    "};",
                    "",
                    "function formatCode(text, options) {",
                    "  try {",
                    "    return prettier.format(text, options);",
                    "  } catch (e) {",
                    "    if (e.constructor && e.constructor.name === \"SyntaxError\") {",
                    "      // Likely something wrong with the user's code",
                    "      return String(e);",
                    "    }",
                    "    // Likely a bug in Prettier",
                    "    // Provide the whole stack for debugging",
                    "    return e.stack || String(e);",
                    "  }",
                    "}"
                ]
            },
            "images": {
                "get_started_rects.svg": {},
                "github.svg": {},
                "github_grey.svg": {},
                "npm.svg": {},
                "npm_grey.svg": {},
                "editors": {
                    "atom-128px.png": {},
                    "editor_atom.svg": {},
                    "editor_emacs.svg": {},
                    "editor_espresso.svg": {},
                    "editor_sublime.svg": {},
                    "editor_vim.svg": {},
                    "editor_vs.svg": {},
                    "editor_vscode.svg": {},
                    "editor_webstorm.svg": {},
                    "emacs-128px.png": {},
                    "espresso-128px.png": {},
                    "sublimetext-128px.png": {},
                    "vim-128px.png": {},
                    "visualstudio-128px.png": {},
                    "vscode-128px.png": {},
                    "webstorm-128px.png": {}
                },
                "languages": {
                    "css-128px.png": {},
                    "css_small_grey.svg": {},
                    "graphql-128px.png": {},
                    "graphql_small_grey.svg": {},
                    "js-128px.png": {},
                    "js_small_grey.svg": {},
                    "markdown-128px.png": {},
                    "markdown_small_grey.svg": {},
                    "python_small_grey.svg": {},
                    "swift_small_grey.svg": {},
                    "tools_css.svg": {},
                    "tools_gql.svg": {},
                    "tools_js.svg": {},
                    "tools_md.svg": {},
                    "tools_wip.svg": {}
                },
                "users": {
                    "3yourmind.svg": {},
                    "algolia-200x100.png": {},
                    "babel-200x100.png": {},
                    "brigad-200x100.png": {},
                    "charlietango-200x100.png": {},
                    "codemix-200x100.png": {},
                    "computerbase.svg": {},
                    "contiamo-200x100.png": {},
                    "danger-200x100.png": {},
                    "discord-200x100.png": {},
                    "drizly-200x100.png": {},
                    "escrow-200x100.png": {},
                    "eventstag-200x100.png": {},
                    "eyesquare-200x100.png": {},
                    "facebook-200x100.png": {},
                    "freelancer-200x100.png": {},
                    "gumgum-200x100.png": {},
                    "hackclub-200x100.png": {},
                    "hasura-200x100.png": {},
                    "hearthsim-200x100.png": {},
                    "holidaycheck-200x100.png": {},
                    "hudl-200x100.png": {},
                    "ideati-200x100.png": {},
                    "iress-200x100.png": {},
                    "jane-200x100.png": {},
                    "jest-200x100.png": {},
                    "leesa.svg": {},
                    "lifesum-200x100.png": {},
                    "loyaltylion-200x100.png": {},
                    "m6web-200x100.png": {},
                    "materialui-200x100.png": {},
                    "mathrioshka-200x100.png": {},
                    "monei-200x100.png": {},
                    "mongodb-200x100.png": {},
                    "moonmail-200x100.png": {},
                    "n26-200x100.png": {},
                    "nhl-200x100.png": {},
                    "nrwl-200x100.png": {},
                    "outreach-200x100.png": {},
                    "paypal-200x100.png": {},
                    "react-200x100.png": {},
                    "rnfirebase-200x100.png": {},
                    "sevenspan-200x100.png": {},
                    "shelf-200x100.png": {},
                    "smooth-code-200x100.png": {},
                    "storybook-200x100.png": {},
                    "talkable-200x100.png": {},
                    "tradeshift-200x100.png": {},
                    "transloadit-200x100.png": {},
                    "troops-200x100.png": {},
                    "used_by_babel.svg": {},
                    "used_by_danger.svg": {},
                    "used_by_facebook.svg": {},
                    "used_by_jest.svg": {},
                    "used_by_react.svg": {},
                    "used_by_storybook.svg": {},
                    "used_by_webpack.svg": {},
                    "used_by_yarn.svg": {},
                    "used_by_zeit.svg": {},
                    "webflow-200x100.png": {},
                    "webpack-200x100.png": {},
                    "wingify-200x100.png": {},
                    "wire-200x100.png": {},
                    "yarn-200x100.png": {},
                    "yelp-200x100.png": {},
                    "zeit-200x100.png": {},
                    "zipch-200x100.png": {}
                }
            },
            "separate-css": {
                "playground.css": {}
            }
        }
    }
}