{
    "1": {
        "bug_file": "src/language-html/embed/angular-attributes.js",
        "compressed": "NO",
        "line_numbers": 94,
        "compressed_line_numbers": 94,
        "compressed_bug_file_content": "import {\n  getUnescapedAttributeValue,\n  getTextValueParts,\n} from \"../utils/index.js\";\nimport { fill } from \"../../document/builders.js\";\nimport {\n  formatAttributeValue,\n  printExpand,\n  shouldHugJsExpression,\n} from \"./utils.js\";\nimport {\n  interpolationRegex as angularInterpolationRegex,\n  printAngularInterpolation,\n} from \"./angular-interpolation.js\";\n\nfunction createAngularPrinter({ parser }) {\n  return (textToDoc, print, path /*, options*/) =>\n    formatAttributeValue(\n      getUnescapedAttributeValue(path.node),\n      textToDoc,\n      {\n        parser,\n        // angular does not allow trailing comma\n        trailingComma: \"none\",\n      },\n      shouldHugJsExpression\n    );\n}\n\nconst printNgAction = createAngularPrinter({ parser: \"__ng_action\" });\nconst printNgBinding = createAngularPrinter({ parser: \"__ng_binding\" });\nconst printNgDirective = createAngularPrinter({ parser: \"__ng_directive\" });\n\nfunction printAngularAttribute(path, options) {\n  if (options.parser !== \"angular\") {\n    return;\n  }\n\n  const { node } = path;\n  const attributeName = node.fullName;\n\n  /**\n   *     (click)=\"angularStatement\"\n   *     on-click=\"angularStatement\"\n   */\n  if (\n    (attributeName.startsWith(\"(\") && attributeName.endsWith(\")\")) ||\n    attributeName.startsWith(\"on-\")\n  ) {\n    return printNgAction;\n  }\n\n  /**\n   *     [target]=\"angularExpression\"\n   *     bind-target=\"angularExpression\"\n   *     [(target)]=\"angularExpression\"\n   *     bindon-target=\"angularExpression\"\n   */\n  if (\n    (attributeName.startsWith(\"[\") && attributeName.endsWith(\"]\")) ||\n    /^bind(?:on)?-/.test(attributeName) ||\n    // Unofficial rudimentary support for some of the most used directives of AngularJS 1.x\n    /^ng-(?:if|show|hide|class|style)$/.test(attributeName)\n  ) {\n    return printNgBinding;\n  }\n\n  /**\n   *     *directive=\"angularDirective\"\n   */\n  if (attributeName.startsWith(\"*\")) {\n    return printNgDirective;\n  }\n\n  const value = getUnescapedAttributeValue(node);\n\n  /**\n   *     i18n=\"longDescription\"\n   *     i18n-attr=\"longDescription\"\n   */\n  if (/^i18n(?:-.+)?$/.test(attributeName)) {\n    return () =>\n      printExpand(\n        fill(getTextValueParts(node, value.trim())),\n        !value.includes(\"@@\")\n      );\n  }\n\n  if (angularInterpolationRegex.test(value)) {\n    return (textToDoc) => printAngularInterpolation(value, textToDoc);\n  }\n}\n\nexport default printAngularAttribute;"
    },
    "2": {
        "bug_file": "src/language-html/embed/angular-interpolation.js",
        "compressed": "NO",
        "line_numbers": 38,
        "compressed_line_numbers": 38,
        "compressed_bug_file_content": "import { group, indent, line } from \"../../document/builders.js\";\nimport { replaceEndOfLine } from \"../../document/utils.js\";\nimport { formatAttributeValue } from \"./utils.js\";\n\nconst interpolationRegex = /{{(.+?)}}/s;\n\nasync function printAngularInterpolation(text, textToDoc) {\n  const parts = [];\n  for (const [index, part] of text.split(interpolationRegex).entries()) {\n    if (index % 2 === 0) {\n      parts.push(replaceEndOfLine(part));\n    } else {\n      try {\n        parts.push(\n          group([\n            \"{{\",\n            indent([\n              line,\n              await formatAttributeValue(part, textToDoc, {\n                parser: \"__ng_interpolation\",\n                __isInHtmlInterpolation: true, // to avoid unexpected `}}`\n                trailingComma: \"none\",\n              }),\n            ]),\n            line,\n            \"}}\",\n          ])\n        );\n      } catch {\n        parts.push(\"{{\", replaceEndOfLine(part), \"}}\");\n      }\n    }\n  }\n\n  return parts;\n}\n\nexport { interpolationRegex, printAngularInterpolation };"
    },
    "3": {
        "bug_file": "src/language-html/printer-html.js",
        "compressed": "NO",
        "line_numbers": 124,
        "compressed_line_numbers": 124,
        "compressed_bug_file_content": "/**\n * @typedef {import(\"../document/builders.js\").Doc} Doc\n */\n\nimport { fill, group, hardline } from \"../document/builders.js\";\nimport { cleanDoc, replaceEndOfLine } from \"../document/utils.js\";\nimport UnexpectedNodeError from \"../utils/unexpected-node-error.js\";\nimport getPreferredQuote from \"../utils/get-preferred-quote.js\";\nimport clean from \"./clean.js\";\nimport { unescapeQuoteEntities, getTextValueParts } from \"./utils/index.js\";\nimport preprocess from \"./print-preprocess.js\";\nimport { insertPragma } from \"./pragma.js\";\nimport { locStart, locEnd } from \"./loc.js\";\nimport embed from \"./embed.js\";\nimport {\n  printClosingTagSuffix,\n  printClosingTagEnd,\n  printOpeningTagPrefix,\n  printOpeningTagStart,\n} from \"./print/tag.js\";\nimport { printElement } from \"./print/element.js\";\nimport { printChildren } from \"./print/children.js\";\nimport getVisitorKeys from \"./get-visitor-keys.js\";\n\nfunction genericPrint(path, options, print) {\n  const { node } = path;\n\n  switch (node.type) {\n    case \"front-matter\":\n      return replaceEndOfLine(node.raw);\n    case \"root\":\n      if (options.__onHtmlRoot) {\n        options.__onHtmlRoot(node);\n      }\n      return [group(printChildren(path, options, print)), hardline];\n    case \"element\":\n    case \"ieConditionalComment\":\n      return printElement(path, options, print);\n\n    case \"ieConditionalStartComment\":\n    case \"ieConditionalEndComment\":\n      return [printOpeningTagStart(node), printClosingTagEnd(node)];\n    case \"interpolation\":\n      return [\n        printOpeningTagStart(node, options),\n        ...path.map(print, \"children\"),\n        printClosingTagEnd(node, options),\n      ];\n    case \"text\": {\n      if (node.parent.type === \"interpolation\") {\n        // replace the trailing literalline with hardline for better readability\n        const trailingNewlineRegex = /\\n[^\\S\\n]*$/;\n        const hasTrailingNewline = trailingNewlineRegex.test(node.value);\n        const value = hasTrailingNewline\n          ? node.value.replace(trailingNewlineRegex, \"\")\n          : node.value;\n        return [replaceEndOfLine(value), hasTrailingNewline ? hardline : \"\"];\n      }\n\n      const printed = cleanDoc([\n        printOpeningTagPrefix(node, options),\n        ...getTextValueParts(node),\n        printClosingTagSuffix(node, options),\n      ]);\n\n      if (Array.isArray(printed)) {\n        return fill(printed);\n      }\n\n      return printed;\n    }\n    case \"docType\":\n      return [\n        group([\n          printOpeningTagStart(node, options),\n          \" \",\n          node.value.replace(/^html\\b/i, \"html\").replaceAll(/\\s+/g, \" \"),\n        ]),\n        printClosingTagEnd(node, options),\n      ];\n    case \"comment\":\n      return [\n        printOpeningTagPrefix(node, options),\n        replaceEndOfLine(\n          options.originalText.slice(locStart(node), locEnd(node))\n        ),\n        printClosingTagSuffix(node, options),\n      ];\n\n    case \"attribute\": {\n      if (node.value === null) {\n        return node.rawName;\n      }\n      const value = unescapeQuoteEntities(node.value);\n      const quote = getPreferredQuote(value, '\"');\n      return [\n        node.rawName,\n        \"=\",\n        quote,\n        replaceEndOfLine(\n          quote === '\"'\n            ? value.replaceAll('\"', \"&quot;\")\n            : value.replaceAll(\"'\", \"&apos;\")\n        ),\n        quote,\n      ];\n    }\n    case \"cdata\": // Transformed into `text`\n    default:\n      /* c8 ignore next */\n      throw new UnexpectedNodeError(node, \"HTML\");\n  }\n}\n\nconst printer = {\n  preprocess,\n  print: genericPrint,\n  insertPragma,\n  massageAstNode: clean,\n  embed,\n  getVisitorKeys,\n};\n\nexport default printer;"
    }
}