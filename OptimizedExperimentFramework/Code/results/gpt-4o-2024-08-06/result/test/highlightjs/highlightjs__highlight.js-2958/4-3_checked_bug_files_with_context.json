{
    "src/languages/xml.js": [
        "/*",
        "Language: HTML, XML",
        "Website: https://www.w3.org/XML/",
        "Category: common",
        "Audit: 2020",
        "*/",
        "",
        "import * as regex from '../lib/regex.js';",
        "",
        "/** @type LanguageFn */",
        "export default function(hljs) {",
        "  // Element names can contain letters, digits, hyphens, underscores, and periods",
        "  const TAG_NAME_RE = regex.concat(/[A-Z_]/, regex.optional(/[A-Z0-9_.-]+:/), /[A-Z0-9_.-]*/);",
        "  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;",
        "  const XML_ENTITIES = {",
        "    className: 'symbol',",
        "    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/",
        "  };",
        "  const XML_META_KEYWORDS = {",
        "    begin: /\\s/,",
        "    contains: [",
        "      {",
        "        className: 'meta-keyword',",
        "        begin: /#?[a-z_][a-z1-9_-]+/,",
        "        illegal: /\\n/",
        "      }",
        "    ]",
        "  };",
        "  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {",
        "    begin: /\\(/,",
        "    end: /\\)/",
        "  });",
        "  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {",
        "    className: 'meta-string'",
        "  });",
        "  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {",
        "    className: 'meta-string'",
        "  });",
        "  const TAG_INTERNALS = {",
        "    endsWithParent: true,",
        "    illegal: /</,",
        "    relevance: 0,",
        "    contains: [",
        "      {",
        "        className: 'attr',",
        "        begin: XML_IDENT_RE,",
        "        relevance: 0",
        "      },",
        "      {",
        "        begin: /=\\s*/,",
        "        relevance: 0,",
        "        contains: [",
        "          {",
        "            className: 'string',",
        "            endsParent: true,",
        "            variants: [",
        "              {",
        "                begin: /\"/,",
        "                end: /\"/,",
        "                contains: [ XML_ENTITIES ]",
        "              },",
        "              {",
        "                begin: /'/,",
        "                end: /'/,",
        "                contains: [ XML_ENTITIES ]",
        "              },",
        "              {",
        "                begin: /[^\\s\"'=<>`]+/",
        "              }",
        "            ]",
        "          }",
        "        ]",
        "      }",
        "    ]",
        "  };",
        "  return {",
        "    name: 'HTML, XML',",
        "    aliases: [",
        "      'html',",
        "      'xhtml',",
        "      'rss',",
        "      'atom',",
        "      'xjb',",
        "      'xsd',",
        "      'xsl',",
        "      'plist',",
        "      'wsf',",
        "      'svg'",
        "    ],",
        "    case_insensitive: true,",
        "    contains: [",
        "      {",
        "        className: 'meta',",
        "        begin: /<![a-z]/,",
        "        end: />/,",
        "        relevance: 10,",
        "        contains: [",
        "          XML_META_KEYWORDS,",
        "          QUOTE_META_STRING_MODE,",
        "          APOS_META_STRING_MODE,",
        "          XML_META_PAR_KEYWORDS,",
        "          {",
        "            begin: /\\[/,",
        "            end: /\\]/,",
        "            contains: [",
        "              {",
        "                className: 'meta',",
        "                begin: /<![a-z]/,",
        "                end: />/,",
        "                contains: [",
        "                  XML_META_KEYWORDS,",
        "                  XML_META_PAR_KEYWORDS,",
        "                  QUOTE_META_STRING_MODE,",
        "                  APOS_META_STRING_MODE",
        "                ]",
        "              }",
        "            ]",
        "          }",
        "        ]",
        "      },",
        "      hljs.COMMENT(",
        "        /<!--/,",
        "        /-->/,",
        "        {",
        "          relevance: 10",
        "        }",
        "      ),",
        "      {",
        "        begin: /<!\\[CDATA\\[/,",
        "        end: /\\]\\]>/,",
        "        relevance: 10",
        "      },",
        "      XML_ENTITIES,",
        "      {",
        "        className: 'meta',",
        "        begin: /<\\?xml/,",
        "        end: /\\?>/,",
        "        relevance: 10",
        "      },",
        "      {",
        "        className: 'tag',",
        "        /*",
        "        The lookahead pattern (?=...) ensures that 'begin' only matches",
        "        '<style' as a single word, followed by a whitespace or an",
        "        ending braket. The '$' is needed for the lexeme to be recognized",
        "        by hljs.subMode() that tests lexemes outside the stream.",
        "        */",
        "        begin: /<style(?=\\s|>)/,",
        "        end: />/,",
        "        keywords: {",
        "          name: 'style'",
        "        },",
        "        contains: [ TAG_INTERNALS ],",
        "        starts: {",
        "          end: /<\\/style>/,",
        "          returnEnd: true,",
        "          subLanguage: [",
        "            'css',",
        "            'xml'",
        "          ]",
        "        }",
        "      },",
        "      {",
        "        className: 'tag',",
        "        // See the comment in the <style tag about the lookahead pattern",
        "        begin: /<script(?=\\s|>)/,",
        "        end: />/,",
        "        keywords: {",
        "          name: 'script'",
        "        },",
        "        contains: [ TAG_INTERNALS ],",
        "        starts: {",
        "          end: /<\\/script>/,",
        "          returnEnd: true,",
        "          subLanguage: [",
        "            'javascript',",
        "            'handlebars',",
        "            'xml'",
        "          ]",
        "        }",
        "      },",
        "      // we need this for now for jSX",
        "      {",
        "        className: 'tag',",
        "        begin: /<>|<\\/>/",
        "      },",
        "      // open tag",
        "      {",
        "        className: 'tag',",
        "        begin: regex.concat(",
        "          /</,",
        "          regex.lookahead(regex.concat(",
        "            TAG_NAME_RE,",
        "            // <tag/>",
        "            // <tag>",
        "            // <tag ...",
        "            regex.either(/\\/>/, />/, /\\s/)",
        "          ))",
        "        ),",
        "        end: /\\/?>/,",
        "        contains: [",
        "          {",
        "            className: 'name',",
        "            begin: TAG_NAME_RE,",
        "            relevance: 0,",
        "            starts: TAG_INTERNALS",
        "          }",
        "        ]",
        "      },",
        "      // close tag",
        "      {",
        "        className: 'tag',",
        "        begin: regex.concat(",
        "          /<\\//,",
        "          regex.lookahead(regex.concat(",
        "            TAG_NAME_RE, />/",
        "          ))",
        "        ),",
        "        contains: [",
        "          {",
        "            className: 'name',",
        "            begin: TAG_NAME_RE,",
        "            relevance: 0",
        "          },",
        "          {",
        "            begin: />/,",
        "            relevance: 0",
        "          }",
        "        ]",
        "      }",
        "    ]",
        "  };",
        "}"
    ],
    "src/lib/regex.js": [
        "/**",
        " * @param {string} value",
        " * @returns {RegExp}",
        " * */",
        "export function escape(value) {",
        "  return new RegExp(value.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'), 'm');",
        "}",
        "",
        "/**",
        " * @param {RegExp | string } re",
        " * @returns {string}",
        " */",
        "export function source(re) {",
        "  if (!re) return null;",
        "  if (typeof re === \"string\") return re;",
        "",
        "  return re.source;",
        "}",
        "",
        "/**",
        " * @param {RegExp | string } re",
        " * @returns {string}",
        " */",
        "export function lookahead(re) {",
        "  return concat('(?=', re, ')');",
        "}",
        "",
        "/**",
        " * @param {RegExp | string } re",
        " * @returns {string}",
        " */",
        "export function anyNumberOfTimes(re) {",
        "  return concat('(', re, ')*');",
        "}",
        "",
        "/**",
        " * @param {RegExp | string } re",
        " * @returns {string}",
        " */",
        "export function optional(re) {",
        "  return concat('(', re, ')?');",
        "}",
        "",
        "/**",
        " * @param {...(RegExp | string) } args",
        " * @returns {string}",
        " */",
        "export function concat(...args) {",
        "  const joined = args.map((x) => source(x)).join(\"\");",
        "  return joined;",
        "}",
        "",
        "/**",
        " * Any of the passed expresssions may match",
        " *",
        " * Creates a huge this | this | that | that match",
        " * @param {(RegExp | string)[] } args",
        " * @returns {string}",
        " */",
        "export function either(...args) {",
        "  const joined = '(' + args.map((x) => source(x)).join(\"|\") + \")\";",
        "  return joined;",
        "}",
        "",
        "/**",
        " * @param {RegExp} re",
        " * @returns {number}",
        " */",
        "export function countMatchGroups(re) {",
        "  return (new RegExp(re.toString() + '|')).exec('').length - 1;",
        "}",
        "",
        "/**",
        " * Does lexeme start with a regular expression match at the beginning",
        " * @param {RegExp} re",
        " * @param {string} lexeme",
        " */",
        "export function startsWith(re, lexeme) {",
        "  const match = re && re.exec(lexeme);",
        "  return match && match.index === 0;",
        "}",
        "",
        "// join logically computes regexps.join(separator), but fixes the",
        "// backreferences so they continue to match.",
        "// it also places each individual regular expression into it's own",
        "// match group, keeping track of the sequencing of those match groups",
        "// is currently an exercise for the caller. :-)",
        "/**",
        " * @param {(string | RegExp)[]} regexps",
        " * @param {string} separator",
        " * @returns {string}",
        " */",
        "export function join(regexps, separator = \"|\") {",
        "  // backreferenceRe matches an open parenthesis or backreference. To avoid",
        "  // an incorrect parse, it additionally matches the following:",
        "  // - [...] elements, where the meaning of parentheses and escapes change",
        "  // - other escape sequences, so we do not misparse escape sequences as",
        "  //   interesting elements",
        "  // - non-matching or lookahead parentheses, which do not capture. These",
        "  //   follow the '(' with a '?'.",
        "  const backreferenceRe = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;",
        "  let numCaptures = 0;",
        "  let ret = '';",
        "  for (let i = 0; i < regexps.length; i++) {",
        "    numCaptures += 1;",
        "    const offset = numCaptures;",
        "    let re = source(regexps[i]);",
        "    if (i > 0) {",
        "      ret += separator;",
        "    }",
        "    ret += \"(\";",
        "    while (re.length > 0) {",
        "      const match = backreferenceRe.exec(re);",
        "      if (match == null) {",
        "        ret += re;",
        "        break;",
        "      }",
        "      ret += re.substring(0, match.index);",
        "      re = re.substring(match.index + match[0].length);",
        "      if (match[0][0] === '\\\\' && match[1]) {",
        "        // Adjust the backreference.",
        "        ret += '\\\\' + String(Number(match[1]) + offset);",
        "      } else {",
        "        ret += match[0];",
        "        if (match[0] === '(') {",
        "          numCaptures++;",
        "        }",
        "      }",
        "    }",
        "    ret += \")\";",
        "  }",
        "  return ret;",
        "}"
    ]
}