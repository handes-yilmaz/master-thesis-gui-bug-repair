{
    "1": {
        "bug_file": "src/languages/cpp.js",
        "compressed": "YES",
        "line_numbers": 587,
        "compressed_line_numbers": 51,
        "compressed_bug_file_content": "/*\n\n\n*/\n\n/** @type LanguageFn */\nexport default function(hljs) {\n\n  // added for historic reasons because `hljs.C_LINE_COMMENT_MODE` does\n  // not include such support nor can we be sure all the grammars depending\n  // on it would desire this behavior\n\n\n  // https://en.cppreference.com/w/cpp/language/escape\n  // \\\\ \\x \\xFF \\u2837 \\u00323747 \\374\n\n\n  // https://en.cppreference.com/w/cpp/keyword\n\n\n  // https://en.cppreference.com/w/cpp/keyword\n\n\n  // https://en.cppreference.com/w/cpp/keyword\n\n\n      // Only for relevance, not highlighting.\n\n\n    // This mode covers expression context where we can't expect a function\n    // definition and shouldn't highlight anything that looks like one:\n    // `return some()`, `else if()`, `(x*sum(1, 2))`\n\n\n      // needed because we do not have look-behind on the below rule\n      // to prevent it from grabbing the final : in a :: pair\n\n\n      // initializers\n\n\n      // allow for multiple declarations, e.g.:\n      // extern void f(int), g(char);\n\n\n          // Count matching parentheses.\n\n\n            // extra complexity to deal with `enum class` and `enum struct`\n\n\n"
    },
    "2": {
        "bug_file": "src/highlight.js",
        "compressed": "YES",
        "line_numbers": 1004,
        "compressed_line_numbers": 448,
        "compressed_bug_file_content": "/*\n\n\n*/\n\n// @ts-ignore\nimport deepFreeze from 'deep-freeze-es6';\nimport Response from './lib/response.js';\nimport TokenTreeEmitter from './lib/token_tree.js';\nimport * as regex from './lib/regex.js';\nimport * as utils from './lib/utils.js';\nimport * as MODES from './lib/modes.js';\nimport { compileLanguage } from './lib/mode_compiler.js';\nimport * as packageJSON from '../package.json';\nimport * as logger from \"./lib/logger.js\";\nimport HTMLInjectionError from \"./lib/html_injection_error.js\";\n\n/**\n\n\n*/\n\n\n/**\n * @param {any} hljs - object that is extended (legacy)\n * @returns {HLJSApi}\n */\n\n  // Global internal variables used within the highlight.js library.\n  /** @type {Record<string, Language>} */\n\n  /** @type {Record<string, string>} */\n\n  /** @type {HLJSPlugin[]} */\n\n\n  // safe/production mode - swallows more errors, tries to keep running\n  // even if a single syntax or parse hits a fatal error\n\n\n  /** @type {Language} */\n\n\n  // Global options used when within external APIs. This is modified when\n  // calling the `hljs.configure` function.\n  /** @type HLJSOptions */\n\n\n    // beta configuration options, subject to change, welcome to discuss\n    // https://github.com/highlightjs/highlight.js/issues/1086\n\n\n  /* Utility functions */\n\n  /**\n   * Tests a language name to see if highlighting should be skipped\n   * @param {string} languageName\n   */\n\n\n  /**\n   * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n   */\n\n\n    // language-* takes precedence over non-prefixed class names.\n\n\n  /**\n   * Core highlighting function.\n   *\n   * OLD API\n   * highlight(lang, code, ignoreIllegals, continuation)\n   *\n   * NEW API\n   * highlight(code, {lang, ignoreIllegals})\n   *\n   * @param {string} codeOrLanguageName - the language to use for highlighting\n   * @param {string | HighlightOptions} optionsOrCode - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {CompiledMode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found\n  */\n\n\n      // old API\n\n\n    // https://github.com/highlightjs/highlight.js/issues/3149\n    // eslint-disable-next-line no-undefined\n\n\n    /** @type {BeforeHighlightContext} */\n\n\n    // the plugin can change the desired language or the code to be highlighted\n    // just be changing the object it was passed\n\n\n    // a before plugin can usurp the result completely by providing it's own\n    // in which case we don't even need to call highlight\n\n\n    // the plugin can change anything in result to suite it\n\n\n  /**\n   * private highlight that's used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} codeToHighlight - the code to highlight\n   * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {CompiledMode?} [continuation] - current continuation mode, if any\n   * @returns {HighlightResult} - result of the highlight operation\n  */\n\n\n    /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {string} matchText - the textual match\n     * @returns {KeywordData | false}\n     */\n\n\n            // _ implied for relevance only, do not highlight\n            // by applying a class name\n\n\n      /** @type HighlightResult */\n\n\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Use case in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n\n\n    /**\n     * @param {CompiledScope} scope\n     * @param {RegExpMatchArray} match\n     */\n\n\n      // eslint-disable-next-line no-undefined\n\n\n    /**\n     * @param {CompiledMode} mode - new mode to start\n     * @param {RegExpMatchArray} match\n     */\n\n\n        // beginScope just wraps the begin match itself in a scope\n\n\n          // at this point modeBuffer should just be the match\n\n\n    /**\n     * @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n     */\n\n\n      // even if on:end fires an `ignore` it's still possible\n      // that we might trigger the end node because of a parent mode\n\n\n    /**\n     * Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text\n     */\n\n\n        // no more regexes to potentially match here, so we move the cursor forward one\n        // space\n\n\n        // no need to move the cursor, we still have additional regexes to try and\n        // match at this very spot\n\n\n    /**\n     * Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor\n     */\n\n\n      // first internal before callbacks, then the public ones\n\n\n    /**\n     * Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match\n     */\n\n\n    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */\n\n\n    /**\n     *  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself\n     */\n\n\n      // add non-matched text to the current mode buffer\n\n\n      // we've found a 0 width match and we're stuck, so we need to advance\n      // this happens when we have badly behaved rules that have optional matchers to the degree that\n      // sometimes they can end up matching nothing at all\n      // Ref: https://github.com/highlightjs/highlight.js/issues/2140\n\n        // spit the \"skipped\" character that our regex choked on back into the output sequence\n\n\n          /** @type {AnnotatedError} */\n\n\n        // illegal match, we do not continue processing\n        /** @type {AnnotatedError} */\n\n\n      // edge case for when illegal matches $ (end of line) which is technically\n      // a 0 width match but not a begin/end match so it's not caught by the\n      // first handler (when ignoreIllegals is true)\n\n        // advance so we aren't stuck in an infinite loop\n\n\n      // infinite loops are BAD, this is a last ditch catch all. if we have a\n      // decent number of iterations yet our index (cursor position in our\n      // parsing) still 3x behind our index then something is very wrong\n      // so we bail\n\n\n      /*\n\n\n      */\n\n\n    /** @type {CompiledMode} */\n\n    /** @type Record<string,CompiledMode> */\n\n\n          // only regexes not matched previously will now be\n          // considered for a potential match\n\n\n        // console.log(\"match\", match[0], match.rule && match.rule.begin)\n\n\n  /**\n   * returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it's possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}\n   */\n\n\n  /**\n\n\n  */\n\n\n      // sort base on relevance\n\n\n      // always award the tie to the base language\n      // ie if C++ and Arduino are tied, it's more likely to be C++\n\n\n      // otherwise say they are equal, which has the effect of sorting on\n      // relevance while preserving the original ordering - which is how ties\n      // have historically been settled, ie the language that comes first always\n      // wins in the case of a tie\n\n\n    /** @type {AutoHighlightResult} */\n\n\n  /**\n   * Builds new class name for block given the language name\n   *\n   * @param {HTMLElement} element\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]\n   */\n\n\n  /**\n   * Applies highlighting to a DOM node containing code.\n   *\n   * @param {HighlightedHTMLElement} element - the HTML element to highlight\n  */\n\n    /** @type HTMLElement */\n\n\n    // we should be all text, no child nodes (unescaped HTML) - this is possibly\n    // an HTML injection attack - it's likely too late if this is already in\n    // production (the code has likely already done its damage by the time\n    // we're seeing it)... but we yell loudly about this so that hopefully it's\n    // more likely to be caught in development before making it to production\n\n\n      // TODO: remove with version 11.0\n\n\n  /**\n   * Updates highlight.js global options with the passed options\n   *\n   * @param {Partial<HLJSOptions>} userOptions\n   */\n\n\n  // TODO: remove v12, deprecated\n\n\n  // TODO: remove v12, deprecated\n\n\n  /**\n   * auto-highlights all pre>code elements on the page\n   */\n\n    // if we are called too early in the loading process\n\n\n    // if a highlight was requested before DOM was loaded, do now\n\n\n  // make sure we are in the browser environment\n\n\n  /**\n   * Register a language grammar module\n   *\n   * @param {string} languageName\n   * @param {LanguageFn} languageDefinition\n   */\n\n\n      // hard or soft error\n\n      // languages that have serious errors are replaced with essentially a\n      // \"plaintext\" stand-in so that the code blocks will still get normal\n      // css classes applied to them - and one bad language won't break the\n      // entire highlighter\n\n\n    // give it a temporary name if it doesn't have one in the meta-data\n\n\n  /**\n   * Remove a language grammar module\n   *\n   * @param {string} languageName\n   */\n\n\n  /**\n   * @returns {string[]} List of language internal names\n   */\n\n\n  /**\n   * @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}\n   */\n\n\n  /**\n   *\n   * @param {string|string[]} aliasList - single alias or list of aliases\n   * @param {{languageName: string}} opts\n   */\n\n\n  /**\n   * Determines if a given language has auto-detection enabled\n   * @param {string} name - name of the language\n   */\n\n\n  /**\n   * Upgrades the old highlightBlock plugins to the new\n   * highlightElement API\n   * @param {HLJSPlugin} plugin\n   */\n\n    // TODO: remove with v12\n\n\n  /**\n   * @param {HLJSPlugin} plugin\n   */\n\n\n  /**\n   *\n   * @param {PluginEvent} event\n   * @param {any} args\n   */\n\n\n  /**\n   * DEPRECATED\n   * @param {HighlightedHTMLElement} el\n   */\n\n\n  /* Interface definition */\n\n\n    // TODO: Remove with v12 API\n\n\n    // @ts-ignore\n\n      // @ts-ignore\n\n\n  // merge all the modes/regexes into our main object\n\n\n// export an \"instance\" of the highlighter\nexport default HLJS({});\n"
    }
}