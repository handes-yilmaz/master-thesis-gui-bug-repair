{
    "lib/features/modeling/behavior/ReplaceConnectionBehavior.js": [
        "import {",
        "  forEach,",
        "  find,",
        "  matchPattern",
        "} from 'min-dash';",
        "",
        "import inherits from 'inherits';",
        "",
        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
        "",
        "import { is } from '../../../util/ModelUtil';",
        "",
        "",
        "export default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {",
        "",
        "  CommandInterceptor.call(this, eventBus);",
        "",
        "  var dragging = injector.get('dragging', false);",
        "",
        "  function fixConnection(connection) {",
        "",
        "    var source = connection.source,",
        "        target = connection.target,",
        "        parent = connection.parent;",
        "",
        "    // do not do anything if connection",
        "    // is already deleted (may happen due to other",
        "    // behaviors plugged-in before)",
        "    if (!parent) {",
        "      return;",
        "    }",
        "",
        "    var replacementType,",
        "        remove;",
        "",
        "    /**",
        "     * Check if incoming or outgoing connections",
        "     * can stay or could be substituted with an",
        "     * appropriate replacement.",
        "     *",
        "     * This holds true for SequenceFlow <> MessageFlow.",
        "     */",
        "",
        "    if (is(connection, 'bpmn:SequenceFlow')) {",
        "      if (!bpmnRules.canConnectSequenceFlow(source, target)) {",
        "        remove = true;",
        "      }",
        "",
        "      if (bpmnRules.canConnectMessageFlow(source, target)) {",
        "        replacementType = 'bpmn:MessageFlow';",
        "      }",
        "    }",
        "",
        "    // transform message flows into sequence flows, if possible",
        "",
        "    if (is(connection, 'bpmn:MessageFlow')) {",
        "",
        "      if (!bpmnRules.canConnectMessageFlow(source, target)) {",
        "        remove = true;",
        "      }",
        "",
        "      if (bpmnRules.canConnectSequenceFlow(source, target)) {",
        "        replacementType = 'bpmn:SequenceFlow';",
        "      }",
        "    }",
        "",
        "    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {",
        "      remove = true;",
        "    }",
        "",
        "",
        "    // remove invalid connection,",
        "    // unless it has been removed already",
        "    if (remove) {",
        "      modeling.removeConnection(connection);",
        "    }",
        "",
        "    // replace SequenceFlow <> MessageFlow",
        "",
        "    if (replacementType) {",
        "      modeling.connect(source, target, {",
        "        type: replacementType,",
        "        waypoints: connection.waypoints.slice()",
        "      });",
        "    }",
        "  }",
        "",
        "  function replaceReconnectedConnection(event) {",
        "",
        "    var context = event.context,",
        "        connection = context.connection,",
        "        allowed,",
        "        replacement;",
        "",
        "    if (context.newTarget) {",
        "      allowed = bpmnRules.canConnect(connection.source, context.newTarget);",
        "    } else {",
        "      allowed = bpmnRules.canConnect(context.newSource, connection.target);",
        "    }",
        "",
        "    if (!allowed || allowed.type === connection.type) {",
        "      return;",
        "    }",
        "",
        "    // temporarily connect old shapes with new connection",
        "    replacement = modeling.connect(connection.source, connection.target, {",
        "      type: allowed.type,",
        "      waypoints: connection.waypoints.slice()",
        "    });",
        "",
        "    // remove old connection",
        "    modeling.removeConnection(connection);",
        "",
        "    // replace connection in context to reconnect end/start",
        "    context.connection = replacement;",
        "",
        "    if (dragging) {",
        "      cleanDraggingSelection(connection, replacement);",
        "    }",
        "  }",
        "",
        "  // monkey-patch selection saved in dragging in order to not re-select non-existing connection",
        "  function cleanDraggingSelection(oldConnection, newConnection) {",
        "    var context = dragging.context(),",
        "        previousSelection = context && context.payload.previousSelection,",
        "        index;",
        "",
        "    // do nothing if not dragging or no selection was present",
        "    if (!previousSelection || !previousSelection.length) {",
        "      return;",
        "    }",
        "",
        "    index = previousSelection.indexOf(oldConnection);",
        "",
        "    if (index === -1) {",
        "      return;",
        "    }",
        "",
        "    previousSelection.splice(index, 1, newConnection);",
        "  }",
        "",
        "  // lifecycle hooks",
        "",
        "  this.postExecuted('elements.move', function(context) {",
        "",
        "    var closure = context.closure,",
        "        allConnections = closure.allConnections;",
        "",
        "    forEach(allConnections, fixConnection);",
        "  }, true);",
        "",
        "  this.preExecute([",
        "    'connection.reconnectStart',",
        "    'connection.reconnectEnd'",
        "  ], replaceReconnectedConnection);",
        "",
        "  this.postExecuted('element.updateProperties', function(event) {",
        "    var context = event.context,",
        "        properties = context.properties,",
        "        element = context.element,",
        "        businessObject = element.businessObject,",
        "        connection;",
        "",
        "    // remove condition expression when morphing to default flow",
        "    if (properties.default) {",
        "      connection = find(",
        "        element.outgoing,",
        "        matchPattern({ id: element.businessObject.default.id })",
        "      );",
        "",
        "      if (connection) {",
        "        modeling.updateProperties(connection, { conditionExpression: undefined });",
        "      }",
        "    }",
        "",
        "    // remove default property from source when morphing to conditional flow",
        "    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {",
        "      modeling.updateProperties(element.source, { default: undefined });",
        "    }",
        "  });",
        "}",
        "",
        "inherits(ReplaceConnectionBehavior, CommandInterceptor);",
        "",
        "ReplaceConnectionBehavior.$inject = [",
        "  'eventBus',",
        "  'modeling',",
        "  'bpmnRules',",
        "  'injector'",
        "];"
    ],
    "lib/features/modeling/behavior/UpdateFlowNodeRefsBehavior.js": [
        "import inherits from 'inherits';",
        "",
        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
        "",
        "import {",
        "  is",
        "} from '../../../util/ModelUtil';",
        "",
        "var LOW_PRIORITY = 500,",
        "    HIGH_PRIORITY = 5000;",
        "",
        "",
        "/**",
        " * BPMN specific delete lane behavior",
        " */",
        "export default function UpdateFlowNodeRefsBehavior(eventBus, modeling, translate) {",
        "",
        "  CommandInterceptor.call(this, eventBus);",
        "",
        "  /**",
        "   * Ok, this is it:",
        "   *",
        "   * We have to update the Lane#flowNodeRefs _and_",
        "   * FlowNode#lanes with every FlowNode move/resize and",
        "   * Lane move/resize.",
        "   *",
        "   * We want to group that stuff to recompute containments",
        "   * as efficient as possible.",
        "   *",
        "   * Yea!",
        "   */",
        "",
        "  // the update context",
        "  var context;",
        "",
        "",
        "  function initContext() {",
        "    context = context || new UpdateContext();",
        "    context.enter();",
        "",
        "    return context;",
        "  }",
        "",
        "  function getContext() {",
        "    if (!context) {",
        "      throw new Error(translate('out of bounds release'));",
        "    }",
        "",
        "    return context;",
        "  }",
        "",
        "  function releaseContext() {",
        "",
        "    if (!context) {",
        "      throw new Error(translate('out of bounds release'));",
        "    }",
        "",
        "    var triggerUpdate = context.leave();",
        "",
        "    if (triggerUpdate) {",
        "      modeling.updateLaneRefs(context.flowNodes, context.lanes);",
        "",
        "      context = null;",
        "    }",
        "",
        "    return triggerUpdate;",
        "  }",
        "",
        "",
        "  var laneRefUpdateEvents = [",
        "    'spaceTool',",
        "    'lane.add',",
        "    'lane.resize',",
        "    'lane.split',",
        "    'elements.move',",
        "    'elements.delete',",
        "    'shape.create',",
        "    'shape.delete',",
        "    'shape.move',",
        "    'shape.resize'",
        "  ];",
        "",
        "",
        "  // listen to a lot of stuff to group lane updates",
        "",
        "  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY, function(event) {",
        "    initContext();",
        "  });",
        "",
        "  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY, function(event) {",
        "    releaseContext();",
        "  });",
        "",
        "",
        "  // Mark flow nodes + lanes that need an update",
        "",
        "  this.preExecute([",
        "    'shape.create',",
        "    'shape.move',",
        "    'shape.delete',",
        "    'shape.resize'",
        "  ], function(event) {",
        "",
        "    var context = event.context,",
        "        shape = context.shape;",
        "",
        "    var updateContext = getContext();",
        "",
        "    // no need to update labels",
        "    if (shape.labelTarget) {",
        "      return;",
        "    }",
        "",
        "    if (is(shape, 'bpmn:Lane')) {",
        "      updateContext.addLane(shape);",
        "    }",
        "",
        "    if (is(shape, 'bpmn:FlowNode')) {",
        "      updateContext.addFlowNode(shape);",
        "    }",
        "  });",
        "}",
        "",
        "UpdateFlowNodeRefsBehavior.$inject = [",
        "  'eventBus',",
        "  'modeling' ,",
        "  'translate'",
        "];",
        "",
        "inherits(UpdateFlowNodeRefsBehavior, CommandInterceptor);",
        "",
        "",
        "function UpdateContext() {",
        "",
        "  this.flowNodes = [];",
        "  this.lanes = [];",
        "",
        "  this.counter = 0;",
        "",
        "  this.addLane = function(lane) {",
        "    this.lanes.push(lane);",
        "  };",
        "",
        "  this.addFlowNode = function(flowNode) {",
        "    this.flowNodes.push(flowNode);",
        "  };",
        "",
        "  this.enter = function() {",
        "    this.counter++;",
        "  };",
        "",
        "  this.leave = function() {",
        "    this.counter--;",
        "",
        "    return !this.counter;",
        "  };",
        "}"
    ],
    "lib/features/modeling/cmd/UpdateSemanticParentHandler.js": [
        "export default function UpdateSemanticParentHandler(bpmnUpdater) {",
        "  this._bpmnUpdater = bpmnUpdater;",
        "}",
        "",
        "UpdateSemanticParentHandler.$inject = [ 'bpmnUpdater' ];",
        "",
        "",
        "UpdateSemanticParentHandler.prototype.execute = function(context) {",
        "  var dataStoreBo = context.dataStoreBo,",
        "      newSemanticParent = context.newSemanticParent,",
        "      newDiParent = context.newDiParent;",
        "",
        "  context.oldSemanticParent = dataStoreBo.$parent;",
        "  context.oldDiParent = dataStoreBo.di.$parent;",
        "",
        "  // update semantic parent",
        "  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);",
        "",
        "  // update DI parent",
        "  this._bpmnUpdater.updateDiParent(dataStoreBo.di, newDiParent);",
        "};",
        "",
        "UpdateSemanticParentHandler.prototype.revert = function(context) {",
        "  var dataStoreBo = context.dataStoreBo,",
        "      oldSemanticParent = context.oldSemanticParent,",
        "      oldDiParent = context.oldDiParent;",
        "",
        "  // update semantic parent",
        "  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);",
        "",
        "  // update DI parent",
        "  this._bpmnUpdater.updateDiParent(dataStoreBo.di, oldDiParent);",
        "};",
        ""
    ]
}