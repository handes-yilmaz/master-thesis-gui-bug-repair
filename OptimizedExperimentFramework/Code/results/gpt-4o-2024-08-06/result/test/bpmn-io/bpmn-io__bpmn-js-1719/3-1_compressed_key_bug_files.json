{
    "1": {
        "bug_file": "lib/features/modeling/behavior/LabelBehavior.js",
        "compressed": "NO",
        "line_numbers": 403,
        "compressed_line_numbers": 403,
        "compressed_bug_file_content": "import {\n  assign\n} from 'min-dash';\n\nimport inherits from 'inherits-browser';\n\nimport {\n  is,\n  getBusinessObject,\n  getDi\n} from '../../../util/ModelUtil';\n\nimport {\n  isLabelExternal,\n  getExternalLabelMid,\n  hasExternalLabel,\n  isLabel\n} from '../../../util/LabelUtil';\n\nimport {\n  getLabel\n} from '../../label-editing/LabelUtil';\n\nimport {\n  getLabelAdjustment\n} from './util/LabelLayoutUtil';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport {\n  getNewAttachPoint\n} from 'diagram-js/lib/util/AttachUtil';\n\nimport {\n  getMid,\n  roundPoint\n} from 'diagram-js/lib/layout/LayoutUtil';\n\nimport {\n  delta\n} from 'diagram-js/lib/util/PositionUtil';\n\nimport {\n  sortBy\n} from 'min-dash';\n\nimport {\n  getDistancePointLine,\n  perpendicularFoot\n} from './util/GeometricUtil';\n\nvar DEFAULT_LABEL_DIMENSIONS = {\n  width: 90,\n  height: 20\n};\n\nvar NAME_PROPERTY = 'name';\nvar TEXT_PROPERTY = 'text';\n\n/**\n * A component that makes sure that external labels are added\n * together with respective elements and properly updated (DI wise)\n * during move.\n *\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {BpmnFactory} bpmnFactory\n * @param {TextRenderer} textRenderer\n */\nexport default function LabelBehavior(\n    eventBus, modeling, bpmnFactory,\n    textRenderer) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  // update label if name property was updated\n  this.postExecute('element.updateProperties', function(e) {\n    var context = e.context,\n        element = context.element,\n        properties = context.properties;\n\n    if (NAME_PROPERTY in properties) {\n      modeling.updateLabel(element, properties[NAME_PROPERTY]);\n    }\n\n    if (TEXT_PROPERTY in properties\n        && is(element, 'bpmn:TextAnnotation')) {\n\n      var newBounds = textRenderer.getTextAnnotationBounds(\n        {\n          x: element.x,\n          y: element.y,\n          width: element.width,\n          height: element.height\n        },\n        properties[TEXT_PROPERTY] || ''\n      );\n\n      modeling.updateLabel(element, properties.text, newBounds);\n    }\n  });\n\n  // create label shape after shape/connection was created\n  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {\n    var context = e.context,\n        hints = context.hints || {};\n\n    if (hints.createElementsBehavior === false) {\n      return;\n    }\n\n    var element = context.shape || context.connection,\n        businessObject = element.businessObject;\n\n    if (isLabel(element) || !isLabelExternal(element)) {\n      return;\n    }\n\n    // only create label if attribute available\n    if (!getLabel(element)) {\n      return;\n    }\n\n    var labelCenter = getExternalLabelMid(element);\n\n    // we don't care about x and y\n    var labelDimensions = textRenderer.getExternalLabelBounds(\n      DEFAULT_LABEL_DIMENSIONS,\n      getLabel(element)\n    );\n\n    modeling.createLabel(element, labelCenter, {\n      id: businessObject.id + '_label',\n      businessObject: businessObject,\n      width: labelDimensions.width,\n      height: labelDimensions.height\n    });\n  });\n\n  // update label after label shape was deleted\n  this.postExecute('shape.delete', function(event) {\n    var context = event.context,\n        labelTarget = context.labelTarget,\n        hints = context.hints || {};\n\n    // check if label\n    if (labelTarget && hints.unsetLabel !== false) {\n      modeling.updateLabel(labelTarget, null, null, { removeShape: false });\n    }\n  });\n\n  // update di information on label creation\n  this.postExecute([ 'label.create' ], function(event) {\n\n    var context = event.context,\n        element = context.shape,\n        labelTarget = context.labelTarget,\n        di;\n\n    // we want to trigger on real labels only\n    if (!labelTarget) {\n      return;\n    }\n\n    // we want to trigger on BPMN elements only\n    if (!is(labelTarget, 'bpmn:BaseElement')) {\n      return;\n    }\n\n    di = getDi(labelTarget);\n\n    if (!di.label) {\n      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {\n        bounds: bpmnFactory.create('dc:Bounds')\n      });\n\n      element.di = di;\n    }\n\n    assign(di.label.bounds, {\n      x: element.x,\n      y: element.y,\n      width: element.width,\n      height: element.height\n    });\n  });\n\n  function getVisibleLabelAdjustment(event) {\n\n    var context = event.context,\n        connection = context.connection,\n        label = connection.label,\n        hints = assign({}, context.hints),\n        newWaypoints = context.newWaypoints || connection.waypoints,\n        oldWaypoints = context.oldWaypoints;\n\n\n    if (typeof hints.startChanged === 'undefined') {\n      hints.startChanged = !!hints.connectionStart;\n    }\n\n    if (typeof hints.endChanged === 'undefined') {\n      hints.endChanged = !!hints.connectionEnd;\n    }\n\n    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);\n  }\n\n  this.postExecute([\n    'connection.layout',\n    'connection.updateWaypoints'\n  ], function(event) {\n    var context = event.context,\n        hints = context.hints || {};\n\n    if (hints.labelBehavior === false) {\n      return;\n    }\n\n    var connection = context.connection,\n        label = connection.label,\n        labelAdjustment;\n\n    // handle missing label as well as the case\n    // that the label parent does not exist (yet),\n    // because it is being pasted / created via multi element create\n    //\n    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227\n    if (!label || !label.parent) {\n      return;\n    }\n\n    labelAdjustment = getVisibleLabelAdjustment(event);\n\n    modeling.moveShape(label, labelAdjustment);\n  });\n\n\n  // keep label position on shape replace\n  this.postExecute([ 'shape.replace' ], function(event) {\n    var context = event.context,\n        newShape = context.newShape,\n        oldShape = context.oldShape;\n\n    var businessObject = getBusinessObject(newShape);\n\n    if (businessObject\n      && isLabelExternal(businessObject)\n      && oldShape.label\n      && newShape.label) {\n      newShape.label.x = oldShape.label.x;\n      newShape.label.y = oldShape.label.y;\n    }\n  });\n\n\n  // move external label after resizing\n  this.postExecute('shape.resize', function(event) {\n\n    var context = event.context,\n        shape = context.shape,\n        newBounds = context.newBounds,\n        oldBounds = context.oldBounds;\n\n    if (hasExternalLabel(shape)) {\n\n      var label = shape.label,\n          labelMid = getMid(label),\n          edges = asEdges(oldBounds);\n\n      // get nearest border point to label as reference point\n      var referencePoint = getReferencePoint(labelMid, edges);\n\n      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);\n\n      modeling.moveShape(label, delta);\n\n    }\n\n  });\n\n}\n\ninherits(LabelBehavior, CommandInterceptor);\n\nLabelBehavior.$inject = [\n  'eventBus',\n  'modeling',\n  'bpmnFactory',\n  'textRenderer'\n];\n\n// helpers //////////////////////\n\n/**\n * Calculates a reference point delta relative to a new position\n * of a certain element's bounds\n *\n * @param {Point} point\n * @param {Bounds} oldBounds\n * @param {Bounds} newBounds\n *\n * @return {Delta} delta\n */\nexport function getReferencePointDelta(referencePoint, oldBounds, newBounds) {\n\n  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);\n\n  return roundPoint(delta(newReferencePoint, referencePoint));\n}\n\n/**\n * Generates the nearest point (reference point) for a given point\n * onto given set of lines\n *\n * @param {Array<Point, Point>} lines\n * @param {Point} point\n *\n * @param {Point}\n */\nexport function getReferencePoint(point, lines) {\n\n  if (!lines.length) {\n    return;\n  }\n\n  var nearestLine = getNearestLine(point, lines);\n\n  return perpendicularFoot(point, nearestLine);\n}\n\n/**\n * Convert the given bounds to a lines array containing all edges\n *\n * @param {Bounds|Point} bounds\n *\n * @return Array<Point>\n */\nexport function asEdges(bounds) {\n  return [\n    [ // top\n      {\n        x: bounds.x,\n        y: bounds.y\n      },\n      {\n        x: bounds.x + (bounds.width || 0),\n        y: bounds.y\n      }\n    ],\n    [ // right\n      {\n        x: bounds.x + (bounds.width || 0),\n        y: bounds.y\n      },\n      {\n        x: bounds.x + (bounds.width || 0),\n        y: bounds.y + (bounds.height || 0)\n      }\n    ],\n    [ // bottom\n      {\n        x: bounds.x,\n        y: bounds.y + (bounds.height || 0)\n      },\n      {\n        x: bounds.x + (bounds.width || 0),\n        y: bounds.y + (bounds.height || 0)\n      }\n    ],\n    [ // left\n      {\n        x: bounds.x,\n        y: bounds.y\n      },\n      {\n        x: bounds.x,\n        y: bounds.y + (bounds.height || 0)\n      }\n    ]\n  ];\n}\n\n/**\n * Returns the nearest line for a given point by distance\n * @param {Point} point\n * @param Array<Point> lines\n *\n * @return Array<Point>\n */\nfunction getNearestLine(point, lines) {\n\n  var distances = lines.map(function(l) {\n    return {\n      line: l,\n      distance: getDistancePointLine(point, l)\n    };\n  });\n\n  var sorted = sortBy(distances, 'distance');\n\n  return sorted[0].line;\n}"
    },
    "2": {
        "bug_file": "lib/features/modeling/behavior/SubProcessPlaneBehavior.js",
        "compressed": "YES",
        "line_numbers": 557,
        "compressed_line_numbers": 133,
        "compressed_bug_file_content": "import inherits from 'inherits-browser';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport { find } from 'min-dash';\nimport { isExpanded } from '../../../util/DiUtil';\nimport { getBusinessObject, getDi, is } from '../../../util/ModelUtil';\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport { getBBox } from 'diagram-js/lib/util/Elements';\nimport {\n\n\n/**\n * Creates bpmndi:BPMNPlane elements and canvas planes when collapsed subprocesses are created.\n *\n *\n * @param {Canvas} canvas\n * @param {EventBus} eventBus\n * @param {Modeling} modeling\n * @param {ElementFactory} elementFactory\n * @param {BpmnFactory} bpmnFactory\n * @param {Bpmnjs} bpmnjs\n * @param {ElementRegistry} elementRegistry\n */\nexport default function SubProcessPlaneBehavior(\n\n\n  // add plane elements for newly created sub-processes\n  // this ensures we can actually drill down into the element\n\n\n    // old plane could have content,\n    // we remove it so it is not recursively deleted from 'shape.delete'\n\n\n  // rename primary elements when the secondary element changes\n  // this ensures rootElement.id = element.id + '_plane'\n\n\n  // re-throw element.changed to re-render primary shape if associated plane has\n  // changed (e.g. bpmn:name property has changed)\n\n\n    // do not re-throw if no associated primary shape (e.g. bpmn:Process)\n\n\n  // create/remove plane for the subprocess\n\n\n  // create/remove plane for the subprocess\n\n\n  // move elements between planes\n\n\n      // collapsed\n\n\n  // copy-paste ///////////\n\n  // add elements in plane to tree\n\n\n      // do not copy invisible root element\n\n\n  // set plane children as direct children of collapsed shape\n\n\n  // hide children during pasting\n\n\n/**\n * Moves the child elements from source to target.\n *\n * If the target is a plane, the children are moved to the top left corner.\n * Otherwise, the center of the target is used.\n *\n * @param {Object|djs.model.Base} source\n * @param {Object|djs.model.Base} target\n */\n\n\n  // only change plane if there are no visible children, but don't move them\n\n\n  // target is a plane\n\n\n  // source is a plane\n\n\n    // move relative to the center of the shape\n\n\n/**\n * Sets `hidden` property on all children of the given shape.\n *\n * @param {Array} elements\n * @param {Boolean} [hidden]\n * @returns {Array} all child elements\n */\n\n\n/**\n* Adds a given rootElement to the bpmnDi diagrams.\n*\n* @param {Object} rootElement\n* @returns {Object} planeElement\n*/\n\n\n/**\n* Creates a new plane element for the given sub process.\n*\n* @param {Object} bpmnElement\n*\n* @return {Object} new diagram element\n*/\n\n\n  // add a virtual element (not being drawn),\n  // a copy cat of our BpmnImporter code\n\n\n/**\n * Removes the diagram for a given root element\n *\n * @param {Object} rootElement\n * @returns {Object} removed bpmndi:BPMNDiagram\n */\n\n\n"
    },
    "3": {
        "bug_file": "lib/features/drilldown/DrilldownOverlayBehavior.js",
        "compressed": "NO",
        "line_numbers": 181,
        "compressed_line_numbers": 181,
        "compressed_bug_file_content": "import inherits from 'inherits-browser';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\nimport { is } from '../../util/ModelUtil';\nimport { classes, domify } from 'min-dom';\nimport { getPlaneIdFromShape } from '../../util/DrilldownUtil';\n\nvar LOW_PRIORITY = 250;\nvar ARROW_DOWN_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z\"/></svg>';\n\nvar EMPTY_MARKER = 'bjs-drilldown-empty';\n\nexport default function DrilldownOverlayBehavior(\n    canvas, eventBus, elementRegistry, overlays\n) {\n  CommandInterceptor.call(this, eventBus);\n\n  this._canvas = canvas;\n  this._eventBus = eventBus;\n  this._elementRegistry = elementRegistry;\n  this._overlays = overlays;\n\n  var self = this;\n\n  this.executed('shape.toggleCollapse', LOW_PRIORITY, function(context) {\n    var shape = context.shape;\n\n    // Add overlay to the collapsed shape\n    if (self.canDrillDown(shape)) {\n      self.addOverlay(shape);\n    } else {\n      self.removeOverlay(shape);\n    }\n  }, true);\n\n\n  this.reverted('shape.toggleCollapse', LOW_PRIORITY, function(context) {\n    var shape = context.shape;\n\n    // Add overlay to the collapsed shape\n    if (self.canDrillDown(shape)) {\n      self.addOverlay(shape);\n    } else {\n      self.removeOverlay(shape);\n    }\n  }, true);\n\n\n  this.executed(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,\n    function(context) {\n      var oldParent = context.oldParent,\n          newParent = context.newParent || context.parent,\n          shape = context.shape;\n\n      // Add overlay to the collapsed shape\n      if (self.canDrillDown(shape)) {\n        self.addOverlay(shape);\n      }\n\n      self.updateDrilldownOverlay(oldParent);\n      self.updateDrilldownOverlay(newParent);\n      self.updateDrilldownOverlay(shape);\n    }, true);\n\n\n  this.reverted(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,\n    function(context) {\n      var oldParent = context.oldParent,\n          newParent = context.newParent || context.parent,\n          shape = context.shape;\n\n      // Add overlay to the collapsed shape\n      if (self.canDrillDown(shape)) {\n        self.addOverlay(shape);\n      }\n\n      self.updateDrilldownOverlay(oldParent);\n      self.updateDrilldownOverlay(newParent);\n      self.updateDrilldownOverlay(shape);\n    }, true);\n\n\n  eventBus.on('import.render.complete', function() {\n    elementRegistry.filter(function(e) {\n      return self.canDrillDown(e);\n    }).map(function(el) {\n      self.addOverlay(el);\n    });\n  });\n\n}\n\ninherits(DrilldownOverlayBehavior, CommandInterceptor);\n\nDrilldownOverlayBehavior.prototype.updateDrilldownOverlay = function(shape) {\n  var canvas = this._canvas;\n\n  if (!shape) {\n    return;\n  }\n\n  var root = canvas.findRoot(shape);\n  if (root) {\n    this.updateOverlayVisibility(root);\n  }\n};\n\n\nDrilldownOverlayBehavior.prototype.canDrillDown = function(element) {\n  var canvas = this._canvas;\n  return is(element, 'bpmn:SubProcess') && canvas.findRoot(getPlaneIdFromShape(element));\n};\n\n/**\n * Updates visibility of the drilldown overlay. If the plane has no elements,\n * the drilldown will be only shown when the element is selected.\n *\n * @param {djs.model.Shape|djs.model.Root} element collapsed shape or root element\n */\nDrilldownOverlayBehavior.prototype.updateOverlayVisibility = function(element) {\n  var overlays = this._overlays;\n\n  var bo = element.businessObject;\n\n  var overlay = overlays.get({ element: bo.id, type: 'drilldown' })[0];\n\n  if (!overlay) {\n    return;\n  }\n\n  var hasContent = bo && bo.flowElements && bo.flowElements.length;\n  classes(overlay.html).toggle(EMPTY_MARKER, !hasContent);\n};\n\n/**\n * Attaches a drilldown button to the given element. We assume that the plane has\n * the same id as the element.\n *\n * @param {djs.model.Shape} element collapsed shape\n */\nDrilldownOverlayBehavior.prototype.addOverlay = function(element) {\n  var canvas = this._canvas;\n  var overlays = this._overlays;\n\n  var existingOverlays = overlays.get({ element: element, type: 'drilldown' });\n  if (existingOverlays.length) {\n    this.removeOverlay(element);\n  }\n\n  var button = domify('<button class=\"bjs-drilldown\">' + ARROW_DOWN_SVG + '</button>');\n\n  button.addEventListener('click', function() {\n    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));\n  });\n\n  overlays.add(element, 'drilldown', {\n    position: {\n      bottom: -7,\n      right: -8\n    },\n    html: button\n  });\n\n  this.updateOverlayVisibility(element);\n};\n\nDrilldownOverlayBehavior.prototype.removeOverlay = function(element) {\n  var overlays = this._overlays;\n\n  overlays.remove({\n    element: element,\n    type: 'drilldown'\n  });\n};\n\nDrilldownOverlayBehavior.$inject = [\n  'canvas',\n  'eventBus',\n  'elementRegistry',\n  'overlays'\n];"
    }
}