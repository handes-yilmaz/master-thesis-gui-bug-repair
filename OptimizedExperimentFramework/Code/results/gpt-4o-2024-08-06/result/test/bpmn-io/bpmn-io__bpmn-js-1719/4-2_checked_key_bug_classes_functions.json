{
    "bug_classes": {
        "1": {
            "class_name": "LabelBehavior (not found) ",
            "file_path": "lib/features/modeling/behavior/LabelBehavior.js",
            "class_details": [
                {
                    "name": "LabelBehavior",
                    "start_line": 1,
                    "end_line": 403
                }
            ],
            "class_code": [
                "import {",
                "  assign",
                "} from 'min-dash';",
                "",
                "import inherits from 'inherits-browser';",
                "",
                "import {",
                "  is,",
                "  getBusinessObject,",
                "  getDi",
                "} from '../../../util/ModelUtil';",
                "",
                "import {",
                "  isLabelExternal,",
                "  getExternalLabelMid,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../../util/LabelUtil';",
                "",
                "import {",
                "  getLabel",
                "} from '../../label-editing/LabelUtil';",
                "",
                "import {",
                "  getLabelAdjustment",
                "} from './util/LabelLayoutUtil';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "",
                "import {",
                "  getNewAttachPoint",
                "} from 'diagram-js/lib/util/AttachUtil';",
                "",
                "import {",
                "  getMid,",
                "  roundPoint",
                "} from 'diagram-js/lib/layout/LayoutUtil';",
                "",
                "import {",
                "  delta",
                "} from 'diagram-js/lib/util/PositionUtil';",
                "",
                "import {",
                "  sortBy",
                "} from 'min-dash';",
                "",
                "import {",
                "  getDistancePointLine,",
                "  perpendicularFoot",
                "} from './util/GeometricUtil';",
                "",
                "var DEFAULT_LABEL_DIMENSIONS = {",
                "  width: 90,",
                "  height: 20",
                "};",
                "",
                "var NAME_PROPERTY = 'name';",
                "var TEXT_PROPERTY = 'text';",
                "",
                "/**",
                " * A component that makes sure that external labels are added",
                " * together with respective elements and properly updated (DI wise)",
                " * during move.",
                " *",
                " * @param {EventBus} eventBus",
                " * @param {Modeling} modeling",
                " * @param {BpmnFactory} bpmnFactory",
                " * @param {TextRenderer} textRenderer",
                " */",
                "export default function LabelBehavior(",
                "    eventBus, modeling, bpmnFactory,",
                "    textRenderer) {",
                "",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  // update label if name property was updated",
                "  this.postExecute('element.updateProperties', function(e) {",
                "    var context = e.context,",
                "        element = context.element,",
                "        properties = context.properties;",
                "",
                "    if (NAME_PROPERTY in properties) {",
                "      modeling.updateLabel(element, properties[NAME_PROPERTY]);",
                "    }",
                "",
                "    if (TEXT_PROPERTY in properties",
                "        && is(element, 'bpmn:TextAnnotation')) {",
                "",
                "      var newBounds = textRenderer.getTextAnnotationBounds(",
                "        {",
                "          x: element.x,",
                "          y: element.y,",
                "          width: element.width,",
                "          height: element.height",
                "        },",
                "        properties[TEXT_PROPERTY] || ''",
                "      );",
                "",
                "      modeling.updateLabel(element, properties.text, newBounds);",
                "    }",
                "  });",
                "",
                "  // create label shape after shape/connection was created",
                "  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {",
                "    var context = e.context,",
                "        hints = context.hints || {};",
                "",
                "    if (hints.createElementsBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    var element = context.shape || context.connection,",
                "        businessObject = element.businessObject;",
                "",
                "    if (isLabel(element) || !isLabelExternal(element)) {",
                "      return;",
                "    }",
                "",
                "    // only create label if attribute available",
                "    if (!getLabel(element)) {",
                "      return;",
                "    }",
                "",
                "    var labelCenter = getExternalLabelMid(element);",
                "",
                "    // we don't care about x and y",
                "    var labelDimensions = textRenderer.getExternalLabelBounds(",
                "      DEFAULT_LABEL_DIMENSIONS,",
                "      getLabel(element)",
                "    );",
                "",
                "    modeling.createLabel(element, labelCenter, {",
                "      id: businessObject.id + '_label',",
                "      businessObject: businessObject,",
                "      width: labelDimensions.width,",
                "      height: labelDimensions.height",
                "    });",
                "  });",
                "",
                "  // update label after label shape was deleted",
                "  this.postExecute('shape.delete', function(event) {",
                "    var context = event.context,",
                "        labelTarget = context.labelTarget,",
                "        hints = context.hints || {};",
                "",
                "    // check if label",
                "    if (labelTarget && hints.unsetLabel !== false) {",
                "      modeling.updateLabel(labelTarget, null, null, { removeShape: false });",
                "    }",
                "  });",
                "",
                "  // update di information on label creation",
                "  this.postExecute([ 'label.create' ], function(event) {",
                "",
                "    var context = event.context,",
                "        element = context.shape,",
                "        labelTarget = context.labelTarget,",
                "        di;",
                "",
                "    // we want to trigger on real labels only",
                "    if (!labelTarget) {",
                "      return;",
                "    }",
                "",
                "    // we want to trigger on BPMN elements only",
                "    if (!is(labelTarget, 'bpmn:BaseElement')) {",
                "      return;",
                "    }",
                "",
                "    di = getDi(labelTarget);",
                "",
                "    if (!di.label) {",
                "      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {",
                "        bounds: bpmnFactory.create('dc:Bounds')",
                "      });",
                "",
                "      element.di = di;",
                "    }",
                "",
                "    assign(di.label.bounds, {",
                "      x: element.x,",
                "      y: element.y,",
                "      width: element.width,",
                "      height: element.height",
                "    });",
                "  });",
                "",
                "  function getVisibleLabelAdjustment(event) {",
                "",
                "    var context = event.context,",
                "        connection = context.connection,",
                "        label = connection.label,",
                "        hints = assign({}, context.hints),",
                "        newWaypoints = context.newWaypoints || connection.waypoints,",
                "        oldWaypoints = context.oldWaypoints;",
                "",
                "",
                "    if (typeof hints.startChanged === 'undefined') {",
                "      hints.startChanged = !!hints.connectionStart;",
                "    }",
                "",
                "    if (typeof hints.endChanged === 'undefined') {",
                "      hints.endChanged = !!hints.connectionEnd;",
                "    }",
                "",
                "    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);",
                "  }",
                "",
                "  this.postExecute([",
                "    'connection.layout',",
                "    'connection.updateWaypoints'",
                "  ], function(event) {",
                "    var context = event.context,",
                "        hints = context.hints || {};",
                "",
                "    if (hints.labelBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    var connection = context.connection,",
                "        label = connection.label,",
                "        labelAdjustment;",
                "",
                "    // handle missing label as well as the case",
                "    // that the label parent does not exist (yet),",
                "    // because it is being pasted / created via multi element create",
                "    //",
                "    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227",
                "    if (!label || !label.parent) {",
                "      return;",
                "    }",
                "",
                "    labelAdjustment = getVisibleLabelAdjustment(event);",
                "",
                "    modeling.moveShape(label, labelAdjustment);",
                "  });",
                "",
                "",
                "  // keep label position on shape replace",
                "  this.postExecute([ 'shape.replace' ], function(event) {",
                "    var context = event.context,",
                "        newShape = context.newShape,",
                "        oldShape = context.oldShape;",
                "",
                "    var businessObject = getBusinessObject(newShape);",
                "",
                "    if (businessObject",
                "      && isLabelExternal(businessObject)",
                "      && oldShape.label",
                "      && newShape.label) {",
                "      newShape.label.x = oldShape.label.x;",
                "      newShape.label.y = oldShape.label.y;",
                "    }",
                "  });",
                "",
                "",
                "  // move external label after resizing",
                "  this.postExecute('shape.resize', function(event) {",
                "",
                "    var context = event.context,",
                "        shape = context.shape,",
                "        newBounds = context.newBounds,",
                "        oldBounds = context.oldBounds;",
                "",
                "    if (hasExternalLabel(shape)) {",
                "",
                "      var label = shape.label,",
                "          labelMid = getMid(label),",
                "          edges = asEdges(oldBounds);",
                "",
                "      // get nearest border point to label as reference point",
                "      var referencePoint = getReferencePoint(labelMid, edges);",
                "",
                "      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);",
                "",
                "      modeling.moveShape(label, delta);",
                "",
                "    }",
                "",
                "  });",
                "",
                "}",
                "",
                "inherits(LabelBehavior, CommandInterceptor);",
                "",
                "LabelBehavior.$inject = [",
                "  'eventBus',",
                "  'modeling',",
                "  'bpmnFactory',",
                "  'textRenderer'",
                "];",
                "",
                "// helpers //////////////////////",
                "",
                "/**",
                " * Calculates a reference point delta relative to a new position",
                " * of a certain element's bounds",
                " *",
                " * @param {Point} point",
                " * @param {Bounds} oldBounds",
                " * @param {Bounds} newBounds",
                " *",
                " * @return {Delta} delta",
                " */",
                "export function getReferencePointDelta(referencePoint, oldBounds, newBounds) {",
                "",
                "  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);",
                "",
                "  return roundPoint(delta(newReferencePoint, referencePoint));",
                "}",
                "",
                "/**",
                " * Generates the nearest point (reference point) for a given point",
                " * onto given set of lines",
                " *",
                " * @param {Array<Point, Point>} lines",
                " * @param {Point} point",
                " *",
                " * @param {Point}",
                " */",
                "export function getReferencePoint(point, lines) {",
                "",
                "  if (!lines.length) {",
                "    return;",
                "  }",
                "",
                "  var nearestLine = getNearestLine(point, lines);",
                "",
                "  return perpendicularFoot(point, nearestLine);",
                "}",
                "",
                "/**",
                " * Convert the given bounds to a lines array containing all edges",
                " *",
                " * @param {Bounds|Point} bounds",
                " *",
                " * @return Array<Point>",
                " */",
                "export function asEdges(bounds) {",
                "  return [",
                "    [ // top",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y",
                "      }",
                "    ],",
                "    [ // right",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ],",
                "    [ // bottom",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y + (bounds.height || 0)",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ],",
                "    [ // left",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ]",
                "  ];",
                "}",
                "",
                "/**",
                " * Returns the nearest line for a given point by distance",
                " * @param {Point} point",
                " * @param Array<Point> lines",
                " *",
                " * @return Array<Point>",
                " */",
                "function getNearestLine(point, lines) {",
                "",
                "  var distances = lines.map(function(l) {",
                "    return {",
                "      line: l,",
                "      distance: getDistancePointLine(point, l)",
                "    };",
                "  });",
                "",
                "  var sorted = sortBy(distances, 'distance');",
                "",
                "  return sorted[0].line;",
                "}"
            ]
        },
        "2": {
            "class_name": "DrilldownOverlayBehavior (not found) ",
            "file_path": "lib/features/drilldown/DrilldownOverlayBehavior.js",
            "class_details": [
                {
                    "name": "DrilldownOverlayBehavior",
                    "start_line": 1,
                    "end_line": 181
                }
            ],
            "class_code": [
                "import inherits from 'inherits-browser';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "import { is } from '../../util/ModelUtil';",
                "import { classes, domify } from 'min-dom';",
                "import { getPlaneIdFromShape } from '../../util/DrilldownUtil';",
                "",
                "var LOW_PRIORITY = 250;",
                "var ARROW_DOWN_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z\"/></svg>';",
                "",
                "var EMPTY_MARKER = 'bjs-drilldown-empty';",
                "",
                "export default function DrilldownOverlayBehavior(",
                "    canvas, eventBus, elementRegistry, overlays",
                ") {",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  this._canvas = canvas;",
                "  this._eventBus = eventBus;",
                "  this._elementRegistry = elementRegistry;",
                "  this._overlays = overlays;",
                "",
                "  var self = this;",
                "",
                "  this.executed('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    // Add overlay to the collapsed shape",
                "    if (self.canDrillDown(shape)) {",
                "      self.addOverlay(shape);",
                "    } else {",
                "      self.removeOverlay(shape);",
                "    }",
                "  }, true);",
                "",
                "",
                "  this.reverted('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    // Add overlay to the collapsed shape",
                "    if (self.canDrillDown(shape)) {",
                "      self.addOverlay(shape);",
                "    } else {",
                "      self.removeOverlay(shape);",
                "    }",
                "  }, true);",
                "",
                "",
                "  this.executed(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,",
                "    function(context) {",
                "      var oldParent = context.oldParent,",
                "          newParent = context.newParent || context.parent,",
                "          shape = context.shape;",
                "",
                "      // Add overlay to the collapsed shape",
                "      if (self.canDrillDown(shape)) {",
                "        self.addOverlay(shape);",
                "      }",
                "",
                "      self.updateDrilldownOverlay(oldParent);",
                "      self.updateDrilldownOverlay(newParent);",
                "      self.updateDrilldownOverlay(shape);",
                "    }, true);",
                "",
                "",
                "  this.reverted(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,",
                "    function(context) {",
                "      var oldParent = context.oldParent,",
                "          newParent = context.newParent || context.parent,",
                "          shape = context.shape;",
                "",
                "      // Add overlay to the collapsed shape",
                "      if (self.canDrillDown(shape)) {",
                "        self.addOverlay(shape);",
                "      }",
                "",
                "      self.updateDrilldownOverlay(oldParent);",
                "      self.updateDrilldownOverlay(newParent);",
                "      self.updateDrilldownOverlay(shape);",
                "    }, true);",
                "",
                "",
                "  eventBus.on('import.render.complete', function() {",
                "    elementRegistry.filter(function(e) {",
                "      return self.canDrillDown(e);",
                "    }).map(function(el) {",
                "      self.addOverlay(el);",
                "    });",
                "  });",
                "",
                "}",
                "",
                "inherits(DrilldownOverlayBehavior, CommandInterceptor);",
                "",
                "DrilldownOverlayBehavior.prototype.updateDrilldownOverlay = function(shape) {",
                "  var canvas = this._canvas;",
                "",
                "  if (!shape) {",
                "    return;",
                "  }",
                "",
                "  var root = canvas.findRoot(shape);",
                "  if (root) {",
                "    this.updateOverlayVisibility(root);",
                "  }",
                "};",
                "",
                "",
                "DrilldownOverlayBehavior.prototype.canDrillDown = function(element) {",
                "  var canvas = this._canvas;",
                "  return is(element, 'bpmn:SubProcess') && canvas.findRoot(getPlaneIdFromShape(element));",
                "};",
                "",
                "/**",
                " * Updates visibility of the drilldown overlay. If the plane has no elements,",
                " * the drilldown will be only shown when the element is selected.",
                " *",
                " * @param {djs.model.Shape|djs.model.Root} element collapsed shape or root element",
                " */",
                "DrilldownOverlayBehavior.prototype.updateOverlayVisibility = function(element) {",
                "  var overlays = this._overlays;",
                "",
                "  var bo = element.businessObject;",
                "",
                "  var overlay = overlays.get({ element: bo.id, type: 'drilldown' })[0];",
                "",
                "  if (!overlay) {",
                "    return;",
                "  }",
                "",
                "  var hasContent = bo && bo.flowElements && bo.flowElements.length;",
                "  classes(overlay.html).toggle(EMPTY_MARKER, !hasContent);",
                "};",
                "",
                "/**",
                " * Attaches a drilldown button to the given element. We assume that the plane has",
                " * the same id as the element.",
                " *",
                " * @param {djs.model.Shape} element collapsed shape",
                " */",
                "DrilldownOverlayBehavior.prototype.addOverlay = function(element) {",
                "  var canvas = this._canvas;",
                "  var overlays = this._overlays;",
                "",
                "  var existingOverlays = overlays.get({ element: element, type: 'drilldown' });",
                "  if (existingOverlays.length) {",
                "    this.removeOverlay(element);",
                "  }",
                "",
                "  var button = domify('<button class=\"bjs-drilldown\">' + ARROW_DOWN_SVG + '</button>');",
                "",
                "  button.addEventListener('click', function() {",
                "    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));",
                "  });",
                "",
                "  overlays.add(element, 'drilldown', {",
                "    position: {",
                "      bottom: -7,",
                "      right: -8",
                "    },",
                "    html: button",
                "  });",
                "",
                "  this.updateOverlayVisibility(element);",
                "};",
                "",
                "DrilldownOverlayBehavior.prototype.removeOverlay = function(element) {",
                "  var overlays = this._overlays;",
                "",
                "  overlays.remove({",
                "    element: element,",
                "    type: 'drilldown'",
                "  });",
                "};",
                "",
                "DrilldownOverlayBehavior.$inject = [",
                "  'canvas',",
                "  'eventBus',",
                "  'elementRegistry',",
                "  'overlays'",
                "];"
            ]
        },
        "3": {
            "class_name": "SubProcessPlaneBehavior (not found) 39-539",
            "file_path": "lib/features/modeling/behavior/SubProcessPlaneBehavior.js",
            "class_details": [
                {
                    "name": "SubProcessPlaneBehavior",
                    "start_line": 39,
                    "end_line": 539
                }
            ],
            "class_code": [
                "export default function SubProcessPlaneBehavior(",
                "    canvas, eventBus, modeling,",
                "    elementFactory, bpmnFactory, bpmnjs, elementRegistry) {",
                "",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  this._canvas = canvas;",
                "  this._eventBus = eventBus;",
                "  this._modeling = modeling;",
                "  this._elementFactory = elementFactory;",
                "  this._bpmnFactory = bpmnFactory;",
                "  this._bpmnjs = bpmnjs;",
                "  this._elementRegistry = elementRegistry;",
                "",
                "  var self = this;",
                "",
                "  function isCollapsedSubProcess(element) {",
                "    return is(element, 'bpmn:SubProcess') && !isExpanded(element);",
                "  }",
                "",
                "  function createRoot(context) {",
                "    var shape = context.shape,",
                "        rootElement = context.newRootElement;",
                "",
                "    var businessObject = getBusinessObject(shape);",
                "",
                "    rootElement = self._addDiagram(rootElement || businessObject);",
                "",
                "    context.newRootElement = canvas.addRootElement(rootElement);",
                "  }",
                "",
                "  function removeRoot(context) {",
                "    var shape = context.shape;",
                "",
                "    var businessObject = getBusinessObject(shape);",
                "    self._removeDiagram(businessObject);",
                "",
                "    var rootElement = context.newRootElement = elementRegistry.get(getPlaneIdFromShape(businessObject));",
                "",
                "    canvas.removeRootElement(rootElement);",
                "  }",
                "",
                "  // add plane elements for newly created sub-processes",
                "  // this ensures we can actually drill down into the element",
                "  this.executed('shape.create', function(context) {",
                "    var shape = context.shape;",
                "    if (!isCollapsedSubProcess(shape)) {",
                "      return;",
                "    }",
                "",
                "    createRoot(context);",
                "  }, true);",
                "",
                "",
                "  this.postExecuted('shape.create', function(context) {",
                "    var shape = context.shape,",
                "        rootElement = context.newRootElement;",
                "",
                "    if (!rootElement || !shape.children) {",
                "      return;",
                "    }",
                "",
                "    self._showRecursively(shape.children);",
                "",
                "    self._moveChildrenToShape(shape, rootElement);",
                "  }, true);",
                "",
                "",
                "  this.reverted('shape.create', function(context) {",
                "    var shape = context.shape;",
                "    if (!isCollapsedSubProcess(shape)) {",
                "      return;",
                "    }",
                "",
                "    removeRoot(context);",
                "  }, true);",
                "",
                "",
                "  this.preExecuted('shape.delete', function(context) {",
                "    var shape = context.shape;",
                "    if (!isCollapsedSubProcess(shape)) {",
                "      return;",
                "    }",
                "",
                "    var attachedRoot = elementRegistry.get(getPlaneIdFromShape(shape));",
                "",
                "    if (!attachedRoot) {",
                "      return;",
                "    }",
                "",
                "    modeling.removeElements(attachedRoot.children.slice());",
                "  }, true);",
                "",
                "",
                "  this.executed('shape.delete', function(context) {",
                "    var shape = context.shape;",
                "    if (!isCollapsedSubProcess(shape)) {",
                "      return;",
                "    }",
                "    removeRoot(context);",
                "  }, true);",
                "",
                "",
                "  this.reverted('shape.delete', function(context) {",
                "    var shape = context.shape;",
                "    if (!isCollapsedSubProcess(shape)) {",
                "      return;",
                "    }",
                "",
                "    createRoot(context);",
                "  }, true);",
                "",
                "",
                "  this.preExecuted('shape.replace', function(context) {",
                "    var oldShape = context.oldShape;",
                "    var newShape = context.newShape;",
                "",
                "    if (!isCollapsedSubProcess(oldShape) || !isCollapsedSubProcess(newShape)) {",
                "      return;",
                "    }",
                "",
                "    // old plane could have content,",
                "    // we remove it so it is not recursively deleted from 'shape.delete'",
                "    context.oldRoot = canvas.removeRootElement(getPlaneIdFromShape(oldShape));",
                "  }, true);",
                "",
                "",
                "  this.postExecuted('shape.replace', function(context) {",
                "    var newShape = context.newShape,",
                "        source = context.oldRoot,",
                "        target = canvas.findRoot(getPlaneIdFromShape(newShape));",
                "",
                "    if (!source || !target) {",
                "      return;",
                "    }",
                "    var elements = source.children;",
                "",
                "    modeling.moveElements(elements, { x: 0, y: 0 }, target);",
                "  }, true);",
                "",
                "",
                "  // rename primary elements when the secondary element changes",
                "  // this ensures rootElement.id = element.id + '_plane'",
                "  this.executed('element.updateProperties', function(context) {",
                "    var shape = context.element;",
                "",
                "    if (!is(shape, 'bpmn:SubProcess')) {",
                "      return;",
                "    }",
                "",
                "    var properties = context.properties;",
                "    var oldProperties = context.oldProperties;",
                "",
                "    var oldId = oldProperties.id,",
                "        newId = properties.id;",
                "",
                "    if (oldId === newId) {",
                "      return;",
                "    }",
                "",
                "    if (isPlane(shape)) {",
                "      elementRegistry.updateId(shape, toPlaneId(newId));",
                "      elementRegistry.updateId(oldId, newId);",
                "",
                "      return;",
                "    }",
                "",
                "    var planeElement = elementRegistry.get(toPlaneId(oldId));",
                "",
                "    if (!planeElement) {",
                "      return;",
                "    }",
                "",
                "    elementRegistry.updateId(toPlaneId(oldId), toPlaneId(newId));",
                "  }, true);",
                "",
                "",
                "  this.reverted('element.updateProperties', function(context) {",
                "    var shape = context.element;",
                "",
                "    if (!is(shape, 'bpmn:SubProcess')) {",
                "      return;",
                "    }",
                "",
                "    var properties = context.properties;",
                "    var oldProperties = context.oldProperties;",
                "",
                "    var oldId = oldProperties.id,",
                "        newId = properties.id;",
                "",
                "    if (oldId === newId) {",
                "      return;",
                "    }",
                "",
                "    if (isPlane(shape)) {",
                "      elementRegistry.updateId(shape, toPlaneId(oldId));",
                "      elementRegistry.updateId(newId, oldId);",
                "",
                "      return;",
                "    }",
                "",
                "    var planeElement = elementRegistry.get(toPlaneId(newId));",
                "",
                "    if (!planeElement) {",
                "      return;",
                "    }",
                "",
                "    elementRegistry.updateId(planeElement, toPlaneId(oldId));",
                "  }, true);",
                "",
                "  // re-throw element.changed to re-render primary shape if associated plane has",
                "  // changed (e.g. bpmn:name property has changed)",
                "  eventBus.on('element.changed', function(context) {",
                "    var element = context.element;",
                "",
                "    if (!isPlane(element)) {",
                "      return;",
                "    }",
                "",
                "    var plane = element;",
                "",
                "    var primaryShape = elementRegistry.get(getShapeIdFromPlane(plane));",
                "",
                "    // do not re-throw if no associated primary shape (e.g. bpmn:Process)",
                "    if (!primaryShape || primaryShape === plane) {",
                "      return;",
                "    }",
                "",
                "    eventBus.fire('element.changed', { element: primaryShape });",
                "  });",
                "",
                "",
                "  // create/remove plane for the subprocess",
                "  this.executed('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    if (!is(shape, 'bpmn:SubProcess')) {",
                "      return;",
                "    }",
                "",
                "    if (!isExpanded(shape)) {",
                "      createRoot(context);",
                "      self._showRecursively(shape.children);",
                "    } else {",
                "      removeRoot(context);",
                "    }",
                "",
                "  }, true);",
                "",
                "",
                "  // create/remove plane for the subprocess",
                "  this.reverted('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    if (!is(shape, 'bpmn:SubProcess')) {",
                "      return;",
                "    }",
                "",
                "    if (!isExpanded(shape)) {",
                "      createRoot(context);",
                "      self._showRecursively(shape.children);",
                "    } else {",
                "      removeRoot(context);",
                "    }",
                "",
                "  }, true);",
                "",
                "  // move elements between planes",
                "  this.postExecuted('shape.toggleCollapse', HIGH_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    if (!is(shape, 'bpmn:SubProcess')) {",
                "      return;",
                "    }",
                "",
                "    var rootElement = context.newRootElement;",
                "",
                "    if (!rootElement) {",
                "      return;",
                "    }",
                "",
                "    if (!isExpanded(shape)) {",
                "",
                "      // collapsed",
                "      self._moveChildrenToShape(shape, rootElement);",
                "",
                "    } else {",
                "      self._moveChildrenToShape(rootElement, shape);",
                "    }",
                "  }, true);",
                "",
                "",
                "  // copy-paste ///////////",
                "",
                "  // add elements in plane to tree",
                "  eventBus.on('copyPaste.createTree', function(context) {",
                "    var element = context.element,",
                "        children = context.children;",
                "",
                "    if (!isCollapsedSubProcess(element)) {",
                "      return;",
                "    }",
                "",
                "    var id = getPlaneIdFromShape(element);",
                "    var parent = elementRegistry.get(id);",
                "",
                "    if (parent) {",
                "",
                "      // do not copy invisible root element",
                "      children.push.apply(children, parent.children);",
                "    }",
                "  });",
                "",
                "  // set plane children as direct children of collapsed shape",
                "  eventBus.on('copyPaste.copyElement', function(context) {",
                "    var descriptor = context.descriptor,",
                "        element = context.element,",
                "        elements = context.elements;",
                "",
                "    var parent = element.parent;",
                "",
                "    var isPlane = is(getDi(parent), 'bpmndi:BPMNPlane');",
                "    if (!isPlane) {",
                "      return;",
                "    }",
                "",
                "    var parentId = getShapeIdFromPlane(parent);",
                "",
                "    var referencedShape = find(elements, function(element) {",
                "      return element.id === parentId;",
                "    });",
                "",
                "    if (!referencedShape) {",
                "      return;",
                "    }",
                "",
                "    descriptor.parent = referencedShape.id;",
                "  });",
                "",
                "  // hide children during pasting",
                "  eventBus.on('copyPaste.pasteElement', function(context) {",
                "    var descriptor = context.descriptor;",
                "",
                "    if (!descriptor.parent) {",
                "      return;",
                "    }",
                "",
                "    if (isCollapsedSubProcess(descriptor.parent) || descriptor.parent.hidden) {",
                "      descriptor.hidden = true;",
                "    }",
                "  });",
                "",
                "}",
                "",
                "inherits(SubProcessPlaneBehavior, CommandInterceptor);",
                "",
                "/**",
                " * Moves the child elements from source to target.",
                " *",
                " * If the target is a plane, the children are moved to the top left corner.",
                " * Otherwise, the center of the target is used.",
                " *",
                " * @param {Object|djs.model.Base} source",
                " * @param {Object|djs.model.Base} target",
                " */",
                "SubProcessPlaneBehavior.prototype._moveChildrenToShape = function(source, target) {",
                "  var modeling = this._modeling;",
                "",
                "  var children = source.children;",
                "  var offset;",
                "",
                "  if (!children) {",
                "    return;",
                "  }",
                "",
                "  // only change plane if there are no visible children, but don't move them",
                "  var visibleChildren = children.filter(function(child) {",
                "    return !child.hidden;",
                "  });",
                "",
                "  if (!visibleChildren.length) {",
                "    modeling.moveElements(children, { x: 0, y: 0 }, target, { autoResize: false });",
                "    return;",
                "  }",
                "",
                "  var childrenBounds = getBBox(visibleChildren);",
                "",
                "  // target is a plane",
                "  if (!target.x) {",
                "    offset = {",
                "      x: DEFAULT_POSITION.x - childrenBounds.x,",
                "      y: DEFAULT_POSITION.y - childrenBounds.y",
                "    };",
                "  }",
                "",
                "  // source is a plane",
                "  else {",
                "",
                "    // move relative to the center of the shape",
                "    var targetMid = getMid(target);",
                "    var childrenMid = getMid(childrenBounds);",
                "",
                "    offset = {",
                "      x: targetMid.x - childrenMid.x,",
                "      y: targetMid.y - childrenMid.y",
                "    };",
                "  }",
                "",
                "  modeling.moveElements(children, offset, target, { autoResize: false });",
                "};",
                "",
                "/**",
                " * Sets `hidden` property on all children of the given shape.",
                " *",
                " * @param {Array} elements",
                " * @param {Boolean} [hidden]",
                " * @returns {Array} all child elements",
                " */",
                "SubProcessPlaneBehavior.prototype._showRecursively = function(elements, hidden) {",
                "  var self = this;",
                "",
                "  var result = [];",
                "  elements.forEach(function(element) {",
                "    element.hidden = !!hidden;",
                "",
                "    result = result.concat(element);",
                "",
                "    if (element.children) {",
                "      result = result.concat(",
                "        self._showRecursively(element.children, element.collapsed || hidden)",
                "      );",
                "    }",
                "  });",
                "",
                "  return result;",
                "};",
                "",
                "/**",
                "* Adds a given rootElement to the bpmnDi diagrams.",
                "*",
                "* @param {Object} rootElement",
                "* @returns {Object} planeElement",
                "*/",
                "SubProcessPlaneBehavior.prototype._addDiagram = function(planeElement) {",
                "  var bpmnjs = this._bpmnjs;",
                "  var diagrams = bpmnjs.getDefinitions().diagrams;",
                "",
                "  if (!planeElement.businessObject) {",
                "    planeElement = this._createNewDiagram(planeElement);",
                "  }",
                "",
                "  diagrams.push(planeElement.di.$parent);",
                "",
                "  return planeElement;",
                "};",
                "",
                "",
                "/**",
                "* Creates a new plane element for the given sub process.",
                "*",
                "* @param {Object} bpmnElement",
                "*",
                "* @return {Object} new diagram element",
                "*/",
                "SubProcessPlaneBehavior.prototype._createNewDiagram = function(bpmnElement) {",
                "  var bpmnFactory = this._bpmnFactory;",
                "  var elementFactory = this._elementFactory;",
                "",
                "  var diPlane = bpmnFactory.create('bpmndi:BPMNPlane', {",
                "    bpmnElement: bpmnElement",
                "  });",
                "  var diDiagram = bpmnFactory.create('bpmndi:BPMNDiagram', {",
                "    plane: diPlane",
                "  });",
                "  diPlane.$parent = diDiagram;",
                "",
                "  // add a virtual element (not being drawn),",
                "  // a copy cat of our BpmnImporter code",
                "  var planeElement = elementFactory.createRoot({",
                "    id: getPlaneIdFromShape(bpmnElement),",
                "    type: bpmnElement.$type,",
                "    di: diPlane,",
                "    businessObject: bpmnElement,",
                "    collapsed: true",
                "  });",
                "",
                "  return planeElement;",
                "};",
                "",
                "/**",
                " * Removes the diagram for a given root element",
                " *",
                " * @param {Object} rootElement",
                " * @returns {Object} removed bpmndi:BPMNDiagram",
                " */",
                "SubProcessPlaneBehavior.prototype._removeDiagram = function(rootElement) {",
                "  var bpmnjs = this._bpmnjs;",
                "",
                "  var diagrams = bpmnjs.getDefinitions().diagrams;",
                "",
                "  var removedDiagram = find(diagrams, function(diagram) {"
            ]
        }
    },
    "bug_functions": {
        "4": {
            "function_name": "getVisibleLabelAdjustment (not found) ",
            "file_path": "lib/features/modeling/behavior/LabelBehavior.js",
            "function_details": [
                {
                    "name": "getVisibleLabelAdjustment",
                    "start_line": 1,
                    "end_line": 403
                }
            ],
            "function_code": [
                "import {",
                "  assign",
                "} from 'min-dash';",
                "",
                "import inherits from 'inherits-browser';",
                "",
                "import {",
                "  is,",
                "  getBusinessObject,",
                "  getDi",
                "} from '../../../util/ModelUtil';",
                "",
                "import {",
                "  isLabelExternal,",
                "  getExternalLabelMid,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../../util/LabelUtil';",
                "",
                "import {",
                "  getLabel",
                "} from '../../label-editing/LabelUtil';",
                "",
                "import {",
                "  getLabelAdjustment",
                "} from './util/LabelLayoutUtil';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "",
                "import {",
                "  getNewAttachPoint",
                "} from 'diagram-js/lib/util/AttachUtil';",
                "",
                "import {",
                "  getMid,",
                "  roundPoint",
                "} from 'diagram-js/lib/layout/LayoutUtil';",
                "",
                "import {",
                "  delta",
                "} from 'diagram-js/lib/util/PositionUtil';",
                "",
                "import {",
                "  sortBy",
                "} from 'min-dash';",
                "",
                "import {",
                "  getDistancePointLine,",
                "  perpendicularFoot",
                "} from './util/GeometricUtil';",
                "",
                "var DEFAULT_LABEL_DIMENSIONS = {",
                "  width: 90,",
                "  height: 20",
                "};",
                "",
                "var NAME_PROPERTY = 'name';",
                "var TEXT_PROPERTY = 'text';",
                "",
                "/**",
                " * A component that makes sure that external labels are added",
                " * together with respective elements and properly updated (DI wise)",
                " * during move.",
                " *",
                " * @param {EventBus} eventBus",
                " * @param {Modeling} modeling",
                " * @param {BpmnFactory} bpmnFactory",
                " * @param {TextRenderer} textRenderer",
                " */",
                "export default function LabelBehavior(",
                "    eventBus, modeling, bpmnFactory,",
                "    textRenderer) {",
                "",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  // update label if name property was updated",
                "  this.postExecute('element.updateProperties', function(e) {",
                "    var context = e.context,",
                "        element = context.element,",
                "        properties = context.properties;",
                "",
                "    if (NAME_PROPERTY in properties) {",
                "      modeling.updateLabel(element, properties[NAME_PROPERTY]);",
                "    }",
                "",
                "    if (TEXT_PROPERTY in properties",
                "        && is(element, 'bpmn:TextAnnotation')) {",
                "",
                "      var newBounds = textRenderer.getTextAnnotationBounds(",
                "        {",
                "          x: element.x,",
                "          y: element.y,",
                "          width: element.width,",
                "          height: element.height",
                "        },",
                "        properties[TEXT_PROPERTY] || ''",
                "      );",
                "",
                "      modeling.updateLabel(element, properties.text, newBounds);",
                "    }",
                "  });",
                "",
                "  // create label shape after shape/connection was created",
                "  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {",
                "    var context = e.context,",
                "        hints = context.hints || {};",
                "",
                "    if (hints.createElementsBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    var element = context.shape || context.connection,",
                "        businessObject = element.businessObject;",
                "",
                "    if (isLabel(element) || !isLabelExternal(element)) {",
                "      return;",
                "    }",
                "",
                "    // only create label if attribute available",
                "    if (!getLabel(element)) {",
                "      return;",
                "    }",
                "",
                "    var labelCenter = getExternalLabelMid(element);",
                "",
                "    // we don't care about x and y",
                "    var labelDimensions = textRenderer.getExternalLabelBounds(",
                "      DEFAULT_LABEL_DIMENSIONS,",
                "      getLabel(element)",
                "    );",
                "",
                "    modeling.createLabel(element, labelCenter, {",
                "      id: businessObject.id + '_label',",
                "      businessObject: businessObject,",
                "      width: labelDimensions.width,",
                "      height: labelDimensions.height",
                "    });",
                "  });",
                "",
                "  // update label after label shape was deleted",
                "  this.postExecute('shape.delete', function(event) {",
                "    var context = event.context,",
                "        labelTarget = context.labelTarget,",
                "        hints = context.hints || {};",
                "",
                "    // check if label",
                "    if (labelTarget && hints.unsetLabel !== false) {",
                "      modeling.updateLabel(labelTarget, null, null, { removeShape: false });",
                "    }",
                "  });",
                "",
                "  // update di information on label creation",
                "  this.postExecute([ 'label.create' ], function(event) {",
                "",
                "    var context = event.context,",
                "        element = context.shape,",
                "        labelTarget = context.labelTarget,",
                "        di;",
                "",
                "    // we want to trigger on real labels only",
                "    if (!labelTarget) {",
                "      return;",
                "    }",
                "",
                "    // we want to trigger on BPMN elements only",
                "    if (!is(labelTarget, 'bpmn:BaseElement')) {",
                "      return;",
                "    }",
                "",
                "    di = getDi(labelTarget);",
                "",
                "    if (!di.label) {",
                "      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {",
                "        bounds: bpmnFactory.create('dc:Bounds')",
                "      });",
                "",
                "      element.di = di;",
                "    }",
                "",
                "    assign(di.label.bounds, {",
                "      x: element.x,",
                "      y: element.y,",
                "      width: element.width,",
                "      height: element.height",
                "    });",
                "  });",
                "",
                "  function getVisibleLabelAdjustment(event) {",
                "",
                "    var context = event.context,",
                "        connection = context.connection,",
                "        label = connection.label,",
                "        hints = assign({}, context.hints),",
                "        newWaypoints = context.newWaypoints || connection.waypoints,",
                "        oldWaypoints = context.oldWaypoints;",
                "",
                "",
                "    if (typeof hints.startChanged === 'undefined') {",
                "      hints.startChanged = !!hints.connectionStart;",
                "    }",
                "",
                "    if (typeof hints.endChanged === 'undefined') {",
                "      hints.endChanged = !!hints.connectionEnd;",
                "    }",
                "",
                "    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);",
                "  }",
                "",
                "  this.postExecute([",
                "    'connection.layout',",
                "    'connection.updateWaypoints'",
                "  ], function(event) {",
                "    var context = event.context,",
                "        hints = context.hints || {};",
                "",
                "    if (hints.labelBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    var connection = context.connection,",
                "        label = connection.label,",
                "        labelAdjustment;",
                "",
                "    // handle missing label as well as the case",
                "    // that the label parent does not exist (yet),",
                "    // because it is being pasted / created via multi element create",
                "    //",
                "    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227",
                "    if (!label || !label.parent) {",
                "      return;",
                "    }",
                "",
                "    labelAdjustment = getVisibleLabelAdjustment(event);",
                "",
                "    modeling.moveShape(label, labelAdjustment);",
                "  });",
                "",
                "",
                "  // keep label position on shape replace",
                "  this.postExecute([ 'shape.replace' ], function(event) {",
                "    var context = event.context,",
                "        newShape = context.newShape,",
                "        oldShape = context.oldShape;",
                "",
                "    var businessObject = getBusinessObject(newShape);",
                "",
                "    if (businessObject",
                "      && isLabelExternal(businessObject)",
                "      && oldShape.label",
                "      && newShape.label) {",
                "      newShape.label.x = oldShape.label.x;",
                "      newShape.label.y = oldShape.label.y;",
                "    }",
                "  });",
                "",
                "",
                "  // move external label after resizing",
                "  this.postExecute('shape.resize', function(event) {",
                "",
                "    var context = event.context,",
                "        shape = context.shape,",
                "        newBounds = context.newBounds,",
                "        oldBounds = context.oldBounds;",
                "",
                "    if (hasExternalLabel(shape)) {",
                "",
                "      var label = shape.label,",
                "          labelMid = getMid(label),",
                "          edges = asEdges(oldBounds);",
                "",
                "      // get nearest border point to label as reference point",
                "      var referencePoint = getReferencePoint(labelMid, edges);",
                "",
                "      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);",
                "",
                "      modeling.moveShape(label, delta);",
                "",
                "    }",
                "",
                "  });",
                "",
                "}",
                "",
                "inherits(LabelBehavior, CommandInterceptor);",
                "",
                "LabelBehavior.$inject = [",
                "  'eventBus',",
                "  'modeling',",
                "  'bpmnFactory',",
                "  'textRenderer'",
                "];",
                "",
                "// helpers //////////////////////",
                "",
                "/**",
                " * Calculates a reference point delta relative to a new position",
                " * of a certain element's bounds",
                " *",
                " * @param {Point} point",
                " * @param {Bounds} oldBounds",
                " * @param {Bounds} newBounds",
                " *",
                " * @return {Delta} delta",
                " */",
                "export function getReferencePointDelta(referencePoint, oldBounds, newBounds) {",
                "",
                "  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);",
                "",
                "  return roundPoint(delta(newReferencePoint, referencePoint));",
                "}",
                "",
                "/**",
                " * Generates the nearest point (reference point) for a given point",
                " * onto given set of lines",
                " *",
                " * @param {Array<Point, Point>} lines",
                " * @param {Point} point",
                " *",
                " * @param {Point}",
                " */",
                "export function getReferencePoint(point, lines) {",
                "",
                "  if (!lines.length) {",
                "    return;",
                "  }",
                "",
                "  var nearestLine = getNearestLine(point, lines);",
                "",
                "  return perpendicularFoot(point, nearestLine);",
                "}",
                "",
                "/**",
                " * Convert the given bounds to a lines array containing all edges",
                " *",
                " * @param {Bounds|Point} bounds",
                " *",
                " * @return Array<Point>",
                " */",
                "export function asEdges(bounds) {",
                "  return [",
                "    [ // top",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y",
                "      }",
                "    ],",
                "    [ // right",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ],",
                "    [ // bottom",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y + (bounds.height || 0)",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ],",
                "    [ // left",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ]",
                "  ];",
                "}",
                "",
                "/**",
                " * Returns the nearest line for a given point by distance",
                " * @param {Point} point",
                " * @param Array<Point> lines",
                " *",
                " * @return Array<Point>",
                " */",
                "function getNearestLine(point, lines) {",
                "",
                "  var distances = lines.map(function(l) {",
                "    return {",
                "      line: l,",
                "      distance: getDistancePointLine(point, l)",
                "    };",
                "  });",
                "",
                "  var sorted = sortBy(distances, 'distance');",
                "",
                "  return sorted[0].line;",
                "}"
            ]
        },
        "5": {
            "function_name": "postExecute (not found) ",
            "file_path": "lib/features/modeling/behavior/LabelBehavior.js",
            "function_details": [
                {
                    "name": "postExecute",
                    "start_line": 1,
                    "end_line": 403
                }
            ],
            "function_code": [
                "import {",
                "  assign",
                "} from 'min-dash';",
                "",
                "import inherits from 'inherits-browser';",
                "",
                "import {",
                "  is,",
                "  getBusinessObject,",
                "  getDi",
                "} from '../../../util/ModelUtil';",
                "",
                "import {",
                "  isLabelExternal,",
                "  getExternalLabelMid,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../../util/LabelUtil';",
                "",
                "import {",
                "  getLabel",
                "} from '../../label-editing/LabelUtil';",
                "",
                "import {",
                "  getLabelAdjustment",
                "} from './util/LabelLayoutUtil';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "",
                "import {",
                "  getNewAttachPoint",
                "} from 'diagram-js/lib/util/AttachUtil';",
                "",
                "import {",
                "  getMid,",
                "  roundPoint",
                "} from 'diagram-js/lib/layout/LayoutUtil';",
                "",
                "import {",
                "  delta",
                "} from 'diagram-js/lib/util/PositionUtil';",
                "",
                "import {",
                "  sortBy",
                "} from 'min-dash';",
                "",
                "import {",
                "  getDistancePointLine,",
                "  perpendicularFoot",
                "} from './util/GeometricUtil';",
                "",
                "var DEFAULT_LABEL_DIMENSIONS = {",
                "  width: 90,",
                "  height: 20",
                "};",
                "",
                "var NAME_PROPERTY = 'name';",
                "var TEXT_PROPERTY = 'text';",
                "",
                "/**",
                " * A component that makes sure that external labels are added",
                " * together with respective elements and properly updated (DI wise)",
                " * during move.",
                " *",
                " * @param {EventBus} eventBus",
                " * @param {Modeling} modeling",
                " * @param {BpmnFactory} bpmnFactory",
                " * @param {TextRenderer} textRenderer",
                " */",
                "export default function LabelBehavior(",
                "    eventBus, modeling, bpmnFactory,",
                "    textRenderer) {",
                "",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  // update label if name property was updated",
                "  this.postExecute('element.updateProperties', function(e) {",
                "    var context = e.context,",
                "        element = context.element,",
                "        properties = context.properties;",
                "",
                "    if (NAME_PROPERTY in properties) {",
                "      modeling.updateLabel(element, properties[NAME_PROPERTY]);",
                "    }",
                "",
                "    if (TEXT_PROPERTY in properties",
                "        && is(element, 'bpmn:TextAnnotation')) {",
                "",
                "      var newBounds = textRenderer.getTextAnnotationBounds(",
                "        {",
                "          x: element.x,",
                "          y: element.y,",
                "          width: element.width,",
                "          height: element.height",
                "        },",
                "        properties[TEXT_PROPERTY] || ''",
                "      );",
                "",
                "      modeling.updateLabel(element, properties.text, newBounds);",
                "    }",
                "  });",
                "",
                "  // create label shape after shape/connection was created",
                "  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {",
                "    var context = e.context,",
                "        hints = context.hints || {};",
                "",
                "    if (hints.createElementsBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    var element = context.shape || context.connection,",
                "        businessObject = element.businessObject;",
                "",
                "    if (isLabel(element) || !isLabelExternal(element)) {",
                "      return;",
                "    }",
                "",
                "    // only create label if attribute available",
                "    if (!getLabel(element)) {",
                "      return;",
                "    }",
                "",
                "    var labelCenter = getExternalLabelMid(element);",
                "",
                "    // we don't care about x and y",
                "    var labelDimensions = textRenderer.getExternalLabelBounds(",
                "      DEFAULT_LABEL_DIMENSIONS,",
                "      getLabel(element)",
                "    );",
                "",
                "    modeling.createLabel(element, labelCenter, {",
                "      id: businessObject.id + '_label',",
                "      businessObject: businessObject,",
                "      width: labelDimensions.width,",
                "      height: labelDimensions.height",
                "    });",
                "  });",
                "",
                "  // update label after label shape was deleted",
                "  this.postExecute('shape.delete', function(event) {",
                "    var context = event.context,",
                "        labelTarget = context.labelTarget,",
                "        hints = context.hints || {};",
                "",
                "    // check if label",
                "    if (labelTarget && hints.unsetLabel !== false) {",
                "      modeling.updateLabel(labelTarget, null, null, { removeShape: false });",
                "    }",
                "  });",
                "",
                "  // update di information on label creation",
                "  this.postExecute([ 'label.create' ], function(event) {",
                "",
                "    var context = event.context,",
                "        element = context.shape,",
                "        labelTarget = context.labelTarget,",
                "        di;",
                "",
                "    // we want to trigger on real labels only",
                "    if (!labelTarget) {",
                "      return;",
                "    }",
                "",
                "    // we want to trigger on BPMN elements only",
                "    if (!is(labelTarget, 'bpmn:BaseElement')) {",
                "      return;",
                "    }",
                "",
                "    di = getDi(labelTarget);",
                "",
                "    if (!di.label) {",
                "      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {",
                "        bounds: bpmnFactory.create('dc:Bounds')",
                "      });",
                "",
                "      element.di = di;",
                "    }",
                "",
                "    assign(di.label.bounds, {",
                "      x: element.x,",
                "      y: element.y,",
                "      width: element.width,",
                "      height: element.height",
                "    });",
                "  });",
                "",
                "  function getVisibleLabelAdjustment(event) {",
                "",
                "    var context = event.context,",
                "        connection = context.connection,",
                "        label = connection.label,",
                "        hints = assign({}, context.hints),",
                "        newWaypoints = context.newWaypoints || connection.waypoints,",
                "        oldWaypoints = context.oldWaypoints;",
                "",
                "",
                "    if (typeof hints.startChanged === 'undefined') {",
                "      hints.startChanged = !!hints.connectionStart;",
                "    }",
                "",
                "    if (typeof hints.endChanged === 'undefined') {",
                "      hints.endChanged = !!hints.connectionEnd;",
                "    }",
                "",
                "    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);",
                "  }",
                "",
                "  this.postExecute([",
                "    'connection.layout',",
                "    'connection.updateWaypoints'",
                "  ], function(event) {",
                "    var context = event.context,",
                "        hints = context.hints || {};",
                "",
                "    if (hints.labelBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    var connection = context.connection,",
                "        label = connection.label,",
                "        labelAdjustment;",
                "",
                "    // handle missing label as well as the case",
                "    // that the label parent does not exist (yet),",
                "    // because it is being pasted / created via multi element create",
                "    //",
                "    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227",
                "    if (!label || !label.parent) {",
                "      return;",
                "    }",
                "",
                "    labelAdjustment = getVisibleLabelAdjustment(event);",
                "",
                "    modeling.moveShape(label, labelAdjustment);",
                "  });",
                "",
                "",
                "  // keep label position on shape replace",
                "  this.postExecute([ 'shape.replace' ], function(event) {",
                "    var context = event.context,",
                "        newShape = context.newShape,",
                "        oldShape = context.oldShape;",
                "",
                "    var businessObject = getBusinessObject(newShape);",
                "",
                "    if (businessObject",
                "      && isLabelExternal(businessObject)",
                "      && oldShape.label",
                "      && newShape.label) {",
                "      newShape.label.x = oldShape.label.x;",
                "      newShape.label.y = oldShape.label.y;",
                "    }",
                "  });",
                "",
                "",
                "  // move external label after resizing",
                "  this.postExecute('shape.resize', function(event) {",
                "",
                "    var context = event.context,",
                "        shape = context.shape,",
                "        newBounds = context.newBounds,",
                "        oldBounds = context.oldBounds;",
                "",
                "    if (hasExternalLabel(shape)) {",
                "",
                "      var label = shape.label,",
                "          labelMid = getMid(label),",
                "          edges = asEdges(oldBounds);",
                "",
                "      // get nearest border point to label as reference point",
                "      var referencePoint = getReferencePoint(labelMid, edges);",
                "",
                "      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);",
                "",
                "      modeling.moveShape(label, delta);",
                "",
                "    }",
                "",
                "  });",
                "",
                "}",
                "",
                "inherits(LabelBehavior, CommandInterceptor);",
                "",
                "LabelBehavior.$inject = [",
                "  'eventBus',",
                "  'modeling',",
                "  'bpmnFactory',",
                "  'textRenderer'",
                "];",
                "",
                "// helpers //////////////////////",
                "",
                "/**",
                " * Calculates a reference point delta relative to a new position",
                " * of a certain element's bounds",
                " *",
                " * @param {Point} point",
                " * @param {Bounds} oldBounds",
                " * @param {Bounds} newBounds",
                " *",
                " * @return {Delta} delta",
                " */",
                "export function getReferencePointDelta(referencePoint, oldBounds, newBounds) {",
                "",
                "  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);",
                "",
                "  return roundPoint(delta(newReferencePoint, referencePoint));",
                "}",
                "",
                "/**",
                " * Generates the nearest point (reference point) for a given point",
                " * onto given set of lines",
                " *",
                " * @param {Array<Point, Point>} lines",
                " * @param {Point} point",
                " *",
                " * @param {Point}",
                " */",
                "export function getReferencePoint(point, lines) {",
                "",
                "  if (!lines.length) {",
                "    return;",
                "  }",
                "",
                "  var nearestLine = getNearestLine(point, lines);",
                "",
                "  return perpendicularFoot(point, nearestLine);",
                "}",
                "",
                "/**",
                " * Convert the given bounds to a lines array containing all edges",
                " *",
                " * @param {Bounds|Point} bounds",
                " *",
                " * @return Array<Point>",
                " */",
                "export function asEdges(bounds) {",
                "  return [",
                "    [ // top",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y",
                "      }",
                "    ],",
                "    [ // right",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ],",
                "    [ // bottom",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y + (bounds.height || 0)",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ],",
                "    [ // left",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ]",
                "  ];",
                "}",
                "",
                "/**",
                " * Returns the nearest line for a given point by distance",
                " * @param {Point} point",
                " * @param Array<Point> lines",
                " *",
                " * @return Array<Point>",
                " */",
                "function getNearestLine(point, lines) {",
                "",
                "  var distances = lines.map(function(l) {",
                "    return {",
                "      line: l,",
                "      distance: getDistancePointLine(point, l)",
                "    };",
                "  });",
                "",
                "  var sorted = sortBy(distances, 'distance');",
                "",
                "  return sorted[0].line;",
                "}"
            ]
        },
        "6": {
            "function_name": "addOverlay (not found) ",
            "file_path": "lib/features/drilldown/DrilldownOverlayBehavior.js",
            "function_details": [
                {
                    "name": "addOverlay",
                    "start_line": 1,
                    "end_line": 181
                }
            ],
            "function_code": [
                "import inherits from 'inherits-browser';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "import { is } from '../../util/ModelUtil';",
                "import { classes, domify } from 'min-dom';",
                "import { getPlaneIdFromShape } from '../../util/DrilldownUtil';",
                "",
                "var LOW_PRIORITY = 250;",
                "var ARROW_DOWN_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z\"/></svg>';",
                "",
                "var EMPTY_MARKER = 'bjs-drilldown-empty';",
                "",
                "export default function DrilldownOverlayBehavior(",
                "    canvas, eventBus, elementRegistry, overlays",
                ") {",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  this._canvas = canvas;",
                "  this._eventBus = eventBus;",
                "  this._elementRegistry = elementRegistry;",
                "  this._overlays = overlays;",
                "",
                "  var self = this;",
                "",
                "  this.executed('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    // Add overlay to the collapsed shape",
                "    if (self.canDrillDown(shape)) {",
                "      self.addOverlay(shape);",
                "    } else {",
                "      self.removeOverlay(shape);",
                "    }",
                "  }, true);",
                "",
                "",
                "  this.reverted('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    // Add overlay to the collapsed shape",
                "    if (self.canDrillDown(shape)) {",
                "      self.addOverlay(shape);",
                "    } else {",
                "      self.removeOverlay(shape);",
                "    }",
                "  }, true);",
                "",
                "",
                "  this.executed(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,",
                "    function(context) {",
                "      var oldParent = context.oldParent,",
                "          newParent = context.newParent || context.parent,",
                "          shape = context.shape;",
                "",
                "      // Add overlay to the collapsed shape",
                "      if (self.canDrillDown(shape)) {",
                "        self.addOverlay(shape);",
                "      }",
                "",
                "      self.updateDrilldownOverlay(oldParent);",
                "      self.updateDrilldownOverlay(newParent);",
                "      self.updateDrilldownOverlay(shape);",
                "    }, true);",
                "",
                "",
                "  this.reverted(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,",
                "    function(context) {",
                "      var oldParent = context.oldParent,",
                "          newParent = context.newParent || context.parent,",
                "          shape = context.shape;",
                "",
                "      // Add overlay to the collapsed shape",
                "      if (self.canDrillDown(shape)) {",
                "        self.addOverlay(shape);",
                "      }",
                "",
                "      self.updateDrilldownOverlay(oldParent);",
                "      self.updateDrilldownOverlay(newParent);",
                "      self.updateDrilldownOverlay(shape);",
                "    }, true);",
                "",
                "",
                "  eventBus.on('import.render.complete', function() {",
                "    elementRegistry.filter(function(e) {",
                "      return self.canDrillDown(e);",
                "    }).map(function(el) {",
                "      self.addOverlay(el);",
                "    });",
                "  });",
                "",
                "}",
                "",
                "inherits(DrilldownOverlayBehavior, CommandInterceptor);",
                "",
                "DrilldownOverlayBehavior.prototype.updateDrilldownOverlay = function(shape) {",
                "  var canvas = this._canvas;",
                "",
                "  if (!shape) {",
                "    return;",
                "  }",
                "",
                "  var root = canvas.findRoot(shape);",
                "  if (root) {",
                "    this.updateOverlayVisibility(root);",
                "  }",
                "};",
                "",
                "",
                "DrilldownOverlayBehavior.prototype.canDrillDown = function(element) {",
                "  var canvas = this._canvas;",
                "  return is(element, 'bpmn:SubProcess') && canvas.findRoot(getPlaneIdFromShape(element));",
                "};",
                "",
                "/**",
                " * Updates visibility of the drilldown overlay. If the plane has no elements,",
                " * the drilldown will be only shown when the element is selected.",
                " *",
                " * @param {djs.model.Shape|djs.model.Root} element collapsed shape or root element",
                " */",
                "DrilldownOverlayBehavior.prototype.updateOverlayVisibility = function(element) {",
                "  var overlays = this._overlays;",
                "",
                "  var bo = element.businessObject;",
                "",
                "  var overlay = overlays.get({ element: bo.id, type: 'drilldown' })[0];",
                "",
                "  if (!overlay) {",
                "    return;",
                "  }",
                "",
                "  var hasContent = bo && bo.flowElements && bo.flowElements.length;",
                "  classes(overlay.html).toggle(EMPTY_MARKER, !hasContent);",
                "};",
                "",
                "/**",
                " * Attaches a drilldown button to the given element. We assume that the plane has",
                " * the same id as the element.",
                " *",
                " * @param {djs.model.Shape} element collapsed shape",
                " */",
                "DrilldownOverlayBehavior.prototype.addOverlay = function(element) {",
                "  var canvas = this._canvas;",
                "  var overlays = this._overlays;",
                "",
                "  var existingOverlays = overlays.get({ element: element, type: 'drilldown' });",
                "  if (existingOverlays.length) {",
                "    this.removeOverlay(element);",
                "  }",
                "",
                "  var button = domify('<button class=\"bjs-drilldown\">' + ARROW_DOWN_SVG + '</button>');",
                "",
                "  button.addEventListener('click', function() {",
                "    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));",
                "  });",
                "",
                "  overlays.add(element, 'drilldown', {",
                "    position: {",
                "      bottom: -7,",
                "      right: -8",
                "    },",
                "    html: button",
                "  });",
                "",
                "  this.updateOverlayVisibility(element);",
                "};",
                "",
                "DrilldownOverlayBehavior.prototype.removeOverlay = function(element) {",
                "  var overlays = this._overlays;",
                "",
                "  overlays.remove({",
                "    element: element,",
                "    type: 'drilldown'",
                "  });",
                "};",
                "",
                "DrilldownOverlayBehavior.$inject = [",
                "  'canvas',",
                "  'eventBus',",
                "  'elementRegistry',",
                "  'overlays'",
                "];"
            ]
        },
        "7": {
            "function_name": "removeOverlay (not found) ",
            "file_path": "lib/features/drilldown/DrilldownOverlayBehavior.js",
            "function_details": [
                {
                    "name": "removeOverlay",
                    "start_line": 1,
                    "end_line": 181
                }
            ],
            "function_code": [
                "import inherits from 'inherits-browser';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "import { is } from '../../util/ModelUtil';",
                "import { classes, domify } from 'min-dom';",
                "import { getPlaneIdFromShape } from '../../util/DrilldownUtil';",
                "",
                "var LOW_PRIORITY = 250;",
                "var ARROW_DOWN_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z\"/></svg>';",
                "",
                "var EMPTY_MARKER = 'bjs-drilldown-empty';",
                "",
                "export default function DrilldownOverlayBehavior(",
                "    canvas, eventBus, elementRegistry, overlays",
                ") {",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  this._canvas = canvas;",
                "  this._eventBus = eventBus;",
                "  this._elementRegistry = elementRegistry;",
                "  this._overlays = overlays;",
                "",
                "  var self = this;",
                "",
                "  this.executed('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    // Add overlay to the collapsed shape",
                "    if (self.canDrillDown(shape)) {",
                "      self.addOverlay(shape);",
                "    } else {",
                "      self.removeOverlay(shape);",
                "    }",
                "  }, true);",
                "",
                "",
                "  this.reverted('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                "    var shape = context.shape;",
                "",
                "    // Add overlay to the collapsed shape",
                "    if (self.canDrillDown(shape)) {",
                "      self.addOverlay(shape);",
                "    } else {",
                "      self.removeOverlay(shape);",
                "    }",
                "  }, true);",
                "",
                "",
                "  this.executed(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,",
                "    function(context) {",
                "      var oldParent = context.oldParent,",
                "          newParent = context.newParent || context.parent,",
                "          shape = context.shape;",
                "",
                "      // Add overlay to the collapsed shape",
                "      if (self.canDrillDown(shape)) {",
                "        self.addOverlay(shape);",
                "      }",
                "",
                "      self.updateDrilldownOverlay(oldParent);",
                "      self.updateDrilldownOverlay(newParent);",
                "      self.updateDrilldownOverlay(shape);",
                "    }, true);",
                "",
                "",
                "  this.reverted(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,",
                "    function(context) {",
                "      var oldParent = context.oldParent,",
                "          newParent = context.newParent || context.parent,",
                "          shape = context.shape;",
                "",
                "      // Add overlay to the collapsed shape",
                "      if (self.canDrillDown(shape)) {",
                "        self.addOverlay(shape);",
                "      }",
                "",
                "      self.updateDrilldownOverlay(oldParent);",
                "      self.updateDrilldownOverlay(newParent);",
                "      self.updateDrilldownOverlay(shape);",
                "    }, true);",
                "",
                "",
                "  eventBus.on('import.render.complete', function() {",
                "    elementRegistry.filter(function(e) {",
                "      return self.canDrillDown(e);",
                "    }).map(function(el) {",
                "      self.addOverlay(el);",
                "    });",
                "  });",
                "",
                "}",
                "",
                "inherits(DrilldownOverlayBehavior, CommandInterceptor);",
                "",
                "DrilldownOverlayBehavior.prototype.updateDrilldownOverlay = function(shape) {",
                "  var canvas = this._canvas;",
                "",
                "  if (!shape) {",
                "    return;",
                "  }",
                "",
                "  var root = canvas.findRoot(shape);",
                "  if (root) {",
                "    this.updateOverlayVisibility(root);",
                "  }",
                "};",
                "",
                "",
                "DrilldownOverlayBehavior.prototype.canDrillDown = function(element) {",
                "  var canvas = this._canvas;",
                "  return is(element, 'bpmn:SubProcess') && canvas.findRoot(getPlaneIdFromShape(element));",
                "};",
                "",
                "/**",
                " * Updates visibility of the drilldown overlay. If the plane has no elements,",
                " * the drilldown will be only shown when the element is selected.",
                " *",
                " * @param {djs.model.Shape|djs.model.Root} element collapsed shape or root element",
                " */",
                "DrilldownOverlayBehavior.prototype.updateOverlayVisibility = function(element) {",
                "  var overlays = this._overlays;",
                "",
                "  var bo = element.businessObject;",
                "",
                "  var overlay = overlays.get({ element: bo.id, type: 'drilldown' })[0];",
                "",
                "  if (!overlay) {",
                "    return;",
                "  }",
                "",
                "  var hasContent = bo && bo.flowElements && bo.flowElements.length;",
                "  classes(overlay.html).toggle(EMPTY_MARKER, !hasContent);",
                "};",
                "",
                "/**",
                " * Attaches a drilldown button to the given element. We assume that the plane has",
                " * the same id as the element.",
                " *",
                " * @param {djs.model.Shape} element collapsed shape",
                " */",
                "DrilldownOverlayBehavior.prototype.addOverlay = function(element) {",
                "  var canvas = this._canvas;",
                "  var overlays = this._overlays;",
                "",
                "  var existingOverlays = overlays.get({ element: element, type: 'drilldown' });",
                "  if (existingOverlays.length) {",
                "    this.removeOverlay(element);",
                "  }",
                "",
                "  var button = domify('<button class=\"bjs-drilldown\">' + ARROW_DOWN_SVG + '</button>');",
                "",
                "  button.addEventListener('click', function() {",
                "    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));",
                "  });",
                "",
                "  overlays.add(element, 'drilldown', {",
                "    position: {",
                "      bottom: -7,",
                "      right: -8",
                "    },",
                "    html: button",
                "  });",
                "",
                "  this.updateOverlayVisibility(element);",
                "};",
                "",
                "DrilldownOverlayBehavior.prototype.removeOverlay = function(element) {",
                "  var overlays = this._overlays;",
                "",
                "  overlays.remove({",
                "    element: element,",
                "    type: 'drilldown'",
                "  });",
                "};",
                "",
                "DrilldownOverlayBehavior.$inject = [",
                "  'canvas',",
                "  'eventBus',",
                "  'elementRegistry',",
                "  'overlays'",
                "];"
            ]
        }
    }
}