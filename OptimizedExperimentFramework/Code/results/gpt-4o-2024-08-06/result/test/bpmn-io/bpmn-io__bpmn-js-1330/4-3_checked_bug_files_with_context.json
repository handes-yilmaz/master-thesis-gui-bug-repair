{
    "lib/features/modeling/behavior/BoundaryEventBehavior.js": [
        "import inherits from 'inherits';",
        "",
        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
        "",
        "import { is } from '../../../util/ModelUtil';",
        "",
        "import {",
        "  filter,",
        "  forEach",
        "} from 'min-dash';",
        "",
        "",
        "/**",
        " * BPMN specific boundary event behavior",
        " */",
        "export default function BoundaryEventBehavior(eventBus, modeling) {",
        "",
        "  CommandInterceptor.call(this, eventBus);",
        "",
        "  function getBoundaryEvents(element) {",
        "    return filter(element.attachers, function(attacher) {",
        "      return is(attacher, 'bpmn:BoundaryEvent');",
        "    });",
        "  }",
        "",
        "  // remove after connecting to event-based gateway",
        "  this.postExecute('connection.create', function(event) {",
        "    var source = event.context.source,",
        "        target = event.context.target,",
        "        boundaryEvents = getBoundaryEvents(target);",
        "",
        "    if (",
        "      is(source, 'bpmn:EventBasedGateway') &&",
        "      is(target, 'bpmn:ReceiveTask') &&",
        "      boundaryEvents.length > 0",
        "    ) {",
        "      modeling.removeElements(boundaryEvents);",
        "    }",
        "",
        "  });",
        "",
        "  // remove after replacing connected gateway with event-based gateway",
        "  this.postExecute('connection.reconnect', function(event) {",
        "    var oldSource = event.context.oldSource,",
        "        newSource = event.context.newSource;",
        "",
        "    if (is(oldSource, 'bpmn:Gateway') &&",
        "        is(newSource, 'bpmn:EventBasedGateway')) {",
        "      forEach(newSource.outgoing, function(connection) {",
        "        var target = connection.target,",
        "            attachedboundaryEvents = getBoundaryEvents(target);",
        "",
        "        if (is(target, 'bpmn:ReceiveTask') &&",
        "            attachedboundaryEvents.length > 0) {",
        "          modeling.removeElements(attachedboundaryEvents);",
        "        }",
        "      });",
        "    }",
        "  });",
        "}",
        "",
        "BoundaryEventBehavior.$inject = [",
        "  'eventBus',",
        "  'modeling'",
        "];",
        "",
        "inherits(BoundaryEventBehavior, CommandInterceptor);"
    ],
    "lib/features/rules/BpmnRules.js": [
        "import {",
        "  every,",
        "  find,",
        "  forEach,",
        "  some",
        "} from 'min-dash';",
        "",
        "import inherits from 'inherits';",
        "",
        "import {",
        "  is,",
        "  getBusinessObject",
        "} from '../../util/ModelUtil';",
        "",
        "import {",
        "  getParent,",
        "  isAny",
        "} from '../modeling/util/ModelingUtil';",
        "",
        "import {",
        "  isLabel",
        "} from '../../util/LabelUtil';",
        "",
        "import {",
        "  isExpanded,",
        "  isEventSubProcess,",
        "  isInterrupting,",
        "  hasErrorEventDefinition,",
        "  hasEscalationEventDefinition,",
        "  hasCompensateEventDefinition",
        "} from '../../util/DiUtil';",
        "",
        "import RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';",
        "",
        "import {",
        "  getBoundaryAttachment as isBoundaryAttachment",
        "} from '../snapping/BpmnSnappingUtil';",
        "",
        "",
        "/**",
        " * BPMN specific modeling rule",
        " */",
        "export default function BpmnRules(eventBus) {",
        "  RuleProvider.call(this, eventBus);",
        "}",
        "",
        "inherits(BpmnRules, RuleProvider);",
        "",
        "BpmnRules.$inject = [ 'eventBus' ];",
        "",
        "BpmnRules.prototype.init = function() {",
        "",
        "  this.addRule('connection.start', function(context) {",
        "    var source = context.source;",
        "",
        "    return canStartConnection(source);",
        "  });",
        "",
        "  this.addRule('connection.create', function(context) {",
        "    var source = context.source,",
        "        target = context.target,",
        "        hints = context.hints || {},",
        "        targetParent = hints.targetParent,",
        "        targetAttach = hints.targetAttach;",
        "",
        "    // don't allow incoming connections on",
        "    // newly created boundary events",
        "    // to boundary events",
        "    if (targetAttach) {",
        "      return false;",
        "    }",
        "",
        "    // temporarily set target parent for scoping",
        "    // checks to work",
        "    if (targetParent) {",
        "      target.parent = targetParent;",
        "    }",
        "",
        "    try {",
        "      return canConnect(source, target);",
        "    } finally {",
        "",
        "      // unset temporary target parent",
        "      if (targetParent) {",
        "        target.parent = null;",
        "      }",
        "    }",
        "  });",
        "",
        "  this.addRule('connection.reconnect', function(context) {",
        "",
        "    var connection = context.connection,",
        "        source = context.source,",
        "        target = context.target;",
        "",
        "    return canConnect(source, target, connection);",
        "  });",
        "",
        "  this.addRule('connection.updateWaypoints', function(context) {",
        "    return {",
        "      type: context.connection.type",
        "    };",
        "  });",
        "",
        "  this.addRule('shape.resize', function(context) {",
        "",
        "    var shape = context.shape,",
        "        newBounds = context.newBounds;",
        "",
        "    return canResize(shape, newBounds);",
        "  });",
        "",
        "  this.addRule('elements.create', function(context) {",
        "    var elements = context.elements,",
        "        position = context.position,",
        "        target = context.target;",
        "",
        "    return every(elements, function(element) {",
        "      if (isConnection(element)) {",
        "        return canConnect(element.source, element.target, element);",
        "      }",
        "",
        "      if (element.host) {",
        "        return canAttach(element, element.host, null, position);",
        "      }",
        "",
        "      return canCreate(element, target, null, position);",
        "    });",
        "  });",
        "",
        "  this.addRule('elements.move', function(context) {",
        "",
        "    var target = context.target,",
        "        shapes = context.shapes,",
        "        position = context.position;",
        "",
        "    return canAttach(shapes, target, null, position) ||",
        "           canReplace(shapes, target, position) ||",
        "           canMove(shapes, target, position) ||",
        "           canInsert(shapes, target, position);",
        "  });",
        "",
        "  this.addRule('shape.create', function(context) {",
        "    return canCreate(",
        "      context.shape,",
        "      context.target,",
        "      context.source,",
        "      context.position",
        "    );",
        "  });",
        "",
        "  this.addRule('shape.attach', function(context) {",
        "",
        "    return canAttach(",
        "      context.shape,",
        "      context.target,",
        "      null,",
        "      context.position",
        "    );",
        "  });",
        "",
        "  this.addRule('element.copy', function(context) {",
        "    var element = context.element,",
        "        elements = context.elements;",
        "",
        "    return canCopy(elements, element);",
        "  });",
        "};",
        "",
        "BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;",
        "",
        "BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;",
        "",
        "BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;",
        "",
        "BpmnRules.prototype.canConnectAssociation = canConnectAssociation;",
        "",
        "BpmnRules.prototype.canMove = canMove;",
        "",
        "BpmnRules.prototype.canAttach = canAttach;",
        "",
        "BpmnRules.prototype.canReplace = canReplace;",
        "",
        "BpmnRules.prototype.canDrop = canDrop;",
        "",
        "BpmnRules.prototype.canInsert = canInsert;",
        "",
        "BpmnRules.prototype.canCreate = canCreate;",
        "",
        "BpmnRules.prototype.canConnect = canConnect;",
        "",
        "BpmnRules.prototype.canResize = canResize;",
        "",
        "BpmnRules.prototype.canCopy = canCopy;",
        "",
        "/**",
        " * Utility functions for rule checking",
        " */",
        "",
        "/**",
        " * Checks if given element can be used for starting connection.",
        " *",
        " * @param  {Element} source",
        " * @return {boolean}",
        " */",
        "function canStartConnection(element) {",
        "  if (nonExistingOrLabel(element)) {",
        "    return null;",
        "  }",
        "",
        "  return isAny(element, [",
        "    'bpmn:FlowNode',",
        "    'bpmn:InteractionNode',",
        "    'bpmn:DataObjectReference',",
        "    'bpmn:DataStoreReference',",
        "    'bpmn:Group'",
        "  ]);",
        "}",
        "",
        "function nonExistingOrLabel(element) {",
        "  return !element || isLabel(element);",
        "}",
        "",
        "function isSame(a, b) {",
        "  return a === b;",
        "}",
        "",
        "function getOrganizationalParent(element) {",
        "",
        "  do {",
        "    if (is(element, 'bpmn:Process')) {",
        "      return getBusinessObject(element);",
        "    }",
        "",
        "    if (is(element, 'bpmn:Participant')) {",
        "      return (",
        "        getBusinessObject(element).processRef ||",
        "        getBusinessObject(element)",
        "      );",
        "    }",
        "  } while ((element = element.parent));",
        "",
        "}",
        "",
        "function isTextAnnotation(element) {",
        "  return is(element, 'bpmn:TextAnnotation');",
        "}",
        "",
        "function isGroup(element) {",
        "  return is(element, 'bpmn:Group') && !element.labelTarget;",
        "}",
        "",
        "function isCompensationBoundary(element) {",
        "  return is(element, 'bpmn:BoundaryEvent') &&",
        "         hasEventDefinition(element, 'bpmn:CompensateEventDefinition');",
        "}",
        "",
        "function isForCompensation(e) {",
        "  return getBusinessObject(e).isForCompensation;",
        "}",
        "",
        "function isSameOrganization(a, b) {",
        "  var parentA = getOrganizationalParent(a),",
        "      parentB = getOrganizationalParent(b);",
        "",
        "  return parentA === parentB;",
        "}",
        "",
        "function isMessageFlowSource(element) {",
        "  return (",
        "    is(element, 'bpmn:InteractionNode') && (",
        "      !is(element, 'bpmn:Event') || (",
        "        is(element, 'bpmn:ThrowEvent') &&",
        "        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')",
        "      )",
        "    )",
        "  );",
        "}",
        "",
        "function isMessageFlowTarget(element) {",
        "  return (",
        "    is(element, 'bpmn:InteractionNode') &&",
        "    !isForCompensation(element) && (",
        "      !is(element, 'bpmn:Event') || (",
        "        is(element, 'bpmn:CatchEvent') &&",
        "        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')",
        "      )",
        "    )",
        "  );",
        "}",
        "",
        "function getScopeParent(element) {",
        "",
        "  var parent = element;",
        "",
        "  while ((parent = parent.parent)) {",
        "",
        "    if (is(parent, 'bpmn:FlowElementsContainer')) {",
        "      return getBusinessObject(parent);",
        "    }",
        "",
        "    if (is(parent, 'bpmn:Participant')) {",
        "      return getBusinessObject(parent).processRef;",
        "    }",
        "  }",
        "",
        "  return null;",
        "}",
        "",
        "function isSameScope(a, b) {",
        "  var scopeParentA = getScopeParent(a),",
        "      scopeParentB = getScopeParent(b);",
        "",
        "  return scopeParentA === scopeParentB;",
        "}",
        "",
        "function hasEventDefinition(element, eventDefinition) {",
        "  var bo = getBusinessObject(element);",
        "",
        "  return !!find(bo.eventDefinitions || [], function(definition) {",
        "    return is(definition, eventDefinition);",
        "  });",
        "}",
        "",
        "function hasEventDefinitionOrNone(element, eventDefinition) {",
        "  var bo = getBusinessObject(element);",
        "",
        "  return (bo.eventDefinitions || []).every(function(definition) {",
        "    return is(definition, eventDefinition);",
        "  });",
        "}",
        "",
        "function isSequenceFlowSource(element) {",
        "  return (",
        "    is(element, 'bpmn:FlowNode') &&",
        "    !is(element, 'bpmn:EndEvent') &&",
        "    !isEventSubProcess(element) &&",
        "    !(is(element, 'bpmn:IntermediateThrowEvent') &&",
        "      hasEventDefinition(element, 'bpmn:LinkEventDefinition')",
        "    ) &&",
        "    !isCompensationBoundary(element) &&",
        "    !isForCompensation(element)",
        "  );",
        "}",
        "",
        "function isSequenceFlowTarget(element) {",
        "  return (",
        "    is(element, 'bpmn:FlowNode') &&",
        "    !is(element, 'bpmn:StartEvent') &&",
        "    !is(element, 'bpmn:BoundaryEvent') &&",
        "    !isEventSubProcess(element) &&",
        "    !(is(element, 'bpmn:IntermediateCatchEvent') &&",
        "      hasEventDefinition(element, 'bpmn:LinkEventDefinition')",
        "    ) &&",
        "    !isForCompensation(element)",
        "  );",
        "}",
        "",
        "function isEventBasedTarget(element) {",
        "  return (",
        "    is(element, 'bpmn:ReceiveTask') || (",
        "      is(element, 'bpmn:IntermediateCatchEvent') && (",
        "        hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||",
        "        hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||",
        "        hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||",
        "        hasEventDefinition(element, 'bpmn:SignalEventDefinition')",
        "      )",
        "    )",
        "  );",
        "}",
        "",
        "function isConnection(element) {",
        "  return element.waypoints;",
        "}",
        "",
        "function getParents(element) {",
        "",
        "  var parents = [];",
        "",
        "  while (element) {",
        "    element = element.parent;",
        "",
        "    if (element) {",
        "      parents.push(element);",
        "    }",
        "  }",
        "",
        "  return parents;",
        "}",
        "",
        "function isParent(possibleParent, element) {",
        "  var allParents = getParents(element);",
        "  return allParents.indexOf(possibleParent) !== -1;",
        "}",
        "",
        "function canConnect(source, target, connection) {",
        "",
        "  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {",
        "    return null;",
        "  }",
        "",
        "  if (!is(connection, 'bpmn:DataAssociation')) {",
        "",
        "    if (canConnectMessageFlow(source, target)) {",
        "      return { type: 'bpmn:MessageFlow' };",
        "    }",
        "",
        "    if (canConnectSequenceFlow(source, target)) {",
        "      return { type: 'bpmn:SequenceFlow' };",
        "    }",
        "  }",
        "",
        "  var connectDataAssociation = canConnectDataAssociation(source, target);",
        "",
        "  if (connectDataAssociation) {",
        "    return connectDataAssociation;",
        "  }",
        "",
        "  if (isCompensationBoundary(source) && isForCompensation(target)) {",
        "    return {",
        "      type: 'bpmn:Association',",
        "      associationDirection: 'One'",
        "    };",
        "  }",
        "",
        "  if (canConnectAssociation(source, target)) {",
        "",
        "    return {",
        "      type: 'bpmn:Association'",
        "    };",
        "  }",
        "",
        "  return false;",
        "}",
        "",
        "/**",
        " * Can an element be dropped into the target element",
        " *",
        " * @return {boolean}",
        " */",
        "function canDrop(element, target, position) {",
        "",
        "  // can move labels and groups everywhere",
        "  if (isLabel(element) || isGroup(element)) {",
        "    return true;",
        "  }",
        "",
        "",
        "  // disallow to create elements on collapsed pools",
        "  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {",
        "    return false;",
        "  }",
        "",
        "  // allow to create new participants on",
        "  // existing collaboration and process diagrams",
        "  if (is(element, 'bpmn:Participant')) {",
        "    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');",
        "  }",
        "",
        "  // allow moving DataInput / DataOutput within its original container only",
        "  if (isAny(element, [ 'bpmn:DataInput', 'bpmn:DataOutput' ])) {",
        "",
        "    if (element.parent) {",
        "      return target === element.parent;",
        "    }",
        "  }",
        "",
        "  // allow creating lanes on participants and other lanes only",
        "  if (is(element, 'bpmn:Lane')) {",
        "    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');",
        "  }",
        "",
        "  // disallow dropping boundary events which cannot replace with intermediate event",
        "  if (is(element, 'bpmn:BoundaryEvent') && !isDroppableBoundaryEvent(element)) {",
        "    return false;",
        "  }",
        "",
        "  // drop flow elements onto flow element containers",
        "  // and participants",
        "  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {",
        "    if (is(target, 'bpmn:FlowElementsContainer')) {",
        "      return isExpanded(target);",
        "    }",
        "",
        "    return isAny(target, [ 'bpmn:Participant', 'bpmn:Lane' ]);",
        "  }",
        "",
        "  // account for the fact that data associations are always",
        "  // rendered and moved to top (Process or Collaboration level)",
        "  //",
        "  // artifacts may be placed wherever, too",
        "  if (isAny(element, [ 'bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference' ])) {",
        "    return isAny(target, [",
        "      'bpmn:Collaboration',",
        "      'bpmn:Lane',",
        "      'bpmn:Participant',",
        "      'bpmn:Process',",
        "      'bpmn:SubProcess' ]);",
        "  }",
        "",
        "  if (is(element, 'bpmn:MessageFlow')) {",
        "    return is(target, 'bpmn:Collaboration')",
        "      || element.source.parent == target",
        "      || element.target.parent == target;",
        "  }",
        "",
        "  return false;",
        "}",
        "",
        "function isDroppableBoundaryEvent(event) {",
        "  return getBusinessObject(event).cancelActivity && (",
        "    hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event)",
        "  );",
        "}",
        "",
        "function isBoundaryEvent(element) {",
        "  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');",
        "}",
        "",
        "function isLane(element) {",
        "  return is(element, 'bpmn:Lane');",
        "}",
        "",
        "/**",
        " * We treat IntermediateThrowEvents as boundary events during create,",
        " * this must be reflected in the rules.",
        " */",
        "function isBoundaryCandidate(element) {",
        "  if (isBoundaryEvent(element)) {",
        "    return true;",
        "  }",
        "",
        "  if (is(element, 'bpmn:IntermediateThrowEvent') && hasNoEventDefinition(element)) {",
        "    return true;",
        "  }",
        "",
        "  return (",
        "    is(element, 'bpmn:IntermediateCatchEvent') &&",
        "    hasCommonBoundaryIntermediateEventDefinition(element)",
        "  );",
        "}",
        "",
        "function hasNoEventDefinition(element) {",
        "..."
    ]
}