{
    "lib/draw/BpmnRenderer.js": [
        "import inherits from 'inherits-browser';",
        "",
        "import {",
        "  assign,",
        "  forEach,",
        "  isObject",
        "} from 'min-dash';",
        "",
        "import BaseRenderer from 'diagram-js/lib/draw/BaseRenderer';",
        "",
        "import {",
        "  isExpanded,",
        "  isEventSubProcess",
        "} from '../util/DiUtil';",
        "",
        "import {",
        "  getLabel",
        "} from '../util/LabelUtil';",
        "",
        "import {",
        "  is",
        "} from '../util/ModelUtil';",
        "",
        "import {",
        "  createLine",
        "} from 'diagram-js/lib/util/RenderUtil';",
        "",
        "import {",
        "  isTypedEvent,",
        "  isThrowEvent,",
        "  isCollection,",
        "  getBounds,",
        "  getDi,",
        "  getSemantic,",
        "  getCirclePath,",
        "  getRoundRectPath,",
        "  getDiamondPath,",
        "  getRectPath,",
        "  getFillColor,",
        "  getStrokeColor,",
        "  getLabelColor,",
        "  getHeight,",
        "  getWidth",
        "} from './BpmnRenderUtil';",
        "",
        "import {",
        "  query as domQuery",
        "} from 'min-dom';",
        "",
        "import {",
        "  append as svgAppend,",
        "  attr as svgAttr,",
        "  create as svgCreate,",
        "  classes as svgClasses",
        "} from 'tiny-svg';",
        "",
        "import {",
        "  rotate,",
        "  transform,",
        "  translate",
        "} from 'diagram-js/lib/util/SvgTransformUtil';",
        "",
        "import Ids from 'ids';",
        "",
        "import { black } from './BpmnRenderUtil';",
        "",
        "var rendererIds = new Ids();",
        "",
        "var ELEMENT_LABEL_DISTANCE = 10,",
        "    INNER_OUTER_DIST = 3,",
        "    PARTICIPANT_STROKE_WIDTH = 1.5,",
        "    TASK_BORDER_RADIUS = 10;",
        "",
        "var DEFAULT_OPACITY = 0.95,",
        "    FULL_OPACITY = 1,",
        "    LOW_OPACITY = 0.25;",
        "",
        "/**",
        " * @typedef { Partial<{",
        " *   defaultFillColor: string,",
        " *   defaultStrokeColor: string,",
        " *   defaultLabelColor: string",
        " * }> } BpmnRendererConfig",
        " *",
        " * @typedef { Partial<{",
        " *   fill: string,",
        " *   stroke: string,",
        " *   width: string,",
        " *   height: string",
        " * }> } Attrs",
        " */",
        "",
        "/**",
        " * @typedef { import('../model/Types').Element } Element",
        " */",
        "",
        "/**",
        " * A renderer for BPMN elements",
        " *",
        " * @param {BpmnRendererConfig} config",
        " * @param {import('diagram-js/lib/core/EventBus').default} eventBus",
        " * @param {import('diagram-js/lib/draw/Styles').default} styles",
        " * @param {import('./PathMap').default} pathMap",
        " * @param {import('diagram-js/lib/core/Canvas').default} canvas",
        " * @param {import('./TextRenderer').default} textRenderer",
        " * @param {number} [priority]",
        " */",
        "export default function BpmnRenderer(",
        "    config, eventBus, styles, pathMap,",
        "    canvas, textRenderer, priority) {",
        "",
        "  BaseRenderer.call(this, eventBus, priority);",
        "",
        "  var defaultFillColor = config && config.defaultFillColor,",
        "      defaultStrokeColor = config && config.defaultStrokeColor,",
        "      defaultLabelColor = config && config.defaultLabelColor;",
        "",
        "  var rendererId = rendererIds.next();",
        "",
        "  var markers = {};",
        "",
        "  function shapeStyle(attrs) {",
        "    return styles.computeStyle(attrs, {",
        "      strokeLinecap: 'round',",
        "      strokeLinejoin: 'round',",
        "      stroke: black,",
        "      strokeWidth: 2,",
        "      fill: 'white'",
        "    });",
        "  }",
        "",
        "  function lineStyle(attrs) {",
        "    return styles.computeStyle(attrs, [ 'no-fill' ], {",
        "      strokeLinecap: 'round',",
        "      strokeLinejoin: 'round',",
        "      stroke: black,",
        "      strokeWidth: 2",
        "    });",
        "  }",
        "",
        "  function addMarker(id, options) {",
        "    var {",
        "      ref = { x: 0, y: 0 },",
        "      scale = 1,",
        "      element",
        "    } = options;",
        "",
        "    var marker = svgCreate('marker', {",
        "      id: id,",
        "      viewBox: '0 0 20 20',",
        "      refX: ref.x,",
        "      refY: ref.y,",
        "      markerWidth: 20 * scale,",
        "      markerHeight: 20 * scale,",
        "      orient: 'auto'",
        "    });",
        "",
        "    svgAppend(marker, element);",
        "",
        "    var defs = domQuery('defs', canvas._svg);",
        "",
        "    if (!defs) {",
        "      defs = svgCreate('defs');",
        "",
        "      svgAppend(canvas._svg, defs);",
        "    }",
        "",
        "    svgAppend(defs, marker);",
        "",
        "    markers[id] = marker;",
        "  }",
        "",
        "  function colorEscape(str) {",
        "",
        "    // only allow characters and numbers",
        "    return str.replace(/[^0-9a-zA-Z]+/g, '_');",
        "  }",
        "",
        "  function marker(type, fill, stroke) {",
        "    var id = type + '-' + colorEscape(fill) + '-' + colorEscape(stroke) + '-' + rendererId;",
        "",
        "    if (!markers[id]) {",
        "      createMarker(id, type, fill, stroke);",
        "    }",
        "",
        "    return 'url(#' + id + ')';",
        "  }",
        "",
        "  function createMarker(id, type, fill, stroke) {",
        "",
        "    if (type === 'sequenceflow-end') {",
        "      var sequenceflowEnd = svgCreate('path', {",
        "        d: 'M 1 5 L 11 10 L 1 15 Z',",
        "        ...shapeStyle({",
        "          fill: stroke,",
        "          stroke: stroke,",
        "          strokeWidth: 1",
        "        })",
        "      });",
        "",
        "      addMarker(id, {",
        "        element: sequenceflowEnd,",
        "        ref: { x: 11, y: 10 },",
        "        scale: 0.5",
        "      });",
        "    }",
        "",
        "    if (type === 'messageflow-start') {",
        "      var messageflowStart = svgCreate('circle', {",
        "        cx: 6,",
        "        cy: 6,",
        "        r: 3.5,",
        "        ...shapeStyle({",
        "          fill,",
        "          stroke: stroke,",
        "          strokeWidth: 1,",
        "",
        "          // fix for safari / chrome / firefox bug not correctly",
        "          // resetting stroke dash array",
        "          strokeDasharray: [ 10000, 1 ]",
        "        })",
        "      });",
        "",
        "      addMarker(id, {",
        "        element: messageflowStart,",
        "        ref: { x: 6, y: 6 }",
        "      });",
        "    }",
        "",
        "    if (type === 'messageflow-end') {",
        "      var messageflowEnd = svgCreate('path', {",
        "        d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z',",
        "        ...shapeStyle({",
        "          fill,",
        "          stroke: stroke,",
        "          strokeWidth: 1,",
        "",
        "          // fix for safari / chrome / firefox bug not correctly",
        "          // resetting stroke dash array",
        "          strokeDasharray: [ 10000, 1 ]",
        "        })",
        "      });",
        "",
        "      addMarker(id, {",
        "        element: messageflowEnd,",
        "        ref: { x: 8.5, y: 5 }",
        "      });",
        "    }",
        "",
        "    if (type === 'association-start') {",
        "      var associationStart = svgCreate('path', {",
        "        d: 'M 11 5 L 1 10 L 11 15',",
        "        ...lineStyle({",
        "          fill: 'none',",
        "          stroke,",
        "          strokeWidth: 1.5,",
        "",
        "          // fix for safari / chrome / firefox bug not correctly",
        "          // resetting stroke dash array",
        "          strokeDasharray: [ 10000, 1 ]",
        "        })",
        "      });",
        "",
        "      addMarker(id, {",
        "        element: associationStart,",
        "        ref: { x: 1, y: 10 },",
        "        scale: 0.5",
        "      });",
        "    }",
        "",
        "    if (type === 'association-end') {",
        "      var associationEnd = svgCreate('path', {",
        "        d: 'M 1 5 L 11 10 L 1 15',",
        "        ...lineStyle({",
        "          fill: 'none',",
        "          stroke,",
        "          strokeWidth: 1.5,",
        "",
        "          // fix for safari / chrome / firefox bug not correctly",
        "          // resetting stroke dash array",
        "          strokeDasharray: [ 10000, 1 ]",
        "        })",
        "      });",
        "",
        "      addMarker(id, {",
        "        element: associationEnd,",
        "        ref: { x: 11, y: 10 },",
        "        scale: 0.5",
        "      });",
        "    }",
        "",
        "    if (type === 'conditional-flow-marker') {",
        "      var conditionalFlowMarker = svgCreate('path', {",
        "        d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z',",
        "        ...shapeStyle({",
        "          fill,",
        "          stroke: stroke",
        "        })",
        "      });",
        "",
        "      addMarker(id, {",
        "        element: conditionalFlowMarker,",
        "        ref: { x: -1, y: 10 },",
        "        scale: 0.5",
        "      });",
        "    }",
        "",
        "    if (type === 'conditional-default-flow-marker') {",
        "      var defaultFlowMarker = svgCreate('path', {",
        "        d: 'M 6 4 L 10 16',",
        "        ...shapeStyle({",
        "          stroke: stroke",
        "        })",
        "      });",
        "",
        "      addMarker(id, {",
        "        element: defaultFlowMarker,",
        "        ref: { x: 0, y: 10 },",
        "        scale: 0.5",
        "      });",
        "    }",
        "  }",
        "",
        "  function drawCircle(parentGfx, width, height, offset, attrs = {}) {",
        "",
        "    if (isObject(offset)) {",
        "      attrs = offset;",
        "      offset = 0;",
        "    }",
        "",
        "    offset = offset || 0;",
        "",
        "    attrs = shapeStyle(attrs);",
        "",
        "    var cx = width / 2,",
        "        cy = height / 2;",
        "",
        "    var circle = svgCreate('circle', {",
        "      cx: cx,",
        "      cy: cy,",
        "      r: Math.round((width + height) / 4 - offset),",
        "      ...attrs",
        "    });",
        "",
        "    svgAppend(parentGfx, circle);",
        "",
        "    return circle;",
        "  }",
        "",
        "  function drawRect(parentGfx, width, height, r, offset, attrs) {",
        "",
        "    if (isObject(offset)) {",
        "      attrs = offset;",
        "      offset = 0;",
        "    }",
        "",
        "    offset = offset || 0;",
        "",
        "    attrs = shapeStyle(attrs);",
        "",
        "    var rect = svgCreate('rect', {",
        "      x: offset,",
        "      y: offset,",
        "      width: width - offset * 2,",
        "      height: height - offset * 2,",
        "      rx: r,",
        "      ry: r,",
        "      ...attrs",
        "    });",
        "",
        "    svgAppend(parentGfx, rect);",
        "",
        "    return rect;",
        "  }",
        "",
        "  function drawDiamond(parentGfx, width, height, attrs) {",
        "",
        "    var x_2 = width / 2;",
        "    var y_2 = height / 2;",
        "",
        "    var points = [",
        "      { x: x_2, y: 0 },",
        "      { x: width, y: y_2 },",
        "      { x: x_2, y: height },",
        "      { x: 0, y: y_2 }",
        "    ];",
        "",
        "    var pointsString = points.map(function(point) {",
        "      return point.x + ',' + point.y;",
        "    }).join(' ');",
        "",
        "    attrs = shapeStyle(attrs);",
        "",
        "    var polygon = svgCreate('polygon', {",
        "      ...attrs,",
        "      points: pointsString",
        "    });",
        "",
        "    svgAppend(parentGfx, polygon);",
        "",
        "    return polygon;",
        "  }",
        "",
        "  /**",
        "   * @param {SVGElement} parentGfx",
        "   * @param {Point[]} waypoints",
        "   * @param {any} attrs",
        "   * @param {number} [radius]",
        "   *",
        "   * @return {SVGElement}",
        "   */",
        "  function drawLine(parentGfx, waypoints, attrs, radius) {",
        "    attrs = lineStyle(attrs);",
        "",
        "    var line = createLine(waypoints, attrs, radius);",
        "",
        "    svgAppend(parentGfx, line);",
        "",
        "    return line;",
        "  }",
        "",
        "  /**",
        "   * @param {SVGElement} parentGfx",
        "   * @param {Point[]} waypoints",
        "   * @param {any} attrs",
        "   *",
        "   * @return {SVGElement}",
        "   */",
        "  function drawConnectionSegments(parentGfx, waypoints, attrs) {",
        "    return drawLine(parentGfx, waypoints, attrs, 5);",
        "  }",
        "",
        "  function drawPath(parentGfx, d, attrs) {",
        "    attrs = lineStyle(attrs);",
        "",
        "    var path = svgCreate('path', {",
        "      ...attrs,",
        "      d",
        "    });",
        "",
        "    svgAppend(parentGfx, path);",
        "",
        "    return path;",
        "  }",
        "",
        "  function drawMarker(type, parentGfx, path, attrs) {",
        "    return drawPath(parentGfx, path, assign({ 'data-marker': type }, attrs));",
        "  }",
        "",
        "  function renderer(type) {",
        "    return handlers[type];",
        "  }",
        "",
        "  function as(type) {",
        "    return function(parentGfx, element, attrs) {",
        "      return renderer(type)(parentGfx, element, attrs);",
        "    };",
        "  }",
        "",
        "  var eventIconRenderers = {",
        "    'bpmn:MessageEventDefinition': function(parentGfx, element, attrs = {}, isThrowing) {",
        "      var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {",
        "        xScaleFactor: 0.9,",
        "        yScaleFactor: 0.9,",
        "        containerWidth: element.width,",
        "        containerHeight: element.height,",
        "        position: {",
        "          mx: 0.235,",
        "          my: 0.315",
        "        }",
        "      });",
        "",
        "      var fill = isThrowing",
        "        ? getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
        "        : getFillColor(element, defaultFillColor, attrs.fill);",
        "",
        "      var stroke = isThrowing",
        "        ? getFillColor(element, defaultFillColor, attrs.fill)",
        "        : getStrokeColor(element, defaultStrokeColor, attrs.stroke);",
        "",
        "      var messagePath = drawPath(parentGfx, pathData, {",
        "        fill,",
        "        stroke,",
        "        strokeWidth: 1",
        "      });",
        "",
        "      return messagePath;",
        "    },",
        "    'bpmn:TimerEventDefinition': function(parentGfx, element, attrs = {}) {",
        "      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {",
        "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
        "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
        "        strokeWidth: 2",
        "      });",
        "",
        "      var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {",
        "        xScaleFactor: 0.75,",
        "        yScaleFactor: 0.75,",
        "        containerWidth: element.width,",
        "        containerHeight: element.height,",
        "        position: {",
        "          mx: 0.5,",
        "          my: 0.5",
        "        }",
        "      });",
        "",
        "      drawPath(parentGfx, pathData, {",
        "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
        "        strokeWidth: 2",
        "      });",
        "",
        "      for (var i = 0; i < 12; i++) {",
        "        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {",
        "          xScaleFactor: 0.75,",
        "          yScaleFactor: 0.75,",
        "          containerWidth: element.width,",
        "          containerHeight: element.height,",
        "          position: {",
        "            mx: 0.5,",
        "            my: 0.5",
        "          }",
        "        });",
        "",
        "        var width = element.width / 2,",
        "            height = element.height / 2;",
        "",
        "        drawPath(parentGfx, linePathData, {",
        "          strokeWidth: 1,",
        "          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
        "          transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')'",
        "        });",
        "      }",
        "",
        "      return circle;",
        "    },",
        "    'bpmn:EscalationEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
        "      var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {",
        "        xScaleFactor: 1,",
        "        yScaleFactor: 1,",
        "        containerWidth: event.width,",
        "        containerHeight: event.height,",
        "        position: {",
        "          mx: 0.5,",
        "          my: 0.2",
        "        }",
        "      });",
        "",
        "      var fill = isThrowing",
        "        ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)",
        "        : getFillColor(event, defaultFillColor, attrs.fill);",
        "",
        "      return drawPath(parentGfx, pathData, {",
        "        fill,",
        "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
        "        strokeWidth: 1",
        "      });",
        "    },",
        "    'bpmn:ConditionalEventDefinition': function(parentGfx, event, attrs = {}) {",
        "      var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {",
        "        xScaleFactor: 1,",
        "        yScaleFactor: 1,",
        "        containerWidth: event.width,",
        "        containerHeight: event.height,",
        "        position: {",
        "          mx: 0.5,",
        "          my: 0.222",
        "        }",
        "      });",
        "",
        "      return drawPath(parentGfx, pathData, {",
        "        fill: getFillColor(event, defaultFillColor, attrs.fill),",
        "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
        "        strokeWidth: 1",
        "      });",
        "    },",
        "    'bpmn:LinkEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
        "      var pathData = pathMap.getScaledPath('EVENT_LINK', {",
        "        xScaleFactor: 1,",
        "        yScaleFactor: 1,",
        "        containerWidth: event.width,",
        "        containerHeight: event.height,",
        "        position: {",
        "          mx: 0.57,",
        "..."
    ],
    "lib/features/modeling/behavior/IsHorizontalFix.js": [
        "import inherits from 'inherits-browser';",
        "",
        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
        "",
        "import {",
        "  getBusinessObject,",
        "  getDi",
        "} from '../../../util/ModelUtil';",
        "",
        "import {",
        "  isAny",
        "} from '../util/ModelingUtil';",
        "",
        "/**",
        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
        " */",
        "",
        "/**",
        " * A component that makes sure that each created or updated",
        " * Pool and Lane is assigned an isHorizontal property set to true.",
        " *",
        " * @param {EventBus} eventBus",
        " */",
        "export default function IsHorizontalFix(eventBus) {",
        "",
        "  CommandInterceptor.call(this, eventBus);",
        "",
        "  var elementTypesToUpdate = [",
        "    'bpmn:Participant',",
        "    'bpmn:Lane'",
        "  ];",
        "",
        "  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], function(event) {",
        "    var shape = event.context.shape,",
        "        bo = getBusinessObject(shape),",
        "        di = getDi(shape);",
        "",
        "    if (isAny(bo, elementTypesToUpdate) && !di.get('isHorizontal')) {",
        "",
        "      // set attribute directly to avoid modeling#updateProperty side effects",
        "      di.set('isHorizontal', true);",
        "    }",
        "  });",
        "",
        "}",
        "",
        "IsHorizontalFix.$inject = [ 'eventBus' ];",
        "",
        "inherits(IsHorizontalFix, CommandInterceptor);"
    ],
    "lib/draw/BpmnRenderUtil.js": [
        "import {",
        "  has,",
        "  some",
        "} from 'min-dash';",
        "",
        "import {",
        "  getDi",
        "} from '../util/ModelUtil';",
        "",
        "import {",
        "  componentsToPath",
        "} from 'diagram-js/lib/util/RenderUtil';",
        "",
        "",
        "/**",
        " * @typedef {import('../model').ModdleElement} ModdleElement",
        " * @typedef {import('../model').Element} Element",
        " *",
        " * @typedef {import('../model').ShapeLike} ShapeLike",
        " *",
        " * @typedef {import('diagram-js/lib/util/Types').Dimensions} Dimensions",
        " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
        " */",
        "",
        "// re-export for compatibility",
        "export {",
        "  getDi,",
        "  getBusinessObject as getSemantic",
        "} from '../util/ModelUtil';",
        "",
        "",
        "export var black = 'hsl(225, 10%, 15%)';",
        "export var white = 'white';",
        "",
        "// element utils //////////////////////",
        "",
        "/**",
        " * Checks if eventDefinition of the given element matches with semantic type.",
        " *",
        " * @param {ModdleElement} event",
        " * @param {string} eventDefinitionType",
        " *",
        " * @return {boolean}",
        " */",
        "export function isTypedEvent(event, eventDefinitionType) {",
        "  return some(event.eventDefinitions, function(definition) {",
        "    return definition.$type === eventDefinitionType;",
        "  });",
        "}",
        "",
        "/**",
        " * Check if element is a throw event.",
        " *",
        " * @param {ModdleElement} event",
        " *",
        " * @return {boolean}",
        " */",
        "export function isThrowEvent(event) {",
        "  return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');",
        "}",
        "",
        "/**",
        " * Check if element is a throw event.",
        " *",
        " * @param {ModdleElement} element",
        " *",
        " * @return {boolean}",
        " */",
        "export function isCollection(element) {",
        "  var dataObject = element.dataObjectRef;",
        "",
        "  return element.isCollection || (dataObject && dataObject.isCollection);",
        "}",
        "",
        "",
        "// color access //////////////////////",
        "",
        "/**",
        " * @param {Element} element",
        " * @param {string} [defaultColor]",
        " * @param {string} [overrideColor]",
        " *",
        " * @return {string}",
        " */",
        "export function getFillColor(element, defaultColor, overrideColor) {",
        "  var di = getDi(element);",
        "",
        "  return overrideColor || di.get('color:background-color') || di.get('bioc:fill') || defaultColor || white;",
        "}",
        "",
        "/**",
        " * @param {Element} element",
        " * @param {string} [defaultColor]",
        " * @param {string} [overrideColor]",
        " *",
        " * @return {string}",
        " */",
        "export function getStrokeColor(element, defaultColor, overrideColor) {",
        "  var di = getDi(element);",
        "",
        "  return overrideColor || di.get('color:border-color') || di.get('bioc:stroke') || defaultColor || black;",
        "}",
        "",
        "/**",
        " * @param {Element} element",
        " * @param {string} [defaultColor]",
        " * @param {string} [defaultStrokeColor]",
        " * @param {string} [overrideColor]",
        " *",
        " * @return {string}",
        " */",
        "export function getLabelColor(element, defaultColor, defaultStrokeColor, overrideColor) {",
        "  var di = getDi(element),",
        "      label = di.get('label');",
        "",
        "  return overrideColor || (label && label.get('color:color')) || defaultColor ||",
        "    getStrokeColor(element, defaultStrokeColor);",
        "}",
        "",
        "// cropping path customizations //////////////////////",
        "",
        "/**",
        " * @param {ShapeLike} shape",
        " *",
        " * @return {string} path",
        " */",
        "export function getCirclePath(shape) {",
        "",
        "  var cx = shape.x + shape.width / 2,",
        "      cy = shape.y + shape.height / 2,",
        "      radius = shape.width / 2;",
        "",
        "  var circlePath = [",
        "    [ 'M', cx, cy ],",
        "    [ 'm', 0, -radius ],",
        "    [ 'a', radius, radius, 0, 1, 1, 0, 2 * radius ],",
        "    [ 'a', radius, radius, 0, 1, 1, 0, -2 * radius ],",
        "    [ 'z' ]",
        "  ];",
        "",
        "  return componentsToPath(circlePath);",
        "}",
        "",
        "/**",
        " * @param {ShapeLike} shape",
        " * @param {number} [borderRadius]",
        " *",
        " * @return {string} path",
        " */",
        "export function getRoundRectPath(shape, borderRadius) {",
        "",
        "  var x = shape.x,",
        "      y = shape.y,",
        "      width = shape.width,",
        "      height = shape.height;",
        "",
        "  var roundRectPath = [",
        "    [ 'M', x + borderRadius, y ],",
        "    [ 'l', width - borderRadius * 2, 0 ],",
        "    [ 'a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius ],",
        "    [ 'l', 0, height - borderRadius * 2 ],",
        "    [ 'a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius ],",
        "    [ 'l', borderRadius * 2 - width, 0 ],",
        "    [ 'a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius ],",
        "    [ 'l', 0, borderRadius * 2 - height ],",
        "    [ 'a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius ],",
        "    [ 'z' ]",
        "  ];",
        "",
        "  return componentsToPath(roundRectPath);",
        "}",
        "",
        "/**",
        " * @param {ShapeLike} shape",
        " *",
        " * @return {string} path",
        " */",
        "export function getDiamondPath(shape) {",
        "",
        "  var width = shape.width,",
        "      height = shape.height,",
        "      x = shape.x,",
        "      y = shape.y,",
        "      halfWidth = width / 2,",
        "      halfHeight = height / 2;",
        "",
        "  var diamondPath = [",
        "    [ 'M', x + halfWidth, y ],",
        "    [ 'l', halfWidth, halfHeight ],",
        "    [ 'l', -halfWidth, halfHeight ],",
        "    [ 'l', -halfWidth, -halfHeight ],",
        "    [ 'z' ]",
        "  ];",
        "",
        "  return componentsToPath(diamondPath);",
        "}",
        "",
        "/**",
        " * @param {ShapeLike} shape",
        " *",
        " * @return {string} path",
        " */",
        "export function getRectPath(shape) {",
        "  var x = shape.x,",
        "      y = shape.y,",
        "      width = shape.width,",
        "      height = shape.height;",
        "",
        "  var rectPath = [",
        "    [ 'M', x, y ],",
        "    [ 'l', width, 0 ],",
        "    [ 'l', 0, height ],",
        "    [ 'l', -width, 0 ],",
        "    [ 'z' ]",
        "  ];",
        "",
        "  return componentsToPath(rectPath);",
        "}",
        "",
        "/**",
        " * Get width and height from element or overrides.",
        " *",
        " * @param {Dimensions|Rect|ShapeLike} bounds",
        " * @param {Object} overrides",
        " *",
        " * @returns {Dimensions}",
        " */",
        "export function getBounds(bounds, overrides = {}) {",
        "  return {",
        "    width: getWidth(bounds, overrides),",
        "    height: getHeight(bounds, overrides)",
        "  };",
        "}",
        "",
        "/**",
        " * Get width from element or overrides.",
        " *",
        " * @param {Dimensions|Rect|ShapeLike} bounds",
        " * @param {Object} overrides",
        " *",
        " * @returns {number}",
        " */",
        "export function getWidth(bounds, overrides = {}) {",
        "  return has(overrides, 'width') ? overrides.width : bounds.width;",
        "}",
        "",
        "/**",
        " * Get height from element or overrides.",
        " *",
        " * @param {Dimensions|Rect|ShapeLike} bounds",
        " * @param {Object} overrides",
        " *",
        " * @returns {number}",
        " */",
        "export function getHeight(bounds, overrides = {}) {",
        "  return has(overrides, 'height') ? overrides.height : bounds.height;",
        "}"
    ]
}