{
    ".eslintignore": {},
    ".eslintrc": {},
    ".gitignore": {},
    "CHANGELOG.md": {},
    "LICENSE": {},
    "README.md": {},
    "index.js": {
        "classes": [],
        "functions": [],
        "text": [
            "export {",
            "  default",
            "} from './lib/Viewer';"
        ]
    },
    "package-lock.json": {},
    "package.json": {},
    "renovate.json": {},
    "rollup.config.js": {
        "classes": [],
        "functions": [],
        "text": [
            "/* eslint-env node */",
            "",
            "import terser from '@rollup/plugin-terser';",
            "import nodeResolve from '@rollup/plugin-node-resolve';",
            "import commonjs from '@rollup/plugin-commonjs';",
            "import json from '@rollup/plugin-json';",
            "import replace from '@rollup/plugin-replace';",
            "import license from 'rollup-plugin-license';",
            "",
            "import {",
            "  readFileSync",
            "} from 'fs';",
            "",
            "import pkg from './package.json';",
            "",
            "const outputDir = 'dist';",
            "",
            "const distros = [",
            "  {",
            "    input: 'Viewer',",
            "    output: 'bpmn-viewer'",
            "  },",
            "  {",
            "    input: 'NavigatedViewer',",
            "    output: 'bpmn-navigated-viewer'",
            "  },",
            "  {",
            "    input: 'Modeler',",
            "    output: 'bpmn-modeler'",
            "  }",
            "];",
            "",
            "const configs = distros.reduce(function(configs, distro) {",
            "  const {",
            "    input,",
            "    output",
            "  } = distro;",
            "",
            "  return [",
            "    ...configs,",
            "    {",
            "      input: `./lib/${input}.js`,",
            "      output: {",
            "        name: 'BpmnJS',",
            "        file: `${outputDir}/${output}.development.js`,",
            "        format: 'umd'",
            "      },",
            "      plugins: pgl([",
            "        banner(output)",
            "      ], 'development')",
            "    },",
            "    {",
            "      input: `./lib/${input}.js`,",
            "      output: {",
            "        name: 'BpmnJS',",
            "        file: `${outputDir}/${output}.production.min.js`,",
            "        format: 'umd'",
            "      },",
            "      plugins: pgl([",
            "        banner(output, true),",
            "        terser({",
            "          output: {",
            "            comments: /license|@preserve/",
            "          }",
            "        })",
            "      ], 'production')",
            "    }",
            "  ];",
            "}, []);",
            "",
            "export default configs;",
            "",
            "",
            "// helpers //////////////////////",
            "",
            "function banner(bundleName, minified) {",
            "",
            "  const bannerName = (",
            "    minified",
            "      ? 'banner-min'",
            "      : 'banner'",
            "  );",
            "",
            "  const bannerTemplate = readFileSync(`${__dirname}/resources/${bannerName}.txt`, 'utf8');",
            "",
            "  const banner = processTemplate(bannerTemplate, {",
            "    version: pkg.version,",
            "    date: today(),",
            "    name: bundleName",
            "  });",
            "",
            "  return license({",
            "    banner",
            "  });",
            "}",
            "",
            "function pgl(plugins = [], env = 'production') {",
            "  return [",
            "    replace({",
            "      preventAssignment: true,",
            "      'process.env.NODE_ENV': JSON.stringify(env)",
            "    }),",
            "    nodeResolve(),",
            "    commonjs(),",
            "    json(),",
            "    ...plugins",
            "  ];",
            "}",
            "",
            "function pad(n) {",
            "  if (n < 10) {",
            "    return '0' + n;",
            "  } else {",
            "    return n;",
            "  }",
            "}",
            "",
            "function today() {",
            "  const d = new Date();",
            "",
            "  return [",
            "    d.getFullYear(),",
            "    pad(d.getMonth() + 1),",
            "    pad(d.getDate())",
            "  ].join('-');",
            "}",
            "",
            "function processTemplate(str, args) {",
            "  return str.replace(/\\{\\{\\s*([^\\s]+)\\s*\\}\\}/g, function(_, n) {",
            "",
            "    var replacement = args[n];",
            "",
            "    if (!replacement) {",
            "      throw new Error('unknown template {{ ' + n + '}}');",
            "    }",
            "",
            "    return replacement;",
            "  });",
            "}"
        ]
    },
    "tsconfig.json": {},
    "lib": {
        ".eslintrc": {},
        "BaseModeler.js": {
            "classes": [],
            "functions": [],
            "text": [
                "import inherits from 'inherits-browser';",
                "",
                "import Ids from 'ids';",
                "",
                "import BaseViewer from './BaseViewer';",
                "",
                "",
                "/**",
                " * @typedef {import('./BaseViewer').BaseViewerOptions} BaseViewerOptions",
                " * @typedef {import('./BaseViewer').ModdleElementsById} ModdleElementsById",
                " *",
                " * @typedef {import('./model/Types').ModdleElement} ModdleElement",
                " */",
                "",
                "/**",
                " * A base modeler for BPMN 2.0 diagrams.",
                " *",
                " * See {@link Modeler} for a fully-featured modeler.",
                " *",
                " * @param {BaseViewerOptions} [options] The options to configure the modeler.",
                " */",
                "export default function BaseModeler(options) {",
                "  BaseViewer.call(this, options);",
                "",
                "  // hook ID collection into the modeler",
                "  this.on('import.parse.complete', function(event) {",
                "    if (!event.error) {",
                "      this._collectIds(event.definitions, event.elementsById);",
                "    }",
                "  }, this);",
                "",
                "  this.on('diagram.destroy', function() {",
                "    this.get('moddle').ids.clear();",
                "  }, this);",
                "}",
                "",
                "inherits(BaseModeler, BaseViewer);",
                "",
                "",
                "/**",
                " * Create a moddle instance, attaching IDs to it.",
                " *",
                " * @param {BaseViewerOptions} options",
                " *",
                " * @return {Moddle}",
                " */",
                "BaseModeler.prototype._createModdle = function(options) {",
                "  var moddle = BaseViewer.prototype._createModdle.call(this, options);",
                "",
                "  // attach ids to moddle to be able to track and validated ids in the BPMN 2.0",
                "  // XML document tree",
                "  moddle.ids = new Ids([ 32, 36, 1 ]);",
                "",
                "  return moddle;",
                "};",
                "",
                "/**",
                " * Collect IDs processed during parsing of the definitions object.",
                " *",
                " * @param {ModdleElement} definitions",
                " * @param {ModdleElementsById} elementsById",
                " */",
                "BaseModeler.prototype._collectIds = function(definitions, elementsById) {",
                "",
                "  var moddle = definitions.$model,",
                "      ids = moddle.ids,",
                "      id;",
                "",
                "  // remove references from previous import",
                "  ids.clear();",
                "",
                "  for (id in elementsById) {",
                "    ids.claim(id, elementsById[ id ]);",
                "  }",
                "};"
            ]
        },
        "BaseModeler.spec.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "import BaseModeler from './BaseModeler';",
                "",
                "import { testViewer } from './BaseViewer.spec';",
                "",
                "const modeler = new BaseModeler({",
                "  container: 'container'",
                "});",
                "",
                "testViewer(modeler);",
                "",
                "",
                "const otherModeler = new BaseModeler({",
                "  container: 'container'",
                "});",
                "",
                "const extendedModeler = new BaseModeler({",
                "  container: 'container',",
                "  alignToOrigin: false,",
                "  propertiesPanel: {",
                "    attachTo: '#properties-panel'",
                "  }",
                "});"
            ]
        },
        "BaseViewer.js": {
            "classes": [],
            "functions": [],
            "text": [
                "/**",
                " * The code in the <project-logo></project-logo> area",
                " * must not be changed.",
                " *",
                " * @see http://bpmn.io/license for more information.",
                " */",
                "import {",
                "  assign,",
                "  find,",
                "  isNumber,",
                "  omit",
                "} from 'min-dash';",
                "",
                "import {",
                "  domify,",
                "  assignStyle,",
                "  query as domQuery,",
                "  remove as domRemove",
                "} from 'min-dom';",
                "",
                "import {",
                "  innerSVG",
                "} from 'tiny-svg';",
                "",
                "import Diagram from 'diagram-js';",
                "import BpmnModdle from 'bpmn-moddle';",
                "",
                "import inherits from 'inherits-browser';",
                "",
                "import {",
                "  importBpmnDiagram",
                "} from './import/Importer';",
                "",
                "/**",
                " * @template T",
                " *",
                " * @typedef {import('diagram-js/lib/core/EventBus').EventBusEventCallback<T>} EventBusEventCallback",
                " */",
                "",
                "/**",
                " * @typedef {import('didi').ModuleDeclaration} ModuleDeclaration",
                " *",
                " * @typedef {import('./model/Types').Moddle} Moddle",
                " * @typedef {import('./model/Types').ModdleElement} ModdleElement",
                " * @typedef {import('./model/Types').ModdleExtension} ModdleExtension",
                " *",
                " * @typedef { {",
                " *   width?: number|string;",
                " *   height?: number|string;",
                " *   position?: string;",
                " *   container?: string|HTMLElement;",
                " *   moddleExtensions?: ModdleExtensions;",
                " *   additionalModules?: ModuleDeclaration[];",
                " * } & Record<string, any> } BaseViewerOptions",
                " *",
                " * @typedef {Record<string, ModdleElement>} ModdleElementsById",
                " *",
                " * @typedef { {",
                " *   [key: string]: ModdleExtension;",
                " * } } ModdleExtensions",
                " *",
                " * @typedef { {",
                " *   warnings: string[];",
                " * } } ImportXMLResult",
                " *",
                " * @typedef {ImportXMLResult & Error} ImportXMLError",
                " *",
                " * @typedef {ImportXMLResult} ImportDefinitionsResult",
                " *",
                " * @typedef {ImportXMLError} ImportDefinitionsError",
                " *",
                " * @typedef {ImportXMLResult} OpenResult",
                " *",
                " * @typedef {ImportXMLError} OpenError",
                " *",
                " * @typedef { {",
                " *   format?: boolean;",
                " *   preamble?: boolean;",
                " * } } SaveXMLOptions",
                " *",
                " * @typedef { {",
                " *   xml?: string;",
                " *   error?: Error;",
                " * } } SaveXMLResult",
                " *",
                " * @typedef { {",
                " *   svg: string;",
                " * } } SaveSVGResult",
                " *",
                " * @typedef { {",
                " *   xml: string;",
                " * } } ImportParseStartEvent",
                " *",
                " * @typedef { {",
                " *   error?: ImportXMLError;",
                " *   definitions?: ModdleElement;",
                " *   elementsById?: ModdleElementsById;",
                " *   references?: ModdleElement[];",
                " *   warnings: string[];",
                " * } } ImportParseCompleteEvent",
                " *",
                " * @typedef { {",
                " *   error?: ImportXMLError;",
                " *   warnings: string[];",
                " * } } ImportDoneEvent",
                " *",
                " * @typedef { {",
                " *   definitions: ModdleElement;",
                " * } } SaveXMLStartEvent",
                " *",
                " * @typedef {SaveXMLResult} SaveXMLDoneEvent",
                " *",
                " * @typedef { {",
                " *   error?: Error;",
                " *   svg: string;",
                " * } } SaveSVGDoneEvent",
                " */",
                "",
                "/**",
                " * A base viewer for BPMN 2.0 diagrams.",
                " *",
                " * Have a look at {@link Viewer}, {@link NavigatedViewer} or {@link Modeler} for",
                " * bundles that include actual features.",
                " *",
                " * @param {BaseViewerOptions} [options] The options to configure the viewer.",
                " */",
                "export default function BaseViewer(options) {",
                "",
                "  /**",
                "   * @type {BaseViewerOptions}",
                "   */",
                "  options = assign({}, DEFAULT_OPTIONS, options);",
                "",
                "  /**",
                "   * @type {Moddle}",
                "   */",
                "  this._moddle = this._createModdle(options);",
                "",
                "  /**",
                "   * @type {HTMLElement}",
                "   */",
                "  this._container = this._createContainer(options);",
                "",
                "  /* <project-logo> */",
                "",
                "  addProjectLogo(this._container);",
                "",
                "  /* </project-logo> */",
                "",
                "  this._init(this._container, this._moddle, options);",
                "}",
                "",
                "inherits(BaseViewer, Diagram);",
                "",
                "/**",
                " * Parse and render a BPMN 2.0 diagram.",
                " *",
                " * Once finished the viewer reports back the result to the",
                " * provided callback function with (err, warnings).",
                " *",
                " * ## Life-Cycle Events",
                " *",
                " * During import the viewer will fire life-cycle events:",
                " *",
                " *   * import.parse.start (about to read model from XML)",
                " *   * import.parse.complete (model read; may have worked or not)",
                " *   * import.render.start (graphical import start)",
                " *   * import.render.complete (graphical import finished)",
                " *   * import.done (everything done)",
                " *",
                " * You can use these events to hook into the life-cycle.",
                " *",
                " * @throws {ImportXMLError} An error thrown during the import of the XML.",
                " *",
                " * @fires BaseViewer#ImportParseStartEvent",
                " * @fires BaseViewer#ImportParseCompleteEvent",
                " * @fires Importer#ImportRenderStartEvent",
                " * @fires Importer#ImportRenderCompleteEvent",
                " * @fires BaseViewer#ImportDoneEvent",
                " *",
                " * @param {string} xml The BPMN 2.0 XML to be imported.",
                " * @param {ModdleElement|string} [bpmnDiagram] The optional diagram or Id of the BPMN diagram to open.",
                " *",
                " * @return {Promise<ImportXMLResult>} A promise resolving with warnings that were produced during the import.",
                " */",
                "BaseViewer.prototype.importXML = async function importXML(xml, bpmnDiagram) {",
                "",
                "  const self = this;",
                "",
                "  function ParseCompleteEvent(data) {",
                "    return self.get('eventBus').createEvent(data);",
                "  }",
                "",
                "  let aggregatedWarnings = [];",
                "  try {",
                "",
                "    // hook in pre-parse listeners +",
                "    // allow xml manipulation",
                "",
                "    /**",
                "     * A `import.parse.start` event.",
                "     *",
                "     * @event BaseViewer#ImportParseStartEvent",
                "     * @type {ImportParseStartEvent}",
                "     */",
                "    xml = this._emit('import.parse.start', { xml: xml }) || xml;",
                "",
                "    let parseResult;",
                "    try {",
                "      parseResult = await this._moddle.fromXML(xml, 'bpmn:Definitions');",
                "    } catch (error) {",
                "      this._emit('import.parse.complete', {",
                "        error",
                "      });",
                "",
                "      throw error;",
                "    }",
                "",
                "    let definitions = parseResult.rootElement;",
                "    const references = parseResult.references;",
                "    const parseWarnings = parseResult.warnings;",
                "    const elementsById = parseResult.elementsById;",
                "",
                "    aggregatedWarnings = aggregatedWarnings.concat(parseWarnings);",
                "",
                "    // hook in post parse listeners +",
                "    // allow definitions manipulation",
                "",
                "    /**",
                "     * A `import.parse.complete` event.",
                "     *",
                "     * @event BaseViewer#ImportParseCompleteEvent",
                "     * @type {ImportParseCompleteEvent}",
                "     */",
                "    definitions = this._emit('import.parse.complete', ParseCompleteEvent({",
                "      error: null,",
                "      definitions: definitions,",
                "      elementsById: elementsById,",
                "      references: references,",
                "      warnings: aggregatedWarnings",
                "    })) || definitions;",
                "",
                "    const importResult = await this.importDefinitions(definitions, bpmnDiagram);",
                "",
                "    aggregatedWarnings = aggregatedWarnings.concat(importResult.warnings);",
                "",
                "    /**",
                "     * A `import.parse.complete` event.",
                "     *",
                "     * @event BaseViewer#ImportDoneEvent",
                "     * @type {ImportDoneEvent}",
                "     */",
                "    this._emit('import.done', { error: null, warnings: aggregatedWarnings });",
                "",
                "    return { warnings: aggregatedWarnings };",
                "  } catch (err) {",
                "    let error = err;",
                "    aggregatedWarnings = aggregatedWarnings.concat(error.warnings || []);",
                "    addWarningsToError(error, aggregatedWarnings);",
                "",
                "    error = checkValidationError(error);",
                "",
                "    this._emit('import.done', { error, warnings: error.warnings });",
                "",
                "    throw error;",
                "  }",
                "};",
                "",
                "",
                "/**",
                " * Import parsed definitions and render a BPMN 2.0 diagram.",
                " *",
                " * Once finished the viewer reports back the result to the",
                " * provided callback function with (err, warnings).",
                " *",
                " * ## Life-Cycle Events",
                " *",
                " * During import the viewer will fire life-cycle events:",
                " *",
                " *   * import.render.start (graphical import start)",
                " *   * import.render.complete (graphical import finished)",
                " *",
                " * You can use these events to hook into the life-cycle.",
                " *",
                " * @throws {ImportDefinitionsError} An error thrown during the import of the definitions.",
                " *",
                " * @param {ModdleElement} definitions The definitions.",
                " * @param {ModdleElement|string} [bpmnDiagram] The optional diagram or ID of the BPMN diagram to open.",
                " *",
                " * @return {Promise<ImportDefinitionsResult>} A promise resolving with warnings that were produced during the import.",
                " */",
                "BaseViewer.prototype.importDefinitions = async function importDefinitions(definitions, bpmnDiagram) {",
                "  this._setDefinitions(definitions);",
                "  const result = await this.open(bpmnDiagram);",
                "",
                "  return { warnings: result.warnings };",
                "};",
                "",
                "",
                "/**",
                " * Open diagram of previously imported XML.",
                " *",
                " * Once finished the viewer reports back the result to the",
                " * provided callback function with (err, warnings).",
                " *",
                " * ## Life-Cycle Events",
                " *",
                " * During switch the viewer will fire life-cycle events:",
                " *",
                " *   * import.render.start (graphical import start)",
                " *   * import.render.complete (graphical import finished)",
                " *",
                " * You can use these events to hook into the life-cycle.",
                " *",
                " * @throws {OpenError} An error thrown during opening.",
                " *",
                " * @param {ModdleElement|string} bpmnDiagramOrId The diagram or Id of the BPMN diagram to open.",
                " *",
                " * @return {Promise<OpenResult>} A promise resolving with warnings that were produced during opening.",
                " */",
                "BaseViewer.prototype.open = async function open(bpmnDiagramOrId) {",
                "",
                "  const definitions = this._definitions;",
                "  let bpmnDiagram = bpmnDiagramOrId;",
                "",
                "  if (!definitions) {",
                "    const error = new Error('no XML imported');",
                "    addWarningsToError(error, []);",
                "",
                "    throw error;",
                "  }",
                "",
                "  if (typeof bpmnDiagramOrId === 'string') {",
                "    bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);",
                "",
                "    if (!bpmnDiagram) {",
                "      const error = new Error('BPMNDiagram <' + bpmnDiagramOrId + '> not found');",
                "      addWarningsToError(error, []);",
                "",
                "      throw error;",
                "    }",
                "  }",
                "",
                "  // clear existing rendered diagram",
                "  // catch synchronous exceptions during #clear()",
                "  try {",
                "    this.clear();",
                "  } catch (error) {",
                "    addWarningsToError(error, []);",
                "",
                "    throw error;",
                "  }",
                "",
                "  // perform graphical import",
                "  const { warnings } = await importBpmnDiagram(this, definitions, bpmnDiagram);",
                "",
                "  return { warnings };",
                "};",
                "",
                "/**",
                " * Export the currently displayed BPMN 2.0 diagram as",
                " * a BPMN 2.0 XML document.",
                " *",
                " * ## Life-Cycle Events",
                " *",
                " * During XML saving the viewer will fire life-cycle events:",
                " *",
                " *   * saveXML.start (before serialization)",
                " *   * saveXML.serialized (after xml generation)",
                " *   * saveXML.done (everything done)",
                " *",
                " * You can use these events to hook into the life-cycle.",
                " *",
                " * @throws {Error} An error thrown during export.",
                " *",
                " * @fires BaseViewer#SaveXMLStart",
                " * @fires BaseViewer#SaveXMLDone",
                " *",
                " * @param {SaveXMLOptions} [options] The options.",
                " *",
                " * @return {Promise<SaveXMLResult>} A promise resolving with the XML.",
                " */",
                "BaseViewer.prototype.saveXML = async function saveXML(options) {",
                "",
                "  options = options || {};",
                "",
                "  let definitions = this._definitions,",
                "      error, xml;",
                "",
                "  try {",
                "    if (!definitions) {",
                "      throw new Error('no definitions loaded');",
                "    }",
                "",
                "    // allow to fiddle around with definitions",
                "",
                "    /**",
                "     * A `saveXML.start` event.",
                "     *",
                "     * @event BaseViewer#SaveXMLStartEvent",
                "     * @type {SaveXMLStartEvent}",
                "     */",
                "    definitions = this._emit('saveXML.start', {",
                "      definitions",
                "    }) || definitions;",
                "",
                "    const result = await this._moddle.toXML(definitions, options);",
                "    xml = result.xml;",
                "",
                "    xml = this._emit('saveXML.serialized', {",
                "      xml",
                "    }) || xml;",
                "  } catch (err) {",
                "    error = err;",
                "  }",
                "",
                "  const result = error ? { error } : { xml };",
                "",
                "  /**",
                "   * A `saveXML.done` event.",
                "   *",
                "   * @event BaseViewer#SaveXMLDoneEvent",
                "   * @type {SaveXMLDoneEvent}",
                "   */",
                "  this._emit('saveXML.done', result);",
                "",
                "  if (error) {",
                "    throw error;",
                "  }",
                "",
                "  return result;",
                "};",
                "",
                "",
                "/**",
                " * Export the currently displayed BPMN 2.0 diagram as",
                " * an SVG image.",
                " *",
                " * ## Life-Cycle Events",
                " *",
                " * During SVG saving the viewer will fire life-cycle events:",
                " *",
                " *   * saveSVG.start (before serialization)",
                " *   * saveSVG.done (everything done)",
                " *",
                " * You can use these events to hook into the life-cycle.",
                " *",
                " * @throws {Error} An error thrown during export.",
                " *",
                " * @fires BaseViewer#SaveSVGDone",
                " *",
                " * @return {Promise<SaveSVGResult>} A promise resolving with the SVG.",
                " */",
                "BaseViewer.prototype.saveSVG = async function saveSVG() {",
                "  this._emit('saveSVG.start');",
                "",
                "  let svg, err;",
                "",
                "  try {",
                "    const canvas = this.get('canvas');",
                "",
                "    const contentNode = canvas.getActiveLayer(),",
                "          defsNode = domQuery('defs', canvas._svg);",
                "",
                "    const contents = innerSVG(contentNode),",
                "          defs = defsNode ? '<defs>' + innerSVG(defsNode) + '</defs>' : '';",
                "",
                "    const bbox = contentNode.getBBox();",
                "",
                "    svg =",
                "      '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n' +",
                "      '<!-- created with bpmn-js / http://bpmn.io -->\\n' +",
                "      '<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\\n' +",
                "      '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +",
                "      'width=\"' + bbox.width + '\" height=\"' + bbox.height + '\" ' +",
                "      'viewBox=\"' + bbox.x + ' ' + bbox.y + ' ' + bbox.width + ' ' + bbox.height + '\" version=\"1.1\">' +",
                "      defs + contents +",
                "      '</svg>';",
                "  } catch (e) {",
                "    err = e;",
                "  }",
                "",
                "  /**",
                "   * A `saveSVG.done` event.",
                "   *",
                "   * @event BaseViewer#SaveSVGDoneEvent",
                "   * @type {SaveSVGDoneEvent}",
                "   */",
                "  this._emit('saveSVG.done', {",
                "    error: err,",
                "    svg: svg",
                "  });",
                "",
                "  if (err) {",
                "    throw err;",
                "  }",
                "",
                "  return { svg };",
                "};",
                "",
                "BaseViewer.prototype._setDefinitions = function(definitions) {",
                "  this._definitions = definitions;",
                "};",
                "",
                "/**",
                " * Return modules to instantiate with.",
                " *",
                " * @return {ModuleDeclaration[]} The modules.",
                " */",
                "BaseViewer.prototype.getModules = function() {",
                "  return this._modules;",
                "};",
                "",
                "/**",
                " * Remove all drawn elements from the viewer.",
                " *",
                " * After calling this method the viewer can still be reused for opening another",
                " * diagram.",
                " */",
                "BaseViewer.prototype.clear = function() {",
                "  if (!this.getDefinitions()) {",
                "",
                "    // no diagram to clear",
                "    return;",
                "  }",
                "",
                "  // remove drawn elements",
                "  Diagram.prototype.clear.call(this);",
                "};",
                "",
                "/**",
                " * Destroy the viewer instance and remove all its remainders from the document",
                " * tree.",
                " */",
                "BaseViewer.prototype.destroy = function() {",
                "",
                "  // diagram destroy",
                "  Diagram.prototype.destroy.call(this);",
                "",
                "  // dom detach",
                "  domRemove(this._container);",
                "};",
                "",
                "/**",
                " * Register an event listener.",
                " *",
                " * Remove an event listener via {@link BaseViewer#off}.",
                " *",
                " * @template T",
                " *",
                " * @param {string|string[]} events The event(s) to listen to.",
                " * @param {number} [priority] The priority with which to listen.",
                " * @param {EventBusEventCallback<T>} callback The callback.",
                " * @param {any} [that] Value of `this` the callback will be called with.",
                " */",
                "BaseViewer.prototype.on = function(events, priority, callback, that) {",
                "  return this.get('eventBus').on(events, priority, callback, that);",
                "};",
                "",
                "/**",
                " * Remove an event listener.",
                " *",
                " * @param {string|string[]} events The event(s).",
                " * @param {Function} [callback] The callback.",
                " */",
                "BaseViewer.prototype.off = function(events, callback) {",
                "  this.get('eventBus').off(events, callback);",
                "};",
                "",
                "/**",
                " * Attach the viewer to an HTML element.",
                " *",
                " * @param {HTMLElement} parentNode The parent node to attach to.",
                " */",
                "BaseViewer.prototype.attachTo = function(parentNode) {",
                "",
                "  if (!parentNode) {",
                "    throw new Error('parentNode required');",
                "  }",
                "",
                "  // ensure we detach from the",
                "  // previous, old parent",
                "  this.detach();",
                "",
                "  // unwrap jQuery if provided",
                "  if (parentNode.get && parentNode.constructor.prototype.jquery) {",
                "    parentNode = parentNode.get(0);",
                "  }",
                "",
                "  if (typeof parentNode === 'string') {",
                "    parentNode = domQuery(parentNode);",
                "  }",
                "",
                "  parentNode.appendChild(this._container);",
                "",
                "  this._emit('attach', {});",
                "",
                "  this.get('canvas').resized();",
                "};",
                "",
                "/**",
                " * Get the definitions model element.",
                " *",
                " * @return {ModdleElement} The definitions model element.",
                " */",
                "BaseViewer.prototype.getDefinitions = function() {",
                "  return this._definitions;",
                "};",
                "",
                "/**",
                " * Detach the viewer.",
                " *",
                " * @fires BaseViewer#DetachEvent",
                " */",
                "BaseViewer.prototype.detach = function() {",
                "",
                "  const container = this._container,",
                "        parentNode = container.parentNode;",
                "",
                "  if (!parentNode) {",
                "    return;",
                "  }",
                "",
                "  /**",
                "   * A `detach` event.",
                "   *",
                "   * @event BaseViewer#DetachEvent",
                "   * @type {Object}",
                "   */",
                "  this._emit('detach', {});",
                "",
                "  parentNode.removeChild(container);",
                "};",
                "",
                "BaseViewer.prototype._init = function(container, moddle, options) {",
                "",
                "  const baseModules = options.modules || this.getModules(options),",
                "        additionalModules = options.additionalModules || [],",
                "        staticModules = [",
                "          {",
                "            bpmnjs: [ 'value', this ],",
                "            moddle: [ 'value', moddle ]",
                "          }",
                "        ];",
                "",
                "  const diagramModules = [].concat(staticModules, baseModules, additionalModules);",
                "",
                "  const diagramOptions = assign(omit(options, [ 'additionalModules' ]), {",
                "    canvas: assign({}, options.canvas, { container: container }),",
                "    modules: diagramModules",
                "  });",
                "",
                "  // invoke diagram constructor",
                "  Diagram.call(this, diagramOptions);",
                "",
                "  if (options && options.container) {",
                "    this.attachTo(options.container);",
                "  }",
                "};",
                "",
                "/**",
                " * Emit an event on the underlying {@link EventBus}",
                " *",
                " * @param  {string} type",
                " * @param  {Object} event",
                " *",
                " * @return {Object} The return value after calling all event listeners.",
                " */",
                "BaseViewer.prototype._emit = function(type, event) {",
                "  return this.get('eventBus').fire(type, event);",
                "};",
                "",
                "/**",
                " * @param {BaseViewerOptions} options",
                " *",
                " * @return {HTMLElement}",
                " */",
                "BaseViewer.prototype._createContainer = function(options) {",
                "",
                "  const container = domify('<div class=\"bjs-container\"></div>');",
                "",
                "  assignStyle(container, {",
                "    width: ensureUnit(options.width),",
                "    height: ensureUnit(options.height),",
                "    position: options.position",
                "  });",
                "",
                "  return container;",
                "};",
                "",
                "/**",
                " * @param {BaseViewerOptions} options",
                " *",
                " * @return {Moddle}",
                " */",
                "BaseViewer.prototype._createModdle = function(options) {",
                "  const moddleOptions = assign({}, this._moddleExtensions, options.moddleExtensions);",
                "",
                "  return new BpmnModdle(moddleOptions);",
                "};",
                "",
                "BaseViewer.prototype._modules = [];",
                "",
                "// helpers ///////////////",
                "",
                "function addWarningsToError(err, warningsAry) {",
                "  err.warnings = warningsAry;",
                "  return err;",
                "}",
                "",
                "function checkValidationError(err) {",
                "",
                "  // check if we can help the user by indicating wrong BPMN 2.0 xml",
                "  // (in case he or the exporting tool did not get that right)",
                "",
                "  const pattern = /unparsable content <([^>]+)> detected([\\s\\S]*)$/;",
                "  const match = pattern.exec(err.message);",
                "",
                "  if (match) {",
                "    err.message =",
                "      'unparsable content <' + match[1] + '> detected; ' +",
                "      'this may indicate an invalid BPMN 2.0 diagram file' + match[2];",
                "  }",
                "",
                "  return err;",
                "}",
                "",
                "const DEFAULT_OPTIONS = {",
                "  width: '100%',",
                "  height: '100%',",
                "  position: 'relative'",
                "};",
                "",
                "",
                "/**",
                " * Ensure the passed argument is a proper unit (defaulting to px)",
                " */",
                "function ensureUnit(val) {",
                "  return val + (isNumber(val) ? 'px' : '');",
                "}",
                "",
                "",
                "/**",
                " * Find BPMNDiagram in definitions by ID",
                " *",
                " * @param {ModdleElement<Definitions>} definitions",
                " * @param {string} diagramId",
                " *",
                " * @return {ModdleElement<BPMNDiagram>|null}",
                " */",
                "function findBPMNDiagram(definitions, diagramId) {",
                "  if (!diagramId) {",
                "    return null;",
                "  }",
                "",
                "  return find(definitions.diagrams, function(element) {",
                "    return element.id === diagramId;",
                "  }) || null;",
                "}",
                "",
                "",
                "/* <project-logo> */",
                "",
                "import {",
                "  open as openPoweredBy,",
                "  BPMNIO_IMG,",
                "  LOGO_STYLES,",
                "  LINK_STYLES",
                "} from './util/PoweredByUtil';",
                "",
                "import {",
                "  event as domEvent",
                "} from 'min-dom';",
                "",
                "/**",
                " * Adds the project logo to the diagram container as",
                " * required by the bpmn.io license.",
                " *",
                " * @see http://bpmn.io/license",
                " *",
                " * @param {Element} container",
                " */",
                "function addProjectLogo(container) {",
                "  const img = BPMNIO_IMG;",
                "",
                "  const linkMarkup =",
                "    '<a href=\"http://bpmn.io\" ' +",
                "    'target=\"_blank\" ' +",
                "    'class=\"bjs-powered-by\" ' +",
                "    'title=\"Powered by bpmn.io\" ' +",
                "    '>' +",
                "    img +",
                "    '</a>';",
                "",
                "  const linkElement = domify(linkMarkup);",
                "",
                "  assignStyle(domQuery('svg', linkElement), LOGO_STYLES);",
                "  assignStyle(linkElement, LINK_STYLES, {",
                "    position: 'absolute',",
                "    bottom: '15px',",
                "    right: '15px',",
                "    zIndex: '100'",
                "  });",
                "",
                "  container.appendChild(linkElement);",
                "",
                "  domEvent.bind(linkElement, 'click', function(event) {",
                "    openPoweredBy();",
                "",
                "    event.preventDefault();",
                "  });",
                "}",
                "",
                "/* </project-logo> */"
            ]
        },
        "BaseViewer.spec.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "import CommandStack from 'diagram-js/lib/command/CommandStack';",
                "",
                "import { Event } from 'diagram-js/lib/core/EventBus';",
                "",
                "import BaseViewer, {",
                "  ImportDoneEvent,",
                "  ImportParseCompleteEvent,",
                "  ImportParseStartEvent,",
                "  SaveXMLDoneEvent,",
                "  SaveXMLStartEvent",
                "} from './BaseViewer';",
                "",
                "import OverlaysModule from 'diagram-js/lib/features/overlays';",
                "",
                "const viewer = new BaseViewer();",
                "",
                "const configuredViewer = new BaseViewer({",
                "  width: 100,",
                "  height: 100,",
                "  position: 'absolute',",
                "  container: 'container',",
                "  moddleExtensions: {",
                "    foo: {}",
                "  },",
                "  additionalModules: [",
                "    OverlaysModule",
                "  ]",
                "});",
                "",
                "testViewer(viewer);",
                "",
                "const extendedViewer = new BaseViewer({",
                "  container: 'container',",
                "  alignToOrigin: false,",
                "  propertiesPanel: {",
                "    attachTo: '#properties-panel'",
                "  }",
                "});",
                "",
                "export function testViewer(viewer: BaseViewer) {",
                "  viewer.importXML('<?xml version=\"1.0\" encoding=\"UTF-8\"?>', 'BPMNDiagram_1');",
                "",
                "  viewer.importXML('<?xml version=\"1.0\" encoding=\"UTF-8\"?>')",
                "    .then(({ warnings }) => {",
                "      console.log(warnings);",
                "    })",
                "    .catch(error => {",
                "      const {",
                "        message,",
                "        warnings",
                "      } = error;",
                "",
                "      console.log(message, warnings);",
                "    });",
                "",
                "  viewer.importDefinitions({ $type: 'bpmn:Definitions' }, 'BPMNDiagram_1');",
                "",
                "  viewer.importDefinitions({ $type: 'bpmn:Definitions' })",
                "    .then(({ warnings }) => {",
                "      console.log(warnings);",
                "    })",
                "    .catch(error => {",
                "      const {",
                "        message,",
                "        warnings",
                "      } = error;",
                "",
                "      console.log(message, warnings);",
                "    });",
                "",
                "  viewer.open('BPMNDiagram_1');",
                "",
                "  viewer.open({ $type: 'bpmn:BPMNDiagram' })",
                "    .then(({ warnings }) => {",
                "      console.log(warnings);",
                "    })",
                "    .catch(error => {",
                "      const {",
                "        message,",
                "        warnings",
                "      } = error;",
                "",
                "      console.log(message, warnings);",
                "    });",
                "",
                "  viewer.saveXML({ format: true, preamble: false })",
                "    .then(({ xml, error }) => {",
                "      if (error) {",
                "        console.log(error);",
                "      } else {",
                "        console.log(xml);",
                "      }",
                "    })",
                "    .catch(error => {",
                "      console.log(error);",
                "    });",
                "",
                "  viewer.saveXML();",
                "",
                "  viewer.saveSVG();",
                "",
                "  viewer.getModules();",
                "",
                "  viewer.clear();",
                "",
                "  viewer.destroy();",
                "",
                "  viewer.get<CommandStack>('commandStack').undo();",
                "",
                "  viewer.invoke((commandStack: CommandStack) => commandStack.undo());",
                "",
                "  viewer.on('foo', () => console.log('foo'));",
                "",
                "  viewer.on([ 'foo', 'bar' ], () => console.log('foo'));",
                "",
                "  viewer.on('foo', 2000, () => console.log('foo'));",
                "",
                "  viewer.on('foo', 2000, () => console.log('foo'), { foo: 'bar' });",
                "",
                "  viewer.off('foo', () => console.log('foo'));",
                "",
                "  viewer.attachTo(document.createElement('div'));",
                "",
                "  viewer.getDefinitions();",
                "",
                "  viewer.detach();",
                "",
                "  viewer.on<ImportParseStartEvent>('import.parse.start', ({ xml }) => {",
                "    console.log(xml);",
                "  });",
                "",
                "  viewer.on<ImportParseCompleteEvent>('import.parse.complete', ({",
                "    error,",
                "    definitions,",
                "    elementsById,",
                "    references,",
                "    warnings",
                "  }) => {",
                "    if (error) {",
                "      console.error(error);",
                "    }",
                "",
                "    if (warnings.length) {",
                "      warnings.forEach(warning => console.log(warning));",
                "    }",
                "",
                "    console.log(definitions, elementsById, references);",
                "  });",
                "",
                "  viewer.on<ImportDoneEvent>('import.done', ({ error, warnings }) => {",
                "    if (error) {",
                "      console.error(error);",
                "    }",
                "",
                "    if (warnings.length) {",
                "      warnings.forEach(warning => console.log(warning));",
                "    }",
                "  });",
                "",
                "  viewer.on<SaveXMLStartEvent>('saveXML.start', ({ definitions }) => {",
                "    console.log(definitions);",
                "  });",
                "",
                "  viewer.on<SaveXMLDoneEvent>('saveXML.done', ({ error, xml }) => {",
                "    if (error) {",
                "      console.error(error);",
                "    } else {",
                "      console.log(xml);",
                "    }",
                "  });",
                "",
                "  viewer.on<Event>('detach', () => {});",
                "}"
            ]
        },
        "Modeler.js": {
            "classes": [],
            "functions": [],
            "text": [
                "import inherits from 'inherits-browser';",
                "",
                "import BaseModeler from './BaseModeler';",
                "",
                "import Viewer from './Viewer';",
                "import NavigatedViewer from './NavigatedViewer';",
                "",
                "import KeyboardMoveModule from 'diagram-js/lib/navigation/keyboard-move';",
                "import MoveCanvasModule from 'diagram-js/lib/navigation/movecanvas';",
                "import TouchModule from 'diagram-js/lib/navigation/touch';",
                "import ZoomScrollModule from 'diagram-js/lib/navigation/zoomscroll';",
                "",
                "import AlignElementsModule from './features/align-elements';",
                "import AutoPlaceModule from './features/auto-place';",
                "import AutoResizeModule from './features/auto-resize';",
                "import AutoScrollModule from 'diagram-js/lib/features/auto-scroll';",
                "import BendpointsModule from 'diagram-js/lib/features/bendpoints';",
                "import ConnectModule from 'diagram-js/lib/features/connect';",
                "import ConnectionPreviewModule from 'diagram-js/lib/features/connection-preview';",
                "import ContextPadModule from './features/context-pad';",
                "import CopyPasteModule from './features/copy-paste';",
                "import CreateModule from 'diagram-js/lib/features/create';",
                "import DistributeElementsModule from './features/distribute-elements';",
                "import EditorActionsModule from './features/editor-actions';",
                "import GridSnappingModule from './features/grid-snapping';",
                "import InteractionEventsModule from './features/interaction-events';",
                "import KeyboardModule from './features/keyboard';",
                "import KeyboardMoveSelectionModule from 'diagram-js/lib/features/keyboard-move-selection';",
                "import LabelEditingModule from './features/label-editing';",
                "import ModelingModule from './features/modeling';",
                "import ModelingFeedbackModule from './features/modeling-feedback';",
                "import MoveModule from 'diagram-js/lib/features/move';",
                "import OutlineModule from './features/outline';",
                "import PaletteModule from './features/palette';",
                "import ReplacePreviewModule from './features/replace-preview';",
                "import ResizeModule from 'diagram-js/lib/features/resize';",
                "import SnappingModule from './features/snapping';",
                "import SearchModule from './features/search';",
                "",
                "var initialDiagram =",
                "  '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +",
                "  '<bpmn:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ' +",
                "                    'xmlns:bpmn=\"http://www.omg.org/spec/BPMN/20100524/MODEL\" ' +",
                "                    'xmlns:bpmndi=\"http://www.omg.org/spec/BPMN/20100524/DI\" ' +",
                "                    'xmlns:dc=\"http://www.omg.org/spec/DD/20100524/DC\" ' +",
                "                    'targetNamespace=\"http://bpmn.io/schema/bpmn\" ' +",
                "                    'id=\"Definitions_1\">' +",
                "    '<bpmn:process id=\"Process_1\" isExecutable=\"false\">' +",
                "      '<bpmn:startEvent id=\"StartEvent_1\"/>' +",
                "    '</bpmn:process>' +",
                "    '<bpmndi:BPMNDiagram id=\"BPMNDiagram_1\">' +",
                "      '<bpmndi:BPMNPlane id=\"BPMNPlane_1\" bpmnElement=\"Process_1\">' +",
                "        '<bpmndi:BPMNShape id=\"_BPMNShape_StartEvent_2\" bpmnElement=\"StartEvent_1\">' +",
                "          '<dc:Bounds height=\"36.0\" width=\"36.0\" x=\"173.0\" y=\"102.0\"/>' +",
                "        '</bpmndi:BPMNShape>' +",
                "      '</bpmndi:BPMNPlane>' +",
                "    '</bpmndi:BPMNDiagram>' +",
                "  '</bpmn:definitions>';",
                "",
                "",
                "/**",
                " * @typedef {import('./BaseViewer').BaseViewerOptions} BaseViewerOptions",
                " * @typedef {import('./BaseViewer').ImportXMLResult} ImportXMLResult",
                " */",
                "",
                "/**",
                " * A modeler for BPMN 2.0 diagrams.",
                " *",
                " *",
                " * ## Extending the Modeler",
                " *",
                " * In order to extend the viewer pass extension modules to bootstrap via the",
                " * `additionalModules` option. An extension module is an object that exposes",
                " * named services.",
                " *",
                " * The following example depicts the integration of a simple",
                " * logging component that integrates with interaction events:",
                " *",
                " *",
                " * ```javascript",
                " *",
                " * // logging component",
                " * function InteractionLogger(eventBus) {",
                " *   eventBus.on('element.hover', function(event) {",
                " *     console.log()",
                " *   })",
                " * }",
                " *",
                " * InteractionLogger.$inject = [ 'eventBus' ]; // minification save",
                " *",
                " * // extension module",
                " * var extensionModule = {",
                " *   __init__: [ 'interactionLogger' ],",
                " *   interactionLogger: [ 'type', InteractionLogger ]",
                " * };",
                " *",
                " * // extend the viewer",
                " * var bpmnModeler = new Modeler({ additionalModules: [ extensionModule ] });",
                " * bpmnModeler.importXML(...);",
                " * ```",
                " *",
                " *",
                " * ## Customizing / Replacing Components",
                " *",
                " * You can replace individual diagram components by redefining them in override modules.",
                " * This works for all components, including those defined in the core.",
                " *",
                " * Pass in override modules via the `options.additionalModules` flag like this:",
                " *",
                " * ```javascript",
                " * function CustomContextPadProvider(contextPad) {",
                " *",
                " *   contextPad.registerProvider(this);",
                " *",
                " *   this.getContextPadEntries = function(element) {",
                " *     // no entries, effectively disable the context pad",
                " *     return {};",
                " *   };",
                " * }",
                " *",
                " * CustomContextPadProvider.$inject = [ 'contextPad' ];",
                " *",
                " * var overrideModule = {",
                " *   contextPadProvider: [ 'type', CustomContextPadProvider ]",
                " * };",
                " *",
                " * var bpmnModeler = new Modeler({ additionalModules: [ overrideModule ]});",
                " * ```",
                " *",
                " * @param {BaseViewerOptions} [options] The options to configure the modeler.",
                " */",
                "export default function Modeler(options) {",
                "  BaseModeler.call(this, options);",
                "}",
                "",
                "inherits(Modeler, BaseModeler);",
                "",
                "",
                "Modeler.Viewer = Viewer;",
                "Modeler.NavigatedViewer = NavigatedViewer;",
                "",
                "/**",
                " * Create a new diagram to start modeling.",
                " *",
                " * @throws {ImportXMLError} An error thrown during the import of the XML.",
                " *",
                " * @return {Promise<ImportXMLResult>} A promise resolving with warnings that were produced during the import.",
                " */",
                "Modeler.prototype.createDiagram = function createDiagram() {",
                "  return this.importXML(initialDiagram);",
                "};",
                "",
                "",
                "Modeler.prototype._interactionModules = [",
                "",
                "  // non-modeling components",
                "  KeyboardMoveModule,",
                "  MoveCanvasModule,",
                "  TouchModule,",
                "  ZoomScrollModule",
                "];",
                "",
                "Modeler.prototype._modelingModules = [",
                "",
                "  // modeling components",
                "  AlignElementsModule,",
                "  AutoPlaceModule,",
                "  AutoScrollModule,",
                "  AutoResizeModule,",
                "  BendpointsModule,",
                "  ConnectModule,",
                "  ConnectionPreviewModule,",
                "  ContextPadModule,",
                "  CopyPasteModule,",
                "  CreateModule,",
                "  DistributeElementsModule,",
                "  EditorActionsModule,",
                "  GridSnappingModule,",
                "  InteractionEventsModule,",
                "  KeyboardModule,",
                "  KeyboardMoveSelectionModule,",
                "  LabelEditingModule,",
                "  ModelingModule,",
                "  ModelingFeedbackModule,",
                "  MoveModule,",
                "  OutlineModule,",
                "  PaletteModule,",
                "  ReplacePreviewModule,",
                "  ResizeModule,",
                "  SnappingModule,",
                "  SearchModule",
                "];",
                "",
                "",
                "// modules the modeler is composed of",
                "//",
                "// - viewer modules",
                "// - interaction modules",
                "// - modeling modules",
                "",
                "Modeler.prototype._modules = [].concat(",
                "  Viewer.prototype._modules,",
                "  Modeler.prototype._interactionModules,",
                "  Modeler.prototype._modelingModules",
                ");"
            ]
        },
        "Modeler.spec.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "import Modeler from './Modeler';",
                "",
                "import { testViewer } from './BaseViewer.spec';",
                "",
                "const modeler = new Modeler({",
                "  container: 'container'",
                "});",
                "",
                "testViewer(modeler);",
                "",
                "modeler.createDiagram();",
                "",
                "",
                "const otherModeler = new Modeler({",
                "  container: 'container'",
                "});",
                "",
                "const extendedModeler = new Modeler({",
                "  container: 'container',",
                "  alignToOrigin: false,",
                "  propertiesPanel: {",
                "    attachTo: '#properties-panel'",
                "  }",
                "});"
            ]
        },
        "NavigatedViewer.js": {
            "classes": [],
            "functions": [],
            "text": [
                "import inherits from 'inherits-browser';",
                "",
                "import Viewer from './Viewer';",
                "",
                "import KeyboardMoveModule from 'diagram-js/lib/navigation/keyboard-move';",
                "import MoveCanvasModule from 'diagram-js/lib/navigation/movecanvas';",
                "import ZoomScrollModule from 'diagram-js/lib/navigation/zoomscroll';",
                "",
                "/**",
                " * @typedef { import('./BaseViewer').BaseViewerOptions } BaseViewerOptions",
                " */",
                "",
                "/**",
                " * A viewer with mouse and keyboard navigation features.",
                " *",
                " * @param {BaseViewerOptions} [options]",
                " */",
                "export default function NavigatedViewer(options) {",
                "  Viewer.call(this, options);",
                "}",
                "",
                "inherits(NavigatedViewer, Viewer);",
                "",
                "",
                "NavigatedViewer.prototype._navigationModules = [",
                "  KeyboardMoveModule,",
                "  MoveCanvasModule,",
                "  ZoomScrollModule",
                "];",
                "",
                "NavigatedViewer.prototype._modules = [].concat(",
                "  Viewer.prototype._modules,",
                "  NavigatedViewer.prototype._navigationModules",
                ");"
            ]
        },
        "NavigatedViewer.spec.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "import NavigatedViewer from './NavigatedViewer';",
                "",
                "import { testViewer } from './BaseViewer.spec';",
                "",
                "const viewer = new NavigatedViewer({",
                "  container: 'container'",
                "});",
                "",
                "testViewer(viewer);",
                "",
                "const extendedViewer = new NavigatedViewer({",
                "  container: 'container',",
                "  alignToOrigin: false,",
                "  propertiesPanel: {",
                "    attachTo: '#properties-panel'",
                "  }",
                "});"
            ]
        },
        "Viewer.js": {
            "classes": [],
            "functions": [],
            "text": [
                "import inherits from 'inherits-browser';",
                "",
                "import CoreModule from './core';",
                "import TranslateModule from 'diagram-js/lib/i18n/translate';",
                "import SelectionModule from 'diagram-js/lib/features/selection';",
                "import OverlaysModule from 'diagram-js/lib/features/overlays';",
                "import DrilldownModdule from './features/drilldown';",
                "",
                "import BaseViewer from './BaseViewer';",
                "",
                "",
                "/**",
                " * @typedef { import('./BaseViewer').BaseViewerOptions } BaseViewerOptions",
                " */",
                "",
                "/**",
                " * A viewer for BPMN 2.0 diagrams.",
                " *",
                " * Have a look at {@link NavigatedViewer} or {@link Modeler} for bundles that include",
                " * additional features.",
                " *",
                " *",
                " * ## Extending the Viewer",
                " *",
                " * In order to extend the viewer pass extension modules to bootstrap via the",
                " * `additionalModules` option. An extension module is an object that exposes",
                " * named services.",
                " *",
                " * The following example depicts the integration of a simple",
                " * logging component that integrates with interaction events:",
                " *",
                " *",
                " * ```javascript",
                " *",
                " * // logging component",
                " * function InteractionLogger(eventBus) {",
                " *   eventBus.on('element.hover', function(event) {",
                " *     console.log()",
                " *   })",
                " * }",
                " *",
                " * InteractionLogger.$inject = [ 'eventBus' ]; // minification save",
                " *",
                " * // extension module",
                " * var extensionModule = {",
                " *   __init__: [ 'interactionLogger' ],",
                " *   interactionLogger: [ 'type', InteractionLogger ]",
                " * };",
                " *",
                " * // extend the viewer",
                " * var bpmnViewer = new Viewer({ additionalModules: [ extensionModule ] });",
                " * bpmnViewer.importXML(...);",
                " * ```",
                " *",
                " * @param {BaseViewerOptions} [options] The options to configure the viewer.",
                " */",
                "export default function Viewer(options) {",
                "  BaseViewer.call(this, options);",
                "}",
                "",
                "inherits(Viewer, BaseViewer);",
                "",
                "// modules the viewer is composed of",
                "Viewer.prototype._modules = [",
                "  CoreModule,",
                "  TranslateModule,",
                "  SelectionModule,",
                "  OverlaysModule,",
                "  DrilldownModdule",
                "];",
                "",
                "// default moddle extensions the viewer is composed of",
                "Viewer.prototype._moddleExtensions = {};"
            ]
        },
        "Viewer.spec.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "import Viewer from './Viewer';",
                "",
                "import { testViewer } from './BaseViewer.spec';",
                "",
                "const viewer = new Viewer({",
                "  container: 'container'",
                "});",
                "",
                "testViewer(viewer);",
                "",
                "const extendedViewer = new Viewer({",
                "  container: 'container',",
                "  alignToOrigin: false,",
                "  propertiesPanel: {",
                "    attachTo: '#properties-panel'",
                "  }",
                "});"
            ]
        },
        "core": {
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import DrawModule from '../draw';",
                    "import ImportModule from '../import';",
                    "",
                    "export default {",
                    "  __depends__: [",
                    "    DrawModule,",
                    "    ImportModule",
                    "  ]",
                    "};"
                ]
            }
        },
        "draw": {
            "BpmnRenderUtil.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  has,",
                    "  some",
                    "} from 'min-dash';",
                    "",
                    "import {",
                    "  getDi",
                    "} from '../util/ModelUtil';",
                    "",
                    "import {",
                    "  componentsToPath",
                    "} from 'diagram-js/lib/util/RenderUtil';",
                    "",
                    "",
                    "/**",
                    " * @typedef {import('../model').ModdleElement} ModdleElement",
                    " * @typedef {import('../model').Element} Element",
                    " *",
                    " * @typedef {import('../model').ShapeLike} ShapeLike",
                    " *",
                    " * @typedef {import('diagram-js/lib/util/Types').Dimensions} Dimensions",
                    " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                    " */",
                    "",
                    "// re-export for compatibility",
                    "export {",
                    "  getDi,",
                    "  getBusinessObject as getSemantic",
                    "} from '../util/ModelUtil';",
                    "",
                    "",
                    "export var black = 'hsl(225, 10%, 15%)';",
                    "export var white = 'white';",
                    "",
                    "// element utils //////////////////////",
                    "",
                    "/**",
                    " * Checks if eventDefinition of the given element matches with semantic type.",
                    " *",
                    " * @param {ModdleElement} event",
                    " * @param {string} eventDefinitionType",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isTypedEvent(event, eventDefinitionType) {",
                    "  return some(event.eventDefinitions, function(definition) {",
                    "    return definition.$type === eventDefinitionType;",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * Check if element is a throw event.",
                    " *",
                    " * @param {ModdleElement} event",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isThrowEvent(event) {",
                    "  return (event.$type === 'bpmn:IntermediateThrowEvent') || (event.$type === 'bpmn:EndEvent');",
                    "}",
                    "",
                    "/**",
                    " * Check if element is a throw event.",
                    " *",
                    " * @param {ModdleElement} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isCollection(element) {",
                    "  var dataObject = element.dataObjectRef;",
                    "",
                    "  return element.isCollection || (dataObject && dataObject.isCollection);",
                    "}",
                    "",
                    "",
                    "// color access //////////////////////",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " * @param {string} [defaultColor]",
                    " * @param {string} [overrideColor]",
                    " *",
                    " * @return {string}",
                    " */",
                    "export function getFillColor(element, defaultColor, overrideColor) {",
                    "  var di = getDi(element);",
                    "",
                    "  return overrideColor || di.get('color:background-color') || di.get('bioc:fill') || defaultColor || white;",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " * @param {string} [defaultColor]",
                    " * @param {string} [overrideColor]",
                    " *",
                    " * @return {string}",
                    " */",
                    "export function getStrokeColor(element, defaultColor, overrideColor) {",
                    "  var di = getDi(element);",
                    "",
                    "  return overrideColor || di.get('color:border-color') || di.get('bioc:stroke') || defaultColor || black;",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " * @param {string} [defaultColor]",
                    " * @param {string} [defaultStrokeColor]",
                    " * @param {string} [overrideColor]",
                    " *",
                    " * @return {string}",
                    " */",
                    "export function getLabelColor(element, defaultColor, defaultStrokeColor, overrideColor) {",
                    "  var di = getDi(element),",
                    "      label = di.get('label');",
                    "",
                    "  return overrideColor || (label && label.get('color:color')) || defaultColor ||",
                    "    getStrokeColor(element, defaultStrokeColor);",
                    "}",
                    "",
                    "// cropping path customizations //////////////////////",
                    "",
                    "/**",
                    " * @param {ShapeLike} shape",
                    " *",
                    " * @return {string} path",
                    " */",
                    "export function getCirclePath(shape) {",
                    "",
                    "  var cx = shape.x + shape.width / 2,",
                    "      cy = shape.y + shape.height / 2,",
                    "      radius = shape.width / 2;",
                    "",
                    "  var circlePath = [",
                    "    [ 'M', cx, cy ],",
                    "    [ 'm', 0, -radius ],",
                    "    [ 'a', radius, radius, 0, 1, 1, 0, 2 * radius ],",
                    "    [ 'a', radius, radius, 0, 1, 1, 0, -2 * radius ],",
                    "    [ 'z' ]",
                    "  ];",
                    "",
                    "  return componentsToPath(circlePath);",
                    "}",
                    "",
                    "/**",
                    " * @param {ShapeLike} shape",
                    " * @param {number} [borderRadius]",
                    " *",
                    " * @return {string} path",
                    " */",
                    "export function getRoundRectPath(shape, borderRadius) {",
                    "",
                    "  var x = shape.x,",
                    "      y = shape.y,",
                    "      width = shape.width,",
                    "      height = shape.height;",
                    "",
                    "  var roundRectPath = [",
                    "    [ 'M', x + borderRadius, y ],",
                    "    [ 'l', width - borderRadius * 2, 0 ],",
                    "    [ 'a', borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius ],",
                    "    [ 'l', 0, height - borderRadius * 2 ],",
                    "    [ 'a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius ],",
                    "    [ 'l', borderRadius * 2 - width, 0 ],",
                    "    [ 'a', borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius ],",
                    "    [ 'l', 0, borderRadius * 2 - height ],",
                    "    [ 'a', borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius ],",
                    "    [ 'z' ]",
                    "  ];",
                    "",
                    "  return componentsToPath(roundRectPath);",
                    "}",
                    "",
                    "/**",
                    " * @param {ShapeLike} shape",
                    " *",
                    " * @return {string} path",
                    " */",
                    "export function getDiamondPath(shape) {",
                    "",
                    "  var width = shape.width,",
                    "      height = shape.height,",
                    "      x = shape.x,",
                    "      y = shape.y,",
                    "      halfWidth = width / 2,",
                    "      halfHeight = height / 2;",
                    "",
                    "  var diamondPath = [",
                    "    [ 'M', x + halfWidth, y ],",
                    "    [ 'l', halfWidth, halfHeight ],",
                    "    [ 'l', -halfWidth, halfHeight ],",
                    "    [ 'l', -halfWidth, -halfHeight ],",
                    "    [ 'z' ]",
                    "  ];",
                    "",
                    "  return componentsToPath(diamondPath);",
                    "}",
                    "",
                    "/**",
                    " * @param {ShapeLike} shape",
                    " *",
                    " * @return {string} path",
                    " */",
                    "export function getRectPath(shape) {",
                    "  var x = shape.x,",
                    "      y = shape.y,",
                    "      width = shape.width,",
                    "      height = shape.height;",
                    "",
                    "  var rectPath = [",
                    "    [ 'M', x, y ],",
                    "    [ 'l', width, 0 ],",
                    "    [ 'l', 0, height ],",
                    "    [ 'l', -width, 0 ],",
                    "    [ 'z' ]",
                    "  ];",
                    "",
                    "  return componentsToPath(rectPath);",
                    "}",
                    "",
                    "/**",
                    " * Get width and height from element or overrides.",
                    " *",
                    " * @param {Dimensions|Rect|ShapeLike} bounds",
                    " * @param {Object} overrides",
                    " *",
                    " * @returns {Dimensions}",
                    " */",
                    "export function getBounds(bounds, overrides = {}) {",
                    "  return {",
                    "    width: getWidth(bounds, overrides),",
                    "    height: getHeight(bounds, overrides)",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * Get width from element or overrides.",
                    " *",
                    " * @param {Dimensions|Rect|ShapeLike} bounds",
                    " * @param {Object} overrides",
                    " *",
                    " * @returns {number}",
                    " */",
                    "export function getWidth(bounds, overrides = {}) {",
                    "  return has(overrides, 'width') ? overrides.width : bounds.width;",
                    "}",
                    "",
                    "/**",
                    " * Get height from element or overrides.",
                    " *",
                    " * @param {Dimensions|Rect|ShapeLike} bounds",
                    " * @param {Object} overrides",
                    " *",
                    " * @returns {number}",
                    " */",
                    "export function getHeight(bounds, overrides = {}) {",
                    "  return has(overrides, 'height') ? overrides.height : bounds.height;",
                    "}"
                ]
            },
            "BpmnRenderer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import inherits from 'inherits-browser';",
                    "",
                    "import {",
                    "  assign,",
                    "  forEach,",
                    "  isObject",
                    "} from 'min-dash';",
                    "",
                    "import BaseRenderer from 'diagram-js/lib/draw/BaseRenderer';",
                    "",
                    "import {",
                    "  isExpanded,",
                    "  isEventSubProcess",
                    "} from '../util/DiUtil';",
                    "",
                    "import {",
                    "  getLabel",
                    "} from '../util/LabelUtil';",
                    "",
                    "import {",
                    "  is",
                    "} from '../util/ModelUtil';",
                    "",
                    "import {",
                    "  createLine",
                    "} from 'diagram-js/lib/util/RenderUtil';",
                    "",
                    "import {",
                    "  isTypedEvent,",
                    "  isThrowEvent,",
                    "  isCollection,",
                    "  getBounds,",
                    "  getDi,",
                    "  getSemantic,",
                    "  getCirclePath,",
                    "  getRoundRectPath,",
                    "  getDiamondPath,",
                    "  getRectPath,",
                    "  getFillColor,",
                    "  getStrokeColor,",
                    "  getLabelColor,",
                    "  getHeight,",
                    "  getWidth",
                    "} from './BpmnRenderUtil';",
                    "",
                    "import {",
                    "  query as domQuery",
                    "} from 'min-dom';",
                    "",
                    "import {",
                    "  append as svgAppend,",
                    "  attr as svgAttr,",
                    "  create as svgCreate,",
                    "  classes as svgClasses",
                    "} from 'tiny-svg';",
                    "",
                    "import {",
                    "  rotate,",
                    "  transform,",
                    "  translate",
                    "} from 'diagram-js/lib/util/SvgTransformUtil';",
                    "",
                    "import Ids from 'ids';",
                    "",
                    "import { black } from './BpmnRenderUtil';",
                    "",
                    "var rendererIds = new Ids();",
                    "",
                    "var ELEMENT_LABEL_DISTANCE = 10,",
                    "    INNER_OUTER_DIST = 3,",
                    "    PARTICIPANT_STROKE_WIDTH = 1.5,",
                    "    TASK_BORDER_RADIUS = 10;",
                    "",
                    "var DEFAULT_OPACITY = 0.95,",
                    "    FULL_OPACITY = 1,",
                    "    LOW_OPACITY = 0.25;",
                    "",
                    "/**",
                    " * @typedef { Partial<{",
                    " *   defaultFillColor: string,",
                    " *   defaultStrokeColor: string,",
                    " *   defaultLabelColor: string",
                    " * }> } BpmnRendererConfig",
                    " *",
                    " * @typedef { Partial<{",
                    " *   fill: string,",
                    " *   stroke: string,",
                    " *   width: string,",
                    " *   height: string",
                    " * }> } Attrs",
                    " */",
                    "",
                    "/**",
                    " * @typedef { import('../model/Types').Element } Element",
                    " */",
                    "",
                    "/**",
                    " * A renderer for BPMN elements",
                    " *",
                    " * @param {BpmnRendererConfig} config",
                    " * @param {import('diagram-js/lib/core/EventBus').default} eventBus",
                    " * @param {import('diagram-js/lib/draw/Styles').default} styles",
                    " * @param {import('./PathMap').default} pathMap",
                    " * @param {import('diagram-js/lib/core/Canvas').default} canvas",
                    " * @param {import('./TextRenderer').default} textRenderer",
                    " * @param {number} [priority]",
                    " */",
                    "export default function BpmnRenderer(",
                    "    config, eventBus, styles, pathMap,",
                    "    canvas, textRenderer, priority) {",
                    "",
                    "  BaseRenderer.call(this, eventBus, priority);",
                    "",
                    "  var defaultFillColor = config && config.defaultFillColor,",
                    "      defaultStrokeColor = config && config.defaultStrokeColor,",
                    "      defaultLabelColor = config && config.defaultLabelColor;",
                    "",
                    "  var rendererId = rendererIds.next();",
                    "",
                    "  var markers = {};",
                    "",
                    "  function shapeStyle(attrs) {",
                    "    return styles.computeStyle(attrs, {",
                    "      strokeLinecap: 'round',",
                    "      strokeLinejoin: 'round',",
                    "      stroke: black,",
                    "      strokeWidth: 2,",
                    "      fill: 'white'",
                    "    });",
                    "  }",
                    "",
                    "  function lineStyle(attrs) {",
                    "    return styles.computeStyle(attrs, [ 'no-fill' ], {",
                    "      strokeLinecap: 'round',",
                    "      strokeLinejoin: 'round',",
                    "      stroke: black,",
                    "      strokeWidth: 2",
                    "    });",
                    "  }",
                    "",
                    "  function addMarker(id, options) {",
                    "    var {",
                    "      ref = { x: 0, y: 0 },",
                    "      scale = 1,",
                    "      element",
                    "    } = options;",
                    "",
                    "    var marker = svgCreate('marker', {",
                    "      id: id,",
                    "      viewBox: '0 0 20 20',",
                    "      refX: ref.x,",
                    "      refY: ref.y,",
                    "      markerWidth: 20 * scale,",
                    "      markerHeight: 20 * scale,",
                    "      orient: 'auto'",
                    "    });",
                    "",
                    "    svgAppend(marker, element);",
                    "",
                    "    var defs = domQuery('defs', canvas._svg);",
                    "",
                    "    if (!defs) {",
                    "      defs = svgCreate('defs');",
                    "",
                    "      svgAppend(canvas._svg, defs);",
                    "    }",
                    "",
                    "    svgAppend(defs, marker);",
                    "",
                    "    markers[id] = marker;",
                    "  }",
                    "",
                    "  function colorEscape(str) {",
                    "",
                    "    // only allow characters and numbers",
                    "    return str.replace(/[^0-9a-zA-Z]+/g, '_');",
                    "  }",
                    "",
                    "  function marker(type, fill, stroke) {",
                    "    var id = type + '-' + colorEscape(fill) + '-' + colorEscape(stroke) + '-' + rendererId;",
                    "",
                    "    if (!markers[id]) {",
                    "      createMarker(id, type, fill, stroke);",
                    "    }",
                    "",
                    "    return 'url(#' + id + ')';",
                    "  }",
                    "",
                    "  function createMarker(id, type, fill, stroke) {",
                    "",
                    "    if (type === 'sequenceflow-end') {",
                    "      var sequenceflowEnd = svgCreate('path', {",
                    "        d: 'M 1 5 L 11 10 L 1 15 Z',",
                    "        ...shapeStyle({",
                    "          fill: stroke,",
                    "          stroke: stroke,",
                    "          strokeWidth: 1",
                    "        })",
                    "      });",
                    "",
                    "      addMarker(id, {",
                    "        element: sequenceflowEnd,",
                    "        ref: { x: 11, y: 10 },",
                    "        scale: 0.5",
                    "      });",
                    "    }",
                    "",
                    "    if (type === 'messageflow-start') {",
                    "      var messageflowStart = svgCreate('circle', {",
                    "        cx: 6,",
                    "        cy: 6,",
                    "        r: 3.5,",
                    "        ...shapeStyle({",
                    "          fill,",
                    "          stroke: stroke,",
                    "          strokeWidth: 1,",
                    "",
                    "          // fix for safari / chrome / firefox bug not correctly",
                    "          // resetting stroke dash array",
                    "          strokeDasharray: [ 10000, 1 ]",
                    "        })",
                    "      });",
                    "",
                    "      addMarker(id, {",
                    "        element: messageflowStart,",
                    "        ref: { x: 6, y: 6 }",
                    "      });",
                    "    }",
                    "",
                    "    if (type === 'messageflow-end') {",
                    "      var messageflowEnd = svgCreate('path', {",
                    "        d: 'm 1 5 l 0 -3 l 7 3 l -7 3 z',",
                    "        ...shapeStyle({",
                    "          fill,",
                    "          stroke: stroke,",
                    "          strokeWidth: 1,",
                    "",
                    "          // fix for safari / chrome / firefox bug not correctly",
                    "          // resetting stroke dash array",
                    "          strokeDasharray: [ 10000, 1 ]",
                    "        })",
                    "      });",
                    "",
                    "      addMarker(id, {",
                    "        element: messageflowEnd,",
                    "        ref: { x: 8.5, y: 5 }",
                    "      });",
                    "    }",
                    "",
                    "    if (type === 'association-start') {",
                    "      var associationStart = svgCreate('path', {",
                    "        d: 'M 11 5 L 1 10 L 11 15',",
                    "        ...lineStyle({",
                    "          fill: 'none',",
                    "          stroke,",
                    "          strokeWidth: 1.5,",
                    "",
                    "          // fix for safari / chrome / firefox bug not correctly",
                    "          // resetting stroke dash array",
                    "          strokeDasharray: [ 10000, 1 ]",
                    "        })",
                    "      });",
                    "",
                    "      addMarker(id, {",
                    "        element: associationStart,",
                    "        ref: { x: 1, y: 10 },",
                    "        scale: 0.5",
                    "      });",
                    "    }",
                    "",
                    "    if (type === 'association-end') {",
                    "      var associationEnd = svgCreate('path', {",
                    "        d: 'M 1 5 L 11 10 L 1 15',",
                    "        ...lineStyle({",
                    "          fill: 'none',",
                    "          stroke,",
                    "          strokeWidth: 1.5,",
                    "",
                    "          // fix for safari / chrome / firefox bug not correctly",
                    "          // resetting stroke dash array",
                    "          strokeDasharray: [ 10000, 1 ]",
                    "        })",
                    "      });",
                    "",
                    "      addMarker(id, {",
                    "        element: associationEnd,",
                    "        ref: { x: 11, y: 10 },",
                    "        scale: 0.5",
                    "      });",
                    "    }",
                    "",
                    "    if (type === 'conditional-flow-marker') {",
                    "      var conditionalFlowMarker = svgCreate('path', {",
                    "        d: 'M 0 10 L 8 6 L 16 10 L 8 14 Z',",
                    "        ...shapeStyle({",
                    "          fill,",
                    "          stroke: stroke",
                    "        })",
                    "      });",
                    "",
                    "      addMarker(id, {",
                    "        element: conditionalFlowMarker,",
                    "        ref: { x: -1, y: 10 },",
                    "        scale: 0.5",
                    "      });",
                    "    }",
                    "",
                    "    if (type === 'conditional-default-flow-marker') {",
                    "      var defaultFlowMarker = svgCreate('path', {",
                    "        d: 'M 6 4 L 10 16',",
                    "        ...shapeStyle({",
                    "          stroke: stroke",
                    "        })",
                    "      });",
                    "",
                    "      addMarker(id, {",
                    "        element: defaultFlowMarker,",
                    "        ref: { x: 0, y: 10 },",
                    "        scale: 0.5",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  function drawCircle(parentGfx, width, height, offset, attrs = {}) {",
                    "",
                    "    if (isObject(offset)) {",
                    "      attrs = offset;",
                    "      offset = 0;",
                    "    }",
                    "",
                    "    offset = offset || 0;",
                    "",
                    "    attrs = shapeStyle(attrs);",
                    "",
                    "    var cx = width / 2,",
                    "        cy = height / 2;",
                    "",
                    "    var circle = svgCreate('circle', {",
                    "      cx: cx,",
                    "      cy: cy,",
                    "      r: Math.round((width + height) / 4 - offset),",
                    "      ...attrs",
                    "    });",
                    "",
                    "    svgAppend(parentGfx, circle);",
                    "",
                    "    return circle;",
                    "  }",
                    "",
                    "  function drawRect(parentGfx, width, height, r, offset, attrs) {",
                    "",
                    "    if (isObject(offset)) {",
                    "      attrs = offset;",
                    "      offset = 0;",
                    "    }",
                    "",
                    "    offset = offset || 0;",
                    "",
                    "    attrs = shapeStyle(attrs);",
                    "",
                    "    var rect = svgCreate('rect', {",
                    "      x: offset,",
                    "      y: offset,",
                    "      width: width - offset * 2,",
                    "      height: height - offset * 2,",
                    "      rx: r,",
                    "      ry: r,",
                    "      ...attrs",
                    "    });",
                    "",
                    "    svgAppend(parentGfx, rect);",
                    "",
                    "    return rect;",
                    "  }",
                    "",
                    "  function drawDiamond(parentGfx, width, height, attrs) {",
                    "",
                    "    var x_2 = width / 2;",
                    "    var y_2 = height / 2;",
                    "",
                    "    var points = [",
                    "      { x: x_2, y: 0 },",
                    "      { x: width, y: y_2 },",
                    "      { x: x_2, y: height },",
                    "      { x: 0, y: y_2 }",
                    "    ];",
                    "",
                    "    var pointsString = points.map(function(point) {",
                    "      return point.x + ',' + point.y;",
                    "    }).join(' ');",
                    "",
                    "    attrs = shapeStyle(attrs);",
                    "",
                    "    var polygon = svgCreate('polygon', {",
                    "      ...attrs,",
                    "      points: pointsString",
                    "    });",
                    "",
                    "    svgAppend(parentGfx, polygon);",
                    "",
                    "    return polygon;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {SVGElement} parentGfx",
                    "   * @param {Point[]} waypoints",
                    "   * @param {any} attrs",
                    "   * @param {number} [radius]",
                    "   *",
                    "   * @return {SVGElement}",
                    "   */",
                    "  function drawLine(parentGfx, waypoints, attrs, radius) {",
                    "    attrs = lineStyle(attrs);",
                    "",
                    "    var line = createLine(waypoints, attrs, radius);",
                    "",
                    "    svgAppend(parentGfx, line);",
                    "",
                    "    return line;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {SVGElement} parentGfx",
                    "   * @param {Point[]} waypoints",
                    "   * @param {any} attrs",
                    "   *",
                    "   * @return {SVGElement}",
                    "   */",
                    "  function drawConnectionSegments(parentGfx, waypoints, attrs) {",
                    "    return drawLine(parentGfx, waypoints, attrs, 5);",
                    "  }",
                    "",
                    "  function drawPath(parentGfx, d, attrs) {",
                    "    attrs = lineStyle(attrs);",
                    "",
                    "    var path = svgCreate('path', {",
                    "      ...attrs,",
                    "      d",
                    "    });",
                    "",
                    "    svgAppend(parentGfx, path);",
                    "",
                    "    return path;",
                    "  }",
                    "",
                    "  function drawMarker(type, parentGfx, path, attrs) {",
                    "    return drawPath(parentGfx, path, assign({ 'data-marker': type }, attrs));",
                    "  }",
                    "",
                    "  function renderer(type) {",
                    "    return handlers[type];",
                    "  }",
                    "",
                    "  function as(type) {",
                    "    return function(parentGfx, element, attrs) {",
                    "      return renderer(type)(parentGfx, element, attrs);",
                    "    };",
                    "  }",
                    "",
                    "  var eventIconRenderers = {",
                    "    'bpmn:MessageEventDefinition': function(parentGfx, element, attrs = {}, isThrowing) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_MESSAGE', {",
                    "        xScaleFactor: 0.9,",
                    "        yScaleFactor: 0.9,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: 0.235,",
                    "          my: 0.315",
                    "        }",
                    "      });",
                    "",
                    "      var fill = isThrowing",
                    "        ? getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "        : getFillColor(element, defaultFillColor, attrs.fill);",
                    "",
                    "      var stroke = isThrowing",
                    "        ? getFillColor(element, defaultFillColor, attrs.fill)",
                    "        : getStrokeColor(element, defaultStrokeColor, attrs.stroke);",
                    "",
                    "      var messagePath = drawPath(parentGfx, pathData, {",
                    "        fill,",
                    "        stroke,",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return messagePath;",
                    "    },",
                    "    'bpmn:TimerEventDefinition': function(parentGfx, element, attrs = {}) {",
                    "      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 2",
                    "      });",
                    "",
                    "      var pathData = pathMap.getScaledPath('EVENT_TIMER_WH', {",
                    "        xScaleFactor: 0.75,",
                    "        yScaleFactor: 0.75,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: 0.5,",
                    "          my: 0.5",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathData, {",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 2",
                    "      });",
                    "",
                    "      for (var i = 0; i < 12; i++) {",
                    "        var linePathData = pathMap.getScaledPath('EVENT_TIMER_LINE', {",
                    "          xScaleFactor: 0.75,",
                    "          yScaleFactor: 0.75,",
                    "          containerWidth: element.width,",
                    "          containerHeight: element.height,",
                    "          position: {",
                    "            mx: 0.5,",
                    "            my: 0.5",
                    "          }",
                    "        });",
                    "",
                    "        var width = element.width / 2,",
                    "            height = element.height / 2;",
                    "",
                    "        drawPath(parentGfx, linePathData, {",
                    "          strokeWidth: 1,",
                    "          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "          transform: 'rotate(' + (i * 30) + ',' + height + ',' + width + ')'",
                    "        });",
                    "      }",
                    "",
                    "      return circle;",
                    "    },",
                    "    'bpmn:EscalationEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_ESCALATION', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.5,",
                    "          my: 0.2",
                    "        }",
                    "      });",
                    "",
                    "      var fill = isThrowing",
                    "        ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)",
                    "        : getFillColor(event, defaultFillColor, attrs.fill);",
                    "",
                    "      return drawPath(parentGfx, pathData, {",
                    "        fill,",
                    "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "    },",
                    "    'bpmn:ConditionalEventDefinition': function(parentGfx, event, attrs = {}) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_CONDITIONAL', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.5,",
                    "          my: 0.222",
                    "        }",
                    "      });",
                    "",
                    "      return drawPath(parentGfx, pathData, {",
                    "        fill: getFillColor(event, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "    },",
                    "    'bpmn:LinkEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_LINK', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.57,",
                    "          my: 0.263",
                    "        }",
                    "      });",
                    "",
                    "      var fill = isThrowing",
                    "        ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)",
                    "        : getFillColor(event, defaultFillColor, attrs.fill);",
                    "",
                    "      return drawPath(parentGfx, pathData, {",
                    "        fill,",
                    "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "    },",
                    "    'bpmn:ErrorEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_ERROR', {",
                    "        xScaleFactor: 1.1,",
                    "        yScaleFactor: 1.1,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.2,",
                    "          my: 0.722",
                    "        }",
                    "      });",
                    "",
                    "      var fill = isThrowing",
                    "        ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)",
                    "        : getFillColor(event, defaultFillColor, attrs.fill);",
                    "",
                    "      return drawPath(parentGfx, pathData, {",
                    "        fill,",
                    "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "    },",
                    "    'bpmn:CancelEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_CANCEL_45', {",
                    "        xScaleFactor: 1.0,",
                    "        yScaleFactor: 1.0,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.638,",
                    "          my: -0.055",
                    "        }",
                    "      });",
                    "",
                    "      var fill = isThrowing ? getStrokeColor(event, defaultStrokeColor, attrs.stroke) : 'none';",
                    "",
                    "      var path = drawPath(parentGfx, pathData, {",
                    "        fill,",
                    "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      rotate(path, 45);",
                    "",
                    "      return path;",
                    "    },",
                    "    'bpmn:CompensateEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_COMPENSATION', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.22,",
                    "          my: 0.5",
                    "        }",
                    "      });",
                    "",
                    "      var fill = isThrowing",
                    "        ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)",
                    "        : getFillColor(event, defaultFillColor, attrs.fill);",
                    "",
                    "      return drawPath(parentGfx, pathData, {",
                    "        fill,",
                    "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "    },",
                    "    'bpmn:SignalEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_SIGNAL', {",
                    "        xScaleFactor: 0.9,",
                    "        yScaleFactor: 0.9,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.5,",
                    "          my: 0.2",
                    "        }",
                    "      });",
                    "",
                    "      var fill = isThrowing",
                    "        ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)",
                    "        : getFillColor(event, defaultFillColor, attrs.fill);",
                    "",
                    "      return drawPath(parentGfx, pathData, {",
                    "        strokeWidth: 1,",
                    "        fill,",
                    "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "    },",
                    "    'bpmn:MultipleEventDefinition': function(parentGfx, event, attrs = {}, isThrowing) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_MULTIPLE', {",
                    "        xScaleFactor: 1.1,",
                    "        yScaleFactor: 1.1,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.222,",
                    "          my: 0.36",
                    "        }",
                    "      });",
                    "",
                    "      var fill = isThrowing",
                    "        ? getStrokeColor(event, defaultStrokeColor, attrs.stroke)",
                    "        : getFillColor(event, defaultFillColor, attrs.fill);",
                    "",
                    "      return drawPath(parentGfx, pathData, {",
                    "        fill,",
                    "        strokeWidth: 1",
                    "      });",
                    "    },",
                    "    'bpmn:ParallelMultipleEventDefinition': function(parentGfx, event, attrs = {}) {",
                    "      var pathData = pathMap.getScaledPath('EVENT_PARALLEL_MULTIPLE', {",
                    "        xScaleFactor: 1.2,",
                    "        yScaleFactor: 1.2,",
                    "        containerWidth: event.width,",
                    "        containerHeight: event.height,",
                    "        position: {",
                    "          mx: 0.458,",
                    "          my: 0.194",
                    "        }",
                    "      });",
                    "",
                    "      return drawPath(parentGfx, pathData, {",
                    "        fill: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
                    "        stroke: getStrokeColor(event, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "    },",
                    "    'bpmn:TerminateEventDefinition': function(parentGfx, element, attrs = {}) {",
                    "      var circle = drawCircle(parentGfx, element.width, element.height, 8, {",
                    "        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 4",
                    "      });",
                    "",
                    "      return circle;",
                    "    }",
                    "  };",
                    "",
                    "  function renderEventIcon(element, parentGfx, attrs = {}) {",
                    "    var semantic = getSemantic(element),",
                    "        isThrowing = isThrowEvent(semantic);",
                    "",
                    "    if (semantic.get('eventDefinitions') && semantic.get('eventDefinitions').length > 1) {",
                    "      if (semantic.get('parallelMultiple')) {",
                    "        return eventIconRenderers[ 'bpmn:ParallelMultipleEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "      }",
                    "      else {",
                    "        return eventIconRenderers[ 'bpmn:MultipleEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "      }",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:MessageEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:MessageEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:TimerEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:TimerEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:ConditionalEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:ConditionalEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:SignalEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:SignalEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:EscalationEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:EscalationEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:LinkEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:LinkEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:ErrorEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:ErrorEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:CancelEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:CancelEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:CompensateEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:CompensateEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    if (isTypedEvent(semantic, 'bpmn:TerminateEventDefinition')) {",
                    "      return eventIconRenderers[ 'bpmn:TerminateEventDefinition' ](parentGfx, element, attrs, isThrowing);",
                    "    }",
                    "",
                    "    return null;",
                    "  }",
                    "",
                    "  var taskMarkerRenderers = {",
                    "    'ParticipantMultiplicityMarker': function(parentGfx, element, attrs = {}) {",
                    "      var width = getWidth(element, attrs),",
                    "          height = getHeight(element, attrs);",
                    "",
                    "      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: width,",
                    "        containerHeight: height,",
                    "        position: {",
                    "          mx: ((width / 2 - 6) / width),",
                    "          my: (height - 15) / height",
                    "        }",
                    "      });",
                    "",
                    "      drawMarker('participant-multiplicity', parentGfx, markerPath, {",
                    "        strokeWidth: 2,",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "    },",
                    "    'SubProcessMarker': function(parentGfx, element, attrs = {}) {",
                    "      var markerRect = drawRect(parentGfx, 14, 14, 0, {",
                    "        strokeWidth: 1,",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "",
                    "      translate(markerRect, element.width / 2 - 7.5, element.height - 20);",
                    "",
                    "      var markerPath = pathMap.getScaledPath('MARKER_SUB_PROCESS', {",
                    "        xScaleFactor: 1.5,",
                    "        yScaleFactor: 1.5,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: (element.width / 2 - 7.5) / element.width,",
                    "          my: (element.height - 20) / element.height",
                    "        }",
                    "      });",
                    "",
                    "      drawMarker('sub-process', parentGfx, markerPath, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "    },",
                    "    'ParallelMarker': function(parentGfx, element, attrs) {",
                    "      var width = getWidth(element, attrs),",
                    "          height = getHeight(element, attrs);",
                    "",
                    "      var markerPath = pathMap.getScaledPath('MARKER_PARALLEL', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: width,",
                    "        containerHeight: height,",
                    "        position: {",
                    "          mx: ((width / 2 + attrs.parallel) / width),",
                    "          my: (height - 20) / height",
                    "        }",
                    "      });",
                    "",
                    "      drawMarker('parallel', parentGfx, markerPath, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "    },",
                    "    'SequentialMarker': function(parentGfx, element, attrs) {",
                    "      var markerPath = pathMap.getScaledPath('MARKER_SEQUENTIAL', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: ((element.width / 2 + attrs.seq) / element.width),",
                    "          my: (element.height - 19) / element.height",
                    "        }",
                    "      });",
                    "",
                    "      drawMarker('sequential', parentGfx, markerPath, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "    },",
                    "    'CompensationMarker': function(parentGfx, element, attrs) {",
                    "      var markerMath = pathMap.getScaledPath('MARKER_COMPENSATION', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: ((element.width / 2 + attrs.compensation) / element.width),",
                    "          my: (element.height - 13) / element.height",
                    "        }",
                    "      });",
                    "",
                    "      drawMarker('compensation', parentGfx, markerMath, {",
                    "        strokeWidth: 1,",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "    },",
                    "    'LoopMarker': function(parentGfx, element, attrs) {",
                    "      var width = getWidth(element, attrs),",
                    "          height = getHeight(element, attrs);",
                    "",
                    "      var markerPath = pathMap.getScaledPath('MARKER_LOOP', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: width,",
                    "        containerHeight: height,",
                    "        position: {",
                    "          mx: ((width / 2 + attrs.loop) / width),",
                    "          my: (height - 7) / height",
                    "        }",
                    "      });",
                    "",
                    "      drawMarker('loop', parentGfx, markerPath, {",
                    "        strokeWidth: 1.5,",
                    "        fill: 'none',",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeMiterlimit: 0.5",
                    "      });",
                    "    },",
                    "    'AdhocMarker': function(parentGfx, element, attrs) {",
                    "      var width = getWidth(element, attrs),",
                    "          height = getHeight(element, attrs);",
                    "",
                    "      var markerPath = pathMap.getScaledPath('MARKER_ADHOC', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: width,",
                    "        containerHeight: height,",
                    "        position: {",
                    "          mx: ((width / 2 + attrs.adhoc) / width),",
                    "          my: (height - 15) / height",
                    "        }",
                    "      });",
                    "",
                    "      drawMarker('adhoc', parentGfx, markerPath, {",
                    "        strokeWidth: 1,",
                    "        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "    }",
                    "  };",
                    "",
                    "  function renderTaskMarker(type, parentGfx, element, attrs) {",
                    "    taskMarkerRenderers[ type ](parentGfx, element, attrs);",
                    "  }",
                    "",
                    "  function renderTaskMarkers(parentGfx, element, taskMarkers, attrs = {}) {",
                    "    attrs = {",
                    "      fill: attrs.fill,",
                    "      stroke: attrs.stroke,",
                    "      width: getWidth(element, attrs),",
                    "      height: getHeight(element, attrs)",
                    "    };",
                    "",
                    "    var semantic = getSemantic(element);",
                    "",
                    "    var subprocess = taskMarkers && taskMarkers.includes('SubProcessMarker');",
                    "",
                    "    if (subprocess) {",
                    "      attrs = {",
                    "        ...attrs,",
                    "        seq: -21,",
                    "        parallel: -22,",
                    "        compensation: -42,",
                    "        loop: -18,",
                    "        adhoc: 10",
                    "      };",
                    "    } else {",
                    "      attrs = {",
                    "        ...attrs,",
                    "        seq: -5,",
                    "        parallel: -6,",
                    "        compensation: -27,",
                    "        loop: 0,",
                    "        adhoc: 10",
                    "      };",
                    "    }",
                    "",
                    "    forEach(taskMarkers, function(marker) {",
                    "      renderTaskMarker(marker, parentGfx, element, attrs);",
                    "    });",
                    "",
                    "    if (semantic.get('isForCompensation')) {",
                    "      renderTaskMarker('CompensationMarker', parentGfx, element, attrs);",
                    "    }",
                    "",
                    "    if (is(semantic, 'bpmn:AdHocSubProcess')) {",
                    "      renderTaskMarker('AdhocMarker', parentGfx, element, attrs);",
                    "    }",
                    "",
                    "    var loopCharacteristics = semantic.get('loopCharacteristics'),",
                    "        isSequential = loopCharacteristics && loopCharacteristics.get('isSequential');",
                    "",
                    "    if (loopCharacteristics) {",
                    "",
                    "      if (isSequential === undefined) {",
                    "        renderTaskMarker('LoopMarker', parentGfx, element, attrs);",
                    "      }",
                    "",
                    "      if (isSequential === false) {",
                    "        renderTaskMarker('ParallelMarker', parentGfx, element, attrs);",
                    "      }",
                    "",
                    "      if (isSequential === true) {",
                    "        renderTaskMarker('SequentialMarker', parentGfx, element, attrs);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  function renderLabel(parentGfx, label, attrs = {}) {",
                    "    attrs = assign({",
                    "      size: {",
                    "        width: 100",
                    "      }",
                    "    }, attrs);",
                    "",
                    "    var text = textRenderer.createText(label || '', attrs);",
                    "",
                    "    svgClasses(text).add('djs-label');",
                    "",
                    "    svgAppend(parentGfx, text);",
                    "",
                    "    return text;",
                    "  }",
                    "",
                    "  function renderEmbeddedLabel(parentGfx, element, align, attrs = {}) {",
                    "    var semantic = getSemantic(element);",
                    "",
                    "    var box = getBounds({",
                    "      x: element.x,",
                    "      y: element.y,",
                    "      width: element.width,",
                    "      height: element.height",
                    "    }, attrs);",
                    "",
                    "    return renderLabel(parentGfx, semantic.name, {",
                    "      align,",
                    "      box,",
                    "      padding: 7,",
                    "      style: {",
                    "        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)",
                    "      }",
                    "    });",
                    "  }",
                    "",
                    "  function renderExternalLabel(parentGfx, element, attrs = {}) {",
                    "    var box = {",
                    "      width: 90,",
                    "      height: 30,",
                    "      x: element.width / 2 + element.x,",
                    "      y: element.height / 2 + element.y",
                    "    };",
                    "",
                    "    return renderLabel(parentGfx, getLabel(element), {",
                    "      box: box,",
                    "      fitBox: true,",
                    "      style: assign(",
                    "        {},",
                    "        textRenderer.getExternalStyle(),",
                    "        {",
                    "          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)",
                    "        }",
                    "      )",
                    "    });",
                    "  }",
                    "",
                    "  function renderLaneLabel(parentGfx, text, element, attrs = {}) {",
                    "    var textBox = renderLabel(parentGfx, text, {",
                    "      box: {",
                    "        height: 30,",
                    "        width: getHeight(element, attrs),",
                    "      },",
                    "      align: 'center-middle',",
                    "      style: {",
                    "        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)",
                    "      }",
                    "    });",
                    "",
                    "    var top = -1 * getHeight(element, attrs);",
                    "",
                    "    transform(textBox, 0, -top, 270);",
                    "  }",
                    "",
                    "  function renderActivity(parentGfx, element, attrs = {}) {",
                    "    var {",
                    "      width,",
                    "      height",
                    "    } = getBounds(element, attrs);",
                    "",
                    "    return drawRect(parentGfx, width, height, TASK_BORDER_RADIUS, {",
                    "      ...attrs,",
                    "      fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "      fillOpacity: DEFAULT_OPACITY,",
                    "      stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "    });",
                    "  }",
                    "",
                    "  function renderAssociation(parentGfx, element, attrs = {}) {",
                    "    var semantic = getSemantic(element);",
                    "",
                    "    var fill = getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);",
                    "",
                    "    if (semantic.get('associationDirection') === 'One' ||",
                    "        semantic.get('associationDirection') === 'Both') {",
                    "      attrs.markerEnd = marker('association-end', fill, stroke);",
                    "    }",
                    "",
                    "    if (semantic.get('associationDirection') === 'Both') {",
                    "      attrs.markerStart = marker('association-start', fill, stroke);",
                    "    }",
                    "",
                    "    attrs = pickAttrs(attrs, [",
                    "      'markerStart',",
                    "      'markerEnd'",
                    "    ]);",
                    "",
                    "    return drawConnectionSegments(parentGfx, element.waypoints, {",
                    "      ...attrs,",
                    "      stroke,",
                    "      strokeDasharray: '0, 5'",
                    "    });",
                    "  }",
                    "",
                    "  function renderDataObject(parentGfx, element, attrs = {}) {",
                    "    var fill = getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);",
                    "",
                    "    var pathData = pathMap.getScaledPath('DATA_OBJECT_PATH', {",
                    "      xScaleFactor: 1,",
                    "      yScaleFactor: 1,",
                    "      containerWidth: element.width,",
                    "      containerHeight: element.height,",
                    "      position: {",
                    "        mx: 0.474,",
                    "        my: 0.296",
                    "      }",
                    "    });",
                    "",
                    "    var dataObject = drawPath(parentGfx, pathData, {",
                    "      fill,",
                    "      fillOpacity: DEFAULT_OPACITY,",
                    "      stroke",
                    "    });",
                    "",
                    "    var semantic = getSemantic(element);",
                    "",
                    "    if (isCollection(semantic)) {",
                    "      var collectionPathData = pathMap.getScaledPath('DATA_OBJECT_COLLECTION_PATH', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: 0.33,",
                    "          my: (element.height - 18) / element.height",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, collectionPathData, {",
                    "        strokeWidth: 2,",
                    "        fill,",
                    "        stroke",
                    "      });",
                    "    }",
                    "",
                    "    return dataObject;",
                    "  }",
                    "",
                    "  function renderEvent(parentGfx, element, attrs = {}) {",
                    "    return drawCircle(parentGfx, element.width, element.height, {",
                    "      fillOpacity: DEFAULT_OPACITY,",
                    "      ...attrs,",
                    "      fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "      stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "    });",
                    "  }",
                    "",
                    "  function renderGateway(parentGfx, element, attrs = {}) {",
                    "    return drawDiamond(parentGfx, element.width, element.height, {",
                    "      fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "      fillOpacity: DEFAULT_OPACITY,",
                    "      stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "    });",
                    "  }",
                    "",
                    "  function renderLane(parentGfx, element, attrs = {}) {",
                    "    var lane = drawRect(parentGfx, getWidth(element, attrs), getHeight(element, attrs), 0, {",
                    "      fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "      fillOpacity: attrs.fillOpacity || DEFAULT_OPACITY,",
                    "      stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "      strokeWidth: 1.5",
                    "    });",
                    "",
                    "    var semantic = getSemantic(element);",
                    "",
                    "    if (is(semantic, 'bpmn:Lane')) {",
                    "      var text = semantic.get('name');",
                    "",
                    "      renderLaneLabel(parentGfx, text, element, attrs);",
                    "    }",
                    "",
                    "    return lane;",
                    "  }",
                    "",
                    "  function renderSubProcess(parentGfx, element, attrs = {}) {",
                    "    var activity = renderActivity(parentGfx, element, attrs);",
                    "",
                    "    if (isEventSubProcess(element)) {",
                    "      svgAttr(activity, {",
                    "        strokeDasharray: '0, 5.5',",
                    "        strokeWidth: 2.5",
                    "      });",
                    "    }",
                    "",
                    "    var expanded = isExpanded(element);",
                    "",
                    "    renderEmbeddedLabel(parentGfx, element, expanded ? 'center-top' : 'center-middle', attrs);",
                    "",
                    "    if (expanded) {",
                    "      renderTaskMarkers(parentGfx, element, undefined, attrs);",
                    "    } else {",
                    "      renderTaskMarkers(parentGfx, element, [ 'SubProcessMarker' ], attrs);",
                    "    }",
                    "",
                    "    return activity;",
                    "  }",
                    "",
                    "  function renderTask(parentGfx, element, attrs = {}) {",
                    "    var activity = renderActivity(parentGfx, element, attrs);",
                    "",
                    "    renderEmbeddedLabel(parentGfx, element, 'center-middle', attrs);",
                    "",
                    "    renderTaskMarkers(parentGfx, element, undefined, attrs);",
                    "",
                    "    return activity;",
                    "  }",
                    "",
                    "  var handlers = this.handlers = {",
                    "    'bpmn:AdHocSubProcess': function(parentGfx, element, attrs = {}) {",
                    "      if (isExpanded(element)) {",
                    "        attrs = pickAttrs(attrs, [",
                    "          'fill',",
                    "          'stroke',",
                    "          'width',",
                    "          'height'",
                    "        ]);",
                    "      } else {",
                    "        attrs = pickAttrs(attrs, [",
                    "          'fill',",
                    "          'stroke'",
                    "        ]);",
                    "      }",
                    "",
                    "      return renderSubProcess(parentGfx, element, attrs);",
                    "    },",
                    "    'bpmn:Association': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      return renderAssociation(parentGfx, element, attrs);",
                    "    },",
                    "    'bpmn:BoundaryEvent': function(parentGfx, element, attrs = {}) {",
                    "      var { renderIcon = true } = attrs;",
                    "",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var semantic = getSemantic(element),",
                    "          cancelActivity = semantic.get('cancelActivity');",
                    "",
                    "      attrs = {",
                    "        strokeWidth: 1.5,",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        fillOpacity: FULL_OPACITY,",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      };",
                    "",
                    "      if (!cancelActivity) {",
                    "        attrs.strokeDasharray = '6';",
                    "      }",
                    "",
                    "      var event = renderEvent(parentGfx, element, attrs);",
                    "",
                    "      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {",
                    "        ...attrs,",
                    "        fill: 'none'",
                    "      });",
                    "",
                    "      if (renderIcon) {",
                    "        renderEventIcon(element, parentGfx, attrs);",
                    "      }",
                    "",
                    "      return event;",
                    "    },",
                    "    'bpmn:BusinessRuleTask': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var task = renderTask(parentGfx, element, attrs);",
                    "",
                    "      var headerData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_MAIN', {",
                    "        abspos: {",
                    "          x: 8,",
                    "          y: 8",
                    "        }",
                    "      });",
                    "",
                    "      var businessPath = drawPath(parentGfx, headerData);",
                    "",
                    "      svgAttr(businessPath, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      var headerPathData = pathMap.getScaledPath('TASK_TYPE_BUSINESS_RULE_HEADER', {",
                    "        abspos: {",
                    "          x: 8,",
                    "          y: 8",
                    "        }",
                    "      });",
                    "",
                    "      var businessHeaderPath = drawPath(parentGfx, headerPathData);",
                    "",
                    "      svgAttr(businessHeaderPath, {",
                    "        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return task;",
                    "    },",
                    "    'bpmn:CallActivity': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      return renderSubProcess(parentGfx, element, {",
                    "        strokeWidth: 5,",
                    "        ...attrs",
                    "      });",
                    "    },",
                    "    'bpmn:ComplexGateway': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var gateway = renderGateway(parentGfx, element, attrs);",
                    "",
                    "      var pathData = pathMap.getScaledPath('GATEWAY_COMPLEX', {",
                    "        xScaleFactor: 0.5,",
                    "        yScaleFactor:0.5,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: 0.46,",
                    "          my: 0.26",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathData, {",
                    "        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return gateway;",
                    "    },",
                    "    'bpmn:DataInput': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var arrowPathData = pathMap.getRawPath('DATA_ARROW');",
                    "",
                    "      var dataObject = renderDataObject(parentGfx, element, attrs);",
                    "",
                    "      drawPath(parentGfx, arrowPathData, {",
                    "        fill: 'none',",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return dataObject;",
                    "    },",
                    "    'bpmn:DataInputAssociation': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      return renderAssociation(parentGfx, element, {",
                    "        ...attrs,",
                    "        markerEnd: marker('association-end', getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor(element, defaultStrokeColor, attrs.stroke))",
                    "      });",
                    "    },",
                    "    'bpmn:DataObject': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      return renderDataObject(parentGfx, element, attrs);",
                    "    },",
                    "    'bpmn:DataObjectReference': as('bpmn:DataObject'),",
                    "    'bpmn:DataOutput': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var arrowPathData = pathMap.getRawPath('DATA_ARROW');",
                    "",
                    "      var dataObject = renderDataObject(parentGfx, element, attrs);",
                    "",
                    "      drawPath(parentGfx, arrowPathData, {",
                    "        strokeWidth: 1,",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "",
                    "      return dataObject;",
                    "    },",
                    "    'bpmn:DataOutputAssociation': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      return renderAssociation(parentGfx, element, {",
                    "        ...attrs,",
                    "        markerEnd: marker('association-end', getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor(element, defaultStrokeColor, attrs.stroke))",
                    "      });",
                    "    },",
                    "    'bpmn:DataStoreReference': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var dataStorePath = pathMap.getScaledPath('DATA_STORE', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: 0,",
                    "          my: 0.133",
                    "        }",
                    "      });",
                    "",
                    "      return drawPath(parentGfx, dataStorePath, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        fillOpacity: DEFAULT_OPACITY,",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 2",
                    "      });",
                    "    },",
                    "    'bpmn:EndEvent': function(parentGfx, element, attrs = {}) {",
                    "      var { renderIcon = true } = attrs;",
                    "",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var event = renderEvent(parentGfx, element, {",
                    "        ...attrs,",
                    "        strokeWidth: 4",
                    "      });",
                    "",
                    "      if (renderIcon) {",
                    "        renderEventIcon(element, parentGfx, attrs);",
                    "      }",
                    "",
                    "      return event;",
                    "    },",
                    "    'bpmn:EventBasedGateway': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var semantic = getSemantic(element);",
                    "",
                    "      var diamond = renderGateway(parentGfx, element, attrs);",
                    "",
                    "      drawCircle(parentGfx, element.width, element.height, element.height * 0.20, {",
                    "        fill: getFillColor(element, 'none', attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      var type = semantic.get('eventGatewayType'),",
                    "          instantiate = !!semantic.get('instantiate');",
                    "",
                    "      function drawEvent() {",
                    "",
                    "        var pathData = pathMap.getScaledPath('GATEWAY_EVENT_BASED', {",
                    "          xScaleFactor: 0.18,",
                    "          yScaleFactor: 0.18,",
                    "          containerWidth: element.width,",
                    "          containerHeight: element.height,",
                    "          position: {",
                    "            mx: 0.36,",
                    "            my: 0.44",
                    "          }",
                    "        });",
                    "",
                    "        drawPath(parentGfx, pathData, {",
                    "          fill: 'none',",
                    "          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "          strokeWidth: 2",
                    "        });",
                    "      }",
                    "",
                    "      if (type === 'Parallel') {",
                    "        var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {",
                    "          xScaleFactor: 0.4,",
                    "          yScaleFactor: 0.4,",
                    "          containerWidth: element.width,",
                    "          containerHeight: element.height,",
                    "          position: {",
                    "            mx: 0.474,",
                    "            my: 0.296",
                    "          }",
                    "        });",
                    "",
                    "        drawPath(parentGfx, pathData, {",
                    "          fill: 'none',",
                    "          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "          strokeWidth: 1",
                    "        });",
                    "      } else if (type === 'Exclusive') {",
                    "        if (!instantiate) {",
                    "          drawCircle(parentGfx, element.width, element.height, element.height * 0.26, {",
                    "            fill: 'none',",
                    "            stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "            strokeWidth: 1",
                    "          });",
                    "        }",
                    "",
                    "        drawEvent();",
                    "      }",
                    "",
                    "",
                    "      return diamond;",
                    "    },",
                    "    'bpmn:ExclusiveGateway': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var gateway = renderGateway(parentGfx, element, attrs);",
                    "",
                    "      var pathData = pathMap.getScaledPath('GATEWAY_EXCLUSIVE', {",
                    "        xScaleFactor: 0.4,",
                    "        yScaleFactor: 0.4,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: 0.32,",
                    "          my: 0.3",
                    "        }",
                    "      });",
                    "",
                    "      var di = getDi(element);",
                    "",
                    "      if (di.get('isMarkerVisible')) {",
                    "        drawPath(parentGfx, pathData, {",
                    "          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "          strokeWidth: 1",
                    "        });",
                    "      }",
                    "",
                    "      return gateway;",
                    "    },",
                    "    'bpmn:Gateway': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      return renderGateway(parentGfx, element, attrs);",
                    "    },",
                    "    'bpmn:Group': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke',",
                    "        'width',",
                    "        'height'",
                    "      ]);",
                    "",
                    "      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1.5,",
                    "        strokeDasharray: '10, 6, 0, 6',",
                    "        fill: 'none',",
                    "        pointerEvents: 'none',",
                    "        width: getWidth(element, attrs),",
                    "        height: getHeight(element, attrs)",
                    "      });",
                    "    },",
                    "    'bpmn:InclusiveGateway': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var gateway = renderGateway(parentGfx, element, attrs);",
                    "",
                    "      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 2.5",
                    "      });",
                    "",
                    "      return gateway;",
                    "    },",
                    "    'bpmn:IntermediateEvent': function(parentGfx, element, attrs = {}) {",
                    "      var { renderIcon = true } = attrs;",
                    "",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var outer = renderEvent(parentGfx, element, {",
                    "        ...attrs,",
                    "        strokeWidth: 1.5",
                    "      });",
                    "",
                    "      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {",
                    "        fill: 'none',",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1.5",
                    "      });",
                    "",
                    "      if (renderIcon) {",
                    "        renderEventIcon(element, parentGfx, attrs);",
                    "      }",
                    "",
                    "      return outer;",
                    "    },",
                    "    'bpmn:IntermediateCatchEvent': as('bpmn:IntermediateEvent'),",
                    "    'bpmn:IntermediateThrowEvent': as('bpmn:IntermediateEvent'),",
                    "    'bpmn:Lane': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke',",
                    "        'width',",
                    "        'height'",
                    "      ]);",
                    "",
                    "      return renderLane(parentGfx, element, {",
                    "        ...attrs,",
                    "        fillOpacity: LOW_OPACITY",
                    "      });",
                    "    },",
                    "    'bpmn:ManualTask': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var task = renderTask(parentGfx, element, attrs);",
                    "",
                    "      var pathData = pathMap.getScaledPath('TASK_TYPE_MANUAL', {",
                    "        abspos: {",
                    "          x: 17,",
                    "          y: 15",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathData, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 0.5",
                    "      });",
                    "",
                    "      return task;",
                    "    },",
                    "    'bpmn:MessageFlow': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var semantic = getSemantic(element),",
                    "          di = getDi(element);",
                    "",
                    "      var fill = getFillColor(element, defaultFillColor, attrs.fill),",
                    "          stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);",
                    "",
                    "      var path = drawConnectionSegments(parentGfx, element.waypoints, {",
                    "        markerEnd: marker('messageflow-end', fill, stroke),",
                    "        markerStart: marker('messageflow-start', fill, stroke),",
                    "        stroke,",
                    "        strokeDasharray: '10, 11',",
                    "        strokeWidth: 1.5",
                    "      });",
                    "",
                    "      if (semantic.get('messageRef')) {",
                    "        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);",
                    "",
                    "        var markerPathData = pathMap.getScaledPath('MESSAGE_FLOW_MARKER', {",
                    "          abspos: {",
                    "            x: midPoint.x,",
                    "            y: midPoint.y",
                    "          }",
                    "        });",
                    "",
                    "        var messageAttrs = {",
                    "          strokeWidth: 1",
                    "        };",
                    "",
                    "        if (di.get('messageVisibleKind') === 'initiating') {",
                    "          messageAttrs.fill = fill;",
                    "          messageAttrs.stroke = stroke;",
                    "        } else {",
                    "          messageAttrs.fill = stroke;",
                    "          messageAttrs.stroke = fill;",
                    "        }",
                    "",
                    "        var message = drawPath(parentGfx, markerPathData, messageAttrs);",
                    "",
                    "        var messageRef = semantic.get('messageRef'),",
                    "            name = messageRef.get('name');",
                    "",
                    "        var label = renderLabel(parentGfx, name, {",
                    "          align: 'center-top',",
                    "          fitBox: true,",
                    "          style: {",
                    "            fill: stroke",
                    "          }",
                    "        });",
                    "",
                    "        var messageBounds = message.getBBox(),",
                    "            labelBounds = label.getBBox();",
                    "",
                    "        var translateX = midPoint.x - labelBounds.width / 2,",
                    "            translateY = midPoint.y + messageBounds.height / 2 + ELEMENT_LABEL_DISTANCE;",
                    "",
                    "        transform(label, translateX, translateY, 0);",
                    "      }",
                    "",
                    "      return path;",
                    "    },",
                    "    'bpmn:ParallelGateway': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var diamond = renderGateway(parentGfx, element, attrs);",
                    "",
                    "      var pathData = pathMap.getScaledPath('GATEWAY_PARALLEL', {",
                    "        xScaleFactor: 0.6,",
                    "        yScaleFactor: 0.6,",
                    "        containerWidth: element.width,",
                    "        containerHeight: element.height,",
                    "        position: {",
                    "          mx: 0.46,",
                    "          my: 0.2",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathData, {",
                    "        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return diamond;",
                    "    },",
                    "    'bpmn:Participant': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke',",
                    "        'width',",
                    "        'height'",
                    "      ]);",
                    "",
                    "      var participant = renderLane(parentGfx, element, attrs);",
                    "",
                    "      var expandedParticipant = isExpanded(element);",
                    "",
                    "      var semantic = getSemantic(element),",
                    "          name = semantic.get('name');",
                    "",
                    "      if (expandedParticipant) {",
                    "        drawLine(parentGfx, [",
                    "          {",
                    "            x: 30,",
                    "            y: 0",
                    "          },",
                    "          {",
                    "            x: 30,",
                    "            y: getHeight(element, attrs)",
                    "          }",
                    "        ], {",
                    "          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "          strokeWidth: PARTICIPANT_STROKE_WIDTH",
                    "        });",
                    "",
                    "        renderLaneLabel(parentGfx, name, element, attrs);",
                    "      } else {",
                    "        renderLabel(parentGfx, name, {",
                    "          box: getBounds(element, attrs),",
                    "          align: 'center-middle',",
                    "          style: {",
                    "            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)",
                    "          }",
                    "        });",
                    "      }",
                    "",
                    "      if (semantic.get('participantMultiplicity')) {",
                    "        renderTaskMarker('ParticipantMultiplicityMarker', parentGfx, element, attrs);",
                    "      }",
                    "",
                    "      return participant;",
                    "    },",
                    "    'bpmn:ReceiveTask' : function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var semantic = getSemantic(element);",
                    "",
                    "      var task = renderTask(parentGfx, element, attrs);",
                    "",
                    "      var pathData;",
                    "",
                    "      if (semantic.get('instantiate')) {",
                    "        drawCircle(parentGfx, 28, 28, 20 * 0.22, {",
                    "          fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "          strokeWidth: 1",
                    "        });",
                    "",
                    "        pathData = pathMap.getScaledPath('TASK_TYPE_INSTANTIATING_SEND', {",
                    "          abspos: {",
                    "            x: 7.77,",
                    "            y: 9.52",
                    "          }",
                    "        });",
                    "      } else {",
                    "        pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {",
                    "          xScaleFactor: 0.9,",
                    "          yScaleFactor: 0.9,",
                    "          containerWidth: 21,",
                    "          containerHeight: 14,",
                    "          position: {",
                    "            mx: 0.3,",
                    "            my: 0.4",
                    "          }",
                    "        });",
                    "      }",
                    "",
                    "      drawPath(parentGfx, pathData, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return task;",
                    "    },",
                    "    'bpmn:ScriptTask': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var task = renderTask(parentGfx, element, attrs);",
                    "",
                    "      var pathData = pathMap.getScaledPath('TASK_TYPE_SCRIPT', {",
                    "        abspos: {",
                    "          x: 15,",
                    "          y: 20",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathData, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return task;",
                    "    },",
                    "    'bpmn:SendTask': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var task = renderTask(parentGfx, element, attrs);",
                    "",
                    "      var pathData = pathMap.getScaledPath('TASK_TYPE_SEND', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: 21,",
                    "        containerHeight: 14,",
                    "        position: {",
                    "          mx: 0.285,",
                    "          my: 0.357",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathData, {",
                    "        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        stroke: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return task;",
                    "    },",
                    "    'bpmn:SequenceFlow': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var fill = getFillColor(element, defaultFillColor, attrs.fill),",
                    "          stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);",
                    "",
                    "      var connection = drawConnectionSegments(parentGfx, element.waypoints, {",
                    "        markerEnd: marker('sequenceflow-end', fill, stroke),",
                    "        stroke",
                    "      });",
                    "",
                    "      var semantic = getSemantic(element);",
                    "",
                    "      var { source } = element;",
                    "",
                    "      if (source) {",
                    "        var sourceSemantic = getSemantic(source);",
                    "",
                    "        // conditional flow marker",
                    "        if (semantic.get('conditionExpression') && is(sourceSemantic, 'bpmn:Activity')) {",
                    "          svgAttr(connection, {",
                    "            markerStart: marker('conditional-flow-marker', fill, stroke)",
                    "          });",
                    "        }",
                    "",
                    "        // default marker",
                    "        if (sourceSemantic.get('default') && (is(sourceSemantic, 'bpmn:Gateway') || is(sourceSemantic, 'bpmn:Activity')) &&",
                    "            sourceSemantic.get('default') === semantic) {",
                    "          svgAttr(connection, {",
                    "            markerStart: marker('conditional-default-flow-marker', fill, stroke)",
                    "          });",
                    "        }",
                    "      }",
                    "",
                    "      return connection;",
                    "    },",
                    "    'bpmn:ServiceTask': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var task = renderTask(parentGfx, element, attrs);",
                    "",
                    "      drawCircle(parentGfx, 10, 10, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: 'none',",
                    "        transform: 'translate(6, 6)'",
                    "      });",
                    "",
                    "      var pathDataService1 = pathMap.getScaledPath('TASK_TYPE_SERVICE', {",
                    "        abspos: {",
                    "          x: 12,",
                    "          y: 18",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathDataService1, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      drawCircle(parentGfx, 10, 10, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: 'none',",
                    "        transform: 'translate(11, 10)'",
                    "      });",
                    "",
                    "      var pathDataService2 = pathMap.getScaledPath('TASK_TYPE_SERVICE', {",
                    "        abspos: {",
                    "          x: 17,",
                    "          y: 22",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathDataService2, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1",
                    "      });",
                    "",
                    "      return task;",
                    "    },",
                    "    'bpmn:StartEvent': function(parentGfx, element, attrs = {}) {",
                    "      var { renderIcon = true } = attrs;",
                    "",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var semantic = getSemantic(element);",
                    "",
                    "      if (!semantic.get('isInterrupting')) {",
                    "        attrs = {",
                    "          ...attrs,",
                    "          strokeDasharray: '6'",
                    "        };",
                    "      }",
                    "",
                    "      var event = renderEvent(parentGfx, element, attrs);",
                    "",
                    "      if (renderIcon) {",
                    "        renderEventIcon(element, parentGfx, attrs);",
                    "      }",
                    "",
                    "      return event;",
                    "    },",
                    "    'bpmn:SubProcess': function(parentGfx, element, attrs = {}) {",
                    "      if (isExpanded(element)) {",
                    "        attrs = pickAttrs(attrs, [",
                    "          'fill',",
                    "          'stroke',",
                    "          'width',",
                    "          'height'",
                    "        ]);",
                    "      } else {",
                    "        attrs = pickAttrs(attrs, [",
                    "          'fill',",
                    "          'stroke'",
                    "        ]);",
                    "      }",
                    "",
                    "      return renderSubProcess(parentGfx, element, attrs);",
                    "    },",
                    "    'bpmn:Task': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      return renderTask(parentGfx, element, attrs);",
                    "    },",
                    "    'bpmn:TextAnnotation': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke',",
                    "        'width',",
                    "        'height'",
                    "      ]);",
                    "",
                    "      var {",
                    "        width,",
                    "        height",
                    "      } = getBounds(element, attrs);",
                    "",
                    "      var textElement = drawRect(parentGfx, width, height, 0, 0, {",
                    "        fill: 'none',",
                    "        stroke: 'none'",
                    "      });",
                    "",
                    "      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {",
                    "        xScaleFactor: 1,",
                    "        yScaleFactor: 1,",
                    "        containerWidth: width,",
                    "        containerHeight: height,",
                    "        position: {",
                    "          mx: 0.0,",
                    "          my: 0.0",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, textPathData, {",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)",
                    "      });",
                    "",
                    "      var semantic = getSemantic(element),",
                    "          text = semantic.get('text') || '';",
                    "",
                    "      renderLabel(parentGfx, text, {",
                    "        align: 'left-top',",
                    "        box: getBounds(element, attrs),",
                    "        padding: 7,",
                    "        style: {",
                    "          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)",
                    "        }",
                    "      });",
                    "",
                    "      return textElement;",
                    "    },",
                    "    'bpmn:Transaction': function(parentGfx, element, attrs = {}) {",
                    "      if (isExpanded(element)) {",
                    "        attrs = pickAttrs(attrs, [",
                    "          'fill',",
                    "          'stroke',",
                    "          'width',",
                    "          'height'",
                    "        ]);",
                    "      } else {",
                    "        attrs = pickAttrs(attrs, [",
                    "          'fill',",
                    "          'stroke'",
                    "        ]);",
                    "      }",
                    "",
                    "      var outer = renderSubProcess(parentGfx, element, {",
                    "        strokeWidth: 1.5,",
                    "        ...attrs",
                    "      });",
                    "",
                    "      var innerAttrs = styles.style([ 'no-fill', 'no-events' ], {",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 1.5",
                    "      });",
                    "",
                    "      var expanded = isExpanded(element);",
                    "",
                    "      if (!expanded) {",
                    "        attrs = {};",
                    "      }",
                    "",
                    "      drawRect(",
                    "        parentGfx,",
                    "        getWidth(element, attrs),",
                    "        getHeight(element, attrs),",
                    "        TASK_BORDER_RADIUS - INNER_OUTER_DIST,",
                    "        INNER_OUTER_DIST,",
                    "        innerAttrs",
                    "      );",
                    "",
                    "      return outer;",
                    "    },",
                    "    'bpmn:UserTask': function(parentGfx, element, attrs = {}) {",
                    "      attrs = pickAttrs(attrs, [",
                    "        'fill',",
                    "        'stroke'",
                    "      ]);",
                    "",
                    "      var task = renderTask(parentGfx, element, attrs);",
                    "",
                    "      var x = 15;",
                    "      var y = 12;",
                    "",
                    "      var pathDataUser1 = pathMap.getScaledPath('TASK_TYPE_USER_1', {",
                    "        abspos: {",
                    "          x: x,",
                    "          y: y",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathDataUser1, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 0.5",
                    "      });",
                    "",
                    "      var pathDataUser2 = pathMap.getScaledPath('TASK_TYPE_USER_2', {",
                    "        abspos: {",
                    "          x: x,",
                    "          y: y",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathDataUser2, {",
                    "        fill: getFillColor(element, defaultFillColor, attrs.fill),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 0.5",
                    "      });",
                    "",
                    "      var pathDataUser3 = pathMap.getScaledPath('TASK_TYPE_USER_3', {",
                    "        abspos: {",
                    "          x: x,",
                    "          y: y",
                    "        }",
                    "      });",
                    "",
                    "      drawPath(parentGfx, pathDataUser3, {",
                    "        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),",
                    "        strokeWidth: 0.5",
                    "      });",
                    "",
                    "      return task;",
                    "    },",
                    "    'label': function(parentGfx, element, attrs = {}) {",
                    "      return renderExternalLabel(parentGfx, element, attrs);",
                    "    }",
                    "  };",
                    "",
                    "  // extension API, use at your own risk",
                    "  this._drawPath = drawPath;",
                    "",
                    "  this._renderer = renderer;",
                    "}",
                    "",
                    "",
                    "inherits(BpmnRenderer, BaseRenderer);",
                    "",
                    "BpmnRenderer.$inject = [",
                    "  'config.bpmnRenderer',",
                    "  'eventBus',",
                    "  'styles',",
                    "  'pathMap',",
                    "  'canvas',",
                    "  'textRenderer'",
                    "];",
                    "",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "BpmnRenderer.prototype.canRender = function(element) {",
                    "  return is(element, 'bpmn:BaseElement');",
                    "};",
                    "",
                    "/**",
                    " * Draw shape into parentGfx.",
                    " *",
                    " * @param {SVGElement} parentGfx",
                    " * @param {Element} element",
                    " * @param {Attrs} [attrs]",
                    " *",
                    " * @return {SVGElement} mainGfx",
                    " */",
                    "BpmnRenderer.prototype.drawShape = function(parentGfx, element, attrs = {}) {",
                    "  var { type } = element;",
                    "",
                    "  var handler = this._renderer(type);",
                    "",
                    "  return handler(parentGfx, element, attrs);",
                    "};",
                    "",
                    "/**",
                    " * Draw connection into parentGfx.",
                    " *",
                    " * @param {SVGElement} parentGfx",
                    " * @param {Element} element",
                    " * @param {Attrs} [attrs]",
                    " *",
                    " * @return {SVGElement} mainGfx",
                    " */",
                    "BpmnRenderer.prototype.drawConnection = function(parentGfx, element, attrs = {}) {",
                    "  var { type } = element;",
                    "",
                    "  var handler = this._renderer(type);",
                    "",
                    "  return handler(parentGfx, element, attrs);",
                    "};",
                    "",
                    "/**",
                    " * Get shape path.",
                    " *",
                    " * @param {Element} element",
                    " *",
                    " * @return {string} path",
                    " */",
                    "BpmnRenderer.prototype.getShapePath = function(element) {",
                    "  if (is(element, 'bpmn:Event')) {",
                    "    return getCirclePath(element);",
                    "  }",
                    "",
                    "  if (is(element, 'bpmn:Activity')) {",
                    "    return getRoundRectPath(element, TASK_BORDER_RADIUS);",
                    "  }",
                    "",
                    "  if (is(element, 'bpmn:Gateway')) {",
                    "    return getDiamondPath(element);",
                    "  }",
                    "",
                    "  return getRectPath(element);",
                    "};",
                    "",
                    "/**",
                    " * Pick attributes if they exist.",
                    " *",
                    " * @param {Object} attrs",
                    " * @param {string[]} keys",
                    " *",
                    " * @returns {Object}",
                    " */",
                    "function pickAttrs(attrs, keys = []) {",
                    "  return keys.reduce((pickedAttrs, key) => {",
                    "    if (attrs[ key ]) {",
                    "      pickedAttrs[ key ] = attrs[ key ];",
                    "    }",
                    "",
                    "    return pickedAttrs;",
                    "  }, {});",
                    "}"
                ]
            },
            "PathMap.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * Map containing SVG paths needed by BpmnRenderer",
                    " */",
                    "export default function PathMap() {",
                    "",
                    "  /**",
                    "   * Contains a map of path elements",
                    "   *",
                    "   * <h1>Path definition</h1>",
                    "   * A parameterized path is defined like this:",
                    "   * <pre>",
                    "   * 'GATEWAY_PARALLEL': {",
                    "   *   d: 'm {mx},{my} {e.x0},0 0,{e.x1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +",
                    "          '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',",
                    "   *   height: 17.5,",
                    "   *   width:  17.5,",
                    "   *   heightElements: [2.5, 7.5],",
                    "   *   widthElements: [2.5, 7.5]",
                    "   * }",
                    "   * </pre>",
                    "   * <p>It's important to specify a correct <b>height and width</b> for the path as the scaling",
                    "   * is based on the ratio between the specified height and width in this object and the",
                    "   * height and width that is set as scale target (Note x,y coordinates will be scaled with",
                    "   * individual ratios).</p>",
                    "   * <p>The '<b>heightElements</b>' and '<b>widthElements</b>' array must contain the values that will be scaled.",
                    "   * The scaling is based on the computed ratios.",
                    "   * Coordinates on the y axis should be in the <b>heightElement</b>'s array, they will be scaled using",
                    "   * the computed ratio coefficient.",
                    "   * In the parameterized path the scaled values can be accessed through the 'e' object in {} brackets.",
                    "   *   <ul>",
                    "   *    <li>The values for the y axis can be accessed in the path string using {e.y0}, {e.y1}, ....</li>",
                    "   *    <li>The values for the x axis can be accessed in the path string using {e.x0}, {e.x1}, ....</li>",
                    "   *   </ul>",
                    "   *   The numbers x0, x1 respectively y0, y1, ... map to the corresponding array index.",
                    "   * </p>",
                    "   */",
                    "  this.pathMap = {",
                    "    'EVENT_MESSAGE': {",
                    "      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',",
                    "      height: 36,",
                    "      width:  36,",
                    "      heightElements: [ 6, 14 ],",
                    "      widthElements: [ 10.5, 21 ]",
                    "    },",
                    "    'EVENT_SIGNAL': {",
                    "      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z',",
                    "      height: 36,",
                    "      width: 36,",
                    "      heightElements: [ 18 ],",
                    "      widthElements: [ 10, 20 ]",
                    "    },",
                    "    'EVENT_ESCALATION': {",
                    "      d: 'M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z',",
                    "      height: 36,",
                    "      width: 36,",
                    "      heightElements: [ 20, 7 ],",
                    "      widthElements: [ 8 ]",
                    "    },",
                    "    'EVENT_CONDITIONAL': {",
                    "      d: 'M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z ' +",
                    "         'M {e.x2},{e.y3} l {e.x0},0 ' +",
                    "         'M {e.x2},{e.y4} l {e.x0},0 ' +",
                    "         'M {e.x2},{e.y5} l {e.x0},0 ' +",
                    "         'M {e.x2},{e.y6} l {e.x0},0 ' +",
                    "         'M {e.x2},{e.y7} l {e.x0},0 ' +",
                    "         'M {e.x2},{e.y8} l {e.x0},0 ',",
                    "      height: 36,",
                    "      width:  36,",
                    "      heightElements: [ 8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5 ],",
                    "      widthElements:  [ 10.5, 14.5, 12.5 ]",
                    "    },",
                    "    'EVENT_LINK': {",
                    "      d: 'm {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z',",
                    "      height: 36,",
                    "      width: 36,",
                    "      heightElements: [ 4.4375, 6.75, 7.8125 ],",
                    "      widthElements: [ 9.84375, 13.5 ]",
                    "    },",
                    "    'EVENT_ERROR': {",
                    "      d: 'm {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z',",
                    "      height: 36,",
                    "      width: 36,",
                    "      heightElements: [ 0.023, 8.737, 8.151, 16.564, 10.591, 8.714 ],",
                    "      widthElements: [ 0.085, 6.672, 6.97, 4.273, 5.337, 6.636 ]",
                    "    },",
                    "    'EVENT_CANCEL_45': {",
                    "      d: 'm {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 ' +",
                    "        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',",
                    "      height: 36,",
                    "      width: 36,",
                    "      heightElements: [ 4.75, 8.5 ],",
                    "      widthElements: [ 4.75, 8.5 ]",
                    "    },",
                    "    'EVENT_COMPENSATION': {",
                    "      d: 'm {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z',",
                    "      height: 36,",
                    "      width: 36,",
                    "      heightElements: [ 6.5, 13, 0.4, 6.1 ],",
                    "      widthElements: [ 9, 9.3, 8.7 ]",
                    "    },",
                    "    'EVENT_TIMER_WH': {",
                    "      d: 'M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ',",
                    "      height: 36,",
                    "      width:  36,",
                    "      heightElements: [ 10, 2 ],",
                    "      widthElements: [ 3, 7 ]",
                    "    },",
                    "    'EVENT_TIMER_LINE': {",
                    "      d:  'M {mx},{my} ' +",
                    "          'm {e.x0},{e.y0} l -{e.x1},{e.y1} ',",
                    "      height: 36,",
                    "      width:  36,",
                    "      heightElements: [ 10, 3 ],",
                    "      widthElements: [ 0, 0 ]",
                    "    },",
                    "    'EVENT_MULTIPLE': {",
                    "      d:'m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z',",
                    "      height: 36,",
                    "      width:  36,",
                    "      heightElements: [ 6.28099, 12.56199 ],",
                    "      widthElements: [ 3.1405, 9.42149, 12.56198 ]",
                    "    },",
                    "    'EVENT_PARALLEL_MULTIPLE': {",
                    "      d:'m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} ' +",
                    "        '-{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z',",
                    "      height: 36,",
                    "      width:  36,",
                    "      heightElements: [ 2.56228, 7.68683 ],",
                    "      widthElements: [ 2.56228, 7.68683 ]",
                    "    },",
                    "    'GATEWAY_EXCLUSIVE': {",
                    "      d:'m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} ' +",
                    "                    '{e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} ' +",
                    "                    '{e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z',",
                    "      height: 17.5,",
                    "      width:  17.5,",
                    "      heightElements: [ 8.5, 6.5312, -6.5312, -8.5 ],",
                    "      widthElements:  [ 6.5, -6.5, 3, -3, 5, -5 ]",
                    "    },",
                    "    'GATEWAY_PARALLEL': {",
                    "      d:'m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 ' +",
                    "        '0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z',",
                    "      height: 30,",
                    "      width:  30,",
                    "      heightElements: [ 5, 12.5 ],",
                    "      widthElements: [ 5, 12.5 ]",
                    "    },",
                    "    'GATEWAY_EVENT_BASED': {",
                    "      d:'m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z',",
                    "      height: 11,",
                    "      width:  11,",
                    "      heightElements: [ -6, 6, 12, -12 ],",
                    "      widthElements: [ 9, -3, -12 ]",
                    "    },",
                    "    'GATEWAY_COMPLEX': {",
                    "      d:'m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} ' +",
                    "        '{e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} ' +",
                    "        '{e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} ' +",
                    "        '-{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z',",
                    "      height: 17.125,",
                    "      width:  17.125,",
                    "      heightElements: [ 4.875, 3.4375, 2.125, 3 ],",
                    "      widthElements: [ 3.4375, 2.125, 4.875, 3 ]",
                    "    },",
                    "    'DATA_OBJECT_PATH': {",
                    "      d:'m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0',",
                    "      height: 61,",
                    "      width:  51,",
                    "      heightElements: [ 10, 50, 60 ],",
                    "      widthElements: [ 10, 40, 50, 60 ]",
                    "    },",
                    "    'DATA_OBJECT_COLLECTION_PATH': {",
                    "      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',",
                    "      height: 10,",
                    "      width: 10,",
                    "      heightElements: [],",
                    "      widthElements: []",
                    "    },",
                    "    'DATA_ARROW': {",
                    "      d:'m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z',",
                    "      height: 61,",
                    "      width:  51,",
                    "      heightElements: [],",
                    "      widthElements: []",
                    "    },",
                    "    'DATA_STORE': {",
                    "      d:'m  {mx},{my} ' +",
                    "        'l  0,{e.y2} ' +",
                    "        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +",
                    "        'l  0,-{e.y2} ' +",
                    "        'c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0' +",
                    "        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 ' +",
                    "        'm  -{e.x2},{e.y0}' +",
                    "        'c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0' +",
                    "        'm  -{e.x2},{e.y0}' +",
                    "        'c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0',",
                    "      height: 61,",
                    "      width:  61,",
                    "      heightElements: [ 7, 10, 45 ],",
                    "      widthElements:  [ 2, 58, 60 ]",
                    "    },",
                    "    'TEXT_ANNOTATION': {",
                    "      d: 'm {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0',",
                    "      height: 30,",
                    "      width: 10,",
                    "      heightElements: [ 30 ],",
                    "      widthElements: [ 10 ]",
                    "    },",
                    "    'MARKER_SUB_PROCESS': {",
                    "      d: 'm{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0',",
                    "      height: 10,",
                    "      width: 10,",
                    "      heightElements: [],",
                    "      widthElements: []",
                    "    },",
                    "    'MARKER_PARALLEL': {",
                    "      d: 'm{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10',",
                    "      height: 10,",
                    "      width: 10,",
                    "      heightElements: [],",
                    "      widthElements: []",
                    "    },",
                    "    'MARKER_SEQUENTIAL': {",
                    "      d: 'm{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0',",
                    "      height: 10,",
                    "      width: 10,",
                    "      heightElements: [],",
                    "      widthElements: []",
                    "    },",
                    "    'MARKER_COMPENSATION': {",
                    "      d: 'm {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z',",
                    "      height: 10,",
                    "      width: 21,",
                    "      heightElements: [],",
                    "      widthElements: []",
                    "    },",
                    "    'MARKER_LOOP': {",
                    "      d: 'm {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 ' +",
                    "        '-6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 ' +",
                    "        '0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 ' +",
                    "        'l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902',",
                    "      height: 13.9,",
                    "      width: 13.7,",
                    "      heightElements: [],",
                    "      widthElements: []",
                    "    },",
                    "    'MARKER_ADHOC': {",
                    "      d: 'm {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 ' +",
                    "        '3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 ' +",
                    "        '1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 ' +",
                    "        '-3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 ' +",
                    "        '-2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z',",
                    "      height: 4,",
                    "      width: 15,",
                    "      heightElements: [],",
                    "      widthElements: []",
                    "    },",
                    "    'TASK_TYPE_SEND': {",
                    "      d: 'm {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}',",
                    "      height: 14,",
                    "      width:  21,",
                    "      heightElements: [ 6, 14 ],",
                    "      widthElements: [ 10.5, 21 ]",
                    "    },",
                    "    'TASK_TYPE_SCRIPT': {",
                    "      d: 'm {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 ' +",
                    "        'c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z ' +",
                    "        'm -7,-12 l 5,0 ' +",
                    "        'm -4.5,3 l 4.5,0 ' +",
                    "        'm -3,3 l 5,0' +",
                    "        'm -4,3 l 5,0',",
                    "      height: 15,",
                    "      width:  12.6,",
                    "      heightElements: [ 6, 14 ],",
                    "      widthElements: [ 10.5, 21 ]",
                    "    },",
                    "    'TASK_TYPE_USER_1': {",
                    "      d: 'm {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 ' +",
                    "        '-4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 ' +",
                    "        '0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 ' +",
                    "        'h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 z' +",
                    "        'm -8,6 l 0,5.5 m 11,0 l 0,-5'",
                    "    },",
                    "    'TASK_TYPE_USER_2': {",
                    "      d: 'm {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 ' +",
                    "        '-2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 '",
                    "    },",
                    "    'TASK_TYPE_USER_3': {",
                    "      d: 'm {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 ' +",
                    "        '4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 ' +",
                    "        '-4.20799998,3.36699999 -4.20699998,4.34799999 z'",
                    "    },",
                    "    'TASK_TYPE_MANUAL': {",
                    "      d: 'm {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 ' +",
                    "        '-0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 ' +",
                    "        '0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 ' +",
                    "        '-1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 ' +",
                    "        '0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 ' +",
                    "        '-10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 ' +",
                    "        '2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 ' +",
                    "        '-0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 ' +",
                    "        '-1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 ' +",
                    "        '-0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 ' +",
                    "        '0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 ' +",
                    "        '-5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z'",
                    "    },",
                    "    'TASK_TYPE_INSTANTIATING_SEND': {",
                    "      d: 'm {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6'",
                    "    },",
                    "    'TASK_TYPE_SERVICE': {",
                    "      d: 'm {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 ' +",
                    "        '0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 ' +",
                    "        '-1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 ' +",
                    "        'v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 ' +",
                    "        '-0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 ' +",
                    "        '-1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 ' +",
                    "        'h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 ' +",
                    "        '-0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 ' +",
                    "        'c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 ' +",
                    "        'l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 ' +",
                    "        '0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 ' +",
                    "        'c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z ' +",
                    "        'm 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +",
                    "        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +",
                    "        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'",
                    "    },",
                    "    'TASK_TYPE_SERVICE_FILL': {",
                    "      d: 'm {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 ' +",
                    "        '0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 ' +",
                    "        '0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z'",
                    "    },",
                    "    'TASK_TYPE_BUSINESS_RULE_HEADER': {",
                    "      d: 'm {mx},{my} 0,4 20,0 0,-4 z'",
                    "    },",
                    "    'TASK_TYPE_BUSINESS_RULE_MAIN': {",
                    "      d: 'm {mx},{my} 0,12 20,0 0,-12 z' +",
                    "        'm 0,8 l 20,0 ' +",
                    "        'm -13,-4 l 0,8'",
                    "    },",
                    "    'MESSAGE_FLOW_MARKER': {",
                    "      d: 'm {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6'",
                    "    }",
                    "  };",
                    "",
                    "  /**",
                    "   * Return raw path for the given ID.",
                    "   *",
                    "   * @param {string} pathId",
                    "   *",
                    "   * @return {string} raw path",
                    "   */",
                    "  this.getRawPath = function getRawPath(pathId) {",
                    "    return this.pathMap[pathId].d;",
                    "  };",
                    "",
                    "  /**",
                    "   * Scales the path to the given height and width.",
                    "   * <h1>Use case</h1>",
                    "   * <p>Use case is to scale the content of elements (event, gateways) based",
                    "   * on the element bounding box's size.",
                    "   * </p>",
                    "   * <h1>Why not transform</h1>",
                    "   * <p>Scaling a path with transform() will also scale the stroke and IE does not support",
                    "   * the option 'non-scaling-stroke' to prevent this.",
                    "   * Also there are use cases where only some parts of a path should be",
                    "   * scaled.</p>",
                    "   *",
                    "   * @param {string} pathId The ID of the path.",
                    "   * @param {Object} param <p>",
                    "   *   Example param object scales the path to 60% size of the container (data.width, data.height).",
                    "   *   <pre>",
                    "   *   {",
                    "   *     xScaleFactor: 0.6,",
                    "   *     yScaleFactor:0.6,",
                    "   *     containerWidth: data.width,",
                    "   *     containerHeight: data.height,",
                    "   *     position: {",
                    "   *       mx: 0.46,",
                    "   *       my: 0.2,",
                    "   *     }",
                    "   *   }",
                    "   *   </pre>",
                    "   *   <ul>",
                    "   *    <li>targetpathwidth = xScaleFactor * containerWidth</li>",
                    "   *    <li>targetpathheight = yScaleFactor * containerHeight</li>",
                    "   *    <li>Position is used to set the starting coordinate of the path. M is computed:",
                    "    *    <ul>",
                    "    *      <li>position.x * containerWidth</li>",
                    "    *      <li>position.y * containerHeight</li>",
                    "    *    </ul>",
                    "    *    Center of the container <pre> position: {",
                    "   *       mx: 0.5,",
                    "   *       my: 0.5,",
                    "   *     }</pre>",
                    "   *     Upper left corner of the container",
                    "   *     <pre> position: {",
                    "   *       mx: 0.0,",
                    "   *       my: 0.0,",
                    "   *     }</pre>",
                    "   *    </li>",
                    "   *   </ul>",
                    "   * </p>",
                    "   *",
                    "   * @return {string} scaled path",
                    "   */",
                    "  this.getScaledPath = function getScaledPath(pathId, param) {",
                    "    var rawPath = this.pathMap[pathId];",
                    "",
                    "    // positioning",
                    "    // compute the start point of the path",
                    "    var mx, my;",
                    "",
                    "    if (param.abspos) {",
                    "      mx = param.abspos.x;",
                    "      my = param.abspos.y;",
                    "    } else {",
                    "      mx = param.containerWidth * param.position.mx;",
                    "      my = param.containerHeight * param.position.my;",
                    "    }",
                    "",
                    "    var coordinates = {}; // map for the scaled coordinates",
                    "    if (param.position) {",
                    "",
                    "      // path",
                    "      var heightRatio = (param.containerHeight / rawPath.height) * param.yScaleFactor;",
                    "      var widthRatio = (param.containerWidth / rawPath.width) * param.xScaleFactor;",
                    "",
                    "",
                    "      // Apply height ratio",
                    "      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {",
                    "        coordinates['y' + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;",
                    "      }",
                    "",
                    "      // Apply width ratio",
                    "      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {",
                    "        coordinates['x' + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;",
                    "      }",
                    "    }",
                    "",
                    "    // Apply value to raw path",
                    "    var path = format(",
                    "      rawPath.d, {",
                    "        mx: mx,",
                    "        my: my,",
                    "        e: coordinates",
                    "      }",
                    "    );",
                    "    return path;",
                    "  };",
                    "}",
                    "",
                    "// helpers //////////////////////",
                    "",
                    "// copied and adjusted from https://github.com/adobe-webplatform/Snap.svg/blob/master/src/svg.js",
                    "var tokenRegex = /\\{([^{}]+)\\}/g,",
                    "    objNotationRegex = /(?:(?:^|\\.)(.+?)(?=\\[|\\.|$|\\()|\\[('|\")(.+?)\\2\\])(\\(\\))?/g; // matches .xxxxx or [\"xxxxx\"] to run over object properties",
                    "",
                    "function replacer(all, key, obj) {",
                    "  var res = obj;",
                    "  key.replace(objNotationRegex, function(all, name, quote, quotedName, isFunc) {",
                    "    name = name || quotedName;",
                    "    if (res) {",
                    "      if (name in res) {",
                    "        res = res[name];",
                    "      }",
                    "      typeof res == 'function' && isFunc && (res = res());",
                    "    }",
                    "  });",
                    "  res = (res == null || res == obj ? all : res) + '';",
                    "",
                    "  return res;",
                    "}",
                    "",
                    "function format(str, obj) {",
                    "  return String(str).replace(tokenRegex, function(all, key) {",
                    "    return replacer(all, key, obj);",
                    "  });",
                    "}"
                ]
            },
            "TextRenderer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { assign } from 'min-dash';",
                    "",
                    "import TextUtil from 'diagram-js/lib/util/Text';",
                    "",
                    "var DEFAULT_FONT_SIZE = 12;",
                    "var LINE_HEIGHT_RATIO = 1.2;",
                    "",
                    "var MIN_TEXT_ANNOTATION_HEIGHT = 30;",
                    "",
                    "/**",
                    " * @typedef { {",
                    " *   fontFamily: string;",
                    " *   fontSize: number;",
                    " *   fontWeight: string;",
                    " *   lineHeight: number;",
                    " * } } TextRendererStyle",
                    " *",
                    " * @typedef { {",
                    " *   defaultStyle?: Partial<TextRendererStyle>;",
                    " *   externalStyle?: Partial<TextRendererStyle>;",
                    " * } } TextRendererConfig",
                    " *",
                    " * @typedef { import('diagram-js/lib/util/Text').TextLayoutConfig } TextLayoutConfig",
                    " *",
                    " * @typedef { import('diagram-js/lib/util/Types').Rect } Rect",
                    " */",
                    "",
                    "",
                    "/**",
                    " * Renders text and computes text bounding boxes.",
                    " *",
                    " * @param {TextRendererConfig} [config]",
                    " */",
                    "export default function TextRenderer(config) {",
                    "",
                    "  var defaultStyle = assign({",
                    "    fontFamily: 'Arial, sans-serif',",
                    "    fontSize: DEFAULT_FONT_SIZE,",
                    "    fontWeight: 'normal',",
                    "    lineHeight: LINE_HEIGHT_RATIO",
                    "  }, config && config.defaultStyle || {});",
                    "",
                    "  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;",
                    "",
                    "  var externalStyle = assign({}, defaultStyle, {",
                    "    fontSize: fontSize",
                    "  }, config && config.externalStyle || {});",
                    "",
                    "  var textUtil = new TextUtil({",
                    "    style: defaultStyle",
                    "  });",
                    "",
                    "  /**",
                    "   * Get the new bounds of an externally rendered,",
                    "   * layouted label.",
                    "   *",
                    "   * @param {Rect} bounds",
                    "   * @param {string} text",
                    "   *",
                    "   * @return {Rect}",
                    "   */",
                    "  this.getExternalLabelBounds = function(bounds, text) {",
                    "",
                    "    var layoutedDimensions = textUtil.getDimensions(text, {",
                    "      box: {",
                    "        width: 90,",
                    "        height: 30",
                    "      },",
                    "      style: externalStyle",
                    "    });",
                    "",
                    "    // resize label shape to fit label text",
                    "    return {",
                    "      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),",
                    "      y: Math.round(bounds.y),",
                    "      width: Math.ceil(layoutedDimensions.width),",
                    "      height: Math.ceil(layoutedDimensions.height)",
                    "    };",
                    "",
                    "  };",
                    "",
                    "  /**",
                    "   * Get the new bounds of text annotation.",
                    "   *",
                    "   * @param {Rect} bounds",
                    "   * @param {string} text",
                    "   *",
                    "   * @return {Rect}",
                    "   */",
                    "  this.getTextAnnotationBounds = function(bounds, text) {",
                    "",
                    "    var layoutedDimensions = textUtil.getDimensions(text, {",
                    "      box: bounds,",
                    "      style: defaultStyle,",
                    "      align: 'left-top',",
                    "      padding: 5",
                    "    });",
                    "",
                    "    return {",
                    "      x: bounds.x,",
                    "      y: bounds.y,",
                    "      width: bounds.width,",
                    "      height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))",
                    "    };",
                    "  };",
                    "",
                    "  /**",
                    "   * Create a layouted text element.",
                    "   *",
                    "   * @param {string} text",
                    "   * @param {TextLayoutConfig} [options]",
                    "   *",
                    "   * @return {SVGElement} rendered text",
                    "   */",
                    "  this.createText = function(text, options) {",
                    "    return textUtil.createText(text, options || {});",
                    "  };",
                    "",
                    "  /**",
                    "   * Get default text style.",
                    "   */",
                    "  this.getDefaultStyle = function() {",
                    "    return defaultStyle;",
                    "  };",
                    "",
                    "  /**",
                    "   * Get the external text style.",
                    "   */",
                    "  this.getExternalStyle = function() {",
                    "    return externalStyle;",
                    "  };",
                    "",
                    "}",
                    "",
                    "TextRenderer.$inject = [",
                    "  'config.textRenderer'",
                    "];"
                ]
            },
            "TextRenderer.spec.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "import TextRenderer from './TextRenderer';",
                    "",
                    "new TextRenderer({",
                    "  defaultStyle: {",
                    "    fontFamily: 'foo'",
                    "  }",
                    "});",
                    "",
                    "const textRenderer = new TextRenderer();",
                    "",
                    "const externalLabelBounds = textRenderer.getExternalLabelBounds({",
                    "  x: 100,",
                    "  y: 100,",
                    "  width: 100,",
                    "  height: 100",
                    "}, 'FOO\\nBAR\\n\\BAZ');",
                    "",
                    "const textAnnotationBounds = textRenderer.getTextAnnotationBounds({",
                    "  x: 100,",
                    "  y: 100,",
                    "  width: 100,",
                    "  height: 100",
                    "}, 'FOO\\nBAR\\n\\BAZ');",
                    "",
                    "let text = textRenderer.createText('foo');",
                    "",
                    "text = textRenderer.createText('foo', {",
                    "  align: 'center-top',",
                    "  padding: 10",
                    "});",
                    "",
                    "const defaultStyle = textRenderer.getDefaultStyle();",
                    "",
                    "const externalStyle = textRenderer.getExternalStyle();"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import BpmnRenderer from './BpmnRenderer';",
                    "import TextRenderer from './TextRenderer';",
                    "",
                    "import PathMap from './PathMap';",
                    "",
                    "export default {",
                    "  __init__: [ 'bpmnRenderer' ],",
                    "  bpmnRenderer: [ 'type', BpmnRenderer ],",
                    "  textRenderer: [ 'type', TextRenderer ],",
                    "  pathMap: [ 'type', PathMap ]",
                    "};"
                ]
            }
        },
        "features": {
            "align-elements": {
                "AlignElementsContextPadProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  assign",
                        "} from 'min-dash';",
                        "",
                        "import ICONS from './AlignElementsIcons';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/features/context-pad/ContextPad').default} ContextPad",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').default} PopupMenu",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('diagram-js/lib/features/context-pad/ContextPad').ContextPadEntries} ContextPadEntries",
                        " * @typedef {import('diagram-js/lib/features/context-pad/ContextPadProvider').default} ContextPadProvider",
                        " */",
                        "",
                        "var LOW_PRIORITY = 900;",
                        "",
                        "/**",
                        " * A provider for the `Align elements` context pad entry.",
                        " *",
                        " * @implements {ContextPadProvider}",
                        " *",
                        " * @param {ContextPad} contextPad",
                        " * @param {PopupMenu} popupMenu",
                        " * @param {Translate} translate",
                        " * @param {Canvas} canvas",
                        " */",
                        "export default function AlignElementsContextPadProvider(contextPad, popupMenu, translate, canvas) {",
                        "",
                        "  contextPad.registerProvider(LOW_PRIORITY, this);",
                        "",
                        "  this._contextPad = contextPad;",
                        "  this._popupMenu = popupMenu;",
                        "  this._translate = translate;",
                        "  this._canvas = canvas;",
                        "}",
                        "",
                        "AlignElementsContextPadProvider.$inject = [",
                        "  'contextPad',",
                        "  'popupMenu',",
                        "  'translate',",
                        "  'canvas'",
                        "];",
                        "",
                        "/**",
                        " * @param {Element[]} elements",
                        " *",
                        " * @return {ContextPadEntries}",
                        " */",
                        "AlignElementsContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {",
                        "  var actions = {};",
                        "",
                        "  if (this._isAllowed(elements)) {",
                        "    assign(actions, this._getEntries(elements));",
                        "  }",
                        "",
                        "  return actions;",
                        "};",
                        "",
                        "AlignElementsContextPadProvider.prototype._isAllowed = function(elements) {",
                        "  return !this._popupMenu.isEmpty(elements, 'align-elements');",
                        "};",
                        "",
                        "AlignElementsContextPadProvider.prototype._getEntries = function() {",
                        "  var self = this;",
                        "",
                        "  return {",
                        "    'align-elements': {",
                        "      group: 'align-elements',",
                        "      title: self._translate('Align elements'),",
                        "      html: `<div class=\"entry\">${ICONS['align']}</div>`,",
                        "      action: {",
                        "        click: function(event, target) {",
                        "          var position = self._getMenuPosition(target);",
                        "",
                        "          assign(position, {",
                        "            cursor: {",
                        "              x: event.x,",
                        "              y: event.y",
                        "            }",
                        "          });",
                        "",
                        "          self._popupMenu.open(target, 'align-elements', position);",
                        "        }",
                        "      }",
                        "    }",
                        "  };",
                        "};",
                        "",
                        "AlignElementsContextPadProvider.prototype._getMenuPosition = function(elements) {",
                        "  var Y_OFFSET = 5;",
                        "",
                        "  var pad = this._contextPad.getPad(elements).html;",
                        "",
                        "  var padRect = pad.getBoundingClientRect();",
                        "",
                        "  var pos = {",
                        "    x: padRect.left,",
                        "    y: padRect.bottom + Y_OFFSET",
                        "  };",
                        "",
                        "  return pos;",
                        "};"
                    ]
                },
                "AlignElementsIcons.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * To change the icons, modify the SVGs in `./resources`, execute `npx svgo -f resources --datauri enc -o dist`,",
                        " * and then replace respective icons with the optimized data URIs in `./dist`.",
                        " */",
                        "var icons = {",
                        "  align:  `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 2000 2000\">",
                        "              <line x1=\"200\" y1=\"150\" x2=\"200\" y2=\"1850\" style=\"stroke:currentColor;stroke-width:100;stroke-linecap:round;\"/>",
                        "              <rect x=\"500\" y=\"150\" width=\"1300\" height=\"700\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "              <rect x=\"500\" y=\"1150\" width=\"700\" height=\"700\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "          </svg>`,",
                        "  bottom: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1800 1800\">",
                        "            <line x1=\"150\" y1=\"1650\" x2=\"1650\" y2=\"1650\" style=\"stroke:currentColor;stroke-width:100;stroke-linecap:round;\"/>",
                        "            <rect x=\"150\" y=\"350\" width=\"600\" height=\"1300\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "            <rect x=\"1050\" y=\"850\" width=\"600\" height=\"800\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "          </svg>`,",
                        "  center: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1800 1800\">",
                        "            <line x1=\"900\" y1=\"150\" x2=\"900\" y2=\"1650\" style=\"stroke:currentColor;stroke-width:100;stroke-linecap:round;\"/>",
                        "            <rect x=\"250\" y=\"150\" width=\"1300\" height=\"600\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "            <rect x=\"500\" y=\"1050\" width=\"800\" height=\"600\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "          </svg>`,",
                        "  left:   `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1800 1800\">",
                        "            <line x1=\"100\" y1=\"150\" x2=\"100\" y2=\"1650\" style=\"stroke:currentColor;stroke-width:100;stroke-linecap:round;\"/>",
                        "            <rect x=\"100\" y=\"150\" width=\"1300\" height=\"600\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "            <rect x=\"100\" y=\"1050\" width=\"800\" height=\"600\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "          </svg>`,",
                        "  right:  `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1800 1800\">",
                        "            <line x1=\"1650\" y1=\"150\" x2=\"1650\" y2=\"1650\" style=\"stroke:currentColor;stroke-width:100;stroke-linecap:round;\"/>",
                        "            <rect x=\"350\" y=\"150\" width=\"1300\" height=\"600\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "            <rect x=\"850\" y=\"1050\" width=\"800\" height=\"600\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "          </svg>`,",
                        "  top:    `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1800 1800\">",
                        "            <line x1=\"150\" y1=\"150\" x2=\"1650\" y2=\"150\" style=\"stroke:currentColor;stroke-width:100;stroke-linecap:round;\"/>",
                        "            <rect x=\"150\" y=\"150\" width=\"600\" height=\"1300\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "            <rect x=\"1050\" y=\"150\" width=\"600\" height=\"800\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "          </svg>`,",
                        "  middle: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1800 1800\">",
                        "            <line x1=\"150\" y1=\"900\" x2=\"1650\" y2=\"900\" style=\"stroke:currentColor;stroke-width:100;stroke-linecap:round;\"/>",
                        "            <rect x=\"150\" y=\"250\" width=\"600\" height=\"1300\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "            <rect x=\"1050\" y=\"500\" width=\"600\" height=\"800\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "          </svg>`",
                        "};",
                        "",
                        "export default icons;"
                    ]
                },
                "AlignElementsMenuProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import ICONS from './AlignElementsIcons';",
                        "",
                        "import {",
                        "  assign,",
                        "  forEach,",
                        "} from 'min-dash';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/features/align-elements/AlignElements').default} AlignElements",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').default} PopupMenu",
                        " * @typedef {import('diagram-js/lib/features/rules/Rules').default} Rules",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " *",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').PopupMenuEntries} PopupMenuEntries",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenuProvider').default} PopupMenuProvider",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').PopupMenuTarget} PopupMenuTarget",
                        " */",
                        "",
                        "var ALIGNMENT_OPTIONS = [",
                        "  'left',",
                        "  'center',",
                        "  'right',",
                        "  'top',",
                        "  'middle',",
                        "  'bottom'",
                        "];",
                        "",
                        "/**",
                        " * A provider for the `Align elements` popup menu.",
                        " *",
                        " * @implements {PopupMenuProvider}",
                        " *",
                        " * @param {PopupMenu} popupMenu",
                        " * @param {AlignElements} alignElements",
                        " * @param {Translate} translate",
                        " * @param {Rules} rules",
                        " */",
                        "export default function AlignElementsMenuProvider(popupMenu, alignElements, translate, rules) {",
                        "",
                        "  this._alignElements = alignElements;",
                        "  this._translate = translate;",
                        "  this._popupMenu = popupMenu;",
                        "  this._rules = rules;",
                        "",
                        "  popupMenu.registerProvider('align-elements', this);",
                        "}",
                        "",
                        "AlignElementsMenuProvider.$inject = [",
                        "  'popupMenu',",
                        "  'alignElements',",
                        "  'translate',",
                        "  'rules'",
                        "];",
                        "",
                        "/**",
                        " * @param {PopupMenuTarget} target",
                        " *",
                        " * @return {PopupMenuEntries}",
                        " */",
                        "AlignElementsMenuProvider.prototype.getPopupMenuEntries = function(target) {",
                        "  var entries = {};",
                        "",
                        "  if (this._isAllowed(target)) {",
                        "    assign(entries, this._getEntries(target));",
                        "  }",
                        "",
                        "  return entries;",
                        "};",
                        "",
                        "AlignElementsMenuProvider.prototype._isAllowed = function(target) {",
                        "  return this._rules.allowed('elements.align', { elements: target });",
                        "};",
                        "",
                        "/**",
                        " * @param {PopupMenuTarget} target",
                        " *",
                        " * @return {PopupMenuEntries}",
                        " */",
                        "AlignElementsMenuProvider.prototype._getEntries = function(target) {",
                        "  var alignElements = this._alignElements,",
                        "      translate = this._translate,",
                        "      popupMenu = this._popupMenu;",
                        "",
                        "  var entries = {};",
                        "",
                        "  forEach(ALIGNMENT_OPTIONS, function(alignment) {",
                        "    entries[ 'align-elements-' + alignment ] = {",
                        "      group: 'align',",
                        "      title: translate('Align elements ' + alignment),",
                        "      className: 'bjs-align-elements-menu-entry',",
                        "      imageHtml: ICONS[ alignment ],",
                        "      action: function() {",
                        "        alignElements.trigger(target, alignment);",
                        "        popupMenu.close();",
                        "      }",
                        "    };",
                        "  });",
                        "",
                        "  return entries;",
                        "};"
                    ]
                },
                "BpmnAlignElements.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';",
                        "import { getParents } from 'diagram-js/lib/util/Elements';",
                        "",
                        "import {",
                        "  filter",
                        "} from 'min-dash';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " */",
                        "",
                        "/**",
                        " * Rule provider for aligning BPMN elements.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " */",
                        "export default function BpmnAlignElements(eventBus) {",
                        "  RuleProvider.call(this, eventBus);",
                        "}",
                        "",
                        "BpmnAlignElements.$inject = [ 'eventBus' ];",
                        "",
                        "inherits(BpmnAlignElements, RuleProvider);",
                        "",
                        "BpmnAlignElements.prototype.init = function() {",
                        "  this.addRule('elements.align', function(context) {",
                        "    var elements = context.elements;",
                        "",
                        "    // filter out elements which cannot be aligned",
                        "    var filteredElements = filter(elements, function(element) {",
                        "      return !(element.waypoints || element.host || element.labelTarget);",
                        "    });",
                        "",
                        "    // filter out elements which are children of any of the selected elements",
                        "    filteredElements = getParents(filteredElements);",
                        "",
                        "    if (filteredElements.length < 2) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return filteredElements;",
                        "  });",
                        "};"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import AlignElementsModule from 'diagram-js/lib/features/align-elements';",
                        "import ContextPadModule from 'diagram-js/lib/features/context-pad';",
                        "import PopupMenuModule from 'diagram-js/lib/features/popup-menu';",
                        "",
                        "import AlignElementsContextPadProvider from './AlignElementsContextPadProvider';",
                        "import AlignElementsMenuProvider from './AlignElementsMenuProvider';",
                        "import BpmnAlignElements from './BpmnAlignElements';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    AlignElementsModule,",
                        "    ContextPadModule,",
                        "    PopupMenuModule",
                        "  ],",
                        "  __init__: [",
                        "    'alignElementsContextPadProvider',",
                        "    'alignElementsMenuProvider',",
                        "    'bpmnAlignElements'",
                        "  ],",
                        "  alignElementsContextPadProvider: [ 'type', AlignElementsContextPadProvider ],",
                        "  alignElementsMenuProvider: [ 'type', AlignElementsMenuProvider ],",
                        "  bpmnAlignElements: [ 'type', BpmnAlignElements ]",
                        "};"
                    ]
                }
            },
            "append-preview": {
                "AppendPreview.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  assign,",
                        "  isNil",
                        "} from 'min-dash';",
                        "",
                        "const round = Math.round;",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/features/complex-preview/ComplexPreview').default} ComplexPreview",
                        " * @typedef {import('diagram-js/lib/layout/ConnectionDocking').default} ConnectionDocking",
                        " * @typedef {import('../modeling/ElementFactory').default} ElementFactory",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('diagram-js/lib/layout/ManhattanLayout').default} ManhattanLayout",
                        " * @typedef {import('diagram-js/lib/features/rules/Rules').default} Rules",
                        " *",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " */",
                        "",
                        "/**",
                        " * A preview for appending.",
                        " *",
                        " * @param {ComplexPreview} complexPreview",
                        " * @param {ConnectionDocking} connectionDocking",
                        " * @param {ElementFactory} elementFactory",
                        " * @param {EventBus} eventBus",
                        " * @param {ManhattanLayout} layouter",
                        " * @param {Rules} rules",
                        " */",
                        "export default function AppendPreview(complexPreview, connectionDocking, elementFactory, eventBus, layouter, rules) {",
                        "  this._complexPreview = complexPreview;",
                        "  this._connectionDocking = connectionDocking;",
                        "  this._elementFactory = elementFactory;",
                        "  this._eventBus = eventBus;",
                        "  this._layouter = layouter;",
                        "  this._rules = rules;",
                        "}",
                        "",
                        "/**",
                        " * Create a preview of appending a shape of the given type to the given source.",
                        " *",
                        " * @param {Shape} source",
                        " * @param {string} type",
                        " * @param {Partial<Shape>} options",
                        " */",
                        "AppendPreview.prototype.create = function(source, type, options) {",
                        "  const complexPreview = this._complexPreview,",
                        "        connectionDocking = this._connectionDocking,",
                        "        elementFactory = this._elementFactory,",
                        "        eventBus = this._eventBus,",
                        "        layouter = this._layouter,",
                        "        rules = this._rules;",
                        "",
                        "  const shape = elementFactory.createShape(assign({ type }, options));",
                        "",
                        "  const position = eventBus.fire('autoPlace', {",
                        "    source,",
                        "    shape",
                        "  });",
                        "",
                        "  if (!position) {",
                        "    return;",
                        "  }",
                        "",
                        "  assign(shape, {",
                        "    x: position.x - round(shape.width / 2),",
                        "    y: position.y - round(shape.height / 2)",
                        "  });",
                        "",
                        "  const connectionCreateAllowed = rules.allowed('connection.create', {",
                        "    source,",
                        "    target: shape,",
                        "    hints: {",
                        "      targetParent: source.parent",
                        "    }",
                        "  });",
                        "",
                        "  let connection = null;",
                        "",
                        "  if (connectionCreateAllowed) {",
                        "    connection = elementFactory.createConnection(connectionCreateAllowed);",
                        "",
                        "    connection.waypoints = layouter.layoutConnection(connection, {",
                        "      source,",
                        "      target: shape",
                        "    });",
                        "",
                        "    connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, shape);",
                        "  }",
                        "",
                        "  complexPreview.create({",
                        "    created: [",
                        "      shape,",
                        "      connection",
                        "    ].filter((element) => !isNil(element))",
                        "  });",
                        "};",
                        "",
                        "AppendPreview.prototype.cleanUp = function() {",
                        "  this._complexPreview.cleanUp();",
                        "};",
                        "",
                        "AppendPreview.$inject = [",
                        "  'complexPreview',",
                        "  'connectionDocking',",
                        "  'elementFactory',",
                        "  'eventBus',",
                        "  'layouter',",
                        "  'rules'",
                        "];"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import AutoPlaceModule from '../auto-place';",
                        "import ComplexPreviewModule from 'diagram-js/lib/features/complex-preview';",
                        "import ModelingModule from '../modeling';",
                        "",
                        "import AppendPreview from './AppendPreview';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    AutoPlaceModule,",
                        "    ComplexPreviewModule,",
                        "    ModelingModule",
                        "  ],",
                        "  __init__: [ 'appendPreview' ],",
                        "  appendPreview: [ 'type', AppendPreview ]",
                        "};"
                    ]
                }
            },
            "auto-place": {
                "BpmnAutoPlace.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { getNewShapePosition } from './BpmnAutoPlaceUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " */",
                        "",
                        "/**",
                        " * BPMN auto-place behavior.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " */",
                        "export default function AutoPlace(eventBus) {",
                        "  eventBus.on('autoPlace', function(context) {",
                        "    var shape = context.shape,",
                        "        source = context.source;",
                        "",
                        "    return getNewShapePosition(source, shape);",
                        "  });",
                        "}",
                        "",
                        "AutoPlace.$inject = [ 'eventBus' ];"
                    ]
                },
                "BpmnAutoPlaceUtil.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { is } from '../../util/ModelUtil';",
                        "import { isAny } from '../modeling/util/ModelingUtil';",
                        "",
                        "import {",
                        "  getMid,",
                        "  asTRBL,",
                        "  getOrientation",
                        "} from 'diagram-js/lib/layout/LayoutUtil';",
                        "",
                        "import {",
                        "  findFreePosition,",
                        "  generateGetNextPosition,",
                        "  getConnectedDistance",
                        "} from 'diagram-js/lib/features/auto-place/AutoPlaceUtil';",
                        "",
                        "import { isConnection } from 'diagram-js/lib/util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                        " * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL",
                        " */",
                        "",
                        "/**",
                        " * Get the position for given new target relative to the source it will be",
                        " * connected to.",
                        " *",
                        " * @param  {Shape} source",
                        " * @param  {Shape} element",
                        " *",
                        " * @return {Point}",
                        " */",
                        "export function getNewShapePosition(source, element) {",
                        "",
                        "  if (is(element, 'bpmn:TextAnnotation')) {",
                        "    return getTextAnnotationPosition(source, element);",
                        "  }",
                        "",
                        "  if (isAny(element, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ])) {",
                        "    return getDataElementPosition(source, element);",
                        "  }",
                        "",
                        "  if (is(element, 'bpmn:FlowNode')) {",
                        "    return getFlowNodePosition(source, element);",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * Get the position for given new flow node. Try placing the flow node right of",
                        " * the source.",
                        " *",
                        " * @param {Shape} source",
                        " * @param {Shape} element",
                        " *",
                        " * @return {Point}",
                        " */",
                        "export function getFlowNodePosition(source, element) {",
                        "",
                        "  var sourceTrbl = asTRBL(source);",
                        "  var sourceMid = getMid(source);",
                        "",
                        "  var horizontalDistance = getConnectedDistance(source, {",
                        "    filter: function(connection) {",
                        "      return is(connection, 'bpmn:SequenceFlow');",
                        "    }",
                        "  });",
                        "",
                        "  var margin = 30,",
                        "      minDistance = 80,",
                        "      orientation = 'left';",
                        "",
                        "  if (is(source, 'bpmn:BoundaryEvent')) {",
                        "    orientation = getOrientation(source, source.host, -25);",
                        "",
                        "    if (orientation.indexOf('top') !== -1) {",
                        "      margin *= -1;",
                        "    }",
                        "  }",
                        "",
                        "  var position = {",
                        "    x: sourceTrbl.right + horizontalDistance + element.width / 2,",
                        "    y: sourceMid.y + getVerticalDistance(orientation, minDistance)",
                        "  };",
                        "",
                        "  var nextPositionDirection = {",
                        "    y: {",
                        "      margin: margin,",
                        "      minDistance: minDistance",
                        "    }",
                        "  };",
                        "",
                        "  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));",
                        "}",
                        "",
                        "/**",
                        " * @param {DirectionTRBL} orientation",
                        " * @param {number} minDistance",
                        " *",
                        " * @return {number}",
                        " */",
                        "function getVerticalDistance(orientation, minDistance) {",
                        "  if (orientation.includes('top')) {",
                        "    return -1 * minDistance;",
                        "  } else if (orientation.includes('bottom')) {",
                        "    return minDistance;",
                        "  } else {",
                        "    return 0;",
                        "  }",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Get the position for given text annotation. Try placing the text annotation",
                        " * top-right of the source.",
                        " *",
                        " * @param {Shape} source",
                        " * @param {Shape} element",
                        " *",
                        " * @return {Point}",
                        " */",
                        "export function getTextAnnotationPosition(source, element) {",
                        "",
                        "  var sourceTrbl = asTRBL(source);",
                        "",
                        "  var position = {",
                        "    x: sourceTrbl.right + element.width / 2,",
                        "    y: sourceTrbl.top - 50 - element.height / 2",
                        "  };",
                        "",
                        "  if (isConnection(source)) {",
                        "    position = getMid(source);",
                        "    position.x += 100;",
                        "    position.y -= 50;",
                        "  }",
                        "",
                        "  var nextPositionDirection = {",
                        "    y: {",
                        "      margin: -30,",
                        "      minDistance: 20",
                        "    }",
                        "  };",
                        "",
                        "  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));",
                        "}",
                        "",
                        "",
                        "/**",
                        " * Get the position for given new data element. Try placing the data element",
                        " * bottom-right of the source.",
                        " *",
                        " * @param {Shape} source",
                        " * @param {Shape} element",
                        " *",
                        " * @return {Point}",
                        " */",
                        "export function getDataElementPosition(source, element) {",
                        "",
                        "  var sourceTrbl = asTRBL(source);",
                        "",
                        "  var position = {",
                        "    x: sourceTrbl.right - 10 + element.width / 2,",
                        "    y: sourceTrbl.bottom + 40 + element.width / 2",
                        "  };",
                        "",
                        "  var nextPositionDirection = {",
                        "    x: {",
                        "      margin: 30,",
                        "      minDistance: 30",
                        "    }",
                        "  };",
                        "",
                        "  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import AutoPlaceModule from 'diagram-js/lib/features/auto-place';",
                        "",
                        "import BpmnAutoPlace from './BpmnAutoPlace';",
                        "",
                        "export default {",
                        "  __depends__: [ AutoPlaceModule ],",
                        "  __init__: [ 'bpmnAutoPlace' ],",
                        "  bpmnAutoPlace: [ 'type', BpmnAutoPlace ]",
                        "};"
                    ]
                }
            },
            "auto-resize": {
                "BpmnAutoResize.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import AutoResize from 'diagram-js/lib/features/auto-resize/AutoResize';",
                        "",
                        "import inherits from 'inherits-browser';",
                        "",
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('didi').Injector} Injector",
                        " *",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                        " */",
                        "",
                        "/**",
                        " * BPMN-specific resize behavior.",
                        " *",
                        " * @param {Injector} injector",
                        " */",
                        "export default function BpmnAutoResize(injector) {",
                        "",
                        "  injector.invoke(AutoResize, this);",
                        "}",
                        "",
                        "BpmnAutoResize.$inject = [",
                        "  'injector'",
                        "];",
                        "",
                        "inherits(BpmnAutoResize, AutoResize);",
                        "",
                        "/**",
                        " * Perform BPMN-specific resizing of participants.",
                        " *",
                        " * @param {Shape} target",
                        " * @param {Rect} newBounds",
                        " * @param {Object} [hints]",
                        " * @param {string} [hints.autoResize]",
                        " */",
                        "BpmnAutoResize.prototype.resize = function(target, newBounds, hints) {",
                        "",
                        "  if (is(target, 'bpmn:Participant')) {",
                        "    this._modeling.resizeLane(target, newBounds, null, hints);",
                        "  } else {",
                        "    this._modeling.resizeShape(target, newBounds, null, hints);",
                        "  }",
                        "};"
                    ]
                },
                "BpmnAutoResizeProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "import { isLabel } from '../../util/LabelUtil';",
                        "",
                        "import inherits from 'inherits-browser';",
                        "",
                        "import { forEach } from 'min-dash';",
                        "",
                        "import AutoResizeProvider from 'diagram-js/lib/features/auto-resize/AutoResizeProvider';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('../modeling/Modeling').default} Modeling",
                        " *",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " */",
                        "",
                        "/**",
                        " * BPMN-specific provider for automatic resizung.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {Modeling} modeling",
                        " */",
                        "export default function BpmnAutoResizeProvider(eventBus, modeling) {",
                        "  AutoResizeProvider.call(this, eventBus);",
                        "",
                        "  this._modeling = modeling;",
                        "}",
                        "",
                        "inherits(BpmnAutoResizeProvider, AutoResizeProvider);",
                        "",
                        "BpmnAutoResizeProvider.$inject = [",
                        "  'eventBus',",
                        "  'modeling'",
                        "];",
                        "",
                        "",
                        "/**",
                        " * BPMN-specific check whether given elements can be resized.",
                        " *",
                        " * @param {Shape[]} elements",
                        " * @param {Shape} target",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "BpmnAutoResizeProvider.prototype.canResize = function(elements, target) {",
                        "",
                        "  // do not resize plane elements:",
                        "  // root elements, collapsed sub-processes",
                        "  if (is(target.di, 'bpmndi:BPMNPlane')) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!is(target, 'bpmn:Participant') && !is(target, 'bpmn:Lane') && !(is(target, 'bpmn:SubProcess'))) {",
                        "    return false;",
                        "  }",
                        "",
                        "  var canResize = true;",
                        "",
                        "  forEach(elements, function(element) {",
                        "",
                        "    if (is(element, 'bpmn:Lane') || isLabel(element)) {",
                        "      canResize = false;",
                        "      return;",
                        "    }",
                        "  });",
                        "",
                        "  return canResize;",
                        "};"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import BpmnAutoResize from './BpmnAutoResize';",
                        "import BpmnAutoResizeProvider from './BpmnAutoResizeProvider';",
                        "",
                        "",
                        "export default {",
                        "  __init__: [",
                        "    'bpmnAutoResize',",
                        "    'bpmnAutoResizeProvider'",
                        "  ],",
                        "  bpmnAutoResize: [ 'type', BpmnAutoResize ],",
                        "  bpmnAutoResizeProvider: [ 'type', BpmnAutoResizeProvider ]",
                        "};"
                    ]
                }
            },
            "context-pad": {
                "ContextPadProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  assign,",
                        "  forEach,",
                        "  isArray,",
                        "  every",
                        "} from 'min-dash';",
                        "",
                        "import {",
                        "  is",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  isExpanded,",
                        "  isEventSubProcess",
                        "} from '../../util/DiUtil';",
                        "",
                        "import {",
                        "  isAny",
                        "} from '../modeling/util/ModelingUtil';",
                        "",
                        "import {",
                        "  getChildLanes",
                        "} from '../modeling/util/LaneUtil';",
                        "",
                        "import {",
                        "  hasPrimaryModifier",
                        "} from 'diagram-js/lib/util/Mouse';",
                        "",
                        "/**",
                        " * @typedef {import('didi').Injector} Injector",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('diagram-js/lib/features/context-pad/ContextPad').default} ContextPad",
                        " * @typedef {import('../modeling/Modeling').default} Modeling",
                        " * @typedef {import('../modeling/ElementFactory').default} ElementFactory",
                        " * @typedef {import('diagram-js/lib/features/connect/Connect').default} Connect",
                        " * @typedef {import('diagram-js/lib/features/create/Create').default} Create",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').default} PopupMenu",
                        " * @typedef {import('diagram-js/lib/features/canvas/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/features/rules/Rules').default} Rules",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').ModdleElement} ModdleElement",
                        " *",
                        " * @typedef {import('diagram-js/lib/features/context-pad/ContextPadProvider').default<Element>} BaseContextPadProvider",
                        " * @typedef {import('diagram-js/lib/features/context-pad/ContextPadProvider').ContextPadEntries} ContextPadEntries",
                        " * @typedef {import('diagram-js/lib/features/context-pad/ContextPadProvider').ContextPadEntry} ContextPadEntry",
                        " *",
                        " * @typedef { { autoPlace?: boolean; } } ContextPadConfig",
                        " */",
                        "",
                        "/**",
                        " * BPMN-specific context pad provider.",
                        " *",
                        " * @implements {BaseContextPadProvider}",
                        " *",
                        " * @param {ContextPadConfig} config",
                        " * @param {Injector} injector",
                        " * @param {EventBus} eventBus",
                        " * @param {ContextPad} contextPad",
                        " * @param {Modeling} modeling",
                        " * @param {ElementFactory} elementFactory",
                        " * @param {Connect} connect",
                        " * @param {Create} create",
                        " * @param {PopupMenu} popupMenu",
                        " * @param {Canvas} canvas",
                        " * @param {Rules} rules",
                        " * @param {Translate} translate",
                        " */",
                        "export default function ContextPadProvider(",
                        "    config, injector, eventBus,",
                        "    contextPad, modeling, elementFactory,",
                        "    connect, create, popupMenu,",
                        "    canvas, rules, translate, appendPreview) {",
                        "",
                        "  config = config || {};",
                        "",
                        "  contextPad.registerProvider(this);",
                        "",
                        "  this._contextPad = contextPad;",
                        "",
                        "  this._modeling = modeling;",
                        "",
                        "  this._elementFactory = elementFactory;",
                        "  this._connect = connect;",
                        "  this._create = create;",
                        "  this._popupMenu = popupMenu;",
                        "  this._canvas = canvas;",
                        "  this._rules = rules;",
                        "  this._translate = translate;",
                        "  this._eventBus = eventBus;",
                        "  this._appendPreview = appendPreview;",
                        "",
                        "  if (config.autoPlace !== false) {",
                        "    this._autoPlace = injector.get('autoPlace', false);",
                        "  }",
                        "",
                        "  eventBus.on('create.end', 250, function(event) {",
                        "    var context = event.context,",
                        "        shape = context.shape;",
                        "",
                        "    if (!hasPrimaryModifier(event) || !contextPad.isOpen(shape)) {",
                        "      return;",
                        "    }",
                        "",
                        "    var entries = contextPad.getEntries(shape);",
                        "",
                        "    if (entries.replace) {",
                        "      entries.replace.action.click(event, shape);",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "ContextPadProvider.$inject = [",
                        "  'config.contextPad',",
                        "  'injector',",
                        "  'eventBus',",
                        "  'contextPad',",
                        "  'modeling',",
                        "  'elementFactory',",
                        "  'connect',",
                        "  'create',",
                        "  'popupMenu',",
                        "  'canvas',",
                        "  'rules',",
                        "  'translate',",
                        "  'appendPreview'",
                        "];",
                        "",
                        "/**",
                        " * @param {Element[]} elements",
                        " *",
                        " * @return {ContextPadEntries}",
                        " */",
                        "ContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {",
                        "  var modeling = this._modeling;",
                        "",
                        "  var actions = {};",
                        "",
                        "  if (this._isDeleteAllowed(elements)) {",
                        "    assign(actions, {",
                        "      'delete': {",
                        "        group: 'edit',",
                        "        className: 'bpmn-icon-trash',",
                        "        title: this._translate('Remove'),",
                        "        action: {",
                        "          click: function(event, elements) {",
                        "            modeling.removeElements(elements.slice());",
                        "          }",
                        "        }",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  return actions;",
                        "};",
                        "",
                        "/**",
                        " * @param {Element[]} elements",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "ContextPadProvider.prototype._isDeleteAllowed = function(elements) {",
                        "",
                        "  var baseAllowed = this._rules.allowed('elements.delete', {",
                        "    elements: elements",
                        "  });",
                        "",
                        "  if (isArray(baseAllowed)) {",
                        "    return every(baseAllowed, function(element) {",
                        "      return includes(baseAllowed, element);",
                        "    });",
                        "  }",
                        "",
                        "  return baseAllowed;",
                        "};",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {ContextPadEntries}",
                        " */",
                        "ContextPadProvider.prototype.getContextPadEntries = function(element) {",
                        "  var contextPad = this._contextPad,",
                        "      modeling = this._modeling,",
                        "      elementFactory = this._elementFactory,",
                        "      connect = this._connect,",
                        "      create = this._create,",
                        "      popupMenu = this._popupMenu,",
                        "      rules = this._rules,",
                        "      autoPlace = this._autoPlace,",
                        "      translate = this._translate,",
                        "      appendPreview = this._appendPreview;",
                        "",
                        "  var actions = {};",
                        "",
                        "  if (element.type === 'label') {",
                        "    return actions;",
                        "  }",
                        "",
                        "  var businessObject = element.businessObject;",
                        "",
                        "  function startConnect(event, element) {",
                        "    connect.start(event, element);",
                        "  }",
                        "",
                        "  function removeElement(e, element) {",
                        "    modeling.removeElements([ element ]);",
                        "  }",
                        "",
                        "  function getReplaceMenuPosition(element) {",
                        "",
                        "    var Y_OFFSET = 5;",
                        "",
                        "    var pad = contextPad.getPad(element).html;",
                        "",
                        "    var padRect = pad.getBoundingClientRect();",
                        "",
                        "    var pos = {",
                        "      x: padRect.left,",
                        "      y: padRect.bottom + Y_OFFSET",
                        "    };",
                        "",
                        "    return pos;",
                        "  }",
                        "",
                        "  /**",
                        "   * Create an append action.",
                        "   *",
                        "   * @param {string} type",
                        "   * @param {string} className",
                        "   * @param {string} [title]",
                        "   * @param {Object} [options]",
                        "   *",
                        "   * @return {ContextPadEntry}",
                        "   */",
                        "  function appendAction(type, className, title, options) {",
                        "",
                        "    if (typeof title !== 'string') {",
                        "      options = title;",
                        "      title = translate('Append {type}', { type: type.replace(/^bpmn:/, '') });",
                        "    }",
                        "",
                        "    function appendStart(event, element) {",
                        "",
                        "      var shape = elementFactory.createShape(assign({ type: type }, options));",
                        "",
                        "      create.start(event, shape, {",
                        "        source: element",
                        "      });",
                        "",
                        "      appendPreview.cleanUp();",
                        "    }",
                        "",
                        "    var append = autoPlace ? function(_, element) {",
                        "      var shape = elementFactory.createShape(assign({ type: type }, options));",
                        "",
                        "      autoPlace.append(element, shape);",
                        "",
                        "      appendPreview.cleanUp();",
                        "    } : appendStart;",
                        "",
                        "    var previewAppend = autoPlace ? function(_, element) {",
                        "",
                        "      // mouseover",
                        "      appendPreview.create(element, type, options);",
                        "",
                        "      return () => {",
                        "",
                        "        // mouseout",
                        "        appendPreview.cleanUp();",
                        "      };",
                        "    } : null;",
                        "",
                        "    return {",
                        "      group: 'model',",
                        "      className: className,",
                        "      title: title,",
                        "      action: {",
                        "        dragstart: appendStart,",
                        "        click: append,",
                        "        hover: previewAppend",
                        "      }",
                        "    };",
                        "  }",
                        "",
                        "  function splitLaneHandler(count) {",
                        "",
                        "    return function(_, element) {",
                        "",
                        "      // actual split",
                        "      modeling.splitLane(element, count);",
                        "",
                        "      // refresh context pad after split to",
                        "      // get rid of split icons",
                        "      contextPad.open(element, true);",
                        "    };",
                        "  }",
                        "",
                        "",
                        "  if (isAny(businessObject, [ 'bpmn:Lane', 'bpmn:Participant' ]) && isExpanded(element)) {",
                        "",
                        "    var childLanes = getChildLanes(element);",
                        "",
                        "    assign(actions, {",
                        "      'lane-insert-above': {",
                        "        group: 'lane-insert-above',",
                        "        className: 'bpmn-icon-lane-insert-above',",
                        "        title: translate('Add Lane above'),",
                        "        action: {",
                        "          click: function(event, element) {",
                        "            modeling.addLane(element, 'top');",
                        "          }",
                        "        }",
                        "      }",
                        "    });",
                        "",
                        "    if (childLanes.length < 2) {",
                        "",
                        "      if (element.height >= 120) {",
                        "        assign(actions, {",
                        "          'lane-divide-two': {",
                        "            group: 'lane-divide',",
                        "            className: 'bpmn-icon-lane-divide-two',",
                        "            title: translate('Divide into two Lanes'),",
                        "            action: {",
                        "              click: splitLaneHandler(2)",
                        "            }",
                        "          }",
                        "        });",
                        "      }",
                        "",
                        "      if (element.height >= 180) {",
                        "        assign(actions, {",
                        "          'lane-divide-three': {",
                        "            group: 'lane-divide',",
                        "            className: 'bpmn-icon-lane-divide-three',",
                        "            title: translate('Divide into three Lanes'),",
                        "            action: {",
                        "              click: splitLaneHandler(3)",
                        "            }",
                        "          }",
                        "        });",
                        "      }",
                        "    }",
                        "",
                        "    assign(actions, {",
                        "      'lane-insert-below': {",
                        "        group: 'lane-insert-below',",
                        "        className: 'bpmn-icon-lane-insert-below',",
                        "        title: translate('Add Lane below'),",
                        "        action: {",
                        "          click: function(event, element) {",
                        "            modeling.addLane(element, 'bottom');",
                        "          }",
                        "        }",
                        "      }",
                        "    });",
                        "",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:FlowNode')) {",
                        "",
                        "    if (is(businessObject, 'bpmn:EventBasedGateway')) {",
                        "",
                        "      assign(actions, {",
                        "        'append.receive-task': appendAction(",
                        "          'bpmn:ReceiveTask',",
                        "          'bpmn-icon-receive-task',",
                        "          translate('Append ReceiveTask')",
                        "        ),",
                        "        'append.message-intermediate-event': appendAction(",
                        "          'bpmn:IntermediateCatchEvent',",
                        "          'bpmn-icon-intermediate-event-catch-message',",
                        "          translate('Append MessageIntermediateCatchEvent'),",
                        "          { eventDefinitionType: 'bpmn:MessageEventDefinition' }",
                        "        ),",
                        "        'append.timer-intermediate-event': appendAction(",
                        "          'bpmn:IntermediateCatchEvent',",
                        "          'bpmn-icon-intermediate-event-catch-timer',",
                        "          translate('Append TimerIntermediateCatchEvent'),",
                        "          { eventDefinitionType: 'bpmn:TimerEventDefinition' }",
                        "        ),",
                        "        'append.condition-intermediate-event': appendAction(",
                        "          'bpmn:IntermediateCatchEvent',",
                        "          'bpmn-icon-intermediate-event-catch-condition',",
                        "          translate('Append ConditionIntermediateCatchEvent'),",
                        "          { eventDefinitionType: 'bpmn:ConditionalEventDefinition' }",
                        "        ),",
                        "        'append.signal-intermediate-event': appendAction(",
                        "          'bpmn:IntermediateCatchEvent',",
                        "          'bpmn-icon-intermediate-event-catch-signal',",
                        "          translate('Append SignalIntermediateCatchEvent'),",
                        "          { eventDefinitionType: 'bpmn:SignalEventDefinition' }",
                        "        )",
                        "      });",
                        "    } else",
                        "",
                        "    if (isEventType(businessObject, 'bpmn:BoundaryEvent', 'bpmn:CompensateEventDefinition')) {",
                        "",
                        "      assign(actions, {",
                        "        'append.compensation-activity':",
                        "            appendAction(",
                        "              'bpmn:Task',",
                        "              'bpmn-icon-task',",
                        "              translate('Append compensation activity'),",
                        "              {",
                        "                isForCompensation: true",
                        "              }",
                        "            )",
                        "      });",
                        "    } else",
                        "",
                        "    if (!is(businessObject, 'bpmn:EndEvent') &&",
                        "        !businessObject.isForCompensation &&",
                        "        !isEventType(businessObject, 'bpmn:IntermediateThrowEvent', 'bpmn:LinkEventDefinition') &&",
                        "        !isEventSubProcess(businessObject)) {",
                        "",
                        "      assign(actions, {",
                        "        'append.end-event': appendAction(",
                        "          'bpmn:EndEvent',",
                        "          'bpmn-icon-end-event-none',",
                        "          translate('Append EndEvent')",
                        "        ),",
                        "        'append.gateway': appendAction(",
                        "          'bpmn:ExclusiveGateway',",
                        "          'bpmn-icon-gateway-none',",
                        "          translate('Append Gateway')",
                        "        ),",
                        "        'append.append-task': appendAction(",
                        "          'bpmn:Task',",
                        "          'bpmn-icon-task',",
                        "          translate('Append Task')",
                        "        ),",
                        "        'append.intermediate-event': appendAction(",
                        "          'bpmn:IntermediateThrowEvent',",
                        "          'bpmn-icon-intermediate-event-none',",
                        "          translate('Append Intermediate/Boundary Event')",
                        "        )",
                        "      });",
                        "    }",
                        "  }",
                        "",
                        "  if (!popupMenu.isEmpty(element, 'bpmn-replace')) {",
                        "",
                        "    // Replace menu entry",
                        "    assign(actions, {",
                        "      'replace': {",
                        "        group: 'edit',",
                        "        className: 'bpmn-icon-screw-wrench',",
                        "        title: translate('Change type'),",
                        "        action: {",
                        "          click: function(event, element) {",
                        "",
                        "            var position = assign(getReplaceMenuPosition(element), {",
                        "              cursor: { x: event.x, y: event.y }",
                        "            });",
                        "",
                        "            popupMenu.open(element, 'bpmn-replace', position, {",
                        "              title: translate('Change element'),",
                        "              width: 300,",
                        "              search: true",
                        "            });",
                        "          }",
                        "        }",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:SequenceFlow')) {",
                        "    assign(actions, {",
                        "      'append.text-annotation': appendAction(",
                        "        'bpmn:TextAnnotation',",
                        "        'bpmn-icon-text-annotation',",
                        "        translate('Append TextAnnotation')",
                        "      )",
                        "    });",
                        "  }",
                        "",
                        "  if (",
                        "    isAny(businessObject, [",
                        "      'bpmn:FlowNode',",
                        "      'bpmn:InteractionNode',",
                        "      'bpmn:DataObjectReference',",
                        "      'bpmn:DataStoreReference',",
                        "    ])",
                        "  ) {",
                        "    assign(actions, {",
                        "      'append.text-annotation': appendAction(",
                        "        'bpmn:TextAnnotation',",
                        "        'bpmn-icon-text-annotation',",
                        "        translate('Append TextAnnotation')",
                        "      ),",
                        "",
                        "      'connect': {",
                        "        group: 'connect',",
                        "        className: 'bpmn-icon-connection-multi',",
                        "        title: translate(",
                        "          'Connect using ' +",
                        "            (businessObject.isForCompensation",
                        "              ? ''",
                        "              : 'Sequence/MessageFlow or ') +",
                        "            'Association'",
                        "        ),",
                        "        action: {",
                        "          click: startConnect,",
                        "          dragstart: startConnect,",
                        "        },",
                        "      },",
                        "    });",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:TextAnnotation')) {",
                        "    assign(actions, {",
                        "      'connect': {",
                        "        group: 'connect',",
                        "        className: 'bpmn-icon-connection-multi',",
                        "        title: translate('Connect using Association'),",
                        "        action: {",
                        "          click: startConnect,",
                        "          dragstart: startConnect,",
                        "        },",
                        "      },",
                        "    });",
                        "  }",
                        "",
                        "  if (isAny(businessObject, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ])) {",
                        "    assign(actions, {",
                        "      'connect': {",
                        "        group: 'connect',",
                        "        className: 'bpmn-icon-connection-multi',",
                        "        title: translate('Connect using DataInputAssociation'),",
                        "        action: {",
                        "          click: startConnect,",
                        "          dragstart: startConnect",
                        "        }",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:Group')) {",
                        "    assign(actions, {",
                        "      'append.text-annotation': appendAction(",
                        "        'bpmn:TextAnnotation',",
                        "        'bpmn-icon-text-annotation',",
                        "        translate('Append TextAnnotation')",
                        "      )",
                        "    });",
                        "  }",
                        "",
                        "  // delete element entry, only show if allowed by rules",
                        "  var deleteAllowed = rules.allowed('elements.delete', { elements: [ element ] });",
                        "",
                        "  if (isArray(deleteAllowed)) {",
                        "",
                        "    // was the element returned as a deletion candidate?",
                        "    deleteAllowed = deleteAllowed[0] === element;",
                        "  }",
                        "",
                        "  if (deleteAllowed) {",
                        "    assign(actions, {",
                        "      'delete': {",
                        "        group: 'edit',",
                        "        className: 'bpmn-icon-trash',",
                        "        title: translate('Remove'),",
                        "        action: {",
                        "          click: removeElement",
                        "        }",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  return actions;",
                        "};",
                        "",
                        "",
                        "// helpers /////////",
                        "",
                        "/**",
                        " * @param {ModdleElement} businessObject",
                        " * @param {string} type",
                        " * @param {string} eventDefinitionType",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isEventType(businessObject, type, eventDefinitionType) {",
                        "",
                        "  var isType = businessObject.$instanceOf(type);",
                        "  var isDefinition = false;",
                        "",
                        "  var definitions = businessObject.eventDefinitions || [];",
                        "  forEach(definitions, function(def) {",
                        "    if (def.$type === eventDefinitionType) {",
                        "      isDefinition = true;",
                        "    }",
                        "  });",
                        "",
                        "  return isType && isDefinition;",
                        "}",
                        "",
                        "function includes(array, item) {",
                        "  return array.indexOf(item) !== -1;",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import AppendPreviewModule from '../append-preview';",
                        "import DirectEditingModule from 'diagram-js-direct-editing';",
                        "import ContextPadModule from 'diagram-js/lib/features/context-pad';",
                        "import SelectionModule from 'diagram-js/lib/features/selection';",
                        "import ConnectModule from 'diagram-js/lib/features/connect';",
                        "import CreateModule from 'diagram-js/lib/features/create';",
                        "import PopupMenuModule from '../popup-menu';",
                        "",
                        "import ContextPadProvider from './ContextPadProvider';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    AppendPreviewModule,",
                        "    DirectEditingModule,",
                        "    ContextPadModule,",
                        "    SelectionModule,",
                        "    ConnectModule,",
                        "    CreateModule,",
                        "    PopupMenuModule",
                        "  ],",
                        "  __init__: [ 'contextPadProvider' ],",
                        "  contextPadProvider: [ 'type', ContextPadProvider ]",
                        "};"
                    ]
                }
            },
            "copy-paste": {
                "BpmnCopyPaste.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  getBusinessObject,",
                        "  getDi,",
                        "  is",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  forEach,",
                        "  isArray,",
                        "  isUndefined,",
                        "  omit,",
                        "  reduce",
                        "} from 'min-dash';",
                        "",
                        "import { isLabel } from '../../util/LabelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('../modeling/BpmnFactory').default} BpmnFactory",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('./ModdleCopy').default} ModdleCopy",
                        " */",
                        "",
                        "function copyProperties(source, target, properties) {",
                        "  if (!isArray(properties)) {",
                        "    properties = [ properties ];",
                        "  }",
                        "",
                        "  forEach(properties, function(property) {",
                        "    if (!isUndefined(source[property])) {",
                        "      target[property] = source[property];",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "var LOW_PRIORITY = 750;",
                        "",
                        "/**",
                        " * BPMN-specific copy & paste.",
                        " *",
                        " * @param {BpmnFactory} bpmnFactory",
                        " * @param {EventBus} eventBus",
                        " * @param {ModdleCopy} moddleCopy",
                        " */",
                        "export default function BpmnCopyPaste(bpmnFactory, eventBus, moddleCopy) {",
                        "",
                        "  function copy(bo, clone) {",
                        "    var targetBo = bpmnFactory.create(bo.$type);",
                        "",
                        "    return moddleCopy.copyElement(bo, targetBo, null, clone);",
                        "  }",
                        "",
                        "  eventBus.on('copyPaste.copyElement', LOW_PRIORITY, function(context) {",
                        "    var descriptor = context.descriptor,",
                        "        element = context.element,",
                        "        businessObject = getBusinessObject(element);",
                        "",
                        "    // do not copy business object + di for labels;",
                        "    // will be pulled from the referenced label target",
                        "    if (isLabel(element)) {",
                        "      return descriptor;",
                        "    }",
                        "",
                        "    var businessObjectCopy = descriptor.businessObject = copy(businessObject, true);",
                        "    var diCopy = descriptor.di = copy(getDi(element), true);",
                        "    diCopy.bpmnElement = businessObjectCopy;",
                        "",
                        "    copyProperties(businessObjectCopy, descriptor, 'name');",
                        "    copyProperties(diCopy, descriptor, 'isExpanded');",
                        "",
                        "    // default sequence flow",
                        "    if (businessObject.default) {",
                        "      descriptor.default = businessObject.default.id;",
                        "    }",
                        "  });",
                        "",
                        "  var referencesKey = '-bpmn-js-refs';",
                        "",
                        "  function getReferences(cache) {",
                        "    return (cache[referencesKey] = cache[referencesKey] || {});",
                        "  }",
                        "",
                        "  function setReferences(cache, references) {",
                        "    cache[referencesKey] = references;",
                        "  }",
                        "",
                        "  function resolveReferences(descriptor, cache, references) {",
                        "    var businessObject = getBusinessObject(descriptor);",
                        "",
                        "    // default sequence flows",
                        "    if (descriptor.default) {",
                        "",
                        "      // relationship cannot be resolved immediately",
                        "      references[ descriptor.default ] = {",
                        "        element: businessObject,",
                        "        property: 'default'",
                        "      };",
                        "    }",
                        "",
                        "    // boundary events",
                        "    if (descriptor.host) {",
                        "",
                        "      // relationship can be resolved immediately",
                        "      getBusinessObject(descriptor).attachedToRef = getBusinessObject(cache[ descriptor.host ]);",
                        "    }",
                        "",
                        "    return omit(references, reduce(references, function(array, reference, key) {",
                        "      var element = reference.element,",
                        "          property = reference.property;",
                        "",
                        "      if (key === descriptor.id) {",
                        "        element.set(property, businessObject);",
                        "",
                        "        array.push(descriptor.id);",
                        "      }",
                        "",
                        "      return array;",
                        "    }, []));",
                        "  }",
                        "",
                        "  eventBus.on('copyPaste.pasteElement', function(context) {",
                        "    var cache = context.cache,",
                        "        descriptor = context.descriptor,",
                        "        businessObject = descriptor.businessObject,",
                        "        di = descriptor.di;",
                        "",
                        "    // wire existing di + businessObject for external label",
                        "    if (isLabel(descriptor)) {",
                        "      descriptor.businessObject = getBusinessObject(cache[ descriptor.labelTarget ]);",
                        "      descriptor.di = getDi(cache[ descriptor.labelTarget ]);",
                        "",
                        "      return;",
                        "    }",
                        "",
                        "    businessObject = descriptor.businessObject = copy(businessObject);",
                        "",
                        "    di = descriptor.di = copy(di);",
                        "    di.bpmnElement = businessObject;",
                        "",
                        "    copyProperties(descriptor, businessObject, [",
                        "      'isExpanded',",
                        "      'name'",
                        "    ]);",
                        "",
                        "    descriptor.type = businessObject.$type;",
                        "  });",
                        "",
                        "  // copy + paste processRef with participant",
                        "",
                        "  eventBus.on('copyPaste.copyElement', LOW_PRIORITY, function(context) {",
                        "    var descriptor = context.descriptor,",
                        "        element = context.element;",
                        "",
                        "    if (!is(element, 'bpmn:Participant')) {",
                        "      return;",
                        "    }",
                        "",
                        "    var participantBo = getBusinessObject(element);",
                        "",
                        "    if (participantBo.processRef) {",
                        "      descriptor.processRef = copy(participantBo.processRef, true);",
                        "    }",
                        "  });",
                        "",
                        "  eventBus.on('copyPaste.pasteElement', function(context) {",
                        "    var descriptor = context.descriptor,",
                        "        processRef = descriptor.processRef;",
                        "",
                        "    if (processRef) {",
                        "      descriptor.processRef = copy(processRef);",
                        "    }",
                        "  });",
                        "",
                        "  // resolve references",
                        "",
                        "  eventBus.on('copyPaste.pasteElement', LOW_PRIORITY, function(context) {",
                        "    var cache = context.cache,",
                        "        descriptor = context.descriptor;",
                        "",
                        "    // resolve references e.g. default sequence flow",
                        "    setReferences(",
                        "      cache,",
                        "      resolveReferences(descriptor, cache, getReferences(cache))",
                        "    );",
                        "  });",
                        "",
                        "}",
                        "",
                        "",
                        "BpmnCopyPaste.$inject = [",
                        "  'bpmnFactory',",
                        "  'eventBus',",
                        "  'moddleCopy'",
                        "];"
                    ]
                },
                "ModdleCopy.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  find,",
                        "  forEach,",
                        "  has,",
                        "  isArray,",
                        "  isDefined,",
                        "  isFunction,",
                        "  isObject,",
                        "  matchPattern,",
                        "  reduce,",
                        "  sortBy",
                        "} from 'min-dash';",
                        "",
                        "var DISALLOWED_PROPERTIES = [",
                        "  'artifacts',",
                        "  'dataInputAssociations',",
                        "  'dataOutputAssociations',",
                        "  'default',",
                        "  'flowElements',",
                        "  'lanes',",
                        "  'incoming',",
                        "  'outgoing',",
                        "  'categoryValue'",
                        "];",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('../modeling/BpmnFactory').default} BpmnFactory",
                        " * @typedef {import('../../model/Types').Moddle} Moddle",
                        " *",
                        " * @typedef {import('../../model/Types').ModdleElement} ModdleElement",
                        " */",
                        "",
                        "/**",
                        " * Utility for copying model properties from source element to target element.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {BpmnFactory} bpmnFactory",
                        " * @param {Moddle} moddle",
                        " */",
                        "export default function ModdleCopy(eventBus, bpmnFactory, moddle) {",
                        "  this._bpmnFactory = bpmnFactory;",
                        "  this._eventBus = eventBus;",
                        "  this._moddle = moddle;",
                        "",
                        "  // copy extension elements last",
                        "  eventBus.on('moddleCopy.canCopyProperties', function(context) {",
                        "    var propertyNames = context.propertyNames;",
                        "",
                        "    if (!propertyNames || !propertyNames.length) {",
                        "      return;",
                        "    }",
                        "",
                        "    return sortBy(propertyNames, function(propertyName) {",
                        "      return propertyName === 'extensionElements';",
                        "    });",
                        "  });",
                        "",
                        "  // default check whether property can be copied",
                        "  eventBus.on('moddleCopy.canCopyProperty', function(context) {",
                        "    var parent = context.parent,",
                        "        parentDescriptor = isObject(parent) && parent.$descriptor,",
                        "        propertyName = context.propertyName;",
                        "",
                        "    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {",
                        "",
                        "      // disallow copying property",
                        "      return false;",
                        "    }",
                        "",
                        "    if (propertyName &&",
                        "      parentDescriptor &&",
                        "      !find(parentDescriptor.properties, matchPattern({ name: propertyName }))) {",
                        "",
                        "      // disallow copying property",
                        "      return false;",
                        "    }",
                        "  });",
                        "",
                        "  // do NOT allow to copy empty extension elements",
                        "  eventBus.on('moddleCopy.canSetCopiedProperty', function(context) {",
                        "    var property = context.property;",
                        "",
                        "    if (is(property, 'bpmn:ExtensionElements') && (!property.values || !property.values.length)) {",
                        "",
                        "      // disallow setting copied property",
                        "      return false;",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "ModdleCopy.$inject = [",
                        "  'eventBus',",
                        "  'bpmnFactory',",
                        "  'moddle'",
                        "];",
                        "",
                        "/**",
                        " * Copy model properties of source element to target element.",
                        " *",
                        " * @param {ModdleElement} sourceElement",
                        " * @param {ModdleElement} targetElement",
                        " * @param {string[]} [propertyNames]",
                        " * @param {boolean} [clone=false]",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "ModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames, clone = false) {",
                        "  var self = this;",
                        "",
                        "  if (propertyNames && !isArray(propertyNames)) {",
                        "    propertyNames = [ propertyNames ];",
                        "  }",
                        "",
                        "  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);",
                        "",
                        "  var canCopyProperties = this._eventBus.fire('moddleCopy.canCopyProperties', {",
                        "    propertyNames: propertyNames,",
                        "    sourceElement: sourceElement,",
                        "    targetElement: targetElement,",
                        "    clone: clone",
                        "  });",
                        "",
                        "  if (canCopyProperties === false) {",
                        "    return targetElement;",
                        "  }",
                        "",
                        "  if (isArray(canCopyProperties)) {",
                        "    propertyNames = canCopyProperties;",
                        "  }",
                        "",
                        "  // copy properties",
                        "  forEach(propertyNames, function(propertyName) {",
                        "    var sourceProperty;",
                        "",
                        "    if (has(sourceElement, propertyName)) {",
                        "      sourceProperty = sourceElement.get(propertyName);",
                        "    }",
                        "",
                        "    var copiedProperty = self.copyProperty(sourceProperty, targetElement, propertyName, clone);",
                        "",
                        "    if (!isDefined(copiedProperty)) {",
                        "      return;",
                        "    }",
                        "",
                        "    var canSetProperty = self._eventBus.fire('moddleCopy.canSetCopiedProperty', {",
                        "      parent: targetElement,",
                        "      property: copiedProperty,",
                        "      propertyName: propertyName",
                        "    });",
                        "",
                        "    if (canSetProperty === false) {",
                        "      return;",
                        "    }",
                        "",
                        "    // TODO(nikku): unclaim old IDs if ID property is copied over",
                        "    // this._moddle.getPropertyDescriptor(parent, propertyName)",
                        "    targetElement.set(propertyName, copiedProperty);",
                        "  });",
                        "",
                        "  return targetElement;",
                        "};",
                        "",
                        "/**",
                        " * Copy model property.",
                        " *",
                        " * @param {any} property",
                        " * @param {ModdleElement} parent",
                        " * @param {string} propertyName",
                        " * @param {boolean} [clone=false]",
                        " *",
                        " * @return {any}",
                        " */",
                        "ModdleCopy.prototype.copyProperty = function(property, parent, propertyName, clone = false) {",
                        "  var self = this;",
                        "",
                        "  // allow others to copy property",
                        "  var copiedProperty = this._eventBus.fire('moddleCopy.canCopyProperty', {",
                        "    parent: parent,",
                        "    property: property,",
                        "    propertyName: propertyName,",
                        "    clone: clone",
                        "  });",
                        "",
                        "  // return if copying is NOT allowed",
                        "  if (copiedProperty === false) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (copiedProperty) {",
                        "    if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {",
                        "      copiedProperty.$parent = parent;",
                        "    }",
                        "",
                        "    return copiedProperty;",
                        "  }",
                        "",
                        "  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);",
                        "",
                        "  // do NOT copy references",
                        "  if (propertyDescriptor.isReference) {",
                        "    return;",
                        "  }",
                        "",
                        "  // copy id",
                        "  if (propertyDescriptor.isId) {",
                        "    return property && this._copyId(property, parent, clone);",
                        "  }",
                        "",
                        "  // copy arrays",
                        "  if (isArray(property)) {",
                        "    return reduce(property, function(childProperties, childProperty) {",
                        "",
                        "      // recursion",
                        "      copiedProperty = self.copyProperty(childProperty, parent, propertyName, clone);",
                        "",
                        "      // copying might NOT be allowed",
                        "      if (copiedProperty) {",
                        "        return childProperties.concat(copiedProperty);",
                        "      }",
                        "",
                        "      return childProperties;",
                        "    }, []);",
                        "  }",
                        "",
                        "  // copy model elements",
                        "  if (isObject(property) && property.$type) {",
                        "    if (this._moddle.getElementDescriptor(property).isGeneric) {",
                        "      return;",
                        "    }",
                        "",
                        "    copiedProperty = self._bpmnFactory.create(property.$type);",
                        "",
                        "    copiedProperty.$parent = parent;",
                        "",
                        "    // recursion",
                        "    copiedProperty = self.copyElement(property, copiedProperty, null, clone);",
                        "",
                        "    return copiedProperty;",
                        "  }",
                        "",
                        "  // copy primitive properties",
                        "  return property;",
                        "};",
                        "",
                        "ModdleCopy.prototype._copyId = function(id, element, clone = false) {",
                        "  if (clone) {",
                        "    return id;",
                        "  }",
                        "",
                        "  // disallow if already taken",
                        "  if (this._moddle.ids.assigned(id)) {",
                        "    return;",
                        "  } else {",
                        "",
                        "    this._moddle.ids.claim(id, element);",
                        "    return id;",
                        "  }",
                        "};",
                        "",
                        "// helpers //////////",
                        "",
                        "export function getPropertyNames(descriptor, keepDefaultProperties) {",
                        "  return reduce(descriptor.properties, function(properties, property) {",
                        "",
                        "    if (keepDefaultProperties && property.default) {",
                        "      return properties;",
                        "    }",
                        "",
                        "    return properties.concat(property.name);",
                        "  }, []);",
                        "}",
                        "",
                        "function is(element, type) {",
                        "  return element && isFunction(element.$instanceOf) && element.$instanceOf(type);",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import CopyPasteModule from 'diagram-js/lib/features/copy-paste';",
                        "",
                        "import BpmnCopyPaste from './BpmnCopyPaste';",
                        "import ModdleCopy from './ModdleCopy';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    CopyPasteModule",
                        "  ],",
                        "  __init__: [ 'bpmnCopyPaste', 'moddleCopy' ],",
                        "  bpmnCopyPaste: [ 'type', BpmnCopyPaste ],",
                        "  moddleCopy: [ 'type', ModdleCopy ]",
                        "};"
                    ]
                }
            },
            "di-ordering": {
                "BpmnDiOrdering.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { getDi } from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  filter,",
                        "  forEach,",
                        "  map",
                        "} from 'min-dash';",
                        "",
                        "import { selfAndAllChildren } from 'diagram-js/lib/util/Elements';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " */",
                        "",
                        "var HIGH_PRIORITY = 2000;",
                        "",
                        "/**",
                        " * @param {EventBus} eventBus",
                        " * @param {Canvas} canvas",
                        " */",
                        "export default function BpmnDiOrdering(eventBus, canvas) {",
                        "",
                        "  eventBus.on('saveXML.start', HIGH_PRIORITY, orderDi);",
                        "",
                        "  function orderDi() {",
                        "    var rootElements = canvas.getRootElements();",
                        "",
                        "    forEach(rootElements, function(root) {",
                        "      var rootDi = getDi(root),",
                        "          elements,",
                        "          diElements;",
                        "",
                        "      elements = selfAndAllChildren([ root ], false);",
                        "",
                        "      // only bpmndi:Shape and bpmndi:Edge can be direct children of bpmndi:Plane",
                        "      elements = filter(elements, function(element) {",
                        "        return element !== root && !element.labelTarget;",
                        "      });",
                        "",
                        "      diElements = map(elements, getDi);",
                        "",
                        "      rootDi.set('planeElement', diElements);",
                        "    });",
                        "  }",
                        "}",
                        "",
                        "BpmnDiOrdering.$inject = [ 'eventBus', 'canvas' ];"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import BpmnDiOrdering from '../di-ordering/BpmnDiOrdering';",
                        "",
                        "export default {",
                        "  __init__: [",
                        "    'bpmnDiOrdering'",
                        "  ],",
                        "  bpmnDiOrdering: [ 'type', BpmnDiOrdering ]",
                        "};"
                    ]
                }
            },
            "distribute-elements": {
                "BpmnDistributeElements.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';",
                        "import { getParents } from 'diagram-js/lib/util/Elements';",
                        "",
                        "import {",
                        "  filter",
                        "} from 'min-dash';",
                        "",
                        "import {",
                        "  isAny",
                        "} from '../modeling/util/ModelingUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " */",
                        "",
                        "/**",
                        " * Registers element exclude filters for elements that currently do not support",
                        " * distribution.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " */",
                        "export default function BpmnDistributeElements(eventBus) {",
                        "  RuleProvider.call(this, eventBus);",
                        "}",
                        "",
                        "BpmnDistributeElements.$inject = [ 'eventBus' ];",
                        "",
                        "inherits(BpmnDistributeElements, RuleProvider);",
                        "",
                        "BpmnDistributeElements.prototype.init = function() {",
                        "  this.addRule('elements.distribute', function(context) {",
                        "    var elements = context.elements;",
                        "",
                        "    elements = filter(elements, function(element) {",
                        "      var cannotDistribute = isAny(element, [",
                        "        'bpmn:Association',",
                        "        'bpmn:BoundaryEvent',",
                        "        'bpmn:DataInputAssociation',",
                        "        'bpmn:DataOutputAssociation',",
                        "        'bpmn:Lane',",
                        "        'bpmn:MessageFlow',",
                        "        'bpmn:SequenceFlow',",
                        "        'bpmn:TextAnnotation'",
                        "      ]);",
                        "",
                        "      return !(element.labelTarget || cannotDistribute);",
                        "    });",
                        "",
                        "    // filter out elements which are children of any of the selected elements",
                        "    elements = getParents(elements);",
                        "",
                        "    if (elements.length < 3) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return elements;",
                        "  });",
                        "};"
                    ]
                },
                "DistributeElementsIcons.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * To change the icons, modify the SVGs in `./resources`, execute `npx svgo -f resources --datauri enc -o dist`,",
                        " * and then replace respective icons with the optimized data URIs in `./dist`.",
                        " */",
                        "var icons = {",
                        "  horizontal: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1800 1800\">",
                        "                <polyline points=\"450 400 450 150 1350 150 1350 400\" style=\"fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;\"/>",
                        "                <rect x=\"150\" y=\"450\" width=\"600\" height=\"1200\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "                <rect x=\"1050\" y=\"450\" width=\"600\" height=\"800\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "              </svg>`,",
                        "  vertical: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1800 1800\">",
                        "              <polyline points=\"400 1350 150 1350 150 450 400 450\" style=\"fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;\"/>",
                        "              <rect x=\"450\" y=\"150\" width=\"1200\" height=\"600\" rx=\"1\" style=\"fill:none;stroke:currentColor;stroke-width:100;\"></rect>",
                        "              <rect x=\"450\" y=\"1050\" width=\"800\" height=\"600\" rx=\"1\" style=\"fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;\"></rect>",
                        "            </svg>`",
                        "};",
                        "",
                        "export default icons;"
                    ]
                },
                "DistributeElementsMenuProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import ICONS from './DistributeElementsIcons';",
                        "",
                        "import { assign } from 'min-dash';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').default} PopupMenu",
                        " * @typedef {import('./BpmnDistributeElements').default} DistributeElements",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " * @typedef {import('diagram-js/lib/features/rules/Rules').default} Rules",
                        " *",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenuProvider').PopupMenuEntries} PopupMenuEntries",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenuProvider').default} PopupMenuProvider",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').PopupMenuTarget} PopupMenuTarget",
                        " */",
                        "",
                        "var LOW_PRIORITY = 900;",
                        "",
                        "/**",
                        " * A provider for the distribute elements popup menu.",
                        " *",
                        " * @implements {PopupMenuProvider}",
                        " *",
                        " * @param {PopupMenu} popupMenu",
                        " * @param {DistributeElements} distributeElements",
                        " * @param {Translate} translate",
                        " * @param {Rules} rules",
                        " */",
                        "export default function DistributeElementsMenuProvider(",
                        "    popupMenu, distributeElements, translate, rules) {",
                        "  this._distributeElements = distributeElements;",
                        "  this._translate = translate;",
                        "  this._popupMenu = popupMenu;",
                        "  this._rules = rules;",
                        "",
                        "  popupMenu.registerProvider('align-elements', LOW_PRIORITY, this);",
                        "}",
                        "",
                        "DistributeElementsMenuProvider.$inject = [",
                        "  'popupMenu',",
                        "  'distributeElements',",
                        "  'translate',",
                        "  'rules'",
                        "];",
                        "",
                        "/**",
                        " * @param {PopupMenuTarget} target",
                        " *",
                        " * @return {PopupMenuEntries}",
                        " */",
                        "DistributeElementsMenuProvider.prototype.getPopupMenuEntries = function(target) {",
                        "  var entries = {};",
                        "",
                        "  if (this._isAllowed(target)) {",
                        "    assign(entries, this._getEntries(target));",
                        "  }",
                        "",
                        "  return entries;",
                        "};",
                        "",
                        "DistributeElementsMenuProvider.prototype._isAllowed = function(elements) {",
                        "  return this._rules.allowed('elements.distribute', { elements: elements });",
                        "};",
                        "",
                        "DistributeElementsMenuProvider.prototype._getEntries = function(elements) {",
                        "  var distributeElements = this._distributeElements,",
                        "      translate = this._translate,",
                        "      popupMenu = this._popupMenu;",
                        "",
                        "  var entries = {",
                        "    'distribute-elements-horizontal': {",
                        "      group: 'distribute',",
                        "      title: translate('Distribute elements horizontally'),",
                        "      className: 'bjs-align-elements-menu-entry',",
                        "      imageHtml: ICONS['horizontal'],",
                        "      action: function(event, entry) {",
                        "        distributeElements.trigger(elements, 'horizontal');",
                        "        popupMenu.close();",
                        "      }",
                        "    },",
                        "    'distribute-elements-vertical': {",
                        "      group: 'distribute',",
                        "      title: translate('Distribute elements vertically'),",
                        "      imageHtml: ICONS['vertical'],",
                        "      action: function(event, entry) {",
                        "        distributeElements.trigger(elements, 'vertical');",
                        "        popupMenu.close();",
                        "      }",
                        "    },",
                        "  };",
                        "",
                        "  return entries;",
                        "};"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import DistributeElementsModule from 'diagram-js/lib/features/distribute-elements';",
                        "import PopupMenuModule from 'diagram-js/lib/features/popup-menu';",
                        "",
                        "import BpmnDistributeElements from './BpmnDistributeElements';",
                        "import DistributeElementsMenuProvider from './DistributeElementsMenuProvider';",
                        "",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    PopupMenuModule,",
                        "    DistributeElementsModule",
                        "  ],",
                        "  __init__: [",
                        "    'bpmnDistributeElements',",
                        "    'distributeElementsMenuProvider'",
                        "  ],",
                        "  bpmnDistributeElements: [ 'type', BpmnDistributeElements ],",
                        "  distributeElementsMenuProvider: [ 'type', DistributeElementsMenuProvider ]",
                        "};"
                    ]
                }
            },
            "drilldown": {
                "DrilldownBreadcrumbs.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { domify, classes } from 'min-dom';",
                        "import { find } from 'min-dash';",
                        "",
                        "import { escapeHTML } from 'diagram-js/lib/util/EscapeUtil';",
                        "import { getBusinessObject, is } from '../../util/ModelUtil';",
                        "import {",
                        "  getPlaneIdFromShape",
                        "} from '../../util/DrilldownUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " */",
                        "",
                        "var OPEN_CLASS = 'bjs-breadcrumbs-shown';",
                        "",
                        "",
                        "/**",
                        " * Adds overlays that allow switching planes on collapsed subprocesses.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {ElementRegistry} elementRegistry",
                        " * @param {Canvas} canvas",
                        " */",
                        "export default function DrilldownBreadcrumbs(eventBus, elementRegistry, canvas) {",
                        "  var breadcrumbs = domify('<ul class=\"bjs-breadcrumbs\"></ul>');",
                        "  var container = canvas.getContainer();",
                        "  var containerClasses = classes(container);",
                        "  container.appendChild(breadcrumbs);",
                        "",
                        "  var businessObjectParents = [];",
                        "",
                        "  // update breadcrumbs if name or ID of the primary shape changes",
                        "  eventBus.on('element.changed', function(event) {",
                        "    var shape = event.element,",
                        "        businessObject = getBusinessObject(shape);",
                        "",
                        "    var isPresent = find(businessObjectParents, function(element) {",
                        "      return element === businessObject;",
                        "    });",
                        "",
                        "    if (!isPresent) {",
                        "      return;",
                        "    }",
                        "",
                        "    updateBreadcrumbs();",
                        "  });",
                        "",
                        "  /**",
                        "   * Updates the displayed breadcrumbs. If no element is provided, only the",
                        "   * labels are updated.",
                        "   *",
                        "   * @param {Element} [element]",
                        "   */",
                        "  function updateBreadcrumbs(element) {",
                        "    if (element) {",
                        "      businessObjectParents = getBusinessObjectParentChain(element);",
                        "    }",
                        "",
                        "    var path = businessObjectParents.map(function(parent) {",
                        "      var title = escapeHTML(parent.name || parent.id);",
                        "      var link = domify('<li><span class=\"bjs-crumb\"><a title=\"' + title + '\">' + title + '</a></span></li>');",
                        "",
                        "      var parentPlane = canvas.findRoot(getPlaneIdFromShape(parent)) || canvas.findRoot(parent.id);",
                        "",
                        "      // when the root is a collaboration, the process does not have a corresponding",
                        "      // element in the elementRegisty. Instead, we search for the corresponding participant",
                        "      if (!parentPlane && is(parent, 'bpmn:Process')) {",
                        "        var participant = elementRegistry.find(function(element) {",
                        "          var businessObject = getBusinessObject(element);",
                        "",
                        "          return businessObject && businessObject.get('processRef') && businessObject.get('processRef') === parent;",
                        "        });",
                        "",
                        "        parentPlane = canvas.findRoot(participant.id);",
                        "      }",
                        "",
                        "      link.addEventListener('click', function() {",
                        "        canvas.setRootElement(parentPlane);",
                        "      });",
                        "",
                        "      return link;",
                        "    });",
                        "",
                        "    breadcrumbs.innerHTML = '';",
                        "",
                        "    // show breadcrumbs and expose state to .djs-container",
                        "    var visible = path.length > 1;",
                        "",
                        "    containerClasses.toggle(OPEN_CLASS, visible);",
                        "",
                        "    path.forEach(function(element) {",
                        "      breadcrumbs.appendChild(element);",
                        "    });",
                        "  }",
                        "",
                        "  eventBus.on('root.set', function(event) {",
                        "    updateBreadcrumbs(event.element);",
                        "  });",
                        "",
                        "}",
                        "",
                        "DrilldownBreadcrumbs.$inject = [ 'eventBus', 'elementRegistry', 'canvas' ];",
                        "",
                        "",
                        "// helpers //////////",
                        "",
                        "/**",
                        " * Returns the parents for the element using the business object chain,",
                        " * starting with the root element.",
                        " *",
                        " * @param {Shape} child",
                        " *",
                        " * @return {Shape}",
                        " */",
                        "function getBusinessObjectParentChain(child) {",
                        "  var businessObject = getBusinessObject(child);",
                        "",
                        "  var parents = [];",
                        "",
                        "  for (var element = businessObject; element; element = element.$parent) {",
                        "    if (is(element, 'bpmn:SubProcess') || is(element, 'bpmn:Process')) {",
                        "      parents.push(element);",
                        "    }",
                        "  }",
                        "",
                        "  return parents.reverse();",
                        "}"
                    ]
                },
                "DrilldownCentering.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " */",
                        "",
                        "/**",
                        " * Move collapsed subprocesses into view when drilling down.",
                        " *",
                        " * Zoom and scroll are saved in a session.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {Canvas} canvas",
                        " */",
                        "export default function DrilldownCentering(eventBus, canvas) {",
                        "",
                        "  var currentRoot = null;",
                        "  var positionMap = new Map();",
                        "",
                        "  eventBus.on('root.set', function(event) {",
                        "    var newRoot = event.element;",
                        "    var currentViewbox = canvas.viewbox();",
                        "    var storedViewbox = positionMap.get(newRoot);",
                        "",
                        "    positionMap.set(currentRoot, {",
                        "      x: currentViewbox.x,",
                        "      y: currentViewbox.y,",
                        "      zoom: currentViewbox.scale",
                        "    });",
                        "",
                        "    currentRoot = newRoot;",
                        "",
                        "    // current root was replaced with a collaboration, we don't update the viewbox",
                        "    if (is(newRoot, 'bpmn:Collaboration') && !storedViewbox) {",
                        "      return;",
                        "    }",
                        "",
                        "    storedViewbox = storedViewbox || { x: 0, y: 0, zoom: 1 };",
                        "",
                        "    var dx = (currentViewbox.x - storedViewbox.x) * currentViewbox.scale,",
                        "        dy = (currentViewbox.y - storedViewbox.y) * currentViewbox.scale;",
                        "",
                        "    if (dx !== 0 || dy !== 0) {",
                        "      canvas.scroll({",
                        "        dx: dx,",
                        "        dy: dy",
                        "      });",
                        "    }",
                        "",
                        "    if (storedViewbox.zoom !== currentViewbox.scale) {",
                        "      canvas.zoom(storedViewbox.zoom, { x: 0, y: 0 });",
                        "    }",
                        "  });",
                        "",
                        "  eventBus.on('diagram.clear', function() {",
                        "    positionMap.clear();",
                        "    currentRoot = null;",
                        "  });",
                        "",
                        "}",
                        "",
                        "DrilldownCentering.$inject = [ 'eventBus', 'canvas' ];",
                        "",
                        "",
                        "/**",
                        " * ES5 Map implementation. Works.",
                        " */",
                        "function Map() {",
                        "",
                        "  this._entries = [];",
                        "",
                        "  this.set = function(key, value) {",
                        "",
                        "    var found = false;",
                        "",
                        "    for (var k in this._entries) {",
                        "      if (this._entries[k][0] === key) {",
                        "        this._entries[k][1] = value;",
                        "",
                        "        found = true;",
                        "",
                        "        break;",
                        "      }",
                        "    }",
                        "",
                        "    if (!found) {",
                        "      this._entries.push([ key, value ]);",
                        "    }",
                        "  };",
                        "",
                        "  this.get = function(key) {",
                        "",
                        "    for (var k in this._entries) {",
                        "      if (this._entries[k][0] === key) {",
                        "        return this._entries[k][1];",
                        "      }",
                        "    }",
                        "",
                        "    return null;",
                        "  };",
                        "",
                        "  this.clear = function() {",
                        "    this._entries.length = 0;",
                        "  };",
                        "",
                        "  this.remove = function(key) {",
                        "",
                        "    var idx = -1;",
                        "",
                        "    for (var k in this._entries) {",
                        "      if (this._entries[k][0] === key) {",
                        "        idx = k;",
                        "",
                        "        break;",
                        "      }",
                        "    }",
                        "",
                        "    if (idx !== -1) {",
                        "      this._entries.splice(idx, 1);",
                        "    }",
                        "  };",
                        "}"
                    ]
                },
                "DrilldownOverlayBehavior.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                        "import { getBusinessObject, is } from '../../util/ModelUtil';",
                        "import { classes, domify } from 'min-dom';",
                        "import { getPlaneIdFromShape } from '../../util/DrilldownUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('diagram-js/lib/features/overlays/Overlays').default} Overlays",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Parent} Parent",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " */",
                        "",
                        "var LOW_PRIORITY = 250;",
                        "var ARROW_DOWN_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z\"/></svg>';",
                        "",
                        "var EMPTY_MARKER = 'bjs-drilldown-empty';",
                        "",
                        "/**",
                        " * @param {Canvas} canvas",
                        " * @param {EventBus} eventBus",
                        " * @param {ElementRegistry} elementRegistry",
                        " * @param {Overlays} overlays",
                        " */",
                        "export default function DrilldownOverlayBehavior(",
                        "    canvas, eventBus, elementRegistry, overlays",
                        ") {",
                        "  CommandInterceptor.call(this, eventBus);",
                        "",
                        "  this._canvas = canvas;",
                        "  this._eventBus = eventBus;",
                        "  this._elementRegistry = elementRegistry;",
                        "  this._overlays = overlays;",
                        "",
                        "  var self = this;",
                        "",
                        "  this.executed('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                        "    var shape = context.shape;",
                        "",
                        "    // Add overlay to the collapsed shape",
                        "    if (self._canDrillDown(shape)) {",
                        "      self._addOverlay(shape);",
                        "    } else {",
                        "      self._removeOverlay(shape);",
                        "    }",
                        "  }, true);",
                        "",
                        "",
                        "  this.reverted('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                        "    var shape = context.shape;",
                        "",
                        "    // Add overlay to the collapsed shape",
                        "    if (self._canDrillDown(shape)) {",
                        "      self._addOverlay(shape);",
                        "    } else {",
                        "      self._removeOverlay(shape);",
                        "    }",
                        "  }, true);",
                        "",
                        "",
                        "  this.executed([ 'shape.create', 'shape.move', 'shape.delete' ], LOW_PRIORITY,",
                        "    function(context) {",
                        "      var oldParent = context.oldParent,",
                        "          newParent = context.newParent || context.parent,",
                        "          shape = context.shape;",
                        "",
                        "      // Add overlay to the collapsed shape",
                        "      if (self._canDrillDown(shape)) {",
                        "        self._addOverlay(shape);",
                        "      }",
                        "",
                        "      self._updateDrilldownOverlay(oldParent);",
                        "      self._updateDrilldownOverlay(newParent);",
                        "      self._updateDrilldownOverlay(shape);",
                        "    }, true);",
                        "",
                        "",
                        "  this.reverted([ 'shape.create', 'shape.move', 'shape.delete' ], LOW_PRIORITY,",
                        "    function(context) {",
                        "      var oldParent = context.oldParent,",
                        "          newParent = context.newParent || context.parent,",
                        "          shape = context.shape;",
                        "",
                        "      // Add overlay to the collapsed shape",
                        "      if (self._canDrillDown(shape)) {",
                        "        self._addOverlay(shape);",
                        "      }",
                        "",
                        "      self._updateDrilldownOverlay(oldParent);",
                        "      self._updateDrilldownOverlay(newParent);",
                        "      self._updateDrilldownOverlay(shape);",
                        "    }, true);",
                        "",
                        "",
                        "  eventBus.on('import.render.complete', function() {",
                        "    elementRegistry.filter(function(e) {",
                        "      return self._canDrillDown(e);",
                        "    }).map(function(el) {",
                        "      self._addOverlay(el);",
                        "    });",
                        "  });",
                        "",
                        "}",
                        "",
                        "inherits(DrilldownOverlayBehavior, CommandInterceptor);",
                        "",
                        "/**",
                        " * @param {Shape} shape",
                        " */",
                        "DrilldownOverlayBehavior.prototype._updateDrilldownOverlay = function(shape) {",
                        "  var canvas = this._canvas;",
                        "",
                        "  if (!shape) {",
                        "    return;",
                        "  }",
                        "",
                        "  var root = canvas.findRoot(shape);",
                        "",
                        "  if (root) {",
                        "    this._updateOverlayVisibility(root);",
                        "  }",
                        "};",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "DrilldownOverlayBehavior.prototype._canDrillDown = function(element) {",
                        "  var canvas = this._canvas;",
                        "",
                        "  return is(element, 'bpmn:SubProcess') && canvas.findRoot(getPlaneIdFromShape(element));",
                        "};",
                        "",
                        "/**",
                        " * Update the visibility of the drilldown overlay. If the plane has no elements,",
                        " * the drilldown will only be shown when the element is selected.",
                        " *",
                        " * @param {Parent} element The collapsed root or shape.",
                        " */",
                        "DrilldownOverlayBehavior.prototype._updateOverlayVisibility = function(element) {",
                        "  var overlays = this._overlays;",
                        "",
                        "  var businessObject = getBusinessObject(element);",
                        "",
                        "  var overlay = overlays.get({ element: businessObject.id, type: 'drilldown' })[0];",
                        "",
                        "  if (!overlay) {",
                        "    return;",
                        "  }",
                        "",
                        "  var hasFlowElements = businessObject",
                        "    && businessObject.get('flowElements')",
                        "    && businessObject.get('flowElements').length;",
                        "",
                        "  classes(overlay.html).toggle(EMPTY_MARKER, !hasFlowElements);",
                        "};",
                        "",
                        "/**",
                        " * Add a drilldown button to the given element assuming the plane has the same",
                        " * ID as the element.",
                        " *",
                        " * @param {Shape} element The collapsed shape.",
                        " */",
                        "DrilldownOverlayBehavior.prototype._addOverlay = function(element) {",
                        "  var canvas = this._canvas,",
                        "      overlays = this._overlays;",
                        "",
                        "  var existingOverlays = overlays.get({ element: element, type: 'drilldown' });",
                        "",
                        "  if (existingOverlays.length) {",
                        "    this._removeOverlay(element);",
                        "  }",
                        "",
                        "  var button = domify('<button class=\"bjs-drilldown\">' + ARROW_DOWN_SVG + '</button>');",
                        "",
                        "  button.addEventListener('click', function() {",
                        "    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));",
                        "  });",
                        "",
                        "  overlays.add(element, 'drilldown', {",
                        "    position: {",
                        "      bottom: -7,",
                        "      right: -8",
                        "    },",
                        "    html: button",
                        "  });",
                        "",
                        "  this._updateOverlayVisibility(element);",
                        "};",
                        "",
                        "DrilldownOverlayBehavior.prototype._removeOverlay = function(element) {",
                        "  var overlays = this._overlays;",
                        "",
                        "  overlays.remove({",
                        "    element: element,",
                        "    type: 'drilldown'",
                        "  });",
                        "};",
                        "",
                        "DrilldownOverlayBehavior.$inject = [",
                        "  'canvas',",
                        "  'eventBus',",
                        "  'elementRegistry',",
                        "  'overlays'",
                        "];"
                    ]
                },
                "SubprocessCompatibility.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "",
                        "import { asBounds, asTRBL } from 'diagram-js/lib/layout/LayoutUtil';",
                        "import { is, isAny } from '../../util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('../../model/Types').Moddle} Moddle",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " *",
                        " * @typedef {import('diagram-js/lib/core/Canvas').CanvasPlane} CanvasPlane",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                        " */",
                        "",
                        "var DEFAULT_POSITION = {",
                        "  x: 180,",
                        "  y: 160",
                        "};",
                        "",
                        "/**",
                        " * Hook into `import.render.start` and create new planes for diagrams with",
                        " * collapsed subprocesses and all DI elements on the same plane.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {Moddle} moddle",
                        " */",
                        "export default function SubprocessCompatibility(eventBus, moddle) {",
                        "  this._eventBus = eventBus;",
                        "  this._moddle = moddle;",
                        "",
                        "  var self = this;",
                        "",
                        "  eventBus.on('import.render.start', 1500, function(e, context) {",
                        "    self._handleImport(context.definitions);",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {ModdleElement} definitions",
                        " */",
                        "SubprocessCompatibility.prototype._handleImport = function(definitions) {",
                        "  if (!definitions.diagrams) {",
                        "    return;",
                        "  }",
                        "",
                        "  var self = this;",
                        "  this._definitions = definitions;",
                        "  this._processToDiagramMap = {};",
                        "",
                        "  definitions.diagrams.forEach(function(diagram) {",
                        "    if (!diagram.plane || !diagram.plane.bpmnElement) {",
                        "      return;",
                        "    }",
                        "",
                        "    self._processToDiagramMap[diagram.plane.bpmnElement.id] = diagram;",
                        "  });",
                        "",
                        "  var newDiagrams = [];",
                        "  definitions.diagrams.forEach(function(diagram) {",
                        "    var createdDiagrams = self._createNewDiagrams(diagram.plane);",
                        "    Array.prototype.push.apply(newDiagrams, createdDiagrams);",
                        "  });",
                        "",
                        "  newDiagrams.forEach(function(diagram) {",
                        "    self._movePlaneElementsToOrigin(diagram.plane);",
                        "  });",
                        "};",
                        "",
                        "",
                        "/**",
                        " * Moves all DI elements from collapsed subprocesses to a new plane.",
                        " *",
                        " * @param {CanvasPlane} plane",
                        " *",
                        " * @return {ModdleElement[]} new diagrams created for the collapsed subprocesses",
                        " */",
                        "SubprocessCompatibility.prototype._createNewDiagrams = function(plane) {",
                        "  var self = this;",
                        "",
                        "  var collapsedElements = [];",
                        "  var elementsToMove = [];",
                        "",
                        "  plane.get('planeElement').forEach(function(diElement) {",
                        "    var businessObject = diElement.bpmnElement;",
                        "",
                        "    if (!businessObject) {",
                        "      return;",
                        "    }",
                        "",
                        "    var parent = businessObject.$parent;",
                        "",
                        "    if (is(businessObject, 'bpmn:SubProcess') && !diElement.isExpanded) {",
                        "      collapsedElements.push(businessObject);",
                        "    }",
                        "",
                        "    if (shouldMoveToPlane(businessObject, plane)) {",
                        "",
                        "      // don't change the array while we iterate over it",
                        "      elementsToMove.push({ diElement: diElement, parent: parent });",
                        "    }",
                        "  });",
                        "",
                        "  var newDiagrams = [];",
                        "",
                        "  // create new planes for all collapsed subprocesses, even when they are empty",
                        "  collapsedElements.forEach(function(element) {",
                        "    if (!self._processToDiagramMap[ element.id ]) {",
                        "      var diagram = self._createDiagram(element);",
                        "",
                        "      self._processToDiagramMap[element.id] = diagram;",
                        "",
                        "      newDiagrams.push(diagram);",
                        "    }",
                        "  });",
                        "",
                        "  elementsToMove.forEach(function(element) {",
                        "    var diElement = element.diElement;",
                        "    var parent = element.parent;",
                        "",
                        "    // parent is expanded, get nearest collapsed parent",
                        "    while (parent && collapsedElements.indexOf(parent) === -1) {",
                        "      parent = parent.$parent;",
                        "    }",
                        "",
                        "    // false positive, all parents are expanded",
                        "    if (!parent) {",
                        "      return;",
                        "    }",
                        "",
                        "    var diagram = self._processToDiagramMap[ parent.id ];",
                        "",
                        "    self._moveToDiPlane(diElement, diagram.plane);",
                        "  });",
                        "",
                        "  return newDiagrams;",
                        "};",
                        "",
                        "/**",
                        " * @param {CanvasPlane} plane",
                        " */",
                        "SubprocessCompatibility.prototype._movePlaneElementsToOrigin = function(plane) {",
                        "  var elements = plane.get('planeElement');",
                        "",
                        "  // get bounding box of all elements",
                        "  var planeBounds = getPlaneBounds(plane);",
                        "",
                        "  var offset = {",
                        "    x: planeBounds.x - DEFAULT_POSITION.x,",
                        "    y: planeBounds.y - DEFAULT_POSITION.y",
                        "  };",
                        "",
                        "  elements.forEach(function(diElement) {",
                        "    if (diElement.waypoint) {",
                        "      diElement.waypoint.forEach(function(waypoint) {",
                        "        waypoint.x = waypoint.x - offset.x;",
                        "        waypoint.y = waypoint.y - offset.y;",
                        "      });",
                        "    } else if (diElement.bounds) {",
                        "      diElement.bounds.x = diElement.bounds.x - offset.x;",
                        "      diElement.bounds.y = diElement.bounds.y - offset.y;",
                        "    }",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} diElement",
                        " * @param {CanvasPlane} newPlane",
                        " */",
                        "SubprocessCompatibility.prototype._moveToDiPlane = function(diElement, newPlane) {",
                        "  var containingDiagram = findRootDiagram(diElement);",
                        "",
                        "  // remove DI from old Plane and add it to the new one",
                        "  var parentPlaneElement = containingDiagram.plane.get('planeElement');",
                        "",
                        "  parentPlaneElement.splice(parentPlaneElement.indexOf(diElement), 1);",
                        "",
                        "  newPlane.get('planeElement').push(diElement);",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} businessObject",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "SubprocessCompatibility.prototype._createDiagram = function(businessObject) {",
                        "  var plane = this._moddle.create('bpmndi:BPMNPlane', {",
                        "    bpmnElement: businessObject",
                        "  });",
                        "",
                        "  var diagram = this._moddle.create('bpmndi:BPMNDiagram', {",
                        "    plane: plane",
                        "  });",
                        "",
                        "  plane.$parent = diagram;",
                        "",
                        "  plane.bpmnElement = businessObject;",
                        "",
                        "  diagram.$parent = this._definitions;",
                        "",
                        "  this._definitions.diagrams.push(diagram);",
                        "",
                        "  return diagram;",
                        "};",
                        "",
                        "SubprocessCompatibility.$inject = [ 'eventBus', 'moddle' ];",
                        "",
                        "",
                        "// helpers //////////",
                        "",
                        "function findRootDiagram(element) {",
                        "  if (is(element, 'bpmndi:BPMNDiagram')) {",
                        "    return element;",
                        "  } else {",
                        "    return findRootDiagram(element.$parent);",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {CanvasPlane} plane",
                        " *",
                        " * @return {Rect}",
                        " */",
                        "function getPlaneBounds(plane) {",
                        "  var planeTrbl = {",
                        "    top: Infinity,",
                        "    right: -Infinity,",
                        "    bottom: -Infinity,",
                        "    left: Infinity",
                        "  };",
                        "",
                        "  plane.planeElement.forEach(function(element) {",
                        "    if (!element.bounds) {",
                        "      return;",
                        "    }",
                        "",
                        "    var trbl = asTRBL(element.bounds);",
                        "",
                        "    planeTrbl.top = Math.min(trbl.top, planeTrbl.top);",
                        "    planeTrbl.left = Math.min(trbl.left, planeTrbl.left);",
                        "  });",
                        "",
                        "  return asBounds(planeTrbl);",
                        "}",
                        "",
                        "/**",
                        " * @param {ModdleElement} businessObject",
                        " * @param {CanvasPlane} plane",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function shouldMoveToPlane(businessObject, plane) {",
                        "  var parent = businessObject.$parent;",
                        "",
                        "  // don't move elements that are already on the plane",
                        "  if (!is(parent, 'bpmn:SubProcess') || parent === plane.bpmnElement) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // dataAssociations are children of the subprocess but rendered on process level",
                        "  // cf. https://github.com/bpmn-io/bpmn-js/issues/1619",
                        "  if (isAny(businessObject, [ 'bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation' ])) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import OverlaysModule from 'diagram-js/lib/features/overlays';",
                        "import ChangeSupportModule from 'diagram-js/lib/features/change-support';",
                        "import RootElementsModule from 'diagram-js/lib/features/root-elements';",
                        "",
                        "import DrilldownBreadcrumbs from './DrilldownBreadcrumbs';",
                        "import DrilldownCentering from './DrilldownCentering';",
                        "import SubprocessCompatibility from './SubprocessCompatibility';",
                        "import DrilldownOverlayBehavior from './DrilldownOverlayBehavior';",
                        "",
                        "export default {",
                        "  __depends__: [ OverlaysModule, ChangeSupportModule, RootElementsModule ],",
                        "  __init__: [ 'drilldownBreadcrumbs', 'drilldownOverlayBehavior', 'drilldownCentering', 'subprocessCompatibility' ],",
                        "  drilldownBreadcrumbs: [ 'type', DrilldownBreadcrumbs ],",
                        "  drilldownCentering: [ 'type', DrilldownCentering ],",
                        "  drilldownOverlayBehavior: [ 'type', DrilldownOverlayBehavior ],",
                        "  subprocessCompatibility: [ 'type', SubprocessCompatibility ]",
                        "};"
                    ]
                }
            },
            "editor-actions": {
                "BpmnEditorActions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import EditorActions from 'diagram-js/lib/features/editor-actions/EditorActions';",
                        "",
                        "import { filter } from 'min-dash';",
                        "",
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  getBBox",
                        "} from 'diagram-js/lib/util/Elements';",
                        "",
                        "/**",
                        " * @typedef {import('didi').Injector} Injector",
                        " */",
                        "",
                        "/**",
                        " * Registers and executes BPMN specific editor actions.",
                        " *",
                        " * @param {Injector} injector",
                        " */",
                        "export default function BpmnEditorActions(injector) {",
                        "  injector.invoke(EditorActions, this);",
                        "}",
                        "",
                        "inherits(BpmnEditorActions, EditorActions);",
                        "",
                        "BpmnEditorActions.$inject = [",
                        "  'injector'",
                        "];",
                        "",
                        "/**",
                        " * Register default actions.",
                        " *",
                        " * @param {Injector} injector",
                        " */",
                        "BpmnEditorActions.prototype._registerDefaultActions = function(injector) {",
                        "",
                        "  // (0) invoke super method",
                        "",
                        "  EditorActions.prototype._registerDefaultActions.call(this, injector);",
                        "",
                        "  // (1) retrieve optional components to integrate with",
                        "",
                        "  var canvas = injector.get('canvas', false);",
                        "  var elementRegistry = injector.get('elementRegistry', false);",
                        "  var selection = injector.get('selection', false);",
                        "  var spaceTool = injector.get('spaceTool', false);",
                        "  var lassoTool = injector.get('lassoTool', false);",
                        "  var handTool = injector.get('handTool', false);",
                        "  var globalConnect = injector.get('globalConnect', false);",
                        "  var distributeElements = injector.get('distributeElements', false);",
                        "  var alignElements = injector.get('alignElements', false);",
                        "  var directEditing = injector.get('directEditing', false);",
                        "  var searchPad = injector.get('searchPad', false);",
                        "  var modeling = injector.get('modeling', false);",
                        "  var contextPad = injector.get('contextPad', false);",
                        "",
                        "  // (2) check components and register actions",
                        "",
                        "  if (canvas && elementRegistry && selection) {",
                        "    this._registerAction('selectElements', function() {",
                        "",
                        "      // select all elements except for the invisible",
                        "      // root element",
                        "      var rootElement = canvas.getRootElement();",
                        "",
                        "      var elements = elementRegistry.filter(function(element) {",
                        "        return element !== rootElement;",
                        "      });",
                        "",
                        "      selection.select(elements);",
                        "",
                        "      return elements;",
                        "    });",
                        "  }",
                        "",
                        "  if (spaceTool) {",
                        "    this._registerAction('spaceTool', function() {",
                        "      spaceTool.toggle();",
                        "    });",
                        "  }",
                        "",
                        "  if (lassoTool) {",
                        "    this._registerAction('lassoTool', function() {",
                        "      lassoTool.toggle();",
                        "    });",
                        "  }",
                        "",
                        "  if (handTool) {",
                        "    this._registerAction('handTool', function() {",
                        "      handTool.toggle();",
                        "    });",
                        "  }",
                        "",
                        "  if (globalConnect) {",
                        "    this._registerAction('globalConnectTool', function() {",
                        "      globalConnect.toggle();",
                        "    });",
                        "  }",
                        "",
                        "  if (selection && distributeElements) {",
                        "    this._registerAction('distributeElements', function(opts) {",
                        "      var currentSelection = selection.get(),",
                        "          type = opts.type;",
                        "",
                        "      if (currentSelection.length) {",
                        "        distributeElements.trigger(currentSelection, type);",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  if (selection && alignElements) {",
                        "    this._registerAction('alignElements', function(opts) {",
                        "      var currentSelection = selection.get(),",
                        "          aligneableElements = [],",
                        "          type = opts.type;",
                        "",
                        "      if (currentSelection.length) {",
                        "        aligneableElements = filter(currentSelection, function(element) {",
                        "          return !is(element, 'bpmn:Lane');",
                        "        });",
                        "",
                        "        alignElements.trigger(aligneableElements, type);",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  if (selection && modeling) {",
                        "    this._registerAction('setColor', function(opts) {",
                        "      var currentSelection = selection.get();",
                        "",
                        "      if (currentSelection.length) {",
                        "        modeling.setColor(currentSelection, opts);",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  if (selection && directEditing) {",
                        "    this._registerAction('directEditing', function() {",
                        "      var currentSelection = selection.get();",
                        "",
                        "      if (currentSelection.length) {",
                        "        directEditing.activate(currentSelection[0]);",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  if (searchPad) {",
                        "    this._registerAction('find', function() {",
                        "      searchPad.toggle();",
                        "    });",
                        "  }",
                        "",
                        "  if (canvas && modeling) {",
                        "    this._registerAction('moveToOrigin', function() {",
                        "      var rootElement = canvas.getRootElement(),",
                        "          boundingBox,",
                        "          elements;",
                        "",
                        "      if (is(rootElement, 'bpmn:Collaboration')) {",
                        "        elements = elementRegistry.filter(function(element) {",
                        "          return is(element.parent, 'bpmn:Collaboration');",
                        "        });",
                        "      } else {",
                        "        elements = elementRegistry.filter(function(element) {",
                        "          return element !== rootElement && !is(element.parent, 'bpmn:SubProcess');",
                        "        });",
                        "      }",
                        "",
                        "      boundingBox = getBBox(elements);",
                        "",
                        "      modeling.moveElements(",
                        "        elements,",
                        "        { x: -boundingBox.x, y: -boundingBox.y },",
                        "        rootElement",
                        "      );",
                        "    });",
                        "  }",
                        "",
                        "  if (selection && contextPad) {",
                        "    this._registerAction('replaceElement', function(event) {",
                        "      contextPad.triggerEntry('replace', 'click', event);",
                        "    });",
                        "  }",
                        "",
                        "};"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import EditorActionsModule from 'diagram-js/lib/features/editor-actions';",
                        "",
                        "import BpmnEditorActions from './BpmnEditorActions';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    EditorActionsModule",
                        "  ],",
                        "  editorActions: [ 'type', BpmnEditorActions ]",
                        "};"
                    ]
                }
            },
            "grid-snapping": {
                "BpmnGridSnapping.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { isAny } from '../modeling/util/ModelingUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " */",
                        "",
                        "/**",
                        " * @param {EventBus} eventBus",
                        " */",
                        "export default function BpmnGridSnapping(eventBus) {",
                        "  eventBus.on([",
                        "    'create.init',",
                        "    'shape.move.init'",
                        "  ], function(event) {",
                        "    var context = event.context,",
                        "        shape = event.shape;",
                        "",
                        "    if (isAny(shape, [",
                        "      'bpmn:Participant',",
                        "      'bpmn:SubProcess',",
                        "      'bpmn:TextAnnotation'",
                        "    ])) {",
                        "      if (!context.gridSnappingContext) {",
                        "        context.gridSnappingContext = {};",
                        "      }",
                        "",
                        "      context.gridSnappingContext.snapLocation = 'top-left';",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "BpmnGridSnapping.$inject = [ 'eventBus' ];"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import BpmnGridSnapping from './BpmnGridSnapping';",
                        "import GridSnappingModule from 'diagram-js/lib/features/grid-snapping';",
                        "",
                        "import GridSnappingBehaviorModule from './behavior';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    GridSnappingModule,",
                        "    GridSnappingBehaviorModule",
                        "  ],",
                        "  __init__: [ 'bpmnGridSnapping' ],",
                        "  bpmnGridSnapping: [ 'type', BpmnGridSnapping ]",
                        "};"
                    ]
                },
                "behavior": {
                    "GridSnappingAutoPlaceBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { getNewShapePosition } from '../../auto-place/BpmnAutoPlaceUtil';",
                            "",
                            "import { getMid } from 'diagram-js/lib/layout/LayoutUtil';",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('diagram-js/lib/features/grid-snapping/GridSnapping').default} GridSnapping",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').Axis} Axis",
                            " */",
                            "",
                            "var HIGH_PRIORITY = 2000;",
                            "",
                            "/**",
                            " * @param {EventBus} eventBus",
                            " * @param {GridSnapping} gridSnapping",
                            " */",
                            "export default function GridSnappingAutoPlaceBehavior(eventBus, gridSnapping) {",
                            "  eventBus.on('autoPlace', HIGH_PRIORITY, function(context) {",
                            "    var source = context.source,",
                            "        sourceMid = getMid(source),",
                            "        shape = context.shape;",
                            "",
                            "    var position = getNewShapePosition(source, shape);",
                            "",
                            "    [ 'x', 'y' ].forEach(function(axis) {",
                            "      var options = {};",
                            "",
                            "      // do not snap if x/y equal",
                            "      if (position[ axis ] === sourceMid[ axis ]) {",
                            "        return;",
                            "      }",
                            "",
                            "      if (position[ axis ] > sourceMid[ axis ]) {",
                            "        options.min = position[ axis ];",
                            "      } else {",
                            "        options.max = position[ axis ];",
                            "      }",
                            "",
                            "      if (is(shape, 'bpmn:TextAnnotation')) {",
                            "",
                            "        if (isHorizontal(axis)) {",
                            "          options.offset = -shape.width / 2;",
                            "        } else {",
                            "          options.offset = -shape.height / 2;",
                            "        }",
                            "",
                            "      }",
                            "",
                            "      position[ axis ] = gridSnapping.snapValue(position[ axis ], options);",
                            "",
                            "    });",
                            "",
                            "    // must be returned to be considered by auto place",
                            "    return position;",
                            "  });",
                            "}",
                            "",
                            "GridSnappingAutoPlaceBehavior.$inject = [",
                            "  'eventBus',",
                            "  'gridSnapping'",
                            "];",
                            "",
                            "// helpers //////////",
                            "",
                            "/**",
                            " * @param {Axis} axis",
                            " *",
                            " * @return {boolean}",
                            " */",
                            "function isHorizontal(axis) {",
                            "  return axis === 'x';",
                            "}"
                        ]
                    },
                    "GridSnappingLayoutConnectionBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { pointsAligned } from 'diagram-js/lib/util/Geometry';",
                            "",
                            "import {",
                            "  assign",
                            "} from 'min-dash';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('diagram-js/lib/features/grid-snapping/GridSnapping').default} GridSnapping",
                            " * @typedef {import('../../modeling/Modeling').default} Modeling",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                            " */",
                            "",
                            "var HIGH_PRIORITY = 3000;",
                            "",
                            "",
                            "/**",
                            " * Snaps connections with Manhattan layout.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {GridSnapping} gridSnapping",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function GridSnappingLayoutConnectionBehavior(eventBus, gridSnapping, modeling) {",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  this._gridSnapping = gridSnapping;",
                            "",
                            "  var self = this;",
                            "",
                            "  this.postExecuted([",
                            "    'connection.create',",
                            "    'connection.layout'",
                            "  ], HIGH_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        hints = context.hints || {},",
                            "        waypoints = connection.waypoints;",
                            "",
                            "    if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (!hasMiddleSegments(waypoints)) {",
                            "      return;",
                            "    }",
                            "",
                            "    modeling.updateWaypoints(connection, self.snapMiddleSegments(waypoints));",
                            "  });",
                            "}",
                            "",
                            "GridSnappingLayoutConnectionBehavior.$inject = [",
                            "  'eventBus',",
                            "  'gridSnapping',",
                            "  'modeling'",
                            "];",
                            "",
                            "inherits(GridSnappingLayoutConnectionBehavior, CommandInterceptor);",
                            "",
                            "/**",
                            " * Snap middle segments of a given connection.",
                            " *",
                            " * @param {Point[]} waypoints",
                            " *",
                            " * @return {Point[]}",
                            " */",
                            "GridSnappingLayoutConnectionBehavior.prototype.snapMiddleSegments = function(waypoints) {",
                            "  var gridSnapping = this._gridSnapping,",
                            "      snapped;",
                            "",
                            "  waypoints = waypoints.slice();",
                            "",
                            "  for (var i = 1; i < waypoints.length - 2; i++) {",
                            "",
                            "    snapped = snapSegment(gridSnapping, waypoints[i], waypoints[i + 1]);",
                            "",
                            "    waypoints[i] = snapped[0];",
                            "    waypoints[i + 1] = snapped[1];",
                            "  }",
                            "",
                            "  return waypoints;",
                            "};",
                            "",
                            "",
                            "// helpers //////////",
                            "",
                            "/**",
                            " * Check whether a connection has a middle segments.",
                            " *",
                            " * @param {Point[]} waypoints",
                            " *",
                            " * @return {boolean}",
                            " */",
                            "function hasMiddleSegments(waypoints) {",
                            "  return waypoints.length > 3;",
                            "}",
                            "",
                            "/**",
                            " * Check whether an alignment is horizontal.",
                            " *",
                            " * @param {string} aligned",
                            " *",
                            " * @return {boolean}",
                            " */",
                            "function horizontallyAligned(aligned) {",
                            "  return aligned === 'h';",
                            "}",
                            "",
                            "/**",
                            " * Check whether an alignment is vertical.",
                            " *",
                            " * @param {string} aligned",
                            " *",
                            " * @return {boolean}",
                            " */",
                            "function verticallyAligned(aligned) {",
                            "  return aligned === 'v';",
                            "}",
                            "",
                            "/**",
                            " * Get middle segments from a given connection.",
                            " *",
                            " * @param {Point[]} waypoints",
                            " *",
                            " * @return {Point[]}",
                            " */",
                            "function snapSegment(gridSnapping, segmentStart, segmentEnd) {",
                            "",
                            "  var aligned = pointsAligned(segmentStart, segmentEnd);",
                            "",
                            "  var snapped = {};",
                            "",
                            "  if (horizontallyAligned(aligned)) {",
                            "",
                            "    // snap horizontally",
                            "    snapped.y = gridSnapping.snapValue(segmentStart.y);",
                            "  }",
                            "",
                            "  if (verticallyAligned(aligned)) {",
                            "",
                            "    // snap vertically",
                            "    snapped.x = gridSnapping.snapValue(segmentStart.x);",
                            "  }",
                            "",
                            "  if ('x' in snapped || 'y' in snapped) {",
                            "    segmentStart = assign({}, segmentStart, snapped);",
                            "    segmentEnd = assign({}, segmentEnd, snapped);",
                            "  }",
                            "",
                            "  return [ segmentStart, segmentEnd ];",
                            "}"
                        ]
                    },
                    "GridSnappingParticipantBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('diagram-js/lib/features/grid-snapping/GridSnapping').default} GridSnapping",
                            " */",
                            "",
                            "var HIGHER_PRIORITY = 1750;",
                            "",
                            "/**",
                            " * @param {Canvas} canvas",
                            " * @param {EventBus} eventBus",
                            " * @param {GridSnapping} gridSnapping",
                            " */",
                            "export default function GridSnappingParticipantBehavior(canvas, eventBus, gridSnapping) {",
                            "  eventBus.on([",
                            "    'create.start',",
                            "    'shape.move.start'",
                            "  ], HIGHER_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        rootElement = canvas.getRootElement();",
                            "",
                            "    if (!is(shape, 'bpmn:Participant') ||",
                            "      !is(rootElement, 'bpmn:Process') ||",
                            "      !rootElement.children.length) {",
                            "      return;",
                            "    }",
                            "",
                            "    var createConstraints = context.createConstraints;",
                            "",
                            "    if (!createConstraints) {",
                            "      return;",
                            "    }",
                            "",
                            "    shape.width = gridSnapping.snapValue(shape.width, { min: shape.width });",
                            "    shape.height = gridSnapping.snapValue(shape.height, { min: shape.height });",
                            "  });",
                            "}",
                            "",
                            "GridSnappingParticipantBehavior.$inject = [",
                            "  'canvas',",
                            "  'eventBus',",
                            "  'gridSnapping'",
                            "];"
                        ]
                    },
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import GridSnappingAutoPlaceBehavior from './GridSnappingAutoPlaceBehavior';",
                            "import GridSnappingParticipantBehavior from './GridSnappingParticipantBehavior';",
                            "import GridSnappingLayoutConnectionBehavior from './GridSnappingLayoutConnectionBehavior';",
                            "",
                            "export default {",
                            "  __init__: [",
                            "    'gridSnappingAutoPlaceBehavior',",
                            "    'gridSnappingParticipantBehavior',",
                            "    'gridSnappingLayoutConnectionBehavior',",
                            "  ],",
                            "  gridSnappingAutoPlaceBehavior: [ 'type', GridSnappingAutoPlaceBehavior ],",
                            "  gridSnappingParticipantBehavior: [ 'type', GridSnappingParticipantBehavior ],",
                            "  gridSnappingLayoutConnectionBehavior: [ 'type', GridSnappingLayoutConnectionBehavior ]",
                            "};"
                        ]
                    }
                }
            },
            "interaction-events": {
                "BpmnInteractionEvents.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "import { isExpanded } from '../../util/DiUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('diagram-js/lib/features/interaction-events/InteractionEvents').default} InteractionEvents",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " */",
                        "",
                        "var LABEL_WIDTH = 30,",
                        "    LABEL_HEIGHT = 30;",
                        "",
                        "",
                        "/**",
                        " * BPMN-specific hit zones and interaction fixes.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {InteractionEvents} interactionEvents",
                        " */",
                        "export default function BpmnInteractionEvents(eventBus, interactionEvents) {",
                        "",
                        "  this._interactionEvents = interactionEvents;",
                        "",
                        "  var self = this;",
                        "",
                        "  eventBus.on([",
                        "    'interactionEvents.createHit',",
                        "    'interactionEvents.updateHit'",
                        "  ], function(context) {",
                        "    var element = context.element,",
                        "        gfx = context.gfx;",
                        "",
                        "    if (is(element, 'bpmn:Lane')) {",
                        "      return self._createParticipantHit(element, gfx);",
                        "    } else",
                        "",
                        "    if (is(element, 'bpmn:Participant')) {",
                        "      if (isExpanded(element)) {",
                        "        return self._createParticipantHit(element, gfx);",
                        "      } else {",
                        "        return self._createDefaultHit(element, gfx);",
                        "      }",
                        "    } else",
                        "",
                        "    if (is(element, 'bpmn:SubProcess')) {",
                        "      if (isExpanded(element)) {",
                        "        return self._createSubProcessHit(element, gfx);",
                        "      } else {",
                        "        return self._createDefaultHit(element, gfx);",
                        "      }",
                        "    }",
                        "  });",
                        "",
                        "}",
                        "",
                        "BpmnInteractionEvents.$inject = [",
                        "  'eventBus',",
                        "  'interactionEvents'",
                        "];",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " * @param {SVGElement} gfx",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "BpmnInteractionEvents.prototype._createDefaultHit = function(element, gfx) {",
                        "  this._interactionEvents.removeHits(gfx);",
                        "",
                        "  this._interactionEvents.createDefaultHit(element, gfx);",
                        "",
                        "  // indicate that we created a hit",
                        "  return true;",
                        "};",
                        "",
                        "/**",
                        " * @param {Shape} element",
                        " * @param {SVGElement} gfx",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "BpmnInteractionEvents.prototype._createParticipantHit = function(element, gfx) {",
                        "",
                        "  // remove existing hits",
                        "  this._interactionEvents.removeHits(gfx);",
                        "",
                        "  // add body hit",
                        "  this._interactionEvents.createBoxHit(gfx, 'no-move', {",
                        "    width: element.width,",
                        "    height: element.height",
                        "  });",
                        "",
                        "  // add outline hit",
                        "  this._interactionEvents.createBoxHit(gfx, 'click-stroke', {",
                        "    width: element.width,",
                        "    height: element.height",
                        "  });",
                        "",
                        "  // add label hit",
                        "  this._interactionEvents.createBoxHit(gfx, 'all', {",
                        "    width: LABEL_WIDTH,",
                        "    height: element.height",
                        "  });",
                        "",
                        "  // indicate that we created a hit",
                        "  return true;",
                        "};",
                        "",
                        "/**",
                        " * @param {Shape} element",
                        " * @param {SVGElement} gfx",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "BpmnInteractionEvents.prototype._createSubProcessHit = function(element, gfx) {",
                        "",
                        "  // remove existing hits",
                        "  this._interactionEvents.removeHits(gfx);",
                        "",
                        "  // add body hit",
                        "  this._interactionEvents.createBoxHit(gfx, 'no-move', {",
                        "    width: element.width,",
                        "    height: element.height",
                        "  });",
                        "",
                        "  // add outline hit",
                        "  this._interactionEvents.createBoxHit(gfx, 'click-stroke', {",
                        "    width: element.width,",
                        "    height: element.height",
                        "  });",
                        "",
                        "  // add label hit",
                        "  this._interactionEvents.createBoxHit(gfx, 'all', {",
                        "    width: element.width,",
                        "    height: LABEL_HEIGHT",
                        "  });",
                        "",
                        "  // indicate that we created a hit",
                        "  return true;",
                        "};"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import BpmnInteractionEvents from './BpmnInteractionEvents';",
                        "",
                        "export default {",
                        "  __init__: [ 'bpmnInteractionEvents' ],",
                        "  bpmnInteractionEvents: [ 'type', BpmnInteractionEvents ]",
                        "};"
                    ]
                }
            },
            "keyboard": {
                "BpmnKeyboardBindings.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import KeyboardBindings from 'diagram-js/lib/features/keyboard/KeyboardBindings';",
                        "",
                        "/**",
                        " * @typedef {import('didi').Injector} Injector",
                        " * @typedef {import('diagram-js/lib/features/editor-actions/EditorActions').default} EditorActions",
                        " * @typedef {import('diagram-js/lib/features/keyboard/Keyboard').default} Keyboard",
                        " */",
                        "",
                        "/**",
                        " * BPMN 2.0 specific keyboard bindings.",
                        " *",
                        " * @param {Injector} injector",
                        " */",
                        "export default function BpmnKeyboardBindings(injector) {",
                        "  injector.invoke(KeyboardBindings, this);",
                        "}",
                        "",
                        "inherits(BpmnKeyboardBindings, KeyboardBindings);",
                        "",
                        "BpmnKeyboardBindings.$inject = [",
                        "  'injector'",
                        "];",
                        "",
                        "",
                        "/**",
                        " * Register available keyboard bindings.",
                        " *",
                        " * @param {Keyboard} keyboard",
                        " * @param {EditorActions} editorActions",
                        " */",
                        "BpmnKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {",
                        "",
                        "  // inherit default bindings",
                        "  KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);",
                        "",
                        "  /**",
                        "   * Add keyboard binding if respective editor action",
                        "   * is registered.",
                        "   *",
                        "   * @param {string} action name",
                        "   * @param {Function} fn that implements the key binding",
                        "   */",
                        "  function addListener(action, fn) {",
                        "",
                        "    if (editorActions.isRegistered(action)) {",
                        "      keyboard.addListener(fn);",
                        "    }",
                        "  }",
                        "",
                        "  // select all elements",
                        "  // CTRL + A",
                        "  addListener('selectElements', function(context) {",
                        "",
                        "    var event = context.keyEvent;",
                        "",
                        "    if (keyboard.isKey([ 'a', 'A' ], event) && keyboard.isCmd(event)) {",
                        "      editorActions.trigger('selectElements');",
                        "",
                        "      return true;",
                        "    }",
                        "  });",
                        "",
                        "  // search labels",
                        "  // CTRL + F",
                        "  addListener('find', function(context) {",
                        "",
                        "    var event = context.keyEvent;",
                        "",
                        "    if (keyboard.isKey([ 'f', 'F' ], event) && keyboard.isCmd(event)) {",
                        "      editorActions.trigger('find');",
                        "",
                        "      return true;",
                        "    }",
                        "  });",
                        "",
                        "  // activate space tool",
                        "  // S",
                        "  addListener('spaceTool', function(context) {",
                        "",
                        "    var event = context.keyEvent;",
                        "",
                        "    if (keyboard.hasModifier(event)) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (keyboard.isKey([ 's', 'S' ], event)) {",
                        "      editorActions.trigger('spaceTool');",
                        "",
                        "      return true;",
                        "    }",
                        "  });",
                        "",
                        "  // activate lasso tool",
                        "  // L",
                        "  addListener('lassoTool', function(context) {",
                        "",
                        "    var event = context.keyEvent;",
                        "",
                        "    if (keyboard.hasModifier(event)) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (keyboard.isKey([ 'l', 'L' ], event)) {",
                        "      editorActions.trigger('lassoTool');",
                        "",
                        "      return true;",
                        "    }",
                        "  });",
                        "",
                        "  // activate hand tool",
                        "  // H",
                        "  addListener('handTool', function(context) {",
                        "",
                        "    var event = context.keyEvent;",
                        "",
                        "    if (keyboard.hasModifier(event)) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (keyboard.isKey([ 'h', 'H' ], event)) {",
                        "      editorActions.trigger('handTool');",
                        "",
                        "      return true;",
                        "    }",
                        "  });",
                        "",
                        "  // activate global connect tool",
                        "  // C",
                        "  addListener('globalConnectTool', function(context) {",
                        "",
                        "    var event = context.keyEvent;",
                        "",
                        "    if (keyboard.hasModifier(event)) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (keyboard.isKey([ 'c', 'C' ], event)) {",
                        "      editorActions.trigger('globalConnectTool');",
                        "",
                        "      return true;",
                        "    }",
                        "  });",
                        "",
                        "  // activate direct editing",
                        "  // E",
                        "  addListener('directEditing', function(context) {",
                        "",
                        "    var event = context.keyEvent;",
                        "",
                        "    if (keyboard.hasModifier(event)) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (keyboard.isKey([ 'e', 'E' ], event)) {",
                        "      editorActions.trigger('directEditing');",
                        "",
                        "      return true;",
                        "    }",
                        "  });",
                        "",
                        "  // activate replace element",
                        "  // R",
                        "  addListener('replaceElement', function(context) {",
                        "",
                        "    var event = context.keyEvent;",
                        "",
                        "    if (keyboard.hasModifier(event)) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (keyboard.isKey([ 'r', 'R' ], event)) {",
                        "      editorActions.trigger('replaceElement', event);",
                        "",
                        "      return true;",
                        "    }",
                        "  });",
                        "",
                        "};"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import KeyboardModule from 'diagram-js/lib/features/keyboard';",
                        "",
                        "import BpmnKeyboardBindings from './BpmnKeyboardBindings';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    KeyboardModule",
                        "  ],",
                        "  __init__: [ 'keyboardBindings' ],",
                        "  keyboardBindings: [ 'type', BpmnKeyboardBindings ]",
                        "};"
                    ]
                }
            },
            "label-editing": {
                "LabelEditingPreview.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  append as svgAppend,",
                        "  attr as svgAttr,",
                        "  create as svgCreate,",
                        "  remove as svgRemove",
                        "} from 'tiny-svg';",
                        "",
                        "import {",
                        "  getDi,",
                        "  is",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  translate",
                        "} from 'diagram-js/lib/util/SvgTransformUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('../../draw/PathMap').default} PathMap",
                        " */",
                        "",
                        "var MARKER_HIDDEN = 'djs-element-hidden',",
                        "    MARKER_LABEL_HIDDEN = 'djs-label-hidden';",
                        "",
                        "/**",
                        " * @param {EventBus} eventBus",
                        " * @param {Canvas} canvas",
                        " * @param {PathMap} pathMap",
                        " */",
                        "export default function LabelEditingPreview(eventBus, canvas, pathMap) {",
                        "",
                        "  var self = this;",
                        "",
                        "  var defaultLayer = canvas.getDefaultLayer();",
                        "",
                        "  var element, absoluteElementBBox, gfx;",
                        "",
                        "  eventBus.on('directEditing.activate', function(context) {",
                        "    var activeProvider = context.active;",
                        "",
                        "    element = activeProvider.element.label || activeProvider.element;",
                        "",
                        "    // text annotation",
                        "    if (is(element, 'bpmn:TextAnnotation')) {",
                        "      absoluteElementBBox = canvas.getAbsoluteBBox(element);",
                        "",
                        "      gfx = svgCreate('g');",
                        "",
                        "      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {",
                        "        xScaleFactor: 1,",
                        "        yScaleFactor: 1,",
                        "        containerWidth: element.width,",
                        "        containerHeight: element.height,",
                        "        position: {",
                        "          mx: 0.0,",
                        "          my: 0.0",
                        "        }",
                        "      });",
                        "",
                        "      var path = self.path = svgCreate('path');",
                        "",
                        "      svgAttr(path, {",
                        "        d: textPathData,",
                        "        strokeWidth: 2,",
                        "        stroke: getStrokeColor(element)",
                        "      });",
                        "",
                        "      svgAppend(gfx, path);",
                        "",
                        "      svgAppend(defaultLayer, gfx);",
                        "",
                        "      translate(gfx, element.x, element.y);",
                        "    }",
                        "",
                        "    if (is(element, 'bpmn:TextAnnotation') ||",
                        "        element.labelTarget) {",
                        "      canvas.addMarker(element, MARKER_HIDDEN);",
                        "    } else if (is(element, 'bpmn:Task') ||",
                        "               is(element, 'bpmn:CallActivity') ||",
                        "               is(element, 'bpmn:SubProcess') ||",
                        "               is(element, 'bpmn:Participant')) {",
                        "      canvas.addMarker(element, MARKER_LABEL_HIDDEN);",
                        "    }",
                        "  });",
                        "",
                        "  eventBus.on('directEditing.resize', function(context) {",
                        "",
                        "    // text annotation",
                        "    if (is(element, 'bpmn:TextAnnotation')) {",
                        "      var height = context.height,",
                        "          dy = context.dy;",
                        "",
                        "      var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);",
                        "",
                        "      var textPathData = pathMap.getScaledPath('TEXT_ANNOTATION', {",
                        "        xScaleFactor: 1,",
                        "        yScaleFactor: 1,",
                        "        containerWidth: element.width,",
                        "        containerHeight: newElementHeight,",
                        "        position: {",
                        "          mx: 0.0,",
                        "          my: 0.0",
                        "        }",
                        "      });",
                        "",
                        "      svgAttr(self.path, {",
                        "        d: textPathData",
                        "      });",
                        "    }",
                        "  });",
                        "",
                        "  eventBus.on([ 'directEditing.complete', 'directEditing.cancel' ], function(context) {",
                        "    var activeProvider = context.active;",
                        "",
                        "    if (activeProvider) {",
                        "      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);",
                        "      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);",
                        "    }",
                        "",
                        "    element = undefined;",
                        "    absoluteElementBBox = undefined;",
                        "",
                        "    if (gfx) {",
                        "      svgRemove(gfx);",
                        "",
                        "      gfx = undefined;",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "LabelEditingPreview.$inject = [",
                        "  'eventBus',",
                        "  'canvas',",
                        "  'pathMap'",
                        "];",
                        "",
                        "",
                        "// helpers //////////",
                        "",
                        "function getStrokeColor(element, defaultColor) {",
                        "  var di = getDi(element);",
                        "",
                        "  return di.get('stroke') || defaultColor || 'black';",
                        "}"
                    ]
                },
                "LabelEditingProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  assign",
                        "} from 'min-dash';",
                        "",
                        "import {",
                        "  getLabel",
                        "} from '../../util/LabelUtil';",
                        "",
                        "import {",
                        "  is",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import { isAny } from '../modeling/util/ModelingUtil';",
                        "import { isExpanded } from '../../util/DiUtil';",
                        "",
                        "import {",
                        "  getExternalLabelMid,",
                        "  isLabelExternal,",
                        "  hasExternalLabel,",
                        "  isLabel",
                        "} from '../../util/LabelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('../modeling/BpmnFactory').default} BpmnFactory",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js-direct-editing/lib/DirectEditing').default} DirectEditing",
                        " * @typedef {import('../modeling/Modeling').default} Modeling",
                        " * @typedef {import('diagram-js/lib/features/resize/ResizeHandles').default} ResizeHandles",
                        " * @typedef {import('../../draw/TextRenderer').default} TextRenderer",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " *",
                        " * @typedef { {",
                        " *   bounds: {",
                        " *     x: number;",
                        " *     y: number;",
                        " *     width: number;",
                        " *     height: number;",
                        " *     minWidth?: number;",
                        " *     minHeight?: number;",
                        " *   };",
                        " *   style: Object;",
                        " * } } DirectEditingContext",
                        " */",
                        "",
                        "var HIGH_PRIORITY = 2000;",
                        "",
                        "/**",
                        " * @param {EventBus} eventBus",
                        " * @param {BpmnFactory} bpmnFactory",
                        " * @param {Canvas} canvas",
                        " * @param {DirectEditing} directEditing",
                        " * @param {Modeling} modeling",
                        " * @param {ResizeHandles} resizeHandles",
                        " * @param {TextRenderer} textRenderer",
                        " */",
                        "export default function LabelEditingProvider(",
                        "    eventBus, bpmnFactory, canvas, directEditing,",
                        "    modeling, resizeHandles, textRenderer) {",
                        "",
                        "  this._bpmnFactory = bpmnFactory;",
                        "  this._canvas = canvas;",
                        "  this._modeling = modeling;",
                        "  this._textRenderer = textRenderer;",
                        "",
                        "  directEditing.registerProvider(this);",
                        "",
                        "  // listen to dblclick on non-root elements",
                        "  eventBus.on('element.dblclick', function(event) {",
                        "    activateDirectEdit(event.element, true);",
                        "  });",
                        "",
                        "  // complete on followup canvas operation",
                        "  eventBus.on([",
                        "    'autoPlace.start',",
                        "    'canvas.viewbox.changing',",
                        "    'drag.init',",
                        "    'element.mousedown',",
                        "    'popupMenu.open',",
                        "    'root.set',",
                        "    'selection.changed'",
                        "  ], function() {",
                        "    if (directEditing.isActive()) {",
                        "      directEditing.complete();",
                        "    }",
                        "  });",
                        "",
                        "  eventBus.on([",
                        "    'shape.remove',",
                        "    'connection.remove'",
                        "  ], HIGH_PRIORITY, function(event) {",
                        "",
                        "    if (directEditing.isActive(event.element)) {",
                        "      directEditing.cancel();",
                        "    }",
                        "  });",
                        "",
                        "  // cancel on command stack changes",
                        "  eventBus.on([ 'commandStack.changed' ], function(e) {",
                        "    if (directEditing.isActive()) {",
                        "      directEditing.cancel();",
                        "    }",
                        "  });",
                        "",
                        "",
                        "  eventBus.on('directEditing.activate', function(event) {",
                        "    resizeHandles.removeResizers();",
                        "  });",
                        "",
                        "  eventBus.on('create.end', 500, function(event) {",
                        "",
                        "    var context = event.context,",
                        "        element = context.shape,",
                        "        canExecute = event.context.canExecute,",
                        "        isTouch = event.isTouch;",
                        "",
                        "    // TODO(nikku): we need to find a way to support the",
                        "    // direct editing on mobile devices; right now this will",
                        "    // break for desworkflowediting on mobile devices",
                        "    // as it breaks the user interaction workflow",
                        "",
                        "    // TODO(nikku): we should temporarily focus the edited element",
                        "    // here and release the focused viewport after the direct edit",
                        "    // operation is finished",
                        "    if (isTouch) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (!canExecute) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (context.hints && context.hints.createElementsBehavior === false) {",
                        "      return;",
                        "    }",
                        "",
                        "    activateDirectEdit(element);",
                        "  });",
                        "",
                        "  eventBus.on('autoPlace.end', 500, function(event) {",
                        "    activateDirectEdit(event.shape);",
                        "  });",
                        "",
                        "",
                        "  function activateDirectEdit(element, force) {",
                        "    if (force ||",
                        "        isAny(element, [ 'bpmn:Task', 'bpmn:TextAnnotation', 'bpmn:Participant' ]) ||",
                        "        isCollapsedSubProcess(element)) {",
                        "",
                        "      directEditing.activate(element);",
                        "    }",
                        "  }",
                        "",
                        "}",
                        "",
                        "LabelEditingProvider.$inject = [",
                        "  'eventBus',",
                        "  'bpmnFactory',",
                        "  'canvas',",
                        "  'directEditing',",
                        "  'modeling',",
                        "  'resizeHandles',",
                        "  'textRenderer'",
                        "];",
                        "",
                        "",
                        "/**",
                        " * Activate direct editing for activities and text annotations.",
                        " *",
                        " * @param {Element} element",
                        " *",
                        " * @return { {",
                        " *   text: string;",
                        " *   options?: {",
                        " *     autoResize?: boolean;",
                        " *     centerVertically?: boolean;",
                        " *     resizable?: boolean;",
                        " *   }",
                        " * } & DirectEditingContext }",
                        " */",
                        "LabelEditingProvider.prototype.activate = function(element) {",
                        "",
                        "  // text",
                        "  var text = getLabel(element);",
                        "",
                        "  if (text === undefined) {",
                        "    return;",
                        "  }",
                        "",
                        "  var context = {",
                        "    text: text",
                        "  };",
                        "",
                        "  // bounds",
                        "  var bounds = this.getEditingBBox(element);",
                        "",
                        "  assign(context, bounds);",
                        "",
                        "  var options = {};",
                        "",
                        "  // tasks",
                        "  if (",
                        "    isAny(element, [",
                        "      'bpmn:Task',",
                        "      'bpmn:Participant',",
                        "      'bpmn:Lane',",
                        "      'bpmn:CallActivity'",
                        "    ]) ||",
                        "    isCollapsedSubProcess(element)",
                        "  ) {",
                        "    assign(options, {",
                        "      centerVertically: true",
                        "    });",
                        "  }",
                        "",
                        "  // external labels",
                        "  if (isLabelExternal(element)) {",
                        "    assign(options, {",
                        "      autoResize: true",
                        "    });",
                        "  }",
                        "",
                        "  // text annotations",
                        "  if (is(element, 'bpmn:TextAnnotation')) {",
                        "    assign(options, {",
                        "      resizable: true,",
                        "      autoResize: true",
                        "    });",
                        "  }",
                        "",
                        "  assign(context, {",
                        "    options: options",
                        "  });",
                        "",
                        "  return context;",
                        "};",
                        "",
                        "",
                        "/**",
                        " * Get the editing bounding box based on the element's size and position.",
                        " *",
                        " * @param {Element} element",
                        " *",
                        " * @return {DirectEditingContext}",
                        " */",
                        "LabelEditingProvider.prototype.getEditingBBox = function(element) {",
                        "  var canvas = this._canvas;",
                        "",
                        "  var target = element.label || element;",
                        "",
                        "  var bbox = canvas.getAbsoluteBBox(target);",
                        "",
                        "  var mid = {",
                        "    x: bbox.x + bbox.width / 2,",
                        "    y: bbox.y + bbox.height / 2",
                        "  };",
                        "",
                        "  // default position",
                        "  var bounds = { x: bbox.x, y: bbox.y };",
                        "",
                        "  var zoom = canvas.zoom();",
                        "",
                        "  var defaultStyle = this._textRenderer.getDefaultStyle(),",
                        "      externalStyle = this._textRenderer.getExternalStyle();",
                        "",
                        "  // take zoom into account",
                        "  var externalFontSize = externalStyle.fontSize * zoom,",
                        "      externalLineHeight = externalStyle.lineHeight,",
                        "      defaultFontSize = defaultStyle.fontSize * zoom,",
                        "      defaultLineHeight = defaultStyle.lineHeight;",
                        "",
                        "  var style = {",
                        "    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,",
                        "    fontWeight: this._textRenderer.getDefaultStyle().fontWeight",
                        "  };",
                        "",
                        "  // adjust for expanded pools AND lanes",
                        "  if (is(element, 'bpmn:Lane') || isExpandedPool(element)) {",
                        "",
                        "    assign(bounds, {",
                        "      width: bbox.height,",
                        "      height: 30 * zoom,",
                        "      x: bbox.x - bbox.height / 2 + (15 * zoom),",
                        "      y: mid.y - (30 * zoom) / 2",
                        "    });",
                        "",
                        "    assign(style, {",
                        "      fontSize: defaultFontSize + 'px',",
                        "      lineHeight: defaultLineHeight,",
                        "      paddingTop: (7 * zoom) + 'px',",
                        "      paddingBottom: (7 * zoom) + 'px',",
                        "      paddingLeft: (5 * zoom) + 'px',",
                        "      paddingRight: (5 * zoom) + 'px',",
                        "      transform: 'rotate(-90deg)'",
                        "    });",
                        "  }",
                        "",
                        "",
                        "  // internal labels for tasks and collapsed call activities,",
                        "  // sub processes and participants",
                        "  if (isAny(element, [ 'bpmn:Task', 'bpmn:CallActivity' ]) ||",
                        "      isCollapsedPool(element) ||",
                        "      isCollapsedSubProcess(element)) {",
                        "",
                        "    assign(bounds, {",
                        "      width: bbox.width,",
                        "      height: bbox.height",
                        "    });",
                        "",
                        "    assign(style, {",
                        "      fontSize: defaultFontSize + 'px',",
                        "      lineHeight: defaultLineHeight,",
                        "      paddingTop: (7 * zoom) + 'px',",
                        "      paddingBottom: (7 * zoom) + 'px',",
                        "      paddingLeft: (5 * zoom) + 'px',",
                        "      paddingRight: (5 * zoom) + 'px'",
                        "    });",
                        "  }",
                        "",
                        "",
                        "  // internal labels for expanded sub processes",
                        "  if (isExpandedSubProcess(element)) {",
                        "    assign(bounds, {",
                        "      width: bbox.width,",
                        "      x: bbox.x",
                        "    });",
                        "",
                        "    assign(style, {",
                        "      fontSize: defaultFontSize + 'px',",
                        "      lineHeight: defaultLineHeight,",
                        "      paddingTop: (7 * zoom) + 'px',",
                        "      paddingBottom: (7 * zoom) + 'px',",
                        "      paddingLeft: (5 * zoom) + 'px',",
                        "      paddingRight: (5 * zoom) + 'px'",
                        "    });",
                        "  }",
                        "",
                        "  var width = 90 * zoom,",
                        "      paddingTop = 7 * zoom,",
                        "      paddingBottom = 4 * zoom;",
                        "",
                        "  // external labels for events, data elements, gateways, groups and connections",
                        "  if (target.labelTarget) {",
                        "    assign(bounds, {",
                        "      width: width,",
                        "      height: bbox.height + paddingTop + paddingBottom,",
                        "      x: mid.x - width / 2,",
                        "      y: bbox.y - paddingTop",
                        "    });",
                        "",
                        "    assign(style, {",
                        "      fontSize: externalFontSize + 'px',",
                        "      lineHeight: externalLineHeight,",
                        "      paddingTop: paddingTop + 'px',",
                        "      paddingBottom: paddingBottom + 'px'",
                        "    });",
                        "  }",
                        "",
                        "  // external label not yet created",
                        "  if (isLabelExternal(target)",
                        "      && !hasExternalLabel(target)",
                        "      && !isLabel(target)) {",
                        "",
                        "    var externalLabelMid = getExternalLabelMid(element);",
                        "",
                        "    var absoluteBBox = canvas.getAbsoluteBBox({",
                        "      x: externalLabelMid.x,",
                        "      y: externalLabelMid.y,",
                        "      width: 0,",
                        "      height: 0",
                        "    });",
                        "",
                        "    var height = externalFontSize + paddingTop + paddingBottom;",
                        "",
                        "    assign(bounds, {",
                        "      width: width,",
                        "      height: height,",
                        "      x: absoluteBBox.x - width / 2,",
                        "      y: absoluteBBox.y - height / 2",
                        "    });",
                        "",
                        "    assign(style, {",
                        "      fontSize: externalFontSize + 'px',",
                        "      lineHeight: externalLineHeight,",
                        "      paddingTop: paddingTop + 'px',",
                        "      paddingBottom: paddingBottom + 'px'",
                        "    });",
                        "  }",
                        "",
                        "  // text annotations",
                        "  if (is(element, 'bpmn:TextAnnotation')) {",
                        "    assign(bounds, {",
                        "      width: bbox.width,",
                        "      height: bbox.height,",
                        "      minWidth: 30 * zoom,",
                        "      minHeight: 10 * zoom",
                        "    });",
                        "",
                        "    assign(style, {",
                        "      textAlign: 'left',",
                        "      paddingTop: (5 * zoom) + 'px',",
                        "      paddingBottom: (7 * zoom) + 'px',",
                        "      paddingLeft: (7 * zoom) + 'px',",
                        "      paddingRight: (5 * zoom) + 'px',",
                        "      fontSize: defaultFontSize + 'px',",
                        "      lineHeight: defaultLineHeight",
                        "    });",
                        "  }",
                        "",
                        "  return { bounds: bounds, style: style };",
                        "};",
                        "",
                        "",
                        "LabelEditingProvider.prototype.update = function(",
                        "    element, newLabel,",
                        "    activeContextText, bounds) {",
                        "",
                        "  var newBounds,",
                        "      bbox;",
                        "",
                        "  if (is(element, 'bpmn:TextAnnotation')) {",
                        "",
                        "    bbox = this._canvas.getAbsoluteBBox(element);",
                        "",
                        "    newBounds = {",
                        "      x: element.x,",
                        "      y: element.y,",
                        "      width: element.width / bbox.width * bounds.width,",
                        "      height: element.height / bbox.height * bounds.height",
                        "    };",
                        "  }",
                        "",
                        "  if (isEmptyText(newLabel)) {",
                        "    newLabel = null;",
                        "  }",
                        "",
                        "  this._modeling.updateLabel(element, newLabel, newBounds);",
                        "};",
                        "",
                        "",
                        "",
                        "// helpers //////////",
                        "",
                        "function isCollapsedSubProcess(element) {",
                        "  return is(element, 'bpmn:SubProcess') && !isExpanded(element);",
                        "}",
                        "",
                        "function isExpandedSubProcess(element) {",
                        "  return is(element, 'bpmn:SubProcess') && isExpanded(element);",
                        "}",
                        "",
                        "function isCollapsedPool(element) {",
                        "  return is(element, 'bpmn:Participant') && !isExpanded(element);",
                        "}",
                        "",
                        "function isExpandedPool(element) {",
                        "  return is(element, 'bpmn:Participant') && isExpanded(element);",
                        "}",
                        "",
                        "function isEmptyText(label) {",
                        "  return !label || !label.trim();",
                        "}"
                    ]
                },
                "LabelUtil.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "export {",
                        "  getLabel,",
                        "  setLabel",
                        "} from '../../util/LabelUtil';"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import ChangeSupportModule from 'diagram-js/lib/features/change-support';",
                        "import ResizeModule from 'diagram-js/lib/features/resize';",
                        "import DirectEditingModule from 'diagram-js-direct-editing';",
                        "",
                        "import LabelEditingProvider from './LabelEditingProvider';",
                        "import LabelEditingPreview from './LabelEditingPreview';",
                        "",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    ChangeSupportModule,",
                        "    ResizeModule,",
                        "    DirectEditingModule",
                        "  ],",
                        "  __init__: [",
                        "    'labelEditingProvider',",
                        "    'labelEditingPreview'",
                        "  ],",
                        "  labelEditingProvider: [ 'type', LabelEditingProvider ],",
                        "  labelEditingPreview: [ 'type', LabelEditingPreview ]",
                        "};"
                    ]
                },
                "cmd": {
                    "UpdateLabelHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  setLabel,",
                            "  getLabel",
                            "} from '../../../util/LabelUtil';",
                            "",
                            "import {",
                            "  getExternalLabelMid,",
                            "  isLabelExternal,",
                            "  hasExternalLabel,",
                            "  isLabel",
                            "} from '../../../util/LabelUtil';",
                            "",
                            "import {",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "var NULL_DIMENSIONS = {",
                            "  width: 0,",
                            "  height: 0",
                            "};",
                            "",
                            "/**",
                            " * @typedef {import('../../modeling/Modeling').default} Modeling",
                            " * @typedef {import('../../../draw/TextRenderer').default} TextRenderer",
                            " * @typedef {import('../../modeling/BpmnFactory').default} BpmnFactory",
                            " *",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " */",
                            "",
                            "/**",
                            " * A handler that updates the text of a BPMN element.",
                            " *",
                            " * @param {Modeling} modeling",
                            " * @param {TextRenderer} textRenderer",
                            " * @param {BpmnFactory} bpmnFactory",
                            " */",
                            "export default function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {",
                            "",
                            "  /**",
                            "   * Set the label and return the changed elements.",
                            "   *",
                            "   * Element parameter can be label itself or connection (i.e. sequence flow).",
                            "   *",
                            "   * @param {Element} element",
                            "   * @param {string} text",
                            "   */",
                            "  function setText(element, text) {",
                            "",
                            "    // external label if present",
                            "    var label = element.label || element;",
                            "",
                            "    var labelTarget = element.labelTarget || element;",
                            "",
                            "    setLabel(label, text, labelTarget !== label);",
                            "",
                            "    return [ label, labelTarget ];",
                            "  }",
                            "",
                            "  function preExecute(ctx) {",
                            "    var element = ctx.element,",
                            "        businessObject = element.businessObject,",
                            "        newLabel = ctx.newLabel;",
                            "",
                            "    if (!isLabel(element)",
                            "        && isLabelExternal(element)",
                            "        && !hasExternalLabel(element)",
                            "        && !isEmptyText(newLabel)) {",
                            "",
                            "      // create label",
                            "      var paddingTop = 7;",
                            "",
                            "      var labelCenter = getExternalLabelMid(element);",
                            "",
                            "      labelCenter = {",
                            "        x: labelCenter.x,",
                            "        y: labelCenter.y + paddingTop",
                            "      };",
                            "",
                            "      modeling.createLabel(element, labelCenter, {",
                            "        id: businessObject.id + '_label',",
                            "        businessObject: businessObject,",
                            "        di: element.di",
                            "      });",
                            "    }",
                            "  }",
                            "",
                            "  function execute(ctx) {",
                            "    ctx.oldLabel = getLabel(ctx.element);",
                            "    return setText(ctx.element, ctx.newLabel);",
                            "  }",
                            "",
                            "  function revert(ctx) {",
                            "    return setText(ctx.element, ctx.oldLabel);",
                            "  }",
                            "",
                            "  function postExecute(ctx) {",
                            "    var element = ctx.element,",
                            "        label = element.label || element,",
                            "        newLabel = ctx.newLabel,",
                            "        newBounds = ctx.newBounds,",
                            "        hints = ctx.hints || {};",
                            "",
                            "    // ignore internal labels for elements except text annotations",
                            "    if (!isLabel(label) && !is(label, 'bpmn:TextAnnotation')) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (isLabel(label) && isEmptyText(newLabel)) {",
                            "",
                            "      if (hints.removeShape !== false) {",
                            "        modeling.removeShape(label, { unsetLabel: false });",
                            "      }",
                            "",
                            "      return;",
                            "    }",
                            "",
                            "    var text = getLabel(element);",
                            "",
                            "    // resize element based on label _or_ pre-defined bounds",
                            "    if (typeof newBounds === 'undefined') {",
                            "      newBounds = textRenderer.getExternalLabelBounds(label, text);",
                            "    }",
                            "",
                            "    // setting newBounds to false or _null_ will",
                            "    // disable the postExecute resize operation",
                            "    if (newBounds) {",
                            "      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);",
                            "    }",
                            "  }",
                            "",
                            "  // API",
                            "",
                            "  this.preExecute = preExecute;",
                            "  this.execute = execute;",
                            "  this.revert = revert;",
                            "  this.postExecute = postExecute;",
                            "}",
                            "",
                            "UpdateLabelHandler.$inject = [",
                            "  'modeling',",
                            "  'textRenderer',",
                            "  'bpmnFactory'",
                            "];",
                            "",
                            "",
                            "// helpers //////////",
                            "",
                            "function isEmptyText(label) {",
                            "  return !label || !label.trim();",
                            "}"
                        ]
                    }
                }
            },
            "modeling": {
                "BpmnFactory.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  map,",
                        "  assign,",
                        "  pick",
                        "} from 'min-dash';",
                        "",
                        "import {",
                        "  isAny",
                        "} from './util/ModelingUtil';",
                        "",
                        "import {",
                        "  is",
                        "} from '../../util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('../../model/Types').Moddle} Moddle",
                        " * @typedef {import('../../model/Types').ModdleElement} ModdleElement",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                        " */",
                        "",
                        "/**",
                        " * A factory for BPMN elements.",
                        " *",
                        " * @param {Moddle} moddle",
                        " */",
                        "export default function BpmnFactory(moddle) {",
                        "  this._model = moddle;",
                        "}",
                        "",
                        "BpmnFactory.$inject = [ 'moddle' ];",
                        "",
                        "/**",
                        " * @param {ModdleElement} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "BpmnFactory.prototype._needsId = function(element) {",
                        "  return isAny(element, [",
                        "    'bpmn:RootElement',",
                        "    'bpmn:FlowElement',",
                        "    'bpmn:MessageFlow',",
                        "    'bpmn:DataAssociation',",
                        "    'bpmn:Artifact',",
                        "    'bpmn:Participant',",
                        "    'bpmn:Lane',",
                        "    'bpmn:LaneSet',",
                        "    'bpmn:Process',",
                        "    'bpmn:Collaboration',",
                        "    'bpmndi:BPMNShape',",
                        "    'bpmndi:BPMNEdge',",
                        "    'bpmndi:BPMNDiagram',",
                        "    'bpmndi:BPMNPlane',",
                        "    'bpmn:Property',",
                        "    'bpmn:CategoryValue'",
                        "  ]);",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} element",
                        " */",
                        "BpmnFactory.prototype._ensureId = function(element) {",
                        "  if (element.id) {",
                        "    this._model.ids.claim(element.id, element);",
                        "    return;",
                        "  }",
                        "",
                        "  // generate semantic ids for elements",
                        "  // bpmn:SequenceFlow -> SequenceFlow_ID",
                        "  var prefix;",
                        "",
                        "  if (is(element, 'bpmn:Activity')) {",
                        "    prefix = 'Activity';",
                        "  } else if (is(element, 'bpmn:Event')) {",
                        "    prefix = 'Event';",
                        "  } else if (is(element, 'bpmn:Gateway')) {",
                        "    prefix = 'Gateway';",
                        "  } else if (isAny(element, [ 'bpmn:SequenceFlow', 'bpmn:MessageFlow' ])) {",
                        "    prefix = 'Flow';",
                        "  } else {",
                        "    prefix = (element.$type || '').replace(/^[^:]*:/g, '');",
                        "  }",
                        "",
                        "  prefix += '_';",
                        "",
                        "  if (!element.id && this._needsId(element)) {",
                        "    element.id = this._model.ids.nextPrefixed(prefix, element);",
                        "  }",
                        "};",
                        "",
                        "/**",
                        " * Create BPMN element.",
                        " *",
                        " * @param {string} type",
                        " * @param {Object} [attrs]",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "BpmnFactory.prototype.create = function(type, attrs) {",
                        "  var element = this._model.create(type, attrs || {});",
                        "",
                        "  this._ensureId(element);",
                        "",
                        "  return element;",
                        "};",
                        "",
                        "/**",
                        " * @return {ModdleElement}",
                        " */",
                        "BpmnFactory.prototype.createDiLabel = function() {",
                        "  return this.create('bpmndi:BPMNLabel', {",
                        "    bounds: this.createDiBounds()",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} semantic",
                        " * @param {Object} [attrs]",
                        " * @return {ModdleElement}",
                        " */",
                        "BpmnFactory.prototype.createDiShape = function(semantic, attrs) {",
                        "  return this.create('bpmndi:BPMNShape', assign({",
                        "    bpmnElement: semantic,",
                        "    bounds: this.createDiBounds()",
                        "  }, attrs));",
                        "};",
                        "",
                        "/**",
                        " * @return {ModdleElement}",
                        " */",
                        "BpmnFactory.prototype.createDiBounds = function(bounds) {",
                        "  return this.create('dc:Bounds', bounds);",
                        "};",
                        "",
                        "/**",
                        " * @param {Point[]} waypoints",
                        " *",
                        " * @return {ModdleElement[]}",
                        " */",
                        "BpmnFactory.prototype.createDiWaypoints = function(waypoints) {",
                        "  var self = this;",
                        "",
                        "  return map(waypoints, function(pos) {",
                        "    return self.createDiWaypoint(pos);",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * @param {Point} point",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "BpmnFactory.prototype.createDiWaypoint = function(point) {",
                        "  return this.create('dc:Point', pick(point, [ 'x', 'y' ]));",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} semantic",
                        " * @param {Object} [attrs]",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "BpmnFactory.prototype.createDiEdge = function(semantic, attrs) {",
                        "  return this.create('bpmndi:BPMNEdge', assign({",
                        "    bpmnElement: semantic,",
                        "    waypoint: this.createDiWaypoints([])",
                        "  }, attrs));",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} semantic",
                        " * @param {Object} [attrs]",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "BpmnFactory.prototype.createDiPlane = function(semantic, attrs) {",
                        "  return this.create('bpmndi:BPMNPlane', assign({",
                        "    bpmnElement: semantic",
                        "  }, attrs));",
                        "};"
                    ]
                },
                "BpmnLayouter.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import {",
                        "  assign",
                        "} from 'min-dash';",
                        "",
                        "import BaseLayouter from 'diagram-js/lib/layout/BaseLayouter';",
                        "",
                        "import {",
                        "  repairConnection,",
                        "  withoutRedundantPoints",
                        "} from 'diagram-js/lib/layout/ManhattanLayout';",
                        "",
                        "import {",
                        "  getMid,",
                        "  getOrientation",
                        "} from 'diagram-js/lib/layout/LayoutUtil';",
                        "",
                        "import {",
                        "  isExpanded",
                        "} from '../../util/DiUtil';",
                        "",
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                        " *",
                        " * @typedef {import('../../model/Types').Connection} Connection",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " *",
                        " * @typedef {import('diagram-js/lib/layout/BaseLayouter').LayoutConnectionHints} LayoutConnectionHints",
                        " *",
                        " * @typedef { {",
                        " *   source?: Element;",
                        " *   target?: Element;",
                        " *   waypoints?: Point[];",
                        " *   connectionStart?: Point;",
                        " *   connectionEnd?: Point;",
                        " * } & LayoutConnectionHints } BpmnLayoutConnectionHints",
                        " */",
                        "",
                        "var ATTACH_ORIENTATION_PADDING = -10,",
                        "    BOUNDARY_TO_HOST_THRESHOLD = 40;",
                        "",
                        "var oppositeOrientationMapping = {",
                        "  'top': 'bottom',",
                        "  'top-right': 'bottom-left',",
                        "  'top-left': 'bottom-right',",
                        "  'right': 'left',",
                        "  'bottom': 'top',",
                        "  'bottom-right': 'top-left',",
                        "  'bottom-left': 'top-right',",
                        "  'left': 'right'",
                        "};",
                        "",
                        "var orientationDirectionMapping = {",
                        "  top: 't',",
                        "  right: 'r',",
                        "  bottom: 'b',",
                        "  left: 'l'",
                        "};",
                        "",
                        "export default function BpmnLayouter() {}",
                        "",
                        "inherits(BpmnLayouter, BaseLayouter);",
                        "",
                        "/**",
                        " * Returns waypoints of laid out connection.",
                        " *",
                        " * @param {Connection} connection",
                        " * @param {BpmnLayoutConnectionHints} [hints]",
                        " *",
                        " * @return {Point[]}",
                        " */",
                        "BpmnLayouter.prototype.layoutConnection = function(connection, hints) {",
                        "  if (!hints) {",
                        "    hints = {};",
                        "  }",
                        "",
                        "  var source = hints.source || connection.source,",
                        "      target = hints.target || connection.target,",
                        "      waypoints = hints.waypoints || connection.waypoints,",
                        "      connectionStart = hints.connectionStart,",
                        "      connectionEnd = hints.connectionEnd;",
                        "",
                        "  var manhattanOptions,",
                        "      updatedWaypoints;",
                        "",
                        "  if (!connectionStart) {",
                        "    connectionStart = getConnectionDocking(waypoints && waypoints[ 0 ], source);",
                        "  }",
                        "",
                        "  if (!connectionEnd) {",
                        "    connectionEnd = getConnectionDocking(waypoints && waypoints[ waypoints.length - 1 ], target);",
                        "  }",
                        "",
                        "  // TODO(nikku): support vertical modeling",
                        "  // and invert preferredLayouts accordingly",
                        "",
                        "  if (is(connection, 'bpmn:Association') ||",
                        "      is(connection, 'bpmn:DataAssociation')) {",
                        "",
                        "    if (waypoints && !isCompensationAssociation(source, target)) {",
                        "      return [].concat([ connectionStart ], waypoints.slice(1, -1), [ connectionEnd ]);",
                        "    }",
                        "  }",
                        "",
                        "  if (is(connection, 'bpmn:MessageFlow')) {",
                        "    manhattanOptions = getMessageFlowManhattanOptions(source, target);",
                        "  } else if (is(connection, 'bpmn:SequenceFlow') || isCompensationAssociation(source, target)) {",
                        "",
                        "    // layout all connection between flow elements h:h, except for",
                        "    // (1) outgoing of boundary events -> layout based on attach orientation and target orientation",
                        "    // (2) incoming/outgoing of gateways -> v:h for outgoing, h:v for incoming",
                        "    // (3) loops",
                        "    if (source === target) {",
                        "      manhattanOptions = {",
                        "        preferredLayouts: getLoopPreferredLayout(source, connection)",
                        "      };",
                        "    } else if (is(source, 'bpmn:BoundaryEvent')) {",
                        "      manhattanOptions = {",
                        "        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)",
                        "      };",
                        "    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {",
                        "      manhattanOptions = getSubProcessManhattanOptions(source);",
                        "    } else if (is(source, 'bpmn:Gateway')) {",
                        "      manhattanOptions = {",
                        "        preferredLayouts: [ 'v:h' ]",
                        "      };",
                        "    } else if (is(target, 'bpmn:Gateway')) {",
                        "      manhattanOptions = {",
                        "        preferredLayouts: [ 'h:v' ]",
                        "      };",
                        "    } else {",
                        "      manhattanOptions = {",
                        "        preferredLayouts: [ 'h:h' ]",
                        "      };",
                        "    }",
                        "  }",
                        "",
                        "  if (manhattanOptions) {",
                        "    manhattanOptions = assign(manhattanOptions, hints);",
                        "",
                        "    updatedWaypoints = withoutRedundantPoints(repairConnection(",
                        "      source,",
                        "      target,",
                        "      connectionStart,",
                        "      connectionEnd,",
                        "      waypoints,",
                        "      manhattanOptions",
                        "    ));",
                        "  }",
                        "",
                        "  return updatedWaypoints || [ connectionStart, connectionEnd ];",
                        "};",
                        "",
                        "",
                        "// helpers //////////",
                        "",
                        "function getAttachOrientation(attachedElement) {",
                        "  var hostElement = attachedElement.host;",
                        "",
                        "  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);",
                        "}",
                        "",
                        "function getMessageFlowManhattanOptions(source, target) {",
                        "  return {",
                        "    preferredLayouts: [ 'straight', 'v:v' ],",
                        "    preserveDocking: getMessageFlowPreserveDocking(source, target)",
                        "  };",
                        "}",
                        "",
                        "function getMessageFlowPreserveDocking(source, target) {",
                        "",
                        "  // (1) docking element connected to participant has precedence",
                        "  if (is(target, 'bpmn:Participant')) {",
                        "    return 'source';",
                        "  }",
                        "",
                        "  if (is(source, 'bpmn:Participant')) {",
                        "    return 'target';",
                        "  }",
                        "",
                        "  // (2) docking element connected to expanded sub-process has precedence",
                        "  if (isExpandedSubProcess(target)) {",
                        "    return 'source';",
                        "  }",
                        "",
                        "  if (isExpandedSubProcess(source)) {",
                        "    return 'target';",
                        "  }",
                        "",
                        "  // (3) docking event has precedence",
                        "  if (is(target, 'bpmn:Event')) {",
                        "    return 'target';",
                        "  }",
                        "",
                        "  if (is(source, 'bpmn:Event')) {",
                        "    return 'source';",
                        "  }",
                        "",
                        "  return null;",
                        "}",
                        "",
                        "function getSubProcessManhattanOptions(source) {",
                        "  return {",
                        "    preferredLayouts: [ 'straight', 'h:h' ],",
                        "    preserveDocking: getSubProcessPreserveDocking(source)",
                        "  };",
                        "}",
                        "",
                        "function getSubProcessPreserveDocking(source) {",
                        "  return isExpandedSubProcess(source) ? 'target' : 'source';",
                        "}",
                        "",
                        "function getConnectionDocking(point, shape) {",
                        "  return point ? (point.original || point) : getMid(shape);",
                        "}",
                        "",
                        "function isCompensationAssociation(source, target) {",
                        "  return is(target, 'bpmn:Activity') &&",
                        "    is(source, 'bpmn:BoundaryEvent') &&",
                        "    target.businessObject.isForCompensation;",
                        "}",
                        "",
                        "function isExpandedSubProcess(element) {",
                        "  return is(element, 'bpmn:SubProcess') && isExpanded(element);",
                        "}",
                        "",
                        "function isSame(a, b) {",
                        "  return a === b;",
                        "}",
                        "",
                        "function isAnyOrientation(orientation, orientations) {",
                        "  return orientations.indexOf(orientation) !== -1;",
                        "}",
                        "",
                        "function getHorizontalOrientation(orientation) {",
                        "  var matches = /right|left/.exec(orientation);",
                        "",
                        "  return matches && matches[0];",
                        "}",
                        "",
                        "function getVerticalOrientation(orientation) {",
                        "  var matches = /top|bottom/.exec(orientation);",
                        "",
                        "  return matches && matches[0];",
                        "}",
                        "",
                        "function isOppositeOrientation(a, b) {",
                        "  return oppositeOrientationMapping[a] === b;",
                        "}",
                        "",
                        "function isOppositeHorizontalOrientation(a, b) {",
                        "  var horizontalOrientation = getHorizontalOrientation(a);",
                        "",
                        "  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];",
                        "",
                        "  return b.indexOf(oppositeHorizontalOrientation) !== -1;",
                        "}",
                        "",
                        "function isOppositeVerticalOrientation(a, b) {",
                        "  var verticalOrientation = getVerticalOrientation(a);",
                        "",
                        "  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];",
                        "",
                        "  return b.indexOf(oppositeVerticalOrientation) !== -1;",
                        "}",
                        "",
                        "function isHorizontalOrientation(orientation) {",
                        "  return orientation === 'right' || orientation === 'left';",
                        "}",
                        "",
                        "function getLoopPreferredLayout(source, connection) {",
                        "  var waypoints = connection.waypoints;",
                        "",
                        "  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);",
                        "",
                        "  if (orientation === 'top') {",
                        "    return [ 't:r' ];",
                        "  } else if (orientation === 'right') {",
                        "    return [ 'r:b' ];",
                        "  } else if (orientation === 'left') {",
                        "    return [ 'l:t' ];",
                        "  }",
                        "",
                        "  return [ 'b:l' ];",
                        "}",
                        "",
                        "function getBoundaryEventPreferredLayouts(source, target, end) {",
                        "  var sourceMid = getMid(source),",
                        "      targetMid = getMid(target),",
                        "      attachOrientation = getAttachOrientation(source),",
                        "      sourceLayout,",
                        "      targetLayout;",
                        "",
                        "  var isLoop = isSame(source.host, target);",
                        "",
                        "  var attachedToSide = isAnyOrientation(attachOrientation, [ 'top', 'right', 'bottom', 'left' ]);",
                        "",
                        "  var targetOrientation = getOrientation(targetMid, sourceMid, {",
                        "    x: source.width / 2 + target.width / 2,",
                        "    y: source.height / 2 + target.height / 2",
                        "  });",
                        "",
                        "  if (isLoop) {",
                        "    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);",
                        "  }",
                        "",
                        "  // source layout",
                        "  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide);",
                        "",
                        "  // target layout",
                        "  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);",
                        "",
                        "  return [ sourceLayout + ':' + targetLayout ];",
                        "}",
                        "",
                        "function getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {",
                        "  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation),",
                        "      sourceLayout = orientationDirectionMapping[ orientation ],",
                        "      targetLayout;",
                        "",
                        "  if (attachedToSide) {",
                        "    if (isHorizontalOrientation(attachOrientation)) {",
                        "      targetLayout = shouldConnectToSameSide('y', source, target, end) ? 'h' : 'b';",
                        "    } else {",
                        "      targetLayout = shouldConnectToSameSide('x', source, target, end) ? 'v' : 'l';",
                        "    }",
                        "  } else {",
                        "    targetLayout = 'v';",
                        "  }",
                        "",
                        "  return [ sourceLayout + ':' + targetLayout ];",
                        "}",
                        "",
                        "function shouldConnectToSameSide(axis, source, target, end) {",
                        "  var threshold = BOUNDARY_TO_HOST_THRESHOLD;",
                        "",
                        "  return !(",
                        "    areCloseOnAxis(axis, end, target, threshold) ||",
                        "    areCloseOnAxis(axis, end, {",
                        "      x: target.x + target.width,",
                        "      y: target.y + target.height",
                        "    }, threshold) ||",
                        "    areCloseOnAxis(axis, end, getMid(source), threshold)",
                        "  );",
                        "}",
                        "",
                        "function areCloseOnAxis(axis, a, b, threshold) {",
                        "  return Math.abs(a[ axis ] - b[ axis ]) < threshold;",
                        "}",
                        "",
                        "function getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {",
                        "",
                        "  // attached to either top, right, bottom or left side",
                        "  if (attachedToSide) {",
                        "    return orientationDirectionMapping[ attachOrientation ];",
                        "  }",
                        "",
                        "  // attached to either top-right, top-left, bottom-right or bottom-left corner",
                        "",
                        "  // same vertical or opposite horizontal orientation",
                        "  if (isSame(",
                        "    getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)",
                        "  ) || isOppositeOrientation(",
                        "    getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation)",
                        "  )) {",
                        "    return orientationDirectionMapping[ getVerticalOrientation(attachOrientation) ];",
                        "  }",
                        "",
                        "  // fallback",
                        "  return orientationDirectionMapping[ getHorizontalOrientation(attachOrientation) ];",
                        "}",
                        "",
                        "function getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {",
                        "",
                        "  // attached to either top, right, bottom or left side",
                        "  if (attachedToSide) {",
                        "    if (isHorizontalOrientation(attachOrientation)) {",
                        "",
                        "      // orientation is right or left",
                        "",
                        "      // opposite horizontal orientation or same orientation",
                        "      if (",
                        "        isOppositeHorizontalOrientation(attachOrientation, targetOrientation) ||",
                        "        isSame(attachOrientation, targetOrientation)",
                        "      ) {",
                        "        return 'h';",
                        "      }",
                        "",
                        "      // fallback",
                        "      return 'v';",
                        "    } else {",
                        "",
                        "      // orientation is top or bottom",
                        "",
                        "      // opposite vertical orientation or same orientation",
                        "      if (",
                        "        isOppositeVerticalOrientation(attachOrientation, targetOrientation) ||",
                        "        isSame(attachOrientation, targetOrientation)",
                        "      ) {",
                        "        return 'v';",
                        "      }",
                        "",
                        "      // fallback",
                        "      return 'h';",
                        "    }",
                        "  }",
                        "",
                        "  // attached to either top-right, top-left, bottom-right or bottom-left corner",
                        "",
                        "  // orientation is right, left",
                        "  // or same vertical orientation but also right or left",
                        "  if (isHorizontalOrientation(targetOrientation) ||",
                        "    (isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) &&",
                        "      getHorizontalOrientation(targetOrientation))) {",
                        "    return 'h';",
                        "  } else {",
                        "    return 'v';",
                        "  }",
                        "}"
                    ]
                },
                "BpmnUpdater.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  assign,",
                        "  forEach",
                        "} from 'min-dash';",
                        "",
                        "import inherits from 'inherits-browser';",
                        "",
                        "import {",
                        "  add as collectionAdd,",
                        "  remove as collectionRemove",
                        "} from 'diagram-js/lib/util/Collections';",
                        "",
                        "import {",
                        "  getBusinessObject,",
                        "  getDi,",
                        "  is",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import { isAny } from './util/ModelingUtil';",
                        "",
                        "import {",
                        "  getLabel,",
                        "  isLabel,",
                        "  isLabelExternal",
                        "} from '../../util/LabelUtil';",
                        "",
                        "import { delta } from 'diagram-js/lib/util/PositionUtil';",
                        "",
                        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('./BpmnFactory').default} BpmnFactory",
                        " * @typedef {import('diagram-js/lib/layout/CroppingConnectionDocking').default} CroppingConnectionDocking",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " *",
                        " * @typedef {import('../../model/Types').Connection} Connection",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " * @typedef {import('../../model/Types').Parent} Parent",
                        " * @typedef {import('../../model/Types').ModdleElement} ModdleElement",
                        " */",
                        "",
                        "/**",
                        " * A handler responsible for updating the underlying BPMN 2.0 XML & DI",
                        " * once changes on the diagram happen.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {BpmnFactory} bpmnFactory",
                        " * @param {CroppingConnectionDocking} connectionDocking",
                        " * @param {Translate} translate",
                        " */",
                        "export default function BpmnUpdater(",
                        "    eventBus,",
                        "    bpmnFactory,",
                        "    connectionDocking,",
                        "    translate",
                        ") {",
                        "",
                        "  CommandInterceptor.call(this, eventBus);",
                        "",
                        "  this._bpmnFactory = bpmnFactory;",
                        "  this._translate = translate;",
                        "",
                        "  var self = this;",
                        "",
                        "",
                        "",
                        "  // connection cropping //////////////////////",
                        "",
                        "  // crop connection ends during create/update",
                        "  function cropConnection(e) {",
                        "    var context = e.context,",
                        "        hints = context.hints || {},",
                        "        connection;",
                        "",
                        "    if (!context.cropped && hints.createElementsBehavior !== false) {",
                        "      connection = context.connection;",
                        "      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);",
                        "      context.cropped = true;",
                        "    }",
                        "  }",
                        "",
                        "  this.executed([",
                        "    'connection.layout',",
                        "    'connection.create'",
                        "  ], cropConnection);",
                        "",
                        "  this.reverted([ 'connection.layout' ], function(e) {",
                        "    delete e.context.cropped;",
                        "  });",
                        "",
                        "",
                        "",
                        "  // BPMN + DI update //////////////////////",
                        "",
                        "",
                        "  // update parent",
                        "  function updateParent(e) {",
                        "    var context = e.context;",
                        "",
                        "    self.updateParent(context.shape || context.connection, context.oldParent);",
                        "  }",
                        "",
                        "  function reverseUpdateParent(e) {",
                        "    var context = e.context;",
                        "",
                        "    var element = context.shape || context.connection,",
                        "",
                        "        // oldParent is the (old) new parent, because we are undoing",
                        "        oldParent = context.parent || context.newParent;",
                        "",
                        "    self.updateParent(element, oldParent);",
                        "  }",
                        "",
                        "  this.executed([",
                        "    'shape.move',",
                        "    'shape.create',",
                        "    'shape.delete',",
                        "    'connection.create',",
                        "    'connection.move',",
                        "    'connection.delete'",
                        "  ], ifBpmn(updateParent));",
                        "",
                        "  this.reverted([",
                        "    'shape.move',",
                        "    'shape.create',",
                        "    'shape.delete',",
                        "    'connection.create',",
                        "    'connection.move',",
                        "    'connection.delete'",
                        "  ], ifBpmn(reverseUpdateParent));",
                        "",
                        "  /*",
                        "   * ## Updating Parent",
                        "   *",
                        "   * When morphing a Process into a Collaboration or vice-versa,",
                        "   * make sure that both the *semantic* and *di* parent of each element",
                        "   * is updated.",
                        "   *",
                        "   */",
                        "  function updateRoot(event) {",
                        "    var context = event.context,",
                        "        oldRoot = context.oldRoot,",
                        "        children = oldRoot.children;",
                        "",
                        "    forEach(children, function(child) {",
                        "      if (is(child, 'bpmn:BaseElement')) {",
                        "        self.updateParent(child);",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  this.executed([ 'canvas.updateRoot' ], updateRoot);",
                        "  this.reverted([ 'canvas.updateRoot' ], updateRoot);",
                        "",
                        "",
                        "  // update bounds",
                        "  function updateBounds(e) {",
                        "    var shape = e.context.shape;",
                        "",
                        "    if (!is(shape, 'bpmn:BaseElement')) {",
                        "      return;",
                        "    }",
                        "",
                        "    self.updateBounds(shape);",
                        "  }",
                        "",
                        "  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {",
                        "",
                        "    // exclude labels because they're handled separately during shape.changed",
                        "    if (event.context.shape.type === 'label') {",
                        "      return;",
                        "    }",
                        "",
                        "    updateBounds(event);",
                        "  }));",
                        "",
                        "  this.reverted([ 'shape.move', 'shape.create', 'shape.resize' ], ifBpmn(function(event) {",
                        "",
                        "    // exclude labels because they're handled separately during shape.changed",
                        "    if (event.context.shape.type === 'label') {",
                        "      return;",
                        "    }",
                        "",
                        "    updateBounds(event);",
                        "  }));",
                        "",
                        "  // Handle labels separately. This is necessary, because the label bounds have to be updated",
                        "  // every time its shape changes, not only on move, create and resize.",
                        "  eventBus.on('shape.changed', function(event) {",
                        "    if (event.element.type === 'label') {",
                        "      updateBounds({ context: { shape: event.element } });",
                        "    }",
                        "  });",
                        "",
                        "  // attach / detach connection",
                        "  function updateConnection(e) {",
                        "    self.updateConnection(e.context);",
                        "  }",
                        "",
                        "  this.executed([",
                        "    'connection.create',",
                        "    'connection.move',",
                        "    'connection.delete',",
                        "    'connection.reconnect'",
                        "  ], ifBpmn(updateConnection));",
                        "",
                        "  this.reverted([",
                        "    'connection.create',",
                        "    'connection.move',",
                        "    'connection.delete',",
                        "    'connection.reconnect'",
                        "  ], ifBpmn(updateConnection));",
                        "",
                        "",
                        "  // update waypoints",
                        "  function updateConnectionWaypoints(e) {",
                        "    self.updateConnectionWaypoints(e.context.connection);",
                        "  }",
                        "",
                        "  this.executed([",
                        "    'connection.layout',",
                        "    'connection.move',",
                        "    'connection.updateWaypoints',",
                        "  ], ifBpmn(updateConnectionWaypoints));",
                        "",
                        "  this.reverted([",
                        "    'connection.layout',",
                        "    'connection.move',",
                        "    'connection.updateWaypoints',",
                        "  ], ifBpmn(updateConnectionWaypoints));",
                        "",
                        "  // update conditional/default flows",
                        "  this.executed('connection.reconnect', ifBpmn(function(event) {",
                        "    var context = event.context,",
                        "        connection = context.connection,",
                        "        oldSource = context.oldSource,",
                        "        newSource = context.newSource,",
                        "        connectionBo = getBusinessObject(connection),",
                        "        oldSourceBo = getBusinessObject(oldSource),",
                        "        newSourceBo = getBusinessObject(newSource);",
                        "",
                        "    // remove condition from connection on reconnect to new source",
                        "    // if new source can NOT have condional sequence flow",
                        "    if (connectionBo.conditionExpression && !isAny(newSourceBo, [",
                        "      'bpmn:Activity',",
                        "      'bpmn:ExclusiveGateway',",
                        "      'bpmn:InclusiveGateway'",
                        "    ])) {",
                        "      context.oldConditionExpression = connectionBo.conditionExpression;",
                        "",
                        "      delete connectionBo.conditionExpression;",
                        "    }",
                        "",
                        "    // remove default from old source flow on reconnect to new source",
                        "    // if source changed",
                        "    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {",
                        "      context.oldDefault = oldSourceBo.default;",
                        "",
                        "      delete oldSourceBo.default;",
                        "    }",
                        "  }));",
                        "",
                        "  this.reverted('connection.reconnect', ifBpmn(function(event) {",
                        "    var context = event.context,",
                        "        connection = context.connection,",
                        "        oldSource = context.oldSource,",
                        "        newSource = context.newSource,",
                        "        connectionBo = getBusinessObject(connection),",
                        "        oldSourceBo = getBusinessObject(oldSource),",
                        "        newSourceBo = getBusinessObject(newSource);",
                        "",
                        "    // add condition to connection on revert reconnect to new source",
                        "    if (context.oldConditionExpression) {",
                        "      connectionBo.conditionExpression = context.oldConditionExpression;",
                        "    }",
                        "",
                        "    // add default to old source on revert reconnect to new source",
                        "    if (context.oldDefault) {",
                        "      oldSourceBo.default = context.oldDefault;",
                        "",
                        "      delete newSourceBo.default;",
                        "    }",
                        "  }));",
                        "",
                        "  // update attachments",
                        "  function updateAttachment(e) {",
                        "    self.updateAttachment(e.context);",
                        "  }",
                        "",
                        "  this.executed([ 'element.updateAttachment' ], ifBpmn(updateAttachment));",
                        "  this.reverted([ 'element.updateAttachment' ], ifBpmn(updateAttachment));",
                        "",
                        "",
                        "  // update BPMNLabel",
                        "  this.executed('element.updateLabel', ifBpmn(updateBPMNLabel));",
                        "  this.reverted('element.updateLabel', ifBpmn(updateBPMNLabel));",
                        "",
                        "  function updateBPMNLabel(event) {",
                        "    const { element } = event.context,",
                        "          label = getLabel(element);",
                        "    const di = getDi(element),",
                        "          diLabel = di && di.get('label');",
                        "",
                        "    if (isLabelExternal(element)) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (label && !diLabel) {",
                        "      di.set('label', bpmnFactory.create('bpmndi:BPMNLabel'));",
                        "    } else if (!label && diLabel) {",
                        "      di.set('label', undefined);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "inherits(BpmnUpdater, CommandInterceptor);",
                        "",
                        "BpmnUpdater.$inject = [",
                        "  'eventBus',",
                        "  'bpmnFactory',",
                        "  'connectionDocking',",
                        "  'translate'",
                        "];",
                        "",
                        "",
                        "// implementation //////////////////////",
                        "",
                        "/**",
                        " * @param { {",
                        " *   shape: Shape;",
                        " *   host: Shape;",
                        " * } } context",
                        " */",
                        "BpmnUpdater.prototype.updateAttachment = function(context) {",
                        "",
                        "  var shape = context.shape,",
                        "      businessObject = shape.businessObject,",
                        "      host = shape.host;",
                        "",
                        "  businessObject.attachedToRef = host && host.businessObject;",
                        "};",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " * @param {Parent} oldParent",
                        " */",
                        "BpmnUpdater.prototype.updateParent = function(element, oldParent) {",
                        "",
                        "  // do not update BPMN 2.0 label parent",
                        "  if (isLabel(element)) {",
                        "    return;",
                        "  }",
                        "",
                        "  // data stores in collaborations are handled separately by DataStoreBehavior",
                        "  if (is(element, 'bpmn:DataStoreReference') &&",
                        "      element.parent &&",
                        "      is(element.parent, 'bpmn:Collaboration')) {",
                        "    return;",
                        "  }",
                        "",
                        "  var parentShape = element.parent;",
                        "",
                        "  var businessObject = element.businessObject,",
                        "      di = getDi(element),",
                        "      parentBusinessObject = parentShape && parentShape.businessObject,",
                        "      parentDi = getDi(parentShape);",
                        "",
                        "  if (is(element, 'bpmn:FlowNode')) {",
                        "    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);",
                        "  }",
                        "",
                        "  if (is(element, 'bpmn:DataOutputAssociation')) {",
                        "    if (element.source) {",
                        "      parentBusinessObject = element.source.businessObject;",
                        "    } else {",
                        "      parentBusinessObject = null;",
                        "    }",
                        "  }",
                        "",
                        "  if (is(element, 'bpmn:DataInputAssociation')) {",
                        "    if (element.target) {",
                        "      parentBusinessObject = element.target.businessObject;",
                        "    } else {",
                        "      parentBusinessObject = null;",
                        "    }",
                        "  }",
                        "",
                        "  this.updateSemanticParent(businessObject, parentBusinessObject);",
                        "",
                        "  if (is(element, 'bpmn:DataObjectReference') && businessObject.dataObjectRef) {",
                        "    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);",
                        "  }",
                        "",
                        "  this.updateDiParent(di, parentDi);",
                        "};",
                        "",
                        "/**",
                        " * @param {Shape} shape",
                        " */",
                        "BpmnUpdater.prototype.updateBounds = function(shape) {",
                        "",
                        "  var di = getDi(shape),",
                        "      embeddedLabelBounds = getEmbeddedLabelBounds(shape);",
                        "",
                        "  // update embedded label bounds if possible",
                        "  if (embeddedLabelBounds) {",
                        "    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get('bounds'));",
                        "",
                        "    assign(embeddedLabelBounds, {",
                        "      x: shape.x + embeddedLabelBoundsDelta.x,",
                        "      y: shape.y + embeddedLabelBoundsDelta.y",
                        "    });",
                        "  }",
                        "",
                        "  var target = isLabel(shape) ? this._getLabel(di) : di;",
                        "",
                        "  var bounds = target.bounds;",
                        "",
                        "  if (!bounds) {",
                        "    bounds = this._bpmnFactory.createDiBounds();",
                        "    target.set('bounds', bounds);",
                        "  }",
                        "",
                        "  assign(bounds, {",
                        "    x: shape.x,",
                        "    y: shape.y,",
                        "    width: shape.width,",
                        "    height: shape.height",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} businessObject",
                        " * @param {ModdleElement} newContainment",
                        " * @param {ModdleElement} oldContainment",
                        " */",
                        "BpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {",
                        "",
                        "  if (oldContainment === newContainment) {",
                        "    return;",
                        "  }",
                        "",
                        "  var oldRefs, newRefs;",
                        "",
                        "  if (is (oldContainment, 'bpmn:Lane')) {",
                        "    oldRefs = oldContainment.get('flowNodeRef');",
                        "    collectionRemove(oldRefs, businessObject);",
                        "  }",
                        "",
                        "  if (is(newContainment, 'bpmn:Lane')) {",
                        "    newRefs = newContainment.get('flowNodeRef');",
                        "    collectionAdd(newRefs, businessObject);",
                        "  }",
                        "};",
                        "",
                        "/**",
                        " * @param {Connection} connection",
                        " * @param {Element} newSource",
                        " * @param {Element} newTarget",
                        " */",
                        "BpmnUpdater.prototype.updateDiConnection = function(connection, newSource, newTarget) {",
                        "  var connectionDi = getDi(connection),",
                        "      newSourceDi = getDi(newSource),",
                        "      newTargetDi = getDi(newTarget);",
                        "",
                        "  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {",
                        "    connectionDi.sourceElement = newSource && newSourceDi;",
                        "  }",
                        "",
                        "  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {",
                        "    connectionDi.targetElement = newTarget && newTargetDi;",
                        "  }",
                        "",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} di",
                        " * @param {ModdleElement} parentDi",
                        " */",
                        "BpmnUpdater.prototype.updateDiParent = function(di, parentDi) {",
                        "",
                        "  if (parentDi && !is(parentDi, 'bpmndi:BPMNPlane')) {",
                        "    parentDi = parentDi.$parent;",
                        "  }",
                        "",
                        "  if (di.$parent === parentDi) {",
                        "    return;",
                        "  }",
                        "",
                        "  var planeElements = (parentDi || di.$parent).get('planeElement');",
                        "",
                        "  if (parentDi) {",
                        "    planeElements.push(di);",
                        "    di.$parent = parentDi;",
                        "  } else {",
                        "    collectionRemove(planeElements, di);",
                        "    di.$parent = null;",
                        "  }",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} element",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "function getDefinitions(element) {",
                        "  while (element && !is(element, 'bpmn:Definitions')) {",
                        "    element = element.$parent;",
                        "  }",
                        "",
                        "  return element;",
                        "}",
                        "",
                        "/**",
                        " * @param {ModdleElement} container",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "BpmnUpdater.prototype.getLaneSet = function(container) {",
                        "",
                        "  var laneSet, laneSets;",
                        "",
                        "  // bpmn:Lane",
                        "  if (is(container, 'bpmn:Lane')) {",
                        "    laneSet = container.childLaneSet;",
                        "",
                        "    if (!laneSet) {",
                        "      laneSet = this._bpmnFactory.create('bpmn:LaneSet');",
                        "      container.childLaneSet = laneSet;",
                        "      laneSet.$parent = container;",
                        "    }",
                        "",
                        "    return laneSet;",
                        "  }",
                        "",
                        "  // bpmn:Participant",
                        "  if (is(container, 'bpmn:Participant')) {",
                        "    container = container.processRef;",
                        "  }",
                        "",
                        "  // bpmn:FlowElementsContainer",
                        "  laneSets = container.get('laneSets');",
                        "  laneSet = laneSets[0];",
                        "",
                        "  if (!laneSet) {",
                        "    laneSet = this._bpmnFactory.create('bpmn:LaneSet');",
                        "    laneSet.$parent = container;",
                        "    laneSets.push(laneSet);",
                        "  }",
                        "",
                        "  return laneSet;",
                        "};",
                        "",
                        "/**",
                        " * @param {ModdleElement} businessObject",
                        " * @param {ModdleElement} newParent",
                        " * @param {ModdleElement} visualParent",
                        " */",
                        "BpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {",
                        "",
                        "  var containment,",
                        "      translate = this._translate;",
                        "",
                        "  if (businessObject.$parent === newParent) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:DataInput') || is(businessObject, 'bpmn:DataOutput')) {",
                        "",
                        "    if (is(newParent, 'bpmn:Participant') && 'processRef' in newParent) {",
                        "      newParent = newParent.processRef;",
                        "    }",
                        "",
                        "    // already in correct ioSpecification",
                        "    if ('ioSpecification' in newParent && newParent.ioSpecification === businessObject.$parent) {",
                        "      return;",
                        "    }",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:Lane')) {",
                        "",
                        "    if (newParent) {",
                        "      newParent = this.getLaneSet(newParent);",
                        "    }",
                        "",
                        "    containment = 'lanes';",
                        "  } else",
                        "",
                        "  if (is(businessObject, 'bpmn:FlowElement')) {",
                        "",
                        "    if (newParent) {",
                        "",
                        "      if (is(newParent, 'bpmn:Participant')) {",
                        "        newParent = newParent.processRef;",
                        "      } else",
                        "",
                        "      if (is(newParent, 'bpmn:Lane')) {",
                        "        do {",
                        "",
                        "          // unwrap Lane -> LaneSet -> (Lane | FlowElementsContainer)",
                        "          newParent = newParent.$parent.$parent;",
                        "        } while (is(newParent, 'bpmn:Lane'));",
                        "",
                        "      }",
                        "    }",
                        "",
                        "    containment = 'flowElements';",
                        "",
                        "  } else",
                        "",
                        "  if (is(businessObject, 'bpmn:Artifact')) {",
                        "",
                        "    while (newParent &&",
                        "           !is(newParent, 'bpmn:Process') &&",
                        "           !is(newParent, 'bpmn:SubProcess') &&",
                        "           !is(newParent, 'bpmn:Collaboration')) {",
                        "",
                        "      if (is(newParent, 'bpmn:Participant')) {",
                        "        newParent = newParent.processRef;",
                        "        break;",
                        "      } else {",
                        "        newParent = newParent.$parent;",
                        "      }",
                        "    }",
                        "",
                        "    containment = 'artifacts';",
                        "  } else",
                        "",
                        "  if (is(businessObject, 'bpmn:MessageFlow')) {",
                        "    containment = 'messageFlows';",
                        "",
                        "  } else",
                        "",
                        "  if (is(businessObject, 'bpmn:Participant')) {",
                        "    containment = 'participants';",
                        "",
                        "    // make sure the participants process is properly attached / detached",
                        "    // from the XML document",
                        "",
                        "    var process = businessObject.processRef,",
                        "        definitions;",
                        "",
                        "    if (process) {",
                        "      definitions = getDefinitions(businessObject.$parent || newParent);",
                        "",
                        "      if (businessObject.$parent) {",
                        "        collectionRemove(definitions.get('rootElements'), process);",
                        "        process.$parent = null;",
                        "      }",
                        "",
                        "      if (newParent) {",
                        "        collectionAdd(definitions.get('rootElements'), process);",
                        "        process.$parent = definitions;",
                        "      }",
                        "    }",
                        "  } else",
                        "",
                        "  if (is(businessObject, 'bpmn:DataOutputAssociation')) {",
                        "    containment = 'dataOutputAssociations';",
                        "  } else",
                        "",
                        "  if (is(businessObject, 'bpmn:DataInputAssociation')) {",
                        "    containment = 'dataInputAssociations';",
                        "  }",
                        "",
                        "  if (!containment) {",
                        "    throw new Error(translate(",
                        "      'no parent for {element} in {parent}',",
                        "      {",
                        "        element: businessObject.id,",
                        "        parent: newParent.id",
                        "      }",
                        "    ));",
                        "  }",
                        "",
                        "  var children;",
                        "",
                        "  if (businessObject.$parent) {",
                        "",
                        "    // remove from old parent",
                        "    children = businessObject.$parent.get(containment);",
                        "    collectionRemove(children, businessObject);",
                        "  }",
                        "",
                        "  if (!newParent) {",
                        "    businessObject.$parent = null;",
                        "  } else {",
                        "",
                        "    // add to new parent",
                        "    children = newParent.get(containment);",
                        "    children.push(businessObject);",
                        "    businessObject.$parent = newParent;",
                        "  }",
                        "",
                        "  if (visualParent) {",
                        "    var diChildren = visualParent.get(containment);",
                        "",
                        "    collectionRemove(children, businessObject);",
                        "",
                        "    if (newParent) {",
                        "",
                        "      if (!diChildren) {",
                        "        diChildren = [];",
                        "        newParent.set(containment, diChildren);",
                        "      }",
                        "",
                        "      diChildren.push(businessObject);",
                        "    }",
                        "  }",
                        "};",
                        "",
                        "/**",
                        " * @param {Connection} connection",
                        " */",
                        "BpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {",
                        "  var di = getDi(connection);",
                        "",
                        "  di.set('waypoint', this._bpmnFactory.createDiWaypoints(connection.waypoints));",
                        "};",
                        "",
                        "/**",
                        " * @param { {",
                        " *   connection: Connection;",
                        " *   parent: Parent;",
                        " *   newParent: Parent;",
                        " * } } context",
                        " */",
                        "BpmnUpdater.prototype.updateConnection = function(context) {",
                        "  var connection = context.connection,",
                        "      businessObject = getBusinessObject(connection),",
                        "      newSource = connection.source,",
                        "      newSourceBo = getBusinessObject(newSource),",
                        "      newTarget = connection.target,",
                        "      newTargetBo = getBusinessObject(connection.target),",
                        "      visualParent;",
                        "",
                        "  if (!is(businessObject, 'bpmn:DataAssociation')) {",
                        "",
                        "    var inverseSet = is(businessObject, 'bpmn:SequenceFlow');",
                        "",
                        "    if (businessObject.sourceRef !== newSourceBo) {",
                        "      if (inverseSet) {",
                        "        collectionRemove(businessObject.sourceRef && businessObject.sourceRef.get('outgoing'), businessObject);",
                        "",
                        "        if (newSourceBo && newSourceBo.get('outgoing')) {",
                        "          newSourceBo.get('outgoing').push(businessObject);",
                        "        }",
                        "      }",
                        "",
                        "      businessObject.sourceRef = newSourceBo;",
                        "    }",
                        "",
                        "    if (businessObject.targetRef !== newTargetBo) {",
                        "      if (inverseSet) {",
                        "        collectionRemove(businessObject.targetRef && businessObject.targetRef.get('incoming'), businessObject);",
                        "",
                        "        if (newTargetBo && newTargetBo.get('incoming')) {",
                        "          newTargetBo.get('incoming').push(businessObject);",
                        "        }",
                        "      }",
                        "",
                        "      businessObject.targetRef = newTargetBo;",
                        "    }",
                        "  } else",
                        "",
                        "  if (is(businessObject, 'bpmn:DataInputAssociation')) {",
                        "",
                        "    // handle obnoxious isMsome sourceRef",
                        "    businessObject.get('sourceRef')[0] = newSourceBo;",
                        "",
                        "    visualParent = context.parent || context.newParent || newTargetBo;",
                        "",
                        "    this.updateSemanticParent(businessObject, newTargetBo, visualParent);",
                        "  } else",
                        "",
                        "  if (is(businessObject, 'bpmn:DataOutputAssociation')) {",
                        "    visualParent = context.parent || context.newParent || newSourceBo;",
                        "",
                        "    this.updateSemanticParent(businessObject, newSourceBo, visualParent);",
                        "",
                        "    // targetRef = new target",
                        "    businessObject.targetRef = newTargetBo;",
                        "  }",
                        "",
                        "  this.updateConnectionWaypoints(connection);",
                        "",
                        "  this.updateDiConnection(connection, newSource, newTarget);",
                        "};",
                        "",
                        "",
                        "// helpers //////////////////////",
                        "",
                        "BpmnUpdater.prototype._getLabel = function(di) {",
                        "  if (!di.label) {",
                        "    di.label = this._bpmnFactory.createDiLabel();",
                        "  }",
                        "",
                        "  return di.label;",
                        "};",
                        "",
                        "",
                        "/**",
                        " * Call function if shape or connection is BPMN element.",
                        " *",
                        " * @param  {Function} fn",
                        " *",
                        " * @return {Function}",
                        " */",
                        "function ifBpmn(fn) {",
                        "",
                        "  return function(event) {",
                        "",
                        "    var context = event.context,",
                        "        element = context.shape || context.connection || context.element;",
                        "",
                        "    if (is(element, 'bpmn:BaseElement')) {",
                        "      fn(event);",
                        "    }",
                        "  };",
                        "}",
                        "",
                        "/**",
                        " * Return dc:Bounds of bpmndi:BPMNLabel if exists.",
                        " *",
                        " * @param {Shape} shape",
                        " *",
                        " * @return {ModdleElement|undefined}",
                        " */",
                        "function getEmbeddedLabelBounds(shape) {",
                        "  if (!is(shape, 'bpmn:Activity')) {",
                        "    return;",
                        "  }",
                        "",
                        "  var di = getDi(shape);",
                        "",
                        "  if (!di) {",
                        "    return;",
                        "  }",
                        "",
                        "  var label = di.get('label');",
                        "",
                        "  if (!label) {",
                        "    return;",
                        "  }",
                        "",
                        "  return label.get('bounds');",
                        "}"
                    ]
                },
                "ElementFactory.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  assign,",
                        "  forEach,",
                        "  isDefined,",
                        "  isObject,",
                        "  omit",
                        "} from 'min-dash';",
                        "",
                        "import inherits from 'inherits-browser';",
                        "",
                        "import {",
                        "  getBusinessObject,",
                        "  getDi,",
                        "  is",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  isAny",
                        "} from '../modeling/util/ModelingUtil';",
                        "",
                        "import {",
                        "  isExpanded",
                        "} from '../../util/DiUtil';",
                        "",
                        "import BaseElementFactory from 'diagram-js/lib/core/ElementFactory';",
                        "",
                        "import {",
                        "  DEFAULT_LABEL_SIZE",
                        "} from '../../util/LabelUtil';",
                        "",
                        "import {",
                        "  ensureCompatDiRef",
                        "} from '../../util/CompatibilityUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Dimensions} Dimensions",
                        " *",
                        " * @typedef {import('./BpmnFactory').default} BpmnFactory",
                        " *",
                        " * @typedef {import('../../model/Types').BpmnAttributes} BpmnAttributes",
                        " * @typedef {import('../../model/Types').Connection} Connection",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Label} Label",
                        " * @typedef {import('../../model/Types').Root} Root",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " * @typedef {import('../../model/Types').Moddle} Moddle",
                        " * @typedef {import('../../model/Types').ModdleElement} ModdleElement",
                        " */",
                        "",
                        "/**",
                        " * A BPMN-specific element factory.",
                        " *",
                        " * @template {Connection} [T=Connection]",
                        " * @template {Label} [U=Label]",
                        " * @template {Root} [V=Root]",
                        " * @template {Shape} [W=Shape]",
                        " *",
                        " * @extends {BaseElementFactory<T, U, V, W>}",
                        " *",
                        " * @param {BpmnFactory} bpmnFactory",
                        " * @param {Moddle} moddle",
                        " * @param {Translate} translate",
                        " */",
                        "export default function ElementFactory(bpmnFactory, moddle, translate) {",
                        "  BaseElementFactory.call(this);",
                        "",
                        "  this._bpmnFactory = bpmnFactory;",
                        "  this._moddle = moddle;",
                        "  this._translate = translate;",
                        "}",
                        "",
                        "inherits(ElementFactory, BaseElementFactory);",
                        "",
                        "ElementFactory.$inject = [",
                        "  'bpmnFactory',",
                        "  'moddle',",
                        "  'translate'",
                        "];",
                        "",
                        "ElementFactory.prototype._baseCreate = BaseElementFactory.prototype.create;",
                        "",
                        "/**",
                        " * Create a root element.",
                        " *",
                        " * @overlord",
                        " * @param {'root'} elementType",
                        " * @param {Partial<Root> & Partial<BpmnAttributes>} [attrs]",
                        " * @return {V}",
                        " */",
                        "",
                        "/**",
                        " * Create a shape.",
                        " *",
                        " * @overlord",
                        " * @param {'shape'} elementType",
                        " * @param {Partial<Shape> & Partial<BpmnAttributes>} [attrs]",
                        " * @return {W}",
                        " */",
                        "",
                        "/**",
                        " * Create a connection.",
                        " *",
                        " * @overlord",
                        " * @param {'connection'} elementType",
                        " * @param {Partial<Connection> & Partial<BpmnAttributes>} [attrs]",
                        " * @return {T}",
                        " */",
                        "",
                        "/**",
                        " * Create a label.",
                        " *",
                        " * @param {'label'} elementType",
                        " * @param {Partial<Label> & Partial<BpmnAttributes>} [attrs]",
                        " * @return {U}",
                        " */",
                        "ElementFactory.prototype.create = function(elementType, attrs) {",
                        "",
                        "  // no special magic for labels,",
                        "  // we assume their businessObjects have already been created",
                        "  // and wired via attrs",
                        "  if (elementType === 'label') {",
                        "    var di = attrs.di || this._bpmnFactory.createDiLabel();",
                        "    return this._baseCreate(elementType, assign({ type: 'label', di: di }, DEFAULT_LABEL_SIZE, attrs));",
                        "  }",
                        "",
                        "  return this.createElement(elementType, attrs);",
                        "};",
                        "",
                        "/**",
                        " * Create a BPMN root element.",
                        " *",
                        " * @overlord",
                        " * @param {'root'} elementType",
                        " * @param {Partial<Root> & Partial<BpmnAttributes>} [attrs]",
                        " * @return {V}",
                        " */",
                        "",
                        "/**",
                        " * Create a BPMN shape.",
                        " *",
                        " * @overlord",
                        " * @param {'shape'} elementType",
                        " * @param {Partial<Shape> & Partial<BpmnAttributes>} [attrs]",
                        " * @return {W}",
                        " */",
                        "",
                        "/**",
                        " * Create a BPMN connection.",
                        " *",
                        " * @param {'connection'} elementType",
                        " * @param {Partial<Connection> & Partial<BpmnAttributes>} [attrs]",
                        " * @return {T}",
                        " */",
                        "ElementFactory.prototype.createElement = function(elementType, attrs) {",
                        "  var size,",
                        "      translate = this._translate;",
                        "",
                        "  attrs = assign({}, attrs || {});",
                        "",
                        "  var businessObject = attrs.businessObject,",
                        "      di = attrs.di;",
                        "",
                        "  if (!businessObject) {",
                        "    if (!attrs.type) {",
                        "      throw new Error(translate('no shape type specified'));",
                        "    }",
                        "",
                        "    businessObject = this._bpmnFactory.create(attrs.type);",
                        "",
                        "    ensureCompatDiRef(businessObject);",
                        "  }",
                        "",
                        "  if (!isModdleDi(di)) {",
                        "    var diAttrs = assign(",
                        "      {},",
                        "      di || {},",
                        "      { id: businessObject.id + '_di' }",
                        "    );",
                        "",
                        "    if (elementType === 'root') {",
                        "      di = this._bpmnFactory.createDiPlane(businessObject, diAttrs);",
                        "    } else",
                        "    if (elementType === 'connection') {",
                        "      di = this._bpmnFactory.createDiEdge(businessObject, diAttrs);",
                        "    } else {",
                        "      di = this._bpmnFactory.createDiShape(businessObject, diAttrs);",
                        "    }",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:Group')) {",
                        "    attrs = assign({",
                        "      isFrame: true",
                        "    }, attrs);",
                        "  }",
                        "",
                        "  attrs = applyAttributes(businessObject, attrs, [",
                        "    'processRef',",
                        "    'isInterrupting',",
                        "    'associationDirection',",
                        "    'isForCompensation'",
                        "  ]);",
                        "",
                        "  if (attrs.isExpanded) {",
                        "    attrs = applyAttribute(di, attrs, 'isExpanded');",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:SubProcess')) {",
                        "    attrs.collapsed = !isExpanded(businessObject, di);",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:ExclusiveGateway')) {",
                        "    di.isMarkerVisible = true;",
                        "  }",
                        "",
                        "  if (isDefined(attrs.triggeredByEvent)) {",
                        "    businessObject.triggeredByEvent = attrs.triggeredByEvent;",
                        "    delete attrs.triggeredByEvent;",
                        "  }",
                        "",
                        "  if (isDefined(attrs.cancelActivity)) {",
                        "    businessObject.cancelActivity = attrs.cancelActivity;",
                        "    delete attrs.cancelActivity;",
                        "  }",
                        "",
                        "  var eventDefinitions,",
                        "      newEventDefinition;",
                        "",
                        "  if (attrs.eventDefinitionType) {",
                        "    eventDefinitions = businessObject.get('eventDefinitions') || [];",
                        "    newEventDefinition = this._bpmnFactory.create(attrs.eventDefinitionType, attrs.eventDefinitionAttrs);",
                        "",
                        "    if (attrs.eventDefinitionType === 'bpmn:ConditionalEventDefinition') {",
                        "      newEventDefinition.condition = this._bpmnFactory.create('bpmn:FormalExpression');",
                        "    }",
                        "",
                        "    eventDefinitions.push(newEventDefinition);",
                        "",
                        "    newEventDefinition.$parent = businessObject;",
                        "    businessObject.eventDefinitions = eventDefinitions;",
                        "",
                        "    delete attrs.eventDefinitionType;",
                        "  }",
                        "",
                        "  size = this.getDefaultSize(businessObject, di);",
                        "",
                        "  attrs = assign({",
                        "    id: businessObject.id",
                        "  }, size, attrs, {",
                        "    businessObject: businessObject,",
                        "    di: di",
                        "  });",
                        "",
                        "  return this._baseCreate(elementType, attrs);",
                        "};",
                        "",
                        "/**",
                        " * Get the default size of a diagram element.",
                        " *",
                        " * @param {Element} element The element.",
                        " * @param {ModdleElement} di The DI.",
                        " *",
                        " * @return {Dimensions} Default width and height of the element.",
                        " */",
                        "ElementFactory.prototype.getDefaultSize = function(element, di) {",
                        "",
                        "  var bo = getBusinessObject(element);",
                        "  di = di || getDi(element);",
                        "",
                        "  if (is(bo, 'bpmn:SubProcess')) {",
                        "    if (isExpanded(bo, di)) {",
                        "      return { width: 350, height: 200 };",
                        "    } else {",
                        "      return { width: 100, height: 80 };",
                        "    }",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:Task')) {",
                        "    return { width: 100, height: 80 };",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:Gateway')) {",
                        "    return { width: 50, height: 50 };",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:Event')) {",
                        "    return { width: 36, height: 36 };",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:Participant')) {",
                        "    if (isExpanded(bo, di)) {",
                        "      return { width: 600, height: 250 };",
                        "    } else {",
                        "      return { width: 400, height: 60 };",
                        "    }",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:Lane')) {",
                        "    return { width: 400, height: 100 };",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:DataObjectReference')) {",
                        "    return { width: 36, height: 50 };",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:DataStoreReference')) {",
                        "    return { width: 50, height: 50 };",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:TextAnnotation')) {",
                        "    return { width: 100, height: 30 };",
                        "  }",
                        "",
                        "  if (is(bo, 'bpmn:Group')) {",
                        "    return { width: 300, height: 300 };",
                        "  }",
                        "",
                        "  return { width: 100, height: 80 };",
                        "};",
                        "",
                        "",
                        "/**",
                        " * Create participant.",
                        " *",
                        " * @param {boolean|Partial<Shape> & Partial<BpmnAttributes>} [attrs]",
                        " * Attributes or whether the participant is expanded.",
                        " *",
                        " * @return {W} The created participant.",
                        " */",
                        "ElementFactory.prototype.createParticipantShape = function(attrs) {",
                        "",
                        "  if (!isObject(attrs)) {",
                        "    attrs = { isExpanded: attrs };",
                        "  }",
                        "",
                        "  attrs = assign({ type: 'bpmn:Participant' }, attrs || {});",
                        "",
                        "  // participants are expanded by default",
                        "  if (attrs.isExpanded !== false) {",
                        "    attrs.processRef = this._bpmnFactory.create('bpmn:Process');",
                        "  }",
                        "",
                        "  return this.createShape(attrs);",
                        "};",
                        "",
                        "",
                        "// helpers //////////////////////",
                        "",
                        "/**",
                        " * Apply attributes from a map to the given element, remove attribute from the",
                        " * map on application.",
                        " *",
                        " * @param {Element} element",
                        " * @param {Object} attrs (in/out map of attributes)",
                        " * @param {string[]} attributeNames name of attributes to apply",
                        " *",
                        " * @return {Object} changed attrs",
                        " */",
                        "function applyAttributes(element, attrs, attributeNames) {",
                        "",
                        "  forEach(attributeNames, function(property) {",
                        "    attrs = applyAttribute(element, attrs, property);",
                        "  });",
                        "",
                        "  return attrs;",
                        "}",
                        "",
                        "/**",
                        " * Apply named property to element and drain it from the attrs collection.",
                        " *",
                        " * @param {Element} element",
                        " * @param {Object} attrs (in/out map of attributes)",
                        " * @param {string} attributeName to apply",
                        " *",
                        " * @return {Object} changed attrs",
                        " */",
                        "function applyAttribute(element, attrs, attributeName) {",
                        "  if (attrs[attributeName] === undefined) {",
                        "    return attrs;",
                        "  }",
                        "",
                        "  element[attributeName] = attrs[attributeName];",
                        "",
                        "  return omit(attrs, [ attributeName ]);",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isModdleDi(element) {",
                        "  return isAny(element, [",
                        "    'bpmndi:BPMNShape',",
                        "    'bpmndi:BPMNEdge',",
                        "    'bpmndi:BPMNDiagram',",
                        "    'bpmndi:BPMNPlane',",
                        "  ]);",
                        "}"
                    ]
                },
                "ElementFactory.test.ts": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import Modeler from '../../Modeler';",
                        "",
                        "import ElementFactory from './ElementFactory';",
                        "",
                        "import {",
                        "  Connection,",
                        "  Label,",
                        "  Root,",
                        "  Shape",
                        "} from '../../model/Types';",
                        "",
                        "const modeler = new Modeler();",
                        "",
                        "const elementFactory = modeler.get<ElementFactory>('elementFactory');",
                        "",
                        "const shape1 = elementFactory.create('shape', {",
                        "  type: 'bpmn:Task',",
                        "  id: 'shape1',",
                        "  x: 100,",
                        "  y: 100,",
                        "  width: 100,",
                        "  height: 100",
                        "});",
                        "",
                        "const shape2 = elementFactory.create('shape', {",
                        "  type: 'bpmn:Task',",
                        "  id: 'shape2',",
                        "  x: 100,",
                        "  y: 100,",
                        "  width: 100,",
                        "  height: 100",
                        "});",
                        "",
                        "const connection = elementFactory.create('connection', {",
                        "  type: 'bpmn:SequenceFlow',",
                        "  id: 'connection',",
                        "  source: shape1,",
                        "  target: shape2,",
                        "  waypoints: []",
                        "});",
                        "",
                        "elementFactory.create('root', {",
                        "  type: 'bpmn:Process',",
                        "  id: 'root'",
                        "});",
                        "",
                        "elementFactory.create('label', {",
                        "  type: 'bpmn:Task',",
                        "  id: 'label'",
                        "});",
                        "",
                        "elementFactory.create('shape', {",
                        "  type: 'bpmn:Task'",
                        "});",
                        "",
                        "elementFactory.create('connection', {",
                        "  type: 'bpmn:SequenceFlow'",
                        "});",
                        "",
                        "elementFactory.create('root', {",
                        "  type: 'bpmn:Process'",
                        "});",
                        "",
                        "elementFactory.create('label', {",
                        "  type: 'bpmn:Task'",
                        "});",
                        "",
                        "elementFactory.create('connection', {",
                        "  type: 'bpmn:Association',",
                        "  associationDirection: 'One'",
                        "});",
                        "",
                        "elementFactory.create('shape', {",
                        "  type: 'bpmn:BoundaryEvent',",
                        "  cancelActivity: true,",
                        "  eventDefinitionType: 'bpmn:ErrorEventDefinition'",
                        "});",
                        "",
                        "elementFactory.create('shape', {",
                        "  type: 'bpmn:Task',",
                        "  isForCompensation: false",
                        "});",
                        "",
                        "elementFactory.create('shape', {",
                        "  type: 'bpmn:Participant',",
                        "  processRef: {}",
                        "});",
                        "",
                        "elementFactory.create('shape', {",
                        "  type: 'bpmn:SubProcess',",
                        "  triggeredByEvent: true",
                        "});",
                        "",
                        "elementFactory.createElement('connection', {",
                        "  type: 'bpmn:SequenceFlow'",
                        "});",
                        "",
                        "elementFactory.createElement('root', {",
                        "  type: 'bpmn:Process'",
                        "});",
                        "",
                        "elementFactory.createElement('shape', {",
                        "  type: 'bpmn:Task'",
                        "});",
                        "",
                        "elementFactory.getDefaultSize(shape1, { type: 'bpmndi:BPMNShape' });",
                        "",
                        "elementFactory.getDefaultSize(connection, { type: 'bpmndi:BPMNEdge' });",
                        "",
                        "elementFactory.createParticipantShape();",
                        "",
                        "elementFactory.createParticipantShape(true);",
                        "",
                        "elementFactory.createParticipantShape({",
                        "  type: 'bpmn:Participant',",
                        "  isExpanded: true",
                        "});",
                        "",
                        "/**",
                        " * Customization",
                        " */",
                        "",
                        "type CustomShape = {",
                        "  foo: string;",
                        "} & Shape;",
                        "",
                        "export class CustomElementFactory extends ElementFactory<Connection, Label, Root, CustomShape> {};",
                        "",
                        "const customElementFactory = modeler.get<CustomElementFactory>('elementFactory');",
                        "",
                        "const customShape = customElementFactory.createShape({ foo: 'bar' });",
                        "",
                        "console.log(customShape.foo);"
                    ]
                },
                "Modeling.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import BaseModeling from 'diagram-js/lib/features/modeling/Modeling';",
                        "",
                        "import UpdateModdlePropertiesHandler from './cmd/UpdateModdlePropertiesHandler';",
                        "import UpdatePropertiesHandler from './cmd/UpdatePropertiesHandler';",
                        "import UpdateCanvasRootHandler from './cmd/UpdateCanvasRootHandler';",
                        "import AddLaneHandler from './cmd/AddLaneHandler';",
                        "import SplitLaneHandler from './cmd/SplitLaneHandler';",
                        "import ResizeLaneHandler from './cmd/ResizeLaneHandler';",
                        "import UpdateFlowNodeRefsHandler from './cmd/UpdateFlowNodeRefsHandler';",
                        "import IdClaimHandler from './cmd/IdClaimHandler';",
                        "import SetColorHandler from './cmd/SetColorHandler';",
                        "",
                        "import UpdateLabelHandler from '../label-editing/cmd/UpdateLabelHandler';",
                        "",
                        "/**",
                        " * @typedef {import('../rules/BpmnRules').default} BpmnRules",
                        " * @typedef {import('diagram-js/lib/command/CommandStack').default} CommandStack",
                        " * @typedef {import('./ElementFactory').default} ElementFactory",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " *",
                        " * @typedef {import('diagram-js/lib/features/modeling/Modeling').ModelingHints} ModelingHints",
                        " *",
                        " * @typedef {import('../../model/Types').Connection} Connection",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Label} Label",
                        " * @typedef {import('../../model/Types').Parent} Parent",
                        " * @typedef {import('../../model/Types').Root} Root",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " * @typedef {import('../../model/Types').ModdleElement} ModdleElement",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                        " *",
                        " * @typedef {import('../../util/Types').Colors} Colors",
                        " *",
                        " * @typedef { {",
                        " *   removeShape?: boolean;",
                        " * } } UpdateLabelHints",
                        " */",
                        "",
                        "/**",
                        " * The BPMN 2.0 modeling entry point.",
                        " *",
                        " * @template {Connection} [T=Connection]",
                        " * @template {Element} [U=Element]",
                        " * @template {Label} [V=Label]",
                        " * @template {Parent} [W=Parent]",
                        " * @template {Shape} [X=Shape]",
                        " *",
                        " * @extends {BaseModeling<T, U, V, W, X>}",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {ElementFactory} elementFactory",
                        " * @param {CommandStack} commandStack",
                        " * @param {BpmnRules} bpmnRules",
                        " */",
                        "export default function Modeling(",
                        "    eventBus,",
                        "    elementFactory,",
                        "    commandStack,",
                        "    bpmnRules",
                        ") {",
                        "",
                        "  BaseModeling.call(this, eventBus, elementFactory, commandStack);",
                        "",
                        "  this._bpmnRules = bpmnRules;",
                        "}",
                        "",
                        "inherits(Modeling, BaseModeling);",
                        "",
                        "Modeling.$inject = [",
                        "  'eventBus',",
                        "  'elementFactory',",
                        "  'commandStack',",
                        "  'bpmnRules'",
                        "];",
                        "",
                        "",
                        "Modeling.prototype.getHandlers = function() {",
                        "  var handlers = BaseModeling.prototype.getHandlers.call(this);",
                        "",
                        "  handlers['element.updateModdleProperties'] = UpdateModdlePropertiesHandler;",
                        "  handlers['element.updateProperties'] = UpdatePropertiesHandler;",
                        "  handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;",
                        "  handlers['lane.add'] = AddLaneHandler;",
                        "  handlers['lane.resize'] = ResizeLaneHandler;",
                        "  handlers['lane.split'] = SplitLaneHandler;",
                        "  handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;",
                        "  handlers['id.updateClaim'] = IdClaimHandler;",
                        "  handlers['element.setColor'] = SetColorHandler;",
                        "  handlers['element.updateLabel'] = UpdateLabelHandler;",
                        "",
                        "  return handlers;",
                        "};",
                        "",
                        "/**",
                        " * Update an element's label.",
                        " *",
                        " * @param {Element} element The element.",
                        " * @param {string} newLabel The new label.",
                        " * @param {Rect} [newBounds] The optional bounds of the label.",
                        " * @param {UpdateLabelHints} [hints] The optional hints.",
                        " */",
                        "Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {",
                        "  this._commandStack.execute('element.updateLabel', {",
                        "    element: element,",
                        "    newLabel: newLabel,",
                        "    newBounds: newBounds,",
                        "    hints: hints || {}",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * @param {Element} source",
                        " * @param {Element} target",
                        " * @param {Partial<Connection>} attrs",
                        " * @param {ModelingHints} [hints]",
                        " *",
                        " * @return {T}",
                        " */",
                        "Modeling.prototype.connect = function(source, target, attrs, hints) {",
                        "",
                        "  var bpmnRules = this._bpmnRules;",
                        "",
                        "  if (!attrs) {",
                        "    attrs = bpmnRules.canConnect(source, target);",
                        "  }",
                        "",
                        "  if (!attrs) {",
                        "    return;",
                        "  }",
                        "",
                        "  return this.createConnection(source, target, attrs, source.parent, hints);",
                        "};",
                        "",
                        "/**",
                        " * Update a model element's properties.",
                        " *",
                        " * @param {Element} element The element.",
                        " * @param {ModdleElement} moddleElement The model element.",
                        " * @param {Object} properties The updated properties.",
                        " */",
                        "Modeling.prototype.updateModdleProperties = function(element, moddleElement, properties) {",
                        "  this._commandStack.execute('element.updateModdleProperties', {",
                        "    element: element,",
                        "    moddleElement: moddleElement,",
                        "    properties: properties",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * Update an element's properties.",
                        " *",
                        " * @param {Element} element The element.",
                        " * @param {Object} properties The updated properties.",
                        " */",
                        "Modeling.prototype.updateProperties = function(element, properties) {",
                        "  this._commandStack.execute('element.updateProperties', {",
                        "    element: element,",
                        "    properties: properties",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * Resize a lane.",
                        " *",
                        " * @param {Shape} laneShape The lane.",
                        " * @param {Rect} newBounds The new bounds of the lane.",
                        " * @param {boolean} [balanced] Wether to resize neighboring lanes.",
                        " */",
                        "Modeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {",
                        "  this._commandStack.execute('lane.resize', {",
                        "    shape: laneShape,",
                        "    newBounds: newBounds,",
                        "    balanced: balanced",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * Add a lane.",
                        " *",
                        " * @param {Shape} targetLaneShape The shape to add the lane to.",
                        " * @param {string} location The location.",
                        " *",
                        " * @return {Shape} The added lane.",
                        " */",
                        "Modeling.prototype.addLane = function(targetLaneShape, location) {",
                        "  var context = {",
                        "    shape: targetLaneShape,",
                        "    location: location",
                        "  };",
                        "",
                        "  this._commandStack.execute('lane.add', context);",
                        "",
                        "  return context.newLane;",
                        "};",
                        "",
                        "/**",
                        " * Split a lane.",
                        " *",
                        " * @param {Shape} targetLane The lane to split.",
                        " * @param {number} count The number of lanes to split the lane into. Must not",
                        " * exceed the number of existing lanes.",
                        " */",
                        "Modeling.prototype.splitLane = function(targetLane, count) {",
                        "  this._commandStack.execute('lane.split', {",
                        "    shape: targetLane,",
                        "    count: count",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * Turn a process into a collaboration.",
                        " *",
                        " * @return {Root} The root of the collaboration.",
                        " */",
                        "Modeling.prototype.makeCollaboration = function() {",
                        "",
                        "  var collaborationElement = this._create('root', {",
                        "    type: 'bpmn:Collaboration'",
                        "  });",
                        "",
                        "  var context = {",
                        "    newRoot: collaborationElement",
                        "  };",
                        "",
                        "  this._commandStack.execute('canvas.updateRoot', context);",
                        "",
                        "  return collaborationElement;",
                        "};",
                        "",
                        "/**",
                        " * Transform a collaboration into a process.",
                        " *",
                        " * @return {Root} The root of the process.",
                        " */",
                        "Modeling.prototype.makeProcess = function() {",
                        "",
                        "  var processElement = this._create('root', {",
                        "    type: 'bpmn:Process'",
                        "  });",
                        "",
                        "  var context = {",
                        "    newRoot: processElement",
                        "  };",
                        "",
                        "  this._commandStack.execute('canvas.updateRoot', context);",
                        "};",
                        "",
                        "/**",
                        " * Update the referenced lanes of each flow node.",
                        " *",
                        " * @param {Shape[]} flowNodeShapes The flow nodes to update.",
                        " * @param {Shape[]} laneShapes The lanes.",
                        " */",
                        "Modeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {",
                        "",
                        "  this._commandStack.execute('lane.updateRefs', {",
                        "    flowNodeShapes: flowNodeShapes,",
                        "    laneShapes: laneShapes",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * Claim an ID.",
                        " *",
                        " * @param {string} id The ID to claim.",
                        " * @param {ModdleElement} moddleElement The model element the ID is claimed for.",
                        " */",
                        "Modeling.prototype.claimId = function(id, moddleElement) {",
                        "  this._commandStack.execute('id.updateClaim', {",
                        "    id: id,",
                        "    element: moddleElement,",
                        "    claiming: true",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * Unclaim an ID.",
                        " *",
                        " * @param {string} id The ID to unclaim.",
                        " * @param {ModdleElement} moddleElement The model element the ID is claimed for.",
                        " */",
                        "Modeling.prototype.unclaimId = function(id, moddleElement) {",
                        "  this._commandStack.execute('id.updateClaim', {",
                        "    id: id,",
                        "    element: moddleElement",
                        "  });",
                        "};",
                        "",
                        "/**",
                        " * Set the color(s) of one or many elements.",
                        " *",
                        " * @param {Element[]} elements The elements to set the color(s) for.",
                        " * @param {Colors} colors The color(s) to set.",
                        " */",
                        "Modeling.prototype.setColor = function(elements, colors) {",
                        "  if (!elements.length) {",
                        "    elements = [ elements ];",
                        "  }",
                        "",
                        "  this._commandStack.execute('element.setColor', {",
                        "    elements: elements,",
                        "    colors: colors",
                        "  });",
                        "};"
                    ]
                },
                "Modeling.test.ts": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { expectType } from 'ts-expect';",
                        "",
                        "import Modeler from '../../Modeler';",
                        "",
                        "import {",
                        "  Connection,",
                        "  Element,",
                        "  Label,",
                        "  Parent,",
                        "  Shape",
                        "} from '../../model/Types';",
                        "",
                        "import ElementFactory from './ElementFactory';",
                        "import Modeling from './Modeling';",
                        "",
                        "import { getBusinessObject } from '../../util/ModelUtil';",
                        "",
                        "import { CustomElementFactory } from './ElementFactory.test';",
                        "",
                        "const modeler = new Modeler();",
                        "",
                        "const elementFactory = modeler.get<ElementFactory>('elementFactory');",
                        "",
                        "const sequenceFlow = elementFactory.create('connection', { type: 'bpmn:SequenceFlow' }),",
                        "      process = elementFactory.create('root', { type: 'bpmn:Process' }),",
                        "      subProcess = elementFactory.create('shape', { type: 'bpmn:SubProcess' }),",
                        "      task = elementFactory.create('shape', { type: 'bpmn:Task' });",
                        "",
                        "const modeling = modeler.get<Modeling>('modeling');",
                        "",
                        "modeling.updateLabel(task, 'foo');",
                        "",
                        "modeling.updateLabel(task, 'foo', {",
                        "  x: 100,",
                        "  y: 100,",
                        "  width: 100,",
                        "  height: 100",
                        "});",
                        "",
                        "modeling.updateLabel(task, 'foo', {",
                        "  x: 100,",
                        "  y: 100,",
                        "  width: 100,",
                        "  height: 100",
                        "}, { removeShape: true });",
                        "",
                        "modeling.connect(subProcess, task, sequenceFlow);",
                        "",
                        "modeling.connect(subProcess, task, sequenceFlow, { foo: 'bar' });",
                        "",
                        "modeling.updateModdleProperties(task, { type: 'bpmn:ExtensionElements' }, {",
                        "  values: []",
                        "});",
                        "",
                        "modeling.updateProperties(task, {",
                        "  name: 'foo'",
                        "});",
                        "",
                        "const participant = elementFactory.create('shape', { type: 'bpmn:Participant'}),",
                        "      lane = elementFactory.create('shape', { type: 'bpmn:Lane'});",
                        "",
                        "modeling.resizeLane(lane, {",
                        "  x: 100,",
                        "  y: 100,",
                        "  width: 100,",
                        "  height: 100",
                        "});",
                        "",
                        "modeling.resizeLane(lane, {",
                        "  x: 100,",
                        "  y: 100,",
                        "  width: 100,",
                        "  height: 100",
                        "}, true);",
                        "",
                        "modeling.addLane(participant, 'top');",
                        "",
                        "modeling.addLane(participant, 'bottom');",
                        "",
                        "modeling.splitLane(lane, 3);",
                        "",
                        "modeling.makeCollaboration();",
                        "",
                        "modeling.makeProcess();",
                        "",
                        "modeling.updateLaneRefs([ task ], [ lane ]);",
                        "",
                        "modeling.claimId('foo', task.businessObject);",
                        "",
                        "modeling.unclaimId('foo', task.businessObject);",
                        "",
                        "modeling.setColor([ task ], { fill: 'red', stroke: 'green' });",
                        "",
                        "modeling.setColor([ task ], { fill: 'red' });",
                        "",
                        "modeling.setColor([ task ], { stroke: 'green' });",
                        "",
                        "/**",
                        " * Integration",
                        " */",
                        "",
                        "expectType<Connection>(modeling.createConnection(subProcess, task, sequenceFlow, process));",
                        "",
                        "expectType<Label>(modeling.createLabel(task, { x: 100, y: 100 }, {",
                        "  businessObject: getBusinessObject(task)",
                        "}));",
                        "",
                        "expectType<Shape>(modeling.createShape(task, { x: 100, y: 100 }, process));",
                        "",
                        "expectType<Element[]>(modeling.createElements([",
                        "  subProcess,",
                        "  task,",
                        "  sequenceFlow",
                        "], { x: 100, y: 100 }, process));",
                        "",
                        "modeling.moveShape(task, { x: 100, y: 100 });",
                        "",
                        "modeling.moveConnection(sequenceFlow, { x: 100, y: 100 });",
                        "",
                        "modeling.moveElements([ subProcess, task ], { x: 100, y: 100 });",
                        "",
                        "/**",
                        " * Customization",
                        " */",
                        "",
                        "type CustomElement = {",
                        "  foo: string;",
                        "} & Element;",
                        "",
                        "type CustomShape = {",
                        "  bar: string;",
                        "} & Shape & CustomElement;",
                        "",
                        "class CustomModeling extends Modeling<Connection, CustomElement, Label, Parent, CustomShape> {};",
                        "",
                        "const customModeling = modeler.get<CustomModeling>('modeling');",
                        "",
                        "const customShape = customModeling.createShape({ bar: 'bar' }, { x: 100, y: 100 }, modeler.get<CustomElementFactory>('elementFactory').create('root'));",
                        "",
                        "customModeling.distributeElements([",
                        "  {",
                        "    elements: [ customShape ],",
                        "    range: {",
                        "      min: 100,",
                        "      max: 200",
                        "    }",
                        "  }",
                        "], 'x', 'width');"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import BehaviorModule from './behavior';",
                        "import RulesModule from '../rules';",
                        "import DiOrderingModule from '../di-ordering';",
                        "import OrderingModule from '../ordering';",
                        "import ReplaceModule from '../replace';",
                        "import SpaceToolModule from '../space-tool';",
                        "",
                        "import CommandModule from 'diagram-js/lib/command';",
                        "import LabelSupportModule from 'diagram-js/lib/features/label-support';",
                        "import AttachSupportModule from 'diagram-js/lib/features/attach-support';",
                        "import SelectionModule from 'diagram-js/lib/features/selection';",
                        "import ChangeSupportModule from 'diagram-js/lib/features/change-support';",
                        "",
                        "import BpmnFactory from './BpmnFactory';",
                        "import BpmnUpdater from './BpmnUpdater';",
                        "import ElementFactory from './ElementFactory';",
                        "import Modeling from './Modeling';",
                        "import BpmnLayouter from './BpmnLayouter';",
                        "import CroppingConnectionDocking from 'diagram-js/lib/layout/CroppingConnectionDocking';",
                        "",
                        "",
                        "export default {",
                        "  __init__: [",
                        "    'modeling',",
                        "    'bpmnUpdater'",
                        "  ],",
                        "  __depends__: [",
                        "    BehaviorModule,",
                        "    RulesModule,",
                        "    DiOrderingModule,",
                        "    OrderingModule,",
                        "    ReplaceModule,",
                        "    CommandModule,",
                        "    LabelSupportModule,",
                        "    AttachSupportModule,",
                        "    SelectionModule,",
                        "    ChangeSupportModule,",
                        "    SpaceToolModule",
                        "  ],",
                        "  bpmnFactory: [ 'type', BpmnFactory ],",
                        "  bpmnUpdater: [ 'type', BpmnUpdater ],",
                        "  elementFactory: [ 'type', ElementFactory ],",
                        "  modeling: [ 'type', Modeling ],",
                        "  layouter: [ 'type', BpmnLayouter ],",
                        "  connectionDocking: [ 'type', CroppingConnectionDocking ]",
                        "};"
                    ]
                },
                "behavior": {
                    "AdaptiveLabelPositioningBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import {",
                            "  getOrientation,",
                            "  getMid,",
                            "  asTRBL",
                            "} from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import {",
                            "  substract",
                            "} from 'diagram-js/lib/util/Math';",
                            "",
                            "import {",
                            "  hasExternalLabel",
                            "} from '../../../util/LabelUtil';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " *",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL",
                            " */",
                            "",
                            "var ALIGNMENTS = [",
                            "  'top',",
                            "  'bottom',",
                            "  'left',",
                            "  'right'",
                            "];",
                            "",
                            "var ELEMENT_LABEL_DISTANCE = 10;",
                            "",
                            "/**",
                            " * A component that makes sure that external labels are added",
                            " * together with respective elements and properly updated (DI wise)",
                            " * during move.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function AdaptiveLabelPositioningBehavior(eventBus, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  this.postExecuted([",
                            "    'connection.create',",
                            "    'connection.layout',",
                            "    'connection.updateWaypoints'",
                            "  ], function(event) {",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        source = connection.source,",
                            "        target = connection.target,",
                            "        hints = context.hints || {};",
                            "",
                            "    if (hints.createElementsBehavior !== false) {",
                            "      checkLabelAdjustment(source);",
                            "      checkLabelAdjustment(target);",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  this.postExecuted([",
                            "    'label.create'",
                            "  ], function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        hints = context.hints || {};",
                            "",
                            "    if (hints.createElementsBehavior !== false) {",
                            "      checkLabelAdjustment(shape.labelTarget);",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  this.postExecuted([",
                            "    'elements.create'",
                            "  ], function(event) {",
                            "    var context = event.context,",
                            "        elements = context.elements,",
                            "        hints = context.hints || {};",
                            "",
                            "    if (hints.createElementsBehavior !== false) {",
                            "      elements.forEach(function(element) {",
                            "        checkLabelAdjustment(element);",
                            "      });",
                            "    }",
                            "  });",
                            "",
                            "  function checkLabelAdjustment(element) {",
                            "",
                            "    // skip non-existing labels",
                            "    if (!hasExternalLabel(element)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var optimalPosition = getOptimalPosition(element);",
                            "",
                            "    // no optimal position found",
                            "    if (!optimalPosition) {",
                            "      return;",
                            "    }",
                            "",
                            "    adjustLabelPosition(element, optimalPosition);",
                            "  }",
                            "",
                            "  function adjustLabelPosition(element, orientation) {",
                            "",
                            "    var elementMid = getMid(element),",
                            "        label = element.label,",
                            "        labelMid = getMid(label);",
                            "",
                            "    // ignore labels that are being created",
                            "    if (!label.parent) {",
                            "      return;",
                            "    }",
                            "",
                            "    var elementTrbl = asTRBL(element);",
                            "",
                            "    var newLabelMid;",
                            "",
                            "    switch (orientation) {",
                            "    case 'top':",
                            "      newLabelMid = {",
                            "        x: elementMid.x,",
                            "        y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2",
                            "      };",
                            "",
                            "      break;",
                            "",
                            "    case 'left':",
                            "",
                            "      newLabelMid = {",
                            "        x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,",
                            "        y: elementMid.y",
                            "      };",
                            "",
                            "      break;",
                            "",
                            "    case 'bottom':",
                            "",
                            "      newLabelMid = {",
                            "        x: elementMid.x,",
                            "        y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2",
                            "      };",
                            "",
                            "      break;",
                            "",
                            "    case 'right':",
                            "",
                            "      newLabelMid = {",
                            "        x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,",
                            "        y: elementMid.y",
                            "      };",
                            "",
                            "      break;",
                            "    }",
                            "",
                            "    var delta = substract(newLabelMid, labelMid);",
                            "",
                            "    modeling.moveShape(label, delta);",
                            "  }",
                            "",
                            "}",
                            "",
                            "inherits(AdaptiveLabelPositioningBehavior, CommandInterceptor);",
                            "",
                            "AdaptiveLabelPositioningBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling'",
                            "];",
                            "",
                            "",
                            "// helpers //////////////////////",
                            "",
                            "/**",
                            " * Return alignments which are taken by a boundary's host element",
                            " *",
                            " * @param {Shape} element",
                            " *",
                            " * @return {DirectionTRBL[]}",
                            " */",
                            "function getTakenHostAlignments(element) {",
                            "",
                            "  var hostElement = element.host,",
                            "      elementMid = getMid(element),",
                            "      hostOrientation = getOrientation(elementMid, hostElement);",
                            "",
                            "  var freeAlignments;",
                            "",
                            "  // check whether there is a multi-orientation, e.g. 'top-left'",
                            "  if (hostOrientation.indexOf('-') >= 0) {",
                            "    freeAlignments = hostOrientation.split('-');",
                            "  } else {",
                            "    freeAlignments = [ hostOrientation ];",
                            "  }",
                            "",
                            "  var takenAlignments = ALIGNMENTS.filter(function(alignment) {",
                            "",
                            "    return freeAlignments.indexOf(alignment) === -1;",
                            "  });",
                            "",
                            "  return takenAlignments;",
                            "",
                            "}",
                            "",
                            "/**",
                            " * Return alignments which are taken by related connections",
                            " *",
                            " * @param {Element} element",
                            " *",
                            " * @return {DirectionTRBL[]}",
                            " */",
                            "function getTakenConnectionAlignments(element) {",
                            "",
                            "  var elementMid = getMid(element);",
                            "",
                            "  var takenAlignments = [].concat(",
                            "    element.incoming.map(function(c) {",
                            "      return c.waypoints[c.waypoints.length - 2 ];",
                            "    }),",
                            "    element.outgoing.map(function(c) {",
                            "      return c.waypoints[1];",
                            "    })",
                            "  ).map(function(point) {",
                            "    return getApproximateOrientation(elementMid, point);",
                            "  });",
                            "",
                            "  return takenAlignments;",
                            "}",
                            "",
                            "/**",
                            " * Return the optimal label position around an element",
                            " * or `undefined`, if none was found.",
                            " *",
                            " * @param  {Element} element",
                            " *",
                            " * @return {DirectionTRBL|undefined}",
                            " */",
                            "function getOptimalPosition(element) {",
                            "",
                            "  var labelMid = getMid(element.label);",
                            "",
                            "  var elementMid = getMid(element);",
                            "",
                            "  var labelOrientation = getApproximateOrientation(elementMid, labelMid);",
                            "",
                            "  if (!isAligned(labelOrientation)) {",
                            "    return;",
                            "  }",
                            "",
                            "  var takenAlignments = getTakenConnectionAlignments(element);",
                            "",
                            "  if (element.host) {",
                            "    var takenHostAlignments = getTakenHostAlignments(element);",
                            "",
                            "    takenAlignments = takenAlignments.concat(takenHostAlignments);",
                            "  }",
                            "",
                            "  var freeAlignments = ALIGNMENTS.filter(function(alignment) {",
                            "",
                            "    return takenAlignments.indexOf(alignment) === -1;",
                            "  });",
                            "",
                            "  // NOTHING TO DO; label already aligned a.O.K.",
                            "  if (freeAlignments.indexOf(labelOrientation) !== -1) {",
                            "    return;",
                            "  }",
                            "",
                            "  return freeAlignments[0];",
                            "}",
                            "",
                            "function getApproximateOrientation(p0, p1) {",
                            "  return getOrientation(p1, p0, 5);",
                            "}",
                            "",
                            "function isAligned(orientation) {",
                            "  return ALIGNMENTS.indexOf(orientation) !== -1;",
                            "}"
                        ]
                    },
                    "AppendBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " */",
                            "",
                            "export default function AppendBehavior(eventBus) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  // assign correct shape position unless already set",
                            "",
                            "  this.preExecute('shape.append', function(context) {",
                            "",
                            "    var source = context.source,",
                            "        shape = context.shape;",
                            "",
                            "    if (!context.position) {",
                            "",
                            "      if (is(shape, 'bpmn:TextAnnotation')) {",
                            "        context.position = {",
                            "          x: source.x + source.width / 2 + 75,",
                            "          y: source.y - 50 - shape.height / 2",
                            "        };",
                            "      } else {",
                            "        context.position = {",
                            "          x: source.x + source.width + 80 + shape.width / 2,",
                            "          y: source.y + source.height / 2",
                            "        };",
                            "      }",
                            "    }",
                            "  }, true);",
                            "}",
                            "",
                            "inherits(AppendBehavior, CommandInterceptor);",
                            "",
                            "AppendBehavior.$inject = [",
                            "  'eventBus'",
                            "];"
                        ]
                    },
                    "AssociationBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  filter,",
                            "  forEach",
                            "} from 'min-dash';",
                            "",
                            "/**",
                            " * @typedef {import('didi').Injector} Injector",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * @param {Injector} injector",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function AssociationBehavior(injector, modeling) {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  this.postExecute('shape.move', function(context) {",
                            "    var newParent = context.newParent,",
                            "        shape = context.shape;",
                            "",
                            "    var associations = filter(shape.incoming.concat(shape.outgoing), function(connection) {",
                            "      return is(connection, 'bpmn:Association');",
                            "    });",
                            "",
                            "    forEach(associations, function(association) {",
                            "      modeling.moveConnection(association, { x: 0, y: 0 }, newParent);",
                            "    });",
                            "  }, true);",
                            "}",
                            "",
                            "inherits(AssociationBehavior, CommandInterceptor);",
                            "",
                            "AssociationBehavior.$inject = [",
                            "  'injector',",
                            "  'modeling'",
                            "];"
                        ]
                    },
                    "AttachEventBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { getBusinessObject } from '../../../util/ModelUtil';",
                            "",
                            "import { isAny } from '../util/ModelingUtil';",
                            "",
                            "import { isLabel } from '../../../util/LabelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('../../replace/BpmnReplace').default} BpmnReplace",
                            " * @typedef {import('didi').Injector} Injector",
                            " */",
                            "",
                            "var LOW_PRIORITY = 500;",
                            "",
                            "",
                            "/**",
                            " * Replace intermediate event with boundary event when creating or moving results in attached event.",
                            " *",
                            " * @param {BpmnReplace} bpmnReplace",
                            " * @param {Injector} injector",
                            " */",
                            "export default function AttachEventBehavior(bpmnReplace, injector) {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  this._bpmnReplace = bpmnReplace;",
                            "",
                            "  var self = this;",
                            "",
                            "  this.postExecuted('elements.create', LOW_PRIORITY, function(context) {",
                            "    var elements = context.elements;",
                            "",
                            "    elements = elements.filter(function(shape) {",
                            "      var host = shape.host;",
                            "",
                            "      return shouldReplace(shape, host);",
                            "    });",
                            "",
                            "    if (elements.length !== 1) {",
                            "      return;",
                            "    }",
                            "",
                            "    elements.map(function(element) {",
                            "      return elements.indexOf(element);",
                            "    }).forEach(function(index) {",
                            "      var host = elements[ index ];",
                            "",
                            "      context.elements[ index ] = self._replaceShape(elements[ index ], host);",
                            "    });",
                            "  }, true);",
                            "",
                            "",
                            "  this.preExecute('elements.move', LOW_PRIORITY, function(context) {",
                            "    var shapes = context.shapes,",
                            "        host = context.newHost;",
                            "",
                            "    if (shapes.length !== 1) {",
                            "      return;",
                            "    }",
                            "",
                            "    var shape = shapes[0];",
                            "",
                            "    if (shouldReplace(shape, host)) {",
                            "      context.shapes = [ self._replaceShape(shape, host) ];",
                            "    }",
                            "  }, true);",
                            "}",
                            "",
                            "AttachEventBehavior.$inject = [",
                            "  'bpmnReplace',",
                            "  'injector'",
                            "];",
                            "",
                            "inherits(AttachEventBehavior, CommandInterceptor);",
                            "",
                            "AttachEventBehavior.prototype._replaceShape = function(shape, host) {",
                            "  var eventDefinition = getEventDefinition(shape);",
                            "",
                            "  var boundaryEvent = {",
                            "    type: 'bpmn:BoundaryEvent',",
                            "    host: host",
                            "  };",
                            "",
                            "  if (eventDefinition) {",
                            "    boundaryEvent.eventDefinitionType = eventDefinition.$type;",
                            "  }",
                            "",
                            "  return this._bpmnReplace.replaceElement(shape, boundaryEvent, { layoutConnection: false });",
                            "};",
                            "",
                            "",
                            "// helpers //////////",
                            "",
                            "function getEventDefinition(element) {",
                            "  var businessObject = getBusinessObject(element),",
                            "      eventDefinitions = businessObject.eventDefinitions;",
                            "",
                            "  return eventDefinitions && eventDefinitions[0];",
                            "}",
                            "",
                            "function shouldReplace(shape, host) {",
                            "  return !isLabel(shape) &&",
                            "    isAny(shape, [ 'bpmn:IntermediateThrowEvent', 'bpmn:IntermediateCatchEvent' ]) && !!host;",
                            "}"
                        ]
                    },
                    "BoundaryEventBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  filter,",
                            "  forEach",
                            "} from 'min-dash';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * BPMN specific boundary event behavior.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function BoundaryEventBehavior(eventBus, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  function getBoundaryEvents(element) {",
                            "    return filter(element.attachers, function(attacher) {",
                            "      return is(attacher, 'bpmn:BoundaryEvent');",
                            "    });",
                            "  }",
                            "",
                            "  // remove after connecting to event-based gateway",
                            "  this.postExecute('connection.create', function(event) {",
                            "    var source = event.context.source,",
                            "        target = event.context.target,",
                            "        boundaryEvents = getBoundaryEvents(target);",
                            "",
                            "    if (",
                            "      is(source, 'bpmn:EventBasedGateway') &&",
                            "      is(target, 'bpmn:ReceiveTask') &&",
                            "      boundaryEvents.length > 0",
                            "    ) {",
                            "      modeling.removeElements(boundaryEvents);",
                            "    }",
                            "",
                            "  });",
                            "",
                            "  // remove after replacing connected gateway with event-based gateway",
                            "  this.postExecute('connection.reconnect', function(event) {",
                            "    var oldSource = event.context.oldSource,",
                            "        newSource = event.context.newSource;",
                            "",
                            "    if (is(oldSource, 'bpmn:Gateway') &&",
                            "        is(newSource, 'bpmn:EventBasedGateway')) {",
                            "      forEach(newSource.outgoing, function(connection) {",
                            "        var target = connection.target,",
                            "            attachedboundaryEvents = getBoundaryEvents(target);",
                            "",
                            "        if (is(target, 'bpmn:ReceiveTask') &&",
                            "            attachedboundaryEvents.length > 0) {",
                            "          modeling.removeElements(attachedboundaryEvents);",
                            "        }",
                            "      });",
                            "    }",
                            "  });",
                            "",
                            "}",
                            "",
                            "BoundaryEventBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling'",
                            "];",
                            "",
                            "inherits(BoundaryEventBehavior, CommandInterceptor);"
                        ]
                    },
                    "CreateBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { getParent } from '../util/ModelingUtil';",
                            "",
                            "/**",
                            " * @typedef {import('didi').Injector} Injector",
                            " */",
                            "",
                            "/**",
                            " * @param {Injector} injector",
                            " */",
                            "export default function CreateBehavior(injector) {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  this.preExecute('shape.create', 1500, function(event) {",
                            "    var context = event.context,",
                            "        parent = context.parent,",
                            "        shape = context.shape;",
                            "",
                            "    if (is(parent, 'bpmn:Lane') && !is(shape, 'bpmn:Lane')) {",
                            "      context.parent = getParent(parent, 'bpmn:Participant');",
                            "    }",
                            "  });",
                            "",
                            "}",
                            "",
                            "",
                            "CreateBehavior.$inject = [ 'injector' ];",
                            "",
                            "inherits(CreateBehavior, CommandInterceptor);"
                        ]
                    },
                    "CreateDataObjectBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../BpmnFactory').default} BpmnFactory",
                            " */",
                            "",
                            "/**",
                            " * BPMN specific create data object behavior.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {BpmnFactory} bpmnFactory",
                            " */",
                            "export default function CreateDataObjectBehavior(eventBus, bpmnFactory) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  this.preExecute('shape.create', function(event) {",
                            "",
                            "    var context = event.context,",
                            "        shape = context.shape;",
                            "",
                            "    if (is(shape, 'bpmn:DataObjectReference') && shape.type !== 'label') {",
                            "",
                            "      // create a DataObject every time a DataObjectReference is created",
                            "      var dataObject = bpmnFactory.create('bpmn:DataObject');",
                            "",
                            "      // set the reference to the DataObject",
                            "      shape.businessObject.dataObjectRef = dataObject;",
                            "    }",
                            "  });",
                            "",
                            "}",
                            "",
                            "CreateDataObjectBehavior.$inject = [",
                            "  'eventBus',",
                            "  'bpmnFactory'",
                            "];",
                            "",
                            "inherits(CreateDataObjectBehavior, CommandInterceptor);"
                        ]
                    },
                    "CreateParticipantBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { getBusinessObject, is } from '../../../util/ModelUtil';",
                            "",
                            "import { isLabel } from '../../../util/LabelUtil';",
                            "",
                            "import { getBBox } from 'diagram-js/lib/util/Elements';",
                            "",
                            "import {",
                            "  assign,",
                            "  find",
                            "} from 'min-dash';",
                            "",
                            "import { asTRBL } from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import { isConnection } from 'diagram-js/lib/util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "var HORIZONTAL_PARTICIPANT_PADDING = 20,",
                            "    VERTICAL_PARTICIPANT_PADDING = 20;",
                            "",
                            "export var PARTICIPANT_BORDER_WIDTH = 30;",
                            "",
                            "var HIGH_PRIORITY = 2000;",
                            "",
                            "",
                            "/**",
                            " * BPMN-specific behavior for creating participants.",
                            " *",
                            " * @param {Canvas} canvas",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function CreateParticipantBehavior(canvas, eventBus, modeling) {",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  // fit participant",
                            "  eventBus.on([",
                            "    'create.start',",
                            "    'shape.move.start'",
                            "  ], HIGH_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        rootElement = canvas.getRootElement();",
                            "",
                            "    if (!is(shape, 'bpmn:Participant') ||",
                            "      !is(rootElement, 'bpmn:Process') ||",
                            "      !rootElement.children.length) {",
                            "      return;",
                            "    }",
                            "",
                            "    // ignore connections, groups and labels",
                            "    var children = rootElement.children.filter(function(element) {",
                            "      return !is(element, 'bpmn:Group') &&",
                            "        !isLabel(element) &&",
                            "        !isConnection(element);",
                            "    });",
                            "",
                            "    // ensure for available children to calculate bounds",
                            "    if (!children.length) {",
                            "      return;",
                            "    }",
                            "",
                            "    var childrenBBox = getBBox(children);",
                            "",
                            "    var participantBounds = getParticipantBounds(shape, childrenBBox);",
                            "",
                            "    // assign width and height",
                            "    assign(shape, participantBounds);",
                            "",
                            "    // assign create constraints",
                            "    context.createConstraints = getParticipantCreateConstraints(shape, childrenBBox);",
                            "  });",
                            "",
                            "  // force hovering process when creating first participant",
                            "  eventBus.on('create.start', HIGH_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        rootElement = canvas.getRootElement(),",
                            "        rootElementGfx = canvas.getGraphics(rootElement);",
                            "",
                            "    function ensureHoveringProcess(event) {",
                            "      event.element = rootElement;",
                            "      event.gfx = rootElementGfx;",
                            "    }",
                            "",
                            "    if (is(shape, 'bpmn:Participant') && is(rootElement, 'bpmn:Process')) {",
                            "      eventBus.on('element.hover', HIGH_PRIORITY, ensureHoveringProcess);",
                            "",
                            "      eventBus.once('create.cleanup', function() {",
                            "        eventBus.off('element.hover', ensureHoveringProcess);",
                            "      });",
                            "    }",
                            "  });",
                            "",
                            "  // turn process into collaboration when creating first participant",
                            "  function getOrCreateCollaboration() {",
                            "    var rootElement = canvas.getRootElement();",
                            "",
                            "    if (is(rootElement, 'bpmn:Collaboration')) {",
                            "      return rootElement;",
                            "    }",
                            "",
                            "    return modeling.makeCollaboration();",
                            "  }",
                            "",
                            "  // when creating mutliple elements through `elements.create` parent must be set to collaboration",
                            "  // and passed to `shape.create` as hint",
                            "  this.preExecute('elements.create', HIGH_PRIORITY, function(context) {",
                            "    var elements = context.elements,",
                            "        parent = context.parent,",
                            "        participant = findParticipant(elements),",
                            "        hints;",
                            "",
                            "    if (participant && is(parent, 'bpmn:Process')) {",
                            "      context.parent = getOrCreateCollaboration();",
                            "",
                            "      hints = context.hints = context.hints || {};",
                            "",
                            "      hints.participant = participant;",
                            "      hints.process = parent;",
                            "      hints.processRef = getBusinessObject(participant).get('processRef');",
                            "    }",
                            "  }, true);",
                            "",
                            "  // when creating single shape through `shape.create` parent must be set to collaboration",
                            "  // unless it was already set through `elements.create`",
                            "  this.preExecute('shape.create', function(context) {",
                            "    var parent = context.parent,",
                            "        shape = context.shape;",
                            "",
                            "    if (is(shape, 'bpmn:Participant') && is(parent, 'bpmn:Process')) {",
                            "      context.parent = getOrCreateCollaboration();",
                            "",
                            "      context.process = parent;",
                            "      context.processRef = getBusinessObject(shape).get('processRef');",
                            "    }",
                            "  }, true);",
                            "",
                            "  // #execute necessary because #preExecute not called on CommandStack#redo",
                            "  this.execute('shape.create', function(context) {",
                            "    var hints = context.hints || {},",
                            "        process = context.process || hints.process,",
                            "        shape = context.shape,",
                            "        participant = hints.participant;",
                            "",
                            "    // both shape.create and elements.create must be handled",
                            "    if (process && (!participant || shape === participant)) {",
                            "",
                            "      // monkey-patch process ref",
                            "      getBusinessObject(shape).set('processRef', getBusinessObject(process));",
                            "    }",
                            "  }, true);",
                            "",
                            "  this.revert('shape.create', function(context) {",
                            "    var hints = context.hints || {},",
                            "        process = context.process || hints.process,",
                            "        processRef = context.processRef || hints.processRef,",
                            "        shape = context.shape,",
                            "        participant = hints.participant;",
                            "",
                            "    // both shape.create and elements.create must be handled",
                            "    if (process && (!participant || shape === participant)) {",
                            "",
                            "      // monkey-patch process ref",
                            "      getBusinessObject(shape).set('processRef', processRef);",
                            "    }",
                            "  }, true);",
                            "",
                            "  this.postExecute('shape.create', function(context) {",
                            "    var hints = context.hints || {},",
                            "        process = context.process || context.hints.process,",
                            "        shape = context.shape,",
                            "        participant = hints.participant;",
                            "",
                            "    if (process) {",
                            "      var children = process.children.slice();",
                            "",
                            "      // both shape.create and elements.create must be handled",
                            "      if (!participant) {",
                            "        modeling.moveElements(children, { x: 0, y: 0 }, shape);",
                            "      } else if (shape === participant) {",
                            "        modeling.moveElements(children, { x: 0, y: 0 }, participant);",
                            "      }",
                            "    }",
                            "  }, true);",
                            "}",
                            "",
                            "CreateParticipantBehavior.$inject = [",
                            "  'canvas',",
                            "  'eventBus',",
                            "  'modeling'",
                            "];",
                            "",
                            "inherits(CreateParticipantBehavior, CommandInterceptor);",
                            "",
                            "// helpers //////////",
                            "",
                            "function getParticipantBounds(shape, childrenBBox) {",
                            "  childrenBBox = {",
                            "    width: childrenBBox.width + HORIZONTAL_PARTICIPANT_PADDING * 2 + PARTICIPANT_BORDER_WIDTH,",
                            "    height: childrenBBox.height + VERTICAL_PARTICIPANT_PADDING * 2",
                            "  };",
                            "",
                            "  var width = Math.max(shape.width, childrenBBox.width),",
                            "      height = Math.max(shape.height, childrenBBox.height);",
                            "",
                            "  return {",
                            "    x: -width / 2,",
                            "    y: -height / 2,",
                            "    width: width,",
                            "    height: height",
                            "  };",
                            "}",
                            "",
                            "function getParticipantCreateConstraints(shape, childrenBBox) {",
                            "  childrenBBox = asTRBL(childrenBBox);",
                            "",
                            "  return {",
                            "    bottom: childrenBBox.top + shape.height / 2 - VERTICAL_PARTICIPANT_PADDING,",
                            "    left: childrenBBox.right - shape.width / 2 + HORIZONTAL_PARTICIPANT_PADDING,",
                            "    top: childrenBBox.bottom - shape.height / 2 + VERTICAL_PARTICIPANT_PADDING,",
                            "    right: childrenBBox.left + shape.width / 2 - HORIZONTAL_PARTICIPANT_PADDING - PARTICIPANT_BORDER_WIDTH",
                            "  };",
                            "}",
                            "",
                            "function findParticipant(elements) {",
                            "  return find(elements, function(element) {",
                            "    return is(element, 'bpmn:Participant');",
                            "  });",
                            "}"
                        ]
                    },
                    "DataInputAssociationBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  add as collectionAdd,",
                            "  remove as collectionRemove",
                            "} from 'diagram-js/lib/util/Collections';",
                            "",
                            "import {",
                            "  find",
                            "} from 'min-dash';",
                            "",
                            "import {",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../BpmnFactory').default} BpmnFactory",
                            " */",
                            "",
                            "var TARGET_REF_PLACEHOLDER_NAME = '__targetRef_placeholder';",
                            "",
                            "",
                            "/**",
                            " * This behavior makes sure we always set a fake",
                            " * DataInputAssociation#targetRef as demanded by the BPMN 2.0",
                            " * XSD schema.",
                            " *",
                            " * The reference is set to a bpmn:Property{ name: '__targetRef_placeholder' }",
                            " * which is created on the fly and cleaned up afterwards if not needed",
                            " * anymore.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {BpmnFactory} bpmnFactory",
                            " */",
                            "export default function DataInputAssociationBehavior(eventBus, bpmnFactory) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "",
                            "  this.executed([",
                            "    'connection.create',",
                            "    'connection.delete',",
                            "    'connection.move',",
                            "    'connection.reconnect'",
                            "  ], ifDataInputAssociation(fixTargetRef));",
                            "",
                            "  this.reverted([",
                            "    'connection.create',",
                            "    'connection.delete',",
                            "    'connection.move',",
                            "    'connection.reconnect'",
                            "  ], ifDataInputAssociation(fixTargetRef));",
                            "",
                            "",
                            "  function usesTargetRef(element, targetRef, removedConnection) {",
                            "",
                            "    var inputAssociations = element.get('dataInputAssociations');",
                            "",
                            "    return find(inputAssociations, function(association) {",
                            "      return association !== removedConnection &&",
                            "             association.targetRef === targetRef;",
                            "    });",
                            "  }",
                            "",
                            "  function getTargetRef(element, create) {",
                            "",
                            "    var properties = element.get('properties');",
                            "",
                            "    var targetRefProp = find(properties, function(p) {",
                            "      return p.name === TARGET_REF_PLACEHOLDER_NAME;",
                            "    });",
                            "",
                            "    if (!targetRefProp && create) {",
                            "      targetRefProp = bpmnFactory.create('bpmn:Property', {",
                            "        name: TARGET_REF_PLACEHOLDER_NAME",
                            "      });",
                            "",
                            "      collectionAdd(properties, targetRefProp);",
                            "    }",
                            "",
                            "    return targetRefProp;",
                            "  }",
                            "",
                            "  function cleanupTargetRef(element, connection) {",
                            "",
                            "    var targetRefProp = getTargetRef(element);",
                            "",
                            "    if (!targetRefProp) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (!usesTargetRef(element, targetRefProp, connection)) {",
                            "      collectionRemove(element.get('properties'), targetRefProp);",
                            "    }",
                            "  }",
                            "",
                            "  /**",
                            "   * Make sure targetRef is set to a valid property or",
                            "   * `null` if the connection is detached.",
                            "   *",
                            "   * @param {Event} event",
                            "   */",
                            "  function fixTargetRef(event) {",
                            "",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        connectionBo = connection.businessObject,",
                            "        target = connection.target,",
                            "        targetBo = target && target.businessObject,",
                            "        newTarget = context.newTarget,",
                            "        newTargetBo = newTarget && newTarget.businessObject,",
                            "        oldTarget = context.oldTarget || context.target,",
                            "        oldTargetBo = oldTarget && oldTarget.businessObject;",
                            "",
                            "    var dataAssociation = connection.businessObject,",
                            "        targetRefProp;",
                            "",
                            "    if (oldTargetBo && oldTargetBo !== targetBo) {",
                            "      cleanupTargetRef(oldTargetBo, connectionBo);",
                            "    }",
                            "",
                            "    if (newTargetBo && newTargetBo !== targetBo) {",
                            "      cleanupTargetRef(newTargetBo, connectionBo);",
                            "    }",
                            "",
                            "    if (targetBo) {",
                            "      targetRefProp = getTargetRef(targetBo, true);",
                            "      dataAssociation.targetRef = targetRefProp;",
                            "    } else {",
                            "      dataAssociation.targetRef = null;",
                            "    }",
                            "  }",
                            "}",
                            "",
                            "DataInputAssociationBehavior.$inject = [",
                            "  'eventBus',",
                            "  'bpmnFactory'",
                            "];",
                            "",
                            "inherits(DataInputAssociationBehavior, CommandInterceptor);",
                            "",
                            "",
                            "/**",
                            " * Only call the given function when the event",
                            " * touches a bpmn:DataInputAssociation.",
                            " *",
                            " * @param {Function} fn",
                            " * @return {Function}",
                            " */",
                            "function ifDataInputAssociation(fn) {",
                            "",
                            "  return function(event) {",
                            "    var context = event.context,",
                            "        connection = context.connection;",
                            "",
                            "    if (is(connection, 'bpmn:DataInputAssociation')) {",
                            "      return fn(event);",
                            "    }",
                            "  };",
                            "}"
                        ]
                    },
                    "DataStoreBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  getBusinessObject,",
                            "  getDi,",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import { isAny } from '../util/ModelingUtil';",
                            "",
                            "import UpdateSemanticParentHandler from '../cmd/UpdateSemanticParentHandler';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                            " * @typedef {import('diagram-js/lib/command/CommandStack').default} CommandStack",
                            " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " */",
                            "",
                            "/**",
                            " * BPMN specific data store behavior.",
                            " *",
                            " * @param {Canvas} canvas",
                            " * @param {CommandStack} commandStack",
                            " * @param {ElementRegistry} elementRegistry",
                            " * @param {EventBus} eventBus",
                            " */",
                            "export default function DataStoreBehavior(",
                            "    canvas, commandStack, elementRegistry,",
                            "    eventBus) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  commandStack.registerHandler('dataStore.updateContainment', UpdateSemanticParentHandler);",
                            "",
                            "  function getFirstParticipantWithProcessRef() {",
                            "    return elementRegistry.filter(function(element) {",
                            "      return is(element, 'bpmn:Participant') && getBusinessObject(element).processRef;",
                            "    })[0];",
                            "  }",
                            "",
                            "  function getDataStores(element) {",
                            "    return element.children.filter(function(child) {",
                            "      return is(child, 'bpmn:DataStoreReference') && !child.labelTarget;",
                            "    });",
                            "  }",
                            "",
                            "  function updateDataStoreParent(dataStore, newDataStoreParent) {",
                            "    var dataStoreBo = dataStore.businessObject || dataStore;",
                            "",
                            "    newDataStoreParent = newDataStoreParent || getFirstParticipantWithProcessRef();",
                            "",
                            "    if (newDataStoreParent) {",
                            "      var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;",
                            "",
                            "      commandStack.execute('dataStore.updateContainment', {",
                            "        dataStoreBo: dataStoreBo,",
                            "        dataStoreDi: getDi(dataStore),",
                            "        newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,",
                            "        newDiParent: getDi(newDataStoreParent)",
                            "      });",
                            "    }",
                            "  }",
                            "",
                            "",
                            "  // disable auto-resize for data stores",
                            "  this.preExecute('shape.create', function(event) {",
                            "",
                            "    var context = event.context,",
                            "        shape = context.shape;",
                            "",
                            "    if (is(shape, 'bpmn:DataStoreReference') &&",
                            "        shape.type !== 'label') {",
                            "",
                            "      if (!context.hints) {",
                            "        context.hints = {};",
                            "      }",
                            "",
                            "      // prevent auto resizing",
                            "      context.hints.autoResize = false;",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  // disable auto-resize for data stores",
                            "  this.preExecute('elements.move', function(event) {",
                            "    var context = event.context,",
                            "        shapes = context.shapes;",
                            "",
                            "    var dataStoreReferences = shapes.filter(function(shape) {",
                            "      return is(shape, 'bpmn:DataStoreReference');",
                            "    });",
                            "",
                            "    if (dataStoreReferences.length) {",
                            "      if (!context.hints) {",
                            "        context.hints = {};",
                            "      }",
                            "",
                            "      // prevent auto resizing for data store references",
                            "      context.hints.autoResize = shapes.filter(function(shape) {",
                            "        return !is(shape, 'bpmn:DataStoreReference');",
                            "      });",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  // update parent on data store created",
                            "  this.postExecute('shape.create', function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        parent = shape.parent;",
                            "",
                            "",
                            "    if (is(shape, 'bpmn:DataStoreReference') &&",
                            "        shape.type !== 'label' &&",
                            "        is(parent, 'bpmn:Collaboration')) {",
                            "",
                            "      updateDataStoreParent(shape);",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  // update parent on data store moved",
                            "  this.postExecute('shape.move', function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        oldParent = context.oldParent,",
                            "        parent = shape.parent;",
                            "",
                            "    if (is(oldParent, 'bpmn:Collaboration')) {",
                            "",
                            "      // do nothing if not necessary",
                            "      return;",
                            "    }",
                            "",
                            "    if (is(shape, 'bpmn:DataStoreReference') &&",
                            "        shape.type !== 'label' &&",
                            "        is(parent, 'bpmn:Collaboration')) {",
                            "",
                            "      var participant = is(oldParent, 'bpmn:Participant') ?",
                            "        oldParent :",
                            "        getAncestor(oldParent, 'bpmn:Participant');",
                            "",
                            "      updateDataStoreParent(shape, participant);",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  // update data store parents on participant or subprocess deleted",
                            "  this.postExecute('shape.delete', function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        rootElement = canvas.getRootElement();",
                            "",
                            "    if (isAny(shape, [ 'bpmn:Participant', 'bpmn:SubProcess' ])",
                            "        && is(rootElement, 'bpmn:Collaboration')) {",
                            "      getDataStores(rootElement)",
                            "        .filter(function(dataStore) {",
                            "          return isDescendant(dataStore, shape);",
                            "        })",
                            "        .forEach(function(dataStore) {",
                            "          updateDataStoreParent(dataStore);",
                            "        });",
                            "    }",
                            "  });",
                            "",
                            "  // update data store parents on collaboration -> process",
                            "  this.postExecute('canvas.updateRoot', function(event) {",
                            "    var context = event.context,",
                            "        oldRoot = context.oldRoot,",
                            "        newRoot = context.newRoot;",
                            "",
                            "    var dataStores = getDataStores(oldRoot);",
                            "",
                            "    dataStores.forEach(function(dataStore) {",
                            "",
                            "      if (is(newRoot, 'bpmn:Process')) {",
                            "        updateDataStoreParent(dataStore, newRoot);",
                            "      }",
                            "",
                            "    });",
                            "  });",
                            "}",
                            "",
                            "DataStoreBehavior.$inject = [",
                            "  'canvas',",
                            "  'commandStack',",
                            "  'elementRegistry',",
                            "  'eventBus',",
                            "];",
                            "",
                            "inherits(DataStoreBehavior, CommandInterceptor);",
                            "",
                            "",
                            "// helpers //////////",
                            "",
                            "function isDescendant(descendant, ancestor) {",
                            "  var descendantBo = descendant.businessObject || descendant,",
                            "      ancestorBo = ancestor.businessObject || ancestor;",
                            "",
                            "  while (descendantBo.$parent) {",
                            "    if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {",
                            "      return true;",
                            "    }",
                            "",
                            "    descendantBo = descendantBo.$parent;",
                            "  }",
                            "",
                            "  return false;",
                            "}",
                            "",
                            "function getAncestor(element, type) {",
                            "",
                            "  while (element.parent) {",
                            "    if (is(element.parent, type)) {",
                            "      return element.parent;",
                            "    }",
                            "",
                            "    element = element.parent;",
                            "  }",
                            "}"
                        ]
                    },
                    "DeleteLaneBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  getChildLanes",
                            "} from '../util/LaneUtil';",
                            "",
                            "import {",
                            "  eachElement",
                            "} from 'diagram-js/lib/util/Elements';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../../space-tool/BpmnSpaceTool').default} SpaceTool",
                            " */",
                            "",
                            "var LOW_PRIORITY = 500;",
                            "",
                            "",
                            "/**",
                            " * BPMN specific delete lane behavior.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {SpaceTool} spaceTool",
                            " */",
                            "export default function DeleteLaneBehavior(eventBus, spaceTool) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "",
                            "  function compensateLaneDelete(shape, oldParent) {",
                            "",
                            "    var siblings = getChildLanes(oldParent);",
                            "",
                            "    var topAffected = [];",
                            "    var bottomAffected = [];",
                            "",
                            "    eachElement(siblings, function(element) {",
                            "",
                            "      if (element.y > shape.y) {",
                            "        bottomAffected.push(element);",
                            "      } else {",
                            "        topAffected.push(element);",
                            "      }",
                            "",
                            "      return element.children;",
                            "    });",
                            "",
                            "    if (!siblings.length) {",
                            "      return;",
                            "    }",
                            "",
                            "    var offset;",
                            "",
                            "    if (bottomAffected.length && topAffected.length) {",
                            "      offset = shape.height / 2;",
                            "    } else {",
                            "      offset = shape.height;",
                            "    }",
                            "",
                            "    var topAdjustments,",
                            "        bottomAdjustments;",
                            "",
                            "    if (topAffected.length) {",
                            "      topAdjustments = spaceTool.calculateAdjustments(",
                            "        topAffected, 'y', offset, shape.y - 10);",
                            "",
                            "      spaceTool.makeSpace(",
                            "        topAdjustments.movingShapes,",
                            "        topAdjustments.resizingShapes,",
                            "        { x: 0, y: offset }, 's');",
                            "    }",
                            "",
                            "    if (bottomAffected.length) {",
                            "      bottomAdjustments = spaceTool.calculateAdjustments(",
                            "        bottomAffected, 'y', -offset, shape.y + shape.height + 10);",
                            "",
                            "      spaceTool.makeSpace(",
                            "        bottomAdjustments.movingShapes,",
                            "        bottomAdjustments.resizingShapes,",
                            "        { x: 0, y: -offset }, 'n');",
                            "    }",
                            "  }",
                            "",
                            "",
                            "  /**",
                            "   * Adjust sizes of other lanes after lane deletion",
                            "   */",
                            "  this.postExecuted('shape.delete', LOW_PRIORITY, function(event) {",
                            "",
                            "    var context = event.context,",
                            "        hints = context.hints,",
                            "        shape = context.shape,",
                            "        oldParent = context.oldParent;",
                            "",
                            "    // only compensate lane deletes",
                            "    if (!is(shape, 'bpmn:Lane')) {",
                            "      return;",
                            "    }",
                            "",
                            "    // compensate root deletes only",
                            "    if (hints && hints.nested) {",
                            "      return;",
                            "    }",
                            "",
                            "    compensateLaneDelete(shape, oldParent);",
                            "  });",
                            "}",
                            "",
                            "DeleteLaneBehavior.$inject = [",
                            "  'eventBus',",
                            "  'spaceTool'",
                            "];",
                            "",
                            "inherits(DeleteLaneBehavior, CommandInterceptor);"
                        ]
                    },
                    "DetachEventBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  getBusinessObject,",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import { isLabel } from '../../../util/LabelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('../../replace/BpmnReplace').default} BpmnReplace",
                            " * @typedef {import('didi').Injector} Injector",
                            " */",
                            "",
                            "var LOW_PRIORITY = 500;",
                            "",
                            "",
                            "/**",
                            " * Replace boundary event with intermediate event when creating or moving results in detached event.",
                            " *",
                            " * @param {BpmnReplace} bpmnReplace",
                            " * @param {Injector} injector",
                            " */",
                            "export default function DetachEventBehavior(bpmnReplace, injector) {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  this._bpmnReplace = bpmnReplace;",
                            "",
                            "  var self = this;",
                            "",
                            "  this.postExecuted('elements.create', LOW_PRIORITY, function(context) {",
                            "    var elements = context.elements;",
                            "",
                            "    elements.filter(function(shape) {",
                            "      var host = shape.host;",
                            "",
                            "      return shouldReplace(shape, host);",
                            "    }).map(function(shape) {",
                            "      return elements.indexOf(shape);",
                            "    }).forEach(function(index) {",
                            "      context.elements[ index ] = self._replaceShape(elements[ index ]);",
                            "    });",
                            "  }, true);",
                            "",
                            "  this.preExecute('elements.move', LOW_PRIORITY, function(context) {",
                            "    var shapes = context.shapes,",
                            "        newHost = context.newHost;",
                            "",
                            "    shapes.forEach(function(shape, index) {",
                            "      var host = shape.host;",
                            "",
                            "      if (shouldReplace(shape, includes(shapes, host) ? host : newHost)) {",
                            "        shapes[ index ] = self._replaceShape(shape);",
                            "      }",
                            "    });",
                            "  }, true);",
                            "}",
                            "",
                            "DetachEventBehavior.$inject = [",
                            "  'bpmnReplace',",
                            "  'injector'",
                            "];",
                            "",
                            "inherits(DetachEventBehavior, CommandInterceptor);",
                            "",
                            "DetachEventBehavior.prototype._replaceShape = function(shape) {",
                            "  var eventDefinition = getEventDefinition(shape),",
                            "      intermediateEvent;",
                            "",
                            "  if (eventDefinition) {",
                            "    intermediateEvent = {",
                            "      type: 'bpmn:IntermediateCatchEvent',",
                            "      eventDefinitionType: eventDefinition.$type",
                            "    };",
                            "  } else {",
                            "    intermediateEvent = {",
                            "      type: 'bpmn:IntermediateThrowEvent'",
                            "    };",
                            "  }",
                            "",
                            "  return this._bpmnReplace.replaceElement(shape, intermediateEvent, { layoutConnection: false });",
                            "};",
                            "",
                            "",
                            "// helpers //////////",
                            "",
                            "function getEventDefinition(element) {",
                            "  var businessObject = getBusinessObject(element),",
                            "      eventDefinitions = businessObject.eventDefinitions;",
                            "",
                            "  return eventDefinitions && eventDefinitions[0];",
                            "}",
                            "",
                            "function shouldReplace(shape, host) {",
                            "  return !isLabel(shape) && is(shape, 'bpmn:BoundaryEvent') && !host;",
                            "}",
                            "",
                            "function includes(array, item) {",
                            "  return array.indexOf(item) !== -1;",
                            "}"
                        ]
                    },
                    "DropOnFlowBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import {",
                            "  assign,",
                            "  filter,",
                            "  find,",
                            "  isNumber",
                            "} from 'min-dash';",
                            "",
                            "import { getMid } from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  getApproxIntersection",
                            "} from 'diagram-js/lib/util/LineIntersection';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../../rules/BpmnRules').default} BpmnRules",
                            " * @typedef {import('../../modeling/Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * @param {EventBus} eventBus",
                            " * @param {BpmnRules} bpmnRules",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  /**",
                            "   * Reconnect start / end of a connection after",
                            "   * dropping an element on a flow.",
                            "   */",
                            "",
                            "  function insertShape(shape, targetFlow, positionOrBounds) {",
                            "    var waypoints = targetFlow.waypoints,",
                            "        waypointsBefore,",
                            "        waypointsAfter,",
                            "        dockingPoint,",
                            "        source,",
                            "        target,",
                            "        incomingConnection,",
                            "        outgoingConnection,",
                            "        oldOutgoing = shape.outgoing.slice(),",
                            "        oldIncoming = shape.incoming.slice();",
                            "",
                            "    var mid;",
                            "",
                            "    if (isNumber(positionOrBounds.width)) {",
                            "      mid = getMid(positionOrBounds);",
                            "    } else {",
                            "      mid = positionOrBounds;",
                            "    }",
                            "",
                            "    var intersection = getApproxIntersection(waypoints, mid);",
                            "",
                            "    if (intersection) {",
                            "      waypointsBefore = waypoints.slice(0, intersection.index);",
                            "      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));",
                            "",
                            "      // due to inaccuracy intersection might have been found",
                            "      if (!waypointsBefore.length || !waypointsAfter.length) {",
                            "        return;",
                            "      }",
                            "",
                            "      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid;",
                            "",
                            "      // if last waypointBefore is inside shape's bounds, ignore docking point",
                            "      if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {",
                            "        waypointsBefore.push(copy(dockingPoint));",
                            "      }",
                            "",
                            "      // if first waypointAfter is inside shape's bounds, ignore docking point",
                            "      if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {",
                            "        waypointsAfter.unshift(copy(dockingPoint));",
                            "      }",
                            "    }",
                            "",
                            "    source = targetFlow.source;",
                            "    target = targetFlow.target;",
                            "",
                            "    if (bpmnRules.canConnect(source, shape, targetFlow)) {",
                            "",
                            "      // reconnect source -> inserted shape",
                            "      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);",
                            "",
                            "      incomingConnection = targetFlow;",
                            "    }",
                            "",
                            "    if (bpmnRules.canConnect(shape, target, targetFlow)) {",
                            "",
                            "      if (!incomingConnection) {",
                            "",
                            "        // reconnect inserted shape -> end",
                            "        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);",
                            "",
                            "        outgoingConnection = targetFlow;",
                            "      } else {",
                            "        outgoingConnection = modeling.connect(",
                            "          shape, target, { type: targetFlow.type, waypoints: waypointsAfter }",
                            "        );",
                            "      }",
                            "    }",
                            "",
                            "    var duplicateConnections = [].concat(",
                            "",
                            "      incomingConnection && filter(oldIncoming, function(connection) {",
                            "        return connection.source === incomingConnection.source;",
                            "      }) || [],",
                            "",
                            "      outgoingConnection && filter(oldOutgoing, function(connection) {",
                            "        return connection.target === outgoingConnection.target;",
                            "      }) || []",
                            "    );",
                            "",
                            "    if (duplicateConnections.length) {",
                            "      modeling.removeElements(duplicateConnections);",
                            "    }",
                            "  }",
                            "",
                            "  this.preExecute('elements.move', function(context) {",
                            "",
                            "    var newParent = context.newParent,",
                            "        shapes = context.shapes,",
                            "        delta = context.delta,",
                            "        shape = shapes[0];",
                            "",
                            "    if (!shape || !newParent) {",
                            "      return;",
                            "    }",
                            "",
                            "    // if the new parent is a connection,",
                            "    // change it to the new parent's parent",
                            "    if (newParent && newParent.waypoints) {",
                            "      context.newParent = newParent = newParent.parent;",
                            "    }",
                            "",
                            "    var shapeMid = getMid(shape);",
                            "    var newShapeMid = {",
                            "      x: shapeMid.x + delta.x,",
                            "      y: shapeMid.y + delta.y",
                            "    };",
                            "",
                            "    // find a connection which intersects with the",
                            "    // element's mid point",
                            "    var connection = find(newParent.children, function(element) {",
                            "      var canInsert = bpmnRules.canInsert(shapes, element);",
                            "",
                            "      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);",
                            "    });",
                            "",
                            "    if (connection) {",
                            "      context.targetFlow = connection;",
                            "      context.position = newShapeMid;",
                            "    }",
                            "",
                            "  }, true);",
                            "",
                            "  this.postExecuted('elements.move', function(context) {",
                            "",
                            "    var shapes = context.shapes,",
                            "        targetFlow = context.targetFlow,",
                            "        position = context.position;",
                            "",
                            "    if (targetFlow) {",
                            "      insertShape(shapes[0], targetFlow, position);",
                            "    }",
                            "",
                            "  }, true);",
                            "",
                            "  this.preExecute('shape.create', function(context) {",
                            "",
                            "    var parent = context.parent,",
                            "        shape = context.shape;",
                            "",
                            "    if (bpmnRules.canInsert(shape, parent)) {",
                            "      context.targetFlow = parent;",
                            "      context.parent = parent.parent;",
                            "    }",
                            "  }, true);",
                            "",
                            "  this.postExecuted('shape.create', function(context) {",
                            "",
                            "    var shape = context.shape,",
                            "        targetFlow = context.targetFlow,",
                            "        positionOrBounds = context.position;",
                            "",
                            "    if (targetFlow) {",
                            "      insertShape(shape, targetFlow, positionOrBounds);",
                            "    }",
                            "  }, true);",
                            "}",
                            "",
                            "inherits(DropOnFlowBehavior, CommandInterceptor);",
                            "",
                            "DropOnFlowBehavior.$inject = [",
                            "  'eventBus',",
                            "  'bpmnRules',",
                            "  'modeling'",
                            "];",
                            "",
                            "",
                            "// helpers /////////////////////",
                            "",
                            "function isPointInsideBBox(bbox, point) {",
                            "  var x = point.x,",
                            "      y = point.y;",
                            "",
                            "  return x >= bbox.x &&",
                            "    x <= bbox.x + bbox.width &&",
                            "    y >= bbox.y &&",
                            "    y <= bbox.y + bbox.height;",
                            "}",
                            "",
                            "function copy(obj) {",
                            "  return assign({}, obj);",
                            "}",
                            ""
                        ]
                    },
                    "EventBasedGatewayBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function EventBasedGatewayBehavior(eventBus, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  /**",
                            "   * Remove incoming sequence flows of event-based target when creating",
                            "   * sequence flow.",
                            "   *",
                            "   * 1. If source is event-based gateway remove all incoming sequence flows",
                            "   * 2. If source is not event-based gateway remove all incoming sequence flows",
                            "   * whose source is event-based gateway",
                            "   */",
                            "  this.preExecuted('connection.create', function(event) {",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        source = context.source,",
                            "        target = context.target,",
                            "        hints = context.hints;",
                            "",
                            "    if (hints && hints.createElementsBehavior === false) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (!isSequenceFlow(connection)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var sequenceFlows = [];",
                            "",
                            "    if (is(source, 'bpmn:EventBasedGateway')) {",
                            "      sequenceFlows = target.incoming",
                            "        .filter(flow =>",
                            "          flow !== connection &&",
                            "          isSequenceFlow(flow)",
                            "        );",
                            "    } else {",
                            "      sequenceFlows = target.incoming",
                            "        .filter(flow =>",
                            "          flow !== connection &&",
                            "          isSequenceFlow(flow) &&",
                            "          is(flow.source, 'bpmn:EventBasedGateway')",
                            "        );",
                            "    }",
                            "",
                            "    sequenceFlows.forEach(function(sequenceFlow) {",
                            "      modeling.removeConnection(sequenceFlow);",
                            "    });",
                            "  });",
                            "",
                            "  /**",
                            "   * Remove incoming sequence flows of event-based targets when replacing source",
                            "   * with event-based gateway.",
                            "   */",
                            "  this.preExecuted('shape.replace', function(event) {",
                            "    var context = event.context,",
                            "        newShape = context.newShape;",
                            "",
                            "    if (!is(newShape, 'bpmn:EventBasedGateway')) {",
                            "      return;",
                            "    }",
                            "",
                            "    var targets = newShape.outgoing.filter(isSequenceFlow)",
                            "      .reduce(function(targets, sequenceFlow) {",
                            "        if (!targets.includes(sequenceFlow.target)) {",
                            "          return targets.concat(sequenceFlow.target);",
                            "        }",
                            "",
                            "        return targets;",
                            "      }, []);",
                            "",
                            "    targets.forEach(function(target) {",
                            "      target.incoming.filter(isSequenceFlow).forEach(function(sequenceFlow) {",
                            "        const sequenceFlowsFromNewShape = target.incoming.filter(isSequenceFlow).filter(function(sequenceFlow) {",
                            "          return sequenceFlow.source === newShape;",
                            "        });",
                            "",
                            "        if (sequenceFlow.source !== newShape || sequenceFlowsFromNewShape.length > 1) {",
                            "          modeling.removeConnection(sequenceFlow);",
                            "        }",
                            "      });",
                            "    });",
                            "  });",
                            "}",
                            "",
                            "EventBasedGatewayBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling'",
                            "];",
                            "",
                            "inherits(EventBasedGatewayBehavior, CommandInterceptor);",
                            "",
                            "// helpers //////////",
                            "",
                            "function isSequenceFlow(connection) {",
                            "  return is(connection, 'bpmn:SequenceFlow');",
                            "}"
                        ]
                    },
                    "FixHoverBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { getLanesRoot } from '../util/LaneUtil';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import { isAny } from '../util/ModelingUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                            " */",
                            "",
                            "var HIGH_PRIORITY = 1500;",
                            "var HIGHEST_PRIORITY = 2000;",
                            "",
                            "",
                            "/**",
                            " * Correct hover targets in certain situations to improve diagram interaction.",
                            " *",
                            " * @param {ElementRegistry} elementRegistry",
                            " * @param {EventBus} eventBus",
                            " * @param {Canvas} canvas",
                            " */",
                            "export default function FixHoverBehavior(elementRegistry, eventBus, canvas) {",
                            "",
                            "  eventBus.on([",
                            "    'create.hover',",
                            "    'create.move',",
                            "    'create.out',",
                            "    'create.end',",
                            "    'shape.move.hover',",
                            "    'shape.move.move',",
                            "    'shape.move.out',",
                            "    'shape.move.end'",
                            "  ], HIGH_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape || event.shape,",
                            "        hover = event.hover;",
                            "",
                            "    // ensure elements are not dropped onto a bpmn:Lane but onto",
                            "    // the underlying bpmn:Participant",
                            "    if (is(hover, 'bpmn:Lane') && !isAny(shape, [ 'bpmn:Lane', 'bpmn:Participant' ])) {",
                            "      event.hover = getLanesRoot(hover);",
                            "      event.hoverGfx = elementRegistry.getGraphics(event.hover);",
                            "    }",
                            "",
                            "    var rootElement = canvas.getRootElement();",
                            "",
                            "    // ensure bpmn:Group and label elements are dropped",
                            "    // always onto the root",
                            "    if (hover !== rootElement && (shape.labelTarget || is(shape, 'bpmn:Group'))) {",
                            "      event.hover = rootElement;",
                            "      event.hoverGfx = elementRegistry.getGraphics(event.hover);",
                            "    }",
                            "  });",
                            "",
                            "  eventBus.on([",
                            "    'connect.hover',",
                            "    'connect.out',",
                            "    'connect.end',",
                            "    'connect.cleanup',",
                            "    'global-connect.hover',",
                            "    'global-connect.out',",
                            "    'global-connect.end',",
                            "    'global-connect.cleanup'",
                            "  ], HIGH_PRIORITY, function(event) {",
                            "    var hover = event.hover;",
                            "",
                            "    // ensure connections start/end on bpmn:Participant,",
                            "    // not the underlying bpmn:Lane",
                            "    if (is(hover, 'bpmn:Lane')) {",
                            "      event.hover = getLanesRoot(hover) || hover;",
                            "      event.hoverGfx = elementRegistry.getGraphics(event.hover);",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  eventBus.on([",
                            "    'bendpoint.move.hover'",
                            "  ], HIGH_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        hover = event.hover,",
                            "        type = context.type;",
                            "",
                            "    // ensure reconnect start/end on bpmn:Participant,",
                            "    // not the underlying bpmn:Lane",
                            "    if (is(hover, 'bpmn:Lane') && /reconnect/.test(type)) {",
                            "      event.hover = getLanesRoot(hover) || hover;",
                            "      event.hoverGfx = elementRegistry.getGraphics(event.hover);",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  eventBus.on([",
                            "    'connect.start'",
                            "  ], HIGH_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        start = context.start;",
                            "",
                            "    // ensure connect start on bpmn:Participant,",
                            "    // not the underlying bpmn:Lane",
                            "    if (is(start, 'bpmn:Lane')) {",
                            "      context.start = getLanesRoot(start) || start;",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  // allow movement of participants from lanes",
                            "  eventBus.on('shape.move.start', HIGHEST_PRIORITY, function(event) {",
                            "    var shape = event.shape;",
                            "",
                            "    if (is(shape, 'bpmn:Lane')) {",
                            "      event.shape = getLanesRoot(shape) || shape;",
                            "    }",
                            "  });",
                            "",
                            "  // ensure lanes aren't resized without their parent participant when using",
                            "  // space tool",
                            "  eventBus.on('spaceTool.move', HIGHEST_PRIORITY, function(event) {",
                            "    var hover = event.hover;",
                            "",
                            "    if (hover && is(hover, 'bpmn:Lane')) {",
                            "      event.hover = getLanesRoot(hover);",
                            "    }",
                            "  });",
                            "",
                            "}",
                            "",
                            "FixHoverBehavior.$inject = [",
                            "  'elementRegistry',",
                            "  'eventBus',",
                            "  'canvas'",
                            "];"
                        ]
                    },
                    "GroupBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  getBusinessObject,",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  createCategory,",
                            "  createCategoryValue,",
                            "  linkCategoryValue,",
                            "  unlinkCategory,",
                            "  unlinkCategoryValue",
                            "} from './util/CategoryUtil';",
                            "",
                            "/**",
                            " * @typedef {import('../BpmnFactory').default} BpmnFactory",
                            " * @typedef {import('../../../Modeler').default} Modeler",
                            " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('didi').Injector} Injector",
                            " * @typedef {import('../../copy-paste/ModdleCopy').default} ModdleCopy",
                            " *",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL",
                            " */",
                            "",
                            "var LOWER_PRIORITY = 770;",
                            "",
                            "",
                            "/**",
                            " * BPMN specific group behavior.",
                            " *",
                            " * @param {BpmnFactory} bpmnFactory",
                            " * @param {Modeler} bpmnjs",
                            " * @param {ElementRegistry} elementRegistry",
                            " * @param {EventBus} eventBus",
                            " * @param {Injector} injector",
                            " * @param {ModdleCopy} moddleCopy",
                            " */",
                            "export default function GroupBehavior(",
                            "    bpmnFactory,",
                            "    bpmnjs,",
                            "    elementRegistry,",
                            "    eventBus,",
                            "    injector,",
                            "    moddleCopy",
                            ") {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  /**",
                            "   * Returns all group element in the current registry.",
                            "   *",
                            "   * @return {Shape[]}",
                            "   */",
                            "  function getGroupElements() {",
                            "    return elementRegistry.filter(function(e) {",
                            "      return is(e, 'bpmn:Group');",
                            "    });",
                            "  }",
                            "",
                            "  /**",
                            "   * Returns true if given category is referenced in one of the given elements.",
                            "   *",
                            "   * @param {Element[]} elements",
                            "   * @param {ModdleElement} category",
                            "   *",
                            "   * @return {boolean}",
                            "   */",
                            "  function isReferencedCategory(elements, category) {",
                            "    return elements.some(function(element) {",
                            "      var businessObject = getBusinessObject(element);",
                            "",
                            "      var _category = businessObject.categoryValueRef && businessObject.categoryValueRef.$parent;",
                            "",
                            "      return _category === category;",
                            "    });",
                            "  }",
                            "",
                            "  /**",
                            "   * Returns true if given categoryValue is referenced in one of the given elements.",
                            "   *",
                            "   * @param {Element[]} elements",
                            "   * @param {ModdleElement} categoryValue",
                            "   *",
                            "   * @return {boolean}",
                            "   */",
                            "  function isReferencedCategoryValue(elements, categoryValue) {",
                            "    return elements.some(function(element) {",
                            "      var businessObject = getBusinessObject(element);",
                            "",
                            "      return businessObject.categoryValueRef === categoryValue;",
                            "    });",
                            "  }",
                            "",
                            "  /**",
                            "   * Remove category value unless it is still referenced.",
                            "   *",
                            "   * @param {ModdleElement} categoryValue",
                            "   * @param {ModdleElement} category",
                            "   * @param {ModdleElement} businessObject",
                            "   */",
                            "  function removeCategoryValue(categoryValue, category, businessObject) {",
                            "",
                            "    var groups = getGroupElements().filter(function(element) {",
                            "      return element.businessObject !== businessObject;",
                            "    });",
                            "",
                            "    if (category && !isReferencedCategory(groups, category)) {",
                            "      unlinkCategory(category);",
                            "    }",
                            "",
                            "    if (categoryValue && !isReferencedCategoryValue(groups, categoryValue)) {",
                            "      unlinkCategoryValue(categoryValue);",
                            "    }",
                            "  }",
                            "",
                            "  /**",
                            "   * Add category value.",
                            "   *",
                            "   * @param {ModdleElement} categoryValue",
                            "   * @param {ModdleElement} category",
                            "   *",
                            "   * @return {ModdleElement}",
                            "   */",
                            "  function addCategoryValue(categoryValue, category) {",
                            "    return linkCategoryValue(categoryValue, category, bpmnjs.getDefinitions());",
                            "  }",
                            "",
                            "  function setCategoryValue(element, context) {",
                            "    var businessObject = getBusinessObject(element),",
                            "        categoryValue = businessObject.categoryValueRef;",
                            "",
                            "    if (!categoryValue) {",
                            "      categoryValue =",
                            "      businessObject.categoryValueRef =",
                            "      context.categoryValue = (",
                            "        context.categoryValue || createCategoryValue(bpmnFactory)",
                            "      );",
                            "    }",
                            "",
                            "    var category = categoryValue.$parent;",
                            "",
                            "    if (!category) {",
                            "      category =",
                            "      categoryValue.$parent =",
                            "      context.category = (",
                            "        context.category || createCategory(bpmnFactory)",
                            "      );",
                            "    }",
                            "",
                            "    addCategoryValue(categoryValue, category, bpmnjs.getDefinitions());",
                            "  }",
                            "",
                            "  function unsetCategoryValue(element, context) {",
                            "    var category = context.category,",
                            "        categoryValue = context.categoryValue,",
                            "        businessObject = getBusinessObject(element);",
                            "",
                            "    if (categoryValue) {",
                            "      businessObject.categoryValueRef = null;",
                            "",
                            "      removeCategoryValue(categoryValue, category, businessObject);",
                            "    } else {",
                            "      removeCategoryValue(null, businessObject.categoryValueRef.$parent, businessObject);",
                            "    }",
                            "  }",
                            "",
                            "",
                            "  // ensure category + value exist before label editing",
                            "",
                            "  this.execute('label.create', function(event) {",
                            "    var context = event.context,",
                            "        labelTarget = context.labelTarget;",
                            "",
                            "    if (!is(labelTarget, 'bpmn:Group')) {",
                            "      return;",
                            "    }",
                            "",
                            "    setCategoryValue(labelTarget, context);",
                            "  });",
                            "",
                            "  this.revert('label.create', function(event) {",
                            "    var context = event.context,",
                            "        labelTarget = context.labelTarget;",
                            "",
                            "    if (!is(labelTarget, 'bpmn:Group')) {",
                            "      return;",
                            "    }",
                            "",
                            "    unsetCategoryValue(labelTarget, context);",
                            "  });",
                            "",
                            "",
                            "  // remove referenced category + value when group was deleted",
                            "",
                            "  this.execute('shape.delete', function(event) {",
                            "",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        businessObject = getBusinessObject(shape);",
                            "",
                            "    if (!is(shape, 'bpmn:Group') || shape.labelTarget) {",
                            "      return;",
                            "    }",
                            "",
                            "    var categoryValue = context.categoryValue = businessObject.categoryValueRef,",
                            "        category;",
                            "",
                            "    if (categoryValue) {",
                            "      category = context.category = categoryValue.$parent;",
                            "",
                            "      removeCategoryValue(categoryValue, category, businessObject);",
                            "",
                            "      businessObject.categoryValueRef = null;",
                            "    }",
                            "  });",
                            "",
                            "  this.reverted('shape.delete', function(event) {",
                            "",
                            "    var context = event.context,",
                            "        shape = context.shape;",
                            "",
                            "    if (!is(shape, 'bpmn:Group') || shape.labelTarget) {",
                            "      return;",
                            "    }",
                            "",
                            "    var category = context.category,",
                            "        categoryValue = context.categoryValue,",
                            "        businessObject = getBusinessObject(shape);",
                            "",
                            "    if (categoryValue) {",
                            "      businessObject.categoryValueRef = categoryValue;",
                            "",
                            "      addCategoryValue(categoryValue, category);",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  // create new category + value when group was created",
                            "",
                            "  this.execute('shape.create', function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape;",
                            "",
                            "    if (!is(shape, 'bpmn:Group') || shape.labelTarget) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (getBusinessObject(shape).categoryValueRef) {",
                            "      setCategoryValue(shape, context);",
                            "    }",
                            "  });",
                            "",
                            "  this.reverted('shape.create', function(event) {",
                            "",
                            "    var context = event.context,",
                            "        shape = context.shape;",
                            "",
                            "    if (!is(shape, 'bpmn:Group') || shape.labelTarget) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (getBusinessObject(shape).categoryValueRef) {",
                            "      unsetCategoryValue(shape, context);",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  // copy + paste categoryValueRef with group",
                            "",
                            "  function copy(bo, clone) {",
                            "    var targetBo = bpmnFactory.create(bo.$type);",
                            "",
                            "    return moddleCopy.copyElement(bo, targetBo, null, clone);",
                            "  }",
                            "",
                            "  eventBus.on('copyPaste.copyElement', LOWER_PRIORITY, function(context) {",
                            "    var descriptor = context.descriptor,",
                            "        element = context.element;",
                            "",
                            "    if (!is(element, 'bpmn:Group') || element.labelTarget) {",
                            "      return;",
                            "    }",
                            "",
                            "    var groupBo = getBusinessObject(element);",
                            "",
                            "    if (groupBo.categoryValueRef) {",
                            "",
                            "      var categoryValue = groupBo.categoryValueRef;",
                            "",
                            "      descriptor.categoryValue = copy(categoryValue, true);",
                            "",
                            "      if (categoryValue.$parent) {",
                            "        descriptor.category = copy(categoryValue.$parent, true);",
                            "      }",
                            "    }",
                            "  });",
                            "",
                            "  eventBus.on('copyPaste.pasteElement', LOWER_PRIORITY, function(context) {",
                            "    var descriptor = context.descriptor,",
                            "        businessObject = descriptor.businessObject,",
                            "        categoryValue = descriptor.categoryValue,",
                            "        category = descriptor.category;",
                            "",
                            "    if (categoryValue) {",
                            "      categoryValue = businessObject.categoryValueRef = copy(categoryValue);",
                            "    }",
                            "",
                            "    if (category) {",
                            "      categoryValue.$parent = copy(category);",
                            "    }",
                            "",
                            "    delete descriptor.category;",
                            "    delete descriptor.categoryValue;",
                            "  });",
                            "",
                            "}",
                            "",
                            "GroupBehavior.$inject = [",
                            "  'bpmnFactory',",
                            "  'bpmnjs',",
                            "  'elementRegistry',",
                            "  'eventBus',",
                            "  'injector',",
                            "  'moddleCopy'",
                            "];",
                            "",
                            "inherits(GroupBehavior, CommandInterceptor);"
                        ]
                    },
                    "ImportDockingFix.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  getMid",
                            "} from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import lineIntersect from './util/LineIntersect';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " */",
                            "",
                            "/**",
                            " * Fix broken dockings after DI imports.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " */",
                            "export default function ImportDockingFix(eventBus) {",
                            "",
                            "  function adjustDocking(startPoint, nextPoint, elementMid) {",
                            "",
                            "    var elementTop = {",
                            "      x: elementMid.x,",
                            "      y: elementMid.y - 50",
                            "    };",
                            "",
                            "    var elementLeft = {",
                            "      x: elementMid.x - 50,",
                            "      y: elementMid.y",
                            "    };",
                            "",
                            "    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop),",
                            "        horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);",
                            "",
                            "    // original is horizontal or vertical center cross intersection",
                            "    var centerIntersect;",
                            "",
                            "    if (verticalIntersect && horizontalIntersect) {",
                            "      if (getDistance(verticalIntersect, elementMid) > getDistance(horizontalIntersect, elementMid)) {",
                            "        centerIntersect = horizontalIntersect;",
                            "      } else {",
                            "        centerIntersect = verticalIntersect;",
                            "      }",
                            "    } else {",
                            "      centerIntersect = verticalIntersect || horizontalIntersect;",
                            "    }",
                            "",
                            "    startPoint.original = centerIntersect;",
                            "  }",
                            "",
                            "  function fixDockings(connection) {",
                            "    var waypoints = connection.waypoints;",
                            "",
                            "    adjustDocking(",
                            "      waypoints[0],",
                            "      waypoints[1],",
                            "      getMid(connection.source)",
                            "    );",
                            "",
                            "    adjustDocking(",
                            "      waypoints[waypoints.length - 1],",
                            "      waypoints[waypoints.length - 2],",
                            "      getMid(connection.target)",
                            "    );",
                            "  }",
                            "",
                            "  eventBus.on('bpmnElement.added', function(e) {",
                            "",
                            "    var element = e.element;",
                            "",
                            "    if (element.waypoints) {",
                            "      fixDockings(element);",
                            "    }",
                            "  });",
                            "}",
                            "",
                            "ImportDockingFix.$inject = [",
                            "  'eventBus'",
                            "];",
                            "",
                            "",
                            "// helpers //////////////////////",
                            "",
                            "function getDistance(p1, p2) {",
                            "  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));",
                            "}"
                        ]
                    },
                    "IsHorizontalFix.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  getBusinessObject,",
                            "  getDi",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  isAny",
                            "} from '../util/ModelingUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " */",
                            "",
                            "/**",
                            " * A component that makes sure that each created or updated",
                            " * Pool and Lane is assigned an isHorizontal property set to true.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " */",
                            "export default function IsHorizontalFix(eventBus) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  var elementTypesToUpdate = [",
                            "    'bpmn:Participant',",
                            "    'bpmn:Lane'",
                            "  ];",
                            "",
                            "  this.executed([ 'shape.move', 'shape.create', 'shape.resize' ], function(event) {",
                            "    var shape = event.context.shape,",
                            "        bo = getBusinessObject(shape),",
                            "        di = getDi(shape);",
                            "",
                            "    if (isAny(bo, elementTypesToUpdate) && !di.get('isHorizontal')) {",
                            "",
                            "      // set attribute directly to avoid modeling#updateProperty side effects",
                            "      di.set('isHorizontal', true);",
                            "    }",
                            "  });",
                            "",
                            "}",
                            "",
                            "IsHorizontalFix.$inject = [ 'eventBus' ];",
                            "",
                            "inherits(IsHorizontalFix, CommandInterceptor);"
                        ]
                    },
                    "LabelBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  assign",
                            "} from 'min-dash';",
                            "",
                            "import inherits from 'inherits-browser';",
                            "",
                            "import {",
                            "  is,",
                            "  getBusinessObject",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  isLabelExternal,",
                            "  getLabel,",
                            "  hasExternalLabel,",
                            "  isLabel",
                            "} from '../../../util/LabelUtil';",
                            "",
                            "import {",
                            "  getLabelAdjustment",
                            "} from './util/LabelLayoutUtil';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  getNewAttachPoint",
                            "} from 'diagram-js/lib/util/AttachUtil';",
                            "",
                            "import {",
                            "  getMid,",
                            "  roundPoint",
                            "} from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import {",
                            "  delta",
                            "} from 'diagram-js/lib/util/PositionUtil';",
                            "",
                            "import {",
                            "  sortBy",
                            "} from 'min-dash';",
                            "",
                            "import {",
                            "  getDistancePointLine,",
                            "  perpendicularFoot",
                            "} from './util/GeometricUtil';",
                            "",
                            "var NAME_PROPERTY = 'name';",
                            "var TEXT_PROPERTY = 'text';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('../BpmnFactory').default} BpmnFactory",
                            " * @typedef {import('../../../draw/TextRenderer').default} TextRenderer",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                            " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                            " *",
                            " * @typedef {Point[]} Line",
                            " */",
                            "",
                            "/**",
                            " * A component that makes sure that external labels are added",
                            " * together with respective elements and properly updated (DI wise)",
                            " * during move.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " * @param {BpmnFactory} bpmnFactory",
                            " * @param {TextRenderer} textRenderer",
                            " */",
                            "export default function LabelBehavior(",
                            "    eventBus, modeling, bpmnFactory,",
                            "    textRenderer) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  // update label if name property was updated",
                            "  this.postExecute('element.updateProperties', onPropertyUpdate);",
                            "  this.postExecute('element.updateModdleProperties', e => {",
                            "    const elementBo = getBusinessObject(e.context.element);",
                            "",
                            "    if (elementBo === e.context.moddleElement) {",
                            "      onPropertyUpdate(e);",
                            "    }",
                            "  });",
                            "",
                            "  function onPropertyUpdate(e) {",
                            "    var context = e.context,",
                            "        element = context.element,",
                            "        properties = context.properties;",
                            "",
                            "    if (NAME_PROPERTY in properties) {",
                            "      modeling.updateLabel(element, properties[NAME_PROPERTY]);",
                            "    }",
                            "",
                            "    if (TEXT_PROPERTY in properties",
                            "        && is(element, 'bpmn:TextAnnotation')) {",
                            "",
                            "      var newBounds = textRenderer.getTextAnnotationBounds(",
                            "        {",
                            "          x: element.x,",
                            "          y: element.y,",
                            "          width: element.width,",
                            "          height: element.height",
                            "        },",
                            "        properties[TEXT_PROPERTY] || ''",
                            "      );",
                            "",
                            "      modeling.updateLabel(element, properties.text, newBounds);",
                            "    }",
                            "  }",
                            "",
                            "  // create label shape after shape/connection was created",
                            "  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {",
                            "    var context = e.context,",
                            "        hints = context.hints || {};",
                            "",
                            "    if (hints.createElementsBehavior === false) {",
                            "      return;",
                            "    }",
                            "",
                            "    var element = context.shape || context.connection;",
                            "",
                            "    if (isLabel(element) || !isLabelExternal(element)) {",
                            "      return;",
                            "    }",
                            "",
                            "    // only create label if attribute available",
                            "    if (!getLabel(element)) {",
                            "      return;",
                            "    }",
                            "",
                            "    modeling.updateLabel(element, getLabel(element));",
                            "  });",
                            "",
                            "  // update label after label shape was deleted",
                            "  this.postExecute('shape.delete', function(event) {",
                            "    var context = event.context,",
                            "        labelTarget = context.labelTarget,",
                            "        hints = context.hints || {};",
                            "",
                            "    // check if label",
                            "    if (labelTarget && hints.unsetLabel !== false) {",
                            "      modeling.updateLabel(labelTarget, null, null, { removeShape: false });",
                            "    }",
                            "  });",
                            "",
                            "  function getVisibleLabelAdjustment(event) {",
                            "",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        label = connection.label,",
                            "        hints = assign({}, context.hints),",
                            "        newWaypoints = context.newWaypoints || connection.waypoints,",
                            "        oldWaypoints = context.oldWaypoints;",
                            "",
                            "",
                            "    if (typeof hints.startChanged === 'undefined') {",
                            "      hints.startChanged = !!hints.connectionStart;",
                            "    }",
                            "",
                            "    if (typeof hints.endChanged === 'undefined') {",
                            "      hints.endChanged = !!hints.connectionEnd;",
                            "    }",
                            "",
                            "    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);",
                            "  }",
                            "",
                            "  this.postExecute([",
                            "    'connection.layout',",
                            "    'connection.updateWaypoints'",
                            "  ], function(event) {",
                            "    var context = event.context,",
                            "        hints = context.hints || {};",
                            "",
                            "    if (hints.labelBehavior === false) {",
                            "      return;",
                            "    }",
                            "",
                            "    var connection = context.connection,",
                            "        label = connection.label,",
                            "        labelAdjustment;",
                            "",
                            "    // handle missing label as well as the case",
                            "    // that the label parent does not exist (yet),",
                            "    // because it is being pasted / created via multi element create",
                            "    //",
                            "    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227",
                            "    if (!label || !label.parent) {",
                            "      return;",
                            "    }",
                            "",
                            "    labelAdjustment = getVisibleLabelAdjustment(event);",
                            "",
                            "    modeling.moveShape(label, labelAdjustment);",
                            "  });",
                            "",
                            "",
                            "  // keep label position on shape replace",
                            "  this.postExecute([ 'shape.replace' ], function(event) {",
                            "    var context = event.context,",
                            "        newShape = context.newShape,",
                            "        oldShape = context.oldShape;",
                            "",
                            "    var businessObject = getBusinessObject(newShape);",
                            "",
                            "    if (businessObject",
                            "      && isLabelExternal(businessObject)",
                            "      && oldShape.label",
                            "      && newShape.label) {",
                            "      newShape.label.x = oldShape.label.x;",
                            "      newShape.label.y = oldShape.label.y;",
                            "    }",
                            "  });",
                            "",
                            "",
                            "  // move external label after resizing",
                            "  this.postExecute('shape.resize', function(event) {",
                            "",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        newBounds = context.newBounds,",
                            "        oldBounds = context.oldBounds;",
                            "",
                            "    if (hasExternalLabel(shape)) {",
                            "",
                            "      var label = shape.label,",
                            "          labelMid = getMid(label),",
                            "          edges = asEdges(oldBounds);",
                            "",
                            "      // get nearest border point to label as reference point",
                            "      var referencePoint = getReferencePoint(labelMid, edges);",
                            "",
                            "      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);",
                            "",
                            "      modeling.moveShape(label, delta);",
                            "",
                            "    }",
                            "",
                            "  });",
                            "",
                            "}",
                            "",
                            "inherits(LabelBehavior, CommandInterceptor);",
                            "",
                            "LabelBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling',",
                            "  'bpmnFactory',",
                            "  'textRenderer'",
                            "];",
                            "",
                            "// helpers //////////////////////",
                            "",
                            "/**",
                            " * Calculates a reference point delta relative to a new position",
                            " * of a certain element's bounds",
                            " *",
                            " * @param {Point} referencePoint",
                            " * @param {Rect} oldBounds",
                            " * @param {Rect} newBounds",
                            " *",
                            " * @return {Point}",
                            " */",
                            "export function getReferencePointDelta(referencePoint, oldBounds, newBounds) {",
                            "",
                            "  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);",
                            "",
                            "  return roundPoint(delta(newReferencePoint, referencePoint));",
                            "}",
                            "",
                            "/**",
                            " * Generates the nearest point (reference point) for a given point",
                            " * onto given set of lines",
                            " *",
                            " * @param {Point} point",
                            " * @param {Line[]} lines",
                            " *",
                            " * @return {Point}",
                            " */",
                            "export function getReferencePoint(point, lines) {",
                            "",
                            "  if (!lines.length) {",
                            "    return;",
                            "  }",
                            "",
                            "  var nearestLine = getNearestLine(point, lines);",
                            "",
                            "  return perpendicularFoot(point, nearestLine);",
                            "}",
                            "",
                            "/**",
                            " * Convert the given bounds to a lines array containing all edges",
                            " *",
                            " * @param {Rect|Point} bounds",
                            " *",
                            " * @return {Line[]}",
                            " */",
                            "export function asEdges(bounds) {",
                            "  return [",
                            "    [ // top",
                            "      {",
                            "        x: bounds.x,",
                            "        y: bounds.y",
                            "      },",
                            "      {",
                            "        x: bounds.x + (bounds.width || 0),",
                            "        y: bounds.y",
                            "      }",
                            "    ],",
                            "    [ // right",
                            "      {",
                            "        x: bounds.x + (bounds.width || 0),",
                            "        y: bounds.y",
                            "      },",
                            "      {",
                            "        x: bounds.x + (bounds.width || 0),",
                            "        y: bounds.y + (bounds.height || 0)",
                            "      }",
                            "    ],",
                            "    [ // bottom",
                            "      {",
                            "        x: bounds.x,",
                            "        y: bounds.y + (bounds.height || 0)",
                            "      },",
                            "      {",
                            "        x: bounds.x + (bounds.width || 0),",
                            "        y: bounds.y + (bounds.height || 0)",
                            "      }",
                            "    ],",
                            "    [ // left",
                            "      {",
                            "        x: bounds.x,",
                            "        y: bounds.y",
                            "      },",
                            "      {",
                            "        x: bounds.x,",
                            "        y: bounds.y + (bounds.height || 0)",
                            "      }",
                            "    ]",
                            "  ];",
                            "}",
                            "",
                            "/**",
                            " * Returns the nearest line for a given point by distance",
                            " * @param {Point} point",
                            " * @param {Line[]} lines",
                            " *",
                            " * @return {Line}",
                            " */",
                            "function getNearestLine(point, lines) {",
                            "",
                            "  var distances = lines.map(function(l) {",
                            "    return {",
                            "      line: l,",
                            "      distance: getDistancePointLine(point, l)",
                            "    };",
                            "  });",
                            "",
                            "  var sorted = sortBy(distances, 'distance');",
                            "",
                            "  return sorted[0].line;",
                            "}"
                        ]
                    },
                    "LayoutConnectionBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  assign",
                            "} from 'min-dash';",
                            "",
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { getConnectionAdjustment as getConnectionAnchorPoint } from './util/ConnectionLayoutUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * A component that makes sure that Associations connected to Connections",
                            " * are updated together with the Connection.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function LayoutConnectionBehavior(eventBus, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  function getnewAnchorPoint(event, point) {",
                            "",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        hints = assign({}, context.hints),",
                            "        newWaypoints = context.newWaypoints || connection.waypoints,",
                            "        oldWaypoints = context.oldWaypoints;",
                            "",
                            "",
                            "    if (typeof hints.startChanged === 'undefined') {",
                            "      hints.startChanged = !!hints.connectionStart;",
                            "    }",
                            "",
                            "    if (typeof hints.endChanged === 'undefined') {",
                            "      hints.endChanged = !!hints.connectionEnd;",
                            "    }",
                            "",
                            "    return getConnectionAnchorPoint(point, newWaypoints, oldWaypoints, hints);",
                            "  }",
                            "",
                            "  this.postExecute([",
                            "    'connection.layout',",
                            "    'connection.updateWaypoints'",
                            "  ], function(event) {",
                            "    var context = event.context;",
                            "",
                            "    var connection = context.connection,",
                            "        outgoing = connection.outgoing,",
                            "        incoming = connection.incoming;",
                            "",
                            "    incoming.forEach(function(connection) {",
                            "      var endPoint = connection.waypoints[connection.waypoints.length - 1];",
                            "      var newEndpoint = getnewAnchorPoint(event, endPoint);",
                            "",
                            "      var newWaypoints = [].concat(connection.waypoints.slice(0, -1), [ newEndpoint ]);",
                            "",
                            "      modeling.updateWaypoints(connection, newWaypoints);",
                            "    });",
                            "",
                            "    outgoing.forEach(function(connection) {",
                            "      var startpoint = connection.waypoints[0];",
                            "      var newStartpoint = getnewAnchorPoint(event, startpoint);",
                            "",
                            "      var newWaypoints = [].concat([ newStartpoint ], connection.waypoints.slice(1));",
                            "",
                            "      modeling.updateWaypoints(connection, newWaypoints);",
                            "    });",
                            "",
                            "  });",
                            "",
                            "",
                            "  this.postExecute([",
                            "    'connection.move'",
                            "  ], function(event) {",
                            "    var context = event.context;",
                            "",
                            "    var connection = context.connection,",
                            "        outgoing = connection.outgoing,",
                            "        incoming = connection.incoming,",
                            "        delta = context.delta;",
                            "",
                            "    incoming.forEach(function(connection) {",
                            "      var endPoint = connection.waypoints[connection.waypoints.length - 1];",
                            "      var newEndpoint = {",
                            "        x: endPoint.x + delta.x,",
                            "        y: endPoint.y + delta.y",
                            "      };",
                            "",
                            "      var newWaypoints = [].concat(connection.waypoints.slice(0, -1), [ newEndpoint ]);",
                            "",
                            "      modeling.updateWaypoints(connection, newWaypoints);",
                            "    });",
                            "",
                            "    outgoing.forEach(function(connection) {",
                            "      var startpoint = connection.waypoints[0];",
                            "      var newStartpoint = {",
                            "        x: startpoint.x + delta.x,",
                            "        y: startpoint.y + delta.y",
                            "      };",
                            "",
                            "      var newWaypoints = [].concat([ newStartpoint ], connection.waypoints.slice(1));",
                            "",
                            "      modeling.updateWaypoints(connection, newWaypoints);",
                            "    });",
                            "",
                            "  });",
                            "",
                            "}",
                            "",
                            "inherits(LayoutConnectionBehavior, CommandInterceptor);",
                            "",
                            "LayoutConnectionBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling'",
                            "];"
                        ]
                    },
                    "MessageFlowBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import { isExpanded } from '../../../util/DiUtil';",
                            "",
                            "import { selfAndAllChildren } from 'diagram-js/lib/util/Elements';",
                            "",
                            "import {",
                            "  getResizedSourceAnchor,",
                            "  getResizedTargetAnchor",
                            "} from 'diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * BPMN-specific message flow behavior.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function MessageFlowBehavior(eventBus, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  this.postExecute('shape.replace', function(context) {",
                            "    var oldShape = context.oldShape,",
                            "        newShape = context.newShape;",
                            "",
                            "    if (!isParticipantCollapse(oldShape, newShape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var messageFlows = getMessageFlows(oldShape);",
                            "",
                            "    messageFlows.incoming.forEach(function(incoming) {",
                            "      var anchor = getResizedTargetAnchor(incoming, newShape, oldShape);",
                            "",
                            "      modeling.reconnectEnd(incoming, newShape, anchor);",
                            "    });",
                            "",
                            "    messageFlows.outgoing.forEach(function(outgoing) {",
                            "      var anchor = getResizedSourceAnchor(outgoing, newShape, oldShape);",
                            "",
                            "      modeling.reconnectStart(outgoing, newShape, anchor);",
                            "    });",
                            "  }, true);",
                            "",
                            "}",
                            "",
                            "MessageFlowBehavior.$inject = [ 'eventBus', 'modeling' ];",
                            "",
                            "inherits(MessageFlowBehavior, CommandInterceptor);",
                            "",
                            "// helpers //////////",
                            "",
                            "function isParticipantCollapse(oldShape, newShape) {",
                            "  return is(oldShape, 'bpmn:Participant')",
                            "    && isExpanded(oldShape)",
                            "    && is(newShape, 'bpmn:Participant')",
                            "    && !isExpanded(newShape);",
                            "}",
                            "",
                            "function getMessageFlows(parent) {",
                            "  var elements = selfAndAllChildren([ parent ], false);",
                            "",
                            "  var incoming = [],",
                            "      outgoing = [];",
                            "",
                            "  elements.forEach(function(element) {",
                            "    if (element === parent) {",
                            "      return;",
                            "    }",
                            "",
                            "    element.incoming.forEach(function(connection) {",
                            "      if (is(connection, 'bpmn:MessageFlow')) {",
                            "        incoming.push(connection);",
                            "      }",
                            "    });",
                            "",
                            "    element.outgoing.forEach(function(connection) {",
                            "      if (is(connection, 'bpmn:MessageFlow')) {",
                            "        outgoing.push(connection);",
                            "      }",
                            "    });",
                            "  }, []);",
                            "",
                            "  return {",
                            "    incoming: incoming,",
                            "    outgoing: outgoing",
                            "  };",
                            "}"
                        ]
                    },
                    "NonInterruptingBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "import inherits from 'inherits-browser';",
                            "",
                            "import { canBeNonInterrupting, getInterruptingProperty } from './util/NonInterruptingUtil';",
                            "import { getBusinessObject } from '../../../util/ModelUtil';",
                            "",
                            "export default function NonInterruptingBehavior(injector, modeling) {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  this.postExecuted('shape.replace', function(event) {",
                            "    const oldShape = event.context.oldShape;",
                            "    const newShape = event.context.newShape;",
                            "    const hints = event.context.hints;",
                            "",
                            "    if (!canBeNonInterrupting(newShape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    const property = getInterruptingProperty(newShape);",
                            "    const isExplicitChange = hints.targetElement && hints.targetElement[property] !== undefined;",
                            "",
                            "    if (isExplicitChange) {",
                            "      return;",
                            "    }",
                            "",
                            "    const isOldInterrupting = getBusinessObject(oldShape).get(property);",
                            "    const isNewInterruptingDefault = getBusinessObject(newShape).get(property);",
                            "",
                            "    if (isOldInterrupting === isNewInterruptingDefault) {",
                            "      return;",
                            "    }",
                            "",
                            "    modeling.updateProperties(newShape, {",
                            "      [property]: isOldInterrupting",
                            "    });",
                            "  });",
                            "}",
                            "",
                            "NonInterruptingBehavior.$inject = [ 'injector', 'modeling' ];",
                            "",
                            "inherits(NonInterruptingBehavior, CommandInterceptor);"
                        ]
                    },
                    "RemoveElementBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import lineIntersect from './util/LineIntersect';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../../rules/BpmnRules').default} BpmnRules",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * @param {EventBus} eventBus",
                            " * @param {BpmnRules} bpmnRules",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function RemoveElementBehavior(eventBus, bpmnRules, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  /**",
                            "   * Combine sequence flows when deleting an element",
                            "   * if there is one incoming and one outgoing",
                            "   * sequence flow",
                            "   */",
                            "  this.preExecute('shape.delete', function(e) {",
                            "",
                            "    var shape = e.context.shape;",
                            "",
                            "    // only handle [a] -> [shape] -> [b] patterns",
                            "    if (shape.incoming.length !== 1 || shape.outgoing.length !== 1) {",
                            "      return;",
                            "    }",
                            "",
                            "    var inConnection = shape.incoming[0],",
                            "        outConnection = shape.outgoing[0];",
                            "",
                            "    // only handle sequence flows",
                            "    if (!is(inConnection, 'bpmn:SequenceFlow') || !is(outConnection, 'bpmn:SequenceFlow')) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {",
                            "",
                            "      // compute new, combined waypoints",
                            "      var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);",
                            "",
                            "      modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);",
                            "    }",
                            "  });",
                            "",
                            "}",
                            "",
                            "inherits(RemoveElementBehavior, CommandInterceptor);",
                            "",
                            "RemoveElementBehavior.$inject = [",
                            "  'eventBus',",
                            "  'bpmnRules',",
                            "  'modeling'",
                            "];",
                            "",
                            "",
                            "// helpers //////////////////////",
                            "",
                            "function getDocking(point) {",
                            "  return point.original || point;",
                            "}",
                            "",
                            "",
                            "function getNewWaypoints(inWaypoints, outWaypoints) {",
                            "",
                            "  var intersection = lineIntersect(",
                            "    getDocking(inWaypoints[inWaypoints.length - 2]),",
                            "    getDocking(inWaypoints[inWaypoints.length - 1]),",
                            "    getDocking(outWaypoints[1]),",
                            "    getDocking(outWaypoints[0]));",
                            "",
                            "  if (intersection) {",
                            "    return [].concat(",
                            "      inWaypoints.slice(0, inWaypoints.length - 1),",
                            "      [ intersection ],",
                            "      outWaypoints.slice(1));",
                            "  } else {",
                            "    return [",
                            "      getDocking(inWaypoints[0]),",
                            "      getDocking(outWaypoints[outWaypoints.length - 1])",
                            "    ];",
                            "  }",
                            "}"
                        ]
                    },
                    "RemoveEmbeddedLabelBoundsBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { getDi } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * BPMN specific behavior ensuring that bpmndi:Label's dc:Bounds are removed",
                            " * when shape is resized.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function RemoveEmbeddedLabelBoundsBehavior(eventBus, modeling) {",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  this.preExecute('shape.resize', function(context) {",
                            "    var shape = context.shape;",
                            "",
                            "    var di = getDi(shape),",
                            "        label = di && di.get('label'),",
                            "        bounds = label && label.get('bounds');",
                            "",
                            "    if (bounds) {",
                            "      modeling.updateModdleProperties(shape, label, {",
                            "        bounds: undefined",
                            "      });",
                            "    }",
                            "  }, true);",
                            "}",
                            "",
                            "inherits(RemoveEmbeddedLabelBoundsBehavior, CommandInterceptor);",
                            "",
                            "RemoveEmbeddedLabelBoundsBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling'",
                            "];"
                        ]
                    },
                    "RemoveParticipantBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * BPMN specific remove behavior.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function RemoveParticipantBehavior(eventBus, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "",
                            "  /**",
                            "   * morph collaboration diagram into process diagram",
                            "   * after the last participant has been removed",
                            "   */",
                            "",
                            "  this.preExecute('shape.delete', function(context) {",
                            "",
                            "    var shape = context.shape,",
                            "        parent = shape.parent;",
                            "",
                            "    // activate the behavior if the shape to be removed",
                            "    // is a participant",
                            "    if (is(shape, 'bpmn:Participant')) {",
                            "      context.collaborationRoot = parent;",
                            "    }",
                            "  }, true);",
                            "",
                            "  this.postExecute('shape.delete', function(context) {",
                            "",
                            "    var collaborationRoot = context.collaborationRoot;",
                            "",
                            "    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {",
                            "",
                            "      // replace empty collaboration with process diagram",
                            "      modeling.makeProcess();",
                            "    }",
                            "  }, true);",
                            "",
                            "}",
                            "",
                            "RemoveParticipantBehavior.$inject = [ 'eventBus', 'modeling' ];",
                            "",
                            "inherits(RemoveParticipantBehavior, CommandInterceptor);"
                        ]
                    },
                    "ReplaceConnectionBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  forEach,",
                            "  find,",
                            "  matchPattern",
                            "} from 'min-dash';",
                            "",
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('../../rules/BpmnRules').default} BpmnRules",
                            " * @typedef {import('didi').Injector} Injector",
                            " */",
                            "",
                            "/**",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " * @param {BpmnRules} bpmnRules",
                            " * @param {Injector} injector",
                            " */",
                            "export default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  var dragging = injector.get('dragging', false);",
                            "",
                            "  function fixConnection(connection) {",
                            "",
                            "    var source = connection.source,",
                            "        target = connection.target,",
                            "        parent = connection.parent;",
                            "",
                            "    // do not do anything if connection",
                            "    // is already deleted (may happen due to other",
                            "    // behaviors plugged-in before)",
                            "    if (!parent) {",
                            "      return;",
                            "    }",
                            "",
                            "    var replacementType,",
                            "        remove;",
                            "",
                            "    /**",
                            "     * Check if incoming or outgoing connections",
                            "     * can stay or could be substituted with an",
                            "     * appropriate replacement.",
                            "     *",
                            "     * This holds true for SequenceFlow <> MessageFlow.",
                            "     */",
                            "",
                            "    if (is(connection, 'bpmn:SequenceFlow')) {",
                            "      if (!bpmnRules.canConnectSequenceFlow(source, target)) {",
                            "        remove = true;",
                            "      }",
                            "",
                            "      if (bpmnRules.canConnectMessageFlow(source, target)) {",
                            "        replacementType = 'bpmn:MessageFlow';",
                            "      }",
                            "    }",
                            "",
                            "    // transform message flows into sequence flows, if possible",
                            "",
                            "    if (is(connection, 'bpmn:MessageFlow')) {",
                            "",
                            "      if (!bpmnRules.canConnectMessageFlow(source, target)) {",
                            "        remove = true;",
                            "      }",
                            "",
                            "      if (bpmnRules.canConnectSequenceFlow(source, target)) {",
                            "        replacementType = 'bpmn:SequenceFlow';",
                            "      }",
                            "    }",
                            "",
                            "    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {",
                            "      remove = true;",
                            "    }",
                            "",
                            "",
                            "    // remove invalid connection,",
                            "    // unless it has been removed already",
                            "    if (remove) {",
                            "      modeling.removeConnection(connection);",
                            "    }",
                            "",
                            "    // replace SequenceFlow <> MessageFlow",
                            "",
                            "    if (replacementType) {",
                            "      modeling.connect(source, target, {",
                            "        type: replacementType,",
                            "        waypoints: connection.waypoints.slice()",
                            "      });",
                            "    }",
                            "  }",
                            "",
                            "  function replaceReconnectedConnection(event) {",
                            "",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        source = context.newSource || connection.source,",
                            "        target = context.newTarget || connection.target,",
                            "        allowed,",
                            "        replacement;",
                            "",
                            "    allowed = bpmnRules.canConnect(source, target);",
                            "",
                            "    if (!allowed || allowed.type === connection.type) {",
                            "      return;",
                            "    }",
                            "",
                            "    replacement = modeling.connect(source, target, {",
                            "      type: allowed.type,",
                            "      waypoints: connection.waypoints.slice()",
                            "    });",
                            "",
                            "    // remove old connection",
                            "    modeling.removeConnection(connection);",
                            "",
                            "    // replace connection in context to reconnect end/start",
                            "    context.connection = replacement;",
                            "",
                            "    if (dragging) {",
                            "      cleanDraggingSelection(connection, replacement);",
                            "    }",
                            "  }",
                            "",
                            "  // monkey-patch selection saved in dragging in order to re-select it when operation is finished",
                            "  function cleanDraggingSelection(oldConnection, newConnection) {",
                            "    var context = dragging.context(),",
                            "        previousSelection = context && context.payload.previousSelection,",
                            "        index;",
                            "",
                            "    // do nothing if not dragging or no selection was present",
                            "    if (!previousSelection || !previousSelection.length) {",
                            "      return;",
                            "    }",
                            "",
                            "    index = previousSelection.indexOf(oldConnection);",
                            "",
                            "    if (index === -1) {",
                            "      return;",
                            "    }",
                            "",
                            "    previousSelection.splice(index, 1, newConnection);",
                            "  }",
                            "",
                            "  // lifecycle hooks",
                            "",
                            "  this.postExecuted('elements.move', function(context) {",
                            "",
                            "    var closure = context.closure,",
                            "        allConnections = closure.allConnections;",
                            "",
                            "    forEach(allConnections, fixConnection);",
                            "  }, true);",
                            "",
                            "  this.preExecute('connection.reconnect', replaceReconnectedConnection);",
                            "",
                            "  this.postExecuted('element.updateProperties', function(event) {",
                            "    var context = event.context,",
                            "        properties = context.properties,",
                            "        element = context.element,",
                            "        businessObject = element.businessObject,",
                            "        connection;",
                            "",
                            "    // remove condition on change to default",
                            "    if (properties.default) {",
                            "      connection = find(",
                            "        element.outgoing,",
                            "        matchPattern({ id: element.businessObject.default.id })",
                            "      );",
                            "",
                            "      if (connection) {",
                            "        modeling.updateProperties(connection, { conditionExpression: undefined });",
                            "      }",
                            "    }",
                            "",
                            "    // remove default from source on change to conditional",
                            "    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {",
                            "      modeling.updateProperties(element.source, { default: undefined });",
                            "    }",
                            "  });",
                            "}",
                            "",
                            "inherits(ReplaceConnectionBehavior, CommandInterceptor);",
                            "",
                            "ReplaceConnectionBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling',",
                            "  'bpmnRules',",
                            "  'injector'",
                            "];"
                        ]
                    },
                    "ReplaceElementBehaviour.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import { forEach, reduce } from 'min-dash';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { isEventSubProcess } from '../../../util/DiUtil';",
                            "",
                            "/**",
                            " * @typedef {import('../../replace/BpmnReplace').default} BpmnReplace",
                            " * @typedef {import('../../rules/BpmnRules').default} BpmnRules",
                            " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                            " * @typedef {import('didi').Injector} Injector",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('diagram-js/lib/features/selection/Selection').default} Selection",
                            " */",
                            "",
                            "/**",
                            " * BPMN-specific replace behavior.",
                            " *",
                            " * @param {BpmnReplace} bpmnReplace",
                            " * @param {BpmnRules} bpmnRules",
                            " * @param {ElementRegistry} elementRegistry",
                            " * @param {Injector} injector",
                            " * @param {Modeling} modeling",
                            " * @param {Selection} selection",
                            " */",
                            "export default function ReplaceElementBehaviour(",
                            "    bpmnReplace,",
                            "    bpmnRules,",
                            "    elementRegistry,",
                            "    injector,",
                            "    modeling,",
                            "    selection",
                            ") {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  this._bpmnReplace = bpmnReplace;",
                            "  this._elementRegistry = elementRegistry;",
                            "  this._selection = selection;",
                            "",
                            "  // replace elements on create, e.g. during copy-paste",
                            "  this.postExecuted([ 'elements.create' ], 500, function(event) {",
                            "    var context = event.context,",
                            "        target = context.parent,",
                            "        elements = context.elements;",
                            "",
                            "    var elementReplacements = reduce(elements, function(replacements, element) {",
                            "      var canReplace = bpmnRules.canReplace([ element ], element.host || element.parent || target);",
                            "",
                            "      return canReplace ? replacements.concat(canReplace.replacements) : replacements;",
                            "    }, []);",
                            "",
                            "    if (elementReplacements.length) {",
                            "      this._replaceElements(elements, elementReplacements);",
                            "    }",
                            "  }, this);",
                            "",
                            "  // replace elements on move",
                            "  this.postExecuted([ 'elements.move' ], 500, function(event) {",
                            "    var context = event.context,",
                            "        target = context.newParent,",
                            "        newHost = context.newHost,",
                            "        elements = [];",
                            "",
                            "    forEach(context.closure.topLevel, function(topLevelElements) {",
                            "      if (isEventSubProcess(topLevelElements)) {",
                            "        elements = elements.concat(topLevelElements.children);",
                            "      } else {",
                            "        elements = elements.concat(topLevelElements);",
                            "      }",
                            "    });",
                            "",
                            "    // set target to host if attaching",
                            "    if (elements.length === 1 && newHost) {",
                            "      target = newHost;",
                            "    }",
                            "",
                            "    var canReplace = bpmnRules.canReplace(elements, target);",
                            "",
                            "    if (canReplace) {",
                            "      this._replaceElements(elements, canReplace.replacements, newHost);",
                            "    }",
                            "  }, this);",
                            "",
                            "  // update attachments on host replace",
                            "  this.postExecute([ 'shape.replace' ], 1500, function(e) {",
                            "    var context = e.context,",
                            "        oldShape = context.oldShape,",
                            "        newShape = context.newShape,",
                            "        attachers = oldShape.attachers,",
                            "        canReplace;",
                            "",
                            "    if (attachers && attachers.length) {",
                            "      canReplace = bpmnRules.canReplace(attachers, newShape);",
                            "",
                            "      this._replaceElements(attachers, canReplace.replacements);",
                            "    }",
                            "",
                            "  }, this);",
                            "",
                            "  // keep ID on shape replace",
                            "  this.postExecuted([ 'shape.replace' ], 1500, function(e) {",
                            "    var context = e.context,",
                            "        oldShape = context.oldShape,",
                            "        newShape = context.newShape;",
                            "",
                            "    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);",
                            "    modeling.updateProperties(newShape, { id: oldShape.id });",
                            "  });",
                            "}",
                            "",
                            "inherits(ReplaceElementBehaviour, CommandInterceptor);",
                            "",
                            "ReplaceElementBehaviour.prototype._replaceElements = function(elements, newElements) {",
                            "  var elementRegistry = this._elementRegistry,",
                            "      bpmnReplace = this._bpmnReplace,",
                            "      selection = this._selection;",
                            "",
                            "  forEach(newElements, function(replacement) {",
                            "    var newElement = {",
                            "      type: replacement.newElementType",
                            "    };",
                            "",
                            "    var oldElement = elementRegistry.get(replacement.oldElementId);",
                            "",
                            "    var idx = elements.indexOf(oldElement);",
                            "",
                            "    elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });",
                            "  });",
                            "",
                            "  if (newElements) {",
                            "    selection.select(elements);",
                            "  }",
                            "};",
                            "",
                            "ReplaceElementBehaviour.$inject = [",
                            "  'bpmnReplace',",
                            "  'bpmnRules',",
                            "  'elementRegistry',",
                            "  'injector',",
                            "  'modeling',",
                            "  'selection'",
                            "];"
                        ]
                    },
                    "ResizeBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import { isExpanded } from '../../../util/DiUtil';",
                            "",
                            "import {",
                            "  asTRBL",
                            "} from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import {",
                            "  collectLanes,",
                            "  getLanesRoot",
                            "} from '../util/LaneUtil';",
                            "",
                            "var HIGH_PRIORITY = 1500;",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " *",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').Dimensions} Dimensions",
                            " * @typedef {import('diagram-js/lib/util/Types').Direction} Direction",
                            " * @typedef {import('diagram-js/lib/util/Types').RectTRBL} RectTRBL",
                            " */",
                            "",
                            "/**",
                            " * @type {Dimensions}",
                            " */",
                            "export var GROUP_MIN_DIMENSIONS = { width: 140, height: 120 };",
                            "",
                            "/**",
                            " * @type {Dimensions}",
                            " */",
                            "export var LANE_MIN_DIMENSIONS = { width: 300, height: 60 };",
                            "",
                            "/**",
                            " * @type {Dimensions}",
                            " */",
                            "export var PARTICIPANT_MIN_DIMENSIONS = { width: 300, height: 150 };",
                            "",
                            "/**",
                            " * @type {Dimensions}",
                            " */",
                            "export var SUB_PROCESS_MIN_DIMENSIONS = { width: 140, height: 120 };",
                            "",
                            "/**",
                            " * @type {Dimensions}",
                            " */",
                            "export var TEXT_ANNOTATION_MIN_DIMENSIONS = { width: 50, height: 30 };",
                            "",
                            "/**",
                            " * Set minimum bounds/resize constraints on resize.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " */",
                            "export default function ResizeBehavior(eventBus) {",
                            "  eventBus.on('resize.start', HIGH_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        direction = context.direction,",
                            "        balanced = context.balanced;",
                            "",
                            "    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {",
                            "      context.resizeConstraints = getParticipantResizeConstraints(shape, direction, balanced);",
                            "    }",
                            "",
                            "    if (is(shape, 'bpmn:Participant')) {",
                            "      context.minDimensions = PARTICIPANT_MIN_DIMENSIONS;",
                            "    }",
                            "",
                            "    if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {",
                            "      context.minDimensions = SUB_PROCESS_MIN_DIMENSIONS;",
                            "    }",
                            "",
                            "    if (is(shape, 'bpmn:TextAnnotation')) {",
                            "      context.minDimensions = TEXT_ANNOTATION_MIN_DIMENSIONS;",
                            "    }",
                            "  });",
                            "}",
                            "",
                            "ResizeBehavior.$inject = [ 'eventBus' ];",
                            "",
                            "",
                            "var abs = Math.abs,",
                            "    min = Math.min,",
                            "    max = Math.max;",
                            "",
                            "",
                            "function addToTrbl(trbl, attr, value, choice) {",
                            "  var current = trbl[attr];",
                            "",
                            "  // make sure to set the value if it does not exist",
                            "  // or apply the correct value by comparing against",
                            "  // choice(value, currentValue)",
                            "  trbl[attr] = current === undefined ? value : choice(value, current);",
                            "}",
                            "",
                            "function addMin(trbl, attr, value) {",
                            "  return addToTrbl(trbl, attr, value, min);",
                            "}",
                            "",
                            "function addMax(trbl, attr, value) {",
                            "  return addToTrbl(trbl, attr, value, max);",
                            "}",
                            "",
                            "var LANE_RIGHT_PADDING = 20,",
                            "    LANE_LEFT_PADDING = 50,",
                            "    LANE_TOP_PADDING = 20,",
                            "    LANE_BOTTOM_PADDING = 20;",
                            "",
                            "/**",
                            " * @param {Shape} laneShape",
                            " * @param {Direction} resizeDirection",
                            " * @param {boolean} [balanced=false]",
                            " *",
                            " * @return { {",
                            " *   min: RectTRBL;",
                            " *   max: RectTRBL;",
                            " * } }",
                            " */",
                            "export function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {",
                            "  var lanesRoot = getLanesRoot(laneShape);",
                            "",
                            "  var isFirst = true,",
                            "      isLast = true;",
                            "",
                            "  // max top/bottom size for lanes",
                            "  var allLanes = collectLanes(lanesRoot, [ lanesRoot ]);",
                            "",
                            "  var laneTrbl = asTRBL(laneShape);",
                            "",
                            "  var maxTrbl = {},",
                            "      minTrbl = {};",
                            "",
                            "  if (/e/.test(resizeDirection)) {",
                            "    minTrbl.right = laneTrbl.left + LANE_MIN_DIMENSIONS.width;",
                            "  } else",
                            "  if (/w/.test(resizeDirection)) {",
                            "    minTrbl.left = laneTrbl.right - LANE_MIN_DIMENSIONS.width;",
                            "  }",
                            "",
                            "  allLanes.forEach(function(other) {",
                            "",
                            "    var otherTrbl = asTRBL(other);",
                            "",
                            "    if (/n/.test(resizeDirection)) {",
                            "",
                            "      if (otherTrbl.top < (laneTrbl.top - 10)) {",
                            "        isFirst = false;",
                            "      }",
                            "",
                            "      // max top size (based on next element)",
                            "      if (balanced && abs(laneTrbl.top - otherTrbl.bottom) < 10) {",
                            "        addMax(maxTrbl, 'top', otherTrbl.top + LANE_MIN_DIMENSIONS.height);",
                            "      }",
                            "",
                            "      // min top size (based on self or nested element)",
                            "      if (abs(laneTrbl.top - otherTrbl.top) < 5) {",
                            "        addMin(minTrbl, 'top', otherTrbl.bottom - LANE_MIN_DIMENSIONS.height);",
                            "      }",
                            "    }",
                            "",
                            "    if (/s/.test(resizeDirection)) {",
                            "",
                            "      if (otherTrbl.bottom > (laneTrbl.bottom + 10)) {",
                            "        isLast = false;",
                            "      }",
                            "",
                            "      // max bottom size (based on previous element)",
                            "      if (balanced && abs(laneTrbl.bottom - otherTrbl.top) < 10) {",
                            "        addMin(maxTrbl, 'bottom', otherTrbl.bottom - LANE_MIN_DIMENSIONS.height);",
                            "      }",
                            "",
                            "      // min bottom size (based on self or nested element)",
                            "      if (abs(laneTrbl.bottom - otherTrbl.bottom) < 5) {",
                            "        addMax(minTrbl, 'bottom', otherTrbl.top + LANE_MIN_DIMENSIONS.height);",
                            "      }",
                            "    }",
                            "  });",
                            "",
                            "  // max top/bottom/left/right size based on flow nodes",
                            "  var flowElements = lanesRoot.children.filter(function(s) {",
                            "    return !s.hidden && !s.waypoints && (is(s, 'bpmn:FlowElement') || is(s, 'bpmn:Artifact'));",
                            "  });",
                            "",
                            "  flowElements.forEach(function(flowElement) {",
                            "",
                            "    var flowElementTrbl = asTRBL(flowElement);",
                            "",
                            "    if (isFirst && /n/.test(resizeDirection)) {",
                            "      addMin(minTrbl, 'top', flowElementTrbl.top - LANE_TOP_PADDING);",
                            "    }",
                            "",
                            "    if (/e/.test(resizeDirection)) {",
                            "      addMax(minTrbl, 'right', flowElementTrbl.right + LANE_RIGHT_PADDING);",
                            "    }",
                            "",
                            "    if (isLast && /s/.test(resizeDirection)) {",
                            "      addMax(minTrbl, 'bottom', flowElementTrbl.bottom + LANE_BOTTOM_PADDING);",
                            "    }",
                            "",
                            "    if (/w/.test(resizeDirection)) {",
                            "      addMin(minTrbl, 'left', flowElementTrbl.left - LANE_LEFT_PADDING);",
                            "    }",
                            "  });",
                            "",
                            "  return {",
                            "    min: minTrbl,",
                            "    max: maxTrbl",
                            "  };",
                            "}"
                        ]
                    },
                    "ResizeLaneBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  roundBounds",
                            "} from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import {",
                            "  hasPrimaryModifier",
                            "} from 'diagram-js/lib/util/Mouse';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "var SLIGHTLY_HIGHER_PRIORITY = 1001;",
                            "",
                            "",
                            "/**",
                            " * Invoke {@link Modeling#resizeLane} instead of {@link Modeling#resizeShape}",
                            " * when resizing a lane or participant shape.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function ResizeLaneBehavior(eventBus, modeling) {",
                            "",
                            "  eventBus.on('resize.start', SLIGHTLY_HIGHER_PRIORITY + 500, function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape;",
                            "",
                            "    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {",
                            "",
                            "      // should we resize the opposite lane(s) in",
                            "      // order to compensate for the resize operation?",
                            "      context.balanced = !hasPrimaryModifier(event);",
                            "    }",
                            "  });",
                            "",
                            "  /**",
                            "   * Intercept resize end and call resize lane function instead.",
                            "   */",
                            "  eventBus.on('resize.end', SLIGHTLY_HIGHER_PRIORITY, function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        canExecute = context.canExecute,",
                            "        newBounds = context.newBounds;",
                            "",
                            "    if (is(shape, 'bpmn:Lane') || is(shape, 'bpmn:Participant')) {",
                            "",
                            "      if (canExecute) {",
                            "",
                            "        // ensure we have actual pixel values for new bounds",
                            "        // (important when zoom level was > 1 during move)",
                            "        newBounds = roundBounds(newBounds);",
                            "",
                            "        // perform the actual resize",
                            "        modeling.resizeLane(shape, newBounds, context.balanced);",
                            "      }",
                            "",
                            "      // stop propagation",
                            "      return false;",
                            "    }",
                            "  });",
                            "}",
                            "",
                            "ResizeLaneBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling'",
                            "];"
                        ]
                    },
                    "RootElementReferenceBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import {",
                            "  find,",
                            "  isArray,",
                            "  matchPattern,",
                            "  some",
                            "} from 'min-dash';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  add as collectionAdd,",
                            "  remove as collectionRemove",
                            "} from 'diagram-js/lib/util/Collections';",
                            "",
                            "import {",
                            "  getBusinessObject,",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import { isAny } from '../util/ModelingUtil';",
                            "",
                            "import { hasEventDefinition } from '../../../util/DiUtil';",
                            "",
                            "/**",
                            " * @typedef {import('../../../Modeler').default} Modeler",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('didi').Injector} Injector",
                            " * @typedef {import('../../copy-paste/ModdleCopy').default} ModdleCopy",
                            " * @typedef {import('../BpmnFactory').default} BpmnFactory",
                            " *",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL",
                            " */",
                            "",
                            "var LOW_PRIORITY = 500;",
                            "",
                            "",
                            "/**",
                            " * Add referenced root elements (error, escalation, message, signal) if they don't exist.",
                            " * Copy referenced root elements on copy & paste.",
                            " *",
                            " * @param {Modeler} bpmnjs",
                            " * @param {EventBus} eventBus",
                            " * @param {Injector} injector",
                            " * @param {ModdleCopy} moddleCopy",
                            " * @param {BpmnFactory} bpmnFactory",
                            " */",
                            "export default function RootElementReferenceBehavior(",
                            "    bpmnjs, eventBus, injector, moddleCopy, bpmnFactory",
                            ") {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  function canHaveRootElementReference(element) {",
                            "    return isAny(element, [ 'bpmn:ReceiveTask', 'bpmn:SendTask' ]) ||",
                            "      hasAnyEventDefinition(element, [",
                            "        'bpmn:ErrorEventDefinition',",
                            "        'bpmn:EscalationEventDefinition',",
                            "        'bpmn:MessageEventDefinition',",
                            "        'bpmn:SignalEventDefinition'",
                            "      ]);",
                            "  }",
                            "",
                            "  function hasRootElement(rootElement) {",
                            "    var definitions = bpmnjs.getDefinitions(),",
                            "        rootElements = definitions.get('rootElements');",
                            "",
                            "    return !!find(rootElements, matchPattern({ id: rootElement.id }));",
                            "  }",
                            "",
                            "  function getRootElementReferencePropertyName(eventDefinition) {",
                            "    if (is(eventDefinition, 'bpmn:ErrorEventDefinition')) {",
                            "      return 'errorRef';",
                            "    } else if (is(eventDefinition, 'bpmn:EscalationEventDefinition')) {",
                            "      return 'escalationRef';",
                            "    } else if (is(eventDefinition, 'bpmn:MessageEventDefinition')) {",
                            "      return 'messageRef';",
                            "    } else if (is(eventDefinition, 'bpmn:SignalEventDefinition')) {",
                            "      return 'signalRef';",
                            "    }",
                            "  }",
                            "",
                            "  function getRootElement(businessObject) {",
                            "    if (isAny(businessObject, [ 'bpmn:ReceiveTask', 'bpmn:SendTask' ])) {",
                            "      return businessObject.get('messageRef');",
                            "    }",
                            "",
                            "    var eventDefinitions = businessObject.get('eventDefinitions'),",
                            "        eventDefinition = eventDefinitions[ 0 ];",
                            "",
                            "    return eventDefinition.get(getRootElementReferencePropertyName(eventDefinition));",
                            "  }",
                            "",
                            "  function setRootElement(businessObject, rootElement) {",
                            "    if (isAny(businessObject, [ 'bpmn:ReceiveTask', 'bpmn:SendTask' ])) {",
                            "      return businessObject.set('messageRef', rootElement);",
                            "    }",
                            "",
                            "    var eventDefinitions = businessObject.get('eventDefinitions'),",
                            "        eventDefinition = eventDefinitions[ 0 ];",
                            "",
                            "    return eventDefinition.set(getRootElementReferencePropertyName(eventDefinition), rootElement);",
                            "  }",
                            "",
                            "  // create shape",
                            "  this.executed([",
                            "    'shape.create',",
                            "    'element.updateProperties',",
                            "    'element.updateModdleProperties'",
                            "  ], function(context) {",
                            "    var shape = context.shape || context.element;",
                            "",
                            "    if (!canHaveRootElementReference(shape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var businessObject = getBusinessObject(shape),",
                            "        rootElement = getRootElement(businessObject),",
                            "        rootElements;",
                            "",
                            "    if (rootElement && !hasRootElement(rootElement)) {",
                            "      rootElements = bpmnjs.getDefinitions().get('rootElements');",
                            "",
                            "      // add root element",
                            "      collectionAdd(rootElements, rootElement);",
                            "",
                            "      context.addedRootElement = rootElement;",
                            "    }",
                            "  }, true);",
                            "",
                            "  this.reverted([",
                            "    'shape.create',",
                            "    'element.updateProperties',",
                            "    'element.updateModdleProperties'",
                            "  ], function(context) {",
                            "    var addedRootElement = context.addedRootElement;",
                            "",
                            "    if (!addedRootElement) {",
                            "      return;",
                            "    }",
                            "",
                            "    var rootElements = bpmnjs.getDefinitions().get('rootElements');",
                            "",
                            "    // remove root element",
                            "    collectionRemove(rootElements, addedRootElement);",
                            "  }, true);",
                            "",
                            "  eventBus.on('copyPaste.copyElement', function(context) {",
                            "    var descriptor = context.descriptor,",
                            "        element = context.element;",
                            "",
                            "    if (element.labelTarget || !canHaveRootElementReference(element)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var businessObject = getBusinessObject(element),",
                            "        rootElement = getRootElement(businessObject);",
                            "",
                            "    if (rootElement) {",
                            "",
                            "      // TODO(nikku): clone on copy",
                            "      descriptor.referencedRootElement = rootElement;",
                            "    }",
                            "  });",
                            "",
                            "  eventBus.on('copyPaste.pasteElement', LOW_PRIORITY, function(context) {",
                            "    var descriptor = context.descriptor,",
                            "        businessObject = descriptor.businessObject,",
                            "        referencedRootElement = descriptor.referencedRootElement;",
                            "",
                            "    if (!referencedRootElement) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (!hasRootElement(referencedRootElement)) {",
                            "      referencedRootElement = moddleCopy.copyElement(",
                            "        referencedRootElement,",
                            "        bpmnFactory.create(referencedRootElement.$type)",
                            "      );",
                            "    }",
                            "",
                            "    setRootElement(businessObject, referencedRootElement);",
                            "",
                            "    delete descriptor.referencedRootElement;",
                            "  });",
                            "}",
                            "",
                            "RootElementReferenceBehavior.$inject = [",
                            "  'bpmnjs',",
                            "  'eventBus',",
                            "  'injector',",
                            "  'moddleCopy',",
                            "  'bpmnFactory'",
                            "];",
                            "",
                            "inherits(RootElementReferenceBehavior, CommandInterceptor);",
                            "",
                            "// helpers //////////",
                            "",
                            "function hasAnyEventDefinition(element, types) {",
                            "  if (!isArray(types)) {",
                            "    types = [ types ];",
                            "  }",
                            "",
                            "  return some(types, function(type) {",
                            "    return hasEventDefinition(element, type);",
                            "  });",
                            "}"
                        ]
                    },
                    "SpaceToolBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { forEach } from 'min-dash';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import { isExpanded } from '../../../util/DiUtil';",
                            "",
                            "import {",
                            "  GROUP_MIN_DIMENSIONS,",
                            "  LANE_MIN_DIMENSIONS,",
                            "  PARTICIPANT_MIN_DIMENSIONS,",
                            "  SUB_PROCESS_MIN_DIMENSIONS,",
                            "  TEXT_ANNOTATION_MIN_DIMENSIONS",
                            "} from './ResizeBehavior';",
                            "",
                            "import { getChildLanes } from '../util/LaneUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " *",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " */",
                            "",
                            "var max = Math.max;",
                            "",
                            "/**",
                            " * @param {EventBus} eventBus",
                            " */",
                            "export default function SpaceToolBehavior(eventBus) {",
                            "  eventBus.on('spaceTool.getMinDimensions', function(context) {",
                            "    var shapes = context.shapes,",
                            "        axis = context.axis,",
                            "        start = context.start,",
                            "        minDimensions = {};",
                            "",
                            "    forEach(shapes, function(shape) {",
                            "      var id = shape.id;",
                            "",
                            "      if (is(shape, 'bpmn:Participant')) {",
                            "",
                            "        if (isHorizontal(axis)) {",
                            "          minDimensions[ id ] = PARTICIPANT_MIN_DIMENSIONS;",
                            "        } else {",
                            "          minDimensions[ id ] = {",
                            "            width: PARTICIPANT_MIN_DIMENSIONS.width,",
                            "            height: getParticipantMinHeight(shape, start)",
                            "          };",
                            "        }",
                            "",
                            "      }",
                            "",
                            "      if (is(shape, 'bpmn:SubProcess') && isExpanded(shape)) {",
                            "        minDimensions[ id ] = SUB_PROCESS_MIN_DIMENSIONS;",
                            "      }",
                            "",
                            "      if (is(shape, 'bpmn:TextAnnotation')) {",
                            "        minDimensions[ id ] = TEXT_ANNOTATION_MIN_DIMENSIONS;",
                            "      }",
                            "",
                            "      if (is(shape, 'bpmn:Group')) {",
                            "        minDimensions[ id ] = GROUP_MIN_DIMENSIONS;",
                            "      }",
                            "    });",
                            "",
                            "    return minDimensions;",
                            "  });",
                            "}",
                            "",
                            "SpaceToolBehavior.$inject = [ 'eventBus' ];",
                            "",
                            "",
                            "// helpers //////////",
                            "function isHorizontal(axis) {",
                            "  return axis === 'x';",
                            "}",
                            "",
                            "/**",
                            " * Get minimum height for participant taking lanes into account.",
                            " *",
                            " * @param {Shape} participant",
                            " * @param {number} start",
                            " *",
                            " * @return {number}",
                            " */",
                            "function getParticipantMinHeight(participant, start) {",
                            "  var lanesMinHeight;",
                            "",
                            "  if (!hasChildLanes(participant)) {",
                            "    return PARTICIPANT_MIN_DIMENSIONS.height;",
                            "  }",
                            "",
                            "  lanesMinHeight = getLanesMinHeight(participant, start);",
                            "",
                            "  return max(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);",
                            "}",
                            "",
                            "function hasChildLanes(element) {",
                            "  return !!getChildLanes(element).length;",
                            "}",
                            "",
                            "function getLanesMinHeight(participant, resizeStart) {",
                            "  var lanes = getChildLanes(participant),",
                            "      resizedLane;",
                            "",
                            "  // find the nested lane which is currently resized",
                            "  resizedLane = findResizedLane(lanes, resizeStart);",
                            "",
                            "  // resized lane cannot shrink below the minimum height",
                            "  // but remaining lanes' dimensions are kept intact",
                            "  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;",
                            "}",
                            "",
                            "/**",
                            " * Find nested lane which is currently resized.",
                            " *",
                            " * @param {Shape[]} lanes",
                            " * @param {number} resizeStart",
                            " *",
                            " * @return {Shape}",
                            " */",
                            "function findResizedLane(lanes, resizeStart) {",
                            "  var i, lane, childLanes;",
                            "",
                            "  for (i = 0; i < lanes.length; i++) {",
                            "    lane = lanes[i];",
                            "",
                            "    // resizing current lane or a lane nested",
                            "    if (resizeStart >= lane.y && resizeStart <= lane.y + lane.height) {",
                            "      childLanes = getChildLanes(lane);",
                            "",
                            "      // a nested lane is resized",
                            "      if (childLanes.length) {",
                            "        return findResizedLane(childLanes, resizeStart);",
                            "      }",
                            "",
                            "      // current lane is the resized one",
                            "      return lane;",
                            "    }",
                            "  }",
                            "}"
                        ]
                    },
                    "SubProcessPlaneBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { find } from 'min-dash';",
                            "",
                            "import { isExpanded } from '../../../util/DiUtil';",
                            "",
                            "import { getBusinessObject, getDi, is } from '../../../util/ModelUtil';",
                            "",
                            "import { getMid } from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import { getBBox } from 'diagram-js/lib/util/Elements';",
                            "",
                            "import {",
                            "  getPlaneIdFromShape,",
                            "  getShapeIdFromPlane,",
                            "  isPlane,",
                            "  toPlaneId",
                            "} from '../../../util/DrilldownUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('../ElementFactory').default} ElementFactory",
                            " * @typedef {import('../BpmnFactory').default} BpmnFactory",
                            " * @typedef {import('../../../Modeler').default} Modeler",
                            " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                            " *",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " * @typedef {import('../../../model/Types').Root} Root",
                            " * @typedef {import('../../../model/Types').ModdleElement} ModdleElement",
                            " */",
                            "",
                            "var LOW_PRIORITY = 400;",
                            "var HIGH_PRIORITY = 600;",
                            "",
                            "var DEFAULT_POSITION = {",
                            "  x: 180,",
                            "  y: 160",
                            "};",
                            "",
                            "",
                            "/**",
                            " * Creates bpmndi:BPMNPlane elements and canvas planes when collapsed subprocesses are created.",
                            " *",
                            " * @param {Canvas} canvas",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " * @param {ElementFactory} elementFactory",
                            " * @param {BpmnFactory} bpmnFactory",
                            " * @param {Modeler} bpmnjs",
                            " * @param {ElementRegistry} elementRegistry",
                            " */",
                            "export default function SubProcessPlaneBehavior(",
                            "    canvas, eventBus, modeling,",
                            "    elementFactory, bpmnFactory, bpmnjs, elementRegistry) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  this._canvas = canvas;",
                            "  this._eventBus = eventBus;",
                            "  this._modeling = modeling;",
                            "  this._elementFactory = elementFactory;",
                            "  this._bpmnFactory = bpmnFactory;",
                            "  this._bpmnjs = bpmnjs;",
                            "  this._elementRegistry = elementRegistry;",
                            "",
                            "  var self = this;",
                            "",
                            "  function isCollapsedSubProcess(element) {",
                            "    return is(element, 'bpmn:SubProcess') && !isExpanded(element);",
                            "  }",
                            "",
                            "  function createRoot(context) {",
                            "    var shape = context.shape,",
                            "        rootElement = context.newRootElement;",
                            "",
                            "    var businessObject = getBusinessObject(shape);",
                            "",
                            "    rootElement = self._addDiagram(rootElement || businessObject);",
                            "",
                            "    context.newRootElement = canvas.addRootElement(rootElement);",
                            "  }",
                            "",
                            "  function removeRoot(context) {",
                            "    var shape = context.shape;",
                            "",
                            "    var businessObject = getBusinessObject(shape);",
                            "    self._removeDiagram(businessObject);",
                            "",
                            "    var rootElement = context.newRootElement = elementRegistry.get(getPlaneIdFromShape(businessObject));",
                            "",
                            "    canvas.removeRootElement(rootElement);",
                            "  }",
                            "",
                            "  // add plane elements for newly created sub-processes",
                            "  // this ensures we can actually drill down into the element",
                            "  this.executed('shape.create', function(context) {",
                            "    var shape = context.shape;",
                            "    if (!isCollapsedSubProcess(shape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    createRoot(context);",
                            "  }, true);",
                            "",
                            "",
                            "  this.postExecuted('shape.create', function(context) {",
                            "    var shape = context.shape,",
                            "        rootElement = context.newRootElement;",
                            "",
                            "    if (!rootElement || !shape.children) {",
                            "      return;",
                            "    }",
                            "",
                            "    self._showRecursively(shape.children);",
                            "",
                            "    self._moveChildrenToShape(shape, rootElement);",
                            "  }, true);",
                            "",
                            "",
                            "  this.reverted('shape.create', function(context) {",
                            "    var shape = context.shape;",
                            "    if (!isCollapsedSubProcess(shape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    removeRoot(context);",
                            "  }, true);",
                            "",
                            "",
                            "  this.preExecuted('shape.delete', function(context) {",
                            "    var shape = context.shape;",
                            "    if (!isCollapsedSubProcess(shape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var attachedRoot = elementRegistry.get(getPlaneIdFromShape(shape));",
                            "",
                            "    if (!attachedRoot) {",
                            "      return;",
                            "    }",
                            "",
                            "    modeling.removeElements(attachedRoot.children.slice());",
                            "  }, true);",
                            "",
                            "",
                            "  this.executed('shape.delete', function(context) {",
                            "    var shape = context.shape;",
                            "    if (!isCollapsedSubProcess(shape)) {",
                            "      return;",
                            "    }",
                            "    removeRoot(context);",
                            "  }, true);",
                            "",
                            "",
                            "  this.reverted('shape.delete', function(context) {",
                            "    var shape = context.shape;",
                            "    if (!isCollapsedSubProcess(shape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    createRoot(context);",
                            "  }, true);",
                            "",
                            "",
                            "  this.preExecuted('shape.replace', function(context) {",
                            "    var oldShape = context.oldShape;",
                            "    var newShape = context.newShape;",
                            "",
                            "    if (!isCollapsedSubProcess(oldShape) || !isCollapsedSubProcess(newShape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    // old plane could have content,",
                            "    // we remove it so it is not recursively deleted from 'shape.delete'",
                            "    context.oldRoot = canvas.removeRootElement(getPlaneIdFromShape(oldShape));",
                            "  }, true);",
                            "",
                            "",
                            "  this.postExecuted('shape.replace', function(context) {",
                            "    var newShape = context.newShape,",
                            "        source = context.oldRoot,",
                            "        target = canvas.findRoot(getPlaneIdFromShape(newShape));",
                            "",
                            "    if (!source || !target) {",
                            "      return;",
                            "    }",
                            "    var elements = source.children;",
                            "",
                            "    modeling.moveElements(elements, { x: 0, y: 0 }, target);",
                            "  }, true);",
                            "",
                            "",
                            "  // rename primary elements when the secondary element changes",
                            "  // this ensures rootElement.id = element.id + '_plane'",
                            "  this.executed('element.updateProperties', function(context) {",
                            "    var shape = context.element;",
                            "",
                            "    if (!is(shape, 'bpmn:SubProcess')) {",
                            "      return;",
                            "    }",
                            "",
                            "    var properties = context.properties;",
                            "    var oldProperties = context.oldProperties;",
                            "",
                            "    var oldId = oldProperties.id,",
                            "        newId = properties.id;",
                            "",
                            "    if (oldId === newId) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (isPlane(shape)) {",
                            "      elementRegistry.updateId(shape, toPlaneId(newId));",
                            "      elementRegistry.updateId(oldId, newId);",
                            "",
                            "      return;",
                            "    }",
                            "",
                            "    var planeElement = elementRegistry.get(toPlaneId(oldId));",
                            "",
                            "    if (!planeElement) {",
                            "      return;",
                            "    }",
                            "",
                            "    elementRegistry.updateId(toPlaneId(oldId), toPlaneId(newId));",
                            "  }, true);",
                            "",
                            "",
                            "  this.reverted('element.updateProperties', function(context) {",
                            "    var shape = context.element;",
                            "",
                            "    if (!is(shape, 'bpmn:SubProcess')) {",
                            "      return;",
                            "    }",
                            "",
                            "    var properties = context.properties;",
                            "    var oldProperties = context.oldProperties;",
                            "",
                            "    var oldId = oldProperties.id,",
                            "        newId = properties.id;",
                            "",
                            "    if (oldId === newId) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (isPlane(shape)) {",
                            "      elementRegistry.updateId(shape, toPlaneId(oldId));",
                            "      elementRegistry.updateId(newId, oldId);",
                            "",
                            "      return;",
                            "    }",
                            "",
                            "    var planeElement = elementRegistry.get(toPlaneId(newId));",
                            "",
                            "    if (!planeElement) {",
                            "      return;",
                            "    }",
                            "",
                            "    elementRegistry.updateId(planeElement, toPlaneId(oldId));",
                            "  }, true);",
                            "",
                            "  // re-throw element.changed to re-render primary shape if associated plane has",
                            "  // changed (e.g. bpmn:name property has changed)",
                            "  eventBus.on('element.changed', function(context) {",
                            "    var element = context.element;",
                            "",
                            "    if (!isPlane(element)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var plane = element;",
                            "",
                            "    var primaryShape = elementRegistry.get(getShapeIdFromPlane(plane));",
                            "",
                            "    // do not re-throw if no associated primary shape (e.g. bpmn:Process)",
                            "    if (!primaryShape || primaryShape === plane) {",
                            "      return;",
                            "    }",
                            "",
                            "    eventBus.fire('element.changed', { element: primaryShape });",
                            "  });",
                            "",
                            "",
                            "  // create/remove plane for the subprocess",
                            "  this.executed('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                            "    var shape = context.shape;",
                            "",
                            "    if (!is(shape, 'bpmn:SubProcess')) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (!isExpanded(shape)) {",
                            "      createRoot(context);",
                            "      self._showRecursively(shape.children);",
                            "    } else {",
                            "      removeRoot(context);",
                            "    }",
                            "",
                            "  }, true);",
                            "",
                            "",
                            "  // create/remove plane for the subprocess",
                            "  this.reverted('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
                            "    var shape = context.shape;",
                            "",
                            "    if (!is(shape, 'bpmn:SubProcess')) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (!isExpanded(shape)) {",
                            "      createRoot(context);",
                            "      self._showRecursively(shape.children);",
                            "    } else {",
                            "      removeRoot(context);",
                            "    }",
                            "",
                            "  }, true);",
                            "",
                            "  // move elements between planes",
                            "  this.postExecuted('shape.toggleCollapse', HIGH_PRIORITY, function(context) {",
                            "    var shape = context.shape;",
                            "",
                            "    if (!is(shape, 'bpmn:SubProcess')) {",
                            "      return;",
                            "    }",
                            "",
                            "    var rootElement = context.newRootElement;",
                            "",
                            "    if (!rootElement) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (!isExpanded(shape)) {",
                            "",
                            "      // collapsed",
                            "      self._moveChildrenToShape(shape, rootElement);",
                            "",
                            "    } else {",
                            "      self._moveChildrenToShape(rootElement, shape);",
                            "    }",
                            "  }, true);",
                            "",
                            "",
                            "  // copy-paste ///////////",
                            "",
                            "  // add elements in plane to tree",
                            "  eventBus.on('copyPaste.createTree', function(context) {",
                            "    var element = context.element,",
                            "        children = context.children;",
                            "",
                            "    if (!isCollapsedSubProcess(element)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var id = getPlaneIdFromShape(element);",
                            "    var parent = elementRegistry.get(id);",
                            "",
                            "    if (parent) {",
                            "",
                            "      // do not copy invisible root element",
                            "      children.push.apply(children, parent.children);",
                            "    }",
                            "  });",
                            "",
                            "  // set plane children as direct children of collapsed shape",
                            "  eventBus.on('copyPaste.copyElement', function(context) {",
                            "    var descriptor = context.descriptor,",
                            "        element = context.element,",
                            "        elements = context.elements;",
                            "",
                            "    var parent = element.parent;",
                            "",
                            "    var isPlane = is(getDi(parent), 'bpmndi:BPMNPlane');",
                            "    if (!isPlane) {",
                            "      return;",
                            "    }",
                            "",
                            "    var parentId = getShapeIdFromPlane(parent);",
                            "",
                            "    var referencedShape = find(elements, function(element) {",
                            "      return element.id === parentId;",
                            "    });",
                            "",
                            "    if (!referencedShape) {",
                            "      return;",
                            "    }",
                            "",
                            "    descriptor.parent = referencedShape.id;",
                            "  });",
                            "",
                            "  // hide children during pasting",
                            "  eventBus.on('copyPaste.pasteElement', function(context) {",
                            "    var descriptor = context.descriptor;",
                            "",
                            "    if (!descriptor.parent) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (isCollapsedSubProcess(descriptor.parent) || descriptor.parent.hidden) {",
                            "      descriptor.hidden = true;",
                            "    }",
                            "  });",
                            "",
                            "}",
                            "",
                            "inherits(SubProcessPlaneBehavior, CommandInterceptor);",
                            "",
                            "/**",
                            " * Moves the child elements from source to target.",
                            " *",
                            " * If the target is a plane, the children are moved to the top left corner.",
                            " * Otherwise, the center of the target is used.",
                            " *",
                            " * @param {Root} source",
                            " * @param {Root} target",
                            " */",
                            "SubProcessPlaneBehavior.prototype._moveChildrenToShape = function(source, target) {",
                            "  var modeling = this._modeling;",
                            "",
                            "  var children = source.children;",
                            "  var offset;",
                            "",
                            "  if (!children) {",
                            "    return;",
                            "  }",
                            "",
                            "  // add external labels that weren't children of sub process",
                            "  children = children.concat(children.reduce(function(labels, child) {",
                            "    if (child.label && child.label.parent !== source) {",
                            "      return labels.concat(child.label);",
                            "    }",
                            "",
                            "    return labels;",
                            "  }, []));",
                            "",
                            "  // only change plane if there are no visible children, but don't move them",
                            "  var visibleChildren = children.filter(function(child) {",
                            "    return !child.hidden;",
                            "  });",
                            "",
                            "  if (!visibleChildren.length) {",
                            "    modeling.moveElements(children, { x: 0, y: 0 }, target, { autoResize: false });",
                            "    return;",
                            "  }",
                            "",
                            "  var childrenBounds = getBBox(visibleChildren);",
                            "",
                            "  // target is a plane",
                            "  if (!target.x) {",
                            "    offset = {",
                            "      x: DEFAULT_POSITION.x - childrenBounds.x,",
                            "      y: DEFAULT_POSITION.y - childrenBounds.y",
                            "    };",
                            "  }",
                            "",
                            "  // source is a plane",
                            "  else {",
                            "",
                            "    // move relative to the center of the shape",
                            "    var targetMid = getMid(target);",
                            "    var childrenMid = getMid(childrenBounds);",
                            "",
                            "    offset = {",
                            "      x: targetMid.x - childrenMid.x,",
                            "      y: targetMid.y - childrenMid.y",
                            "    };",
                            "  }",
                            "",
                            "  modeling.moveElements(children, offset, target, { autoResize: false });",
                            "};",
                            "",
                            "/**",
                            " * Sets `hidden` property on all children of the given shape.",
                            " *",
                            " * @param {Element[]} elements",
                            " * @param {boolean} [hidden=false]",
                            " *",
                            " * @return {Element[]}",
                            " */",
                            "SubProcessPlaneBehavior.prototype._showRecursively = function(elements, hidden) {",
                            "  var self = this;",
                            "",
                            "  var result = [];",
                            "  elements.forEach(function(element) {",
                            "    element.hidden = !!hidden;",
                            "",
                            "    result = result.concat(element);",
                            "",
                            "    if (element.children) {",
                            "      result = result.concat(",
                            "        self._showRecursively(element.children, element.collapsed || hidden)",
                            "      );",
                            "    }",
                            "  });",
                            "",
                            "  return result;",
                            "};",
                            "",
                            "/**",
                            " * Adds a given root element to the BPMNDI diagrams.",
                            " *",
                            " * @param {Root|ModdleElement} planeElement",
                            " *",
                            " * @return {Root}",
                            " */",
                            "SubProcessPlaneBehavior.prototype._addDiagram = function(planeElement) {",
                            "  var bpmnjs = this._bpmnjs;",
                            "  var diagrams = bpmnjs.getDefinitions().diagrams;",
                            "",
                            "  if (!planeElement.businessObject) {",
                            "    planeElement = this._createNewDiagram(planeElement);",
                            "  }",
                            "",
                            "  diagrams.push(planeElement.di.$parent);",
                            "",
                            "  return planeElement;",
                            "};",
                            "",
                            "",
                            "/**",
                            " * Creates a new plane element for the given sub process.",
                            " *",
                            " * @param {ModdleElement} bpmnElement",
                            " *",
                            " * @return {Root}",
                            " */",
                            "SubProcessPlaneBehavior.prototype._createNewDiagram = function(bpmnElement) {",
                            "  var bpmnFactory = this._bpmnFactory,",
                            "      elementFactory = this._elementFactory;",
                            "",
                            "  var diPlane = bpmnFactory.create('bpmndi:BPMNPlane', {",
                            "    bpmnElement: bpmnElement",
                            "  });",
                            "",
                            "  var diDiagram = bpmnFactory.create('bpmndi:BPMNDiagram', {",
                            "    plane: diPlane",
                            "  });",
                            "",
                            "  diPlane.$parent = diDiagram;",
                            "",
                            "  // add a virtual element (not being drawn),",
                            "  // a copy cat of our BpmnImporter code",
                            "  var planeElement = elementFactory.createRoot({",
                            "    id: getPlaneIdFromShape(bpmnElement),",
                            "    type: bpmnElement.$type,",
                            "    di: diPlane,",
                            "    businessObject: bpmnElement,",
                            "    collapsed: true",
                            "  });",
                            "",
                            "  return planeElement;",
                            "};",
                            "",
                            "/**",
                            " * Removes the diagram for a given root element.",
                            " *",
                            " * @param {Root} rootElement",
                            " *",
                            " * @return {ModdleElement}",
                            " */",
                            "SubProcessPlaneBehavior.prototype._removeDiagram = function(rootElement) {",
                            "  var bpmnjs = this._bpmnjs;",
                            "",
                            "  var diagrams = bpmnjs.getDefinitions().diagrams;",
                            "",
                            "  var removedDiagram = find(diagrams, function(diagram) {",
                            "    return diagram.plane.bpmnElement.id === rootElement.id;",
                            "  });",
                            "",
                            "  diagrams.splice(diagrams.indexOf(removedDiagram), 1);",
                            "",
                            "  return removedDiagram;",
                            "};",
                            "",
                            "",
                            "SubProcessPlaneBehavior.$inject = [",
                            "  'canvas',",
                            "  'eventBus',",
                            "  'modeling',",
                            "  'elementFactory',",
                            "  'bpmnFactory',",
                            "  'bpmnjs',",
                            "  'elementRegistry'",
                            "];"
                        ]
                    },
                    "SubProcessStartEventBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import { isExpanded } from '../../../util/DiUtil.js';",
                            "",
                            "/**",
                            " * @typedef {import('didi').Injector} Injector",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * Add start event replacing element with expanded sub process.",
                            " *",
                            " * @param {Injector} injector",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function SubProcessStartEventBehavior(injector, modeling) {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  this.postExecuted('shape.replace', function(event) {",
                            "    var oldShape = event.context.oldShape,",
                            "        newShape = event.context.newShape;",
                            "",
                            "    if (",
                            "      !is(newShape, 'bpmn:SubProcess') ||",
                            "      ! (is(oldShape, 'bpmn:Task') || is(oldShape, 'bpmn:CallActivity')) ||",
                            "      !isExpanded(newShape)",
                            "    ) {",
                            "      return;",
                            "    }",
                            "",
                            "    var position = getStartEventPosition(newShape);",
                            "",
                            "    modeling.createShape({ type: 'bpmn:StartEvent' }, position, newShape);",
                            "  });",
                            "}",
                            "",
                            "SubProcessStartEventBehavior.$inject = [",
                            "  'injector',",
                            "  'modeling'",
                            "];",
                            "",
                            "inherits(SubProcessStartEventBehavior, CommandInterceptor);",
                            "",
                            "// helpers //////////",
                            "",
                            "function getStartEventPosition(shape) {",
                            "  return {",
                            "    x: shape.x + shape.width / 6,",
                            "    y: shape.y + shape.height / 2",
                            "  };",
                            "}"
                        ]
                    },
                    "ToggleCollapseConnectionBehaviour.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "",
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  forEach",
                            "} from 'min-dash';",
                            "",
                            "import { getMid } from 'diagram-js/lib/layout/LayoutUtil';",
                            "import { selfAndAllChildren } from 'diagram-js/lib/util/Elements';",
                            "",
                            "import { isExpanded } from '../../../util/DiUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " *",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL",
                            " */",
                            "",
                            "/**",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function ToggleCollapseConnectionBehaviour(",
                            "    eventBus, modeling",
                            ") {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  this.postExecuted('shape.toggleCollapse', 1500, function(context) {",
                            "",
                            "    // var shape = context.shape;",
                            "    var shape = context.shape;",
                            "",
                            "    // only change connections when collapsing",
                            "    if (isExpanded(shape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    var allChildren = selfAndAllChildren(shape);",
                            "",
                            "    allChildren.forEach(function(child) {",
                            "",
                            "      // Ensure that the connection array is not modified during iteration",
                            "      var incomingConnections = child.incoming.slice(),",
                            "          outgoingConnections = child.outgoing.slice();",
                            "",
                            "      forEach(incomingConnections, function(c) {",
                            "        handleConnection(c, true);",
                            "      });",
                            "",
                            "      forEach(outgoingConnections, function(c) {",
                            "        handleConnection(c, false);",
                            "      });",
                            "    });",
                            "",
                            "",
                            "    function handleConnection(c, incoming) {",
                            "      if (allChildren.indexOf(c.source) !== -1 && allChildren.indexOf(c.target) !== -1) {",
                            "        return;",
                            "      }",
                            "",
                            "      if (incoming) {",
                            "        modeling.reconnectEnd(c, shape, getMid(shape));",
                            "      } else {",
                            "        modeling.reconnectStart(c, shape, getMid(shape));",
                            "      }",
                            "",
                            "    }",
                            "",
                            "  }, true);",
                            "",
                            "}",
                            "",
                            "inherits(ToggleCollapseConnectionBehaviour, CommandInterceptor);",
                            "",
                            "ToggleCollapseConnectionBehaviour.$inject = [",
                            "  'eventBus',",
                            "  'modeling',",
                            "];",
                            "",
                            ""
                        ]
                    },
                    "ToggleElementCollapseBehaviour.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  getDi,",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  computeChildrenBBox",
                            "} from 'diagram-js/lib/features/resize/ResizeUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../ElementFactory').default} ElementFactory",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "var LOW_PRIORITY = 500;",
                            "",
                            "/**",
                            " * @param {EventBus} eventBus",
                            " * @param {ElementFactory} elementFactory",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function ToggleElementCollapseBehaviour(",
                            "    eventBus, elementFactory, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "",
                            "  function hideEmptyLabels(children) {",
                            "    if (children.length) {",
                            "      children.forEach(function(child) {",
                            "        if (child.type === 'label' && !child.businessObject.name) {",
                            "          child.hidden = true;",
                            "        }",
                            "      });",
                            "    }",
                            "  }",
                            "",
                            "  function expandedBounds(shape, defaultSize) {",
                            "    var children = shape.children,",
                            "        newBounds = defaultSize,",
                            "        visibleElements,",
                            "        visibleBBox;",
                            "",
                            "    visibleElements = filterVisible(children).concat([ shape ]);",
                            "",
                            "    visibleBBox = computeChildrenBBox(visibleElements);",
                            "",
                            "    if (visibleBBox) {",
                            "",
                            "      // center to visibleBBox with max(defaultSize, childrenBounds)",
                            "      newBounds.width = Math.max(visibleBBox.width, newBounds.width);",
                            "      newBounds.height = Math.max(visibleBBox.height, newBounds.height);",
                            "",
                            "      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;",
                            "      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;",
                            "    } else {",
                            "",
                            "      // center to collapsed shape with defaultSize",
                            "      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;",
                            "      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;",
                            "    }",
                            "",
                            "    return newBounds;",
                            "  }",
                            "",
                            "  function collapsedBounds(shape, defaultSize) {",
                            "",
                            "    return {",
                            "      x: shape.x + (shape.width - defaultSize.width) / 2,",
                            "      y: shape.y + (shape.height - defaultSize.height) / 2,",
                            "      width: defaultSize.width,",
                            "      height: defaultSize.height",
                            "    };",
                            "  }",
                            "",
                            "  this.executed([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {",
                            "",
                            "    var context = e.context,",
                            "        shape = context.shape;",
                            "",
                            "    if (!is(shape, 'bpmn:SubProcess')) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (!shape.collapsed) {",
                            "",
                            "      // all children got made visible through djs, hide empty labels",
                            "      hideEmptyLabels(shape.children);",
                            "",
                            "      // remove collapsed marker",
                            "      getDi(shape).isExpanded = true;",
                            "    } else {",
                            "",
                            "      // place collapsed marker",
                            "      getDi(shape).isExpanded = false;",
                            "    }",
                            "  });",
                            "",
                            "  this.reverted([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {",
                            "",
                            "    var context = e.context;",
                            "    var shape = context.shape;",
                            "",
                            "",
                            "    // revert removing/placing collapsed marker",
                            "    if (!shape.collapsed) {",
                            "      getDi(shape).isExpanded = true;",
                            "",
                            "    } else {",
                            "      getDi(shape).isExpanded = false;",
                            "    }",
                            "  });",
                            "",
                            "  this.postExecuted([ 'shape.toggleCollapse' ], LOW_PRIORITY, function(e) {",
                            "    var shape = e.context.shape,",
                            "        defaultSize = elementFactory.getDefaultSize(shape),",
                            "        newBounds;",
                            "",
                            "    if (shape.collapsed) {",
                            "",
                            "      // resize to default size of collapsed shapes",
                            "      newBounds = collapsedBounds(shape, defaultSize);",
                            "    } else {",
                            "",
                            "      // resize to bounds of max(visible children, defaultSize)",
                            "      newBounds = expandedBounds(shape, defaultSize);",
                            "    }",
                            "",
                            "    modeling.resizeShape(shape, newBounds, null, {",
                            "      autoResize: shape.collapsed ? false : 'nwse'",
                            "    });",
                            "  });",
                            "",
                            "}",
                            "",
                            "",
                            "inherits(ToggleElementCollapseBehaviour, CommandInterceptor);",
                            "",
                            "ToggleElementCollapseBehaviour.$inject = [",
                            "  'eventBus',",
                            "  'elementFactory',",
                            "  'modeling'",
                            "];",
                            "",
                            "",
                            "// helpers //////////////////////",
                            "",
                            "function filterVisible(elements) {",
                            "  return elements.filter(function(e) {",
                            "    return !e.hidden;",
                            "  });",
                            "}"
                        ]
                    },
                    "UnclaimIdBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import { is } from '../../../util/ModelUtil';",
                            "import { isExpanded } from '../../../util/DiUtil';",
                            "import { isLabel } from '../../../util/LabelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                            " * @typedef {import('didi').Injector} Injector",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " *",
                            " * @typedef {import('../../../model/Types').Moddle} Moddle",
                            " */",
                            "",
                            "/**",
                            " * Unclaims model IDs on element deletion.",
                            " *",
                            " * @param {Canvas} canvas",
                            " * @param {Injector} injector",
                            " * @param {Moddle} moddle",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function UnclaimIdBehavior(canvas, injector, moddle, modeling) {",
                            "  injector.invoke(CommandInterceptor, this);",
                            "",
                            "  this.preExecute('shape.delete', function(event) {",
                            "    var context = event.context,",
                            "        shape = context.shape,",
                            "        shapeBo = shape.businessObject;",
                            "",
                            "    if (isLabel(shape)) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (is(shape, 'bpmn:Participant') && isExpanded(shape)) {",
                            "      moddle.ids.unclaim(shapeBo.processRef.id);",
                            "    }",
                            "",
                            "    modeling.unclaimId(shapeBo.id, shapeBo);",
                            "  });",
                            "",
                            "",
                            "  this.preExecute('connection.delete', function(event) {",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        connectionBo = connection.businessObject;",
                            "",
                            "    modeling.unclaimId(connectionBo.id, connectionBo);",
                            "  });",
                            "",
                            "  this.preExecute('canvas.updateRoot', function() {",
                            "    var rootElement = canvas.getRootElement(),",
                            "        rootElementBo = rootElement.businessObject;",
                            "",
                            "    if (is(rootElement, 'bpmn:Collaboration')) {",
                            "      moddle.ids.unclaim(rootElementBo.id);",
                            "    }",
                            "  });",
                            "}",
                            "",
                            "inherits(UnclaimIdBehavior, CommandInterceptor);",
                            "",
                            "UnclaimIdBehavior.$inject = [ 'canvas', 'injector', 'moddle', 'modeling' ];"
                        ]
                    },
                    "UnsetDefaultFlowBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  getBusinessObject,",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * A behavior that unsets the Default property of sequence flow source on",
                            " * element delete, if the removed element is the Gateway or Task's default flow.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function DeleteSequenceFlowBehavior(eventBus, modeling) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "",
                            "  this.preExecute('connection.delete', function(event) {",
                            "    var context = event.context,",
                            "        connection = context.connection,",
                            "        source = connection.source;",
                            "",
                            "    if (isDefaultFlow(connection, source)) {",
                            "      modeling.updateProperties(source, {",
                            "        'default': null",
                            "      });",
                            "    }",
                            "  });",
                            "}",
                            "",
                            "inherits(DeleteSequenceFlowBehavior, CommandInterceptor);",
                            "",
                            "DeleteSequenceFlowBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling'",
                            "];",
                            "",
                            "",
                            "// helpers //////////////////////",
                            "",
                            "function isDefaultFlow(connection, source) {",
                            "",
                            "  if (!is(connection, 'bpmn:SequenceFlow')) {",
                            "    return false;",
                            "  }",
                            "",
                            "  var sourceBo = getBusinessObject(source),",
                            "      sequenceFlow = getBusinessObject(connection);",
                            "",
                            "  return sourceBo.get('default') === sequenceFlow;",
                            "}"
                        ]
                    },
                    "UpdateFlowNodeRefsBehavior.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import inherits from 'inherits-browser';",
                            "",
                            "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                            "",
                            "import {",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                            " */",
                            "",
                            "var LOW_PRIORITY = 500,",
                            "    HIGH_PRIORITY = 5000;",
                            "",
                            "",
                            "/**",
                            " * BPMN specific delete lane behavior.",
                            " *",
                            " * @param {EventBus} eventBus",
                            " * @param {Modeling} modeling",
                            " * @param {Translate} translate",
                            " */",
                            "export default function UpdateFlowNodeRefsBehavior(eventBus, modeling, translate) {",
                            "",
                            "  CommandInterceptor.call(this, eventBus);",
                            "",
                            "  /**",
                            "   * Update Lane#flowNodeRefs and FlowNode#lanes with every flow node",
                            "   * move/resize and lane move/resize. Groups elements to recompute containments",
                            "   * as efficient as possible.",
                            "   */",
                            "",
                            "  // the update context",
                            "  var context;",
                            "",
                            "",
                            "  function initContext() {",
                            "    context = context || new UpdateContext();",
                            "    context.enter();",
                            "",
                            "    return context;",
                            "  }",
                            "",
                            "  function getContext() {",
                            "    if (!context) {",
                            "      throw new Error(translate('out of bounds release'));",
                            "    }",
                            "",
                            "    return context;",
                            "  }",
                            "",
                            "  function releaseContext() {",
                            "",
                            "    if (!context) {",
                            "      throw new Error(translate('out of bounds release'));",
                            "    }",
                            "",
                            "    var triggerUpdate = context.leave();",
                            "",
                            "    if (triggerUpdate) {",
                            "      modeling.updateLaneRefs(context.flowNodes, context.lanes);",
                            "",
                            "      context = null;",
                            "    }",
                            "",
                            "    return triggerUpdate;",
                            "  }",
                            "",
                            "",
                            "  var laneRefUpdateEvents = [",
                            "    'spaceTool',",
                            "    'lane.add',",
                            "    'lane.resize',",
                            "    'lane.split',",
                            "    'elements.create',",
                            "    'elements.delete',",
                            "    'elements.move',",
                            "    'shape.create',",
                            "    'shape.delete',",
                            "    'shape.move',",
                            "    'shape.resize'",
                            "  ];",
                            "",
                            "",
                            "  // listen to a lot of stuff to group lane updates",
                            "",
                            "  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY, function(event) {",
                            "    initContext();",
                            "  });",
                            "",
                            "  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY, function(event) {",
                            "    releaseContext();",
                            "  });",
                            "",
                            "",
                            "  // Mark flow nodes + lanes that need an update",
                            "",
                            "  this.preExecute([",
                            "    'shape.create',",
                            "    'shape.move',",
                            "    'shape.delete',",
                            "    'shape.resize'",
                            "  ], function(event) {",
                            "",
                            "    var context = event.context,",
                            "        shape = context.shape;",
                            "",
                            "    var updateContext = getContext();",
                            "",
                            "    // no need to update labels",
                            "    if (shape.labelTarget) {",
                            "      return;",
                            "    }",
                            "",
                            "    if (is(shape, 'bpmn:Lane')) {",
                            "      updateContext.addLane(shape);",
                            "    }",
                            "",
                            "    if (is(shape, 'bpmn:FlowNode')) {",
                            "      updateContext.addFlowNode(shape);",
                            "    }",
                            "  });",
                            "}",
                            "",
                            "UpdateFlowNodeRefsBehavior.$inject = [",
                            "  'eventBus',",
                            "  'modeling' ,",
                            "  'translate'",
                            "];",
                            "",
                            "inherits(UpdateFlowNodeRefsBehavior, CommandInterceptor);",
                            "",
                            "",
                            "function UpdateContext() {",
                            "",
                            "  this.flowNodes = [];",
                            "  this.lanes = [];",
                            "",
                            "  this.counter = 0;",
                            "",
                            "  this.addLane = function(lane) {",
                            "    this.lanes.push(lane);",
                            "  };",
                            "",
                            "  this.addFlowNode = function(flowNode) {",
                            "    this.flowNodes.push(flowNode);",
                            "  };",
                            "",
                            "  this.enter = function() {",
                            "    this.counter++;",
                            "  };",
                            "",
                            "  this.leave = function() {",
                            "    this.counter--;",
                            "",
                            "    return !this.counter;",
                            "  };",
                            "}"
                        ]
                    },
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import AdaptiveLabelPositioningBehavior from './AdaptiveLabelPositioningBehavior';",
                            "import AppendBehavior from './AppendBehavior';",
                            "import AssociationBehavior from './AssociationBehavior';",
                            "import AttachEventBehavior from './AttachEventBehavior';",
                            "import BoundaryEventBehavior from './BoundaryEventBehavior';",
                            "import CreateBehavior from './CreateBehavior';",
                            "import CreateDataObjectBehavior from './CreateDataObjectBehavior';",
                            "import CreateParticipantBehavior from './CreateParticipantBehavior';",
                            "import DataInputAssociationBehavior from './DataInputAssociationBehavior';",
                            "import DataStoreBehavior from './DataStoreBehavior';",
                            "import DeleteLaneBehavior from './DeleteLaneBehavior';",
                            "import DetachEventBehavior from './DetachEventBehavior';",
                            "import DropOnFlowBehavior from './DropOnFlowBehavior';",
                            "import EventBasedGatewayBehavior from './EventBasedGatewayBehavior';",
                            "import FixHoverBehavior from './FixHoverBehavior';",
                            "import GroupBehavior from './GroupBehavior';",
                            "import ImportDockingFix from './ImportDockingFix';",
                            "import IsHorizontalFix from './IsHorizontalFix';",
                            "import LabelBehavior from './LabelBehavior';",
                            "import LayoutConnectionBehavior from './LayoutConnectionBehavior';",
                            "import MessageFlowBehavior from './MessageFlowBehavior';",
                            "import NonInterruptingBehavior from './NonInterruptingBehavior';",
                            "import RemoveEmbeddedLabelBoundsBehavior from './RemoveEmbeddedLabelBoundsBehavior';",
                            "import RemoveElementBehavior from './RemoveElementBehavior';",
                            "import RemoveParticipantBehavior from './RemoveParticipantBehavior';",
                            "import ReplaceConnectionBehavior from './ReplaceConnectionBehavior';",
                            "import ReplaceElementBehaviour from './ReplaceElementBehaviour';",
                            "import ResizeBehavior from './ResizeBehavior';",
                            "import ResizeLaneBehavior from './ResizeLaneBehavior';",
                            "import RootElementReferenceBehavior from './RootElementReferenceBehavior';",
                            "import SpaceToolBehavior from './SpaceToolBehavior';",
                            "import SubProcessPlaneBehavior from './SubProcessPlaneBehavior';",
                            "import SubProcessStartEventBehavior from './SubProcessStartEventBehavior';",
                            "import ToggleCollapseConnectionBehaviour from './ToggleCollapseConnectionBehaviour';",
                            "import ToggleElementCollapseBehaviour from './ToggleElementCollapseBehaviour';",
                            "import UnclaimIdBehavior from './UnclaimIdBehavior';",
                            "import UnsetDefaultFlowBehavior from './UnsetDefaultFlowBehavior';",
                            "import UpdateFlowNodeRefsBehavior from './UpdateFlowNodeRefsBehavior';",
                            "",
                            "/**",
                            " * @type { import('didi').ModuleDeclaration }",
                            " */",
                            "export default {",
                            "  __init__: [",
                            "    'adaptiveLabelPositioningBehavior',",
                            "    'appendBehavior',",
                            "    'associationBehavior',",
                            "    'attachEventBehavior',",
                            "    'boundaryEventBehavior',",
                            "    'createBehavior',",
                            "    'createDataObjectBehavior',",
                            "    'createParticipantBehavior',",
                            "    'dataInputAssociationBehavior',",
                            "    'dataStoreBehavior',",
                            "    'deleteLaneBehavior',",
                            "    'detachEventBehavior',",
                            "    'dropOnFlowBehavior',",
                            "    'eventBasedGatewayBehavior',",
                            "    'fixHoverBehavior',",
                            "    'groupBehavior',",
                            "    'importDockingFix',",
                            "    'isHorizontalFix',",
                            "    'labelBehavior',",
                            "    'layoutConnectionBehavior',",
                            "    'messageFlowBehavior',",
                            "    'nonInterruptingBehavior',",
                            "    'removeElementBehavior',",
                            "    'removeEmbeddedLabelBoundsBehavior',",
                            "    'removeParticipantBehavior',",
                            "    'replaceConnectionBehavior',",
                            "    'replaceElementBehaviour',",
                            "    'resizeBehavior',",
                            "    'resizeLaneBehavior',",
                            "    'rootElementReferenceBehavior',",
                            "    'spaceToolBehavior',",
                            "    'subProcessPlaneBehavior',",
                            "    'subProcessStartEventBehavior',",
                            "    'toggleCollapseConnectionBehaviour',",
                            "    'toggleElementCollapseBehaviour',",
                            "    'unclaimIdBehavior',",
                            "    'updateFlowNodeRefsBehavior',",
                            "    'unsetDefaultFlowBehavior'",
                            "  ],",
                            "  adaptiveLabelPositioningBehavior: [ 'type', AdaptiveLabelPositioningBehavior ],",
                            "  appendBehavior: [ 'type', AppendBehavior ],",
                            "  associationBehavior: [ 'type', AssociationBehavior ],",
                            "  attachEventBehavior: [ 'type', AttachEventBehavior ],",
                            "  boundaryEventBehavior: [ 'type', BoundaryEventBehavior ],",
                            "  createBehavior: [ 'type', CreateBehavior ],",
                            "  createDataObjectBehavior: [ 'type', CreateDataObjectBehavior ],",
                            "  createParticipantBehavior: [ 'type', CreateParticipantBehavior ],",
                            "  dataInputAssociationBehavior: [ 'type', DataInputAssociationBehavior ],",
                            "  dataStoreBehavior: [ 'type', DataStoreBehavior ],",
                            "  deleteLaneBehavior: [ 'type', DeleteLaneBehavior ],",
                            "  detachEventBehavior: [ 'type', DetachEventBehavior ],",
                            "  dropOnFlowBehavior: [ 'type', DropOnFlowBehavior ],",
                            "  eventBasedGatewayBehavior: [ 'type', EventBasedGatewayBehavior ],",
                            "  fixHoverBehavior: [ 'type', FixHoverBehavior ],",
                            "  groupBehavior: [ 'type', GroupBehavior ],",
                            "  importDockingFix: [ 'type', ImportDockingFix ],",
                            "  isHorizontalFix: [ 'type', IsHorizontalFix ],",
                            "  labelBehavior: [ 'type', LabelBehavior ],",
                            "  layoutConnectionBehavior: [ 'type', LayoutConnectionBehavior ],",
                            "  messageFlowBehavior: [ 'type', MessageFlowBehavior ],",
                            "  nonInterruptingBehavior: [ 'type', NonInterruptingBehavior ],",
                            "  removeElementBehavior: [ 'type', RemoveElementBehavior ],",
                            "  removeEmbeddedLabelBoundsBehavior: [ 'type', RemoveEmbeddedLabelBoundsBehavior ],",
                            "  removeParticipantBehavior: [ 'type', RemoveParticipantBehavior ],",
                            "  replaceConnectionBehavior: [ 'type', ReplaceConnectionBehavior ],",
                            "  replaceElementBehaviour: [ 'type', ReplaceElementBehaviour ],",
                            "  resizeBehavior: [ 'type', ResizeBehavior ],",
                            "  resizeLaneBehavior: [ 'type', ResizeLaneBehavior ],",
                            "  rootElementReferenceBehavior: [ 'type', RootElementReferenceBehavior ],",
                            "  spaceToolBehavior: [ 'type', SpaceToolBehavior ],",
                            "  subProcessPlaneBehavior: [ 'type', SubProcessPlaneBehavior ],",
                            "  subProcessStartEventBehavior: [ 'type', SubProcessStartEventBehavior ],",
                            "  toggleCollapseConnectionBehaviour: [ 'type', ToggleCollapseConnectionBehaviour ],",
                            "  toggleElementCollapseBehaviour : [ 'type', ToggleElementCollapseBehaviour ],",
                            "  unclaimIdBehavior: [ 'type', UnclaimIdBehavior ],",
                            "  unsetDefaultFlowBehavior: [ 'type', UnsetDefaultFlowBehavior ],",
                            "  updateFlowNodeRefsBehavior: [ 'type', UpdateFlowNodeRefsBehavior ]",
                            "};"
                        ]
                    },
                    "util": {
                        "CategoryUtil.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "import {",
                                "  add as collectionAdd,",
                                "  remove as collectionRemove",
                                "} from 'diagram-js/lib/util/Collections';",
                                "",
                                "/**",
                                " * @typedef {import('../../BpmnFactory').default} BpmnFactory",
                                " *",
                                " * @typedef {import('../../../model/Types').ModdleElement} ModdleElement",
                                " */",
                                "",
                                "/**",
                                " * Creates a new bpmn:CategoryValue inside a new bpmn:Category",
                                " *",
                                " * @param {BpmnFactory} bpmnFactory",
                                " *",
                                " * @return {ModdleElement}",
                                " */",
                                "export function createCategory(bpmnFactory) {",
                                "  return bpmnFactory.create('bpmn:Category');",
                                "}",
                                "",
                                "/**",
                                " * Creates a new bpmn:CategoryValue inside a new bpmn:Category",
                                " *",
                                " * @param {BpmnFactory} bpmnFactory",
                                " *",
                                " * @return {ModdleElement}",
                                " */",
                                "export function createCategoryValue(bpmnFactory) {",
                                "  return bpmnFactory.create('bpmn:CategoryValue');",
                                "}",
                                "",
                                "/**",
                                " * Adds category value to definitions",
                                " *",
                                " * @param {ModdleElement} categoryValue",
                                " * @param {ModdleElement} category",
                                " * @param {ModdleElement} definitions",
                                " *",
                                " * @return {ModdleElement}",
                                " */",
                                "export function linkCategoryValue(categoryValue, category, definitions) {",
                                "  collectionAdd(category.get('categoryValue'), categoryValue);",
                                "  categoryValue.$parent = category;",
                                "",
                                "  collectionAdd(definitions.get('rootElements'), category);",
                                "  category.$parent = definitions;",
                                "",
                                "  return categoryValue;",
                                "}",
                                "",
                                "/**",
                                " * Unlink category value from parent",
                                " *",
                                " * @param {ModdleElement} categoryValue",
                                " *",
                                " * @return {ModdleElement}",
                                " */",
                                "export function unlinkCategoryValue(categoryValue) {",
                                "  var category = categoryValue.$parent;",
                                "",
                                "  if (category) {",
                                "    collectionRemove(category.get('categoryValue'), categoryValue);",
                                "    categoryValue.$parent = null;",
                                "  }",
                                "",
                                "  return categoryValue;",
                                "}",
                                "",
                                "/**",
                                " * Unlink category from parent",
                                " *",
                                " * @param {ModdleElement} category",
                                " *",
                                " * @return {ModdleElement}",
                                " */",
                                "export function unlinkCategory(category) {",
                                "  var definitions = category.$parent;",
                                "",
                                "  if (definitions) {",
                                "    collectionRemove(definitions.get('rootElements'), category);",
                                "    category.$parent = null;",
                                "  }",
                                "",
                                "  return category;",
                                "}"
                            ]
                        },
                        "ConnectionLayoutUtil.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "import { getAnchorPointAdjustment } from './LayoutUtil';",
                                "",
                                "/**",
                                " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                                " *",
                                " * @typedef {import('./LayoutUtil').FindNewLineStartIndexHints} FindNewLineStartIndexHints",
                                " */",
                                "",
                                "/**",
                                " * Calculate the new point after the connection waypoints got updated.",
                                " *",
                                " * @param {Point} position",
                                " * @param {Point[]} newWaypoints",
                                " * @param {Point[]} oldWaypoints",
                                " * @param {FindNewLineStartIndexHints} hints",
                                " *",
                                " * @return {Point}",
                                " */",
                                "export function getConnectionAdjustment(position, newWaypoints, oldWaypoints, hints) {",
                                "  return getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints).point;",
                                "}",
                                ""
                            ]
                        },
                        "GeometricUtil.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "export * from 'diagram-js/lib/features/bendpoints/GeometricUtil';"
                            ]
                        },
                        "LabelLayoutUtil.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "import { findNewLineStartIndex, getAnchorPointAdjustment } from './LayoutUtil';",
                                "",
                                "import { getMid } from 'diagram-js/lib/layout/LayoutUtil';",
                                "",
                                "/**",
                                " * @typedef {import('./LineAttachmentUtil').Attachment} Attachment",
                                " *",
                                " * @typedef {import('./LayoutUtil').FindNewLineStartIndexHints} FindNewLineStartIndexHints",
                                " *",
                                " * @typedef {import('../../../../model/Types').Label} Label",
                                " *",
                                " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                                " */",
                                "",
                                "/**",
                                " * @param {Point[]} oldWaypoints",
                                " * @param {Point[]} newWaypoints",
                                " * @param {Attachment} attachment",
                                " * @param {FindNewLineStartIndexHints} hints",
                                " *",
                                " * @return {number}",
                                " */",
                                "export function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {",
                                "  return findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);",
                                "}",
                                "",
                                "/**",
                                " * Calculate the required adjustment (move delta) for the given label",
                                " * after the connection waypoints got updated.",
                                " *",
                                " * @param {Label} label",
                                " * @param {Point[]} newWaypoints",
                                " * @param {Point[]} oldWaypoints",
                                " * @param {FindNewLineStartIndexHints} hints",
                                " *",
                                " * @return {Point}",
                                " */",
                                "export function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {",
                                "  var labelPosition = getMid(label);",
                                "",
                                "  return getAnchorPointAdjustment(labelPosition, newWaypoints, oldWaypoints, hints).delta;",
                                "}"
                            ]
                        },
                        "LayoutUtil.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "import {",
                                "  getDistancePointPoint,",
                                "  rotateVector,",
                                "  getAngle",
                                "} from './GeometricUtil';",
                                "",
                                "import {",
                                "  getAttachment",
                                "} from './LineAttachmentUtil';",
                                "",
                                "import {",
                                "  roundPoint",
                                "} from 'diagram-js/lib/layout/LayoutUtil';",
                                "",
                                "/**",
                                " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                                " *",
                                " * @typedef {import('./LineAttachmentUtil').Attachment} Attachment",
                                " *",
                                " * @typedef { {",
                                " *   point: Point;",
                                " *   delta: Point;",
                                " * } } AnchorPointAdjustment",
                                " *",
                                " * @typedef { {",
                                " *   segmentMove?: {",
                                "*     segmentStartIndex: number;",
                                "*     newSegmentStartIndex: number;",
                                "*   };",
                                "*   bendpointMove?: {",
                                "*     insert: boolean;",
                                "*     bendpointIndex: number;",
                                "*   };",
                                "*   connectionStart: boolean;",
                                "*   connectionEnd: boolean;",
                                "* } } FindNewLineStartIndexHints",
                                " */",
                                "",
                                "/**",
                                " * @param {Point[]} oldWaypoints",
                                " * @param {Point[]} newWaypoints",
                                " * @param {Attachment} attachment",
                                " * @param {FindNewLineStartIndexHints} hints",
                                " *",
                                " * @return {number}",
                                " */",
                                "export function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {",
                                "",
                                "  var index = attachment.segmentIndex;",
                                "",
                                "  var offset = newWaypoints.length - oldWaypoints.length;",
                                "",
                                "  // segmentMove happened",
                                "  if (hints.segmentMove) {",
                                "",
                                "    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,",
                                "        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;",
                                "",
                                "    // if point was on moved segment return new segment index",
                                "    if (index === oldSegmentStartIndex) {",
                                "      return newSegmentStartIndex;",
                                "    }",
                                "",
                                "    // point is after new segment index",
                                "    if (index >= newSegmentStartIndex) {",
                                "      return (index + offset < newSegmentStartIndex) ? newSegmentStartIndex : index + offset;",
                                "    }",
                                "",
                                "    // if point is before new segment index",
                                "    return index;",
                                "  }",
                                "",
                                "  // bendpointMove happened",
                                "  if (hints.bendpointMove) {",
                                "",
                                "    var insert = hints.bendpointMove.insert,",
                                "        bendpointIndex = hints.bendpointMove.bendpointIndex,",
                                "        newIndex;",
                                "",
                                "    // waypoints length didnt change",
                                "    if (offset === 0) {",
                                "      return index;",
                                "    }",
                                "",
                                "    // point behind new/removed bendpoint",
                                "    if (index >= bendpointIndex) {",
                                "      newIndex = insert ? index + 1 : index - 1;",
                                "    }",
                                "",
                                "    // point before new/removed bendpoint",
                                "    if (index < bendpointIndex) {",
                                "",
                                "      newIndex = index;",
                                "",
                                "      // decide point should take right or left segment",
                                "      if (insert && attachment.type !== 'bendpoint' && bendpointIndex - 1 === index) {",
                                "",
                                "        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);",
                                "",
                                "        if (rel < attachment.relativeLocation) {",
                                "          newIndex++;",
                                "        }",
                                "      }",
                                "    }",
                                "",
                                "    return newIndex;",
                                "  }",
                                "",
                                "  // start/end changed",
                                "  if (offset === 0) {",
                                "    return index;",
                                "  }",
                                "",
                                "  if (hints.connectionStart && index === 0) {",
                                "    return 0;",
                                "  }",
                                "",
                                "  if (hints.connectionEnd && index === oldWaypoints.length - 2) {",
                                "    return newWaypoints.length - 2;",
                                "  }",
                                "",
                                "  // if nothing fits, take the middle segment",
                                "  return Math.floor((newWaypoints.length - 2) / 2);",
                                "}",
                                "",
                                "",
                                "/**",
                                " * Calculate the required adjustment (move delta) for the given point",
                                " * after the connection waypoints got updated.",
                                " *",
                                " * @param {Point} position",
                                " * @param {Point[]} newWaypoints",
                                " * @param {Point[]} oldWaypoints",
                                " * @param {FindNewLineStartIndexHints} hints",
                                " *",
                                " * @return {AnchorPointAdjustment} result",
                                " */",
                                "export function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {",
                                "",
                                "  var dx = 0,",
                                "      dy = 0;",
                                "",
                                "  var oldPosition = {",
                                "    point: position,",
                                "    delta: { x: 0, y: 0 }",
                                "  };",
                                "",
                                "  // get closest attachment",
                                "  var attachment = getAttachment(position, oldWaypoints),",
                                "      oldLabelLineIndex = attachment.segmentIndex,",
                                "      newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);",
                                "",
                                "",
                                "  // should never happen",
                                "  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored",
                                "  if (newLabelLineIndex < 0 ||",
                                "      newLabelLineIndex > newWaypoints.length - 2 ||",
                                "      newLabelLineIndex === null) {",
                                "    return oldPosition;",
                                "  }",
                                "",
                                "  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),",
                                "      newLabelLine = getLine(newWaypoints, newLabelLineIndex),",
                                "      oldFoot = attachment.position;",
                                "",
                                "  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),",
                                "      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);",
                                "",
                                "  // special rule if label on bendpoint",
                                "  if (attachment.type === 'bendpoint') {",
                                "",
                                "    var offset = newWaypoints.length - oldWaypoints.length,",
                                "        oldBendpointIndex = attachment.bendpointIndex,",
                                "        oldBendpoint = oldWaypoints[oldBendpointIndex];",
                                "",
                                "    // bendpoint position hasn't changed, return same position",
                                "    if (newWaypoints.indexOf(oldBendpoint) !== -1) {",
                                "      return oldPosition;",
                                "    }",
                                "",
                                "    // new bendpoint and old bendpoint have same index, then just return the offset",
                                "    if (offset === 0) {",
                                "      var newBendpoint = newWaypoints[oldBendpointIndex];",
                                "",
                                "      dx = newBendpoint.x - attachment.position.x,",
                                "      dy = newBendpoint.y - attachment.position.y;",
                                "",
                                "      return {",
                                "        delta: {",
                                "          x: dx,",
                                "          y: dy",
                                "        },",
                                "        point: {",
                                "          x: position.x + dx,",
                                "          y: position.y + dy",
                                "        }",
                                "      };",
                                "    }",
                                "",
                                "    // if bendpoints get removed",
                                "    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {",
                                "      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);",
                                "    }",
                                "  }",
                                "",
                                "  var newFoot = {",
                                "    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,",
                                "    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y",
                                "  };",
                                "",
                                "  // the rotated vector to label",
                                "  var newLabelVector = rotateVector({",
                                "    x: position.x - oldFoot.x,",
                                "    y: position.y - oldFoot.y",
                                "  }, angleDelta);",
                                "",
                                "  // the new relative position",
                                "  dx = newFoot.x + newLabelVector.x - position.x;",
                                "  dy = newFoot.y + newLabelVector.y - position.y;",
                                "",
                                "  return {",
                                "    point: roundPoint(newFoot),",
                                "    delta: roundPoint({",
                                "      x: dx,",
                                "      y: dy",
                                "    })",
                                "  };",
                                "}",
                                "",
                                "",
                                "// HELPERS //////////////////////",
                                "",
                                "function relativePositionMidWaypoint(waypoints, idx) {",
                                "",
                                "  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]),",
                                "      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);",
                                "",
                                "  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);",
                                "",
                                "  return relativePosition;",
                                "}",
                                "",
                                "function getAngleDelta(l1, l2) {",
                                "  var a1 = getAngle(l1),",
                                "      a2 = getAngle(l2);",
                                "  return a2 - a1;",
                                "}",
                                "",
                                "function getLine(waypoints, idx) {",
                                "  return [ waypoints[idx], waypoints[idx + 1] ];",
                                "}",
                                "",
                                "function getRelativeFootPosition(line, foot) {",
                                "",
                                "  var length = getDistancePointPoint(line[0], line[1]),",
                                "      lengthToFoot = getDistancePointPoint(line[0], foot);",
                                "",
                                "  return length === 0 ? 0 : lengthToFoot / length;",
                                "}"
                            ]
                        },
                        "LineAttachmentUtil.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "/**",
                                " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                                " *",
                                " * @typedef { {",
                                "*   type: 'bendpoint' | 'segment';",
                                "*   position: Point;",
                                "*   segmentIndex: number;",
                                "*   bendpointIndex?: number;",
                                "*   relativeLocation?: number;",
                                "* } } Attachment",
                                "*/",
                                "",
                                "var sqrt = Math.sqrt,",
                                "    min = Math.min,",
                                "    max = Math.max,",
                                "    abs = Math.abs;",
                                "",
                                "/**",
                                " * Calculate the square (power to two) of a number.",
                                " *",
                                " * @param {number} n",
                                " *",
                                " * @return {number}",
                                " */",
                                "function sq(n) {",
                                "  return Math.pow(n, 2);",
                                "}",
                                "",
                                "/**",
                                " * Get distance between two points.",
                                " *",
                                " * @param {Point} p1",
                                " * @param {Point} p2",
                                " *",
                                " * @return {number}",
                                " */",
                                "function getDistance(p1, p2) {",
                                "  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));",
                                "}",
                                "",
                                "/**",
                                " * Return the attachment of the given point on the specified line.",
                                " *",
                                " * The attachment is either a bendpoint (attached to the given point)",
                                " * or segment (attached to a location on a line segment) attachment:",
                                " *",
                                " * ```javascript",
                                " * var pointAttachment = {",
                                " *   type: 'bendpoint',",
                                " *   bendpointIndex: 3,",
                                " *   position: { x: 10, y: 10 } // the attach point on the line",
                                " * };",
                                " *",
                                " * var segmentAttachment = {",
                                " *   type: 'segment',",
                                " *   segmentIndex: 2,",
                                " *   relativeLocation: 0.31, // attach point location between 0 (at start) and 1 (at end)",
                                " *   position: { x: 10, y: 10 } // the attach point on the line",
                                " * };",
                                " * ```",
                                " *",
                                " * @param {Point} point",
                                " * @param {Point[]} line",
                                " *",
                                " * @return {Attachment}",
                                " */",
                                "export function getAttachment(point, line) {",
                                "",
                                "  var idx = 0,",
                                "      segmentStart,",
                                "      segmentEnd,",
                                "      segmentStartDistance,",
                                "      segmentEndDistance,",
                                "      attachmentPosition,",
                                "      minDistance,",
                                "      intersections,",
                                "      attachment,",
                                "      attachmentDistance,",
                                "      closestAttachmentDistance,",
                                "      closestAttachment;",
                                "",
                                "  for (idx = 0; idx < line.length - 1; idx++) {",
                                "",
                                "    segmentStart = line[idx];",
                                "    segmentEnd = line[idx + 1];",
                                "",
                                "    if (pointsEqual(segmentStart, segmentEnd)) {",
                                "      intersections = [ segmentStart ];",
                                "    } else {",
                                "      segmentStartDistance = getDistance(point, segmentStart);",
                                "      segmentEndDistance = getDistance(point, segmentEnd);",
                                "",
                                "      minDistance = min(segmentStartDistance, segmentEndDistance);",
                                "",
                                "      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);",
                                "    }",
                                "",
                                "    if (intersections.length < 1) {",
                                "      throw new Error('expected between [1, 2] circle -> line intersections');",
                                "    }",
                                "",
                                "    // one intersection -> bendpoint attachment",
                                "    if (intersections.length === 1) {",
                                "      attachment = {",
                                "        type: 'bendpoint',",
                                "        position: intersections[0],",
                                "        segmentIndex: idx,",
                                "        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1",
                                "      };",
                                "    }",
                                "",
                                "    // two intersections -> segment attachment",
                                "    if (intersections.length === 2) {",
                                "",
                                "      attachmentPosition = mid(intersections[0], intersections[1]);",
                                "",
                                "      attachment = {",
                                "        type: 'segment',",
                                "        position: attachmentPosition,",
                                "        segmentIndex: idx,",
                                "        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)",
                                "      };",
                                "    }",
                                "",
                                "    attachmentDistance = getDistance(attachment.position, point);",
                                "",
                                "    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {",
                                "      closestAttachment = attachment;",
                                "      closestAttachmentDistance = attachmentDistance;",
                                "    }",
                                "  }",
                                "",
                                "  return closestAttachment;",
                                "}",
                                "",
                                "/**",
                                " * Get the intersection between a circle and a line segment.",
                                " *",
                                " * @param {Point} s1 segment start",
                                " * @param {Point} s2 segment end",
                                " * @param {Point} cc circle center",
                                " * @param {number} cr circle radius",
                                " *",
                                " * @return {Point[]} intersections",
                                " */",
                                "function getCircleSegmentIntersections(s1, s2, cc, cr) {",
                                "",
                                "  var baX = s2.x - s1.x;",
                                "  var baY = s2.y - s1.y;",
                                "  var caX = cc.x - s1.x;",
                                "  var caY = cc.y - s1.y;",
                                "",
                                "  var a = baX * baX + baY * baY;",
                                "  var bBy2 = baX * caX + baY * caY;",
                                "  var c = caX * caX + caY * caY - cr * cr;",
                                "",
                                "  var pBy2 = bBy2 / a;",
                                "  var q = c / a;",
                                "",
                                "  var disc = pBy2 * pBy2 - q;",
                                "",
                                "  // check against negative value to work around",
                                "  // negative, very close to zero results (-4e-15)",
                                "  // being produced in some environments",
                                "  if (disc < 0 && disc > -0.000001) {",
                                "    disc = 0;",
                                "  }",
                                "",
                                "  if (disc < 0) {",
                                "    return [];",
                                "  }",
                                "",
                                "  // if disc == 0 ... dealt with later",
                                "  var tmpSqrt = sqrt(disc);",
                                "  var abScalingFactor1 = -pBy2 + tmpSqrt;",
                                "  var abScalingFactor2 = -pBy2 - tmpSqrt;",
                                "",
                                "  var i1 = {",
                                "    x: s1.x - baX * abScalingFactor1,",
                                "    y: s1.y - baY * abScalingFactor1",
                                "  };",
                                "",
                                "  if (disc === 0) { // abScalingFactor1 == abScalingFactor2",
                                "    return [ i1 ];",
                                "  }",
                                "",
                                "  var i2 = {",
                                "    x: s1.x - baX * abScalingFactor2,",
                                "    y: s1.y - baY * abScalingFactor2",
                                "  };",
                                "",
                                "  // return only points on line segment",
                                "  return [ i1, i2 ].filter(function(p) {",
                                "    return isPointInSegment(p, s1, s2);",
                                "  });",
                                "}",
                                "",
                                "",
                                "function isPointInSegment(p, segmentStart, segmentEnd) {",
                                "  return (",
                                "    fenced(p.x, segmentStart.x, segmentEnd.x) &&",
                                "    fenced(p.y, segmentStart.y, segmentEnd.y)",
                                "  );",
                                "}",
                                "",
                                "function fenced(n, rangeStart, rangeEnd) {",
                                "",
                                "  // use matching threshold to work around",
                                "  // precision errors in intersection computation",
                                "",
                                "  return (",
                                "    n >= min(rangeStart, rangeEnd) - EQUAL_THRESHOLD &&",
                                "    n <= max(rangeStart, rangeEnd) + EQUAL_THRESHOLD",
                                "  );",
                                "}",
                                "",
                                "/**",
                                " * Calculate the mid between two points.",
                                " *",
                                " * @param {Point} p1",
                                " * @param {Point} p2",
                                " *",
                                " * @return {Point}",
                                " */",
                                "function mid(p1, p2) {",
                                "",
                                "  return {",
                                "    x: (p1.x + p2.x) / 2,",
                                "    y: (p1.y + p2.y) / 2",
                                "  };",
                                "}",
                                "",
                                "var EQUAL_THRESHOLD = 0.1;",
                                "",
                                "function pointsEqual(p1, p2) {",
                                "",
                                "  return (",
                                "    abs(p1.x - p2.x) <= EQUAL_THRESHOLD &&",
                                "    abs(p1.y - p2.y) <= EQUAL_THRESHOLD",
                                "  );",
                                "}"
                            ]
                        },
                        "LineIntersect.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "/**",
                                " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                                " */",
                                "",
                                "/**",
                                " * Returns the intersection between two line segments a and b.",
                                " *",
                                " * @param {Point} l1s",
                                " * @param {Point} l1e",
                                " * @param {Point} l2s",
                                " * @param {Point} l2e",
                                " *",
                                " * @return {Point}",
                                " */",
                                "export default function lineIntersect(l1s, l1e, l2s, l2e) {",
                                "",
                                "  // if the lines intersect, the result contains the x and y of the",
                                "  // intersection (treating the lines as infinite) and booleans for",
                                "  // whether line segment 1 or line segment 2 contain the point",
                                "  var denominator, a, b, c, numerator;",
                                "",
                                "  denominator = ((l2e.y - l2s.y) * (l1e.x - l1s.x)) - ((l2e.x - l2s.x) * (l1e.y - l1s.y));",
                                "",
                                "  if (denominator == 0) {",
                                "    return null;",
                                "  }",
                                "",
                                "  a = l1s.y - l2s.y;",
                                "  b = l1s.x - l2s.x;",
                                "  numerator = ((l2e.x - l2s.x) * a) - ((l2e.y - l2s.y) * b);",
                                "",
                                "  c = numerator / denominator;",
                                "",
                                "  // if we cast these lines infinitely in",
                                "  // both directions, they intersect here",
                                "  return {",
                                "    x: Math.round(l1s.x + (c * (l1e.x - l1s.x))),",
                                "    y: Math.round(l1s.y + (c * (l1e.y - l1s.y)))",
                                "  };",
                                "}"
                            ]
                        },
                        "NonInterruptingUtil.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "import { isEventSubProcess } from '../../../../util/DiUtil';",
                                "import { getBusinessObject, is } from '../../../../util/ModelUtil';",
                                "",
                                "export const NON_INTERRUPTING_EVENT_TYPES = [",
                                "  'bpmn:MessageEventDefinition',",
                                "  'bpmn:TimerEventDefinition',",
                                "  'bpmn:EscalationEventDefinition',",
                                "  'bpmn:ConditionalEventDefinition',",
                                "  'bpmn:SignalEventDefinition'",
                                "];",
                                "",
                                "export function canBeNonInterrupting(shape) {",
                                "",
                                "  const businessObject = getBusinessObject(shape);",
                                "",
                                "  if (",
                                "    !is(businessObject, 'bpmn:BoundaryEvent') &&",
                                "    !(is(businessObject, 'bpmn:StartEvent') && isEventSubProcess(businessObject.$parent))",
                                "  ) {",
                                "    return false;",
                                "  }",
                                "",
                                "  const eventDefinitions = businessObject.get('eventDefinitions');",
                                "  if (!eventDefinitions || !eventDefinitions.length) {",
                                "    return false;",
                                "  }",
                                "",
                                "  return NON_INTERRUPTING_EVENT_TYPES.some(event => is(eventDefinitions[0], event));",
                                "}",
                                "",
                                "export function getInterruptingProperty(shape) {",
                                "  return is(shape, 'bpmn:BoundaryEvent') ? 'cancelActivity' : 'isInterrupting';",
                                "}"
                            ]
                        },
                        "ResizeUtil.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "export { getParticipantResizeConstraints } from '../ResizeBehavior';"
                            ]
                        }
                    }
                },
                "cmd": {
                    "AddLaneHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  filter",
                            "} from 'min-dash';",
                            "",
                            "import {",
                            "  eachElement",
                            "} from 'diagram-js/lib/util/Elements';",
                            "",
                            "import {",
                            "  getLanesRoot,",
                            "  getChildLanes,",
                            "  LANE_INDENTATION",
                            "} from '../util/LaneUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('../../space-tool/BpmnSpaceTool').default} SpaceTool",
                            " */",
                            "",
                            "/**",
                            " * A handler that allows us to add a new lane",
                            " * above or below an existing one.",
                            " *",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {Modeling} modeling",
                            " * @param {SpaceTool} spaceTool",
                            " */",
                            "export default function AddLaneHandler(modeling, spaceTool) {",
                            "  this._modeling = modeling;",
                            "  this._spaceTool = spaceTool;",
                            "}",
                            "",
                            "AddLaneHandler.$inject = [",
                            "  'modeling',",
                            "  'spaceTool'",
                            "];",
                            "",
                            "",
                            "AddLaneHandler.prototype.preExecute = function(context) {",
                            "",
                            "  var spaceTool = this._spaceTool,",
                            "      modeling = this._modeling;",
                            "",
                            "  var shape = context.shape,",
                            "      location = context.location;",
                            "",
                            "  var lanesRoot = getLanesRoot(shape);",
                            "",
                            "  var isRoot = lanesRoot === shape,",
                            "      laneParent = isRoot ? shape : shape.parent;",
                            "",
                            "  var existingChildLanes = getChildLanes(laneParent);",
                            "",
                            "  // (0) add a lane if we currently got none and are adding to root",
                            "  if (!existingChildLanes.length) {",
                            "    modeling.createShape({ type: 'bpmn:Lane' }, {",
                            "      x: shape.x + LANE_INDENTATION,",
                            "      y: shape.y,",
                            "      width: shape.width - LANE_INDENTATION,",
                            "      height: shape.height",
                            "    }, laneParent);",
                            "  }",
                            "",
                            "  // (1) collect affected elements to create necessary space",
                            "  var allAffected = [];",
                            "",
                            "  eachElement(lanesRoot, function(element) {",
                            "    allAffected.push(element);",
                            "",
                            "    // handle element labels in the diagram root",
                            "    if (element.label) {",
                            "      allAffected.push(element.label);",
                            "    }",
                            "",
                            "    if (element === shape) {",
                            "      return [];",
                            "    }",
                            "",
                            "    return filter(element.children, function(c) {",
                            "      return c !== shape;",
                            "    });",
                            "  });",
                            "",
                            "  var offset = location === 'top' ? -120 : 120,",
                            "      lanePosition = location === 'top' ? shape.y : shape.y + shape.height,",
                            "      spacePos = lanePosition + (location === 'top' ? 10 : -10),",
                            "      direction = location === 'top' ? 'n' : 's';",
                            "",
                            "  var adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);",
                            "",
                            "  spaceTool.makeSpace(",
                            "    adjustments.movingShapes,",
                            "    adjustments.resizingShapes,",
                            "    { x: 0, y: offset },",
                            "    direction,",
                            "    spacePos",
                            "  );",
                            "",
                            "  // (2) create new lane at open space",
                            "  context.newLane = modeling.createShape({ type: 'bpmn:Lane' }, {",
                            "    x: shape.x + (isRoot ? LANE_INDENTATION : 0),",
                            "    y: lanePosition - (location === 'top' ? 120 : 0),",
                            "    width: shape.width - (isRoot ? LANE_INDENTATION : 0),",
                            "    height: 120",
                            "  }, laneParent);",
                            "};"
                        ]
                    },
                    "IdClaimHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('../../../model/Types').Moddle} Moddle",
                            " */",
                            "",
                            "/**",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {Moddle} moddle",
                            " */",
                            "export default function IdClaimHandler(moddle) {",
                            "  this._moddle = moddle;",
                            "}",
                            "",
                            "IdClaimHandler.$inject = [ 'moddle' ];",
                            "",
                            "",
                            "IdClaimHandler.prototype.execute = function(context) {",
                            "  var ids = this._moddle.ids,",
                            "      id = context.id,",
                            "      element = context.element,",
                            "      claiming = context.claiming;",
                            "",
                            "  if (claiming) {",
                            "    ids.claim(id, element);",
                            "  } else {",
                            "    ids.unclaim(id);",
                            "  }",
                            "",
                            "  return [];",
                            "};",
                            "",
                            "/**",
                            " * Command revert implementation.",
                            " */",
                            "IdClaimHandler.prototype.revert = function(context) {",
                            "  var ids = this._moddle.ids,",
                            "      id = context.id,",
                            "      element = context.element,",
                            "      claiming = context.claiming;",
                            "",
                            "  if (claiming) {",
                            "    ids.unclaim(id);",
                            "  } else {",
                            "    ids.claim(id, element);",
                            "  }",
                            "",
                            "  return [];",
                            "};",
                            ""
                        ]
                    },
                    "ResizeLaneHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  getLanesRoot,",
                            "  computeLanesResize",
                            "} from '../util/LaneUtil';",
                            "",
                            "import {",
                            "  eachElement",
                            "} from 'diagram-js/lib/util/Elements';",
                            "",
                            "import {",
                            "  asTRBL",
                            "} from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import {",
                            "  substractTRBL",
                            "} from 'diagram-js/lib/features/resize/ResizeUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('../../space-tool/BpmnSpaceTool').default} SpaceTool",
                            " *",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                            " */",
                            "",
                            "/**",
                            " * A handler that resizes a lane.",
                            " *",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {Modeling} modeling",
                            " * @param {SpaceTool} spaceTool",
                            " */",
                            "export default function ResizeLaneHandler(modeling, spaceTool) {",
                            "  this._modeling = modeling;",
                            "  this._spaceTool = spaceTool;",
                            "}",
                            "",
                            "ResizeLaneHandler.$inject = [",
                            "  'modeling',",
                            "  'spaceTool'",
                            "];",
                            "",
                            "",
                            "ResizeLaneHandler.prototype.preExecute = function(context) {",
                            "",
                            "  var shape = context.shape,",
                            "      newBounds = context.newBounds,",
                            "      balanced = context.balanced;",
                            "",
                            "  if (balanced !== false) {",
                            "    this.resizeBalanced(shape, newBounds);",
                            "  } else {",
                            "    this.resizeSpace(shape, newBounds);",
                            "  }",
                            "};",
                            "",
                            "",
                            "/**",
                            " * Resize balanced, adjusting next / previous lane sizes.",
                            " *",
                            " * @param {Shape} shape",
                            " * @param {Rect} newBounds",
                            " */",
                            "ResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {",
                            "",
                            "  var modeling = this._modeling;",
                            "",
                            "  var resizeNeeded = computeLanesResize(shape, newBounds);",
                            "",
                            "  // resize the lane",
                            "  modeling.resizeShape(shape, newBounds);",
                            "",
                            "  // resize other lanes as needed",
                            "  resizeNeeded.forEach(function(r) {",
                            "    modeling.resizeShape(r.shape, r.newBounds);",
                            "  });",
                            "};",
                            "",
                            "",
                            "/**",
                            " * Resize, making actual space and moving below / above elements.",
                            " *",
                            " * @param {Shape} shape",
                            " * @param {Rect} newBounds",
                            " */",
                            "ResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {",
                            "  var spaceTool = this._spaceTool;",
                            "",
                            "  var shapeTrbl = asTRBL(shape),",
                            "      newTrbl = asTRBL(newBounds);",
                            "",
                            "  var trblDiff = substractTRBL(newTrbl, shapeTrbl);",
                            "",
                            "  var lanesRoot = getLanesRoot(shape);",
                            "",
                            "  var allAffected = [],",
                            "      allLanes = [];",
                            "",
                            "  eachElement(lanesRoot, function(element) {",
                            "    allAffected.push(element);",
                            "",
                            "    if (is(element, 'bpmn:Lane') || is(element, 'bpmn:Participant')) {",
                            "      allLanes.push(element);",
                            "    }",
                            "",
                            "    return element.children;",
                            "  });",
                            "",
                            "  var change,",
                            "      spacePos,",
                            "      direction,",
                            "      offset,",
                            "      adjustments;",
                            "",
                            "  if (trblDiff.bottom || trblDiff.top) {",
                            "",
                            "    change = trblDiff.bottom || trblDiff.top;",
                            "    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);",
                            "    direction = trblDiff.bottom ? 's' : 'n';",
                            "",
                            "    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;",
                            "",
                            "    adjustments = spaceTool.calculateAdjustments(allAffected, 'y', offset, spacePos);",
                            "",
                            "    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);",
                            "  }",
                            "",
                            "",
                            "  if (trblDiff.left || trblDiff.right) {",
                            "",
                            "    change = trblDiff.right || trblDiff.left;",
                            "    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);",
                            "    direction = trblDiff.right ? 'e' : 'w';",
                            "",
                            "    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;",
                            "",
                            "    adjustments = spaceTool.calculateAdjustments(allLanes, 'x', offset, spacePos);",
                            "",
                            "    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);",
                            "  }",
                            "};"
                        ]
                    },
                    "SetColorHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  assign,",
                            "  forEach,",
                            "  isString,",
                            "  pick",
                            "} from 'min-dash';",
                            "",
                            "import {",
                            "  getDi,",
                            "  isAny",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  isLabel",
                            "} from '../../../util/LabelUtil';",
                            "",
                            "import { isConnection } from 'diagram-js/lib/util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('diagram-js/lib/command/CommandStack').default} CommandStack",
                            " *",
                            " * @typedef {import('../../../model/Types').ModdleElement} ModdleElement",
                            " */",
                            "",
                            "var DEFAULT_COLORS = {",
                            "  fill: undefined,",
                            "  stroke: undefined",
                            "};",
                            "",
                            "/**",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {CommandStack} commandStack",
                            " */",
                            "export default function SetColorHandler(commandStack) {",
                            "  this._commandStack = commandStack;",
                            "",
                            "  this._normalizeColor = function(color) {",
                            "",
                            "    // Remove color for falsy values.",
                            "    if (!color) {",
                            "      return undefined;",
                            "    }",
                            "",
                            "    if (isString(color)) {",
                            "      var hexColor = colorToHex(color);",
                            "",
                            "      if (hexColor) {",
                            "        return hexColor;",
                            "      }",
                            "    }",
                            "",
                            "    throw new Error('invalid color value: ' + color);",
                            "  };",
                            "}",
                            "",
                            "SetColorHandler.$inject = [",
                            "  'commandStack'",
                            "];",
                            "",
                            "",
                            "SetColorHandler.prototype.postExecute = function(context) {",
                            "  var elements = context.elements,",
                            "      colors = context.colors || DEFAULT_COLORS;",
                            "",
                            "  var self = this;",
                            "",
                            "  var di = {};",
                            "",
                            "  if ('fill' in colors) {",
                            "    assign(di, {",
                            "      'background-color': this._normalizeColor(colors.fill) });",
                            "  }",
                            "",
                            "  if ('stroke' in colors) {",
                            "    assign(di, {",
                            "      'border-color': this._normalizeColor(colors.stroke) });",
                            "  }",
                            "",
                            "  forEach(elements, function(element) {",
                            "    var assignedDi = isConnection(element) ? pick(di, [ 'border-color' ]) : di,",
                            "        elementDi = getDi(element);",
                            "",
                            "    // TODO @barmac: remove once we drop bpmn.io properties",
                            "    ensureLegacySupport(assignedDi);",
                            "",
                            "    if (isLabel(element)) {",
                            "",
                            "      // set label colors as bpmndi:BPMNLabel#color",
                            "      self._commandStack.execute('element.updateModdleProperties', {",
                            "        element: element,",
                            "        moddleElement: elementDi.label,",
                            "        properties: {",
                            "          color: di['border-color']",
                            "        }",
                            "      });",
                            "    } else {",
                            "",
                            "      // ignore non-compliant di",
                            "      if (!isAny(elementDi, [ 'bpmndi:BPMNEdge', 'bpmndi:BPMNShape' ])) {",
                            "        return;",
                            "      }",
                            "",
                            "      // set colors bpmndi:BPMNEdge or bpmndi:BPMNShape",
                            "      self._commandStack.execute('element.updateProperties', {",
                            "        element: element,",
                            "        properties: {",
                            "          di: assignedDi",
                            "        }",
                            "      });",
                            "    }",
                            "  });",
                            "",
                            "};",
                            "",
                            "/**",
                            " * Convert color from rgb(a)/hsl to hex. Returns `null` for unknown color names",
                            " * and for colors with alpha less than 1.0. This depends on `<canvas>`",
                            " * serialization of the `context.fillStyle`.",
                            " * Cf. https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-fillstyle",
                            " *",
                            " * @example",
                            " *",
                            " * ```javascript",
                            " * colorToHex('fuchsia'); // \"#ff00ff\"",
                            " *",
                            " * colorToHex('rgba(1, 2, 3, 0.4)'); // null",
                            " * ```",
                            " *",
                            " * @param {string} color",
                            " *",
                            " * @return {string|null}",
                            " */",
                            "function colorToHex(color) {",
                            "  var context = document.createElement('canvas').getContext('2d');",
                            "",
                            "  // (0) Start with transparent to account for browser default values.",
                            "  context.fillStyle = 'transparent';",
                            "",
                            "  // (1) Assign color so that it's serialized.",
                            "  context.fillStyle = color;",
                            "",
                            "  // (2) Return null for non-hex serialization result.",
                            "  return /^#[0-9a-fA-F]{6}$/.test(context.fillStyle) ? context.fillStyle : null;",
                            "}",
                            "",
                            "/**",
                            " * Add legacy properties if required.",
                            " *",
                            " * @param {ModdleElement} di",
                            " */",
                            "function ensureLegacySupport(di) {",
                            "  if ('border-color' in di) {",
                            "    di.stroke = di['border-color'];",
                            "  }",
                            "",
                            "  if ('background-color' in di) {",
                            "    di.fill = di['background-color'];",
                            "  }",
                            "}"
                        ]
                    },
                    "SplitLaneHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  getChildLanes,",
                            "  LANE_INDENTATION",
                            "} from '../util/LaneUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                            " */",
                            "",
                            "/**",
                            " * A handler that splits a lane into a number of sub-lanes,",
                            " * creating new sub lanes, if necessary.",
                            " *",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {Modeling} modeling",
                            " * @param {Translate} translate",
                            " */",
                            "export default function SplitLaneHandler(modeling, translate) {",
                            "  this._modeling = modeling;",
                            "  this._translate = translate;",
                            "}",
                            "",
                            "SplitLaneHandler.$inject = [",
                            "  'modeling',",
                            "  'translate'",
                            "];",
                            "",
                            "",
                            "SplitLaneHandler.prototype.preExecute = function(context) {",
                            "",
                            "  var modeling = this._modeling,",
                            "      translate = this._translate;",
                            "",
                            "  var shape = context.shape,",
                            "      newLanesCount = context.count;",
                            "",
                            "  var childLanes = getChildLanes(shape),",
                            "      existingLanesCount = childLanes.length;",
                            "",
                            "  if (existingLanesCount > newLanesCount) {",
                            "    throw new Error(translate('more than {count} child lanes', { count: newLanesCount }));",
                            "  }",
                            "",
                            "  var newLanesHeight = Math.round(shape.height / newLanesCount);",
                            "",
                            "  // Iterate from top to bottom in child lane order,",
                            "  // resizing existing lanes and creating new ones",
                            "  // so that they split the parent proportionally.",
                            "  //",
                            "  // Due to rounding related errors, the bottom lane",
                            "  // needs to take up all the remaining space.",
                            "  var laneY,",
                            "      laneHeight,",
                            "      laneBounds,",
                            "      newLaneAttrs,",
                            "      idx;",
                            "",
                            "  for (idx = 0; idx < newLanesCount; idx++) {",
                            "",
                            "    laneY = shape.y + idx * newLanesHeight;",
                            "",
                            "    // if bottom lane",
                            "    if (idx === newLanesCount - 1) {",
                            "      laneHeight = shape.height - (newLanesHeight * idx);",
                            "    } else {",
                            "      laneHeight = newLanesHeight;",
                            "    }",
                            "",
                            "    laneBounds = {",
                            "      x: shape.x + LANE_INDENTATION,",
                            "      y: laneY,",
                            "      width: shape.width - LANE_INDENTATION,",
                            "      height: laneHeight",
                            "    };",
                            "",
                            "    if (idx < existingLanesCount) {",
                            "",
                            "      // resize existing lane",
                            "      modeling.resizeShape(childLanes[idx], laneBounds);",
                            "    } else {",
                            "",
                            "      // create a new lane at position",
                            "      newLaneAttrs = {",
                            "        type: 'bpmn:Lane'",
                            "      };",
                            "",
                            "      modeling.createShape(newLaneAttrs, laneBounds, shape);",
                            "    }",
                            "  }",
                            "};"
                        ]
                    },
                    "UpdateCanvasRootHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  add as collectionAdd,",
                            "  remove as collectionRemove",
                            "} from 'diagram-js/lib/util/Collections';",
                            "",
                            "import { getDi } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " */",
                            "",
                            "/**",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {Canvas} canvas",
                            " * @param {Modeling} modeling",
                            " */",
                            "export default function UpdateCanvasRootHandler(canvas, modeling) {",
                            "  this._canvas = canvas;",
                            "  this._modeling = modeling;",
                            "}",
                            "",
                            "UpdateCanvasRootHandler.$inject = [",
                            "  'canvas',",
                            "  'modeling'",
                            "];",
                            "",
                            "",
                            "UpdateCanvasRootHandler.prototype.execute = function(context) {",
                            "",
                            "  var canvas = this._canvas;",
                            "",
                            "  var newRoot = context.newRoot,",
                            "      newRootBusinessObject = newRoot.businessObject,",
                            "      oldRoot = canvas.getRootElement(),",
                            "      oldRootBusinessObject = oldRoot.businessObject,",
                            "      bpmnDefinitions = oldRootBusinessObject.$parent,",
                            "      diPlane = getDi(oldRoot);",
                            "",
                            "  // (1) replace process old <> new root",
                            "  canvas.setRootElement(newRoot);",
                            "  canvas.removeRootElement(oldRoot);",
                            "",
                            "  // (2) update root elements",
                            "  collectionAdd(bpmnDefinitions.rootElements, newRootBusinessObject);",
                            "  newRootBusinessObject.$parent = bpmnDefinitions;",
                            "",
                            "  collectionRemove(bpmnDefinitions.rootElements, oldRootBusinessObject);",
                            "  oldRootBusinessObject.$parent = null;",
                            "",
                            "  // (3) wire di",
                            "  oldRoot.di = null;",
                            "",
                            "  diPlane.bpmnElement = newRootBusinessObject;",
                            "  newRoot.di = diPlane;",
                            "",
                            "  context.oldRoot = oldRoot;",
                            "",
                            "  // TODO(nikku): return changed elements?",
                            "  // return [ newRoot, oldRoot ];",
                            "  return [];",
                            "};",
                            "",
                            "",
                            "UpdateCanvasRootHandler.prototype.revert = function(context) {",
                            "",
                            "  var canvas = this._canvas;",
                            "",
                            "  var newRoot = context.newRoot,",
                            "      newRootBusinessObject = newRoot.businessObject,",
                            "      oldRoot = context.oldRoot,",
                            "      oldRootBusinessObject = oldRoot.businessObject,",
                            "      bpmnDefinitions = newRootBusinessObject.$parent,",
                            "      diPlane = getDi(newRoot);",
                            "",
                            "  // (1) replace process old <> new root",
                            "  canvas.setRootElement(oldRoot);",
                            "  canvas.removeRootElement(newRoot);",
                            "",
                            "  // (2) update root elements",
                            "  collectionRemove(bpmnDefinitions.rootElements, newRootBusinessObject);",
                            "  newRootBusinessObject.$parent = null;",
                            "",
                            "  collectionAdd(bpmnDefinitions.rootElements, oldRootBusinessObject);",
                            "  oldRootBusinessObject.$parent = bpmnDefinitions;",
                            "",
                            "  // (3) wire di",
                            "  newRoot.di = null;",
                            "",
                            "  diPlane.bpmnElement = oldRootBusinessObject;",
                            "  oldRoot.di = diPlane;",
                            "",
                            "  // TODO(nikku): return changed elements?",
                            "  // return [ newRoot, oldRoot ];",
                            "",
                            "  return [];",
                            "};"
                        ]
                    },
                    "UpdateFlowNodeRefsHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  collectLanes,",
                            "  getLanesRoot",
                            "} from '../util/LaneUtil';",
                            "",
                            "import {",
                            "  is",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  add as collectionAdd,",
                            "  remove as collectionRemove",
                            "} from 'diagram-js/lib/util/Collections';",
                            "",
                            "import {",
                            "  asTRBL",
                            "} from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                            " *",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " */",
                            "",
                            "var FLOW_NODE_REFS_ATTR = 'flowNodeRef',",
                            "    LANES_ATTR = 'lanes';",
                            "",
                            "",
                            "/**",
                            " * A handler that updates lane refs on changed elements.",
                            " *",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {ElementRegistry} elementRegistry",
                            " */",
                            "export default function UpdateFlowNodeRefsHandler(elementRegistry) {",
                            "  this._elementRegistry = elementRegistry;",
                            "}",
                            "",
                            "UpdateFlowNodeRefsHandler.$inject = [",
                            "  'elementRegistry'",
                            "];",
                            "",
                            "/**",
                            " * @param {Shape} flowNodeShapes",
                            " * @param {Shape} laneShapes",
                            " *",
                            " * @return { {",
                            " *   flowNode: Shape;",
                            " *   add: Shape[];",
                            " *   remove: Shape[];",
                            " * }[] }",
                            " */",
                            "UpdateFlowNodeRefsHandler.prototype._computeUpdates = function(flowNodeShapes, laneShapes) {",
                            "",
                            "  var handledNodes = [];",
                            "",
                            "  var updates = [];",
                            "",
                            "  var participantCache = {};",
                            "",
                            "  var allFlowNodeShapes = [];",
                            "",
                            "  function isInLaneShape(element, laneShape) {",
                            "",
                            "    var laneTrbl = asTRBL(laneShape);",
                            "",
                            "    var elementMid = {",
                            "      x: element.x + element.width / 2,",
                            "      y: element.y + element.height / 2",
                            "    };",
                            "",
                            "    return elementMid.x > laneTrbl.left &&",
                            "           elementMid.x < laneTrbl.right &&",
                            "           elementMid.y > laneTrbl.top &&",
                            "           elementMid.y < laneTrbl.bottom;",
                            "  }",
                            "",
                            "  function addFlowNodeShape(flowNodeShape) {",
                            "    if (handledNodes.indexOf(flowNodeShape) === -1) {",
                            "      allFlowNodeShapes.push(flowNodeShape);",
                            "      handledNodes.push(flowNodeShape);",
                            "    }",
                            "  }",
                            "",
                            "  function getAllLaneShapes(flowNodeShape) {",
                            "",
                            "    var root = getLanesRoot(flowNodeShape);",
                            "",
                            "    if (!participantCache[root.id]) {",
                            "      participantCache[root.id] = collectLanes(root);",
                            "    }",
                            "",
                            "    return participantCache[root.id];",
                            "  }",
                            "",
                            "  function getNewLanes(flowNodeShape) {",
                            "    if (!flowNodeShape.parent) {",
                            "      return [];",
                            "    }",
                            "",
                            "    var allLaneShapes = getAllLaneShapes(flowNodeShape);",
                            "",
                            "    return allLaneShapes.filter(function(l) {",
                            "      return isInLaneShape(flowNodeShape, l);",
                            "    }).map(function(shape) {",
                            "      return shape.businessObject;",
                            "    });",
                            "  }",
                            "",
                            "  laneShapes.forEach(function(laneShape) {",
                            "    var root = getLanesRoot(laneShape);",
                            "",
                            "    if (!root || handledNodes.indexOf(root) !== -1) {",
                            "      return;",
                            "    }",
                            "",
                            "    var children = root.children.filter(function(c) {",
                            "      return is(c, 'bpmn:FlowNode');",
                            "    });",
                            "",
                            "    children.forEach(addFlowNodeShape);",
                            "",
                            "    handledNodes.push(root);",
                            "  });",
                            "",
                            "  flowNodeShapes.forEach(addFlowNodeShape);",
                            "",
                            "",
                            "  allFlowNodeShapes.forEach(function(flowNodeShape) {",
                            "",
                            "    var flowNode = flowNodeShape.businessObject;",
                            "",
                            "    var lanes = flowNode.get(LANES_ATTR),",
                            "        remove = lanes.slice(),",
                            "        add = getNewLanes(flowNodeShape);",
                            "",
                            "    updates.push({ flowNode: flowNode, remove: remove, add: add });",
                            "  });",
                            "",
                            "  laneShapes.forEach(function(laneShape) {",
                            "",
                            "    var lane = laneShape.businessObject;",
                            "",
                            "    // lane got removed XX-)",
                            "    if (!laneShape.parent) {",
                            "      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {",
                            "        updates.push({ flowNode: flowNode, remove: [ lane ], add: [] });",
                            "      });",
                            "    }",
                            "  });",
                            "",
                            "  return updates;",
                            "};",
                            "",
                            "UpdateFlowNodeRefsHandler.prototype.execute = function(context) {",
                            "",
                            "  var updates = context.updates;",
                            "",
                            "  if (!updates) {",
                            "    updates = context.updates = this._computeUpdates(context.flowNodeShapes, context.laneShapes);",
                            "  }",
                            "",
                            "",
                            "  updates.forEach(function(update) {",
                            "",
                            "    var flowNode = update.flowNode,",
                            "        lanes = flowNode.get(LANES_ATTR);",
                            "",
                            "    // unwire old",
                            "    update.remove.forEach(function(oldLane) {",
                            "      collectionRemove(lanes, oldLane);",
                            "      collectionRemove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);",
                            "    });",
                            "",
                            "    // wire new",
                            "    update.add.forEach(function(newLane) {",
                            "      collectionAdd(lanes, newLane);",
                            "      collectionAdd(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);",
                            "    });",
                            "  });",
                            "",
                            "  // TODO(nikku): return changed elements",
                            "  // return [ ... ];",
                            "",
                            "  return [];",
                            "};",
                            "",
                            "",
                            "UpdateFlowNodeRefsHandler.prototype.revert = function(context) {",
                            "",
                            "  var updates = context.updates;",
                            "",
                            "  updates.forEach(function(update) {",
                            "",
                            "    var flowNode = update.flowNode,",
                            "        lanes = flowNode.get(LANES_ATTR);",
                            "",
                            "    // unwire new",
                            "    update.add.forEach(function(newLane) {",
                            "      collectionRemove(lanes, newLane);",
                            "      collectionRemove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);",
                            "    });",
                            "",
                            "    // wire old",
                            "    update.remove.forEach(function(oldLane) {",
                            "      collectionAdd(lanes, oldLane);",
                            "      collectionAdd(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);",
                            "    });",
                            "  });",
                            "",
                            "  // TODO(nikku): return changed elements",
                            "  // return [ ... ];",
                            "",
                            "  return [];",
                            "};"
                        ]
                    },
                    "UpdateModdlePropertiesHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  reduce,",
                            "  keys,",
                            "  forEach",
                            "} from 'min-dash';",
                            "",
                            "import {",
                            "  is,",
                            "  getBusinessObject",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                            " *",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " * @typedef {import('../../../model/Types').ModdleElement} ModdleElement",
                            " */",
                            "",
                            "/**",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {ElementRegistry} elementRegistry",
                            " */",
                            "export default function UpdateModdlePropertiesHandler(elementRegistry) {",
                            "  this._elementRegistry = elementRegistry;",
                            "}",
                            "",
                            "UpdateModdlePropertiesHandler.$inject = [ 'elementRegistry' ];",
                            "",
                            "UpdateModdlePropertiesHandler.prototype.execute = function(context) {",
                            "",
                            "  var element = context.element,",
                            "      moddleElement = context.moddleElement,",
                            "      properties = context.properties;",
                            "",
                            "  if (!moddleElement) {",
                            "    throw new Error('<moddleElement> required');",
                            "  }",
                            "",
                            "  // TODO(nikku): we need to ensure that ID properties",
                            "  // are properly registered / unregistered via",
                            "  // this._moddle.ids.assigned(id)",
                            "  var changed = context.changed || this._getVisualReferences(moddleElement).concat(element);",
                            "  var oldProperties = context.oldProperties || getModdleProperties(moddleElement, keys(properties));",
                            "",
                            "  setModdleProperties(moddleElement, properties);",
                            "",
                            "  context.oldProperties = oldProperties;",
                            "  context.changed = changed;",
                            "",
                            "  return changed;",
                            "};",
                            "",
                            "UpdateModdlePropertiesHandler.prototype.revert = function(context) {",
                            "  var oldProperties = context.oldProperties,",
                            "      moddleElement = context.moddleElement,",
                            "      changed = context.changed;",
                            "",
                            "  setModdleProperties(moddleElement, oldProperties);",
                            "",
                            "  return changed;",
                            "};",
                            "",
                            "/**",
                            " * Return visual references of given moddle element within the diagram.",
                            " *",
                            " * @param {ModdleElement} moddleElement",
                            " *",
                            " * @return {Shape[]}",
                            " */",
                            "UpdateModdlePropertiesHandler.prototype._getVisualReferences = function(moddleElement) {",
                            "",
                            "  var elementRegistry = this._elementRegistry;",
                            "",
                            "  if (is(moddleElement, 'bpmn:DataObject')) {",
                            "    return getAllDataObjectReferences(moddleElement, elementRegistry);",
                            "  }",
                            "",
                            "  return [];",
                            "};",
                            "",
                            "",
                            "// helpers /////////////////",
                            "",
                            "function getModdleProperties(moddleElement, propertyNames) {",
                            "  return reduce(propertyNames, function(result, key) {",
                            "    result[key] = moddleElement.get(key);",
                            "    return result;",
                            "  }, {});",
                            "}",
                            "",
                            "function setModdleProperties(moddleElement, properties) {",
                            "  forEach(properties, function(value, key) {",
                            "    moddleElement.set(key, value);",
                            "  });",
                            "}",
                            "",
                            "function getAllDataObjectReferences(dataObject, elementRegistry) {",
                            "  return elementRegistry.filter(function(element) {",
                            "    return (",
                            "      is(element, 'bpmn:DataObjectReference') &&",
                            "          getBusinessObject(element).dataObjectRef === dataObject",
                            "    );",
                            "  });",
                            "}"
                        ]
                    },
                    "UpdatePropertiesHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  reduce,",
                            "  keys,",
                            "  forEach,",
                            "  assign",
                            "} from 'min-dash';",
                            "",
                            "import {",
                            "  getBusinessObject,",
                            "  getDi",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " * @typedef {import('diagram-js/lib/command/CommandStack').CommandContext} CommandContext",
                            " *",
                            " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                            " * @typedef {import('../../../model/Types').Moddle} Moddle",
                            " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                            " * @typedef {import('../Modeling').default} Modeling",
                            " * @typedef {import('../../../draw/TextRenderer').default} TextRenderer",
                            " *",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " */",
                            "",
                            "var DEFAULT_FLOW = 'default',",
                            "    ID = 'id',",
                            "    DI = 'di';",
                            "",
                            "var NULL_DIMENSIONS = {",
                            "  width: 0,",
                            "  height: 0",
                            "};",
                            "",
                            "/**",
                            " * A handler that implements a BPMN 2.0 property update.",
                            " *",
                            " * This should be used to set simple properties on elements with",
                            " * an underlying BPMN business object.",
                            " *",
                            " * Use respective diagram-js provided handlers if you would",
                            " * like to perform automated modeling.",
                            " *",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {ElementRegistry} elementRegistry",
                            " * @param {Moddle} moddle",
                            " * @param {Translate} translate",
                            " * @param {Modeling} modeling",
                            " * @param {TextRenderer} textRenderer",
                            " */",
                            "export default function UpdatePropertiesHandler(",
                            "    elementRegistry, moddle, translate,",
                            "    modeling, textRenderer) {",
                            "",
                            "  this._elementRegistry = elementRegistry;",
                            "  this._moddle = moddle;",
                            "  this._translate = translate;",
                            "  this._modeling = modeling;",
                            "  this._textRenderer = textRenderer;",
                            "}",
                            "",
                            "UpdatePropertiesHandler.$inject = [",
                            "  'elementRegistry',",
                            "  'moddle',",
                            "  'translate',",
                            "  'modeling',",
                            "  'textRenderer'",
                            "];",
                            "",
                            "",
                            "// api //////////////////////",
                            "",
                            "/**",
                            " * Update a BPMN element's properties.",
                            " *",
                            " * @param { {",
                            " *   element: Element;",
                            " *   properties: Record<string, any>;",
                            " * } & CommandContext } context",
                            " *",
                            " * @return {Element[]}",
                            " */",
                            "UpdatePropertiesHandler.prototype.execute = function(context) {",
                            "",
                            "  var element = context.element,",
                            "      changed = [ element ],",
                            "      translate = this._translate;",
                            "",
                            "  if (!element) {",
                            "    throw new Error(translate('element required'));",
                            "  }",
                            "",
                            "  var elementRegistry = this._elementRegistry,",
                            "      ids = this._moddle.ids;",
                            "",
                            "  var businessObject = element.businessObject,",
                            "      properties = unwrapBusinessObjects(context.properties),",
                            "      oldProperties = context.oldProperties || getProperties(element, properties);",
                            "",
                            "  if (isIdChange(properties, businessObject)) {",
                            "    ids.unclaim(businessObject[ID]);",
                            "",
                            "    elementRegistry.updateId(element, properties[ID]);",
                            "",
                            "    ids.claim(properties[ID], businessObject);",
                            "  }",
                            "",
                            "  // correctly indicate visual changes on default flow updates",
                            "  if (DEFAULT_FLOW in properties) {",
                            "",
                            "    if (properties[DEFAULT_FLOW]) {",
                            "      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));",
                            "    }",
                            "",
                            "    if (businessObject[DEFAULT_FLOW]) {",
                            "      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));",
                            "    }",
                            "  }",
                            "",
                            "  // update properties",
                            "  setProperties(element, properties);",
                            "",
                            "  // store old values",
                            "  context.oldProperties = oldProperties;",
                            "  context.changed = changed;",
                            "",
                            "  // indicate changed on objects affected by the update",
                            "  return changed;",
                            "};",
                            "",
                            "",
                            "UpdatePropertiesHandler.prototype.postExecute = function(context) {",
                            "  var element = context.element,",
                            "      label = element.label;",
                            "",
                            "  var text = label && getBusinessObject(label).name;",
                            "",
                            "  if (!text) {",
                            "    return;",
                            "  }",
                            "",
                            "  // get layouted text bounds and resize external",
                            "  // external label accordingly",
                            "  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);",
                            "",
                            "  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);",
                            "};",
                            "",
                            "/**",
                            " * Revert updating a BPMN element's properties.",
                            " *",
                            " * @param { {",
                            " *   element: Element;",
                            " *   properties: Record<string, any>;",
                            " *   oldProperties: Record<string, any>;",
                            " * } & CommandContext } context",
                            " *",
                            " * @return {Element[]}",
                            " */",
                            "UpdatePropertiesHandler.prototype.revert = function(context) {",
                            "",
                            "  var element = context.element,",
                            "      properties = context.properties,",
                            "      oldProperties = context.oldProperties,",
                            "      businessObject = element.businessObject,",
                            "      elementRegistry = this._elementRegistry,",
                            "      ids = this._moddle.ids;",
                            "",
                            "  // update properties",
                            "  setProperties(element, oldProperties);",
                            "",
                            "  if (isIdChange(properties, businessObject)) {",
                            "    ids.unclaim(properties[ID]);",
                            "",
                            "    elementRegistry.updateId(element, oldProperties[ID]);",
                            "",
                            "    ids.claim(oldProperties[ID], businessObject);",
                            "  }",
                            "",
                            "  return context.changed;",
                            "};",
                            "",
                            "",
                            "function isIdChange(properties, businessObject) {",
                            "  return ID in properties && properties[ID] !== businessObject[ID];",
                            "}",
                            "",
                            "",
                            "function getProperties(element, properties) {",
                            "  var propertyNames = keys(properties),",
                            "      businessObject = element.businessObject,",
                            "      di = getDi(element);",
                            "",
                            "  return reduce(propertyNames, function(result, key) {",
                            "",
                            "    // handle DI separately",
                            "    if (key !== DI) {",
                            "      result[key] = businessObject.get(key);",
                            "",
                            "    } else {",
                            "      result[key] = getDiProperties(di, keys(properties.di));",
                            "    }",
                            "",
                            "    return result;",
                            "  }, {});",
                            "}",
                            "",
                            "",
                            "function getDiProperties(di, propertyNames) {",
                            "  return reduce(propertyNames, function(result, key) {",
                            "    result[key] = di && di.get(key);",
                            "",
                            "    return result;",
                            "  }, {});",
                            "}",
                            "",
                            "",
                            "function setProperties(element, properties) {",
                            "  var businessObject = element.businessObject,",
                            "      di = getDi(element);",
                            "",
                            "  forEach(properties, function(value, key) {",
                            "",
                            "    if (key !== DI) {",
                            "      businessObject.set(key, value);",
                            "    } else {",
                            "",
                            "      // only update, if di exists",
                            "      if (di) {",
                            "        setDiProperties(di, value);",
                            "      }",
                            "    }",
                            "  });",
                            "}",
                            "",
                            "",
                            "function setDiProperties(di, properties) {",
                            "  forEach(properties, function(value, key) {",
                            "    di.set(key, value);",
                            "  });",
                            "}",
                            "",
                            "",
                            "var referencePropertyNames = [ 'default' ];",
                            "",
                            "/**",
                            " * Make sure we unwrap the actual business object behind diagram element that",
                            " * may have been passed as arguments.",
                            " *",
                            " * @param  {Record<string, any>} properties",
                            " *",
                            " * @return {Record<string, any>} unwrappedProps",
                            " */",
                            "function unwrapBusinessObjects(properties) {",
                            "",
                            "  var unwrappedProps = assign({}, properties);",
                            "",
                            "  referencePropertyNames.forEach(function(name) {",
                            "    if (name in properties) {",
                            "      unwrappedProps[name] = getBusinessObject(unwrappedProps[name]);",
                            "    }",
                            "  });",
                            "",
                            "  return unwrappedProps;",
                            "}"
                        ]
                    },
                    "UpdateSemanticParentHandler.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "/**",
                            " * @typedef {import('diagram-js/lib/command/CommandHandler').default} CommandHandler",
                            " *",
                            " * @typedef {import('../BpmnUpdater').default} BpmnUpdater",
                            " */",
                            "",
                            "/**",
                            " * @implements {CommandHandler}",
                            " *",
                            " * @param {BpmnUpdater} bpmnUpdater",
                            " */",
                            "export default function UpdateSemanticParentHandler(bpmnUpdater) {",
                            "  this._bpmnUpdater = bpmnUpdater;",
                            "}",
                            "",
                            "UpdateSemanticParentHandler.$inject = [ 'bpmnUpdater' ];",
                            "",
                            "",
                            "UpdateSemanticParentHandler.prototype.execute = function(context) {",
                            "  var dataStoreBo = context.dataStoreBo,",
                            "      dataStoreDi = context.dataStoreDi,",
                            "      newSemanticParent = context.newSemanticParent,",
                            "      newDiParent = context.newDiParent;",
                            "",
                            "  context.oldSemanticParent = dataStoreBo.$parent;",
                            "  context.oldDiParent = dataStoreDi.$parent;",
                            "",
                            "  // update semantic parent",
                            "  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);",
                            "",
                            "  // update DI parent",
                            "  this._bpmnUpdater.updateDiParent(dataStoreDi, newDiParent);",
                            "",
                            "  return [];",
                            "};",
                            "",
                            "UpdateSemanticParentHandler.prototype.revert = function(context) {",
                            "  var dataStoreBo = context.dataStoreBo,",
                            "      dataStoreDi = context.dataStoreDi,",
                            "      oldSemanticParent = context.oldSemanticParent,",
                            "      oldDiParent = context.oldDiParent;",
                            "",
                            "  // update semantic parent",
                            "  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);",
                            "",
                            "  // update DI parent",
                            "  this._bpmnUpdater.updateDiParent(dataStoreDi, oldDiParent);",
                            "",
                            "  return [];",
                            "};",
                            ""
                        ]
                    }
                },
                "util": {
                    "LaneUtil.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { is } from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  getParent",
                            "} from './ModelingUtil';",
                            "",
                            "import {",
                            "  asTRBL",
                            "} from 'diagram-js/lib/layout/LayoutUtil';",
                            "",
                            "import {",
                            "  substractTRBL,",
                            "  resizeTRBL",
                            "} from 'diagram-js/lib/features/resize/ResizeUtil';",
                            "",
                            "/**",
                            " * @typedef {import('../../../model/Types').Shape} Shape",
                            " *",
                            " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                            " */",
                            "",
                            "var abs = Math.abs;",
                            "",
                            "",
                            "function getTRBLResize(oldBounds, newBounds) {",
                            "  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));",
                            "}",
                            "",
                            "",
                            "var LANE_PARENTS = [",
                            "  'bpmn:Participant',",
                            "  'bpmn:Process',",
                            "  'bpmn:SubProcess'",
                            "];",
                            "",
                            "export var LANE_INDENTATION = 30;",
                            "",
                            "",
                            "/**",
                            " * Return all lanes that are children of the given shape.",
                            " *",
                            " * @param  {Shape} shape",
                            " * @param  {Shape[]} [collectedShapes]",
                            " *",
                            " * @return {Shape[]}",
                            " */",
                            "export function collectLanes(shape, collectedShapes) {",
                            "",
                            "  collectedShapes = collectedShapes || [];",
                            "",
                            "  shape.children.filter(function(s) {",
                            "    if (is(s, 'bpmn:Lane')) {",
                            "      collectLanes(s, collectedShapes);",
                            "",
                            "      collectedShapes.push(s);",
                            "    }",
                            "  });",
                            "",
                            "  return collectedShapes;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Return all lanes that are direct children of the given shape.",
                            " *",
                            " * @param {Shape} shape",
                            " *",
                            " * @return {Shape[]}",
                            " */",
                            "export function getChildLanes(shape) {",
                            "  return shape.children.filter(function(c) {",
                            "    return is(c, 'bpmn:Lane');",
                            "  });",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Return the parent shape of the given lane.",
                            " *",
                            " * @param {Shape} shape",
                            " *",
                            " * @return {Shape}",
                            " */",
                            "export function getLanesRoot(shape) {",
                            "  return getParent(shape, LANE_PARENTS) || shape;",
                            "}",
                            "",
                            "",
                            "/**",
                            " * Compute the required resize operations for lanes",
                            " * adjacent to the given shape, assuming it will be",
                            " * resized to the given new bounds.",
                            " *",
                            " * @param {Shape} shape",
                            " * @param {Rect} newBounds",
                            " *",
                            " * @return { {",
                            " *   shape: Shape;",
                            " *   newBounds: Rect;",
                            " * }[] }",
                            " */",
                            "export function computeLanesResize(shape, newBounds) {",
                            "",
                            "  var rootElement = getLanesRoot(shape);",
                            "",
                            "  var initialShapes = is(rootElement, 'bpmn:Process') ? [] : [ rootElement ];",
                            "",
                            "  var allLanes = collectLanes(rootElement, initialShapes),",
                            "      shapeTrbl = asTRBL(shape),",
                            "      shapeNewTrbl = asTRBL(newBounds),",
                            "      trblResize = getTRBLResize(shape, newBounds),",
                            "      resizeNeeded = [];",
                            "",
                            "  allLanes.forEach(function(other) {",
                            "",
                            "    if (other === shape) {",
                            "      return;",
                            "    }",
                            "",
                            "    var topResize = 0,",
                            "        rightResize = trblResize.right,",
                            "        bottomResize = 0,",
                            "        leftResize = trblResize.left;",
                            "",
                            "    var otherTrbl = asTRBL(other);",
                            "",
                            "    if (trblResize.top) {",
                            "      if (abs(otherTrbl.bottom - shapeTrbl.top) < 10) {",
                            "        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;",
                            "      }",
                            "",
                            "      if (abs(otherTrbl.top - shapeTrbl.top) < 5) {",
                            "        topResize = shapeNewTrbl.top - otherTrbl.top;",
                            "      }",
                            "    }",
                            "",
                            "    if (trblResize.bottom) {",
                            "      if (abs(otherTrbl.top - shapeTrbl.bottom) < 10) {",
                            "        topResize = shapeNewTrbl.bottom - otherTrbl.top;",
                            "      }",
                            "",
                            "      if (abs(otherTrbl.bottom - shapeTrbl.bottom) < 5) {",
                            "        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;",
                            "      }",
                            "    }",
                            "",
                            "    if (topResize || rightResize || bottomResize || leftResize) {",
                            "",
                            "      resizeNeeded.push({",
                            "        shape: other,",
                            "        newBounds: resizeTRBL(other, {",
                            "          top: topResize,",
                            "          right: rightResize,",
                            "          bottom: bottomResize,",
                            "          left: leftResize",
                            "        })",
                            "      });",
                            "    }",
                            "",
                            "  });",
                            "",
                            "  return resizeNeeded;",
                            "}"
                        ]
                    },
                    "ModelingUtil.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { isString } from 'min-dash';",
                            "",
                            "export { is, isAny } from '../../../util/ModelUtil';",
                            "",
                            "import { isAny } from '../../../util/ModelUtil';",
                            "",
                            "/**",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " */",
                            "",
                            "/**",
                            " * Return the parent of the element with any of the given types.",
                            " *",
                            " * @param {Element} element",
                            " * @param {string|string[]} anyType",
                            " *",
                            " * @return {Element|null}",
                            " */",
                            "export function getParent(element, anyType) {",
                            "",
                            "  if (isString(anyType)) {",
                            "    anyType = [ anyType ];",
                            "  }",
                            "",
                            "  while ((element = element.parent)) {",
                            "    if (isAny(element, anyType)) {",
                            "      return element;",
                            "    }",
                            "  }",
                            "",
                            "  return null;",
                            "}"
                        ]
                    }
                }
            },
            "modeling-feedback": {
                "ModelingFeedback.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('diagram-js/lib/features/tooltips/Tooltips').default} Tooltips",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " */",
                        "",
                        "var COLLAB_ERR_MSG = 'flow elements must be children of pools/participants';",
                        "",
                        "/**",
                        " * @param {EventBus} eventBus",
                        " * @param {Tooltips} tooltips",
                        " * @param {Translate} translate",
                        " */",
                        "export default function ModelingFeedback(eventBus, tooltips, translate) {",
                        "",
                        "  function showError(position, message, timeout) {",
                        "    tooltips.add({",
                        "      position: {",
                        "        x: position.x + 5,",
                        "        y: position.y + 5",
                        "      },",
                        "      type: 'error',",
                        "      timeout: timeout || 2000,",
                        "      html: '<div>' + message + '</div>'",
                        "    });",
                        "  }",
                        "",
                        "  eventBus.on([ 'shape.move.rejected', 'create.rejected' ], function(event) {",
                        "    var context = event.context,",
                        "        shape = context.shape,",
                        "        target = context.target;",
                        "",
                        "    if (is(target, 'bpmn:Collaboration') && is(shape, 'bpmn:FlowNode')) {",
                        "      showError(event, translate(COLLAB_ERR_MSG));",
                        "    }",
                        "  });",
                        "",
                        "}",
                        "",
                        "ModelingFeedback.$inject = [",
                        "  'eventBus',",
                        "  'tooltips',",
                        "  'translate'",
                        "];"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import TooltipsModule from 'diagram-js/lib/features/tooltips';",
                        "",
                        "import ModelingFeedback from './ModelingFeedback';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    TooltipsModule",
                        "  ],",
                        "  __init__: [",
                        "    'modelingFeedback'",
                        "  ],",
                        "  modelingFeedback: [ 'type', ModelingFeedback ]",
                        "};"
                    ]
                }
            },
            "ordering": {
                "BpmnOrderingProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import OrderingProvider from 'diagram-js/lib/features/ordering/OrderingProvider';",
                        "",
                        "import {",
                        "  isAny",
                        "} from '../modeling/util/ModelingUtil';",
                        "",
                        "import {",
                        "  findIndex,",
                        "  find",
                        "} from 'min-dash';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('diagram-js/i18n/translate/translate').default} Translate",
                        " */",
                        "",
                        "/**",
                        " * A BPMN-specific ordering provider.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {Canvas} canvas",
                        " * @param {Translate} translate",
                        " */",
                        "export default function BpmnOrderingProvider(eventBus, canvas, translate) {",
                        "",
                        "  OrderingProvider.call(this, eventBus);",
                        "",
                        "  var orders = [",
                        "    { type: 'bpmn:SubProcess', order: { level: 6 } },",
                        "",
                        "    // handle SequenceFlow(s) like message flows and render them always on top",
                        "    {",
                        "      type: 'bpmn:SequenceFlow',",
                        "      order: {",
                        "        level: 9,",
                        "        containers: [",
                        "          'bpmn:Participant',",
                        "          'bpmn:FlowElementsContainer'",
                        "        ]",
                        "      }",
                        "    },",
                        "",
                        "    // handle DataAssociation(s) like message flows and render them always on top",
                        "    {",
                        "      type: 'bpmn:DataAssociation',",
                        "      order: {",
                        "        level: 9,",
                        "        containers: [",
                        "          'bpmn:Collaboration',",
                        "          'bpmn:FlowElementsContainer'",
                        "        ]",
                        "      }",
                        "    },",
                        "    {",
                        "      type: 'bpmn:MessageFlow', order: {",
                        "        level: 9,",
                        "        containers: [ 'bpmn:Collaboration' ]",
                        "      }",
                        "    },",
                        "    {",
                        "      type: 'bpmn:Association',",
                        "      order: {",
                        "        level: 6,",
                        "        containers: [",
                        "          'bpmn:Participant',",
                        "          'bpmn:FlowElementsContainer',",
                        "          'bpmn:Collaboration'",
                        "        ]",
                        "      }",
                        "    },",
                        "    { type: 'bpmn:BoundaryEvent', order: { level: 8 } },",
                        "    {",
                        "      type: 'bpmn:Group',",
                        "      order: {",
                        "        level: 10,",
                        "        containers: [",
                        "          'bpmn:Collaboration',",
                        "          'bpmn:FlowElementsContainer'",
                        "        ]",
                        "      }",
                        "    },",
                        "    { type: 'bpmn:FlowElement', order: { level: 5 } },",
                        "    { type: 'bpmn:Participant', order: { level: -2 } },",
                        "    { type: 'bpmn:Lane', order: { level: -1 } }",
                        "  ];",
                        "",
                        "  function computeOrder(element) {",
                        "    if (element.labelTarget) {",
                        "      return { level: 10 };",
                        "    }",
                        "",
                        "    var entry = find(orders, function(o) {",
                        "      return isAny(element, [ o.type ]);",
                        "    });",
                        "",
                        "    return entry && entry.order || { level: 1 };",
                        "  }",
                        "",
                        "  function getOrder(element) {",
                        "",
                        "    var order = element.order;",
                        "",
                        "    if (!order) {",
                        "      element.order = order = computeOrder(element);",
                        "    }",
                        "",
                        "    if (!order) {",
                        "      throw new Error('no order for <' + element.id + '>');",
                        "    }",
                        "",
                        "    return order;",
                        "  }",
                        "",
                        "  function findActualParent(element, newParent, containers) {",
                        "",
                        "    var actualParent = newParent;",
                        "",
                        "    while (actualParent) {",
                        "",
                        "      if (isAny(actualParent, containers)) {",
                        "        break;",
                        "      }",
                        "",
                        "      actualParent = actualParent.parent;",
                        "    }",
                        "",
                        "    if (!actualParent) {",
                        "      throw new Error('no parent for <' + element.id + '> in <' + (newParent && newParent.id) + '>');",
                        "    }",
                        "",
                        "    return actualParent;",
                        "  }",
                        "",
                        "  this.getOrdering = function(element, newParent) {",
                        "",
                        "    // render labels always on top",
                        "    if (element.labelTarget) {",
                        "      return {",
                        "        parent: canvas.findRoot(newParent) || canvas.getRootElement(),",
                        "        index: -1",
                        "      };",
                        "    }",
                        "",
                        "    var elementOrder = getOrder(element);",
                        "",
                        "    if (elementOrder.containers) {",
                        "      newParent = findActualParent(element, newParent, elementOrder.containers);",
                        "    }",
                        "",
                        "    var currentIndex = newParent.children.indexOf(element);",
                        "",
                        "    var insertIndex = findIndex(newParent.children, function(child) {",
                        "",
                        "      // do not compare with labels, they are created",
                        "      // in the wrong order (right after elements) during import and",
                        "      // mess up the positioning.",
                        "      if (!element.labelTarget && child.labelTarget) {",
                        "        return false;",
                        "      }",
                        "",
                        "      return elementOrder.level < getOrder(child).level;",
                        "    });",
                        "",
                        "",
                        "    // if the element is already in the child list at",
                        "    // a smaller index, we need to adjust the insert index.",
                        "    // this takes into account that the element is being removed",
                        "    // before being re-inserted",
                        "    if (insertIndex !== -1) {",
                        "      if (currentIndex !== -1 && currentIndex < insertIndex) {",
                        "        insertIndex -= 1;",
                        "      }",
                        "    }",
                        "",
                        "    return {",
                        "      index: insertIndex,",
                        "      parent: newParent",
                        "    };",
                        "  };",
                        "}",
                        "",
                        "BpmnOrderingProvider.$inject = [ 'eventBus', 'canvas', 'translate' ];",
                        "",
                        "inherits(BpmnOrderingProvider, OrderingProvider);"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import translate from 'diagram-js/lib/i18n/translate';",
                        "",
                        "import BpmnOrderingProvider from './BpmnOrderingProvider';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    translate",
                        "  ],",
                        "  __init__: [ 'bpmnOrderingProvider' ],",
                        "  bpmnOrderingProvider: [ 'type', BpmnOrderingProvider ]",
                        "};"
                    ]
                }
            },
            "outline": {
                "OutlineProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { assign } from 'min-dash';",
                        "",
                        "import {",
                        "  attr as svgAttr,",
                        "  create as svgCreate",
                        "} from 'tiny-svg';",
                        "",
                        "import {",
                        "  is,",
                        "  isAny",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import { isLabel } from '../../util/LabelUtil';",
                        "",
                        "import {",
                        "  DATA_OBJECT_REFERENCE_OUTLINE_PATH,",
                        "  DATA_STORE_REFERENCE_OUTLINE_PATH,",
                        "  DATA_OBJECT_REFERENCE_STANDARD_SIZE,",
                        "  DATA_STORE_REFERENCE_STANDARD_SIZE,",
                        "  createPath",
                        "} from './OutlineUtil';",
                        "",
                        "const DEFAULT_OFFSET = 5;",
                        "",
                        "/**",
                        " * BPMN-specific outline provider.",
                        " *",
                        " * @implements {BaseOutlineProvider}",
                        " *",
                        " * @param {Outline} outline",
                        " * @param {Styles} styles",
                        " */",
                        "export default function OutlineProvider(outline, styles) {",
                        "",
                        "  this._styles = styles;",
                        "  outline.registerProvider(this);",
                        "}",
                        "",
                        "OutlineProvider.$inject = [",
                        "  'outline',",
                        "  'styles'",
                        "];",
                        "",
                        "/**",
                        " * Returns outline for a given element.",
                        " *",
                        " * @param {Element} element",
                        " *",
                        " * @return {Outline}",
                        " */",
                        "OutlineProvider.prototype.getOutline = function(element) {",
                        "",
                        "  const OUTLINE_STYLE = this._styles.cls('djs-outline', [ 'no-fill' ]);",
                        "",
                        "  var outline;",
                        "",
                        "  if (isLabel(element)) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (is(element, 'bpmn:Gateway')) {",
                        "    outline = svgCreate('rect');",
                        "",
                        "    assign(outline.style, {",
                        "      'transform-box': 'fill-box',",
                        "      'transform': 'rotate(45deg)',",
                        "      'transform-origin': 'center'",
                        "    });",
                        "",
                        "    svgAttr(outline, assign({",
                        "      x: 2,",
                        "      y: 2,",
                        "      rx: 4,",
                        "      width: element.width - 4,",
                        "      height: element.height - 4,",
                        "    }, OUTLINE_STYLE));",
                        "",
                        "  } else if (isAny(element, [ 'bpmn:Task', 'bpmn:SubProcess', 'bpmn:Group' ])) {",
                        "    outline = svgCreate('rect');",
                        "",
                        "    svgAttr(outline, assign({",
                        "      x: -DEFAULT_OFFSET,",
                        "      y: -DEFAULT_OFFSET,",
                        "      rx: 14,",
                        "      width: element.width + DEFAULT_OFFSET * 2,",
                        "      height: element.height + DEFAULT_OFFSET * 2",
                        "    }, OUTLINE_STYLE));",
                        "",
                        "  } else if (is(element, 'bpmn:EndEvent')) {",
                        "",
                        "    outline = svgCreate('circle');",
                        "",
                        "    // Extra 1px offset needed due to increased stroke-width of end event",
                        "    // which makes it bigger than other events.",
                        "",
                        "    svgAttr(outline, assign({",
                        "      cx: element.width / 2,",
                        "      cy: element.height / 2,",
                        "      r: element.width / 2 + DEFAULT_OFFSET + 1",
                        "    }, OUTLINE_STYLE));",
                        "",
                        "  } else if (is(element, 'bpmn:Event')) {",
                        "    outline = svgCreate('circle');",
                        "",
                        "    svgAttr(outline, assign({",
                        "      cx: element.width / 2,",
                        "      cy: element.height / 2,",
                        "      r: element.width / 2 + DEFAULT_OFFSET",
                        "    }, OUTLINE_STYLE));",
                        "",
                        "  } else if (is(element, 'bpmn:DataObjectReference') && isStandardSize(element, 'bpmn:DataObjectReference')) {",
                        "",
                        "    outline = createPath(",
                        "      DATA_OBJECT_REFERENCE_OUTLINE_PATH,",
                        "      { x: -6, y: -6 },",
                        "      OUTLINE_STYLE",
                        "    );",
                        "",
                        "  } else if (is(element, 'bpmn:DataStoreReference') && isStandardSize(element, 'bpmn:DataStoreReference')) {",
                        "",
                        "    outline = createPath(",
                        "      DATA_STORE_REFERENCE_OUTLINE_PATH,",
                        "      { x: -6, y: -6 },",
                        "      OUTLINE_STYLE",
                        "    );",
                        "  }",
                        "",
                        "  return outline;",
                        "};",
                        "",
                        "/**",
                        " * Updates the outline for a given element.",
                        " * Returns true if the update for the given element was handled by this provider.",
                        " *",
                        " * @param {Element} element",
                        " * @param {Outline} outline",
                        " * @returns {boolean}",
                        " */",
                        "OutlineProvider.prototype.updateOutline = function(element, outline) {",
                        "",
                        "  if (isLabel(element)) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (isAny(element, [ 'bpmn:SubProcess', 'bpmn:Group' ])) {",
                        "",
                        "    svgAttr(outline, {",
                        "      width: element.width + DEFAULT_OFFSET * 2,",
                        "      height: element.height + DEFAULT_OFFSET * 2",
                        "    });",
                        "",
                        "    return true;",
                        "",
                        "  } else if (isAny(element, [",
                        "    'bpmn:Event',",
                        "    'bpmn:Gateway',",
                        "    'bpmn:DataStoreReference',",
                        "    'bpmn:DataObjectReference'",
                        "  ])) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "};",
                        "",
                        "",
                        "// helpers //////////",
                        "",
                        "function isStandardSize(element, type) {",
                        "  var standardSize;",
                        "",
                        "  if (type === 'bpmn:DataObjectReference') {",
                        "    standardSize = DATA_OBJECT_REFERENCE_STANDARD_SIZE;",
                        "  } else if (type === 'bpmn:DataStoreReference') {",
                        "    standardSize = DATA_STORE_REFERENCE_STANDARD_SIZE;",
                        "  }",
                        "",
                        "  return element.width === standardSize.width",
                        "          && element.height === standardSize.height;",
                        "}"
                    ]
                },
                "OutlineUtil.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  create as svgCreate",
                        "} from 'tiny-svg';",
                        "",
                        "export const DATA_OBJECT_REFERENCE_OUTLINE_PATH = 'M44.7648 11.3263L36.9892 2.64074C36.0451 1.58628 34.5651 0.988708 33.1904 0.988708H5.98667C3.22688 0.988708 0.989624 3.34892 0.989624 6.26039V55.0235C0.989624 57.9349 3.22688 60.2952 5.98667 60.2952H40.966C43.7257 60.2952 45.963 57.9349 45.963 55.0235V14.9459C45.963 13.5998 45.6407 12.3048 44.7648 11.3263Z';",
                        "export const DATA_STORE_REFERENCE_OUTLINE_PATH = 'M1.03845 48.1347C1.03845 49.3511 1.07295 50.758 1.38342 52.064C1.69949 53.3938 2.32428 54.7154 3.56383 55.6428C6.02533 57.4841 10.1161 58.7685 14.8212 59.6067C19.5772 60.4538 25.1388 60.8738 30.6831 60.8738C36.2276 60.8738 41.7891 60.4538 46.545 59.6067C51.2504 58.7687 55.3412 57.4842 57.8028 55.6429C59.0424 54.7156 59.6673 53.3938 59.9834 52.064C60.2938 50.7579 60.3285 49.351 60.3285 48.1344V13.8415C60.3285 12.6249 60.2938 11.218 59.9834 9.91171C59.6673 8.58194 59.0423 7.2602 57.8027 6.33294C55.341 4.49168 51.2503 3.20723 46.545 2.36914C41.7891 1.522 36.2276 1.10204 30.6831 1.10205C25.1388 1.10206 19.5772 1.52206 14.8213 2.36923C10.1162 3.20734 6.02543 4.49183 3.5639 6.33314C2.32433 7.26038 1.69951 8.58206 1.38343 9.91181C1.07295 11.2179 1.03845 12.6247 1.03845 13.8411V48.1347Z';",
                        "",
                        "/**",
                        " * @type {Dimensions}",
                        " */",
                        "export const DATA_OBJECT_REFERENCE_STANDARD_SIZE = { width: 36, height: 50 };",
                        "",
                        "/**",
                        " * @type {Dimensions}",
                        " */",
                        "export const DATA_STORE_REFERENCE_STANDARD_SIZE = { width: 50, height: 50 };",
                        "",
                        "/**",
                        " * Create a path element with given attributes.",
                        " * @param {string} path",
                        " * @param {Object} attrs",
                        " * @param {Object} OUTLINE_STYLE",
                        " * @return {SVGElement}",
                        " */",
                        "export function createPath(path, attrs, OUTLINE_STYLE) {",
                        "  return svgCreate('path', {",
                        "    d: path,",
                        "    strokeWidth: 2,",
                        "    transform: `translate(${attrs.x}, ${attrs.y})`,",
                        "    ...OUTLINE_STYLE",
                        "  });",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import Ouline from 'diagram-js/lib/features/outline';",
                        "import OulineProvider from './OutlineProvider';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    Ouline",
                        "  ],",
                        "  __init__: [ 'outlineProvider' ],",
                        "  outlineProvider: [ 'type', OulineProvider ]",
                        "};"
                    ]
                }
            },
            "palette": {
                "PaletteProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  assign",
                        "} from 'min-dash';",
                        "",
                        "import { getDi } from '../../util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/features/palette/Palette').default} Palette",
                        " * @typedef {import('diagram-js/lib/features/create/Create').default} Create",
                        " * @typedef {import('diagram-js/lib/core/ElementFactory').default} ElementFactory",
                        " * @typedef {import('../space-tool/BpmnSpaceTool').default} SpaceTool",
                        " * @typedef {import('diagram-js/lib/features/lasso-tool/LassoTool').default} LassoTool",
                        " * @typedef {import('diagram-js/lib/features/hand-tool/HandTool').default} HandTool",
                        " * @typedef {import('diagram-js/lib/features/global-connect/GlobalConnect').default} GlobalConnect",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " *",
                        " * @typedef {import('diagram-js/lib/features/palette/Palette').PaletteEntries} PaletteEntries",
                        " */",
                        "",
                        "/**",
                        " * A palette provider for BPMN 2.0 elements.",
                        " *",
                        " * @param {Palette} palette",
                        " * @param {Create} create",
                        " * @param {ElementFactory} elementFactory",
                        " * @param {SpaceTool} spaceTool",
                        " * @param {LassoTool} lassoTool",
                        " * @param {HandTool} handTool",
                        " * @param {GlobalConnect} globalConnect",
                        " * @param {Translate} translate",
                        " */",
                        "export default function PaletteProvider(",
                        "    palette, create, elementFactory,",
                        "    spaceTool, lassoTool, handTool,",
                        "    globalConnect, translate) {",
                        "",
                        "  this._palette = palette;",
                        "  this._create = create;",
                        "  this._elementFactory = elementFactory;",
                        "  this._spaceTool = spaceTool;",
                        "  this._lassoTool = lassoTool;",
                        "  this._handTool = handTool;",
                        "  this._globalConnect = globalConnect;",
                        "  this._translate = translate;",
                        "",
                        "  palette.registerProvider(this);",
                        "}",
                        "",
                        "PaletteProvider.$inject = [",
                        "  'palette',",
                        "  'create',",
                        "  'elementFactory',",
                        "  'spaceTool',",
                        "  'lassoTool',",
                        "  'handTool',",
                        "  'globalConnect',",
                        "  'translate'",
                        "];",
                        "",
                        "/**",
                        " * @return {PaletteEntries}",
                        " */",
                        "PaletteProvider.prototype.getPaletteEntries = function() {",
                        "",
                        "  var actions = {},",
                        "      create = this._create,",
                        "      elementFactory = this._elementFactory,",
                        "      spaceTool = this._spaceTool,",
                        "      lassoTool = this._lassoTool,",
                        "      handTool = this._handTool,",
                        "      globalConnect = this._globalConnect,",
                        "      translate = this._translate;",
                        "",
                        "  function createAction(type, group, className, title, options) {",
                        "",
                        "    function createListener(event) {",
                        "      var shape = elementFactory.createShape(assign({ type: type }, options));",
                        "",
                        "      if (options) {",
                        "        var di = getDi(shape);",
                        "        di.isExpanded = options.isExpanded;",
                        "      }",
                        "",
                        "      create.start(event, shape);",
                        "    }",
                        "",
                        "    var shortType = type.replace(/^bpmn:/, '');",
                        "",
                        "    return {",
                        "      group: group,",
                        "      className: className,",
                        "      title: title || translate('Create {type}', { type: shortType }),",
                        "      action: {",
                        "        dragstart: createListener,",
                        "        click: createListener",
                        "      }",
                        "    };",
                        "  }",
                        "",
                        "  function createSubprocess(event) {",
                        "    var subProcess = elementFactory.createShape({",
                        "      type: 'bpmn:SubProcess',",
                        "      x: 0,",
                        "      y: 0,",
                        "      isExpanded: true",
                        "    });",
                        "",
                        "    var startEvent = elementFactory.createShape({",
                        "      type: 'bpmn:StartEvent',",
                        "      x: 40,",
                        "      y: 82,",
                        "      parent: subProcess",
                        "    });",
                        "",
                        "    create.start(event, [ subProcess, startEvent ], {",
                        "      hints: {",
                        "        autoSelect: [ subProcess ]",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  function createParticipant(event) {",
                        "    create.start(event, elementFactory.createParticipantShape());",
                        "  }",
                        "",
                        "  assign(actions, {",
                        "    'hand-tool': {",
                        "      group: 'tools',",
                        "      className: 'bpmn-icon-hand-tool',",
                        "      title: translate('Activate the hand tool'),",
                        "      action: {",
                        "        click: function(event) {",
                        "          handTool.activateHand(event);",
                        "        }",
                        "      }",
                        "    },",
                        "    'lasso-tool': {",
                        "      group: 'tools',",
                        "      className: 'bpmn-icon-lasso-tool',",
                        "      title: translate('Activate the lasso tool'),",
                        "      action: {",
                        "        click: function(event) {",
                        "          lassoTool.activateSelection(event);",
                        "        }",
                        "      }",
                        "    },",
                        "    'space-tool': {",
                        "      group: 'tools',",
                        "      className: 'bpmn-icon-space-tool',",
                        "      title: translate('Activate the create/remove space tool'),",
                        "      action: {",
                        "        click: function(event) {",
                        "          spaceTool.activateSelection(event);",
                        "        }",
                        "      }",
                        "    },",
                        "    'global-connect-tool': {",
                        "      group: 'tools',",
                        "      className: 'bpmn-icon-connection-multi',",
                        "      title: translate('Activate the global connect tool'),",
                        "      action: {",
                        "        click: function(event) {",
                        "          globalConnect.start(event);",
                        "        }",
                        "      }",
                        "    },",
                        "    'tool-separator': {",
                        "      group: 'tools',",
                        "      separator: true",
                        "    },",
                        "    'create.start-event': createAction(",
                        "      'bpmn:StartEvent', 'event', 'bpmn-icon-start-event-none',",
                        "      translate('Create StartEvent')",
                        "    ),",
                        "    'create.intermediate-event': createAction(",
                        "      'bpmn:IntermediateThrowEvent', 'event', 'bpmn-icon-intermediate-event-none',",
                        "      translate('Create Intermediate/Boundary Event')",
                        "    ),",
                        "    'create.end-event': createAction(",
                        "      'bpmn:EndEvent', 'event', 'bpmn-icon-end-event-none',",
                        "      translate('Create EndEvent')",
                        "    ),",
                        "    'create.exclusive-gateway': createAction(",
                        "      'bpmn:ExclusiveGateway', 'gateway', 'bpmn-icon-gateway-none',",
                        "      translate('Create Gateway')",
                        "    ),",
                        "    'create.task': createAction(",
                        "      'bpmn:Task', 'activity', 'bpmn-icon-task',",
                        "      translate('Create Task')",
                        "    ),",
                        "    'create.data-object': createAction(",
                        "      'bpmn:DataObjectReference', 'data-object', 'bpmn-icon-data-object',",
                        "      translate('Create DataObjectReference')",
                        "    ),",
                        "    'create.data-store': createAction(",
                        "      'bpmn:DataStoreReference', 'data-store', 'bpmn-icon-data-store',",
                        "      translate('Create DataStoreReference')",
                        "    ),",
                        "    'create.subprocess-expanded': {",
                        "      group: 'activity',",
                        "      className: 'bpmn-icon-subprocess-expanded',",
                        "      title: translate('Create expanded SubProcess'),",
                        "      action: {",
                        "        dragstart: createSubprocess,",
                        "        click: createSubprocess",
                        "      }",
                        "    },",
                        "    'create.participant-expanded': {",
                        "      group: 'collaboration',",
                        "      className: 'bpmn-icon-participant',",
                        "      title: translate('Create Pool/Participant'),",
                        "      action: {",
                        "        dragstart: createParticipant,",
                        "        click: createParticipant",
                        "      }",
                        "    },",
                        "    'create.group': createAction(",
                        "      'bpmn:Group', 'artifact', 'bpmn-icon-group',",
                        "      translate('Create Group')",
                        "    ),",
                        "  });",
                        "",
                        "  return actions;",
                        "};"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import PaletteModule from 'diagram-js/lib/features/palette';",
                        "import CreateModule from 'diagram-js/lib/features/create';",
                        "import SpaceToolModule from '../space-tool';",
                        "import LassoToolModule from 'diagram-js/lib/features/lasso-tool';",
                        "import HandToolModule from 'diagram-js/lib/features/hand-tool';",
                        "import GlobalConnectModule from 'diagram-js/lib/features/global-connect';",
                        "import translate from 'diagram-js/lib/i18n/translate';",
                        "",
                        "import PaletteProvider from './PaletteProvider';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    PaletteModule,",
                        "    CreateModule,",
                        "    SpaceToolModule,",
                        "    LassoToolModule,",
                        "    HandToolModule,",
                        "    GlobalConnectModule,",
                        "    translate",
                        "  ],",
                        "  __init__: [ 'paletteProvider' ],",
                        "  paletteProvider: [ 'type', PaletteProvider ]",
                        "};"
                    ]
                }
            },
            "popup-menu": {
                "ReplaceMenuProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  getBusinessObject,",
                        "  is",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  isEventSubProcess,",
                        "  isExpanded",
                        "} from '../../util/DiUtil';",
                        "",
                        "import {",
                        "  isDifferentType",
                        "} from './util/TypeUtil';",
                        "",
                        "import {",
                        "  forEach,",
                        "  filter,",
                        "  isArray",
                        "} from 'min-dash';",
                        "",
                        "import * as replaceOptions from '../replace/ReplaceOptions';",
                        "import { canBeNonInterrupting, getInterruptingProperty } from '../modeling/behavior/util/NonInterruptingUtil';",
                        "import Icons from './util/Icons';",
                        "",
                        "/**",
                        " * @typedef {import('../modeling/BpmnFactory').default} BpmnFactory",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').default} PopupMenu",
                        " * @typedef {import('../modeling/Modeling').default} Modeling",
                        " * @typedef {import('../replace/BpmnReplace').default} BpmnReplace",
                        " * @typedef {import('diagram-js/lib/features/Rules').default} Rules",
                        " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                        " * @typedef {import('../copy-paste/ModdleCopy').default} ModdleCopy",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Moddle} Moddle",
                        " *",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenuProvider').PopupMenuEntries} PopupMenuEntries",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenuProvider').PopupMenuEntry} PopupMenuEntry",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenuProvider').PopupMenuEntryAction} PopupMenuEntryAction",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenuProvider').PopupMenuHeaderEntries} PopupMenuHeaderEntries",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenuProvider').default} PopupMenuProvider",
                        " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').PopupMenuTarget} PopupMenuTarget",
                        " *",
                        " * @typedef {import('./ReplaceOptions').ReplaceOption} ReplaceOption",
                        " */",
                        "",
                        "/**",
                        " * A BPMN-specific popup menu provider.",
                        " *",
                        " * @implements {PopupMenuProvider}",
                        " *",
                        " * @param {BpmnFactory} bpmnFactory",
                        " * @param {PopupMenu} popupMenu",
                        " * @param {Modeling} modeling",
                        " * @param {Moddle} moddle",
                        " * @param {BpmnReplace} bpmnReplace",
                        " * @param {Rules} rules",
                        " * @param {Translate} translate",
                        " * @param {ModdleCopy} moddleCopy",
                        " */",
                        "export default function ReplaceMenuProvider(",
                        "    bpmnFactory, popupMenu, modeling, moddle,",
                        "    bpmnReplace, rules, translate, moddleCopy) {",
                        "",
                        "  this._bpmnFactory = bpmnFactory;",
                        "  this._popupMenu = popupMenu;",
                        "  this._modeling = modeling;",
                        "  this._moddle = moddle;",
                        "  this._bpmnReplace = bpmnReplace;",
                        "  this._rules = rules;",
                        "  this._translate = translate;",
                        "  this._moddleCopy = moddleCopy;",
                        "",
                        "  this._register();",
                        "}",
                        "",
                        "ReplaceMenuProvider.$inject = [",
                        "  'bpmnFactory',",
                        "  'popupMenu',",
                        "  'modeling',",
                        "  'moddle',",
                        "  'bpmnReplace',",
                        "  'rules',",
                        "  'translate',",
                        "  'moddleCopy'",
                        "];",
                        "",
                        "ReplaceMenuProvider.prototype._register = function() {",
                        "  this._popupMenu.registerProvider('bpmn-replace', this);",
                        "};",
                        "",
                        "/**",
                        " * @param {PopupMenuTarget} target",
                        " *",
                        " * @return {PopupMenuEntries}",
                        " */",
                        "ReplaceMenuProvider.prototype.getPopupMenuEntries = function(target) {",
                        "",
                        "  var businessObject = target.businessObject;",
                        "",
                        "  var rules = this._rules;",
                        "",
                        "  var filteredReplaceOptions = [];",
                        "",
                        "  if (isArray(target) || !rules.allowed('shape.replace', { element: target })) {",
                        "    return {};",
                        "  }",
                        "",
                        "  var differentType = isDifferentType(target);",
                        "",
                        "  if (is(businessObject, 'bpmn:DataObjectReference')) {",
                        "    return this._createEntries(target, replaceOptions.DATA_OBJECT_REFERENCE);",
                        "  }",
                        "",
                        "  if (is(businessObject, 'bpmn:DataStoreReference') && !is(target.parent, 'bpmn:Collaboration')) {",
                        "    return this._createEntries(target, replaceOptions.DATA_STORE_REFERENCE);",
                        "  }",
                        "",
                        "  // start events outside sub processes",
                        "  if (is(businessObject, 'bpmn:StartEvent') && !is(businessObject.$parent, 'bpmn:SubProcess')) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.START_EVENT, differentType);",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // expanded/collapsed pools",
                        "  if (is(businessObject, 'bpmn:Participant')) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.PARTICIPANT, function(replaceOption) {",
                        "      return isExpanded(target) !== replaceOption.target.isExpanded;",
                        "    });",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // start events inside event sub processes",
                        "  if (is(businessObject, 'bpmn:StartEvent') && isEventSubProcess(businessObject.$parent)) {",
                        "    filteredReplaceOptions = filter(replaceOptions.EVENT_SUB_PROCESS_START_EVENT, function(replaceOption) {",
                        "",
                        "      var target = replaceOption.target;",
                        "",
                        "      var isInterrupting = target.isInterrupting !== false;",
                        "",
                        "      var isInterruptingEqual = businessObject.isInterrupting === isInterrupting;",
                        "",
                        "      // filters elements which types and event definition are equal but have have different interrupting types",
                        "      return differentType(replaceOption) || !differentType(replaceOption) && !isInterruptingEqual;",
                        "",
                        "    });",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // start events inside sub processes",
                        "  if (is(businessObject, 'bpmn:StartEvent') && !isEventSubProcess(businessObject.$parent)",
                        "      && is(businessObject.$parent, 'bpmn:SubProcess')) {",
                        "    filteredReplaceOptions = filter(replaceOptions.START_EVENT_SUB_PROCESS, differentType);",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // end events",
                        "  if (is(businessObject, 'bpmn:EndEvent')) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.END_EVENT, function(replaceOption) {",
                        "      var target = replaceOption.target;",
                        "",
                        "      // hide cancel end events outside transactions",
                        "      if (target.eventDefinitionType == 'bpmn:CancelEventDefinition' && !is(businessObject.$parent, 'bpmn:Transaction')) {",
                        "        return false;",
                        "      }",
                        "",
                        "      return differentType(replaceOption);",
                        "    });",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // boundary events",
                        "  if (is(businessObject, 'bpmn:BoundaryEvent')) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.BOUNDARY_EVENT, function(replaceOption) {",
                        "",
                        "      var target = replaceOption.target;",
                        "",
                        "      if (target.eventDefinitionType == 'bpmn:CancelEventDefinition' &&",
                        "         !is(businessObject.attachedToRef, 'bpmn:Transaction')) {",
                        "        return false;",
                        "      }",
                        "      var cancelActivity = target.cancelActivity !== false;",
                        "",
                        "      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;",
                        "",
                        "      return differentType(replaceOption) || !differentType(replaceOption) && !isCancelActivityEqual;",
                        "    });",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // intermediate events",
                        "  if (is(businessObject, 'bpmn:IntermediateCatchEvent') ||",
                        "      is(businessObject, 'bpmn:IntermediateThrowEvent')) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.INTERMEDIATE_EVENT, differentType);",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // gateways",
                        "  if (is(businessObject, 'bpmn:Gateway')) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.GATEWAY, differentType);",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // transactions",
                        "  if (is(businessObject, 'bpmn:Transaction')) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.TRANSACTION, differentType);",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // expanded event sub processes",
                        "  if (isEventSubProcess(businessObject) && isExpanded(target)) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.EVENT_SUB_PROCESS, differentType);",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // expanded sub processes",
                        "  if (is(businessObject, 'bpmn:SubProcess') && isExpanded(target)) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.SUBPROCESS_EXPANDED, differentType);",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // collapsed ad hoc sub processes",
                        "  if (is(businessObject, 'bpmn:AdHocSubProcess') && !isExpanded(target)) {",
                        "",
                        "    filteredReplaceOptions = filter(replaceOptions.TASK, function(replaceOption) {",
                        "",
                        "      var target = replaceOption.target;",
                        "",
                        "      var isTargetSubProcess = target.type === 'bpmn:SubProcess';",
                        "",
                        "      var isTargetExpanded = target.isExpanded === true;",
                        "",
                        "      return isDifferentType(target, target) && (!isTargetSubProcess || isTargetExpanded);",
                        "    });",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  // sequence flows",
                        "  if (is(businessObject, 'bpmn:SequenceFlow')) {",
                        "    return this._createSequenceFlowEntries(target, replaceOptions.SEQUENCE_FLOW);",
                        "  }",
                        "",
                        "  // flow nodes",
                        "  if (is(businessObject, 'bpmn:FlowNode')) {",
                        "    filteredReplaceOptions = filter(replaceOptions.TASK, differentType);",
                        "",
                        "    // collapsed sub process cannot be replaced with itself",
                        "    if (is(businessObject, 'bpmn:SubProcess') && !isExpanded(target)) {",
                        "      filteredReplaceOptions = filter(filteredReplaceOptions, function(replaceOption) {",
                        "        return replaceOption.label !== 'Sub Process (collapsed)';",
                        "      });",
                        "    }",
                        "",
                        "    return this._createEntries(target, filteredReplaceOptions);",
                        "  }",
                        "",
                        "  return {};",
                        "};",
                        "",
                        "/**",
                        " * @param {PopupMenuTarget} target",
                        " *",
                        " * @return {PopupMenuHeaderEntries}",
                        " */",
                        "ReplaceMenuProvider.prototype.getPopupMenuHeaderEntries = function(target) {",
                        "",
                        "  var headerEntries = {};",
                        "",
                        "  if (is(target, 'bpmn:Activity') && !isEventSubProcess(target)) {",
                        "    headerEntries = {",
                        "      ...headerEntries,",
                        "      ...this._getLoopCharacteristicsHeaderEntries(target)",
                        "    };",
                        "  }",
                        "",
                        "  if (is(target, 'bpmn:DataObjectReference')) {",
                        "    headerEntries = {",
                        "      ...headerEntries,",
                        "      ...this._getCollectionHeaderEntries(target)",
                        "    };",
                        "  }",
                        "",
                        "  if (is(target, 'bpmn:Participant')) {",
                        "    headerEntries = {",
                        "      ...headerEntries,",
                        "      ...this._getParticipantMultiplicityHeaderEntries(target)",
                        "    };",
                        "  }",
                        "",
                        "  if (is(target, 'bpmn:SubProcess') &&",
                        "      !is(target, 'bpmn:Transaction') &&",
                        "      !isEventSubProcess(target)) {",
                        "    headerEntries = {",
                        "      ...headerEntries,",
                        "      ...this._getAdHocHeaderEntries(target)",
                        "    };",
                        "  }",
                        "",
                        "  if (canBeNonInterrupting(target)) {",
                        "    headerEntries = {",
                        "      ...headerEntries,",
                        "      ...this._getNonInterruptingHeaderEntries(target)",
                        "    };",
                        "  }",
                        "",
                        "  return headerEntries;",
                        "};",
                        "",
                        "",
                        "/**",
                        " * Create popup menu entries for the given target.",
                        " *",
                        " * @param  {PopupMenuTarget} target",
                        " * @param  {ReplaceOption[]} replaceOptions",
                        " *",
                        " * @return {PopupMenuEntries}",
                        " */",
                        "ReplaceMenuProvider.prototype._createEntries = function(target, replaceOptions) {",
                        "  var entries = {};",
                        "",
                        "  var self = this;",
                        "",
                        "  forEach(replaceOptions, function(replaceOption) {",
                        "    entries[ replaceOption.actionName ] = self._createEntry(replaceOption, target);",
                        "  });",
                        "",
                        "  return entries;",
                        "};",
                        "",
                        "/**",
                        " * Creates popup menu entries for the given sequence flow.",
                        " *",
                        " * @param  {PopupMenuTarget} target",
                        " * @param  {ReplaceOption[]} replaceOptions",
                        " *",
                        " * @return {PopupMenuEntries}",
                        " */",
                        "ReplaceMenuProvider.prototype._createSequenceFlowEntries = function(target, replaceOptions) {",
                        "",
                        "  var businessObject = getBusinessObject(target);",
                        "",
                        "  var entries = {};",
                        "",
                        "  var modeling = this._modeling,",
                        "      moddle = this._moddle;",
                        "",
                        "  var self = this;",
                        "",
                        "  forEach(replaceOptions, function(replaceOption) {",
                        "",
                        "    switch (replaceOption.actionName) {",
                        "    case 'replace-with-default-flow':",
                        "      if (businessObject.sourceRef.default !== businessObject &&",
                        "            (is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||",
                        "             is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||",
                        "             is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||",
                        "             is(businessObject.sourceRef, 'bpmn:Activity'))) {",
                        "",
                        "        entries = {",
                        "          ...entries,",
                        "          [ replaceOption.actionName ]: self._createEntry(replaceOption, target, function() {",
                        "            modeling.updateProperties(target.source, { default: businessObject });",
                        "          })",
                        "        };",
                        "      }",
                        "      break;",
                        "    case 'replace-with-conditional-flow':",
                        "      if (!businessObject.conditionExpression && is(businessObject.sourceRef, 'bpmn:Activity')) {",
                        "",
                        "        entries = {",
                        "          ...entries,",
                        "          [ replaceOption.actionName ]: self._createEntry(replaceOption, target, function() {",
                        "            var conditionExpression = moddle.create('bpmn:FormalExpression', { body: '' });",
                        "",
                        "            modeling.updateProperties(target, { conditionExpression: conditionExpression });",
                        "          })",
                        "        };",
                        "      }",
                        "      break;",
                        "    default:",
                        "",
                        "      // conditional flow -> sequence flow",
                        "      if (is(businessObject.sourceRef, 'bpmn:Activity') && businessObject.conditionExpression) {",
                        "        entries = {",
                        "          ...entries,",
                        "          [ replaceOption.actionName ]: self._createEntry(replaceOption, target, function() {",
                        "            modeling.updateProperties(target, { conditionExpression: undefined });",
                        "          })",
                        "        };",
                        "      }",
                        "",
                        "      // default flow -> sequence flow",
                        "      if ((is(businessObject.sourceRef, 'bpmn:ExclusiveGateway') ||",
                        "           is(businessObject.sourceRef, 'bpmn:InclusiveGateway') ||",
                        "           is(businessObject.sourceRef, 'bpmn:ComplexGateway') ||",
                        "           is(businessObject.sourceRef, 'bpmn:Activity')) &&",
                        "           businessObject.sourceRef.default === businessObject) {",
                        "        entries = {",
                        "          ...entries,",
                        "          [ replaceOption.actionName ]: self._createEntry(replaceOption, target, function() {",
                        "            modeling.updateProperties(target.source, { default: undefined });",
                        "          })",
                        "        };",
                        "      }",
                        "    }",
                        "  });",
                        "",
                        "  return entries;",
                        "};",
                        "",
                        "/**",
                        " * Create a popup menu entry for the given replace option.",
                        " *",
                        " * @param  {ReplaceOption} replaceOption",
                        " * @param  {PopupMenuTarget} target",
                        " * @param  {PopupMenuEntryAction} [action]",
                        " *",
                        " * @return {PopupMenuEntry}",
                        " */",
                        "ReplaceMenuProvider.prototype._createEntry = function(replaceOption, target, action) {",
                        "  var translate = this._translate;",
                        "  var replaceElement = this._bpmnReplace.replaceElement;",
                        "",
                        "  var replaceAction = function() {",
                        "    return replaceElement(target, replaceOption.target);",
                        "  };",
                        "",
                        "  var label = replaceOption.label;",
                        "  if (label && typeof label === 'function') {",
                        "    label = label(target);",
                        "  }",
                        "",
                        "  action = action || replaceAction;",
                        "",
                        "  return {",
                        "    label: translate(label),",
                        "    className: replaceOption.className,",
                        "    action: action",
                        "  };",
                        "};",
                        "",
                        "/**",
                        " * Get popup menu header entries for the loop characteristics of the given BPMN element.",
                        " *",
                        " * @param  {PopupMenuTarget} target",
                        " *",
                        " * @return {PopupMenuHeaderEntries}",
                        " */",
                        "ReplaceMenuProvider.prototype._getLoopCharacteristicsHeaderEntries = function(target) {",
                        "",
                        "  var self = this;",
                        "  var translate = this._translate;",
                        "",
                        "  function toggleLoopEntry(event, entry) {",
                        "",
                        "    // remove",
                        "    if (entry.active) {",
                        "      self._modeling.updateProperties(target, { loopCharacteristics: undefined });",
                        "      return;",
                        "    }",
                        "",
                        "    const currentLoopCharacteristics = target.businessObject.get('loopCharacteristics'),",
                        "          newLoopCharacteristics = self._moddle.create(entry.options.loopCharacteristics);",
                        "",
                        "    // copy old properties",
                        "    if (currentLoopCharacteristics) {",
                        "      self._moddleCopy.copyElement(currentLoopCharacteristics, newLoopCharacteristics);",
                        "    }",
                        "",
                        "    // update `isSequential` property",
                        "    newLoopCharacteristics.set('isSequential', entry.options.isSequential);",
                        "",
                        "    self._modeling.updateProperties(target, { loopCharacteristics: newLoopCharacteristics });",
                        "  }",
                        "",
                        "  var businessObject = getBusinessObject(target),",
                        "      loopCharacteristics = businessObject.loopCharacteristics;",
                        "",
                        "  var isSequential,",
                        "      isLoop,",
                        "      isParallel;",
                        "",
                        "  if (loopCharacteristics) {",
                        "    isSequential = loopCharacteristics.isSequential;",
                        "    isLoop = loopCharacteristics.isSequential === undefined;",
                        "    isParallel = loopCharacteristics.isSequential !== undefined && !loopCharacteristics.isSequential;",
                        "  }",
                        "",
                        "",
                        "  return {",
                        "    'toggle-parallel-mi' : {",
                        "      className: 'bpmn-icon-parallel-mi-marker',",
                        "      title: translate('Parallel Multi Instance'),",
                        "      active: isParallel,",
                        "      action: toggleLoopEntry,",
                        "      options: {",
                        "        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',",
                        "        isSequential: false",
                        "      }",
                        "    },",
                        "    'toggle-sequential-mi': {",
                        "      className: 'bpmn-icon-sequential-mi-marker',",
                        "      title: translate('Sequential Multi Instance'),",
                        "      active: isSequential,",
                        "      action: toggleLoopEntry,",
                        "      options: {",
                        "        loopCharacteristics: 'bpmn:MultiInstanceLoopCharacteristics',",
                        "        isSequential: true",
                        "      }",
                        "    },",
                        "    'toggle-loop': {",
                        "      className: 'bpmn-icon-loop-marker',",
                        "      title: translate('Loop'),",
                        "      active: isLoop,",
                        "      action: toggleLoopEntry,",
                        "      options: {",
                        "        loopCharacteristics: 'bpmn:StandardLoopCharacteristics'",
                        "      }",
                        "    }",
                        "  };",
                        "};",
                        "",
                        "/**",
                        " * Get popup menu header entries for the collection property of the given BPMN element.",
                        " *",
                        " * @param  {PopupMenuTarget} target",
                        " *",
                        " * @return {PopupMenuHeaderEntries}",
                        " */",
                        "ReplaceMenuProvider.prototype._getCollectionHeaderEntries = function(target) {",
                        "",
                        "  var self = this;",
                        "  var translate = this._translate;",
                        "",
                        "  var dataObject = target.businessObject.dataObjectRef;",
                        "",
                        "  if (!dataObject) {",
                        "    return {};",
                        "  }",
                        "",
                        "  function toggleIsCollection(event, entry) {",
                        "    self._modeling.updateModdleProperties(",
                        "      target,",
                        "      dataObject,",
                        "      { isCollection: !entry.active });",
                        "  }",
                        "",
                        "  var isCollection = dataObject.isCollection;",
                        "",
                        "  return {",
                        "    'toggle-is-collection': {",
                        "      className: 'bpmn-icon-parallel-mi-marker',",
                        "      title: translate('Collection'),",
                        "      active: isCollection,",
                        "      action: toggleIsCollection,",
                        "    }",
                        "  };",
                        "};",
                        "",
                        "/**",
                        " * Get popup menu header entries for the participant multiplicity property of the given BPMN element.",
                        " *",
                        " * @param  {PopupMenuTarget} target",
                        " *",
                        " * @return {PopupMenuHeaderEntries}",
                        " */",
                        "ReplaceMenuProvider.prototype._getParticipantMultiplicityHeaderEntries = function(target) {",
                        "",
                        "  var self = this;",
                        "  var bpmnFactory = this._bpmnFactory;",
                        "  var translate = this._translate;",
                        "",
                        "  function toggleParticipantMultiplicity(event, entry) {",
                        "    var isActive = entry.active;",
                        "    var participantMultiplicity;",
                        "",
                        "    if (!isActive) {",
                        "      participantMultiplicity = bpmnFactory.create('bpmn:ParticipantMultiplicity');",
                        "    }",
                        "",
                        "    self._modeling.updateProperties(",
                        "      target,",
                        "      { participantMultiplicity: participantMultiplicity });",
                        "  }",
                        "",
                        "  var participantMultiplicity = target.businessObject.participantMultiplicity;",
                        "",
                        "  return {",
                        "    'toggle-participant-multiplicity': {",
                        "      className: 'bpmn-icon-parallel-mi-marker',",
                        "      title: translate('Participant Multiplicity'),",
                        "      active: !!participantMultiplicity,",
                        "      action: toggleParticipantMultiplicity,",
                        "    }",
                        "  };",
                        "};",
                        "",
                        "/**",
                        " * Get popup menu header entries for the ad-hoc property of the given BPMN element.",
                        " *",
                        " * @param  {PopupMenuTarget} element",
                        " *",
                        " * @return {PopupMenuHeaderEntries}",
                        " */",
                        "ReplaceMenuProvider.prototype._getAdHocHeaderEntries = function(element) {",
                        "  var translate = this._translate;",
                        "  var businessObject = getBusinessObject(element);",
                        "",
                        "  var isAdHoc = is(businessObject, 'bpmn:AdHocSubProcess');",
                        "",
                        "  var replaceElement = this._bpmnReplace.replaceElement;",
                        "",
                        "  return {",
                        "    'toggle-adhoc': {",
                        "      className: 'bpmn-icon-ad-hoc-marker',",
                        "      title: translate('Ad-hoc'),",
                        "      active: isAdHoc,",
                        "      action: function(event, entry) {",
                        "        if (isAdHoc) {",
                        "          return replaceElement(element, { type: 'bpmn:SubProcess' }, {",
                        "            autoResize: false,",
                        "            layoutConnection: false",
                        "          });",
                        "        } else {",
                        "          return replaceElement(element, { type: 'bpmn:AdHocSubProcess' }, {",
                        "            autoResize: false,",
                        "            layoutConnection: false",
                        "          });",
                        "        }",
                        "      }",
                        "    }",
                        "  };",
                        "};",
                        "",
                        "",
                        "ReplaceMenuProvider.prototype._getNonInterruptingHeaderEntries = function(element) {",
                        "  const translate = this._translate;",
                        "  const businessObject = getBusinessObject(element);",
                        "  const self = this;",
                        "",
                        "  const interruptingProperty = getInterruptingProperty(element);",
                        "",
                        "  const icon = is(element, 'bpmn:BoundaryEvent') ? Icons['intermediate-event-non-interrupting'] : Icons['start-event-non-interrupting'];",
                        "",
                        "  const isNonInterrupting = !businessObject[interruptingProperty];",
                        "",
                        "  return {",
                        "    'toggle-non-interrupting': {",
                        "      imageHtml: icon,",
                        "      title: translate('Toggle Non-Interrupting'),",
                        "      active: isNonInterrupting,",
                        "      action: function() {",
                        "        self._modeling.updateProperties(element, {",
                        "          [interruptingProperty]: !!isNonInterrupting",
                        "        });",
                        "      }",
                        "    }",
                        "  };",
                        "};"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import PopupMenuModule from 'diagram-js/lib/features/popup-menu';",
                        "import ReplaceModule from '../replace';",
                        "",
                        "import ReplaceMenuProvider from './ReplaceMenuProvider';",
                        "import AutoPlaceModule from '../auto-place';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    PopupMenuModule,",
                        "    ReplaceModule,",
                        "    AutoPlaceModule",
                        "  ],",
                        "  __init__: [",
                        "    'replaceMenuProvider'",
                        "  ],",
                        "  replaceMenuProvider: [ 'type', ReplaceMenuProvider ]",
                        "};"
                    ]
                },
                "util": {
                    "Icons.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "export default {",
                            "  'start-event-non-interrupting': `",
                            "  <svg viewBox=\"0 0 2048 2048\" xmlns=\"http://www.w3.org/2000/svg\">",
                            "    <g transform=\"translate(0 995.64)\">",
                            "      <path d=\"m1899 28.357c21.545 567.43-598.38 1023.5-1133.6 835.92-548.09-147.21-801.57-873.95-463.59-1330 302.62-480.3 1071.7-507.54 1407.6-49.847 122.14 153.12 190.07 348.07 189.59 543.91z\" fill=\"none\" stroke=\"currentColor\" stroke-dasharray=\"418.310422, 361.2328165\" stroke-linecap=\"round\" stroke-width=\"100\"/>",
                            "    </g>",
                            "  </svg>`,",
                            "  'intermediate-event-non-interrupting': `",
                            "  <svg viewBox=\"0 0 2048 2048\" xmlns=\"http://www.w3.org/2000/svg\">",
                            "     <g transform=\"translate(0 995.64)\" fill=\"none\" stroke=\"currentColor\" stroke-linecap=\"round\">",
                            "        <circle cx=\"1024\" cy=\"28.357\" r=\"875\" stroke-dasharray=\"418.310422, 361.2328165\" stroke-width=\"100\"/>",
                            "        <circle cx=\"1024\" cy=\"28.357\" r=\"685\" stroke-dasharray=\"348.31044857,261.23283643\" stroke-dashoffset=\"500\" stroke-width=\"100\"/>",
                            "     </g>",
                            "  </svg>`",
                            "};"
                        ]
                    },
                    "TypeUtil.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import {",
                            "  getBusinessObject",
                            "} from '../../../util/ModelUtil';",
                            "",
                            "import {",
                            "  isExpanded",
                            "} from '../../../util/DiUtil';",
                            "",
                            "/**",
                            " * @typedef {import('../../../model/Types').Element} Element",
                            " * @typedef {import('diagram-js/lib/features/popup-menu/PopupMenu').PopupMenuTarget} PopupMenuTarget",
                            " *",
                            " * @typedef {(entry: PopupMenuTarget) => boolean} DifferentTypeValidator",
                            " */",
                            "",
                            "/**",
                            " * Returns true, if an element is from a different type",
                            " * than a target definition. Takes into account the type,",
                            " * event definition type and triggeredByEvent property.",
                            " *",
                            " * @param {Element} element",
                            " *",
                            " * @return {DifferentTypeValidator}",
                            " */",
                            "export function isDifferentType(element) {",
                            "",
                            "  return function(entry) {",
                            "    var target = entry.target;",
                            "",
                            "    var businessObject = getBusinessObject(element),",
                            "        eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];",
                            "",
                            "    var isTypeEqual = businessObject.$type === target.type;",
                            "",
                            "    var isEventDefinitionEqual = (",
                            "      (eventDefinition && eventDefinition.$type) === target.eventDefinitionType",
                            "    );",
                            "",
                            "    var isTriggeredByEventEqual = (",
                            "",
                            "      // coherse to <false>",
                            "      !!target.triggeredByEvent === !!businessObject.triggeredByEvent",
                            "    );",
                            "",
                            "    var isExpandedEqual = (",
                            "      target.isExpanded === undefined ||",
                            "      target.isExpanded === isExpanded(element)",
                            "    );",
                            "",
                            "    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;",
                            "  };",
                            "}"
                        ]
                    }
                }
            },
            "replace": {
                "BpmnReplace.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  pick,",
                        "  assign,",
                        "  filter,",
                        "  forEach,",
                        "  isArray,",
                        "  isUndefined,",
                        "  has",
                        "} from 'min-dash';",
                        "",
                        "import {",
                        "  is,",
                        "  getBusinessObject",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  isAny",
                        "} from '../modeling/util/ModelingUtil';",
                        "",
                        "import {",
                        "  isExpanded,",
                        "  isEventSubProcess",
                        "} from '../../util/DiUtil';",
                        "",
                        "import { getPropertyNames } from '../copy-paste/ModdleCopy';",
                        "",
                        "/**",
                        " * @typedef {import('../modeling/BpmnFactory').default} BpmnFactory",
                        " * @typedef {import('../modeling/ElementFactory').default} ElementFactory",
                        " * @typedef {import('../copy-paste/ModdleCopy').default} ModdleCopy",
                        " * @typedef {import('../modeling/Modeling').default} Modeling",
                        " * @typedef {import('diagram-js/lib/features/replace/Replace').default} Replace",
                        " * @typedef {import('diagram-js/lib/features/rules/Rules').default} Rules",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " * @typedef {import('../../model/Types').ModdleElement} ModdleElement",
                        " *",
                        " * @typedef { {",
                        " *   type: string;",
                        " *   cancelActivity: boolean;",
                        " *   instantiate: boolean;",
                        " *   eventGatewayType: string;",
                        " *   triggeredByEvent: boolean;",
                        " *   isInterrupting: boolean;",
                        " *   collapsed: boolean;",
                        " *   isExpanded: boolean;",
                        " *   eventDefinitionType: string;",
                        " *   eventDefinitionAttrs: Object;",
                        " *   host: Shape;",
                        " * } } TargetElement",
                        " *",
                        " * @typedef { {",
                        " *   moveChildren: boolean;",
                        " * } & Record<string, any> } Hints",
                        " */",
                        "",
                        "function copyProperties(source, target, properties) {",
                        "  if (!isArray(properties)) {",
                        "    properties = [ properties ];",
                        "  }",
                        "",
                        "  forEach(properties, function(property) {",
                        "    if (!isUndefined(source[property])) {",
                        "      target[property] = source[property];",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "",
                        "var CUSTOM_PROPERTIES = [",
                        "  'cancelActivity',",
                        "  'instantiate',",
                        "  'eventGatewayType',",
                        "  'triggeredByEvent',",
                        "  'isInterrupting'",
                        "];",
                        "",
                        "/**",
                        " * Check if element should be collapsed or expanded.",
                        " */",
                        "function shouldToggleCollapsed(element, targetElement) {",
                        "",
                        "  var oldCollapsed = (",
                        "    element && has(element, 'collapsed') ? element.collapsed : !isExpanded(element)",
                        "  );",
                        "",
                        "  var targetCollapsed;",
                        "",
                        "  if (targetElement && (has(targetElement, 'collapsed') || has(targetElement, 'isExpanded'))) {",
                        "",
                        "    // property is explicitly set so use it",
                        "    targetCollapsed = (",
                        "      has(targetElement, 'collapsed') ? targetElement.collapsed : !targetElement.isExpanded",
                        "    );",
                        "  } else {",
                        "",
                        "    // keep old state",
                        "    targetCollapsed = oldCollapsed;",
                        "  }",
                        "",
                        "  if (oldCollapsed !== targetCollapsed) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "",
                        "/**",
                        " * BPMN-specific replace.",
                        " *",
                        " * @param {BpmnFactory} bpmnFactory",
                        " * @param {ElementFactory} elementFactory",
                        " * @param {ModdleCopy} moddleCopy",
                        " * @param {Modeling} modeling",
                        " * @param {Replace} replace",
                        " * @param {Rules} rules",
                        " */",
                        "export default function BpmnReplace(",
                        "    bpmnFactory,",
                        "    elementFactory,",
                        "    moddleCopy,",
                        "    modeling,",
                        "    replace,",
                        "    rules",
                        ") {",
                        "",
                        "  /**",
                        "   * Prepares a new business object for the replacement element",
                        "   * and triggers the replace operation.",
                        "   *",
                        "   * @param  {Element} element",
                        "   * @param  {TargetElement} targetElement",
                        "   * @param  {Hints} [hints]",
                        "   *",
                        "   * @return {Element}",
                        "   */",
                        "  function replaceElement(element, targetElement, hints) {",
                        "",
                        "    hints = hints || {};",
                        "",
                        "    var type = targetElement.type,",
                        "        oldBusinessObject = element.businessObject;",
                        "",
                        "    if (isSubProcess(oldBusinessObject) && type === 'bpmn:SubProcess') {",
                        "      if (shouldToggleCollapsed(element, targetElement)) {",
                        "",
                        "        // expanding or collapsing process",
                        "        modeling.toggleCollapse(element);",
                        "",
                        "        return element;",
                        "      }",
                        "    }",
                        "",
                        "    var newBusinessObject = bpmnFactory.create(type);",
                        "",
                        "    var newElement = {",
                        "      type: type,",
                        "      businessObject: newBusinessObject,",
                        "    };",
                        "",
                        "    newElement.di = {};",
                        "",
                        "    // colors will be set to DI",
                        "    copyProperties(element.di, newElement.di, [",
                        "      'fill',",
                        "      'stroke',",
                        "      'background-color',",
                        "      'border-color',",
                        "      'color'",
                        "    ]);",
                        "",
                        "    var elementProps = getPropertyNames(oldBusinessObject.$descriptor),",
                        "        newElementProps = getPropertyNames(newBusinessObject.$descriptor, true),",
                        "        copyProps = intersection(elementProps, newElementProps);",
                        "",
                        "    // initialize special properties defined in target definition",
                        "    assign(newBusinessObject, pick(targetElement, CUSTOM_PROPERTIES));",
                        "",
                        "    var properties = filter(copyProps, function(propertyName) {",
                        "",
                        "      // copying event definitions, unless we replace",
                        "      if (propertyName === 'eventDefinitions') {",
                        "        return hasEventDefinition(element, targetElement.eventDefinitionType);",
                        "      }",
                        "",
                        "      // retain loop characteristics if the target element",
                        "      // is not an event sub process",
                        "      if (propertyName === 'loopCharacteristics') {",
                        "        return !isEventSubProcess(newBusinessObject);",
                        "      }",
                        "",
                        "      // so the applied properties from 'target' don't get lost",
                        "      if (has(newBusinessObject, propertyName)) {",
                        "        return false;",
                        "      }",
                        "",
                        "      if (propertyName === 'processRef' && targetElement.isExpanded === false) {",
                        "        return false;",
                        "      }",
                        "",
                        "      if (propertyName === 'triggeredByEvent') {",
                        "        return false;",
                        "      }",
                        "",
                        "      return true;",
                        "    });",
                        "",
                        "    newBusinessObject = moddleCopy.copyElement(",
                        "      oldBusinessObject,",
                        "      newBusinessObject,",
                        "      properties",
                        "    );",
                        "",
                        "    // initialize custom BPMN extensions",
                        "    if (targetElement.eventDefinitionType) {",
                        "",
                        "      // only initialize with new eventDefinition",
                        "      // if we did not set an event definition yet,",
                        "      // i.e. because we copied it",
                        "      if (!hasEventDefinition(newBusinessObject, targetElement.eventDefinitionType)) {",
                        "        newElement.eventDefinitionType = targetElement.eventDefinitionType;",
                        "        newElement.eventDefinitionAttrs = targetElement.eventDefinitionAttrs;",
                        "      }",
                        "    }",
                        "",
                        "    if (is(oldBusinessObject, 'bpmn:Activity')) {",
                        "",
                        "      if (isSubProcess(oldBusinessObject)) {",
                        "",
                        "        // no toggeling, so keep old state",
                        "        newElement.isExpanded = isExpanded(element);",
                        "      }",
                        "",
                        "      // else if property is explicitly set, use it",
                        "      else if (targetElement && has(targetElement, 'isExpanded')) {",
                        "        newElement.isExpanded = targetElement.isExpanded;",
                        "",
                        "        // assign default size of new expanded element",
                        "        var defaultSize = elementFactory.getDefaultSize(newBusinessObject, {",
                        "          isExpanded: newElement.isExpanded",
                        "        });",
                        "",
                        "        newElement.width = defaultSize.width;",
                        "        newElement.height = defaultSize.height;",
                        "",
                        "        // keep element centered",
                        "        newElement.x = element.x - (newElement.width - element.width) / 2;",
                        "        newElement.y = element.y - (newElement.height - element.height) / 2;",
                        "      }",
                        "",
                        "      // TODO: need also to respect min/max Size",
                        "      // copy size, from an expanded subprocess to an expanded alternative subprocess",
                        "      // except bpmn:Task, because Task is always expanded",
                        "      if ((isExpanded(element) && !is(oldBusinessObject, 'bpmn:Task')) && newElement.isExpanded) {",
                        "        newElement.width = element.width;",
                        "        newElement.height = element.height;",
                        "      }",
                        "    }",
                        "",
                        "    // remove children if not expanding sub process",
                        "    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {",
                        "      hints.moveChildren = false;",
                        "    }",
                        "",
                        "    // transform collapsed/expanded pools",
                        "    if (is(oldBusinessObject, 'bpmn:Participant')) {",
                        "",
                        "      // create expanded pool",
                        "      if (targetElement.isExpanded === true) {",
                        "        newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');",
                        "      } else {",
                        "",
                        "        // remove children when transforming to collapsed pool",
                        "        hints.moveChildren = false;",
                        "      }",
                        "",
                        "      // apply same width and default height",
                        "      newElement.width = element.width;",
                        "      newElement.height = elementFactory.getDefaultSize(newElement).height;",
                        "    }",
                        "",
                        "    if (!rules.allowed('shape.resize', { shape: newBusinessObject })) {",
                        "      newElement.height = elementFactory.getDefaultSize(newElement).height;",
                        "      newElement.width = elementFactory.getDefaultSize(newElement).width;",
                        "    }",
                        "",
                        "    newBusinessObject.name = oldBusinessObject.name;",
                        "",
                        "    // retain default flow's reference between inclusive <-> exclusive gateways and activities",
                        "    if (",
                        "      isAny(oldBusinessObject, [",
                        "        'bpmn:ExclusiveGateway',",
                        "        'bpmn:InclusiveGateway',",
                        "        'bpmn:Activity'",
                        "      ]) &&",
                        "      isAny(newBusinessObject, [",
                        "        'bpmn:ExclusiveGateway',",
                        "        'bpmn:InclusiveGateway',",
                        "        'bpmn:Activity'",
                        "      ])",
                        "    ) {",
                        "      newBusinessObject.default = oldBusinessObject.default;",
                        "    }",
                        "",
                        "    if (",
                        "      targetElement.host &&",
                        "      !is(oldBusinessObject, 'bpmn:BoundaryEvent') &&",
                        "      is(newBusinessObject, 'bpmn:BoundaryEvent')",
                        "    ) {",
                        "      newElement.host = targetElement.host;",
                        "    }",
                        "",
                        "    // The DataStoreReference element is 14px wider than the DataObjectReference element",
                        "    // This ensures that they stay centered on the x axis when replaced",
                        "    if (",
                        "      newElement.type === 'bpmn:DataStoreReference' ||",
                        "      newElement.type === 'bpmn:DataObjectReference'",
                        "    ) {",
                        "      newElement.x = element.x + (element.width - newElement.width) / 2;",
                        "    }",
                        "",
                        "    return replace.replaceElement(element, newElement, { ...hints, targetElement });",
                        "  }",
                        "",
                        "  this.replaceElement = replaceElement;",
                        "}",
                        "",
                        "BpmnReplace.$inject = [",
                        "  'bpmnFactory',",
                        "  'elementFactory',",
                        "  'moddleCopy',",
                        "  'modeling',",
                        "  'replace',",
                        "  'rules'",
                        "];",
                        "",
                        "/**",
                        " * @param {ModdleElement} businessObject",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isSubProcess(businessObject) {",
                        "  return is(businessObject, 'bpmn:SubProcess');",
                        "}",
                        "",
                        "/**",
                        " * @param {Element|ModdleElement} element",
                        " * @param {string} type",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function hasEventDefinition(element, type) {",
                        "  var businessObject = getBusinessObject(element);",
                        "",
                        "  return type && businessObject.get('eventDefinitions').some(function(definition) {",
                        "    return is(definition, type);",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * Compute intersection between two arrays.",
                        " *",
                        " * @param {Array} a",
                        " * @param {Array} b",
                        " *",
                        " * @return {Array}",
                        " */",
                        "function intersection(a, b) {",
                        "  return a.filter(function(item) {",
                        "    return b.includes(item);",
                        "  });",
                        "}"
                    ]
                },
                "ReplaceOptions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * @typedef { () => string } LabelGetter",
                        " *",
                        " * @typedef { {",
                        " *   label: string | LabelGetter;",
                        " *   actionName: string;",
                        " *   className: string;",
                        " *   target?: {",
                        " *     type: string;",
                        " *     isExpanded?: boolean;",
                        " *     isInterrupting?: boolean;",
                        " *     triggeredByEvent?: boolean;",
                        " *     cancelActivity?: boolean;",
                        " *     eventDefinitionType?: string;",
                        " *     eventDefinitionAttrs?: Record<string, any>",
                        " *   };",
                        " * } } ReplaceOption",
                        " */",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var START_EVENT = [",
                        "  {",
                        "    label: 'Start Event',",
                        "    actionName: 'replace-with-none-start',",
                        "    className: 'bpmn-icon-start-event-none',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Intermediate Throw Event',",
                        "    actionName: 'replace-with-none-intermediate-throwing',",
                        "    className: 'bpmn-icon-intermediate-event-none',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'End Event',",
                        "    actionName: 'replace-with-none-end',",
                        "    className: 'bpmn-icon-end-event-none',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Message Start Event',",
                        "    actionName: 'replace-with-message-start',",
                        "    className: 'bpmn-icon-start-event-message',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:MessageEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Timer Start Event',",
                        "    actionName: 'replace-with-timer-start',",
                        "    className: 'bpmn-icon-start-event-timer',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:TimerEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Conditional Start Event',",
                        "    actionName: 'replace-with-conditional-start',",
                        "    className: 'bpmn-icon-start-event-condition',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:ConditionalEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Signal Start Event',",
                        "    actionName: 'replace-with-signal-start',",
                        "    className: 'bpmn-icon-start-event-signal',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:SignalEventDefinition'",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var START_EVENT_SUB_PROCESS = [",
                        "  {",
                        "    label: 'Start Event',",
                        "    actionName: 'replace-with-none-start',",
                        "    className: 'bpmn-icon-start-event-none',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Intermediate Throw Event',",
                        "    actionName: 'replace-with-none-intermediate-throwing',",
                        "    className: 'bpmn-icon-intermediate-event-none',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'End Event',",
                        "    actionName: 'replace-with-none-end',",
                        "    className: 'bpmn-icon-end-event-none',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent'",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var INTERMEDIATE_EVENT = [",
                        "  {",
                        "    label: 'Start Event',",
                        "    actionName: 'replace-with-none-start',",
                        "    className: 'bpmn-icon-start-event-none',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Intermediate Throw Event',",
                        "    actionName: 'replace-with-none-intermediate-throw',",
                        "    className: 'bpmn-icon-intermediate-event-none',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'End Event',",
                        "    actionName: 'replace-with-none-end',",
                        "    className: 'bpmn-icon-end-event-none',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Message Intermediate Catch Event',",
                        "    actionName: 'replace-with-message-intermediate-catch',",
                        "    className: 'bpmn-icon-intermediate-event-catch-message',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateCatchEvent',",
                        "      eventDefinitionType: 'bpmn:MessageEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Message Intermediate Throw Event',",
                        "    actionName: 'replace-with-message-intermediate-throw',",
                        "    className: 'bpmn-icon-intermediate-event-throw-message',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent',",
                        "      eventDefinitionType: 'bpmn:MessageEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Timer Intermediate Catch Event',",
                        "    actionName: 'replace-with-timer-intermediate-catch',",
                        "    className: 'bpmn-icon-intermediate-event-catch-timer',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateCatchEvent',",
                        "      eventDefinitionType: 'bpmn:TimerEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Escalation Intermediate Throw Event',",
                        "    actionName: 'replace-with-escalation-intermediate-throw',",
                        "    className: 'bpmn-icon-intermediate-event-throw-escalation',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent',",
                        "      eventDefinitionType: 'bpmn:EscalationEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Conditional Intermediate Catch Event',",
                        "    actionName: 'replace-with-conditional-intermediate-catch',",
                        "    className: 'bpmn-icon-intermediate-event-catch-condition',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateCatchEvent',",
                        "      eventDefinitionType: 'bpmn:ConditionalEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Link Intermediate Catch Event',",
                        "    actionName: 'replace-with-link-intermediate-catch',",
                        "    className: 'bpmn-icon-intermediate-event-catch-link',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateCatchEvent',",
                        "      eventDefinitionType: 'bpmn:LinkEventDefinition',",
                        "      eventDefinitionAttrs: {",
                        "        name: ''",
                        "      }",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Link Intermediate Throw Event',",
                        "    actionName: 'replace-with-link-intermediate-throw',",
                        "    className: 'bpmn-icon-intermediate-event-throw-link',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent',",
                        "      eventDefinitionType: 'bpmn:LinkEventDefinition',",
                        "      eventDefinitionAttrs: {",
                        "        name: ''",
                        "      }",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Compensation Intermediate Throw Event',",
                        "    actionName: 'replace-with-compensation-intermediate-throw',",
                        "    className: 'bpmn-icon-intermediate-event-throw-compensation',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent',",
                        "      eventDefinitionType: 'bpmn:CompensateEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Signal Intermediate Catch Event',",
                        "    actionName: 'replace-with-signal-intermediate-catch',",
                        "    className: 'bpmn-icon-intermediate-event-catch-signal',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateCatchEvent',",
                        "      eventDefinitionType: 'bpmn:SignalEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Signal Intermediate Throw Event',",
                        "    actionName: 'replace-with-signal-intermediate-throw',",
                        "    className: 'bpmn-icon-intermediate-event-throw-signal',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent',",
                        "      eventDefinitionType: 'bpmn:SignalEventDefinition'",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var END_EVENT = [",
                        "  {",
                        "    label: 'Start Event',",
                        "    actionName: 'replace-with-none-start',",
                        "    className: 'bpmn-icon-start-event-none',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Intermediate Throw Event',",
                        "    actionName: 'replace-with-none-intermediate-throw',",
                        "    className: 'bpmn-icon-intermediate-event-none',",
                        "    target: {",
                        "      type: 'bpmn:IntermediateThrowEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'End Event',",
                        "    actionName: 'replace-with-none-end',",
                        "    className: 'bpmn-icon-end-event-none',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Message End Event',",
                        "    actionName: 'replace-with-message-end',",
                        "    className: 'bpmn-icon-end-event-message',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent',",
                        "      eventDefinitionType: 'bpmn:MessageEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Escalation End Event',",
                        "    actionName: 'replace-with-escalation-end',",
                        "    className: 'bpmn-icon-end-event-escalation',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent',",
                        "      eventDefinitionType: 'bpmn:EscalationEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Error End Event',",
                        "    actionName: 'replace-with-error-end',",
                        "    className: 'bpmn-icon-end-event-error',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent',",
                        "      eventDefinitionType: 'bpmn:ErrorEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Cancel End Event',",
                        "    actionName: 'replace-with-cancel-end',",
                        "    className: 'bpmn-icon-end-event-cancel',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent',",
                        "      eventDefinitionType: 'bpmn:CancelEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Compensation End Event',",
                        "    actionName: 'replace-with-compensation-end',",
                        "    className: 'bpmn-icon-end-event-compensation',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent',",
                        "      eventDefinitionType: 'bpmn:CompensateEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Signal End Event',",
                        "    actionName: 'replace-with-signal-end',",
                        "    className: 'bpmn-icon-end-event-signal',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent',",
                        "      eventDefinitionType: 'bpmn:SignalEventDefinition'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Terminate End Event',",
                        "    actionName: 'replace-with-terminate-end',",
                        "    className: 'bpmn-icon-end-event-terminate',",
                        "    target: {",
                        "      type: 'bpmn:EndEvent',",
                        "      eventDefinitionType: 'bpmn:TerminateEventDefinition'",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var GATEWAY = [",
                        "  {",
                        "    label: 'Exclusive Gateway',",
                        "    actionName: 'replace-with-exclusive-gateway',",
                        "    className: 'bpmn-icon-gateway-xor',",
                        "    target: {",
                        "      type: 'bpmn:ExclusiveGateway'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Parallel Gateway',",
                        "    actionName: 'replace-with-parallel-gateway',",
                        "    className: 'bpmn-icon-gateway-parallel',",
                        "    target: {",
                        "      type: 'bpmn:ParallelGateway'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Inclusive Gateway',",
                        "    actionName: 'replace-with-inclusive-gateway',",
                        "    className: 'bpmn-icon-gateway-or',",
                        "    target: {",
                        "      type: 'bpmn:InclusiveGateway'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Complex Gateway',",
                        "    actionName: 'replace-with-complex-gateway',",
                        "    className: 'bpmn-icon-gateway-complex',",
                        "    target: {",
                        "      type: 'bpmn:ComplexGateway'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Event based Gateway',",
                        "    actionName: 'replace-with-event-based-gateway',",
                        "    className: 'bpmn-icon-gateway-eventbased',",
                        "    target: {",
                        "      type: 'bpmn:EventBasedGateway',",
                        "      instantiate: false,",
                        "      eventGatewayType: 'Exclusive'",
                        "    }",
                        "  }",
                        "",
                        "  // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194",
                        "  // {",
                        "  //   label: 'Event based instantiating Gateway',",
                        "  //   actionName: 'replace-with-exclusive-event-based-gateway',",
                        "  //   className: 'bpmn-icon-exclusive-event-based',",
                        "  //   target: {",
                        "  //     type: 'bpmn:EventBasedGateway'",
                        "  //   },",
                        "  //   options: {",
                        "  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }",
                        "  //   }",
                        "  // },",
                        "  // {",
                        "  //   label: 'Parallel Event based instantiating Gateway',",
                        "  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',",
                        "  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',",
                        "  //   target: {",
                        "  //     type: 'bpmn:EventBasedGateway'",
                        "  //   },",
                        "  //   options: {",
                        "  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }",
                        "  //   }",
                        "  // }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var SUBPROCESS_EXPANDED = [",
                        "  {",
                        "    label: 'Transaction',",
                        "    actionName: 'replace-with-transaction',",
                        "    className: 'bpmn-icon-transaction',",
                        "    target: {",
                        "      type: 'bpmn:Transaction',",
                        "      isExpanded: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Event Sub Process',",
                        "    actionName: 'replace-with-event-subprocess',",
                        "    className: 'bpmn-icon-event-subprocess-expanded',",
                        "    target: {",
                        "      type: 'bpmn:SubProcess',",
                        "      triggeredByEvent: true,",
                        "      isExpanded: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Sub Process (collapsed)',",
                        "    actionName: 'replace-with-collapsed-subprocess',",
                        "    className: 'bpmn-icon-subprocess-collapsed',",
                        "    target: {",
                        "      type: 'bpmn:SubProcess',",
                        "      isExpanded: false",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var TRANSACTION = [",
                        "  {",
                        "    label: 'Transaction',",
                        "    actionName: 'replace-with-transaction',",
                        "    className: 'bpmn-icon-transaction',",
                        "    target: {",
                        "      type: 'bpmn:Transaction',",
                        "      isExpanded: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Sub Process',",
                        "    actionName: 'replace-with-subprocess',",
                        "    className: 'bpmn-icon-subprocess-expanded',",
                        "    target: {",
                        "      type: 'bpmn:SubProcess',",
                        "      isExpanded: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Event Sub Process',",
                        "    actionName: 'replace-with-event-subprocess',",
                        "    className: 'bpmn-icon-event-subprocess-expanded',",
                        "    target: {",
                        "      type: 'bpmn:SubProcess',",
                        "      triggeredByEvent: true,",
                        "      isExpanded: true",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var EVENT_SUB_PROCESS = TRANSACTION;",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var TASK = [",
                        "  {",
                        "    label: 'Task',",
                        "    actionName: 'replace-with-task',",
                        "    className: 'bpmn-icon-task',",
                        "    target: {",
                        "      type: 'bpmn:Task'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'User Task',",
                        "    actionName: 'replace-with-user-task',",
                        "    className: 'bpmn-icon-user',",
                        "    target: {",
                        "      type: 'bpmn:UserTask'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Service Task',",
                        "    actionName: 'replace-with-service-task',",
                        "    className: 'bpmn-icon-service',",
                        "    target: {",
                        "      type: 'bpmn:ServiceTask'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Send Task',",
                        "    actionName: 'replace-with-send-task',",
                        "    className: 'bpmn-icon-send',",
                        "    target: {",
                        "      type: 'bpmn:SendTask'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Receive Task',",
                        "    actionName: 'replace-with-receive-task',",
                        "    className: 'bpmn-icon-receive',",
                        "    target: {",
                        "      type: 'bpmn:ReceiveTask'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Manual Task',",
                        "    actionName: 'replace-with-manual-task',",
                        "    className: 'bpmn-icon-manual',",
                        "    target: {",
                        "      type: 'bpmn:ManualTask'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Business Rule Task',",
                        "    actionName: 'replace-with-rule-task',",
                        "    className: 'bpmn-icon-business-rule',",
                        "    target: {",
                        "      type: 'bpmn:BusinessRuleTask'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Script Task',",
                        "    actionName: 'replace-with-script-task',",
                        "    className: 'bpmn-icon-script',",
                        "    target: {",
                        "      type: 'bpmn:ScriptTask'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Call Activity',",
                        "    actionName: 'replace-with-call-activity',",
                        "    className: 'bpmn-icon-call-activity',",
                        "    target: {",
                        "      type: 'bpmn:CallActivity'",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Sub Process (collapsed)',",
                        "    actionName: 'replace-with-collapsed-subprocess',",
                        "    className: 'bpmn-icon-subprocess-collapsed',",
                        "    target: {",
                        "      type: 'bpmn:SubProcess',",
                        "      isExpanded: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Sub Process (expanded)',",
                        "    actionName: 'replace-with-expanded-subprocess',",
                        "    className: 'bpmn-icon-subprocess-expanded',",
                        "    target: {",
                        "      type: 'bpmn:SubProcess',",
                        "      isExpanded: true",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var DATA_OBJECT_REFERENCE = [",
                        "  {",
                        "    label: 'Data Store Reference',",
                        "    actionName: 'replace-with-data-store-reference',",
                        "    className: 'bpmn-icon-data-store',",
                        "    target: {",
                        "      type: 'bpmn:DataStoreReference'",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var DATA_STORE_REFERENCE = [",
                        "  {",
                        "    label: 'Data Object Reference',",
                        "    actionName: 'replace-with-data-object-reference',",
                        "    className: 'bpmn-icon-data-object',",
                        "    target: {",
                        "      type: 'bpmn:DataObjectReference'",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var BOUNDARY_EVENT = [",
                        "  {",
                        "    label: 'Message Boundary Event',",
                        "    actionName: 'replace-with-message-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-message',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:MessageEventDefinition',",
                        "      cancelActivity: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Timer Boundary Event',",
                        "    actionName: 'replace-with-timer-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-timer',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:TimerEventDefinition',",
                        "      cancelActivity: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Escalation Boundary Event',",
                        "    actionName: 'replace-with-escalation-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-escalation',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:EscalationEventDefinition',",
                        "      cancelActivity: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Conditional Boundary Event',",
                        "    actionName: 'replace-with-conditional-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-condition',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:ConditionalEventDefinition',",
                        "      cancelActivity: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Error Boundary Event',",
                        "    actionName: 'replace-with-error-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-error',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:ErrorEventDefinition',",
                        "      cancelActivity: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Cancel Boundary Event',",
                        "    actionName: 'replace-with-cancel-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-cancel',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:CancelEventDefinition',",
                        "      cancelActivity: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Signal Boundary Event',",
                        "    actionName: 'replace-with-signal-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-signal',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:SignalEventDefinition',",
                        "      cancelActivity: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Compensation Boundary Event',",
                        "    actionName: 'replace-with-compensation-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-compensation',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:CompensateEventDefinition',",
                        "      cancelActivity: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Message Boundary Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-message-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-message',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:MessageEventDefinition',",
                        "      cancelActivity: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Timer Boundary Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-timer-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-timer',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:TimerEventDefinition',",
                        "      cancelActivity: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Escalation Boundary Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-escalation-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-escalation',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:EscalationEventDefinition',",
                        "      cancelActivity: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Conditional Boundary Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-conditional-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-condition',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:ConditionalEventDefinition',",
                        "      cancelActivity: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Signal Boundary Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-signal-boundary',",
                        "    className: 'bpmn-icon-intermediate-event-catch-non-interrupting-signal',",
                        "    target: {",
                        "      type: 'bpmn:BoundaryEvent',",
                        "      eventDefinitionType: 'bpmn:SignalEventDefinition',",
                        "      cancelActivity: false",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var EVENT_SUB_PROCESS_START_EVENT = [",
                        "  {",
                        "    label: 'Message Start Event',",
                        "    actionName: 'replace-with-message-start',",
                        "    className: 'bpmn-icon-start-event-message',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:MessageEventDefinition',",
                        "      isInterrupting: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Timer Start Event',",
                        "    actionName: 'replace-with-timer-start',",
                        "    className: 'bpmn-icon-start-event-timer',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:TimerEventDefinition',",
                        "      isInterrupting: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Conditional Start Event',",
                        "    actionName: 'replace-with-conditional-start',",
                        "    className: 'bpmn-icon-start-event-condition',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:ConditionalEventDefinition',",
                        "      isInterrupting: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Signal Start Event',",
                        "    actionName: 'replace-with-signal-start',",
                        "    className: 'bpmn-icon-start-event-signal',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:SignalEventDefinition',",
                        "      isInterrupting: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Error Start Event',",
                        "    actionName: 'replace-with-error-start',",
                        "    className: 'bpmn-icon-start-event-error',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:ErrorEventDefinition',",
                        "      isInterrupting: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Escalation Start Event',",
                        "    actionName: 'replace-with-escalation-start',",
                        "    className: 'bpmn-icon-start-event-escalation',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:EscalationEventDefinition',",
                        "      isInterrupting: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Compensation Start Event',",
                        "    actionName: 'replace-with-compensation-start',",
                        "    className: 'bpmn-icon-start-event-compensation',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:CompensateEventDefinition',",
                        "      isInterrupting: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Message Start Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-message-start',",
                        "    className: 'bpmn-icon-start-event-non-interrupting-message',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:MessageEventDefinition',",
                        "      isInterrupting: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Timer Start Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-timer-start',",
                        "    className: 'bpmn-icon-start-event-non-interrupting-timer',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:TimerEventDefinition',",
                        "      isInterrupting: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Conditional Start Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-conditional-start',",
                        "    className: 'bpmn-icon-start-event-non-interrupting-condition',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:ConditionalEventDefinition',",
                        "      isInterrupting: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Signal Start Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-signal-start',",
                        "    className: 'bpmn-icon-start-event-non-interrupting-signal',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:SignalEventDefinition',",
                        "      isInterrupting: false",
                        "    }",
                        "  },",
                        "  {",
                        "    label: 'Escalation Start Event (non-interrupting)',",
                        "    actionName: 'replace-with-non-interrupting-escalation-start',",
                        "    className: 'bpmn-icon-start-event-non-interrupting-escalation',",
                        "    target: {",
                        "      type: 'bpmn:StartEvent',",
                        "      eventDefinitionType: 'bpmn:EscalationEventDefinition',",
                        "      isInterrupting: false",
                        "    }",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var SEQUENCE_FLOW = [",
                        "  {",
                        "    label: 'Sequence Flow',",
                        "    actionName: 'replace-with-sequence-flow',",
                        "    className: 'bpmn-icon-connection'",
                        "  },",
                        "  {",
                        "    label: 'Default Flow',",
                        "    actionName: 'replace-with-default-flow',",
                        "    className: 'bpmn-icon-default-flow'",
                        "  },",
                        "  {",
                        "    label: 'Conditional Flow',",
                        "    actionName: 'replace-with-conditional-flow',",
                        "    className: 'bpmn-icon-conditional-flow'",
                        "  }",
                        "];",
                        "",
                        "/**",
                        " * @type {ReplaceOption[]}",
                        " */",
                        "export var PARTICIPANT = [",
                        "  {",
                        "    label: 'Expanded Pool',",
                        "    actionName: 'replace-with-expanded-pool',",
                        "    className: 'bpmn-icon-participant',",
                        "    target: {",
                        "      type: 'bpmn:Participant',",
                        "      isExpanded: true",
                        "    }",
                        "  },",
                        "  {",
                        "    label: function(element) {",
                        "      var label = 'Empty Pool';",
                        "",
                        "      if (element.children && element.children.length) {",
                        "        label += ' (removes content)';",
                        "      }",
                        "",
                        "      return label;",
                        "    },",
                        "    actionName: 'replace-with-collapsed-pool',",
                        "",
                        "    // TODO(@janstuemmel): maybe design new icon",
                        "    className: 'bpmn-icon-lane',",
                        "    target: {",
                        "      type: 'bpmn:Participant',",
                        "      isExpanded: false",
                        "    }",
                        "  }",
                        "];"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import CopyPasteModule from '../copy-paste';",
                        "import ReplaceModule from 'diagram-js/lib/features/replace';",
                        "import SelectionModule from 'diagram-js/lib/features/selection';",
                        "",
                        "import BpmnReplace from './BpmnReplace';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    CopyPasteModule,",
                        "    ReplaceModule,",
                        "    SelectionModule",
                        "  ],",
                        "  bpmnReplace: [ 'type', BpmnReplace ]",
                        "};"
                    ]
                }
            },
            "replace-preview": {
                "BpmnReplacePreview.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                        "",
                        "import inherits from 'inherits-browser';",
                        "",
                        "import { escapeCSS as cssEscape } from 'diagram-js/lib/util/EscapeUtil';",
                        "",
                        "import {",
                        "  assign,",
                        "  forEach",
                        "} from 'min-dash';",
                        "",
                        "import {",
                        "  query as domQuery",
                        "} from 'min-dom';",
                        "",
                        "import {",
                        "  attr as svgAttr",
                        "} from 'tiny-svg';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                        " * @typedef {import('diagram-js/lib/core/ElementFactory').default} ElementFactory",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/features/preview-support/PreviewSupport').default} PreviewSupport",
                        " */",
                        "",
                        "var LOW_PRIORITY = 250;",
                        "",
                        "/**",
                        " * @param {EventBus} eventBus",
                        " * @param {ElementRegistry} elementRegistry",
                        " * @param {ElementFactory} elementFactory",
                        " * @param {Canvas} canvas",
                        " * @param {PreviewSupport} previewSupport",
                        " */",
                        "export default function BpmnReplacePreview(",
                        "    eventBus, elementRegistry, elementFactory,",
                        "    canvas, previewSupport) {",
                        "",
                        "  CommandInterceptor.call(this, eventBus);",
                        "",
                        "  /**",
                        "   * Replace the visuals of all elements in the context which can be replaced",
                        "   *",
                        "   * @param  {Object} context",
                        "   */",
                        "  function replaceVisual(context) {",
                        "",
                        "    var replacements = context.canExecute.replacements;",
                        "",
                        "    forEach(replacements, function(replacement) {",
                        "",
                        "      var id = replacement.oldElementId;",
                        "",
                        "      var newElement = {",
                        "        type: replacement.newElementType",
                        "      };",
                        "",
                        "      // if the visual of the element is already replaced",
                        "      if (context.visualReplacements[id]) {",
                        "        return;",
                        "      }",
                        "",
                        "      var element = elementRegistry.get(id);",
                        "",
                        "      assign(newElement, { x: element.x, y: element.y });",
                        "",
                        "      // create a temporary shape",
                        "      var tempShape = elementFactory.createShape(newElement);",
                        "",
                        "      canvas.addShape(tempShape, element.parent);",
                        "",
                        "      // select the original SVG element related to the element and hide it",
                        "      var gfx = domQuery('[data-element-id=\"' + cssEscape(element.id) + '\"]', context.dragGroup);",
                        "",
                        "      if (gfx) {",
                        "        svgAttr(gfx, { display: 'none' });",
                        "      }",
                        "",
                        "      // clone the gfx of the temporary shape and add it to the drag group",
                        "      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);",
                        "",
                        "      context.visualReplacements[id] = dragger;",
                        "",
                        "      canvas.removeShape(tempShape);",
                        "    });",
                        "  }",
                        "",
                        "  /**",
                        "   * Restore the original visuals of the previously replaced elements",
                        "   *",
                        "   * @param  {Object} context",
                        "   */",
                        "  function restoreVisual(context) {",
                        "",
                        "    var visualReplacements = context.visualReplacements;",
                        "",
                        "    forEach(visualReplacements, function(dragger, id) {",
                        "",
                        "      var originalGfx = domQuery('[data-element-id=\"' + cssEscape(id) + '\"]', context.dragGroup);",
                        "",
                        "      if (originalGfx) {",
                        "        svgAttr(originalGfx, { display: 'inline' });",
                        "      }",
                        "",
                        "      dragger.remove();",
                        "",
                        "      if (visualReplacements[id]) {",
                        "        delete visualReplacements[id];",
                        "      }",
                        "    });",
                        "  }",
                        "",
                        "  eventBus.on('shape.move.move', LOW_PRIORITY, function(event) {",
                        "",
                        "    var context = event.context,",
                        "        canExecute = context.canExecute;",
                        "",
                        "    if (!context.visualReplacements) {",
                        "      context.visualReplacements = {};",
                        "    }",
                        "",
                        "    if (canExecute && canExecute.replacements) {",
                        "      replaceVisual(context);",
                        "    } else {",
                        "      restoreVisual(context);",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "BpmnReplacePreview.$inject = [",
                        "  'eventBus',",
                        "  'elementRegistry',",
                        "  'elementFactory',",
                        "  'canvas',",
                        "  'previewSupport'",
                        "];",
                        "",
                        "inherits(BpmnReplacePreview, CommandInterceptor);"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import PreviewSupportModule from 'diagram-js/lib/features/preview-support';",
                        "",
                        "import BpmnReplacePreview from './BpmnReplacePreview';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    PreviewSupportModule",
                        "  ],",
                        "  __init__: [ 'bpmnReplacePreview' ],",
                        "  bpmnReplacePreview: [ 'type', BpmnReplacePreview ]",
                        "};"
                    ]
                }
            },
            "rules": {
                "BpmnRules.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  every,",
                        "  find,",
                        "  forEach,",
                        "  some",
                        "} from 'min-dash';",
                        "",
                        "import inherits from 'inherits-browser';",
                        "",
                        "import {",
                        "  is,",
                        "  getBusinessObject",
                        "} from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  getParent,",
                        "  isAny",
                        "} from '../modeling/util/ModelingUtil';",
                        "",
                        "import {",
                        "  isLabel",
                        "} from '../../util/LabelUtil';",
                        "",
                        "import {",
                        "  isExpanded,",
                        "  isEventSubProcess,",
                        "  isInterrupting,",
                        "  hasErrorEventDefinition,",
                        "  hasEscalationEventDefinition,",
                        "  hasCompensateEventDefinition",
                        "} from '../../util/DiUtil';",
                        "",
                        "import RuleProvider from 'diagram-js/lib/features/rules/RuleProvider';",
                        "",
                        "import {",
                        "  getBoundaryAttachment as isBoundaryAttachment",
                        "} from '../snapping/BpmnSnappingUtil';",
                        "",
                        "import { isConnection } from 'diagram-js/lib/util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " *",
                        " * @typedef {import('../../model/Types').Connection} Connection",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " * @typedef {import('../../model/Types').ModdleElement} ModdleElement",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                        " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                        " *",
                        " * @typedef { {",
                        " *   associationDirection?: string;",
                        " *   type: string;",
                        " * } | boolean | null } CanConnectResult",
                        " *",
                        " * @typedef { {",
                        " *   id: string;",
                        " *   type: string;",
                        " * } | boolean } CanReplaceResult",
                        " */",
                        "",
                        "/**",
                        " * BPMN-specific modeling rules.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " */",
                        "export default function BpmnRules(eventBus) {",
                        "  RuleProvider.call(this, eventBus);",
                        "}",
                        "",
                        "inherits(BpmnRules, RuleProvider);",
                        "",
                        "BpmnRules.$inject = [ 'eventBus' ];",
                        "",
                        "BpmnRules.prototype.init = function() {",
                        "",
                        "  this.addRule('connection.start', function(context) {",
                        "    var source = context.source;",
                        "",
                        "    return canStartConnection(source);",
                        "  });",
                        "",
                        "  this.addRule('connection.create', function(context) {",
                        "    var source = context.source,",
                        "        target = context.target,",
                        "        hints = context.hints || {},",
                        "        targetParent = hints.targetParent,",
                        "        targetAttach = hints.targetAttach;",
                        "",
                        "    // don't allow incoming connections on",
                        "    // newly created boundary events",
                        "    // to boundary events",
                        "    if (targetAttach) {",
                        "      return false;",
                        "    }",
                        "",
                        "    // temporarily set target parent for scoping",
                        "    // checks to work",
                        "    if (targetParent) {",
                        "      target.parent = targetParent;",
                        "    }",
                        "",
                        "    try {",
                        "      return canConnect(source, target);",
                        "    } finally {",
                        "",
                        "      // unset temporary target parent",
                        "      if (targetParent) {",
                        "        target.parent = null;",
                        "      }",
                        "    }",
                        "  });",
                        "",
                        "  this.addRule('connection.reconnect', function(context) {",
                        "",
                        "    var connection = context.connection,",
                        "        source = context.source,",
                        "        target = context.target;",
                        "",
                        "    return canConnect(source, target, connection);",
                        "  });",
                        "",
                        "  this.addRule('connection.updateWaypoints', function(context) {",
                        "    return {",
                        "      type: context.connection.type",
                        "    };",
                        "  });",
                        "",
                        "  this.addRule('shape.resize', function(context) {",
                        "",
                        "    var shape = context.shape,",
                        "        newBounds = context.newBounds;",
                        "",
                        "    return canResize(shape, newBounds);",
                        "  });",
                        "",
                        "  this.addRule('elements.create', function(context) {",
                        "    var elements = context.elements,",
                        "        position = context.position,",
                        "        target = context.target;",
                        "",
                        "    if (isConnection(target) && !canInsert(elements, target, position)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return every(elements, function(element) {",
                        "      if (isConnection(element)) {",
                        "        return canConnect(element.source, element.target, element);",
                        "      }",
                        "",
                        "      if (element.host) {",
                        "        return canAttach(element, element.host, null, position);",
                        "      }",
                        "",
                        "      return canCreate(element, target, null, position);",
                        "    });",
                        "  });",
                        "",
                        "  this.addRule('elements.move', function(context) {",
                        "",
                        "    var target = context.target,",
                        "        shapes = context.shapes,",
                        "        position = context.position;",
                        "",
                        "    return canAttach(shapes, target, null, position) ||",
                        "           canReplace(shapes, target, position) ||",
                        "           canMove(shapes, target, position) ||",
                        "           canInsert(shapes, target, position);",
                        "  });",
                        "",
                        "  this.addRule('shape.create', function(context) {",
                        "    return canCreate(",
                        "      context.shape,",
                        "      context.target,",
                        "      context.source,",
                        "      context.position",
                        "    );",
                        "  });",
                        "",
                        "  this.addRule('shape.attach', function(context) {",
                        "",
                        "    return canAttach(",
                        "      context.shape,",
                        "      context.target,",
                        "      null,",
                        "      context.position",
                        "    );",
                        "  });",
                        "",
                        "  this.addRule('element.copy', function(context) {",
                        "    var element = context.element,",
                        "        elements = context.elements;",
                        "",
                        "    return canCopy(elements, element);",
                        "  });",
                        "};",
                        "",
                        "BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;",
                        "",
                        "BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;",
                        "",
                        "BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;",
                        "",
                        "BpmnRules.prototype.canConnectAssociation = canConnectAssociation;",
                        "",
                        "BpmnRules.prototype.canMove = canMove;",
                        "",
                        "BpmnRules.prototype.canAttach = canAttach;",
                        "",
                        "BpmnRules.prototype.canReplace = canReplace;",
                        "",
                        "BpmnRules.prototype.canDrop = canDrop;",
                        "",
                        "BpmnRules.prototype.canInsert = canInsert;",
                        "",
                        "BpmnRules.prototype.canCreate = canCreate;",
                        "",
                        "BpmnRules.prototype.canConnect = canConnect;",
                        "",
                        "BpmnRules.prototype.canResize = canResize;",
                        "",
                        "BpmnRules.prototype.canCopy = canCopy;",
                        "",
                        "/**",
                        " * Utility functions for rule checking",
                        " */",
                        "",
                        "/**",
                        " * Checks if given element can be used for starting connection.",
                        " *",
                        " * @param  {Element} source",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canStartConnection(element) {",
                        "  if (nonExistingOrLabel(element)) {",
                        "    return null;",
                        "  }",
                        "",
                        "  return isAny(element, [",
                        "    'bpmn:FlowNode',",
                        "    'bpmn:InteractionNode',",
                        "    'bpmn:DataObjectReference',",
                        "    'bpmn:DataStoreReference',",
                        "    'bpmn:Group',",
                        "    'bpmn:TextAnnotation'",
                        "  ]);",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function nonExistingOrLabel(element) {",
                        "  return !element || isLabel(element);",
                        "}",
                        "",
                        "function isSame(a, b) {",
                        "  return a === b;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "function getOrganizationalParent(element) {",
                        "",
                        "  do {",
                        "    if (is(element, 'bpmn:Process')) {",
                        "      return getBusinessObject(element);",
                        "    }",
                        "",
                        "    if (is(element, 'bpmn:Participant')) {",
                        "      return (",
                        "        getBusinessObject(element).processRef ||",
                        "        getBusinessObject(element)",
                        "      );",
                        "    }",
                        "  } while ((element = element.parent));",
                        "",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isTextAnnotation(element) {",
                        "  return is(element, 'bpmn:TextAnnotation');",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isGroup(element) {",
                        "  return is(element, 'bpmn:Group') && !element.labelTarget;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isCompensationBoundary(element) {",
                        "  return is(element, 'bpmn:BoundaryEvent') &&",
                        "         hasEventDefinition(element, 'bpmn:CompensateEventDefinition');",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isForCompensation(element) {",
                        "  return getBusinessObject(element).isForCompensation;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} a",
                        " * @param {Element} b",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isSameOrganization(a, b) {",
                        "  var parentA = getOrganizationalParent(a),",
                        "      parentB = getOrganizationalParent(b);",
                        "",
                        "  return parentA === parentB;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isMessageFlowSource(element) {",
                        "  return (",
                        "    is(element, 'bpmn:InteractionNode') &&",
                        "    !is(element, 'bpmn:BoundaryEvent') && (",
                        "      !is(element, 'bpmn:Event') || (",
                        "        is(element, 'bpmn:ThrowEvent') &&",
                        "        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')",
                        "      )",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isMessageFlowTarget(element) {",
                        "  return (",
                        "    is(element, 'bpmn:InteractionNode') &&",
                        "    !isForCompensation(element) && (",
                        "      !is(element, 'bpmn:Event') || (",
                        "        is(element, 'bpmn:CatchEvent') &&",
                        "        hasEventDefinitionOrNone(element, 'bpmn:MessageEventDefinition')",
                        "      )",
                        "    ) && !(",
                        "      is(element, 'bpmn:BoundaryEvent') &&",
                        "      !hasEventDefinition(element, 'bpmn:MessageEventDefinition')",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {ModdleElement}",
                        " */",
                        "function getScopeParent(element) {",
                        "",
                        "  var parent = element;",
                        "",
                        "  while ((parent = parent.parent)) {",
                        "",
                        "    if (is(parent, 'bpmn:FlowElementsContainer')) {",
                        "      return getBusinessObject(parent);",
                        "    }",
                        "",
                        "    if (is(parent, 'bpmn:Participant')) {",
                        "      return getBusinessObject(parent).processRef;",
                        "    }",
                        "  }",
                        "",
                        "  return null;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} a",
                        " * @param {Element} b",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isSameScope(a, b) {",
                        "  var scopeParentA = getScopeParent(a),",
                        "      scopeParentB = getScopeParent(b);",
                        "",
                        "  return scopeParentA === scopeParentB;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " * @param {string} eventDefinition",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function hasEventDefinition(element, eventDefinition) {",
                        "  var businessObject = getBusinessObject(element);",
                        "",
                        "  return !!find(businessObject.eventDefinitions || [], function(definition) {",
                        "    return is(definition, eventDefinition);",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " * @param {string} eventDefinition",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function hasEventDefinitionOrNone(element, eventDefinition) {",
                        "  var businessObject = getBusinessObject(element);",
                        "",
                        "  return (businessObject.eventDefinitions || []).every(function(definition) {",
                        "    return is(definition, eventDefinition);",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isSequenceFlowSource(element) {",
                        "  return (",
                        "    is(element, 'bpmn:FlowNode') &&",
                        "    !is(element, 'bpmn:EndEvent') &&",
                        "    !isEventSubProcess(element) &&",
                        "    !(is(element, 'bpmn:IntermediateThrowEvent') &&",
                        "      hasEventDefinition(element, 'bpmn:LinkEventDefinition')",
                        "    ) &&",
                        "    !isCompensationBoundary(element) &&",
                        "    !isForCompensation(element)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isSequenceFlowTarget(element) {",
                        "  return (",
                        "    is(element, 'bpmn:FlowNode') &&",
                        "    !is(element, 'bpmn:StartEvent') &&",
                        "    !is(element, 'bpmn:BoundaryEvent') &&",
                        "    !isEventSubProcess(element) &&",
                        "    !(is(element, 'bpmn:IntermediateCatchEvent') &&",
                        "      hasEventDefinition(element, 'bpmn:LinkEventDefinition')",
                        "    ) &&",
                        "    !isForCompensation(element)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isEventBasedTarget(element) {",
                        "  return (",
                        "    is(element, 'bpmn:ReceiveTask') || (",
                        "      is(element, 'bpmn:IntermediateCatchEvent') && (",
                        "        hasEventDefinition(element, 'bpmn:MessageEventDefinition') ||",
                        "        hasEventDefinition(element, 'bpmn:TimerEventDefinition') ||",
                        "        hasEventDefinition(element, 'bpmn:ConditionalEventDefinition') ||",
                        "        hasEventDefinition(element, 'bpmn:SignalEventDefinition')",
                        "      )",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {Shape[]}",
                        " */",
                        "function getParents(element) {",
                        "",
                        "  var parents = [];",
                        "",
                        "  while (element) {",
                        "    element = element.parent;",
                        "",
                        "    if (element) {",
                        "      parents.push(element);",
                        "    }",
                        "  }",
                        "",
                        "  return parents;",
                        "}",
                        "",
                        "/**",
                        " * @param {Shape} possibleParent",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isParent(possibleParent, element) {",
                        "  var allParents = getParents(element);",
                        "",
                        "  return allParents.indexOf(possibleParent) !== -1;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} source",
                        " * @param {Element} target",
                        " * @param {Connection} connection",
                        " *",
                        " * @return {CanConnectResult}",
                        " */",
                        "function canConnect(source, target, connection) {",
                        "",
                        "  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {",
                        "    return null;",
                        "  }",
                        "",
                        "  if (!is(connection, 'bpmn:DataAssociation')) {",
                        "",
                        "    if (canConnectMessageFlow(source, target)) {",
                        "      return { type: 'bpmn:MessageFlow' };",
                        "    }",
                        "",
                        "    if (canConnectSequenceFlow(source, target)) {",
                        "      return { type: 'bpmn:SequenceFlow' };",
                        "    }",
                        "  }",
                        "",
                        "  var connectDataAssociation = canConnectDataAssociation(source, target);",
                        "",
                        "  if (connectDataAssociation) {",
                        "    return connectDataAssociation;",
                        "  }",
                        "",
                        "  if (isCompensationBoundary(source) && isForCompensation(target)) {",
                        "    return {",
                        "      type: 'bpmn:Association',",
                        "      associationDirection: 'One'",
                        "    };",
                        "  }",
                        "",
                        "  if (canConnectAssociation(source, target)) {",
                        "",
                        "    return {",
                        "      type: 'bpmn:Association'",
                        "    };",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * Can an element be dropped into the target element.",
                        " *",
                        " * @param {Element} element",
                        " * @param {Shape} target",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canDrop(element, target) {",
                        "",
                        "  // can move labels and groups everywhere",
                        "  if (isLabel(element) || isGroup(element)) {",
                        "    return true;",
                        "  }",
                        "",
                        "",
                        "  // disallow to create elements on collapsed pools",
                        "  if (is(target, 'bpmn:Participant') && !isExpanded(target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // allow to create new participants on",
                        "  // existing collaboration and process diagrams",
                        "  if (is(element, 'bpmn:Participant')) {",
                        "    return is(target, 'bpmn:Process') || is(target, 'bpmn:Collaboration');",
                        "  }",
                        "",
                        "  // allow moving DataInput / DataOutput within its original container only",
                        "  if (isAny(element, [ 'bpmn:DataInput', 'bpmn:DataOutput' ])) {",
                        "",
                        "    if (element.parent) {",
                        "      return target === element.parent;",
                        "    }",
                        "  }",
                        "",
                        "  // allow creating lanes on participants and other lanes only",
                        "  if (is(element, 'bpmn:Lane')) {",
                        "    return is(target, 'bpmn:Participant') || is(target, 'bpmn:Lane');",
                        "  }",
                        "",
                        "  // disallow dropping boundary events which cannot replace with intermediate event",
                        "  if (is(element, 'bpmn:BoundaryEvent') && !isDroppableBoundaryEvent(element)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // drop flow elements onto flow element containers",
                        "  // and participants",
                        "  if (is(element, 'bpmn:FlowElement') && !is(element, 'bpmn:DataStoreReference')) {",
                        "    if (is(target, 'bpmn:FlowElementsContainer')) {",
                        "      return isExpanded(target);",
                        "    }",
                        "",
                        "    return isAny(target, [ 'bpmn:Participant', 'bpmn:Lane' ]);",
                        "  }",
                        "",
                        "  // disallow dropping data store reference if there is no process to append to",
                        "  if (is(element, 'bpmn:DataStoreReference') && is(target, 'bpmn:Collaboration')) {",
                        "    return some(getBusinessObject(target).get('participants'), function(participant) {",
                        "      return !!participant.get('processRef');",
                        "    });",
                        "  }",
                        "",
                        "  // account for the fact that data associations are always",
                        "  // rendered and moved to top (Process or Collaboration level)",
                        "  //",
                        "  // artifacts may be placed wherever, too",
                        "  if (isAny(element, [ 'bpmn:Artifact', 'bpmn:DataAssociation', 'bpmn:DataStoreReference' ])) {",
                        "    return isAny(target, [",
                        "      'bpmn:Collaboration',",
                        "      'bpmn:Lane',",
                        "      'bpmn:Participant',",
                        "      'bpmn:Process',",
                        "      'bpmn:SubProcess' ]);",
                        "  }",
                        "",
                        "  if (is(element, 'bpmn:MessageFlow')) {",
                        "    return is(target, 'bpmn:Collaboration')",
                        "      || element.source.parent == target",
                        "      || element.target.parent == target;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * @param {Shape} event",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isDroppableBoundaryEvent(event) {",
                        "  return getBusinessObject(event).cancelActivity && (",
                        "    hasNoEventDefinition(event) || hasCommonBoundaryIntermediateEventDefinition(event)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isBoundaryEvent(element) {",
                        "  return !isLabel(element) && is(element, 'bpmn:BoundaryEvent');",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isLane(element) {",
                        "  return is(element, 'bpmn:Lane');",
                        "}",
                        "",
                        "/**",
                        " * `bpmn:IntermediateThrowEvents` are treated as boundary events during create.",
                        " *",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isBoundaryCandidate(element) {",
                        "  if (isBoundaryEvent(element)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (is(element, 'bpmn:IntermediateThrowEvent') && hasNoEventDefinition(element)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return (",
                        "    is(element, 'bpmn:IntermediateCatchEvent') &&",
                        "    hasCommonBoundaryIntermediateEventDefinition(element)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function hasNoEventDefinition(element) {",
                        "  var businessObject = getBusinessObject(element);",
                        "",
                        "  return businessObject && !(businessObject.eventDefinitions && businessObject.eventDefinitions.length);",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function hasCommonBoundaryIntermediateEventDefinition(element) {",
                        "  return hasOneOfEventDefinitions(element, [",
                        "    'bpmn:MessageEventDefinition',",
                        "    'bpmn:TimerEventDefinition',",
                        "    'bpmn:SignalEventDefinition',",
                        "    'bpmn:ConditionalEventDefinition'",
                        "  ]);",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " * @param {string[]} eventDefinitions",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function hasOneOfEventDefinitions(element, eventDefinitions) {",
                        "  return eventDefinitions.some(function(definition) {",
                        "    return hasEventDefinition(element, definition);",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isReceiveTaskAfterEventBasedGateway(element) {",
                        "  return (",
                        "    is(element, 'bpmn:ReceiveTask') &&",
                        "    find(element.incoming, function(incoming) {",
                        "      return is(incoming.source, 'bpmn:EventBasedGateway');",
                        "    })",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * TODO(philippfromme): remove `source` parameter",
                        " *",
                        " * @param {Element[]} elements",
                        " * @param {Shape} target",
                        " * @param {Element} source",
                        " * @param {Point} [position]",
                        " *",
                        " * @return {boolean | 'attach'}",
                        " */",
                        "function canAttach(elements, target, source, position) {",
                        "",
                        "  if (!Array.isArray(elements)) {",
                        "    elements = [ elements ];",
                        "  }",
                        "",
                        "  // only (re-)attach one element at a time",
                        "  if (elements.length !== 1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  var element = elements[0];",
                        "",
                        "  // do not attach labels",
                        "  if (isLabel(element)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // only handle boundary events",
                        "  if (!isBoundaryCandidate(element)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // disallow drop on event sub processes",
                        "  if (isEventSubProcess(target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // only allow drop on non compensation activities",
                        "  if (!is(target, 'bpmn:Activity') || isForCompensation(target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // only attach to subprocess border",
                        "  if (position && !isBoundaryAttachment(position, target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // do not attach on receive tasks after event based gateways",
                        "  if (isReceiveTaskAfterEventBasedGateway(target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return 'attach';",
                        "}",
                        "",
                        "/**",
                        " * Check whether the given elements can be replaced. Return all elements which",
                        " * can be replaced.",
                        " *",
                        " * @example",
                        " *",
                        " * ```javascript",
                        " * [{",
                        " *   id: 'IntermediateEvent_1',",
                        " *   type: 'bpmn:StartEvent'",
                        " * },",
                        " * {",
                        " *   id: 'Task_1',",
                        " *   type: 'bpmn:ServiceTask'",
                        " * }]",
                        " * ```",
                        " *",
                        " * @param  {Element[]} elements",
                        " * @param  {Shape} [target]",
                        " * @param  {Point} [position]",
                        " *",
                        " * @return {CanReplaceResult}",
                        " */",
                        "function canReplace(elements, target, position) {",
                        "",
                        "  if (!target) {",
                        "    return false;",
                        "  }",
                        "",
                        "  var canExecute = {",
                        "    replacements: []",
                        "  };",
                        "",
                        "  forEach(elements, function(element) {",
                        "",
                        "    if (!isEventSubProcess(target)) {",
                        "",
                        "      if (is(element, 'bpmn:StartEvent') &&",
                        "          element.type !== 'label' &&",
                        "          canDrop(element, target)) {",
                        "",
                        "        // replace a non-interrupting start event by a blank interrupting start event",
                        "        // when the target is not an event sub process",
                        "        if (!isInterrupting(element)) {",
                        "          canExecute.replacements.push({",
                        "            oldElementId: element.id,",
                        "            newElementType: 'bpmn:StartEvent'",
                        "          });",
                        "        }",
                        "",
                        "        // replace an error/escalation/compensate start event by a blank interrupting start event",
                        "        // when the target is not an event sub process",
                        "        if (hasErrorEventDefinition(element) ||",
                        "            hasEscalationEventDefinition(element) ||",
                        "            hasCompensateEventDefinition(element)) {",
                        "          canExecute.replacements.push({",
                        "            oldElementId: element.id,",
                        "            newElementType: 'bpmn:StartEvent'",
                        "          });",
                        "        }",
                        "",
                        "        // replace a typed start event by a blank interrupting start event",
                        "        // when the target is a sub process but not an event sub process",
                        "        if (hasOneOfEventDefinitions(element,",
                        "          [",
                        "            'bpmn:MessageEventDefinition',",
                        "            'bpmn:TimerEventDefinition',",
                        "            'bpmn:SignalEventDefinition',",
                        "            'bpmn:ConditionalEventDefinition'",
                        "          ]) &&",
                        "            is(target, 'bpmn:SubProcess')) {",
                        "          canExecute.replacements.push({",
                        "            oldElementId: element.id,",
                        "            newElementType: 'bpmn:StartEvent'",
                        "          });",
                        "        }",
                        "      }",
                        "    }",
                        "",
                        "    if (!is(target, 'bpmn:Transaction')) {",
                        "      if (hasEventDefinition(element, 'bpmn:CancelEventDefinition') &&",
                        "          element.type !== 'label') {",
                        "",
                        "        if (is(element, 'bpmn:EndEvent') && canDrop(element, target)) {",
                        "          canExecute.replacements.push({",
                        "            oldElementId: element.id,",
                        "            newElementType: 'bpmn:EndEvent'",
                        "          });",
                        "        }",
                        "",
                        "        if (is(element, 'bpmn:BoundaryEvent') && canAttach(element, target, null, position)) {",
                        "          canExecute.replacements.push({",
                        "            oldElementId: element.id,",
                        "            newElementType: 'bpmn:BoundaryEvent'",
                        "          });",
                        "        }",
                        "      }",
                        "    }",
                        "  });",
                        "",
                        "  return canExecute.replacements.length ? canExecute : false;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element[]} elements",
                        " * @param {Shape} target",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canMove(elements, target) {",
                        "",
                        "  // do not move selection containing lanes",
                        "  if (some(elements, isLane)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // allow default move check to start move operation",
                        "  if (!target) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return elements.every(function(element) {",
                        "    return canDrop(element, target);",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {Shape} shape",
                        " * @param {Shape} target",
                        " * @param {Element} source",
                        " * @param {Point} position",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canCreate(shape, target, source, position) {",
                        "",
                        "  if (!target) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isLabel(shape) || isGroup(shape)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (isSame(source, target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // ensure we do not drop the element",
                        "  // into source",
                        "  if (source && isParent(source, target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return canDrop(shape, target, position) || canInsert(shape, target, position);",
                        "}",
                        "",
                        "/**",
                        " * @param {Shape} shape",
                        " * @param {Rect} newBounds",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canResize(shape, newBounds) {",
                        "  if (is(shape, 'bpmn:SubProcess')) {",
                        "    return (",
                        "      isExpanded(shape) && (",
                        "        !newBounds || (newBounds.width >= 100 && newBounds.height >= 80)",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  if (is(shape, 'bpmn:Lane')) {",
                        "    return !newBounds || (newBounds.width >= 130 && newBounds.height >= 60);",
                        "  }",
                        "",
                        "  if (is(shape, 'bpmn:Participant')) {",
                        "    return !newBounds || (newBounds.width >= 250 && newBounds.height >= 50);",
                        "  }",
                        "",
                        "  if (isTextAnnotation(shape)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (isGroup(shape)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * Check whether one of of the elements to be connected is a text annotation.",
                        " *",
                        " * @param {Element} source",
                        " * @param {Element} target",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isOneTextAnnotation(source, target) {",
                        "",
                        "  var sourceTextAnnotation = isTextAnnotation(source),",
                        "      targetTextAnnotation = isTextAnnotation(target);",
                        "",
                        "  return (",
                        "    (sourceTextAnnotation || targetTextAnnotation) &&",
                        "    (sourceTextAnnotation !== targetTextAnnotation)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} source",
                        " * @param {Element} target",
                        " *",
                        " * @return {CanConnectResult}",
                        " */",
                        "function canConnectAssociation(source, target) {",
                        "",
                        "  // compensation boundary events are exception",
                        "  if (isCompensationBoundary(source) && isForCompensation(target)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // don't connect parent <-> child",
                        "  if (isParent(target, source) || isParent(source, target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // allow connection of associations between <!TextAnnotation> and <TextAnnotation>",
                        "  if (isOneTextAnnotation(source, target)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // can connect associations where we can connect",
                        "  // data associations, too (!)",
                        "  return !!canConnectDataAssociation(source, target);",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} source",
                        " * @param {Element} target",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canConnectMessageFlow(source, target) {",
                        "",
                        "  // during connect user might move mouse out of canvas",
                        "  // https://github.com/bpmn-io/bpmn-js/issues/1033",
                        "  if (getRootElement(source) && !getRootElement(target)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return (",
                        "    isMessageFlowSource(source) &&",
                        "    isMessageFlowTarget(target) &&",
                        "    !isSameOrganization(source, target)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} source",
                        " * @param {Element} target",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canConnectSequenceFlow(source, target) {",
                        "  return isSequenceFlowSource(source) &&",
                        "         isSequenceFlowTarget(target) &&",
                        "         isSameScope(source, target) &&",
                        "         !(is(source, 'bpmn:EventBasedGateway') && !isEventBasedTarget(target));",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} source",
                        " * @param {Element} target",
                        " *",
                        " * @return {CanConnectResult}",
                        " */",
                        "function canConnectDataAssociation(source, target) {",
                        "",
                        "  if (isAny(source, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&",
                        "      isAny(target, [ 'bpmn:Activity', 'bpmn:ThrowEvent' ])) {",
                        "    return { type: 'bpmn:DataInputAssociation' };",
                        "  }",
                        "",
                        "  if (isAny(target, [ 'bpmn:DataObjectReference', 'bpmn:DataStoreReference' ]) &&",
                        "      isAny(source, [ 'bpmn:Activity', 'bpmn:CatchEvent' ])) {",
                        "    return { type: 'bpmn:DataOutputAssociation' };",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * @param {Shape} shape",
                        " * @param {Connection} connection",
                        " * @param {Point} position",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canInsert(shape, connection, position) {",
                        "  if (!connection) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (Array.isArray(shape)) {",
                        "    if (shape.length !== 1) {",
                        "      return false;",
                        "    }",
                        "",
                        "    shape = shape[ 0 ];",
                        "  }",
                        "",
                        "  if (connection.source === shape ||",
                        "      connection.target === shape) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // return true if shape can be inserted into connection parent",
                        "  return (",
                        "    isAny(connection, [ 'bpmn:SequenceFlow', 'bpmn:MessageFlow' ]) &&",
                        "    !isLabel(connection) &&",
                        "    is(shape, 'bpmn:FlowNode') &&",
                        "    !is(shape, 'bpmn:BoundaryEvent') &&",
                        "    canDrop(shape, connection.parent, position));",
                        "}",
                        "",
                        "/**",
                        " * @param {Element[]} elements",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function includes(elements, element) {",
                        "  return (elements && element) && elements.indexOf(element) !== -1;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element[]} elements",
                        " * @param {Element} element",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function canCopy(elements, element) {",
                        "  if (isLabel(element)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (is(element, 'bpmn:Lane') && !includes(elements, element.parent)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " *",
                        " * @return {Element|null}",
                        " */",
                        "function getRootElement(element) {",
                        "  return getParent(element, 'bpmn:Process') || getParent(element, 'bpmn:Collaboration');",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import RulesModule from 'diagram-js/lib/features/rules';",
                        "",
                        "import BpmnRules from './BpmnRules';",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    RulesModule",
                        "  ],",
                        "  __init__: [ 'bpmnRules' ],",
                        "  bpmnRules: [ 'type', BpmnRules ]",
                        "};"
                    ]
                }
            },
            "search": {
                "BpmnSearchProvider.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  map,",
                        "  filter,",
                        "  sortBy",
                        "} from 'min-dash';",
                        "",
                        "import {",
                        "  getLabel",
                        "} from '../../util/LabelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                        " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                        " * @typedef {import('diagram-js/lib/features/search-pad/SearchPad').default} SearchPad",
                        " *",
                        " * @typedef {import('diagram-js/lib/features/search-pad/SearchPadProvider').default} SearchPadProvider",
                        " * @typedef {import('diagram-js/lib/features/search-pad/SearchPadProvider').SearchResult} SearchResult",
                        " */",
                        "",
                        "/**",
                        " * Provides ability to search for BPMN elements.",
                        " *",
                        " * @implements {SearchPadProvider}",
                        " *",
                        " * @param {ElementRegistry} elementRegistry",
                        " * @param {SearchPad} searchPad",
                        " * @param {Canvas} canvas",
                        " */",
                        "export default function BpmnSearchProvider(elementRegistry, searchPad, canvas) {",
                        "  this._elementRegistry = elementRegistry;",
                        "  this._canvas = canvas;",
                        "",
                        "  searchPad.registerProvider(this);",
                        "}",
                        "",
                        "BpmnSearchProvider.$inject = [",
                        "  'elementRegistry',",
                        "  'searchPad',",
                        "  'canvas'",
                        "];",
                        "",
                        "/**",
                        " * @param {string} pattern",
                        " *",
                        " * @return {SearchResult[]}",
                        " */",
                        "BpmnSearchProvider.prototype.find = function(pattern) {",
                        "  var rootElement = this._canvas.getRootElement();",
                        "",
                        "  var elements = this._elementRegistry.filter(function(element) {",
                        "    if (element.labelTarget) {",
                        "      return false;",
                        "    }",
                        "    return true;",
                        "  });",
                        "",
                        "  // do not include root element",
                        "  elements = filter(elements, function(element) {",
                        "    return element !== rootElement;",
                        "  });",
                        "",
                        "  elements = map(elements, function(element) {",
                        "    return {",
                        "      primaryTokens: matchAndSplit(getLabel(element), pattern),",
                        "      secondaryTokens: matchAndSplit(element.id, pattern),",
                        "      element: element",
                        "    };",
                        "  });",
                        "",
                        "  // exclude non-matched elements",
                        "  elements = filter(elements, function(element) {",
                        "    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);",
                        "  });",
                        "",
                        "  elements = sortBy(elements, function(element) {",
                        "    return getLabel(element.element) + element.element.id;",
                        "  });",
                        "",
                        "  return elements;",
                        "};",
                        "",
                        "/**",
                        " * @param {Token[]} tokens",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function hasMatched(tokens) {",
                        "  var matched = filter(tokens, function(token) {",
                        "    return !!token.matched;",
                        "  });",
                        "",
                        "  return matched.length > 0;",
                        "}",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {string} pattern",
                        " *",
                        " * @return {Token[]}",
                        " */",
                        "function matchAndSplit(text, pattern) {",
                        "  var tokens = [],",
                        "      originalText = text;",
                        "",
                        "  if (!text) {",
                        "    return tokens;",
                        "  }",
                        "",
                        "  text = text.toLowerCase();",
                        "  pattern = pattern.toLowerCase();",
                        "",
                        "  var i = text.indexOf(pattern);",
                        "",
                        "  if (i > -1) {",
                        "    if (i !== 0) {",
                        "      tokens.push({",
                        "        normal: originalText.substr(0, i)",
                        "      });",
                        "    }",
                        "",
                        "    tokens.push({",
                        "      matched: originalText.substr(i, pattern.length)",
                        "    });",
                        "",
                        "    if (pattern.length + i < text.length) {",
                        "      tokens.push({",
                        "        normal: originalText.substr(pattern.length + i, text.length)",
                        "      });",
                        "    }",
                        "  } else {",
                        "    tokens.push({",
                        "      normal: originalText",
                        "    });",
                        "  }",
                        "",
                        "  return tokens;",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import SearchPadModule from 'diagram-js/lib/features/search-pad';",
                        "",
                        "import BpmnSearchProvider from './BpmnSearchProvider';",
                        "",
                        "",
                        "export default {",
                        "  __depends__: [",
                        "    SearchPadModule",
                        "  ],",
                        "  __init__: [ 'bpmnSearch' ],",
                        "  bpmnSearch: [ 'type', BpmnSearchProvider ]",
                        "};"
                    ]
                }
            },
            "snapping": {
                "BpmnConnectSnapping.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  mid,",
                        "  setSnapped",
                        "} from 'diagram-js/lib/features/snapping/SnapUtil';",
                        "",
                        "import { isCmd } from 'diagram-js/lib/features/keyboard/KeyboardUtil';",
                        "",
                        "import {",
                        "  getOrientation",
                        "} from 'diagram-js/lib/layout/LayoutUtil';",
                        "",
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "import { isAny } from '../modeling/util/ModelingUtil';",
                        "",
                        "import { some } from 'min-dash';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " *",
                        " * @typedef {import('diagram-js/lib/core/EventBus').Event} Event",
                        " *",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Axis} Axis",
                        " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                        " */",
                        "",
                        "var HIGHER_PRIORITY = 1250;",
                        "",
                        "var BOUNDARY_TO_HOST_THRESHOLD = 40;",
                        "",
                        "var TARGET_BOUNDS_PADDING = 20,",
                        "    TASK_BOUNDS_PADDING = 10;",
                        "",
                        "var TARGET_CENTER_PADDING = 20;",
                        "",
                        "var AXES = [ 'x', 'y' ];",
                        "",
                        "var abs = Math.abs;",
                        "",
                        "/**",
                        " * Snap during connect.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " */",
                        "export default function BpmnConnectSnapping(eventBus) {",
                        "  eventBus.on([",
                        "    'connect.hover',",
                        "    'connect.move',",
                        "    'connect.end',",
                        "  ], HIGHER_PRIORITY, function(event) {",
                        "    var context = event.context,",
                        "        canExecute = context.canExecute,",
                        "        start = context.start,",
                        "        hover = context.hover,",
                        "        source = context.source,",
                        "        target = context.target;",
                        "",
                        "    // do NOT snap on CMD",
                        "    if (event.originalEvent && isCmd(event.originalEvent)) {",
                        "      return;",
                        "    }",
                        "",
                        "    if (!context.initialConnectionStart) {",
                        "      context.initialConnectionStart = context.connectionStart;",
                        "    }",
                        "",
                        "    // snap hover",
                        "    if (canExecute && hover) {",
                        "      snapToShape(event, hover, getTargetBoundsPadding(hover));",
                        "    }",
                        "",
                        "    if (hover && isAnyType(canExecute, [",
                        "      'bpmn:Association',",
                        "      'bpmn:DataInputAssociation',",
                        "      'bpmn:DataOutputAssociation',",
                        "      'bpmn:SequenceFlow'",
                        "    ])) {",
                        "      context.connectionStart = mid(start);",
                        "",
                        "      // snap hover",
                        "      if (isAny(hover, [ 'bpmn:Event', 'bpmn:Gateway' ])) {",
                        "        snapToPosition(event, mid(hover));",
                        "      }",
                        "",
                        "      // snap hover",
                        "      if (isAny(hover, [ 'bpmn:Task', 'bpmn:SubProcess' ])) {",
                        "        snapToTargetMid(event, hover);",
                        "      }",
                        "",
                        "      // snap source and target",
                        "      if (is(source, 'bpmn:BoundaryEvent') && target === source.host) {",
                        "        snapBoundaryEventLoop(event);",
                        "      }",
                        "",
                        "    } else if (isType(canExecute, 'bpmn:MessageFlow')) {",
                        "",
                        "      if (is(start, 'bpmn:Event')) {",
                        "",
                        "        // snap start",
                        "        context.connectionStart = mid(start);",
                        "      }",
                        "",
                        "      if (is(hover, 'bpmn:Event')) {",
                        "",
                        "        // snap hover",
                        "        snapToPosition(event, mid(hover));",
                        "      }",
                        "",
                        "    } else {",
                        "",
                        "      // un-snap source",
                        "      context.connectionStart = context.initialConnectionStart;",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "BpmnConnectSnapping.$inject = [ 'eventBus' ];",
                        "",
                        "",
                        "// helpers //////////",
                        "",
                        "/**",
                        " * Snap to the given target if the event is inside the bounds of the target.",
                        " *",
                        " * @param {Event} event",
                        " * @param {Shape} target",
                        " * @param {number} padding",
                        " */",
                        "function snapToShape(event, target, padding) {",
                        "  AXES.forEach(function(axis) {",
                        "    var dimensionForAxis = getDimensionForAxis(axis, target);",
                        "",
                        "    if (event[ axis ] < target[ axis ] + padding) {",
                        "      setSnapped(event, axis, target[ axis ] + padding);",
                        "    } else if (event[ axis ] > target[ axis ] + dimensionForAxis - padding) {",
                        "      setSnapped(event, axis, target[ axis ] + dimensionForAxis - padding);",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * Snap to the target mid if the event is in the target mid.",
                        " *",
                        " * @param {Event} event",
                        " * @param {Shape} target",
                        " */",
                        "function snapToTargetMid(event, target) {",
                        "  var targetMid = mid(target);",
                        "",
                        "  AXES.forEach(function(axis) {",
                        "    if (isMid(event, target, axis)) {",
                        "      setSnapped(event, axis, targetMid[ axis ]);",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * Snap to prevent a loop overlapping a boundary event.",
                        " *",
                        " * @param {Event} event",
                        " */",
                        "function snapBoundaryEventLoop(event) {",
                        "  var context = event.context,",
                        "      source = context.source,",
                        "      target = context.target;",
                        "",
                        "  if (isReverse(context)) {",
                        "    return;",
                        "  }",
                        "",
                        "  var sourceMid = mid(source),",
                        "      orientation = getOrientation(sourceMid, target, -10),",
                        "      axes = [];",
                        "",
                        "  if (/top|bottom/.test(orientation)) {",
                        "    axes.push('x');",
                        "  }",
                        "",
                        "  if (/left|right/.test(orientation)) {",
                        "    axes.push('y');",
                        "  }",
                        "",
                        "  axes.forEach(function(axis) {",
                        "    var coordinate = event[ axis ], newCoordinate;",
                        "",
                        "    if (abs(coordinate - sourceMid[ axis ]) < BOUNDARY_TO_HOST_THRESHOLD) {",
                        "      if (coordinate > sourceMid[ axis ]) {",
                        "        newCoordinate = sourceMid[ axis ] + BOUNDARY_TO_HOST_THRESHOLD;",
                        "      }",
                        "      else {",
                        "        newCoordinate = sourceMid[ axis ] - BOUNDARY_TO_HOST_THRESHOLD;",
                        "      }",
                        "",
                        "      setSnapped(event, axis, newCoordinate);",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {Event} event",
                        " * @param {Point} position",
                        " */",
                        "function snapToPosition(event, position) {",
                        "  setSnapped(event, 'x', position.x);",
                        "  setSnapped(event, 'y', position.y);",
                        "}",
                        "",
                        "function isType(attrs, type) {",
                        "  return attrs && attrs.type === type;",
                        "}",
                        "",
                        "function isAnyType(attrs, types) {",
                        "  return some(types, function(type) {",
                        "    return isType(attrs, type);",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {Axis} axis",
                        " * @param {Shape} element",
                        " *",
                        " * @return {number}",
                        " */",
                        "function getDimensionForAxis(axis, element) {",
                        "  return axis === 'x' ? element.width : element.height;",
                        "}",
                        "",
                        "/**",
                        " * @param {Shape} target",
                        " *",
                        " * @return {number}",
                        " */",
                        "function getTargetBoundsPadding(target) {",
                        "  if (is(target, 'bpmn:Task')) {",
                        "    return TASK_BOUNDS_PADDING;",
                        "  } else {",
                        "    return TARGET_BOUNDS_PADDING;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {Event} event",
                        " * @param {Shape} target",
                        " * @param {Axis} axis",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function isMid(event, target, axis) {",
                        "  return event[ axis ] > target[ axis ] + TARGET_CENTER_PADDING",
                        "    && event[ axis ] < target[ axis ] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;",
                        "}",
                        "",
                        "function isReverse(context) {",
                        "  var hover = context.hover,",
                        "      source = context.source;",
                        "",
                        "  return hover && source && hover === source;",
                        "}"
                    ]
                },
                "BpmnCreateMoveSnapping.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import CreateMoveSnapping from 'diagram-js/lib/features/snapping/CreateMoveSnapping';",
                        "",
                        "import {",
                        "  isSnapped,",
                        "  setSnapped,",
                        "  topLeft,",
                        "  bottomRight",
                        "} from 'diagram-js/lib/features/snapping/SnapUtil';",
                        "",
                        "import { isExpanded } from '../../util/DiUtil';",
                        "",
                        "import { is } from '../../util/ModelUtil';",
                        "",
                        "import {",
                        "  asTRBL,",
                        "  getMid",
                        "} from 'diagram-js/lib/layout/LayoutUtil';",
                        "",
                        "import { getBoundaryAttachment } from './BpmnSnappingUtil';",
                        "",
                        "import { forEach } from 'min-dash';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                        " * @typedef {import('didi').Injector} Injector",
                        " *",
                        " * @typedef {import('diagram-js/lib/features/snapping/SnapContext').default} SnapContext",
                        " * @typedef {import('diagram-js/lib/features/snapping/SnapContext').SnapPoints} SnapPoints",
                        " *",
                        " * @typedef {import('diagram-js/lib/core/EventBus').Event} Event",
                        " *",
                        " * @typedef {import('../../model/Types').Element} Element",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " */",
                        "",
                        "var HIGH_PRIORITY = 1500;",
                        "",
                        "",
                        "/**",
                        " * Snap during create and move.",
                        " *",
                        " * @param {EventBus} eventBus",
                        " * @param {Injector} injector",
                        " */",
                        "export default function BpmnCreateMoveSnapping(eventBus, injector) {",
                        "  injector.invoke(CreateMoveSnapping, this);",
                        "",
                        "  // creating first participant",
                        "  eventBus.on([ 'create.move', 'create.end' ], HIGH_PRIORITY, setSnappedIfConstrained);",
                        "",
                        "  // snap boundary events",
                        "  eventBus.on([",
                        "    'create.move',",
                        "    'create.end',",
                        "    'shape.move.move',",
                        "    'shape.move.end'",
                        "  ], HIGH_PRIORITY, function(event) {",
                        "    var context = event.context,",
                        "        canExecute = context.canExecute,",
                        "        target = context.target;",
                        "",
                        "    var canAttach = canExecute && (canExecute === 'attach' || canExecute.attach);",
                        "",
                        "    if (canAttach && !isSnapped(event)) {",
                        "      snapBoundaryEvent(event, target);",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "inherits(BpmnCreateMoveSnapping, CreateMoveSnapping);",
                        "",
                        "BpmnCreateMoveSnapping.$inject = [",
                        "  'eventBus',",
                        "  'injector'",
                        "];",
                        "",
                        "/**",
                        " * @param {Event} event",
                        " *",
                        " * @return {SnapContext}",
                        " */",
                        "BpmnCreateMoveSnapping.prototype.initSnap = function(event) {",
                        "  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event);",
                        "",
                        "  var shape = event.shape;",
                        "",
                        "  var isMove = !!this._elementRegistry.get(shape.id);",
                        "",
                        "  // snap to docking points",
                        "  forEach(shape.outgoing, function(connection) {",
                        "    var docking = connection.waypoints[0];",
                        "",
                        "    docking = docking.original || docking;",
                        "",
                        "    snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));",
                        "  });",
                        "",
                        "  forEach(shape.incoming, function(connection) {",
                        "    var docking = connection.waypoints[connection.waypoints.length - 1];",
                        "",
                        "    docking = docking.original || docking;",
                        "",
                        "    snapContext.setSnapOrigin(connection.id + '-docking', getDockingSnapOrigin(docking, isMove, event));",
                        "  });",
                        "",
                        "  if (is(shape, 'bpmn:Participant')) {",
                        "",
                        "    // snap to borders with higher priority",
                        "    snapContext.setSnapLocations([ 'top-left', 'bottom-right', 'mid' ]);",
                        "  }",
                        "",
                        "  return snapContext;",
                        "};",
                        "",
                        "/**",
                        " * @param {SnapPoints} snapPoints",
                        " * @param {Shape} shape",
                        " * @param {Shape} target",
                        " *",
                        " * @return {SnapPoints}",
                        " */",
                        "BpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {",
                        "  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);",
                        "",
                        "  var snapTargets = this.getSnapTargets(shape, target);",
                        "",
                        "  forEach(snapTargets, function(snapTarget) {",
                        "",
                        "    // handle TRBL alignment",
                        "    //",
                        "    // * with container elements",
                        "    // * with text annotations",
                        "    if (isContainer(snapTarget) || areAll([ shape, snapTarget ], 'bpmn:TextAnnotation')) {",
                        "      snapPoints.add('top-left', topLeft(snapTarget));",
                        "      snapPoints.add('bottom-right', bottomRight(snapTarget));",
                        "    }",
                        "  });",
                        "",
                        "  var elementRegistry = this._elementRegistry;",
                        "",
                        "  // snap to docking points if not create mode",
                        "  forEach(shape.incoming, function(connection) {",
                        "    if (elementRegistry.get(shape.id)) {",
                        "",
                        "      if (!includes(snapTargets, connection.source)) {",
                        "        snapPoints.add('mid', getMid(connection.source));",
                        "      }",
                        "",
                        "      var docking = connection.waypoints[0];",
                        "      snapPoints.add(connection.id + '-docking', docking.original || docking);",
                        "    }",
                        "  });",
                        "",
                        "  forEach(shape.outgoing, function(connection) {",
                        "    if (elementRegistry.get(shape.id)) {",
                        "",
                        "      if (!includes(snapTargets, connection.target)) {",
                        "        snapPoints.add('mid', getMid(connection.target));",
                        "      }",
                        "",
                        "      var docking = connection.waypoints[ connection.waypoints.length - 1 ];",
                        "",
                        "      snapPoints.add(connection.id + '-docking', docking.original || docking);",
                        "    }",
                        "  });",
                        "",
                        "  // add sequence flow parents as snap targets",
                        "  if (is(target, 'bpmn:SequenceFlow')) {",
                        "    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);",
                        "  }",
                        "",
                        "  return snapPoints;",
                        "};",
                        "",
                        "/**",
                        " * @param {Shape} shape",
                        " * @param {Shape} target",
                        " *",
                        " * @return {Shape[]}",
                        " */",
                        "BpmnCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {",
                        "  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target)",
                        "    .filter(function(snapTarget) {",
                        "",
                        "      // do not snap to lanes",
                        "      return !is(snapTarget, 'bpmn:Lane');",
                        "    });",
                        "};",
                        "",
                        "// helpers //////////",
                        "",
                        "/**",
                        " * @param {Shape} event",
                        " * @param {Shape} target",
                        " */",
                        "function snapBoundaryEvent(event, target) {",
                        "  var targetTRBL = asTRBL(target);",
                        "",
                        "  var direction = getBoundaryAttachment(event, target);",
                        "",
                        "  var context = event.context,",
                        "      shape = context.shape;",
                        "",
                        "  var offset;",
                        "",
                        "  if (shape.parent) {",
                        "    offset = { x: 0, y: 0 };",
                        "  } else {",
                        "    offset = getMid(shape);",
                        "  }",
                        "",
                        "  if (/top/.test(direction)) {",
                        "    setSnapped(event, 'y', targetTRBL.top - offset.y);",
                        "  } else if (/bottom/.test(direction)) {",
                        "    setSnapped(event, 'y', targetTRBL.bottom - offset.y);",
                        "  }",
                        "",
                        "  if (/left/.test(direction)) {",
                        "    setSnapped(event, 'x', targetTRBL.left - offset.x);",
                        "  } else if (/right/.test(direction)) {",
                        "    setSnapped(event, 'x', targetTRBL.right - offset.x);",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {Element[]} elements",
                        " * @param {string} type",
                        " *",
                        " * @return {boolean}",
                        " */",
                        "function areAll(elements, type) {",
                        "  return elements.every(function(el) {",
                        "    return is(el, type);",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {Element} element",
                        " */",
                        "function isContainer(element) {",
                        "  if (is(element, 'bpmn:SubProcess') && isExpanded(element)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return is(element, 'bpmn:Participant');",
                        "}",
                        "",
                        "/**",
                        " * @param {Event} event",
                        " */",
                        "function setSnappedIfConstrained(event) {",
                        "  var context = event.context,",
                        "      createConstraints = context.createConstraints;",
                        "",
                        "  if (!createConstraints) {",
                        "    return;",
                        "  }",
                        "",
                        "  var top = createConstraints.top,",
                        "      right = createConstraints.right,",
                        "      bottom = createConstraints.bottom,",
                        "      left = createConstraints.left;",
                        "",
                        "  if ((left && left >= event.x) || (right && right <= event.x)) {",
                        "    setSnapped(event, 'x', event.x);",
                        "  }",
                        "",
                        "  if ((top && top >= event.y) || (bottom && bottom <= event.y)) {",
                        "    setSnapped(event, 'y', event.y);",
                        "  }",
                        "}",
                        "",
                        "function includes(array, value) {",
                        "  return array.indexOf(value) !== -1;",
                        "}",
                        "",
                        "function getDockingSnapOrigin(docking, isMove, event) {",
                        "  return isMove ? (",
                        "    {",
                        "      x: docking.x - event.x,",
                        "      y: docking.y - event.y",
                        "    }",
                        "  ) : {",
                        "    x: docking.x,",
                        "    y: docking.y",
                        "  };",
                        "}"
                    ]
                },
                "BpmnSnappingUtil.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { getOrientation } from 'diagram-js/lib/layout/LayoutUtil';",
                        "",
                        "/**",
                        " * @typedef {import('diagram-js/lib/util/Types').DirectionTRBL} DirectionTRBL",
                        " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                        " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                        " */",
                        "",
                        "/**",
                        " * @param {Point} position",
                        " * @param {Rect} targetBounds",
                        " *",
                        " * @return {DirectionTRBL|null}",
                        " */",
                        "export function getBoundaryAttachment(position, targetBounds) {",
                        "",
                        "  var orientation = getOrientation(position, targetBounds, -15);",
                        "",
                        "  if (orientation !== 'intersect') {",
                        "    return orientation;",
                        "  } else {",
                        "    return null;",
                        "  }",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import BpmnConnectSnapping from './BpmnConnectSnapping';",
                        "import BpmnCreateMoveSnapping from './BpmnCreateMoveSnapping';",
                        "import SnappingModule from 'diagram-js/lib/features/snapping';",
                        "",
                        "export default {",
                        "  __depends__: [ SnappingModule ],",
                        "  __init__: [",
                        "    'connectSnapping',",
                        "    'createMoveSnapping'",
                        "  ],",
                        "  connectSnapping: [ 'type', BpmnConnectSnapping ],",
                        "  createMoveSnapping: [ 'type', BpmnCreateMoveSnapping ]",
                        "};"
                    ]
                }
            },
            "space-tool": {
                "BpmnSpaceTool.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import inherits from 'inherits-browser';",
                        "",
                        "import SpaceTool from 'diagram-js/lib/features/space-tool/SpaceTool';",
                        "",
                        "import { getBusinessObject, is } from '../../util/ModelUtil';",
                        "",
                        "/**",
                        " * @typedef {import('didi').Injector} Injector",
                        " *",
                        " * @typedef {import('../../model/Types').Shape} Shape",
                        " *",
                        " * @typedef {import('diagram-js/lib/util/Types').Axis} Axis",
                        " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                        " */",
                        "",
                        "/**",
                        " * @param {Injector} injector",
                        " */",
                        "export default function BpmnSpaceTool(injector) {",
                        "  injector.invoke(SpaceTool, this);",
                        "}",
                        "",
                        "BpmnSpaceTool.$inject = [",
                        "  'injector'",
                        "];",
                        "",
                        "inherits(BpmnSpaceTool, SpaceTool);",
                        "",
                        "/**",
                        " * @param {Shape[]} elements",
                        " * @param {Axis} axis",
                        " * @param {Point} delta",
                        " * @param {number} start",
                        " *",
                        " * @return {Object}",
                        " */",
                        "BpmnSpaceTool.prototype.calculateAdjustments = function(elements, axis, delta, start) {",
                        "  var adjustments = SpaceTool.prototype.calculateAdjustments.call(this, elements, axis, delta, start);",
                        "",
                        "  // do not resize:",
                        "  //",
                        "  // * text annotations (horizontally/vertically)",
                        "  // * empty pools (vertically)",
                        "  adjustments.resizingShapes = adjustments.resizingShapes.filter(function(shape) {",
                        "",
                        "    if (is(shape, 'bpmn:TextAnnotation')) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (axis === 'y' && isCollapsedPool(shape)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return true;",
                        "  });",
                        "",
                        "  return adjustments;",
                        "};",
                        "",
                        "",
                        "// helpers ///////////",
                        "",
                        "function isCollapsedPool(shape) {",
                        "  return is(shape, 'bpmn:Participant') && !getBusinessObject(shape).processRef;",
                        "}"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import SpaceToolModule from 'diagram-js/lib/features/space-tool';",
                        "",
                        "import BpmnSpaceTool from './BpmnSpaceTool';",
                        "",
                        "export default {",
                        "  __depends__: [ SpaceToolModule ],",
                        "  spaceTool: [ 'type', BpmnSpaceTool ]",
                        "};"
                    ]
                }
            }
        },
        "import": {
            "BpmnImporter.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  assign",
                    "} from 'min-dash';",
                    "",
                    "import { is } from '../util/ModelUtil';",
                    "",
                    "import {",
                    "  isLabelExternal,",
                    "  getExternalLabelBounds,",
                    "  getLabel",
                    "} from '../util/LabelUtil';",
                    "",
                    "import {",
                    "  getMid",
                    "} from 'diagram-js/lib/layout/LayoutUtil';",
                    "",
                    "import {",
                    "  isExpanded",
                    "} from '../util/DiUtil';",
                    "",
                    "import {",
                    "  elementToString",
                    "} from './Util';",
                    "",
                    "/**",
                    " * @typedef {import('diagram-js/lib/core/Canvas').default} Canvas",
                    " * @typedef {import('diagram-js/lib/core/ElementRegistry').default} ElementRegistry",
                    " * @typedef {import('diagram-js/lib/core/EventBus').default} EventBus",
                    " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                    " *",
                    " * @typedef {import('../features/modeling/ElementFactory').default} ElementFactory",
                    " * @typedef {import('../draw/TextRenderer').default} TextRenderer",
                    " *",
                    " * @typedef {import('../model/Types').Element} Element",
                    " * @typedef {import('../model/Types').Label} Label",
                    " * @typedef {import('../model/Types').Shape} Shape",
                    " * @typedef {import('../model/Types').Connection} Connection",
                    " * @typedef {import('../model/Types').Root} Root",
                    " * @typedef {import('../model/Types').ModdleElement} ModdleElement",
                    " */",
                    "",
                    "/**",
                    " * @param {ModdleElement} semantic",
                    " * @param {ModdleElement} di",
                    " * @param {Object} [attrs=null]",
                    " *",
                    " * @return {Object}",
                    " */",
                    "function elementData(semantic, di, attrs) {",
                    "  return assign({",
                    "    id: semantic.id,",
                    "    type: semantic.$type,",
                    "    businessObject: semantic,",
                    "    di: di",
                    "  }, attrs);",
                    "}",
                    "",
                    "function getWaypoints(di, source, target) {",
                    "",
                    "  var waypoints = di.waypoint;",
                    "",
                    "  if (!waypoints || waypoints.length < 2) {",
                    "    return [ getMid(source), getMid(target) ];",
                    "  }",
                    "",
                    "  return waypoints.map(function(p) {",
                    "    return { x: p.x, y: p.y };",
                    "  });",
                    "}",
                    "",
                    "function notYetDrawn(translate, semantic, refSemantic, property) {",
                    "  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {",
                    "    element: elementToString(refSemantic),",
                    "    referenced: elementToString(semantic),",
                    "    property: property",
                    "  }));",
                    "}",
                    "",
                    "",
                    "/**",
                    " * An importer that adds bpmn elements to the canvas",
                    " *",
                    " * @param {EventBus} eventBus",
                    " * @param {Canvas} canvas",
                    " * @param {ElementFactory} elementFactory",
                    " * @param {ElementRegistry} elementRegistry",
                    " * @param {Function} translate",
                    " * @param {TextRenderer} textRenderer",
                    " */",
                    "export default function BpmnImporter(",
                    "    eventBus, canvas, elementFactory,",
                    "    elementRegistry, translate, textRenderer) {",
                    "",
                    "  this._eventBus = eventBus;",
                    "  this._canvas = canvas;",
                    "  this._elementFactory = elementFactory;",
                    "  this._elementRegistry = elementRegistry;",
                    "  this._translate = translate;",
                    "  this._textRenderer = textRenderer;",
                    "}",
                    "",
                    "BpmnImporter.$inject = [",
                    "  'eventBus',",
                    "  'canvas',",
                    "  'elementFactory',",
                    "  'elementRegistry',",
                    "  'translate',",
                    "  'textRenderer'",
                    "];",
                    "",
                    "",
                    "/**",
                    " * Add a BPMN element (semantic) to the canvas making it a child of the",
                    " * given parent.",
                    " *",
                    " * @param {ModdleElement} semantic",
                    " * @param {ModdleElement} di",
                    " * @param {Shape} parentElement",
                    " *",
                    " * @return {Shape | Root | Connection}",
                    " */",
                    "BpmnImporter.prototype.add = function(semantic, di, parentElement) {",
                    "  var element,",
                    "      translate = this._translate,",
                    "      hidden;",
                    "",
                    "  var parentIndex;",
                    "",
                    "  // ROOT ELEMENT",
                    "  // handle the special case that we deal with a",
                    "  // invisible root element (process, subprocess or collaboration)",
                    "  if (is(di, 'bpmndi:BPMNPlane')) {",
                    "",
                    "    var attrs = is(semantic, 'bpmn:SubProcess')",
                    "      ? { id: semantic.id + '_plane' }",
                    "      : {};",
                    "",
                    "    // add a virtual element (not being drawn)",
                    "    element = this._elementFactory.createRoot(elementData(semantic, di, attrs));",
                    "",
                    "    this._canvas.addRootElement(element);",
                    "  }",
                    "",
                    "  // SHAPE",
                    "  else if (is(di, 'bpmndi:BPMNShape')) {",
                    "",
                    "    var collapsed = !isExpanded(semantic, di),",
                    "        isFrame = isFrameElement(semantic);",
                    "",
                    "    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);",
                    "",
                    "    var bounds = di.bounds;",
                    "",
                    "    element = this._elementFactory.createShape(elementData(semantic, di, {",
                    "      collapsed: collapsed,",
                    "      hidden: hidden,",
                    "      x: Math.round(bounds.x),",
                    "      y: Math.round(bounds.y),",
                    "      width: Math.round(bounds.width),",
                    "      height: Math.round(bounds.height),",
                    "      isFrame: isFrame",
                    "    }));",
                    "",
                    "    if (is(semantic, 'bpmn:BoundaryEvent')) {",
                    "      this._attachBoundary(semantic, element);",
                    "    }",
                    "",
                    "    // insert lanes behind other flow nodes (cf. #727)",
                    "    if (is(semantic, 'bpmn:Lane')) {",
                    "      parentIndex = 0;",
                    "    }",
                    "",
                    "    if (is(semantic, 'bpmn:DataStoreReference')) {",
                    "",
                    "      // check whether data store is inside our outside of its semantic parent",
                    "      if (!isPointInsideBBox(parentElement, getMid(bounds))) {",
                    "        parentElement = this._canvas.findRoot(parentElement);",
                    "      }",
                    "    }",
                    "",
                    "    this._canvas.addShape(element, parentElement, parentIndex);",
                    "  }",
                    "",
                    "  // CONNECTION",
                    "  else if (is(di, 'bpmndi:BPMNEdge')) {",
                    "",
                    "    var source = this._getSource(semantic),",
                    "        target = this._getTarget(semantic);",
                    "",
                    "    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);",
                    "",
                    "    element = this._elementFactory.createConnection(elementData(semantic, di, {",
                    "      hidden: hidden,",
                    "      source: source,",
                    "      target: target,",
                    "      waypoints: getWaypoints(di, source, target)",
                    "    }));",
                    "",
                    "    if (is(semantic, 'bpmn:DataAssociation')) {",
                    "",
                    "      // render always on top; this ensures DataAssociations",
                    "      // are rendered correctly across different \"hacks\" people",
                    "      // love to model such as cross participant / sub process",
                    "      // associations",
                    "      parentElement = this._canvas.findRoot(parentElement);",
                    "    }",
                    "",
                    "    this._canvas.addConnection(element, parentElement, parentIndex);",
                    "  } else {",
                    "    throw new Error(translate('unknown di {di} for element {semantic}', {",
                    "      di: elementToString(di),",
                    "      semantic: elementToString(semantic)",
                    "    }));",
                    "  }",
                    "",
                    "  // (optional) LABEL",
                    "  if (isLabelExternal(semantic) && getLabel(element)) {",
                    "    this.addLabel(semantic, di, element);",
                    "  }",
                    "",
                    "",
                    "  this._eventBus.fire('bpmnElement.added', { element: element });",
                    "",
                    "  return element;",
                    "};",
                    "",
                    "",
                    "/**",
                    " * Attach a boundary element to the given host.",
                    " *",
                    " * @param {ModdleElement} boundarySemantic",
                    " * @param {Shape} boundaryElement",
                    " */",
                    "BpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {",
                    "  var translate = this._translate;",
                    "  var hostSemantic = boundarySemantic.attachedToRef;",
                    "",
                    "  if (!hostSemantic) {",
                    "    throw new Error(translate('missing {semantic}#attachedToRef', {",
                    "      semantic: elementToString(boundarySemantic)",
                    "    }));",
                    "  }",
                    "",
                    "  var host = this._elementRegistry.get(hostSemantic.id),",
                    "      attachers = host && host.attachers;",
                    "",
                    "  if (!host) {",
                    "    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');",
                    "  }",
                    "",
                    "  // wire element.host <> host.attachers",
                    "  boundaryElement.host = host;",
                    "",
                    "  if (!attachers) {",
                    "    host.attachers = attachers = [];",
                    "  }",
                    "",
                    "  if (attachers.indexOf(boundaryElement) === -1) {",
                    "    attachers.push(boundaryElement);",
                    "  }",
                    "};",
                    "",
                    "",
                    "/**",
                    " * Add a label to a given element.",
                    " *",
                    " * @param {ModdleElement} semantic",
                    " * @param {ModdleElement} di",
                    " * @param {Element} element",
                    " *",
                    " * @return {Label}",
                    " */",
                    "BpmnImporter.prototype.addLabel = function(semantic, di, element) {",
                    "  var bounds,",
                    "      text,",
                    "      label;",
                    "",
                    "  bounds = getExternalLabelBounds(di, element);",
                    "",
                    "  text = getLabel(element);",
                    "",
                    "  if (text) {",
                    "",
                    "    // get corrected bounds from actual layouted text",
                    "    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);",
                    "  }",
                    "",
                    "  label = this._elementFactory.createLabel(elementData(semantic, di, {",
                    "    id: semantic.id + '_label',",
                    "    labelTarget: element,",
                    "    type: 'label',",
                    "    hidden: element.hidden || !getLabel(element),",
                    "    x: Math.round(bounds.x),",
                    "    y: Math.round(bounds.y),",
                    "    width: Math.round(bounds.width),",
                    "    height: Math.round(bounds.height)",
                    "  }));",
                    "",
                    "  return this._canvas.addShape(label, element.parent);",
                    "};",
                    "",
                    "/**",
                    " * Get the source or target of the given connection.",
                    " *",
                    " * @param {ModdleElement} semantic",
                    " * @param {'source' | 'target'} side",
                    " *",
                    " * @return {Element}",
                    " */",
                    "BpmnImporter.prototype._getConnectedElement = function(semantic, side) {",
                    "",
                    "  var element,",
                    "      refSemantic,",
                    "      type = semantic.$type,",
                    "      translate = this._translate;",
                    "",
                    "  refSemantic = semantic[side + 'Ref'];",
                    "",
                    "  // handle mysterious isMany DataAssociation#sourceRef",
                    "  if (side === 'source' && type === 'bpmn:DataInputAssociation') {",
                    "    refSemantic = refSemantic && refSemantic[0];",
                    "  }",
                    "",
                    "  // fix source / target for DataInputAssociation / DataOutputAssociation",
                    "  if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||",
                    "      side === 'target' && type === 'bpmn:DataInputAssociation') {",
                    "",
                    "    refSemantic = semantic.$parent;",
                    "  }",
                    "",
                    "  element = refSemantic && this._getElement(refSemantic);",
                    "",
                    "  if (element) {",
                    "    return element;",
                    "  }",
                    "",
                    "  if (refSemantic) {",
                    "    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');",
                    "  } else {",
                    "    throw new Error(translate('{semantic}#{side} Ref not specified', {",
                    "      semantic: elementToString(semantic),",
                    "      side: side",
                    "    }));",
                    "  }",
                    "};",
                    "",
                    "BpmnImporter.prototype._getSource = function(semantic) {",
                    "  return this._getConnectedElement(semantic, 'source');",
                    "};",
                    "",
                    "BpmnImporter.prototype._getTarget = function(semantic) {",
                    "  return this._getConnectedElement(semantic, 'target');",
                    "};",
                    "",
                    "",
                    "BpmnImporter.prototype._getElement = function(semantic) {",
                    "  return this._elementRegistry.get(semantic.id);",
                    "};",
                    "",
                    "",
                    "// helpers ////////////////////",
                    "",
                    "function isPointInsideBBox(bbox, point) {",
                    "  var x = point.x,",
                    "      y = point.y;",
                    "",
                    "  return x >= bbox.x &&",
                    "    x <= bbox.x + bbox.width &&",
                    "    y >= bbox.y &&",
                    "    y <= bbox.y + bbox.height;",
                    "}",
                    "",
                    "function isFrameElement(semantic) {",
                    "  return is(semantic, 'bpmn:Group');",
                    "}"
                ]
            },
            "BpmnTreeWalker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  filter,",
                    "  find,",
                    "  forEach",
                    "} from 'min-dash';",
                    "",
                    "import {",
                    "  elementToString",
                    "} from './Util';",
                    "",
                    "import {",
                    "  ensureCompatDiRef",
                    "} from '../util/CompatibilityUtil';",
                    "",
                    "/**",
                    " * @typedef {import('diagram-js/lib/i18n/translate/translate').default} Translate",
                    " *",
                    " * @typedef {import('../model/Types').ModdleElement} ModdleElement",
                    " */",
                    "",
                    "/**",
                    " * Returns true if an element is of the given meta-model type.",
                    " *",
                    " * @param {ModdleElement} element",
                    " * @param {string} type",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "function is(element, type) {",
                    "  return element.$instanceOf(type);",
                    "}",
                    "",
                    "",
                    "/**",
                    " * Find a suitable display candidate for definitions where the DI does not",
                    " * correctly specify one.",
                    " *",
                    " * @param {ModdleElement} definitions",
                    " *",
                    " * @return {ModdleElement}",
                    " */",
                    "function findDisplayCandidate(definitions) {",
                    "  return find(definitions.rootElements, function(e) {",
                    "    return is(e, 'bpmn:Process') || is(e, 'bpmn:Collaboration');",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {Record<'element' | 'root' | 'error', Function>} handler",
                    " * @param {Translate} translate",
                    " */",
                    "export default function BpmnTreeWalker(handler, translate) {",
                    "",
                    "  // list of containers already walked",
                    "  var handledElements = {};",
                    "",
                    "  // list of elements to handle deferred to ensure",
                    "  // prerequisites are drawn",
                    "  var deferred = [];",
                    "",
                    "  var diMap = {};",
                    "",
                    "  // Helpers //////////////////////",
                    "",
                    "  function contextual(fn, ctx) {",
                    "    return function(e) {",
                    "      fn(e, ctx);",
                    "    };",
                    "  }",
                    "",
                    "  function handled(element) {",
                    "    handledElements[element.id] = element;",
                    "  }",
                    "",
                    "  function isHandled(element) {",
                    "    return handledElements[element.id];",
                    "  }",
                    "",
                    "  function visit(element, ctx) {",
                    "",
                    "    var gfx = element.gfx;",
                    "",
                    "    // avoid multiple rendering of elements",
                    "    if (gfx) {",
                    "      throw new Error(",
                    "        translate('already rendered {element}', { element: elementToString(element) })",
                    "      );",
                    "    }",
                    "",
                    "    // call handler",
                    "    return handler.element(element, diMap[element.id], ctx);",
                    "  }",
                    "",
                    "  function visitRoot(element, diagram) {",
                    "    return handler.root(element, diMap[element.id], diagram);",
                    "  }",
                    "",
                    "  function visitIfDi(element, ctx) {",
                    "",
                    "    try {",
                    "      var gfx = diMap[element.id] && visit(element, ctx);",
                    "",
                    "      handled(element);",
                    "",
                    "      return gfx;",
                    "    } catch (e) {",
                    "      logError(e.message, { element: element, error: e });",
                    "",
                    "      console.error(translate('failed to import {element}', { element: elementToString(element) }));",
                    "      console.error(e);",
                    "    }",
                    "  }",
                    "",
                    "  function logError(message, context) {",
                    "    handler.error(message, context);",
                    "  }",
                    "",
                    "  // DI handling //////////////////////",
                    "",
                    "  var registerDi = this.registerDi = function registerDi(di) {",
                    "    var bpmnElement = di.bpmnElement;",
                    "",
                    "    if (bpmnElement) {",
                    "      if (diMap[bpmnElement.id]) {",
                    "        logError(",
                    "          translate('multiple DI elements defined for {element}', {",
                    "            element: elementToString(bpmnElement)",
                    "          }),",
                    "          { element: bpmnElement }",
                    "        );",
                    "      } else {",
                    "        diMap[bpmnElement.id] = di;",
                    "",
                    "        ensureCompatDiRef(bpmnElement);",
                    "      }",
                    "    } else {",
                    "      logError(",
                    "        translate('no bpmnElement referenced in {element}', {",
                    "          element: elementToString(di)",
                    "        }),",
                    "        { element: di }",
                    "      );",
                    "    }",
                    "  };",
                    "",
                    "  function handleDiagram(diagram) {",
                    "    handlePlane(diagram.plane);",
                    "  }",
                    "",
                    "  function handlePlane(plane) {",
                    "    registerDi(plane);",
                    "",
                    "    forEach(plane.planeElement, handlePlaneElement);",
                    "  }",
                    "",
                    "  function handlePlaneElement(planeElement) {",
                    "    registerDi(planeElement);",
                    "  }",
                    "",
                    "",
                    "  // Semantic handling //////////////////////",
                    "",
                    "  /**",
                    "   * Handle definitions and return the rendered diagram (if any).",
                    "   *",
                    "   * @param {ModdleElement} definitions to walk and import",
                    "   * @param {ModdleElement} [diagram] specific diagram to import and display",
                    "   *",
                    "   * @throws {Error} if no diagram to display could be found",
                    "   */",
                    "  this.handleDefinitions = function handleDefinitions(definitions, diagram) {",
                    "",
                    "    // make sure we walk the correct bpmnElement",
                    "",
                    "    var diagrams = definitions.diagrams;",
                    "",
                    "    if (diagram && diagrams.indexOf(diagram) === -1) {",
                    "      throw new Error(translate('diagram not part of bpmn:Definitions'));",
                    "    }",
                    "",
                    "    if (!diagram && diagrams && diagrams.length) {",
                    "      diagram = diagrams[0];",
                    "    }",
                    "",
                    "    // no diagram -> nothing to import",
                    "    if (!diagram) {",
                    "      throw new Error(translate('no diagram to display'));",
                    "    }",
                    "",
                    "    // load DI from selected diagram only",
                    "    diMap = {};",
                    "    handleDiagram(diagram);",
                    "",
                    "",
                    "    var plane = diagram.plane;",
                    "",
                    "    if (!plane) {",
                    "      throw new Error(translate(",
                    "        'no plane for {element}',",
                    "        { element: elementToString(diagram) }",
                    "      ));",
                    "    }",
                    "",
                    "    var rootElement = plane.bpmnElement;",
                    "",
                    "    // ensure we default to a suitable display candidate (process or collaboration),",
                    "    // even if non is specified in DI",
                    "    if (!rootElement) {",
                    "      rootElement = findDisplayCandidate(definitions);",
                    "",
                    "      if (!rootElement) {",
                    "        throw new Error(translate('no process or collaboration to display'));",
                    "      } else {",
                    "",
                    "        logError(",
                    "          translate('correcting missing bpmnElement on {plane} to {rootElement}', {",
                    "            plane: elementToString(plane),",
                    "            rootElement: elementToString(rootElement)",
                    "          })",
                    "        );",
                    "",
                    "        // correct DI on the fly",
                    "        plane.bpmnElement = rootElement;",
                    "        registerDi(plane);",
                    "      }",
                    "    }",
                    "",
                    "",
                    "    var ctx = visitRoot(rootElement, plane);",
                    "",
                    "    if (is(rootElement, 'bpmn:Process') || is(rootElement, 'bpmn:SubProcess')) {",
                    "      handleProcess(rootElement, ctx);",
                    "    } else if (is(rootElement, 'bpmn:Collaboration')) {",
                    "      handleCollaboration(rootElement, ctx);",
                    "",
                    "      // force drawing of everything not yet drawn that is part of the target DI",
                    "      handleUnhandledProcesses(definitions.rootElements, ctx);",
                    "    } else {",
                    "      throw new Error(",
                    "        translate('unsupported bpmnElement for {plane}: {rootElement}', {",
                    "          plane: elementToString(plane),",
                    "          rootElement: elementToString(rootElement)",
                    "        })",
                    "      );",
                    "    }",
                    "",
                    "    // handle all deferred elements",
                    "    handleDeferred(deferred);",
                    "  };",
                    "",
                    "  var handleDeferred = this.handleDeferred = function handleDeferred() {",
                    "",
                    "    var fn;",
                    "",
                    "    // drain deferred until empty",
                    "    while (deferred.length) {",
                    "      fn = deferred.shift();",
                    "",
                    "      fn();",
                    "    }",
                    "  };",
                    "",
                    "  function handleProcess(process, context) {",
                    "    handleFlowElementsContainer(process, context);",
                    "    handleIoSpecification(process.ioSpecification, context);",
                    "",
                    "    handleArtifacts(process.artifacts, context);",
                    "",
                    "    // log process handled",
                    "    handled(process);",
                    "  }",
                    "",
                    "  function handleUnhandledProcesses(rootElements, ctx) {",
                    "",
                    "    // walk through all processes that have not yet been drawn and draw them",
                    "    // if they contain lanes with DI information.",
                    "    // we do this to pass the free-floating lane test cases in the MIWG test suite",
                    "    var processes = filter(rootElements, function(e) {",
                    "      return !isHandled(e) && is(e, 'bpmn:Process') && e.laneSets;",
                    "    });",
                    "",
                    "    processes.forEach(contextual(handleProcess, ctx));",
                    "  }",
                    "",
                    "  function handleMessageFlow(messageFlow, context) {",
                    "    visitIfDi(messageFlow, context);",
                    "  }",
                    "",
                    "  function handleMessageFlows(messageFlows, context) {",
                    "    forEach(messageFlows, contextual(handleMessageFlow, context));",
                    "  }",
                    "",
                    "  function handleDataAssociation(association, context) {",
                    "    visitIfDi(association, context);",
                    "  }",
                    "",
                    "  function handleDataInput(dataInput, context) {",
                    "    visitIfDi(dataInput, context);",
                    "  }",
                    "",
                    "  function handleDataOutput(dataOutput, context) {",
                    "    visitIfDi(dataOutput, context);",
                    "  }",
                    "",
                    "  function handleArtifact(artifact, context) {",
                    "",
                    "    // bpmn:TextAnnotation",
                    "    // bpmn:Group",
                    "    // bpmn:Association",
                    "",
                    "    visitIfDi(artifact, context);",
                    "  }",
                    "",
                    "  function handleArtifacts(artifacts, context) {",
                    "",
                    "    forEach(artifacts, function(e) {",
                    "      if (is(e, 'bpmn:Association')) {",
                    "        deferred.push(function() {",
                    "          handleArtifact(e, context);",
                    "        });",
                    "      } else {",
                    "        handleArtifact(e, context);",
                    "      }",
                    "    });",
                    "  }",
                    "",
                    "  function handleIoSpecification(ioSpecification, context) {",
                    "",
                    "    if (!ioSpecification) {",
                    "      return;",
                    "    }",
                    "",
                    "    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));",
                    "    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));",
                    "  }",
                    "",
                    "  var handleSubProcess = this.handleSubProcess = function handleSubProcess(subProcess, context) {",
                    "    handleFlowElementsContainer(subProcess, context);",
                    "    handleArtifacts(subProcess.artifacts, context);",
                    "  };",
                    "",
                    "  function handleFlowNode(flowNode, context) {",
                    "    var childCtx = visitIfDi(flowNode, context);",
                    "",
                    "    if (is(flowNode, 'bpmn:SubProcess')) {",
                    "      handleSubProcess(flowNode, childCtx || context);",
                    "    }",
                    "",
                    "    if (is(flowNode, 'bpmn:Activity')) {",
                    "      handleIoSpecification(flowNode.ioSpecification, context);",
                    "    }",
                    "",
                    "    // defer handling of associations",
                    "    // affected types:",
                    "    //",
                    "    //   * bpmn:Activity",
                    "    //   * bpmn:ThrowEvent",
                    "    //   * bpmn:CatchEvent",
                    "    //",
                    "    deferred.push(function() {",
                    "      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));",
                    "      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));",
                    "    });",
                    "  }",
                    "",
                    "  function handleSequenceFlow(sequenceFlow, context) {",
                    "    visitIfDi(sequenceFlow, context);",
                    "  }",
                    "",
                    "  function handleDataElement(dataObject, context) {",
                    "    visitIfDi(dataObject, context);",
                    "  }",
                    "",
                    "  function handleLane(lane, context) {",
                    "",
                    "    deferred.push(function() {",
                    "",
                    "      var newContext = visitIfDi(lane, context);",
                    "",
                    "      if (lane.childLaneSet) {",
                    "        handleLaneSet(lane.childLaneSet, newContext || context);",
                    "      }",
                    "",
                    "      wireFlowNodeRefs(lane);",
                    "    });",
                    "  }",
                    "",
                    "  function handleLaneSet(laneSet, context) {",
                    "    forEach(laneSet.lanes, contextual(handleLane, context));",
                    "  }",
                    "",
                    "  function handleLaneSets(laneSets, context) {",
                    "    forEach(laneSets, contextual(handleLaneSet, context));",
                    "  }",
                    "",
                    "  function handleFlowElementsContainer(container, context) {",
                    "    handleFlowElements(container.flowElements, context);",
                    "",
                    "    if (container.laneSets) {",
                    "      handleLaneSets(container.laneSets, context);",
                    "    }",
                    "  }",
                    "",
                    "  function handleFlowElements(flowElements, context) {",
                    "    forEach(flowElements, function(e) {",
                    "      if (is(e, 'bpmn:SequenceFlow')) {",
                    "        deferred.push(function() {",
                    "          handleSequenceFlow(e, context);",
                    "        });",
                    "      } else if (is(e, 'bpmn:BoundaryEvent')) {",
                    "        deferred.unshift(function() {",
                    "          handleFlowNode(e, context);",
                    "        });",
                    "      } else if (is(e, 'bpmn:FlowNode')) {",
                    "        handleFlowNode(e, context);",
                    "      } else if (is(e, 'bpmn:DataObject')) {",
                    "",
                    "        // SKIP (assume correct referencing via DataObjectReference)",
                    "      } else if (is(e, 'bpmn:DataStoreReference')) {",
                    "        handleDataElement(e, context);",
                    "      } else if (is(e, 'bpmn:DataObjectReference')) {",
                    "        handleDataElement(e, context);",
                    "      } else {",
                    "        logError(",
                    "          translate('unrecognized flowElement {element} in context {context}', {",
                    "            element: elementToString(e),",
                    "            context: (context ? elementToString(context.businessObject) : 'null')",
                    "          }),",
                    "          { element: e, context: context }",
                    "        );",
                    "      }",
                    "    });",
                    "  }",
                    "",
                    "  function handleParticipant(participant, context) {",
                    "    var newCtx = visitIfDi(participant, context);",
                    "",
                    "    var process = participant.processRef;",
                    "    if (process) {",
                    "      handleProcess(process, newCtx || context);",
                    "    }",
                    "  }",
                    "",
                    "  function handleCollaboration(collaboration, context) {",
                    "",
                    "    forEach(collaboration.participants, contextual(handleParticipant, context));",
                    "",
                    "    handleArtifacts(collaboration.artifacts, context);",
                    "",
                    "    // handle message flows latest in the process",
                    "    deferred.push(function() {",
                    "      handleMessageFlows(collaboration.messageFlows, context);",
                    "    });",
                    "  }",
                    "",
                    "",
                    "  function wireFlowNodeRefs(lane) {",
                    "",
                    "    // wire the virtual flowNodeRefs <-> relationship",
                    "    forEach(lane.flowNodeRef, function(flowNode) {",
                    "      var lanes = flowNode.get('lanes');",
                    "",
                    "      if (lanes) {",
                    "        lanes.push(lane);",
                    "      }",
                    "    });",
                    "  }",
                    "}"
                ]
            },
            "Importer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  find,",
                    "  forEach,",
                    "  map",
                    "} from 'min-dash';",
                    "",
                    "import BpmnTreeWalker from './BpmnTreeWalker';",
                    "",
                    "import { is } from '../util/ModelUtil';",
                    "",
                    "",
                    "/**",
                    " * @typedef {import('../model/Types').ModdleElement} ModdleElement",
                    " *",
                    " * @typedef { {",
                    " *   warnings: string[];",
                    " * } } ImportBPMNDiagramResult",
                    " *",
                    " * @typedef {ImportBPMNDiagramResult & Error} ImportBPMNDiagramError",
                    " */",
                    "",
                    "/**",
                    " * Import the definitions into a diagram.",
                    " *",
                    " * Errors and warnings are reported through the specified callback.",
                    " *",
                    " * @param {ModdleElement} diagram",
                    " * @param {ModdleElement} definitions",
                    " * @param {ModdleElement} [bpmnDiagram] The diagram to be rendered (if not",
                    " * provided, the first one will be rendered).",
                    " *",
                    " * @return {Promise<ImportBPMNDiagramResult>}",
                    " */",
                    "export function importBpmnDiagram(diagram, definitions, bpmnDiagram) {",
                    "",
                    "  var importer,",
                    "      eventBus,",
                    "      translate,",
                    "      canvas;",
                    "",
                    "  var error,",
                    "      warnings = [];",
                    "",
                    "  /**",
                    "   * Walk the diagram semantically, importing (=drawing)",
                    "   * all elements you encounter.",
                    "   *",
                    "   * @param {ModdleElement} definitions",
                    "   * @param {ModdleElement} bpmnDiagram",
                    "   */",
                    "  function render(definitions, bpmnDiagram) {",
                    "",
                    "    var visitor = {",
                    "",
                    "      root: function(element, di) {",
                    "        return importer.add(element, di);",
                    "      },",
                    "",
                    "      element: function(element, di, parentShape) {",
                    "        return importer.add(element, di, parentShape);",
                    "      },",
                    "",
                    "      error: function(message, context) {",
                    "        warnings.push({ message: message, context: context });",
                    "      }",
                    "    };",
                    "",
                    "    var walker = new BpmnTreeWalker(visitor, translate);",
                    "",
                    "",
                    "    bpmnDiagram = bpmnDiagram || (definitions.diagrams && definitions.diagrams[0]);",
                    "",
                    "    var diagramsToImport = getDiagramsToImport(definitions, bpmnDiagram);",
                    "",
                    "    if (!diagramsToImport) {",
                    "      throw new Error(translate('no diagram to display'));",
                    "    }",
                    "",
                    "    // traverse BPMN 2.0 document model,",
                    "    // starting at definitions",
                    "    forEach(diagramsToImport, function(diagram) {",
                    "      walker.handleDefinitions(definitions, diagram);",
                    "    });",
                    "",
                    "    var rootId = bpmnDiagram.plane.bpmnElement.id;",
                    "",
                    "    // we do need to account for different ways we create root elements",
                    "    // each nested imported <root> do have the `_plane` suffix, while",
                    "    // the root <root> is found under the business object ID",
                    "    canvas.setRootElement(",
                    "      canvas.findRoot(rootId + '_plane') || canvas.findRoot(rootId)",
                    "    );",
                    "  }",
                    "",
                    "  return new Promise(function(resolve, reject) {",
                    "    try {",
                    "      importer = diagram.get('bpmnImporter');",
                    "      eventBus = diagram.get('eventBus');",
                    "      translate = diagram.get('translate');",
                    "      canvas = diagram.get('canvas');",
                    "",
                    "      eventBus.fire('import.render.start', { definitions: definitions });",
                    "",
                    "      render(definitions, bpmnDiagram);",
                    "",
                    "      eventBus.fire('import.render.complete', {",
                    "        error: error,",
                    "        warnings: warnings",
                    "      });",
                    "",
                    "      return resolve({ warnings: warnings });",
                    "    } catch (e) {",
                    "",
                    "      e.warnings = warnings;",
                    "      return reject(e);",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * Returns all diagrams in the same hierarchy as the requested diagram.",
                    " * Includes all parent and sub process diagrams.",
                    " *",
                    " * @param {ModdleElement} definitions",
                    " * @param {ModdleElement} bpmnDiagram",
                    " *",
                    " * @return {ModdleElement[]}",
                    " */",
                    "function getDiagramsToImport(definitions, bpmnDiagram) {",
                    "  if (!bpmnDiagram) {",
                    "    return;",
                    "  }",
                    "",
                    "  var bpmnElement = bpmnDiagram.plane.bpmnElement,",
                    "      rootElement = bpmnElement;",
                    "",
                    "  if (!is(bpmnElement, 'bpmn:Process') && !is(bpmnElement, 'bpmn:Collaboration')) {",
                    "    rootElement = findRootProcess(bpmnElement);",
                    "  }",
                    "",
                    "  // in case the process is part of a collaboration, the plane references the",
                    "  // collaboration, not the process",
                    "  var collaboration;",
                    "",
                    "  if (is(rootElement, 'bpmn:Collaboration')) {",
                    "    collaboration = rootElement;",
                    "  } else {",
                    "    collaboration = find(definitions.rootElements, function(element) {",
                    "      if (!is(element, 'bpmn:Collaboration')) {",
                    "        return;",
                    "      }",
                    "",
                    "      return find(element.participants, function(participant) {",
                    "        return participant.processRef === rootElement;",
                    "      });",
                    "    });",
                    "  }",
                    "",
                    "  var rootElements = [ rootElement ];",
                    "",
                    "  // all collaboration processes can contain sub-diagrams",
                    "  if (collaboration) {",
                    "    rootElements = map(collaboration.participants, function(participant) {",
                    "      return participant.processRef;",
                    "    });",
                    "",
                    "    rootElements.push(collaboration);",
                    "  }",
                    "",
                    "  var allChildren = selfAndAllFlowElements(rootElements);",
                    "",
                    "  // if we have multiple diagrams referencing the same element, we",
                    "  // use the first in the file",
                    "  var diagramsToImport = [ bpmnDiagram ];",
                    "  var handledElements = [ bpmnElement ];",
                    "",
                    "  forEach(definitions.diagrams, function(diagram) {",
                    "    var businessObject = diagram.plane.bpmnElement;",
                    "",
                    "    if (",
                    "      allChildren.indexOf(businessObject) !== -1 &&",
                    "      handledElements.indexOf(businessObject) === -1",
                    "    ) {",
                    "      diagramsToImport.push(diagram);",
                    "      handledElements.push(businessObject);",
                    "    }",
                    "  });",
                    "",
                    "",
                    "  return diagramsToImport;",
                    "}",
                    "",
                    "function selfAndAllFlowElements(elements) {",
                    "  var result = [];",
                    "",
                    "  forEach(elements, function(element) {",
                    "    if (!element) {",
                    "      return;",
                    "    }",
                    "",
                    "    result.push(element);",
                    "",
                    "    result = result.concat(selfAndAllFlowElements(element.flowElements));",
                    "  });",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function findRootProcess(element) {",
                    "  var parent = element;",
                    "",
                    "  while (parent) {",
                    "    if (is(parent, 'bpmn:Process')) {",
                    "      return parent;",
                    "    }",
                    "",
                    "    parent = parent.$parent;",
                    "  }",
                    "}"
                ]
            },
            "Util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function elementToString(e) {",
                    "  if (!e) {",
                    "    return '<null>';",
                    "  }",
                    "",
                    "  return '<' + e.$type + (e.id ? ' id=\"' + e.id : '') + '\" />';",
                    "}"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import translate from 'diagram-js/lib/i18n/translate';",
                    "",
                    "import BpmnImporter from './BpmnImporter';",
                    "",
                    "export default {",
                    "  __depends__: [",
                    "    translate",
                    "  ],",
                    "  bpmnImporter: [ 'type', BpmnImporter ]",
                    "};"
                ]
            }
        },
        "model": {
            "Types.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "import type {",
                    "  Connection as BaseConnection,",
                    "  Element as BaseElement,",
                    "  Label as BaseLabel,",
                    "  Root as BaseRoot,",
                    "  Shape as BaseShape",
                    "} from \"diagram-js/lib/model\";",
                    "",
                    "export type Moddle = any;",
                    "",
                    "export type ModdleElement = any;",
                    "",
                    "export type ModdleExtension = {};",
                    "",
                    "export type BpmnAttributes = {",
                    "  associationDirection: 'None' | 'One' | 'Both';",
                    "  cancelActivity: boolean;",
                    "  eventDefinitionType: string;",
                    "  isExpanded: boolean;",
                    "  isForCompensation: boolean;",
                    "  isInterrupting: boolean;",
                    "  processRef: ModdleElement;",
                    "  triggeredByEvent: boolean;",
                    "};",
                    "",
                    "export type Element = {",
                    "  businessObject: any;",
                    "  di: any;",
                    "  type: string;",
                    "} & BaseElement;",
                    "",
                    "export type Connection = BaseConnection & Element;",
                    "",
                    "export type Label = BaseLabel & Element;",
                    "",
                    "export type Root = BaseRoot & Element;",
                    "",
                    "export type Shape = BaseShape & Element;",
                    "",
                    "export type Parent = Root | Shape;"
                ]
            }
        },
        "util": {
            "CompatibilityUtil.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  has",
                    "} from 'min-dash';",
                    "",
                    "/**",
                    " * @typedef {import('../model/Types').ModdleElement} ModdleElement",
                    " */",
                    "",
                    "",
                    "// TODO(nikku): remove with future bpmn-js version",
                    "",
                    "var DI_ERROR_MESSAGE = 'Tried to access di from the businessObject. The di is available through the diagram element only. For more information, see https://github.com/bpmn-io/bpmn-js/issues/1472';",
                    "",
                    "/**",
                    " * @private",
                    " *",
                    " * @param {ModdleElement} businessObject",
                    " */",
                    "export function ensureCompatDiRef(businessObject) {",
                    "",
                    "  // bpmnElement can have multiple independent DIs",
                    "  if (!has(businessObject, 'di')) {",
                    "    Object.defineProperty(businessObject, 'di', {",
                    "      enumerable: false,",
                    "      get: function() {",
                    "        throw new Error(DI_ERROR_MESSAGE);",
                    "      }",
                    "    });",
                    "  }",
                    "}"
                ]
            },
            "DiUtil.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  is,",
                    "  getBusinessObject,",
                    "  getDi",
                    "} from './ModelUtil';",
                    "",
                    "import {",
                    "  some",
                    "} from 'min-dash';",
                    "",
                    "/**",
                    " * @typedef {import('../model/Types').Element} Element",
                    " * @typedef {import('../model/Types').ModdleElement} ModdleElement",
                    " */",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " * @param {ModdleElement} [di]",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isExpanded(element, di) {",
                    "",
                    "  if (is(element, 'bpmn:CallActivity')) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (is(element, 'bpmn:SubProcess')) {",
                    "    di = di || getDi(element);",
                    "",
                    "    if (di && is(di, 'bpmndi:BPMNPlane')) {",
                    "      return true;",
                    "    }",
                    "",
                    "    return di && !!di.isExpanded;",
                    "  }",
                    "",
                    "  if (is(element, 'bpmn:Participant')) {",
                    "    return !!getBusinessObject(element).processRef;",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isInterrupting(element) {",
                    "  return element && getBusinessObject(element).isInterrupting !== false;",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isEventSubProcess(element) {",
                    "  return element && !!getBusinessObject(element).triggeredByEvent;",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " * @param {string} eventType",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function hasEventDefinition(element, eventType) {",
                    "  var eventDefinitions = getBusinessObject(element).eventDefinitions;",
                    "",
                    "  return some(eventDefinitions, function(event) {",
                    "    return is(event, eventType);",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function hasErrorEventDefinition(element) {",
                    "  return hasEventDefinition(element, 'bpmn:ErrorEventDefinition');",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function hasEscalationEventDefinition(element) {",
                    "  return hasEventDefinition(element, 'bpmn:EscalationEventDefinition');",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function hasCompensateEventDefinition(element) {",
                    "  return hasEventDefinition(element, 'bpmn:CompensateEventDefinition');",
                    "}"
                ]
            },
            "DrilldownUtil.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { getDi, is } from './ModelUtil';",
                    "",
                    "/**",
                    " * @typedef {import('../model/Types').Element} Element",
                    " * @typedef {import('../model/Types').ModdleElement} ModdleElement",
                    " */",
                    "",
                    "export var planeSuffix = '_plane';",
                    "",
                    "/**",
                    " * Get primary shape ID for a plane.",
                    " *",
                    " * @param  {Element|ModdleElement} element",
                    " *",
                    " * @return {string}",
                    " */",
                    "export function getShapeIdFromPlane(element) {",
                    "  var id = element.id;",
                    "",
                    "  return removePlaneSuffix(id);",
                    "}",
                    "",
                    "/**",
                    " * Get plane ID for a primary shape.",
                    " *",
                    " * @param  {Element|ModdleElement} element",
                    " *",
                    " * @return {string}",
                    " */",
                    "export function getPlaneIdFromShape(element) {",
                    "  var id = element.id;",
                    "",
                    "  if (is(element, 'bpmn:SubProcess')) {",
                    "    return addPlaneSuffix(id);",
                    "  }",
                    "",
                    "  return id;",
                    "}",
                    "",
                    "/**",
                    " * Get plane ID for primary shape ID.",
                    " *",
                    " * @param {string} id",
                    " *",
                    " * @return {string}",
                    " */",
                    "export function toPlaneId(id) {",
                    "  return addPlaneSuffix(id);",
                    "}",
                    "",
                    "/**",
                    " * Check wether element is plane.",
                    " *",
                    " * @param  {Element|ModdleElement} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isPlane(element) {",
                    "  var di = getDi(element);",
                    "",
                    "  return is(di, 'bpmndi:BPMNPlane');",
                    "}",
                    "",
                    "function addPlaneSuffix(id) {",
                    "  return id + planeSuffix;",
                    "}",
                    "",
                    "function removePlaneSuffix(id) {",
                    "  return id.replace(new RegExp(planeSuffix + '$'), '');",
                    "}"
                ]
            },
            "LabelUtil.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  assign",
                    "} from 'min-dash';",
                    "",
                    "import { is } from './ModelUtil';",
                    "",
                    "import { isLabel } from 'diagram-js/lib/util/ModelUtil';",
                    "",
                    "export { isLabel } from 'diagram-js/lib/util/ModelUtil';",
                    "",
                    "/**",
                    " * @typedef {import('diagram-js/lib/util/Types').Point} Point",
                    " * @typedef {import('diagram-js/lib/util/Types').Rect} Rect",
                    " *",
                    " * @typedef {import('../model/Types').Element} Element",
                    " * @typedef {import('../model/Types').ModdleElement} ModdleElement",
                    " */",
                    "",
                    "export var DEFAULT_LABEL_SIZE = {",
                    "  width: 90,",
                    "  height: 20",
                    "};",
                    "",
                    "export var FLOW_LABEL_INDENT = 15;",
                    "",
                    "",
                    "/**",
                    " * Return true if the given semantic has an external label.",
                    " *",
                    " * @param {Element} semantic",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isLabelExternal(semantic) {",
                    "  return is(semantic, 'bpmn:Event') ||",
                    "         is(semantic, 'bpmn:Gateway') ||",
                    "         is(semantic, 'bpmn:DataStoreReference') ||",
                    "         is(semantic, 'bpmn:DataObjectReference') ||",
                    "         is(semantic, 'bpmn:DataInput') ||",
                    "         is(semantic, 'bpmn:DataOutput') ||",
                    "         is(semantic, 'bpmn:SequenceFlow') ||",
                    "         is(semantic, 'bpmn:MessageFlow') ||",
                    "         is(semantic, 'bpmn:Group');",
                    "}",
                    "",
                    "/**",
                    " * Return true if the given element has an external label.",
                    " *",
                    " * @param {Element} element",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function hasExternalLabel(element) {",
                    "  return isLabel(element.label);",
                    "}",
                    "",
                    "/**",
                    " * Get the position of a sequence flow label.",
                    " *",
                    " * @param  {Point[]} waypoints",
                    " *",
                    " * @return {Point}",
                    " */",
                    "export function getFlowLabelPosition(waypoints) {",
                    "",
                    "  // get the waypoints mid",
                    "  var mid = waypoints.length / 2 - 1;",
                    "",
                    "  var first = waypoints[Math.floor(mid)];",
                    "  var second = waypoints[Math.ceil(mid + 0.01)];",
                    "",
                    "  // get position",
                    "  var position = getWaypointsMid(waypoints);",
                    "",
                    "  // calculate angle",
                    "  var angle = Math.atan((second.y - first.y) / (second.x - first.x));",
                    "",
                    "  var x = position.x,",
                    "      y = position.y;",
                    "",
                    "  if (Math.abs(angle) < Math.PI / 2) {",
                    "    y -= FLOW_LABEL_INDENT;",
                    "  } else {",
                    "    x += FLOW_LABEL_INDENT;",
                    "  }",
                    "",
                    "  return { x: x, y: y };",
                    "}",
                    "",
                    "",
                    "/**",
                    " * Get the middle of a number of waypoints.",
                    " *",
                    " * @param  {Point[]} waypoints",
                    " *",
                    " * @return {Point}",
                    " */",
                    "export function getWaypointsMid(waypoints) {",
                    "",
                    "  var mid = waypoints.length / 2 - 1;",
                    "",
                    "  var first = waypoints[Math.floor(mid)];",
                    "  var second = waypoints[Math.ceil(mid + 0.01)];",
                    "",
                    "  return {",
                    "    x: first.x + (second.x - first.x) / 2,",
                    "    y: first.y + (second.y - first.y) / 2",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * Get the middle of the external label of an element.",
                    " *",
                    " * @param {Element} element",
                    " *",
                    " * @return {Point}",
                    " */",
                    "export function getExternalLabelMid(element) {",
                    "",
                    "  if (element.waypoints) {",
                    "    return getFlowLabelPosition(element.waypoints);",
                    "  } else if (is(element, 'bpmn:Group')) {",
                    "    return {",
                    "      x: element.x + element.width / 2,",
                    "      y: element.y + DEFAULT_LABEL_SIZE.height / 2",
                    "    };",
                    "  } else {",
                    "    return {",
                    "      x: element.x + element.width / 2,",
                    "      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "",
                    "/**",
                    " * Return the bounds of an elements label, parsed from the elements DI or",
                    " * generated from its bounds.",
                    " *",
                    " * @param {ModdleElement} di",
                    " * @param {Element} element",
                    " *",
                    " * @return {Rect}",
                    " */",
                    "export function getExternalLabelBounds(di, element) {",
                    "",
                    "  var mid,",
                    "      size,",
                    "      bounds,",
                    "      label = di.label;",
                    "",
                    "  if (label && label.bounds) {",
                    "    bounds = label.bounds;",
                    "",
                    "    size = {",
                    "      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),",
                    "      height: bounds.height",
                    "    };",
                    "",
                    "    mid = {",
                    "      x: bounds.x + bounds.width / 2,",
                    "      y: bounds.y + bounds.height / 2",
                    "    };",
                    "  } else {",
                    "",
                    "    mid = getExternalLabelMid(element);",
                    "",
                    "    size = DEFAULT_LABEL_SIZE;",
                    "  }",
                    "",
                    "  return assign({",
                    "    x: mid.x - size.width / 2,",
                    "    y: mid.y - size.height / 2",
                    "  }, size);",
                    "}",
                    "",
                    "/**",
                    " * @param {ModdleElement} semantic",
                    " *",
                    " * @returns {string}",
                    " */",
                    "function getLabelAttr(semantic) {",
                    "  if (",
                    "    is(semantic, 'bpmn:FlowElement') ||",
                    "    is(semantic, 'bpmn:Participant') ||",
                    "    is(semantic, 'bpmn:Lane') ||",
                    "    is(semantic, 'bpmn:SequenceFlow') ||",
                    "    is(semantic, 'bpmn:MessageFlow') ||",
                    "    is(semantic, 'bpmn:DataInput') ||",
                    "    is(semantic, 'bpmn:DataOutput')",
                    "  ) {",
                    "    return 'name';",
                    "  }",
                    "",
                    "  if (is(semantic, 'bpmn:TextAnnotation')) {",
                    "    return 'text';",
                    "  }",
                    "",
                    "  if (is(semantic, 'bpmn:Group')) {",
                    "    return 'categoryValueRef';",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {ModdleElement} semantic",
                    " *",
                    " * @returns {string}",
                    " */",
                    "function getCategoryValue(semantic) {",
                    "  var categoryValueRef = semantic['categoryValueRef'];",
                    "",
                    "  if (!categoryValueRef) {",
                    "    return '';",
                    "  }",
                    "",
                    "",
                    "  return categoryValueRef.value || '';",
                    "}",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " *",
                    " * @return {string}",
                    " */",
                    "export function getLabel(element) {",
                    "  var semantic = element.businessObject,",
                    "      attr = getLabelAttr(semantic);",
                    "",
                    "  if (attr) {",
                    "",
                    "    if (attr === 'categoryValueRef') {",
                    "",
                    "      return getCategoryValue(semantic);",
                    "    }",
                    "",
                    "    return semantic[attr] || '';",
                    "  }",
                    "}",
                    "",
                    "",
                    "/**",
                    " * @param {Element} element",
                    " * @param {string} text",
                    " *",
                    " * @return {Element}",
                    " */",
                    "export function setLabel(element, text) {",
                    "  var semantic = element.businessObject,",
                    "      attr = getLabelAttr(semantic);",
                    "",
                    "  if (attr) {",
                    "",
                    "    if (attr === 'categoryValueRef') {",
                    "      semantic['categoryValueRef'].value = text;",
                    "    } else {",
                    "      semantic[attr] = text;",
                    "    }",
                    "",
                    "  }",
                    "",
                    "  return element;",
                    "}"
                ]
            },
            "ModelUtil.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  some",
                    "} from 'min-dash';",
                    "",
                    "/**",
                    " * @typedef { import('../model/Types').Element } Element",
                    " * @typedef { import('../model/Types').ModdleElement } ModdleElement",
                    " */",
                    "",
                    "/**",
                    " * Is an element of the given BPMN type?",
                    " *",
                    " * @param  {Element|ModdleElement} element",
                    " * @param  {string} type",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function is(element, type) {",
                    "  var bo = getBusinessObject(element);",
                    "",
                    "  return bo && (typeof bo.$instanceOf === 'function') && bo.$instanceOf(type);",
                    "}",
                    "",
                    "",
                    "/**",
                    " * Return true if element has any of the given types.",
                    " *",
                    " * @param {Element|ModdleElement} element",
                    " * @param {string[]} types",
                    " *",
                    " * @return {boolean}",
                    " */",
                    "export function isAny(element, types) {",
                    "  return some(types, function(t) {",
                    "    return is(element, t);",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * Return the business object for a given element.",
                    " *",
                    " * @param {Element|ModdleElement} element",
                    " *",
                    " * @return {ModdleElement}",
                    " */",
                    "export function getBusinessObject(element) {",
                    "  return (element && element.businessObject) || element;",
                    "}",
                    "",
                    "/**",
                    " * Return the di object for a given element.",
                    " *",
                    " * @param {Element} element",
                    " *",
                    " * @return {ModdleElement}",
                    " */",
                    "export function getDi(element) {",
                    "  return element && element.di;",
                    "}"
                ]
            },
            "PoweredByUtil.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * This file must not be changed or exchanged.",
                    " *",
                    " * @see http://bpmn.io/license for more information.",
                    " */",
                    "",
                    "import {",
                    "  assignStyle,",
                    "  domify,",
                    "  delegate as domDelegate,",
                    "  query as domQuery",
                    "} from 'min-dom';",
                    "",
                    "",
                    "// inlined ../../resources/logo.svg",
                    "var BPMNIO_LOGO_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 14.02 5.57\" width=\"53\" height=\"21\"><path fill=\"currentColor\" d=\"M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z\"/><path fill=\"currentColor\" d=\"M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z\"/></svg>';",
                    "",
                    "export var BPMNIO_IMG = BPMNIO_LOGO_SVG;",
                    "",
                    "export var LOGO_STYLES = {",
                    "  verticalAlign: 'middle'",
                    "};",
                    "",
                    "export var LINK_STYLES = {",
                    "  'color': '#404040'",
                    "};",
                    "",
                    "var LIGHTBOX_STYLES = {",
                    "  'zIndex': '1001',",
                    "  'position': 'fixed',",
                    "  'top': '0',",
                    "  'left': '0',",
                    "  'right': '0',",
                    "  'bottom': '0'",
                    "};",
                    "",
                    "var BACKDROP_STYLES = {",
                    "  'width': '100%',",
                    "  'height': '100%',",
                    "  'background': 'rgba(40,40,40,0.2)'",
                    "};",
                    "",
                    "var NOTICE_STYLES = {",
                    "  'position': 'absolute',",
                    "  'left': '50%',",
                    "  'top': '40%',",
                    "  'transform': 'translate(-50%)',",
                    "  'width': '260px',",
                    "  'padding': '10px',",
                    "  'background': 'white',",
                    "  'boxShadow': '0 1px 4px rgba(0,0,0,0.3)',",
                    "  'fontFamily': 'Helvetica, Arial, sans-serif',",
                    "  'fontSize': '14px',",
                    "  'display': 'flex',",
                    "  'lineHeight': '1.3'",
                    "};",
                    "",
                    "var LIGHTBOX_MARKUP =",
                    "  '<div class=\"bjs-powered-by-lightbox\">' +",
                    "    '<div class=\"backdrop\"></div>' +",
                    "    '<div class=\"notice\">' +",
                    "      '<a href=\"https://bpmn.io\" target=\"_blank\" rel=\"noopener\" class=\"link\">' +",
                    "        BPMNIO_IMG +",
                    "      '</a>' +",
                    "      '<span>' +",
                    "        'Web-based tooling for BPMN, DMN and forms ' +",
                    "        'powered by <a href=\"https://bpmn.io\" target=\"_blank\" rel=\"noopener\">bpmn.io</a>.' +",
                    "      '</span>' +",
                    "    '</div>' +",
                    "  '</div>';",
                    "",
                    "",
                    "var lightbox;",
                    "",
                    "function createLightbox() {",
                    "  lightbox = domify(LIGHTBOX_MARKUP);",
                    "",
                    "  assignStyle(lightbox, LIGHTBOX_STYLES);",
                    "  assignStyle(domQuery('svg', lightbox), LOGO_STYLES);",
                    "  assignStyle(domQuery('.backdrop', lightbox), BACKDROP_STYLES);",
                    "  assignStyle(domQuery('.notice', lightbox), NOTICE_STYLES);",
                    "  assignStyle(domQuery('.link', lightbox), LINK_STYLES, {",
                    "    'margin': '15px 20px 15px 10px',",
                    "    'alignSelf': 'center'",
                    "  });",
                    "}",
                    "",
                    "export function open() {",
                    "",
                    "  if (!lightbox) {",
                    "    createLightbox();",
                    "",
                    "    domDelegate.bind(lightbox, '.backdrop', 'click', function(event) {",
                    "      document.body.removeChild(lightbox);",
                    "    });",
                    "  }",
                    "",
                    "  document.body.appendChild(lightbox);",
                    "}"
                ]
            },
            "Types.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @typedef {Object} Colors",
                    " * @property {string} [fill]",
                    " * @property {string} [stroke]",
                    " */"
                ]
            },
            "Types.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "export type Colors = {",
                    "  fill?: string;",
                    "  stroke?: string;",
                    "};"
                ]
            }
        }
    },
    "resources": {
        "banner-min.txt": {},
        "banner.txt": {},
        "initial.bpmn": {},
        "logo.svg": {},
        "screencast.gif": {}
    },
    "tasks": {
        ".eslintrc": {},
        "build-distro.mjs": {},
        "test-distro.mjs": {},
        "stages": {
            "await-published": {},
            "update-demo": {},
            "update-examples": {},
            "update-integration-test": {},
            "update-translations": {},
            "update-website": {}
        }
    }
}