{
    "lib/features/drilldown/DrilldownOverlayBehavior.js": [
        "import inherits from 'inherits';",
        "",
        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
        "import { is } from '../../util/ModelUtil';",
        "import { classes, domify } from 'min-dom';",
        "import { getPlaneIdFromShape } from '../../util/DrilldownUtil';",
        "",
        "var LOW_PRIORITY = 250;",
        "var ARROW_DOWN_SVG = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z\"/></svg>';",
        "",
        "var EMPTY_MARKER = 'bjs-drilldown-empty';",
        "",
        "export default function DrilldownOverlayBehavior(",
        "    canvas, eventBus, elementRegistry, overlays",
        ") {",
        "  CommandInterceptor.call(this, eventBus);",
        "",
        "  this._canvas = canvas;",
        "  this._eventBus = eventBus;",
        "  this._elementRegistry = elementRegistry;",
        "  this._overlays = overlays;",
        "",
        "  var self = this;",
        "",
        "  this.executed('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
        "    var shape = context.shape;",
        "",
        "    // Add overlay to the collapsed shape",
        "    if (self.canDrillDown(shape)) {",
        "      self.addOverlay(shape);",
        "    } else {",
        "      self.removeOverlay(shape);",
        "    }",
        "  }, true);",
        "",
        "",
        "  this.reverted('shape.toggleCollapse', LOW_PRIORITY, function(context) {",
        "    var shape = context.shape;",
        "",
        "    // Add overlay to the collapsed shape",
        "    if (self.canDrillDown(shape)) {",
        "      self.addOverlay(shape);",
        "    } else {",
        "      self.removeOverlay(shape);",
        "    }",
        "  }, true);",
        "",
        "",
        "  this.executed(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,",
        "    function(context) {",
        "      var oldParent = context.oldParent,",
        "          newParent = context.newParent || context.parent,",
        "          shape = context.shape;",
        "",
        "      // Add overlay to the collapsed shape",
        "      if (self.canDrillDown(shape)) {",
        "        self.addOverlay(shape);",
        "      }",
        "",
        "      self.updateDrilldownOverlay(oldParent);",
        "      self.updateDrilldownOverlay(newParent);",
        "      self.updateDrilldownOverlay(shape);",
        "    }, true);",
        "",
        "",
        "  this.reverted(['shape.create', 'shape.move', 'shape.delete'], LOW_PRIORITY,",
        "    function(context) {",
        "      var oldParent = context.oldParent,",
        "          newParent = context.newParent || context.parent,",
        "          shape = context.shape;",
        "",
        "      // Add overlay to the collapsed shape",
        "      if (self.canDrillDown(shape)) {",
        "        self.addOverlay(shape);",
        "      }",
        "",
        "      self.updateDrilldownOverlay(oldParent);",
        "      self.updateDrilldownOverlay(newParent);",
        "      self.updateDrilldownOverlay(shape);",
        "    }, true);",
        "",
        "",
        "  eventBus.on('import.done', function() {",
        "    elementRegistry.filter(function(e) {",
        "      return self.canDrillDown(e);",
        "    }).map(function(el) {",
        "      self.addOverlay(el);",
        "    });",
        "  });",
        "",
        "}",
        "",
        "inherits(DrilldownOverlayBehavior, CommandInterceptor);",
        "",
        "DrilldownOverlayBehavior.prototype.updateDrilldownOverlay = function(shape) {",
        "  var canvas = this._canvas;",
        "",
        "  if (!shape) {",
        "    return;",
        "  }",
        "",
        "  var root = canvas.findRoot(shape);",
        "  if (root) {",
        "    this.updateOverlayVisibility(root);",
        "  }",
        "};",
        "",
        "",
        "DrilldownOverlayBehavior.prototype.canDrillDown = function(element) {",
        "  var canvas = this._canvas;",
        "  return is(element, 'bpmn:SubProcess') && canvas.findRoot(getPlaneIdFromShape(element));",
        "};",
        "",
        "/**",
        " * Updates visibility of the drilldown overlay. If the plane has no elements,",
        " * the drilldown will be only shown when the element is selected.",
        " *",
        " * @param {djs.model.Shape|djs.model.Root} element collapsed shape or root element",
        " */",
        "DrilldownOverlayBehavior.prototype.updateOverlayVisibility = function(element) {",
        "  var overlays = this._overlays;",
        "",
        "  var bo = element.businessObject;",
        "",
        "  var overlay = overlays.get({ element: bo.id, type: 'drilldown' })[0];",
        "",
        "  if (!overlay) {",
        "    return;",
        "  }",
        "",
        "  var hasContent = bo && bo.flowElements && bo.flowElements.length;",
        "  classes(overlay.html).toggle(EMPTY_MARKER, !hasContent);",
        "};",
        "",
        "/**",
        " * Attaches a drilldown button to the given element. We assume that the plane has",
        " * the same id as the element.",
        " *",
        " * @param {djs.model.Shape} element collapsed shape",
        " */",
        "DrilldownOverlayBehavior.prototype.addOverlay = function(element) {",
        "  var canvas = this._canvas;",
        "  var overlays = this._overlays;",
        "",
        "  var existingOverlays = overlays.get({ element: element, type: 'drilldown' });",
        "  if (existingOverlays.length) {",
        "    this.removeOverlay(element);",
        "  }",
        "",
        "  var button = domify('<button class=\"bjs-drilldown\">' + ARROW_DOWN_SVG + '</button>');",
        "",
        "  button.addEventListener('click', function() {",
        "    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));",
        "  });",
        "",
        "  overlays.add(element, 'drilldown', {",
        "    position: {",
        "      bottom: -7,",
        "      right: -8",
        "    },",
        "    html: button",
        "  });",
        "",
        "  this.updateOverlayVisibility(element);",
        "};",
        "",
        "DrilldownOverlayBehavior.prototype.removeOverlay = function(element) {",
        "  var overlays = this._overlays;",
        "",
        "  overlays.remove({",
        "    element: element,",
        "    type: 'drilldown'",
        "  });",
        "};",
        "",
        "DrilldownOverlayBehavior.$inject = [",
        "  'canvas',",
        "  'eventBus',",
        "  'elementRegistry',",
        "  'overlays'",
        "];"
    ],
    "lib/features/drilldown/SubprocessCompatibility.js": [
        "",
        "import { asBounds, asTRBL } from 'diagram-js/lib/layout/LayoutUtil';",
        "import { is, isAny } from '../../util/ModelUtil';",
        "",
        "var DEFAULT_POSITION = {",
        "  x: 180,",
        "  y: 160",
        "};",
        "",
        "/**",
        " * Hook into `import.render.start` and create new planes for diagrams with",
        " * collapsed subprocesses and all dis on the same plane.",
        " *",
        " * @param {eventBus} eventBus",
        " * @param {moddle} moddle",
        " */",
        "export default function SubprocessCompatibility(eventBus, moddle) {",
        "  this._eventBus = eventBus;",
        "  this._moddle = moddle;",
        "",
        "  var self = this;",
        "",
        "  eventBus.on('import.render.start', 1500, function(e, context) {",
        "    self.handleImport(context.definitions);",
        "  });",
        "}",
        "",
        "SubprocessCompatibility.prototype.handleImport = function(definitions) {",
        "  if (!definitions.diagrams) {",
        "    return;",
        "  }",
        "",
        "  var self = this;",
        "  this._definitions = definitions;",
        "  this._processToDiagramMap = {};",
        "",
        "  definitions.diagrams.forEach(function(diagram) {",
        "    if (!diagram.plane || !diagram.plane.bpmnElement) {",
        "      return;",
        "    }",
        "",
        "    self._processToDiagramMap[diagram.plane.bpmnElement.id] = diagram;",
        "  });",
        "",
        "  var newDiagrams = [];",
        "  definitions.diagrams.forEach(function(diagram) {",
        "    var createdDiagrams = self.createNewDiagrams(diagram.plane);",
        "    Array.prototype.push.apply(newDiagrams, createdDiagrams);",
        "  });",
        "",
        "  newDiagrams.forEach(function(diagram) {",
        "    self.movePlaneElementsToOrigin(diagram.plane);",
        "  });",
        "};",
        "",
        "",
        "/**",
        " * Moves all DI elements from collapsed subprocesses to a new plane.",
        " *",
        " * @param {Object} plane",
        " * @return {Array} new diagrams created for the collapsed subprocesses",
        " */",
        "SubprocessCompatibility.prototype.createNewDiagrams = function(plane) {",
        "  var self = this;",
        "",
        "  var collapsedElements = [];",
        "  var elementsToMove = [];",
        "",
        "  plane.get('planeElement').forEach(function(diElement) {",
        "    var bo = diElement.bpmnElement;",
        "",
        "    if (!bo) {",
        "      return;",
        "    }",
        "",
        "    var parent = bo.$parent;",
        "",
        "    if (is(bo, 'bpmn:SubProcess') && !diElement.isExpanded) {",
        "      collapsedElements.push(bo);",
        "    }",
        "",
        "    if (shouldMoveToPlane(bo, plane)) {",
        "",
        "      // don't change the array while we iterate over it",
        "      elementsToMove.push({ diElement: diElement, parent: parent });",
        "    }",
        "  });",
        "",
        "  var newDiagrams = [];",
        "",
        "  // create new planes for all collapsed subprocesses, even when they are empty",
        "  collapsedElements.forEach(function(element) {",
        "    if (!self._processToDiagramMap[element.id]) {",
        "      var diagram = self.createDiagram(element);",
        "      self._processToDiagramMap[element.id] = diagram;",
        "      newDiagrams.push(diagram);",
        "    }",
        "  });",
        "",
        "  elementsToMove.forEach(function(element) {",
        "    var diElement = element.diElement;",
        "    var parent = element.parent;",
        "",
        "    // parent is expanded, get nearest collapsed parent",
        "    while (parent && collapsedElements.indexOf(parent) === -1) {",
        "      parent = parent.$parent;",
        "    }",
        "",
        "    // false positive, all parents are expanded",
        "    if (!parent) {",
        "      return;",
        "    }",
        "",
        "    var diagram = self._processToDiagramMap[parent.id];",
        "    self.moveToDiPlane(diElement, diagram.plane);",
        "  });",
        "",
        "  return newDiagrams;",
        "};",
        "",
        "SubprocessCompatibility.prototype.movePlaneElementsToOrigin = function(plane) {",
        "  var elements = plane.get('planeElement');",
        "",
        "  // get bounding box of all elements",
        "  var planeBounds = getPlaneBounds(plane);",
        "",
        "  var offset = {",
        "    x: planeBounds.x - DEFAULT_POSITION.x,",
        "    y: planeBounds.y - DEFAULT_POSITION.y",
        "  };",
        "",
        "  elements.forEach(function(diElement) {",
        "    if (diElement.waypoint) {",
        "      diElement.waypoint.forEach(function(waypoint) {",
        "        waypoint.x = waypoint.x - offset.x;",
        "        waypoint.y = waypoint.y - offset.y;",
        "      });",
        "    } else if (diElement.bounds) {",
        "      diElement.bounds.x = diElement.bounds.x - offset.x;",
        "      diElement.bounds.y = diElement.bounds.y - offset.y;",
        "    }",
        "  });",
        "};",
        "",
        "",
        "SubprocessCompatibility.prototype.moveToDiPlane = function(diElement, newPlane) {",
        "  var containingDiagram = findRootDiagram(diElement);",
        "",
        "  // remove DI from old Plane and add it to the new one",
        "  var parentPlaneElement = containingDiagram.plane.get('planeElement');",
        "  parentPlaneElement.splice(parentPlaneElement.indexOf(diElement), 1);",
        "  newPlane.get('planeElement').push(diElement);",
        "};",
        "",
        "",
        "SubprocessCompatibility.prototype.createDiagram = function(bo) {",
        "  var plane = this._moddle.create('bpmndi:BPMNPlane', { bpmnElement: bo });",
        "  var diagram = this._moddle.create('bpmndi:BPMNDiagram', {",
        "    plane: plane",
        "  });",
        "  plane.$parent = diagram;",
        "  plane.bpmnElement = bo;",
        "  diagram.$parent = this._definitions;",
        "  this._definitions.diagrams.push(diagram);",
        "  return diagram;",
        "};",
        "",
        "SubprocessCompatibility.$inject = [ 'eventBus', 'moddle' ];",
        "",
        "",
        "// helpers //////////////////////////",
        "",
        "function findRootDiagram(element) {",
        "  if (is(element, 'bpmndi:BPMNDiagram')) {",
        "    return element;",
        "  } else {",
        "    return findRootDiagram(element.$parent);",
        "  }",
        "}",
        "",
        "function getPlaneBounds(plane) {",
        "  var planeTrbl = {",
        "    top: Infinity,",
        "    right: -Infinity,",
        "    bottom: -Infinity,",
        "    left: Infinity",
        "  };",
        "",
        "  plane.planeElement.forEach(function(element) {",
        "    if (!element.bounds) {",
        "      return;",
        "    }",
        "",
        "    var trbl = asTRBL(element.bounds);",
        "",
        "    planeTrbl.top = Math.min(trbl.top, planeTrbl.top);",
        "    planeTrbl.left = Math.min(trbl.left, planeTrbl.left);",
        "  });",
        "",
        "  return asBounds(planeTrbl);",
        "}",
        "",
        "function shouldMoveToPlane(bo, plane) {",
        "  var parent = bo.$parent;",
        "",
        "  // don't move elements that are already on the plane",
        "  if (!is(parent, 'bpmn:SubProcess') || parent === plane.bpmnElement) {",
        "    return false;",
        "  }",
        "",
        "  // dataAssociations are children of the subprocess but rendered on process level",
        "  // cf. https://github.com/bpmn-io/bpmn-js/issues/1619",
        "  if (isAny(bo, ['bpmn:DataInputAssociation', 'bpmn:DataOutputAssociation'])) {",
        "    return false;",
        "  }",
        "",
        "  return true;",
        "}"
    ],
    "lib/util/DrilldownUtil.js": [
        "import { getDi, is } from './ModelUtil';",
        "",
        "",
        "export var planeSuffix = '_plane';",
        "",
        "/**",
        " * Get primary shape ID for a plane.",
        " *",
        " * @param  {djs.model.Base|ModdleElement} element",
        " *",
        " * @returns {String}",
        " */",
        "export function getShapeIdFromPlane(element) {",
        "  var id = element.id;",
        "",
        "  return removePlaneSuffix(id);",
        "}",
        "",
        "/**",
        " * Get plane ID for a primary shape.",
        " *",
        " * @param  {djs.model.Base|ModdleElement} element",
        " *",
        " * @returns {String}",
        " */",
        "export function getPlaneIdFromShape(element) {",
        "  var id = element.id;",
        "",
        "  if (is(element, 'bpmn:SubProcess')) {",
        "    return addPlaneSuffix(id);",
        "  }",
        "",
        "  return id;",
        "}",
        "",
        "/**",
        " * Get plane ID for primary shape ID.",
        " *",
        " * @param {String} id",
        " *",
        " * @returns {String}",
        " */",
        "export function toPlaneId(id) {",
        "  return addPlaneSuffix(id);",
        "}",
        "",
        "/**",
        " * Check wether element is plane.",
        " *",
        " * @param  {djs.model.Base|ModdleElement} element",
        " *",
        " * @returns {Boolean}",
        " */",
        "export function isPlane(element) {",
        "  var di = getDi(element);",
        "",
        "  return is(di, 'bpmndi:BPMNPlane');",
        "}",
        "",
        "function addPlaneSuffix(id) {",
        "  return id + planeSuffix;",
        "}",
        "",
        "function removePlaneSuffix(id) {",
        "  return id.replace(new RegExp(planeSuffix + '$'), '');",
        "}"
    ]
}