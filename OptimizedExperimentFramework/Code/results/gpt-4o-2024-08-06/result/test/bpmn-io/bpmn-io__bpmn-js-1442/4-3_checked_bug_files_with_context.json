{
    "lib/features/modeling/behavior/DropOnFlowBehavior.js": [
        "import inherits from 'inherits';",
        "",
        "import {",
        "  assign,",
        "  filter,",
        "  find,",
        "  isNumber",
        "} from 'min-dash';",
        "",
        "import { getMid } from 'diagram-js/lib/layout/LayoutUtil';",
        "",
        "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
        "",
        "import {",
        "  getApproxIntersection",
        "} from 'diagram-js/lib/util/LineIntersection';",
        "",
        "",
        "export default function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {",
        "",
        "  CommandInterceptor.call(this, eventBus);",
        "",
        "  /**",
        "   * Reconnect start / end of a connection after",
        "   * dropping an element on a flow.",
        "   */",
        "",
        "  function insertShape(shape, targetFlow, positionOrBounds) {",
        "    var waypoints = targetFlow.waypoints,",
        "        waypointsBefore,",
        "        waypointsAfter,",
        "        dockingPoint,",
        "        source,",
        "        target,",
        "        incomingConnection,",
        "        outgoingConnection,",
        "        oldOutgoing = shape.outgoing.slice(),",
        "        oldIncoming = shape.incoming.slice();",
        "",
        "    var mid;",
        "",
        "    if (isNumber(positionOrBounds.width)) {",
        "      mid = getMid(positionOrBounds);",
        "    } else {",
        "      mid = positionOrBounds;",
        "    }",
        "",
        "    var intersection = getApproxIntersection(waypoints, mid);",
        "",
        "    if (intersection) {",
        "      waypointsBefore = waypoints.slice(0, intersection.index);",
        "      waypointsAfter = waypoints.slice(intersection.index + (intersection.bendpoint ? 1 : 0));",
        "",
        "      // due to inaccuracy intersection might have been found",
        "      if (!waypointsBefore.length || !waypointsAfter.length) {",
        "        return;",
        "      }",
        "",
        "      dockingPoint = intersection.bendpoint ? waypoints[intersection.index] : mid;",
        "",
        "      // if last waypointBefore is inside shape's bounds, ignore docking point",
        "      if (!isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length-1])) {",
        "        waypointsBefore.push(copy(dockingPoint));",
        "      }",
        "",
        "      // if first waypointAfter is inside shape's bounds, ignore docking point",
        "      if (!isPointInsideBBox(shape, waypointsAfter[0])) {",
        "        waypointsAfter.unshift(copy(dockingPoint));",
        "      }",
        "    }",
        "",
        "    source = targetFlow.source;",
        "    target = targetFlow.target;",
        "",
        "    if (bpmnRules.canConnect(source, shape, targetFlow)) {",
        "",
        "      // reconnect source -> inserted shape",
        "      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid);",
        "",
        "      incomingConnection = targetFlow;",
        "    }",
        "",
        "    if (bpmnRules.canConnect(shape, target, targetFlow)) {",
        "",
        "      if (!incomingConnection) {",
        "",
        "        // reconnect inserted shape -> end",
        "        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid);",
        "",
        "        outgoingConnection = targetFlow;",
        "      } else {",
        "        outgoingConnection = modeling.connect(",
        "          shape, target, { type: targetFlow.type, waypoints: waypointsAfter }",
        "        );",
        "      }",
        "    }",
        "",
        "    var duplicateConnections = [].concat(",
        "",
        "      incomingConnection && filter(oldIncoming, function(connection) {",
        "        return connection.source === incomingConnection.source;",
        "      }) || [],",
        "",
        "      outgoingConnection && filter(oldOutgoing, function(connection) {",
        "        return connection.target === outgoingConnection.target;",
        "      }) || []",
        "    );",
        "",
        "    if (duplicateConnections.length) {",
        "      modeling.removeElements(duplicateConnections);",
        "    }",
        "  }",
        "",
        "  this.preExecute('elements.move', function(context) {",
        "",
        "    var newParent = context.newParent,",
        "        shapes = context.shapes,",
        "        delta = context.delta,",
        "        shape = shapes[0];",
        "",
        "    if (!shape || !newParent) {",
        "      return;",
        "    }",
        "",
        "    // if the new parent is a connection,",
        "    // change it to the new parent's parent",
        "    if (newParent && newParent.waypoints) {",
        "      context.newParent = newParent = newParent.parent;",
        "    }",
        "",
        "    var shapeMid = getMid(shape);",
        "    var newShapeMid = {",
        "      x: shapeMid.x + delta.x,",
        "      y: shapeMid.y + delta.y",
        "    };",
        "",
        "    // find a connection which intersects with the",
        "    // element's mid point",
        "    var connection = find(newParent.children, function(element) {",
        "      var canInsert = bpmnRules.canInsert(shapes, element);",
        "",
        "      return canInsert && getApproxIntersection(element.waypoints, newShapeMid);",
        "    });",
        "",
        "    if (connection) {",
        "      context.targetFlow = connection;",
        "      context.position = newShapeMid;",
        "    }",
        "",
        "  }, true);",
        "",
        "  this.postExecuted('elements.move', function(context) {",
        "",
        "    var shapes = context.shapes,",
        "        targetFlow = context.targetFlow,",
        "        position = context.position;",
        "",
        "    if (targetFlow) {",
        "      insertShape(shapes[0], targetFlow, position);",
        "    }",
        "",
        "  }, true);",
        "",
        "  this.preExecute('shape.create', function(context) {",
        "",
        "    var parent = context.parent,",
        "        shape = context.shape;",
        "",
        "    if (bpmnRules.canInsert(shape, parent)) {",
        "      context.targetFlow = parent;",
        "      context.parent = parent.parent;",
        "    }",
        "  }, true);",
        "",
        "  this.postExecuted('shape.create', function(context) {",
        "",
        "    var shape = context.shape,",
        "        targetFlow = context.targetFlow,",
        "        positionOrBounds = context.position;",
        "",
        "    if (targetFlow) {",
        "      insertShape(shape, targetFlow, positionOrBounds);",
        "    }",
        "  }, true);",
        "}",
        "",
        "inherits(DropOnFlowBehavior, CommandInterceptor);",
        "",
        "DropOnFlowBehavior.$inject = [",
        "  'eventBus',",
        "  'bpmnRules',",
        "  'modeling'",
        "];",
        "",
        "",
        "// helpers /////////////////////",
        "",
        "function isPointInsideBBox(bbox, point) {",
        "  var x = point.x,",
        "      y = point.y;",
        "",
        "  return x >= bbox.x &&",
        "    x <= bbox.x + bbox.width &&",
        "    y >= bbox.y &&",
        "    y <= bbox.y + bbox.height;",
        "}",
        "",
        "function copy(obj) {",
        "  return assign({}, obj);",
        "}",
        ""
    ],
    "lib/features/copy-paste/BpmnCopyPaste.js": [
        "import {",
        "  getBusinessObject,",
        "  is",
        "} from '../../util/ModelUtil';",
        "",
        "import {",
        "  forEach,",
        "  isArray,",
        "  isUndefined,",
        "  omit,",
        "  reduce",
        "} from 'min-dash';",
        "",
        "function copyProperties(source, target, properties) {",
        "  if (!isArray(properties)) {",
        "    properties = [ properties ];",
        "  }",
        "",
        "  forEach(properties, function(property) {",
        "    if (!isUndefined(source[property])) {",
        "      target[property] = source[property];",
        "    }",
        "  });",
        "}",
        "",
        "function removeProperties(element, properties) {",
        "  if (!isArray(properties)) {",
        "    properties = [ properties ];",
        "  }",
        "",
        "  forEach(properties, function(property) {",
        "    if (element[property]) {",
        "      delete element[property];",
        "    }",
        "  });",
        "}",
        "",
        "var LOW_PRIORITY = 750;",
        "",
        "",
        "export default function BpmnCopyPaste(bpmnFactory, eventBus, moddleCopy) {",
        "",
        "  eventBus.on('copyPaste.copyElement', LOW_PRIORITY, function(context) {",
        "    var descriptor = context.descriptor,",
        "        element = context.element;",
        "",
        "    var businessObject = descriptor.oldBusinessObject = getBusinessObject(element);",
        "",
        "    descriptor.type = element.type;",
        "",
        "    copyProperties(businessObject, descriptor, 'name');",
        "",
        "    descriptor.di = {};",
        "",
        "    // fill and stroke will be set to DI",
        "    copyProperties(businessObject.di, descriptor.di, [",
        "      'fill',",
        "      'stroke'",
        "    ]);",
        "",
        "    copyProperties(businessObject.di, descriptor, 'isExpanded');",
        "",
        "    if (isLabel(descriptor)) {",
        "      return descriptor;",
        "    }",
        "",
        "    // default sequence flow",
        "    if (businessObject.default) {",
        "      descriptor.default = businessObject.default.id;",
        "    }",
        "  });",
        "",
        "  eventBus.on('moddleCopy.canCopyProperty', function(context) {",
        "    var parent = context.parent,",
        "        property = context.property,",
        "        propertyName = context.propertyName,",
        "        bpmnProcess;",
        "",
        "    if (",
        "      propertyName === 'processRef' &&",
        "      is(parent, 'bpmn:Participant') &&",
        "      is(property, 'bpmn:Process')",
        "    ) {",
        "      bpmnProcess = bpmnFactory.create('bpmn:Process');",
        "",
        "      // return copy of process",
        "      return moddleCopy.copyElement(property, bpmnProcess);",
        "    }",
        "  });",
        "",
        "  var references;",
        "",
        "  function resolveReferences(descriptor, cache) {",
        "    var businessObject = getBusinessObject(descriptor);",
        "",
        "    // default sequence flows",
        "    if (descriptor.default) {",
        "",
        "      // relationship cannot be resolved immediately",
        "      references[ descriptor.default ] = {",
        "        element: businessObject,",
        "        property: 'default'",
        "      };",
        "    }",
        "",
        "    // boundary events",
        "    if (descriptor.host) {",
        "",
        "      // relationship can be resolved immediately",
        "      getBusinessObject(descriptor).attachedToRef = getBusinessObject(cache[ descriptor.host ]);",
        "    }",
        "",
        "    references = omit(references, reduce(references, function(array, reference, key) {",
        "      var element = reference.element,",
        "          property = reference.property;",
        "",
        "      if (key === descriptor.id) {",
        "        element[ property ] = businessObject;",
        "",
        "        array.push(descriptor.id);",
        "      }",
        "",
        "      return array;",
        "    }, []));",
        "  }",
        "",
        "  eventBus.on('copyPaste.pasteElements', function() {",
        "    references = {};",
        "  });",
        "",
        "  eventBus.on('copyPaste.pasteElement', function(context) {",
        "    var cache = context.cache,",
        "        descriptor = context.descriptor,",
        "        oldBusinessObject = descriptor.oldBusinessObject,",
        "        newBusinessObject;",
        "",
        "    // do NOT copy business object if external label",
        "    if (isLabel(descriptor)) {",
        "      descriptor.businessObject = getBusinessObject(cache[ descriptor.labelTarget ]);",
        "",
        "      return;",
        "    }",
        "",
        "    newBusinessObject = bpmnFactory.create(oldBusinessObject.$type);",
        "",
        "    descriptor.businessObject = moddleCopy.copyElement(",
        "      oldBusinessObject,",
        "      newBusinessObject",
        "    );",
        "",
        "    // resolve references e.g. default sequence flow",
        "    resolveReferences(descriptor, cache);",
        "",
        "    copyProperties(descriptor, newBusinessObject, [",
        "      'isExpanded',",
        "      'name'",
        "    ]);",
        "",
        "    removeProperties(descriptor, 'oldBusinessObject');",
        "  });",
        "",
        "}",
        "",
        "",
        "BpmnCopyPaste.$inject = [",
        "  'bpmnFactory',",
        "  'eventBus',",
        "  'moddleCopy'",
        "];",
        "",
        "// helpers //////////",
        "",
        "function isLabel(element) {",
        "  return !!element.labelTarget;",
        "}"
    ]
}