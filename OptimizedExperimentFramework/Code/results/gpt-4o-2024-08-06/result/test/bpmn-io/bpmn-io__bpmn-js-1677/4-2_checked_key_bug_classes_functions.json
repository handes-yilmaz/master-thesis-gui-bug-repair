{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) ",
            "file_path": "lib/features/label-editing/LabelEditingProvider.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 446
                }
            ],
            "class_code": [
                "import {",
                "  assign",
                "} from 'min-dash';",
                "",
                "import {",
                "  getLabel",
                "} from './LabelUtil';",
                "",
                "import {",
                "  getBusinessObject,",
                "  is",
                "} from '../../util/ModelUtil';",
                "",
                "import {",
                "  createCategoryValue",
                "} from '../modeling/behavior/util/CategoryUtil';",
                "",
                "import { isAny } from '../modeling/util/ModelingUtil';",
                "import { isExpanded } from '../../util/DiUtil';",
                "",
                "import {",
                "  getExternalLabelMid,",
                "  isLabelExternal,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../util/LabelUtil';",
                "",
                "",
                "export default function LabelEditingProvider(",
                "    eventBus, bpmnFactory, canvas, directEditing,",
                "    modeling, resizeHandles, textRenderer) {",
                "",
                "  this._bpmnFactory = bpmnFactory;",
                "  this._canvas = canvas;",
                "  this._modeling = modeling;",
                "  this._textRenderer = textRenderer;",
                "",
                "  directEditing.registerProvider(this);",
                "",
                "  // listen to dblclick on non-root elements",
                "  eventBus.on('element.dblclick', function(event) {",
                "    activateDirectEdit(event.element, true);",
                "  });",
                "",
                "  // complete on followup canvas operation",
                "  eventBus.on([",
                "    'autoPlace.start',",
                "    'canvas.viewbox.changing',",
                "    'drag.init',",
                "    'element.mousedown',",
                "    'popupMenu.open',",
                "    'root.set',",
                "    'selection.changed'",
                "  ], function(event) {",
                "",
                "    if (directEditing.isActive()) {",
                "      directEditing.complete();",
                "    }",
                "  });",
                "",
                "  eventBus.on([",
                "    'shape.remove',",
                "    'connection.remove'",
                "  ], function(event) {",
                "",
                "    if (directEditing.isActive(event.element)) {",
                "      directEditing.cancel();",
                "    }",
                "  });",
                "",
                "  // cancel on command stack changes",
                "  eventBus.on([ 'commandStack.changed' ], function(e) {",
                "    if (directEditing.isActive()) {",
                "      directEditing.cancel();",
                "    }",
                "  });",
                "",
                "",
                "  eventBus.on('directEditing.activate', function(event) {",
                "    resizeHandles.removeResizers();",
                "  });",
                "",
                "  eventBus.on('create.end', 500, function(event) {",
                "",
                "    var context = event.context,",
                "        element = context.shape,",
                "        canExecute = event.context.canExecute,",
                "        isTouch = event.isTouch;",
                "",
                "    // TODO(nikku): we need to find a way to support the",
                "    // direct editing on mobile devices; right now this will",
                "    // break for desworkflowediting on mobile devices",
                "    // as it breaks the user interaction workflow",
                "",
                "    // TODO(nre): we should temporarily focus the edited element",
                "    // here and release the focused viewport after the direct edit",
                "    // operation is finished",
                "    if (isTouch) {",
                "      return;",
                "    }",
                "",
                "    if (!canExecute) {",
                "      return;",
                "    }",
                "",
                "    if (context.hints && context.hints.createElementsBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    activateDirectEdit(element);",
                "  });",
                "",
                "  eventBus.on('autoPlace.end', 500, function(event) {",
                "    activateDirectEdit(event.shape);",
                "  });",
                "",
                "",
                "  function activateDirectEdit(element, force) {",
                "    if (force ||",
                "        isAny(element, [ 'bpmn:Task', 'bpmn:TextAnnotation' ]) ||",
                "        isCollapsedSubProcess(element)) {",
                "",
                "      directEditing.activate(element);",
                "    }",
                "  }",
                "",
                "}",
                "",
                "LabelEditingProvider.$inject = [",
                "  'eventBus',",
                "  'bpmnFactory',",
                "  'canvas',",
                "  'directEditing',",
                "  'modeling',",
                "  'resizeHandles',",
                "  'textRenderer'",
                "];",
                "",
                "",
                "/**",
                " * Activate direct editing for activities and text annotations.",
                " *",
                " * @param  {djs.model.Base} element",
                " *",
                " * @return {Object} an object with properties bounds (position and size), text and options",
                " */",
                "LabelEditingProvider.prototype.activate = function(element) {",
                "",
                "  // text",
                "  var text = getLabel(element);",
                "",
                "  if (text === undefined) {",
                "    return;",
                "  }",
                "",
                "  var context = {",
                "    text: text",
                "  };",
                "",
                "  // bounds",
                "  var bounds = this.getEditingBBox(element);",
                "",
                "  assign(context, bounds);",
                "",
                "  var options = {};",
                "",
                "  // tasks",
                "  if (",
                "    isAny(element, [",
                "      'bpmn:Task',",
                "      'bpmn:Participant',",
                "      'bpmn:Lane',",
                "      'bpmn:CallActivity'",
                "    ]) ||",
                "    isCollapsedSubProcess(element)",
                "  ) {",
                "    assign(options, {",
                "      centerVertically: true",
                "    });",
                "  }",
                "",
                "  // external labels",
                "  if (isLabelExternal(element)) {",
                "    assign(options, {",
                "      autoResize: true",
                "    });",
                "  }",
                "",
                "  // text annotations",
                "  if (is(element, 'bpmn:TextAnnotation')) {",
                "    assign(options, {",
                "      resizable: true,",
                "      autoResize: true",
                "    });",
                "  }",
                "",
                "  assign(context, {",
                "    options: options",
                "  });",
                "",
                "  return context;",
                "};",
                "",
                "",
                "/**",
                " * Get the editing bounding box based on the element's size and position",
                " *",
                " * @param  {djs.model.Base} element",
                " *",
                " * @return {Object} an object containing information about position",
                " *                  and size (fixed or minimum and/or maximum)",
                " */",
                "LabelEditingProvider.prototype.getEditingBBox = function(element) {",
                "  var canvas = this._canvas;",
                "",
                "  var target = element.label || element;",
                "",
                "  var bbox = canvas.getAbsoluteBBox(target);",
                "",
                "  var mid = {",
                "    x: bbox.x + bbox.width / 2,",
                "    y: bbox.y + bbox.height / 2",
                "  };",
                "",
                "  // default position",
                "  var bounds = { x: bbox.x, y: bbox.y };",
                "",
                "  var zoom = canvas.zoom();",
                "",
                "  var defaultStyle = this._textRenderer.getDefaultStyle(),",
                "      externalStyle = this._textRenderer.getExternalStyle();",
                "",
                "  // take zoom into account",
                "  var externalFontSize = externalStyle.fontSize * zoom,",
                "      externalLineHeight = externalStyle.lineHeight,",
                "      defaultFontSize = defaultStyle.fontSize * zoom,",
                "      defaultLineHeight = defaultStyle.lineHeight;",
                "",
                "  var style = {",
                "    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,",
                "    fontWeight: this._textRenderer.getDefaultStyle().fontWeight",
                "  };",
                "",
                "  // adjust for expanded pools AND lanes",
                "  if (is(element, 'bpmn:Lane') || isExpandedPool(element)) {",
                "",
                "    assign(bounds, {",
                "      width: bbox.height,",
                "      height: 30 * zoom,",
                "      x: bbox.x - bbox.height / 2 + (15 * zoom),",
                "      y: mid.y - (30 * zoom) / 2",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: defaultFontSize + 'px',",
                "      lineHeight: defaultLineHeight,",
                "      paddingTop: (7 * zoom) + 'px',",
                "      paddingBottom: (7 * zoom) + 'px',",
                "      paddingLeft: (5 * zoom) + 'px',",
                "      paddingRight: (5 * zoom) + 'px',",
                "      transform: 'rotate(-90deg)'",
                "    });",
                "  }",
                "",
                "",
                "  // internal labels for tasks and collapsed call activities,",
                "  // sub processes and participants",
                "  if (isAny(element, [ 'bpmn:Task', 'bpmn:CallActivity']) ||",
                "      isCollapsedPool(element) ||",
                "      isCollapsedSubProcess(element)) {",
                "",
                "    assign(bounds, {",
                "      width: bbox.width,",
                "      height: bbox.height",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: defaultFontSize + 'px',",
                "      lineHeight: defaultLineHeight,",
                "      paddingTop: (7 * zoom) + 'px',",
                "      paddingBottom: (7 * zoom) + 'px',",
                "      paddingLeft: (5 * zoom) + 'px',",
                "      paddingRight: (5 * zoom) + 'px'",
                "    });",
                "  }",
                "",
                "",
                "  // internal labels for expanded sub processes",
                "  if (isExpandedSubProcess(element)) {",
                "    assign(bounds, {",
                "      width: bbox.width,",
                "      x: bbox.x",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: defaultFontSize + 'px',",
                "      lineHeight: defaultLineHeight,",
                "      paddingTop: (7 * zoom) + 'px',",
                "      paddingBottom: (7 * zoom) + 'px',",
                "      paddingLeft: (5 * zoom) + 'px',",
                "      paddingRight: (5 * zoom) + 'px'",
                "    });",
                "  }",
                "",
                "  var width = 90 * zoom,",
                "      paddingTop = 7 * zoom,",
                "      paddingBottom = 4 * zoom;",
                "",
                "  // external labels for events, data elements, gateways, groups and connections",
                "  if (target.labelTarget) {",
                "    assign(bounds, {",
                "      width: width,",
                "      height: bbox.height + paddingTop + paddingBottom,",
                "      x: mid.x - width / 2,",
                "      y: bbox.y - paddingTop",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: externalFontSize + 'px',",
                "      lineHeight: externalLineHeight,",
                "      paddingTop: paddingTop + 'px',",
                "      paddingBottom: paddingBottom + 'px'",
                "    });",
                "  }",
                "",
                "  // external label not yet created",
                "  if (isLabelExternal(target)",
                "      && !hasExternalLabel(target)",
                "      && !isLabel(target)) {",
                "",
                "    var externalLabelMid = getExternalLabelMid(element);",
                "",
                "    var absoluteBBox = canvas.getAbsoluteBBox({",
                "      x: externalLabelMid.x,",
                "      y: externalLabelMid.y,",
                "      width: 0,",
                "      height: 0",
                "    });",
                "",
                "    var height = externalFontSize + paddingTop + paddingBottom;",
                "",
                "    assign(bounds, {",
                "      width: width,",
                "      height: height,",
                "      x: absoluteBBox.x - width / 2,",
                "      y: absoluteBBox.y - height / 2",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: externalFontSize + 'px',",
                "      lineHeight: externalLineHeight,",
                "      paddingTop: paddingTop + 'px',",
                "      paddingBottom: paddingBottom + 'px'",
                "    });",
                "  }",
                "",
                "  // text annotations",
                "  if (is(element, 'bpmn:TextAnnotation')) {",
                "    assign(bounds, {",
                "      width: bbox.width,",
                "      height: bbox.height,",
                "      minWidth: 30 * zoom,",
                "      minHeight: 10 * zoom",
                "    });",
                "",
                "    assign(style, {",
                "      textAlign: 'left',",
                "      paddingTop: (5 * zoom) + 'px',",
                "      paddingBottom: (7 * zoom) + 'px',",
                "      paddingLeft: (7 * zoom) + 'px',",
                "      paddingRight: (5 * zoom) + 'px',",
                "      fontSize: defaultFontSize + 'px',",
                "      lineHeight: defaultLineHeight",
                "    });",
                "  }",
                "",
                "  return { bounds: bounds, style: style };",
                "};",
                "",
                "",
                "LabelEditingProvider.prototype.update = function(",
                "    element, newLabel,",
                "    activeContextText, bounds) {",
                "",
                "  var newBounds,",
                "      bbox;",
                "",
                "  if (is(element, 'bpmn:TextAnnotation')) {",
                "",
                "    bbox = this._canvas.getAbsoluteBBox(element);",
                "",
                "    newBounds = {",
                "      x: element.x,",
                "      y: element.y,",
                "      width: element.width / bbox.width * bounds.width,",
                "      height: element.height / bbox.height * bounds.height",
                "    };",
                "  }",
                "",
                "  if (is(element, 'bpmn:Group')) {",
                "",
                "    var businessObject = getBusinessObject(element);",
                "",
                "    // initialize categoryValue if not existing",
                "    if (!businessObject.categoryValueRef) {",
                "",
                "      var rootElement = this._canvas.getRootElement(),",
                "          definitions = getBusinessObject(rootElement).$parent;",
                "",
                "      var categoryValue = createCategoryValue(definitions, this._bpmnFactory);",
                "",
                "      getBusinessObject(element).categoryValueRef = categoryValue;",
                "    }",
                "",
                "  }",
                "",
                "  if (isEmptyText(newLabel)) {",
                "    newLabel = null;",
                "  }",
                "",
                "  this._modeling.updateLabel(element, newLabel, newBounds);",
                "};",
                "",
                "",
                "",
                "// helpers //////////////////////",
                "",
                "function isCollapsedSubProcess(element) {",
                "  return is(element, 'bpmn:SubProcess') && !isExpanded(element);",
                "}",
                "",
                "function isExpandedSubProcess(element) {",
                "  return is(element, 'bpmn:SubProcess') && isExpanded(element);",
                "}",
                "",
                "function isCollapsedPool(element) {",
                "  return is(element, 'bpmn:Participant') && !isExpanded(element);",
                "}",
                "",
                "function isExpandedPool(element) {",
                "  return is(element, 'bpmn:Participant') && isExpanded(element);",
                "}",
                "",
                "function isEmptyText(label) {",
                "  return !label || !label.trim();",
                "}"
            ]
        },
        "2": {
            "class_name": "  (not found) ",
            "file_path": "lib/features/modeling/Modeling.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 202
                }
            ],
            "class_code": [
                "import inherits from 'inherits-browser';",
                "",
                "import BaseModeling from 'diagram-js/lib/features/modeling/Modeling';",
                "",
                "import UpdateModdlePropertiesHandler from './cmd/UpdateModdlePropertiesHandler';",
                "import UpdatePropertiesHandler from './cmd/UpdatePropertiesHandler';",
                "import UpdateCanvasRootHandler from './cmd/UpdateCanvasRootHandler';",
                "import AddLaneHandler from './cmd/AddLaneHandler';",
                "import SplitLaneHandler from './cmd/SplitLaneHandler';",
                "import ResizeLaneHandler from './cmd/ResizeLaneHandler';",
                "import UpdateFlowNodeRefsHandler from './cmd/UpdateFlowNodeRefsHandler';",
                "import IdClaimHandler from './cmd/IdClaimHandler';",
                "import SetColorHandler from './cmd/SetColorHandler';",
                "",
                "import UpdateLabelHandler from '../label-editing/cmd/UpdateLabelHandler';",
                "",
                "",
                "/**",
                " * BPMN 2.0 modeling features activator",
                " *",
                " * @param {EventBus} eventBus",
                " * @param {ElementFactory} elementFactory",
                " * @param {CommandStack} commandStack",
                " * @param {BpmnRules} bpmnRules",
                " */",
                "export default function Modeling(",
                "    eventBus, elementFactory, commandStack,",
                "    bpmnRules) {",
                "",
                "  BaseModeling.call(this, eventBus, elementFactory, commandStack);",
                "",
                "  this._bpmnRules = bpmnRules;",
                "}",
                "",
                "inherits(Modeling, BaseModeling);",
                "",
                "Modeling.$inject = [",
                "  'eventBus',",
                "  'elementFactory',",
                "  'commandStack',",
                "  'bpmnRules'",
                "];",
                "",
                "",
                "Modeling.prototype.getHandlers = function() {",
                "  var handlers = BaseModeling.prototype.getHandlers.call(this);",
                "",
                "  handlers['element.updateModdleProperties'] = UpdateModdlePropertiesHandler;",
                "  handlers['element.updateProperties'] = UpdatePropertiesHandler;",
                "  handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;",
                "  handlers['lane.add'] = AddLaneHandler;",
                "  handlers['lane.resize'] = ResizeLaneHandler;",
                "  handlers['lane.split'] = SplitLaneHandler;",
                "  handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;",
                "  handlers['id.updateClaim'] = IdClaimHandler;",
                "  handlers['element.setColor'] = SetColorHandler;",
                "  handlers['element.updateLabel'] = UpdateLabelHandler;",
                "",
                "  return handlers;",
                "};",
                "",
                "",
                "Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {",
                "  this._commandStack.execute('element.updateLabel', {",
                "    element: element,",
                "    newLabel: newLabel,",
                "    newBounds: newBounds,",
                "    hints: hints || {}",
                "  });",
                "};",
                "",
                "",
                "Modeling.prototype.connect = function(source, target, attrs, hints) {",
                "",
                "  var bpmnRules = this._bpmnRules;",
                "",
                "  if (!attrs) {",
                "    attrs = bpmnRules.canConnect(source, target);",
                "  }",
                "",
                "  if (!attrs) {",
                "    return;",
                "  }",
                "",
                "  return this.createConnection(source, target, attrs, source.parent, hints);",
                "};",
                "",
                "",
                "Modeling.prototype.updateModdleProperties = function(element, moddleElement, properties) {",
                "  this._commandStack.execute('element.updateModdleProperties', {",
                "    element: element,",
                "    moddleElement: moddleElement,",
                "    properties: properties",
                "  });",
                "};",
                "",
                "Modeling.prototype.updateProperties = function(element, properties) {",
                "  this._commandStack.execute('element.updateProperties', {",
                "    element: element,",
                "    properties: properties",
                "  });",
                "};",
                "",
                "Modeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {",
                "  this._commandStack.execute('lane.resize', {",
                "    shape: laneShape,",
                "    newBounds: newBounds,",
                "    balanced: balanced",
                "  });",
                "};",
                "",
                "Modeling.prototype.addLane = function(targetLaneShape, location) {",
                "  var context = {",
                "    shape: targetLaneShape,",
                "    location: location",
                "  };",
                "",
                "  this._commandStack.execute('lane.add', context);",
                "",
                "  return context.newLane;",
                "};",
                "",
                "Modeling.prototype.splitLane = function(targetLane, count) {",
                "  this._commandStack.execute('lane.split', {",
                "    shape: targetLane,",
                "    count: count",
                "  });",
                "};",
                "",
                "/**",
                " * Transform the current diagram into a collaboration.",
                " *",
                " * @return {djs.model.Root} the new root element",
                " */",
                "Modeling.prototype.makeCollaboration = function() {",
                "",
                "  var collaborationElement = this._create('root', {",
                "    type: 'bpmn:Collaboration'",
                "  });",
                "",
                "  var context = {",
                "    newRoot: collaborationElement",
                "  };",
                "",
                "  this._commandStack.execute('canvas.updateRoot', context);",
                "",
                "  return collaborationElement;",
                "};",
                "",
                "Modeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {",
                "",
                "  this._commandStack.execute('lane.updateRefs', {",
                "    flowNodeShapes: flowNodeShapes,",
                "    laneShapes: laneShapes",
                "  });",
                "};",
                "",
                "/**",
                " * Transform the current diagram into a process.",
                " *",
                " * @return {djs.model.Root} the new root element",
                " */",
                "Modeling.prototype.makeProcess = function() {",
                "",
                "  var processElement = this._create('root', {",
                "    type: 'bpmn:Process'",
                "  });",
                "",
                "  var context = {",
                "    newRoot: processElement",
                "  };",
                "",
                "  this._commandStack.execute('canvas.updateRoot', context);",
                "};",
                "",
                "",
                "Modeling.prototype.claimId = function(id, moddleElement) {",
                "  this._commandStack.execute('id.updateClaim', {",
                "    id: id,",
                "    element: moddleElement,",
                "    claiming: true",
                "  });",
                "};",
                "",
                "",
                "Modeling.prototype.unclaimId = function(id, moddleElement) {",
                "  this._commandStack.execute('id.updateClaim', {",
                "    id: id,",
                "    element: moddleElement",
                "  });",
                "};",
                "",
                "Modeling.prototype.setColor = function(elements, colors) {",
                "  if (!elements.length) {",
                "    elements = [ elements ];",
                "  }",
                "",
                "  this._commandStack.execute('element.setColor', {",
                "    elements: elements,",
                "    colors: colors",
                "  });",
                "};"
            ]
        },
        "3": {
            "class_name": "  (not found) ",
            "file_path": "lib/features/label-editing/cmd/UpdateLabelHandler.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 165
                }
            ],
            "class_code": [
                "import {",
                "  setLabel,",
                "  getLabel",
                "} from '../LabelUtil';",
                "",
                "import {",
                "  getExternalLabelMid,",
                "  isLabelExternal,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../../util/LabelUtil';",
                "",
                "import {",
                "  getDi,",
                "  is",
                "} from '../../../util/ModelUtil';",
                "",
                "var NULL_DIMENSIONS = {",
                "  width: 0,",
                "  height: 0",
                "};",
                "",
                "",
                "/**",
                " * A handler that updates the text of a BPMN element.",
                " */",
                "export default function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {",
                "",
                "  /**",
                "   * Creates an empty `diLabel` attribute for embedded labels.",
                "   *",
                "   * @param {djs.model.Base} element",
                "   * @param {string} text",
                "   */",
                "  function ensureInternalLabelDi(element, text) {",
                "    if (isLabelExternal(element)) {",
                "      return;",
                "    }",
                "",
                "    var di = getDi(element);",
                "",
                "    if (text && !di.label) {",
                "      di.label = bpmnFactory.create('bpmndi:BPMNLabel');",
                "    }",
                "",
                "    if (!text && di.label) {",
                "      delete di.label;",
                "    }",
                "  }",
                "",
                "",
                "  /**",
                "   * Set the label and return the changed elements.",
                "   *",
                "   * Element parameter can be label itself or connection (i.e. sequence flow).",
                "   *",
                "   * @param {djs.model.Base} element",
                "   * @param {string} text",
                "   */",
                "  function setText(element, text) {",
                "",
                "    // external label if present",
                "    var label = element.label || element;",
                "",
                "    var labelTarget = element.labelTarget || element;",
                "",
                "    setLabel(label, text, labelTarget !== label);",
                "",
                "    ensureInternalLabelDi(element, text);",
                "",
                "    return [ label, labelTarget ];",
                "  }",
                "",
                "  function preExecute(ctx) {",
                "    var element = ctx.element,",
                "        businessObject = element.businessObject,",
                "        newLabel = ctx.newLabel;",
                "",
                "    if (!isLabel(element)",
                "        && isLabelExternal(element)",
                "        && !hasExternalLabel(element)",
                "        && !isEmptyText(newLabel)) {",
                "",
                "      // create label",
                "      var paddingTop = 7;",
                "",
                "      var labelCenter = getExternalLabelMid(element);",
                "",
                "      labelCenter = {",
                "        x: labelCenter.x,",
                "        y: labelCenter.y + paddingTop",
                "      };",
                "",
                "      modeling.createLabel(element, labelCenter, {",
                "        id: businessObject.id + '_label',",
                "        businessObject: businessObject,",
                "        di: element.di",
                "      });",
                "    }",
                "  }",
                "",
                "  function execute(ctx) {",
                "    ctx.oldLabel = getLabel(ctx.element);",
                "    return setText(ctx.element, ctx.newLabel);",
                "  }",
                "",
                "  function revert(ctx) {",
                "    return setText(ctx.element, ctx.oldLabel);",
                "  }",
                "",
                "  function postExecute(ctx) {",
                "    var element = ctx.element,",
                "        label = element.label || element,",
                "        newLabel = ctx.newLabel,",
                "        newBounds = ctx.newBounds,",
                "        hints = ctx.hints || {};",
                "",
                "    // ignore internal labels for elements except text annotations",
                "    if (!isLabel(label) && !is(label, 'bpmn:TextAnnotation')) {",
                "      return;",
                "    }",
                "",
                "    if (isLabel(label) && isEmptyText(newLabel)) {",
                "",
                "      if (hints.removeShape !== false) {",
                "        modeling.removeShape(label, { unsetLabel: false });",
                "      }",
                "",
                "      return;",
                "    }",
                "",
                "    var text = getLabel(label);",
                "",
                "    // resize element based on label _or_ pre-defined bounds",
                "    if (typeof newBounds === 'undefined') {",
                "      newBounds = textRenderer.getExternalLabelBounds(label, text);",
                "    }",
                "",
                "    // setting newBounds to false or _null_ will",
                "    // disable the postExecute resize operation",
                "    if (newBounds) {",
                "      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);",
                "    }",
                "  }",
                "",
                "  // API",
                "",
                "  this.preExecute = preExecute;",
                "  this.execute = execute;",
                "  this.revert = revert;",
                "  this.postExecute = postExecute;",
                "}",
                "",
                "UpdateLabelHandler.$inject = [",
                "  'modeling',",
                "  'textRenderer',",
                "  'bpmnFactory'",
                "];",
                "",
                "",
                "// helpers ///////////////////////",
                "",
                "function isEmptyText(label) {",
                "  return !label || !label.trim();",
                "}"
            ]
        }
    },
    "bug_functions": {
        "4": {
            "function_name": "LabelEditingProvider.prototype.update (not found) ",
            "file_path": "lib/features/label-editing/LabelEditingProvider.js",
            "function_details": [
                {
                    "name": "LabelEditingProvider.prototype.update",
                    "start_line": 1,
                    "end_line": 446
                }
            ],
            "function_code": [
                "import {",
                "  assign",
                "} from 'min-dash';",
                "",
                "import {",
                "  getLabel",
                "} from './LabelUtil';",
                "",
                "import {",
                "  getBusinessObject,",
                "  is",
                "} from '../../util/ModelUtil';",
                "",
                "import {",
                "  createCategoryValue",
                "} from '../modeling/behavior/util/CategoryUtil';",
                "",
                "import { isAny } from '../modeling/util/ModelingUtil';",
                "import { isExpanded } from '../../util/DiUtil';",
                "",
                "import {",
                "  getExternalLabelMid,",
                "  isLabelExternal,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../util/LabelUtil';",
                "",
                "",
                "export default function LabelEditingProvider(",
                "    eventBus, bpmnFactory, canvas, directEditing,",
                "    modeling, resizeHandles, textRenderer) {",
                "",
                "  this._bpmnFactory = bpmnFactory;",
                "  this._canvas = canvas;",
                "  this._modeling = modeling;",
                "  this._textRenderer = textRenderer;",
                "",
                "  directEditing.registerProvider(this);",
                "",
                "  // listen to dblclick on non-root elements",
                "  eventBus.on('element.dblclick', function(event) {",
                "    activateDirectEdit(event.element, true);",
                "  });",
                "",
                "  // complete on followup canvas operation",
                "  eventBus.on([",
                "    'autoPlace.start',",
                "    'canvas.viewbox.changing',",
                "    'drag.init',",
                "    'element.mousedown',",
                "    'popupMenu.open',",
                "    'root.set',",
                "    'selection.changed'",
                "  ], function(event) {",
                "",
                "    if (directEditing.isActive()) {",
                "      directEditing.complete();",
                "    }",
                "  });",
                "",
                "  eventBus.on([",
                "    'shape.remove',",
                "    'connection.remove'",
                "  ], function(event) {",
                "",
                "    if (directEditing.isActive(event.element)) {",
                "      directEditing.cancel();",
                "    }",
                "  });",
                "",
                "  // cancel on command stack changes",
                "  eventBus.on([ 'commandStack.changed' ], function(e) {",
                "    if (directEditing.isActive()) {",
                "      directEditing.cancel();",
                "    }",
                "  });",
                "",
                "",
                "  eventBus.on('directEditing.activate', function(event) {",
                "    resizeHandles.removeResizers();",
                "  });",
                "",
                "  eventBus.on('create.end', 500, function(event) {",
                "",
                "    var context = event.context,",
                "        element = context.shape,",
                "        canExecute = event.context.canExecute,",
                "        isTouch = event.isTouch;",
                "",
                "    // TODO(nikku): we need to find a way to support the",
                "    // direct editing on mobile devices; right now this will",
                "    // break for desworkflowediting on mobile devices",
                "    // as it breaks the user interaction workflow",
                "",
                "    // TODO(nre): we should temporarily focus the edited element",
                "    // here and release the focused viewport after the direct edit",
                "    // operation is finished",
                "    if (isTouch) {",
                "      return;",
                "    }",
                "",
                "    if (!canExecute) {",
                "      return;",
                "    }",
                "",
                "    if (context.hints && context.hints.createElementsBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    activateDirectEdit(element);",
                "  });",
                "",
                "  eventBus.on('autoPlace.end', 500, function(event) {",
                "    activateDirectEdit(event.shape);",
                "  });",
                "",
                "",
                "  function activateDirectEdit(element, force) {",
                "    if (force ||",
                "        isAny(element, [ 'bpmn:Task', 'bpmn:TextAnnotation' ]) ||",
                "        isCollapsedSubProcess(element)) {",
                "",
                "      directEditing.activate(element);",
                "    }",
                "  }",
                "",
                "}",
                "",
                "LabelEditingProvider.$inject = [",
                "  'eventBus',",
                "  'bpmnFactory',",
                "  'canvas',",
                "  'directEditing',",
                "  'modeling',",
                "  'resizeHandles',",
                "  'textRenderer'",
                "];",
                "",
                "",
                "/**",
                " * Activate direct editing for activities and text annotations.",
                " *",
                " * @param  {djs.model.Base} element",
                " *",
                " * @return {Object} an object with properties bounds (position and size), text and options",
                " */",
                "LabelEditingProvider.prototype.activate = function(element) {",
                "",
                "  // text",
                "  var text = getLabel(element);",
                "",
                "  if (text === undefined) {",
                "    return;",
                "  }",
                "",
                "  var context = {",
                "    text: text",
                "  };",
                "",
                "  // bounds",
                "  var bounds = this.getEditingBBox(element);",
                "",
                "  assign(context, bounds);",
                "",
                "  var options = {};",
                "",
                "  // tasks",
                "  if (",
                "    isAny(element, [",
                "      'bpmn:Task',",
                "      'bpmn:Participant',",
                "      'bpmn:Lane',",
                "      'bpmn:CallActivity'",
                "    ]) ||",
                "    isCollapsedSubProcess(element)",
                "  ) {",
                "    assign(options, {",
                "      centerVertically: true",
                "    });",
                "  }",
                "",
                "  // external labels",
                "  if (isLabelExternal(element)) {",
                "    assign(options, {",
                "      autoResize: true",
                "    });",
                "  }",
                "",
                "  // text annotations",
                "  if (is(element, 'bpmn:TextAnnotation')) {",
                "    assign(options, {",
                "      resizable: true,",
                "      autoResize: true",
                "    });",
                "  }",
                "",
                "  assign(context, {",
                "    options: options",
                "  });",
                "",
                "  return context;",
                "};",
                "",
                "",
                "/**",
                " * Get the editing bounding box based on the element's size and position",
                " *",
                " * @param  {djs.model.Base} element",
                " *",
                " * @return {Object} an object containing information about position",
                " *                  and size (fixed or minimum and/or maximum)",
                " */",
                "LabelEditingProvider.prototype.getEditingBBox = function(element) {",
                "  var canvas = this._canvas;",
                "",
                "  var target = element.label || element;",
                "",
                "  var bbox = canvas.getAbsoluteBBox(target);",
                "",
                "  var mid = {",
                "    x: bbox.x + bbox.width / 2,",
                "    y: bbox.y + bbox.height / 2",
                "  };",
                "",
                "  // default position",
                "  var bounds = { x: bbox.x, y: bbox.y };",
                "",
                "  var zoom = canvas.zoom();",
                "",
                "  var defaultStyle = this._textRenderer.getDefaultStyle(),",
                "      externalStyle = this._textRenderer.getExternalStyle();",
                "",
                "  // take zoom into account",
                "  var externalFontSize = externalStyle.fontSize * zoom,",
                "      externalLineHeight = externalStyle.lineHeight,",
                "      defaultFontSize = defaultStyle.fontSize * zoom,",
                "      defaultLineHeight = defaultStyle.lineHeight;",
                "",
                "  var style = {",
                "    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,",
                "    fontWeight: this._textRenderer.getDefaultStyle().fontWeight",
                "  };",
                "",
                "  // adjust for expanded pools AND lanes",
                "  if (is(element, 'bpmn:Lane') || isExpandedPool(element)) {",
                "",
                "    assign(bounds, {",
                "      width: bbox.height,",
                "      height: 30 * zoom,",
                "      x: bbox.x - bbox.height / 2 + (15 * zoom),",
                "      y: mid.y - (30 * zoom) / 2",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: defaultFontSize + 'px',",
                "      lineHeight: defaultLineHeight,",
                "      paddingTop: (7 * zoom) + 'px',",
                "      paddingBottom: (7 * zoom) + 'px',",
                "      paddingLeft: (5 * zoom) + 'px',",
                "      paddingRight: (5 * zoom) + 'px',",
                "      transform: 'rotate(-90deg)'",
                "    });",
                "  }",
                "",
                "",
                "  // internal labels for tasks and collapsed call activities,",
                "  // sub processes and participants",
                "  if (isAny(element, [ 'bpmn:Task', 'bpmn:CallActivity']) ||",
                "      isCollapsedPool(element) ||",
                "      isCollapsedSubProcess(element)) {",
                "",
                "    assign(bounds, {",
                "      width: bbox.width,",
                "      height: bbox.height",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: defaultFontSize + 'px',",
                "      lineHeight: defaultLineHeight,",
                "      paddingTop: (7 * zoom) + 'px',",
                "      paddingBottom: (7 * zoom) + 'px',",
                "      paddingLeft: (5 * zoom) + 'px',",
                "      paddingRight: (5 * zoom) + 'px'",
                "    });",
                "  }",
                "",
                "",
                "  // internal labels for expanded sub processes",
                "  if (isExpandedSubProcess(element)) {",
                "    assign(bounds, {",
                "      width: bbox.width,",
                "      x: bbox.x",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: defaultFontSize + 'px',",
                "      lineHeight: defaultLineHeight,",
                "      paddingTop: (7 * zoom) + 'px',",
                "      paddingBottom: (7 * zoom) + 'px',",
                "      paddingLeft: (5 * zoom) + 'px',",
                "      paddingRight: (5 * zoom) + 'px'",
                "    });",
                "  }",
                "",
                "  var width = 90 * zoom,",
                "      paddingTop = 7 * zoom,",
                "      paddingBottom = 4 * zoom;",
                "",
                "  // external labels for events, data elements, gateways, groups and connections",
                "  if (target.labelTarget) {",
                "    assign(bounds, {",
                "      width: width,",
                "      height: bbox.height + paddingTop + paddingBottom,",
                "      x: mid.x - width / 2,",
                "      y: bbox.y - paddingTop",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: externalFontSize + 'px',",
                "      lineHeight: externalLineHeight,",
                "      paddingTop: paddingTop + 'px',",
                "      paddingBottom: paddingBottom + 'px'",
                "    });",
                "  }",
                "",
                "  // external label not yet created",
                "  if (isLabelExternal(target)",
                "      && !hasExternalLabel(target)",
                "      && !isLabel(target)) {",
                "",
                "    var externalLabelMid = getExternalLabelMid(element);",
                "",
                "    var absoluteBBox = canvas.getAbsoluteBBox({",
                "      x: externalLabelMid.x,",
                "      y: externalLabelMid.y,",
                "      width: 0,",
                "      height: 0",
                "    });",
                "",
                "    var height = externalFontSize + paddingTop + paddingBottom;",
                "",
                "    assign(bounds, {",
                "      width: width,",
                "      height: height,",
                "      x: absoluteBBox.x - width / 2,",
                "      y: absoluteBBox.y - height / 2",
                "    });",
                "",
                "    assign(style, {",
                "      fontSize: externalFontSize + 'px',",
                "      lineHeight: externalLineHeight,",
                "      paddingTop: paddingTop + 'px',",
                "      paddingBottom: paddingBottom + 'px'",
                "    });",
                "  }",
                "",
                "  // text annotations",
                "  if (is(element, 'bpmn:TextAnnotation')) {",
                "    assign(bounds, {",
                "      width: bbox.width,",
                "      height: bbox.height,",
                "      minWidth: 30 * zoom,",
                "      minHeight: 10 * zoom",
                "    });",
                "",
                "    assign(style, {",
                "      textAlign: 'left',",
                "      paddingTop: (5 * zoom) + 'px',",
                "      paddingBottom: (7 * zoom) + 'px',",
                "      paddingLeft: (7 * zoom) + 'px',",
                "      paddingRight: (5 * zoom) + 'px',",
                "      fontSize: defaultFontSize + 'px',",
                "      lineHeight: defaultLineHeight",
                "    });",
                "  }",
                "",
                "  return { bounds: bounds, style: style };",
                "};",
                "",
                "",
                "LabelEditingProvider.prototype.update = function(",
                "    element, newLabel,",
                "    activeContextText, bounds) {",
                "",
                "  var newBounds,",
                "      bbox;",
                "",
                "  if (is(element, 'bpmn:TextAnnotation')) {",
                "",
                "    bbox = this._canvas.getAbsoluteBBox(element);",
                "",
                "    newBounds = {",
                "      x: element.x,",
                "      y: element.y,",
                "      width: element.width / bbox.width * bounds.width,",
                "      height: element.height / bbox.height * bounds.height",
                "    };",
                "  }",
                "",
                "  if (is(element, 'bpmn:Group')) {",
                "",
                "    var businessObject = getBusinessObject(element);",
                "",
                "    // initialize categoryValue if not existing",
                "    if (!businessObject.categoryValueRef) {",
                "",
                "      var rootElement = this._canvas.getRootElement(),",
                "          definitions = getBusinessObject(rootElement).$parent;",
                "",
                "      var categoryValue = createCategoryValue(definitions, this._bpmnFactory);",
                "",
                "      getBusinessObject(element).categoryValueRef = categoryValue;",
                "    }",
                "",
                "  }",
                "",
                "  if (isEmptyText(newLabel)) {",
                "    newLabel = null;",
                "  }",
                "",
                "  this._modeling.updateLabel(element, newLabel, newBounds);",
                "};",
                "",
                "",
                "",
                "// helpers //////////////////////",
                "",
                "function isCollapsedSubProcess(element) {",
                "  return is(element, 'bpmn:SubProcess') && !isExpanded(element);",
                "}",
                "",
                "function isExpandedSubProcess(element) {",
                "  return is(element, 'bpmn:SubProcess') && isExpanded(element);",
                "}",
                "",
                "function isCollapsedPool(element) {",
                "  return is(element, 'bpmn:Participant') && !isExpanded(element);",
                "}",
                "",
                "function isExpandedPool(element) {",
                "  return is(element, 'bpmn:Participant') && isExpanded(element);",
                "}",
                "",
                "function isEmptyText(label) {",
                "  return !label || !label.trim();",
                "}"
            ]
        },
        "5": {
            "function_name": "Modeling.prototype.updateLabel (not found) ",
            "file_path": "lib/features/modeling/Modeling.js",
            "function_details": [
                {
                    "name": "Modeling.prototype.updateLabel",
                    "start_line": 1,
                    "end_line": 202
                }
            ],
            "function_code": [
                "import inherits from 'inherits-browser';",
                "",
                "import BaseModeling from 'diagram-js/lib/features/modeling/Modeling';",
                "",
                "import UpdateModdlePropertiesHandler from './cmd/UpdateModdlePropertiesHandler';",
                "import UpdatePropertiesHandler from './cmd/UpdatePropertiesHandler';",
                "import UpdateCanvasRootHandler from './cmd/UpdateCanvasRootHandler';",
                "import AddLaneHandler from './cmd/AddLaneHandler';",
                "import SplitLaneHandler from './cmd/SplitLaneHandler';",
                "import ResizeLaneHandler from './cmd/ResizeLaneHandler';",
                "import UpdateFlowNodeRefsHandler from './cmd/UpdateFlowNodeRefsHandler';",
                "import IdClaimHandler from './cmd/IdClaimHandler';",
                "import SetColorHandler from './cmd/SetColorHandler';",
                "",
                "import UpdateLabelHandler from '../label-editing/cmd/UpdateLabelHandler';",
                "",
                "",
                "/**",
                " * BPMN 2.0 modeling features activator",
                " *",
                " * @param {EventBus} eventBus",
                " * @param {ElementFactory} elementFactory",
                " * @param {CommandStack} commandStack",
                " * @param {BpmnRules} bpmnRules",
                " */",
                "export default function Modeling(",
                "    eventBus, elementFactory, commandStack,",
                "    bpmnRules) {",
                "",
                "  BaseModeling.call(this, eventBus, elementFactory, commandStack);",
                "",
                "  this._bpmnRules = bpmnRules;",
                "}",
                "",
                "inherits(Modeling, BaseModeling);",
                "",
                "Modeling.$inject = [",
                "  'eventBus',",
                "  'elementFactory',",
                "  'commandStack',",
                "  'bpmnRules'",
                "];",
                "",
                "",
                "Modeling.prototype.getHandlers = function() {",
                "  var handlers = BaseModeling.prototype.getHandlers.call(this);",
                "",
                "  handlers['element.updateModdleProperties'] = UpdateModdlePropertiesHandler;",
                "  handlers['element.updateProperties'] = UpdatePropertiesHandler;",
                "  handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;",
                "  handlers['lane.add'] = AddLaneHandler;",
                "  handlers['lane.resize'] = ResizeLaneHandler;",
                "  handlers['lane.split'] = SplitLaneHandler;",
                "  handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;",
                "  handlers['id.updateClaim'] = IdClaimHandler;",
                "  handlers['element.setColor'] = SetColorHandler;",
                "  handlers['element.updateLabel'] = UpdateLabelHandler;",
                "",
                "  return handlers;",
                "};",
                "",
                "",
                "Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {",
                "  this._commandStack.execute('element.updateLabel', {",
                "    element: element,",
                "    newLabel: newLabel,",
                "    newBounds: newBounds,",
                "    hints: hints || {}",
                "  });",
                "};",
                "",
                "",
                "Modeling.prototype.connect = function(source, target, attrs, hints) {",
                "",
                "  var bpmnRules = this._bpmnRules;",
                "",
                "  if (!attrs) {",
                "    attrs = bpmnRules.canConnect(source, target);",
                "  }",
                "",
                "  if (!attrs) {",
                "    return;",
                "  }",
                "",
                "  return this.createConnection(source, target, attrs, source.parent, hints);",
                "};",
                "",
                "",
                "Modeling.prototype.updateModdleProperties = function(element, moddleElement, properties) {",
                "  this._commandStack.execute('element.updateModdleProperties', {",
                "    element: element,",
                "    moddleElement: moddleElement,",
                "    properties: properties",
                "  });",
                "};",
                "",
                "Modeling.prototype.updateProperties = function(element, properties) {",
                "  this._commandStack.execute('element.updateProperties', {",
                "    element: element,",
                "    properties: properties",
                "  });",
                "};",
                "",
                "Modeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {",
                "  this._commandStack.execute('lane.resize', {",
                "    shape: laneShape,",
                "    newBounds: newBounds,",
                "    balanced: balanced",
                "  });",
                "};",
                "",
                "Modeling.prototype.addLane = function(targetLaneShape, location) {",
                "  var context = {",
                "    shape: targetLaneShape,",
                "    location: location",
                "  };",
                "",
                "  this._commandStack.execute('lane.add', context);",
                "",
                "  return context.newLane;",
                "};",
                "",
                "Modeling.prototype.splitLane = function(targetLane, count) {",
                "  this._commandStack.execute('lane.split', {",
                "    shape: targetLane,",
                "    count: count",
                "  });",
                "};",
                "",
                "/**",
                " * Transform the current diagram into a collaboration.",
                " *",
                " * @return {djs.model.Root} the new root element",
                " */",
                "Modeling.prototype.makeCollaboration = function() {",
                "",
                "  var collaborationElement = this._create('root', {",
                "    type: 'bpmn:Collaboration'",
                "  });",
                "",
                "  var context = {",
                "    newRoot: collaborationElement",
                "  };",
                "",
                "  this._commandStack.execute('canvas.updateRoot', context);",
                "",
                "  return collaborationElement;",
                "};",
                "",
                "Modeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {",
                "",
                "  this._commandStack.execute('lane.updateRefs', {",
                "    flowNodeShapes: flowNodeShapes,",
                "    laneShapes: laneShapes",
                "  });",
                "};",
                "",
                "/**",
                " * Transform the current diagram into a process.",
                " *",
                " * @return {djs.model.Root} the new root element",
                " */",
                "Modeling.prototype.makeProcess = function() {",
                "",
                "  var processElement = this._create('root', {",
                "    type: 'bpmn:Process'",
                "  });",
                "",
                "  var context = {",
                "    newRoot: processElement",
                "  };",
                "",
                "  this._commandStack.execute('canvas.updateRoot', context);",
                "};",
                "",
                "",
                "Modeling.prototype.claimId = function(id, moddleElement) {",
                "  this._commandStack.execute('id.updateClaim', {",
                "    id: id,",
                "    element: moddleElement,",
                "    claiming: true",
                "  });",
                "};",
                "",
                "",
                "Modeling.prototype.unclaimId = function(id, moddleElement) {",
                "  this._commandStack.execute('id.updateClaim', {",
                "    id: id,",
                "    element: moddleElement",
                "  });",
                "};",
                "",
                "Modeling.prototype.setColor = function(elements, colors) {",
                "  if (!elements.length) {",
                "    elements = [ elements ];",
                "  }",
                "",
                "  this._commandStack.execute('element.setColor', {",
                "    elements: elements,",
                "    colors: colors",
                "  });",
                "};"
            ]
        },
        "6": {
            "function_name": "execute (not found) ",
            "file_path": "lib/features/label-editing/cmd/UpdateLabelHandler.js",
            "function_details": [
                {
                    "name": "execute",
                    "start_line": 1,
                    "end_line": 165
                }
            ],
            "function_code": [
                "import {",
                "  setLabel,",
                "  getLabel",
                "} from '../LabelUtil';",
                "",
                "import {",
                "  getExternalLabelMid,",
                "  isLabelExternal,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../../util/LabelUtil';",
                "",
                "import {",
                "  getDi,",
                "  is",
                "} from '../../../util/ModelUtil';",
                "",
                "var NULL_DIMENSIONS = {",
                "  width: 0,",
                "  height: 0",
                "};",
                "",
                "",
                "/**",
                " * A handler that updates the text of a BPMN element.",
                " */",
                "export default function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {",
                "",
                "  /**",
                "   * Creates an empty `diLabel` attribute for embedded labels.",
                "   *",
                "   * @param {djs.model.Base} element",
                "   * @param {string} text",
                "   */",
                "  function ensureInternalLabelDi(element, text) {",
                "    if (isLabelExternal(element)) {",
                "      return;",
                "    }",
                "",
                "    var di = getDi(element);",
                "",
                "    if (text && !di.label) {",
                "      di.label = bpmnFactory.create('bpmndi:BPMNLabel');",
                "    }",
                "",
                "    if (!text && di.label) {",
                "      delete di.label;",
                "    }",
                "  }",
                "",
                "",
                "  /**",
                "   * Set the label and return the changed elements.",
                "   *",
                "   * Element parameter can be label itself or connection (i.e. sequence flow).",
                "   *",
                "   * @param {djs.model.Base} element",
                "   * @param {string} text",
                "   */",
                "  function setText(element, text) {",
                "",
                "    // external label if present",
                "    var label = element.label || element;",
                "",
                "    var labelTarget = element.labelTarget || element;",
                "",
                "    setLabel(label, text, labelTarget !== label);",
                "",
                "    ensureInternalLabelDi(element, text);",
                "",
                "    return [ label, labelTarget ];",
                "  }",
                "",
                "  function preExecute(ctx) {",
                "    var element = ctx.element,",
                "        businessObject = element.businessObject,",
                "        newLabel = ctx.newLabel;",
                "",
                "    if (!isLabel(element)",
                "        && isLabelExternal(element)",
                "        && !hasExternalLabel(element)",
                "        && !isEmptyText(newLabel)) {",
                "",
                "      // create label",
                "      var paddingTop = 7;",
                "",
                "      var labelCenter = getExternalLabelMid(element);",
                "",
                "      labelCenter = {",
                "        x: labelCenter.x,",
                "        y: labelCenter.y + paddingTop",
                "      };",
                "",
                "      modeling.createLabel(element, labelCenter, {",
                "        id: businessObject.id + '_label',",
                "        businessObject: businessObject,",
                "        di: element.di",
                "      });",
                "    }",
                "  }",
                "",
                "  function execute(ctx) {",
                "    ctx.oldLabel = getLabel(ctx.element);",
                "    return setText(ctx.element, ctx.newLabel);",
                "  }",
                "",
                "  function revert(ctx) {",
                "    return setText(ctx.element, ctx.oldLabel);",
                "  }",
                "",
                "  function postExecute(ctx) {",
                "    var element = ctx.element,",
                "        label = element.label || element,",
                "        newLabel = ctx.newLabel,",
                "        newBounds = ctx.newBounds,",
                "        hints = ctx.hints || {};",
                "",
                "    // ignore internal labels for elements except text annotations",
                "    if (!isLabel(label) && !is(label, 'bpmn:TextAnnotation')) {",
                "      return;",
                "    }",
                "",
                "    if (isLabel(label) && isEmptyText(newLabel)) {",
                "",
                "      if (hints.removeShape !== false) {",
                "        modeling.removeShape(label, { unsetLabel: false });",
                "      }",
                "",
                "      return;",
                "    }",
                "",
                "    var text = getLabel(label);",
                "",
                "    // resize element based on label _or_ pre-defined bounds",
                "    if (typeof newBounds === 'undefined') {",
                "      newBounds = textRenderer.getExternalLabelBounds(label, text);",
                "    }",
                "",
                "    // setting newBounds to false or _null_ will",
                "    // disable the postExecute resize operation",
                "    if (newBounds) {",
                "      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);",
                "    }",
                "  }",
                "",
                "  // API",
                "",
                "  this.preExecute = preExecute;",
                "  this.execute = execute;",
                "  this.revert = revert;",
                "  this.postExecute = postExecute;",
                "}",
                "",
                "UpdateLabelHandler.$inject = [",
                "  'modeling',",
                "  'textRenderer',",
                "  'bpmnFactory'",
                "];",
                "",
                "",
                "// helpers ///////////////////////",
                "",
                "function isEmptyText(label) {",
                "  return !label || !label.trim();",
                "}"
            ]
        },
        "7": {
            "function_name": "revert (not found) ",
            "file_path": "lib/features/label-editing/cmd/UpdateLabelHandler.js",
            "function_details": [
                {
                    "name": "revert",
                    "start_line": 1,
                    "end_line": 165
                }
            ],
            "function_code": [
                "import {",
                "  setLabel,",
                "  getLabel",
                "} from '../LabelUtil';",
                "",
                "import {",
                "  getExternalLabelMid,",
                "  isLabelExternal,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../../util/LabelUtil';",
                "",
                "import {",
                "  getDi,",
                "  is",
                "} from '../../../util/ModelUtil';",
                "",
                "var NULL_DIMENSIONS = {",
                "  width: 0,",
                "  height: 0",
                "};",
                "",
                "",
                "/**",
                " * A handler that updates the text of a BPMN element.",
                " */",
                "export default function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {",
                "",
                "  /**",
                "   * Creates an empty `diLabel` attribute for embedded labels.",
                "   *",
                "   * @param {djs.model.Base} element",
                "   * @param {string} text",
                "   */",
                "  function ensureInternalLabelDi(element, text) {",
                "    if (isLabelExternal(element)) {",
                "      return;",
                "    }",
                "",
                "    var di = getDi(element);",
                "",
                "    if (text && !di.label) {",
                "      di.label = bpmnFactory.create('bpmndi:BPMNLabel');",
                "    }",
                "",
                "    if (!text && di.label) {",
                "      delete di.label;",
                "    }",
                "  }",
                "",
                "",
                "  /**",
                "   * Set the label and return the changed elements.",
                "   *",
                "   * Element parameter can be label itself or connection (i.e. sequence flow).",
                "   *",
                "   * @param {djs.model.Base} element",
                "   * @param {string} text",
                "   */",
                "  function setText(element, text) {",
                "",
                "    // external label if present",
                "    var label = element.label || element;",
                "",
                "    var labelTarget = element.labelTarget || element;",
                "",
                "    setLabel(label, text, labelTarget !== label);",
                "",
                "    ensureInternalLabelDi(element, text);",
                "",
                "    return [ label, labelTarget ];",
                "  }",
                "",
                "  function preExecute(ctx) {",
                "    var element = ctx.element,",
                "        businessObject = element.businessObject,",
                "        newLabel = ctx.newLabel;",
                "",
                "    if (!isLabel(element)",
                "        && isLabelExternal(element)",
                "        && !hasExternalLabel(element)",
                "        && !isEmptyText(newLabel)) {",
                "",
                "      // create label",
                "      var paddingTop = 7;",
                "",
                "      var labelCenter = getExternalLabelMid(element);",
                "",
                "      labelCenter = {",
                "        x: labelCenter.x,",
                "        y: labelCenter.y + paddingTop",
                "      };",
                "",
                "      modeling.createLabel(element, labelCenter, {",
                "        id: businessObject.id + '_label',",
                "        businessObject: businessObject,",
                "        di: element.di",
                "      });",
                "    }",
                "  }",
                "",
                "  function execute(ctx) {",
                "    ctx.oldLabel = getLabel(ctx.element);",
                "    return setText(ctx.element, ctx.newLabel);",
                "  }",
                "",
                "  function revert(ctx) {",
                "    return setText(ctx.element, ctx.oldLabel);",
                "  }",
                "",
                "  function postExecute(ctx) {",
                "    var element = ctx.element,",
                "        label = element.label || element,",
                "        newLabel = ctx.newLabel,",
                "        newBounds = ctx.newBounds,",
                "        hints = ctx.hints || {};",
                "",
                "    // ignore internal labels for elements except text annotations",
                "    if (!isLabel(label) && !is(label, 'bpmn:TextAnnotation')) {",
                "      return;",
                "    }",
                "",
                "    if (isLabel(label) && isEmptyText(newLabel)) {",
                "",
                "      if (hints.removeShape !== false) {",
                "        modeling.removeShape(label, { unsetLabel: false });",
                "      }",
                "",
                "      return;",
                "    }",
                "",
                "    var text = getLabel(label);",
                "",
                "    // resize element based on label _or_ pre-defined bounds",
                "    if (typeof newBounds === 'undefined') {",
                "      newBounds = textRenderer.getExternalLabelBounds(label, text);",
                "    }",
                "",
                "    // setting newBounds to false or _null_ will",
                "    // disable the postExecute resize operation",
                "    if (newBounds) {",
                "      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);",
                "    }",
                "  }",
                "",
                "  // API",
                "",
                "  this.preExecute = preExecute;",
                "  this.execute = execute;",
                "  this.revert = revert;",
                "  this.postExecute = postExecute;",
                "}",
                "",
                "UpdateLabelHandler.$inject = [",
                "  'modeling',",
                "  'textRenderer',",
                "  'bpmnFactory'",
                "];",
                "",
                "",
                "// helpers ///////////////////////",
                "",
                "function isEmptyText(label) {",
                "  return !label || !label.trim();",
                "}"
            ]
        },
        "8": {
            "function_name": "updateLabel (not found) ",
            "file_path": "lib/features/modeling/Modeling.js",
            "function_details": [
                {
                    "name": "updateLabel",
                    "start_line": 1,
                    "end_line": 202
                }
            ],
            "function_code": [
                "import inherits from 'inherits-browser';",
                "",
                "import BaseModeling from 'diagram-js/lib/features/modeling/Modeling';",
                "",
                "import UpdateModdlePropertiesHandler from './cmd/UpdateModdlePropertiesHandler';",
                "import UpdatePropertiesHandler from './cmd/UpdatePropertiesHandler';",
                "import UpdateCanvasRootHandler from './cmd/UpdateCanvasRootHandler';",
                "import AddLaneHandler from './cmd/AddLaneHandler';",
                "import SplitLaneHandler from './cmd/SplitLaneHandler';",
                "import ResizeLaneHandler from './cmd/ResizeLaneHandler';",
                "import UpdateFlowNodeRefsHandler from './cmd/UpdateFlowNodeRefsHandler';",
                "import IdClaimHandler from './cmd/IdClaimHandler';",
                "import SetColorHandler from './cmd/SetColorHandler';",
                "",
                "import UpdateLabelHandler from '../label-editing/cmd/UpdateLabelHandler';",
                "",
                "",
                "/**",
                " * BPMN 2.0 modeling features activator",
                " *",
                " * @param {EventBus} eventBus",
                " * @param {ElementFactory} elementFactory",
                " * @param {CommandStack} commandStack",
                " * @param {BpmnRules} bpmnRules",
                " */",
                "export default function Modeling(",
                "    eventBus, elementFactory, commandStack,",
                "    bpmnRules) {",
                "",
                "  BaseModeling.call(this, eventBus, elementFactory, commandStack);",
                "",
                "  this._bpmnRules = bpmnRules;",
                "}",
                "",
                "inherits(Modeling, BaseModeling);",
                "",
                "Modeling.$inject = [",
                "  'eventBus',",
                "  'elementFactory',",
                "  'commandStack',",
                "  'bpmnRules'",
                "];",
                "",
                "",
                "Modeling.prototype.getHandlers = function() {",
                "  var handlers = BaseModeling.prototype.getHandlers.call(this);",
                "",
                "  handlers['element.updateModdleProperties'] = UpdateModdlePropertiesHandler;",
                "  handlers['element.updateProperties'] = UpdatePropertiesHandler;",
                "  handlers['canvas.updateRoot'] = UpdateCanvasRootHandler;",
                "  handlers['lane.add'] = AddLaneHandler;",
                "  handlers['lane.resize'] = ResizeLaneHandler;",
                "  handlers['lane.split'] = SplitLaneHandler;",
                "  handlers['lane.updateRefs'] = UpdateFlowNodeRefsHandler;",
                "  handlers['id.updateClaim'] = IdClaimHandler;",
                "  handlers['element.setColor'] = SetColorHandler;",
                "  handlers['element.updateLabel'] = UpdateLabelHandler;",
                "",
                "  return handlers;",
                "};",
                "",
                "",
                "Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {",
                "  this._commandStack.execute('element.updateLabel', {",
                "    element: element,",
                "    newLabel: newLabel,",
                "    newBounds: newBounds,",
                "    hints: hints || {}",
                "  });",
                "};",
                "",
                "",
                "Modeling.prototype.connect = function(source, target, attrs, hints) {",
                "",
                "  var bpmnRules = this._bpmnRules;",
                "",
                "  if (!attrs) {",
                "    attrs = bpmnRules.canConnect(source, target);",
                "  }",
                "",
                "  if (!attrs) {",
                "    return;",
                "  }",
                "",
                "  return this.createConnection(source, target, attrs, source.parent, hints);",
                "};",
                "",
                "",
                "Modeling.prototype.updateModdleProperties = function(element, moddleElement, properties) {",
                "  this._commandStack.execute('element.updateModdleProperties', {",
                "    element: element,",
                "    moddleElement: moddleElement,",
                "    properties: properties",
                "  });",
                "};",
                "",
                "Modeling.prototype.updateProperties = function(element, properties) {",
                "  this._commandStack.execute('element.updateProperties', {",
                "    element: element,",
                "    properties: properties",
                "  });",
                "};",
                "",
                "Modeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {",
                "  this._commandStack.execute('lane.resize', {",
                "    shape: laneShape,",
                "    newBounds: newBounds,",
                "    balanced: balanced",
                "  });",
                "};",
                "",
                "Modeling.prototype.addLane = function(targetLaneShape, location) {",
                "  var context = {",
                "    shape: targetLaneShape,",
                "    location: location",
                "  };",
                "",
                "  this._commandStack.execute('lane.add', context);",
                "",
                "  return context.newLane;",
                "};",
                "",
                "Modeling.prototype.splitLane = function(targetLane, count) {",
                "  this._commandStack.execute('lane.split', {",
                "    shape: targetLane,",
                "    count: count",
                "  });",
                "};",
                "",
                "/**",
                " * Transform the current diagram into a collaboration.",
                " *",
                " * @return {djs.model.Root} the new root element",
                " */",
                "Modeling.prototype.makeCollaboration = function() {",
                "",
                "  var collaborationElement = this._create('root', {",
                "    type: 'bpmn:Collaboration'",
                "  });",
                "",
                "  var context = {",
                "    newRoot: collaborationElement",
                "  };",
                "",
                "  this._commandStack.execute('canvas.updateRoot', context);",
                "",
                "  return collaborationElement;",
                "};",
                "",
                "Modeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {",
                "",
                "  this._commandStack.execute('lane.updateRefs', {",
                "    flowNodeShapes: flowNodeShapes,",
                "    laneShapes: laneShapes",
                "  });",
                "};",
                "",
                "/**",
                " * Transform the current diagram into a process.",
                " *",
                " * @return {djs.model.Root} the new root element",
                " */",
                "Modeling.prototype.makeProcess = function() {",
                "",
                "  var processElement = this._create('root', {",
                "    type: 'bpmn:Process'",
                "  });",
                "",
                "  var context = {",
                "    newRoot: processElement",
                "  };",
                "",
                "  this._commandStack.execute('canvas.updateRoot', context);",
                "};",
                "",
                "",
                "Modeling.prototype.claimId = function(id, moddleElement) {",
                "  this._commandStack.execute('id.updateClaim', {",
                "    id: id,",
                "    element: moddleElement,",
                "    claiming: true",
                "  });",
                "};",
                "",
                "",
                "Modeling.prototype.unclaimId = function(id, moddleElement) {",
                "  this._commandStack.execute('id.updateClaim', {",
                "    id: id,",
                "    element: moddleElement",
                "  });",
                "};",
                "",
                "Modeling.prototype.setColor = function(elements, colors) {",
                "  if (!elements.length) {",
                "    elements = [ elements ];",
                "  }",
                "",
                "  this._commandStack.execute('element.setColor', {",
                "    elements: elements,",
                "    colors: colors",
                "  });",
                "};"
            ]
        }
    }
}