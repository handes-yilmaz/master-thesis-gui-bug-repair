{
    "1": {
        "bug_file": "lib/linter/code-path-analysis/code-path-analyzer.js",
        "compressed": "YES",
        "line_numbers": 852,
        "compressed_line_numbers": 325,
        "compressed_bug_file_content": "/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\n\n\n/**\n * Checks if a given node appears as the value of a PropertyDefinition node.\n * @param {ASTNode} node THe node to check.\n * @returns {boolean} `true` if the node is a PropertyDefinition value,\n *      false if not.\n */\n\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\n\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\n\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\n\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\n\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\n\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\n\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n    // Fires leaving events.\n\n\n    // Update state.\n\n\n    // Fires entering events.\n\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n        // The `arguments.length == 0` case is in `postprocess` function.\n\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n    /**\n     * Creates a new code path and trigger the onCodePathStart event\n     * based on the currently selected node.\n     * @param {string} origin The reason the code path was started.\n     * @returns {void}\n     */\n\n\n            // Emits onCodePathSegmentStart events if updated.\n\n\n        // Create the code path of this scope.\n\n\n        // Emits onCodePathStart events.\n\n\n    /*\n     * Special case: The right side of class field initializer is considered\n     * to be its own function, so we need to start a new code path in this\n     * case.\n     */\n\n\n        /*\n         * Intentional fall through because `node` needs to also be\n         * processed by the code below. For example, if we have:\n         *\n         * class Foo {\n         *     a = () => {}\n         * }\n         *\n         * In this case, we also need start a second code path.\n         */\n\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n\n\n    // Emits onCodePathSegmentStart events if updated.\n\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n\n\n    // Emits onCodePathSegmentStart events if updated.\n\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n    /**\n     * Ends the code path for the current node.\n     * @returns {void}\n     */\n\n\n        // Mark the current path as the final node.\n\n\n        // Emits onCodePathSegmentEnd event of the current segments.\n\n\n        // Emits onCodePathEnd event of this code path.\n\n\n        // The `arguments.length >= 1` case is in `preprocess` function.\n\n\n    /*\n     * Special case: The right side of class field initializer is considered\n     * to be its own function, so we need to end a code path in this\n     * case.\n     *\n     * We need to check after the other checks in order to close the\n     * code paths in the correct order for code like this:\n     *\n     *\n     * class Foo {\n     *     a = () => {}\n     * }\n     *\n     * In this case, The ArrowFunctionExpression code path is closed first\n     * and then we need to close the code path for the PropertyDefinition\n     * value.\n     */\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\n\n\n    /**\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\n     */\n\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     * @param {ASTNode} node A node which is entering.\n     * @returns {void}\n     */\n\n\n        // Updates the code path due to node's position in its parent node.\n\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n\n\n        // Emits node events.\n\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     * @param {ASTNode} node A node which is leaving.\n     * @returns {void}\n     */\n\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n\n\n        // Emits node events.\n\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     * @param {CodePathSegment} fromSegment A segment of prev.\n     * @param {CodePathSegment} toSegment A segment of next.\n     * @returns {void}\n     */\n\n\n"
    },
    "2": {
        "bug_file": "lib/linter/code-path-analysis/code-path-segment.js",
        "compressed": "NO",
        "line_numbers": 263,
        "compressed_line_numbers": 263,
        "compressed_bug_file_content": "/**\n * @fileoverview The CodePathSegment class.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n *\n * Each segment is arranged in a series of linked lists (implemented by arrays)\n * that keep track of the previous and next segments in a code path. In this way,\n * you can navigate between all segments in any code path so long as you have a\n * reference to any segment in that code path.\n *\n * When first created, the segment is in a detached state, meaning that it knows the\n * segments that came before it but those segments don't know that this new segment\n * follows it. Only when `CodePathSegment#markUsed()` is called on a segment does it\n * officially become part of the code path by updating the previous segments to know\n * that this new segment follows.\n */\nclass CodePathSegment {\n\n    /**\n     * Creates a new instance.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next reachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous reachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of all next segments including reachable and unreachable.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of all previous segments including reachable and unreachable.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n\n                // determines if the segment has been attached to the code path\n                used: false,\n\n                // array of previous segments coming from the end of a loop\n                loopedPrevSegments: []\n            }\n        });\n\n        /* c8 ignore start */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n        }/* c8 ignore stop */\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     * @param {CodePathSegment} segment A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.includes(segment);\n    }\n\n    /**\n     * Creates the root segment.\n     * @param {string} id An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a new segment and appends it after the given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments\n     *      to append to.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment and appends it after the given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be removed.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Marks a given segment as used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     * @param {CodePathSegment} segment A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n\n            /*\n             * If the segment is reachable, then it's officially part of the\n             * code path. This loops through all previous segments to update\n             * their list of next segments. Because the segment is reachable,\n             * it's added to both `nextSegments` and `allNextSegments`.\n             */\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n\n            /*\n             * If the segment is not reachable, then it's not officially part of the\n             * code path. This loops through all previous segments to update\n             * their list of next segments. Because the segment is not reachable,\n             * it's added only to `allNextSegments`.\n             */\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     * @param {CodePathSegment} segment A segment.\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Creates a new array based on an array of segments. If any segment in the\n     * array is unused, then it is replaced by all of its previous segments.\n     * All used segments are returned as-is without replacement.\n     * @param {CodePathSegment[]} segments The array of segments to flatten.\n     * @returns {CodePathSegment[]} The flattened array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = new Set();\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done.has(segment)) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done.has(prevSegment)) {\n                        done.add(prevSegment);\n                    }\n                }\n            } else {\n                done.add(segment);\n            }\n        }\n\n        return [...done];\n    }\n}\n\nmodule.exports = CodePathSegment;"
    },
    "3": {
        "bug_file": "lib/linter/code-path-analysis/code-path.js",
        "compressed": "NO",
        "line_numbers": 342,
        "compressed_line_numbers": 342,
        "compressed_bug_file_content": "/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathState = require(\"./code-path-state\");\nconst IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n */\nclass CodePath {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} options Options for the function (see below).\n     * @param {string} options.id An identifier.\n     * @param {string} options.origin The type of code path origin.\n     * @param {CodePath|null} options.upper The code path of the upper function scope.\n     * @param {Function} options.onLooped A callback function to notify looping.\n     */\n    constructor({ id, origin, upper, onLooped }) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The reason that this code path was started. May be \"program\",\n         * \"function\", \"class-field-initializer\", or \"class-static-block\".\n         * @type {string}\n         */\n        this.origin = origin;\n\n        /**\n         * The code path of the upper function scope.\n         * @type {CodePath|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The code paths of nested function scopes.\n         * @type {CodePath[]}\n         */\n        this.childCodePaths = [];\n\n        // Initializes internal state.\n        Object.defineProperty(\n            this,\n            \"internal\",\n            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }\n        );\n\n        // Adds this into `childCodePaths` of `upper`.\n        if (upper) {\n            upper.childCodePaths.push(this);\n        }\n    }\n\n    /**\n     * Gets the state of a given code path.\n     * @param {CodePath} codePath A code path to get.\n     * @returns {CodePathState} The state of the code path.\n     */\n    static getState(codePath) {\n        return codePath.internal;\n    }\n\n    /**\n     * The initial code path segment. This is the segment that is at the head\n     * of the code path.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment}\n     */\n    get initialSegment() {\n        return this.internal.initialSegment;\n    }\n\n    /**\n     * Final code path segments. These are the terminal (tail) segments in the\n     * code path, which is the combination of `returnedSegments` and `thrownSegments`.\n     * All segments in this array are reachable.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     */\n    get finalSegments() {\n        return this.internal.finalSegments;\n    }\n\n    /**\n     * Final code path segments that represent normal completion of the code path.\n     * For functions, this means both explicit `return` statements and implicit returns,\n     * such as the last reachable segment in a function that does not have an\n     * explicit `return` as this implicitly returns `undefined`. For scripts,\n     * modules, class field initializers, and class static blocks, this means\n     * all lines of code have been executed.\n     * These segments are also present in `finalSegments`.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     */\n    get returnedSegments() {\n        return this.internal.returnedForkContext;\n    }\n\n    /**\n     * Final code path segments that represent `throw` statements.\n     * This is a passthrough to the underlying `CodePathState`.\n     * These segments are also present in `finalSegments`.\n     * @type {CodePathSegment[]}\n     */\n    get thrownSegments() {\n        return this.internal.thrownForkContext;\n    }\n\n    /**\n     * Tracks the traversal of the code path through each segment. This array\n     * starts empty and segments are added or removed as the code path is\n     * traversed. This array always ends up empty at the end of a code path\n     * traversal. The `CodePathState` uses this to track its progress through\n     * the code path.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     * @deprecated\n     */\n    get currentSegments() {\n        return this.internal.currentSegments;\n    }\n\n    /**\n     * Traverses all segments in this code path.\n     *\n     *     codePath.traverseSegments((segment, controller) => {\n     *         // do something.\n     *     });\n     *\n     * This method enumerates segments in order from the head.\n     *\n     * The `controller` argument has two methods:\n     *\n     * - `skip()` - skips the following segments in this branch\n     * - `break()` - skips all following segments in the traversal\n     *\n     * A note on the parameters: the `options` argument is optional. This means\n     * the first argument might be an options object or the callback function.\n     * @param {Object} [optionsOrCallback] Optional first and last segments to traverse.\n     * @param {CodePathSegment} [optionsOrCallback.first] The first segment to traverse.\n     * @param {CodePathSegment} [optionsOrCallback.last] The last segment to traverse.\n     * @param {Function} callback A callback function.\n     * @returns {void}\n     */\n    traverseSegments(optionsOrCallback, callback) {\n\n        // normalize the arguments into a callback and options\n        let resolvedOptions;\n        let resolvedCallback;\n\n        if (typeof optionsOrCallback === \"function\") {\n            resolvedCallback = optionsOrCallback;\n            resolvedOptions = {};\n        } else {\n            resolvedOptions = optionsOrCallback || {};\n            resolvedCallback = callback;\n        }\n\n        // determine where to start traversing from based on the options\n        const startSegment = resolvedOptions.first || this.internal.initialSegment;\n        const lastSegment = resolvedOptions.last;\n\n        // set up initial location information\n        let record = null;\n        let index = 0;\n        let end = 0;\n        let segment = null;\n\n        // segments that have already been visited during traversal\n        const visited = new Set();\n\n        // tracks the traversal steps\n        const stack = [[startSegment, 0]];\n\n        // tracks the last skipped segment during traversal\n        let skippedSegment = null;\n\n        // indicates if we exited early from the traversal\n        let broken = false;\n\n        /**\n         * Maintains traversal state.\n         */\n        const controller = {\n\n            /**\n             * Skip the following segments in this branch.\n             * @returns {void}\n             */\n            skip() {\n                if (stack.length <= 1) {\n                    broken = true;\n                } else {\n                    skippedSegment = stack[stack.length - 2][0];\n                }\n            },\n\n            /**\n             * Stop traversal completely - do not traverse to any\n             * other segments.\n             * @returns {void}\n             */\n            break() {\n                broken = true;\n            }\n        };\n\n        /**\n         * Checks if a given previous segment has been visited.\n         * @param {CodePathSegment} prevSegment A previous segment to check.\n         * @returns {boolean} `true` if the segment has been visited.\n         */\n        function isVisited(prevSegment) {\n            return (\n                visited.has(prevSegment) ||\n                segment.isLoopedPrevSegment(prevSegment)\n            );\n        }\n\n        // the traversal\n        while (stack.length > 0) {\n\n            /*\n             * This isn't a pure stack. We use the top record all the time\n             * but don't always pop it off. The record is popped only if\n             * one of the following is true:\n             *\n             * 1) We have already visited the segment.\n             * 2) We have not visited *all* of the previous segments.\n             * 3) We have traversed past the available next segments.\n             *\n             * Otherwise, we just read the value and sometimes modify the\n             * record as we traverse.\n             */\n            record = stack[stack.length - 1];\n            segment = record[0];\n            index = record[1];\n\n            if (index === 0) {\n\n                // Skip if this segment has been visited already.\n                if (visited.has(segment)) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Skip if all previous segments have not been visited.\n                if (segment !== startSegment &&\n                    segment.prevSegments.length > 0 &&\n                    !segment.prevSegments.every(isVisited)\n                ) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Reset the skipping flag if all branches have been skipped.\n                if (skippedSegment && segment.prevSegments.includes(skippedSegment)) {\n                    skippedSegment = null;\n                }\n                visited.add(segment);\n\n                /*\n                 * If the most recent segment hasn't been skipped, then we call\n                 * the callback, passing in the segment and the controller.\n                 */\n                if (!skippedSegment) {\n                    resolvedCallback.call(this, segment, controller);\n\n                    // exit if we're at the last segment\n                    if (segment === lastSegment) {\n                        controller.skip();\n                    }\n\n                    /*\n                     * If the previous statement was executed, or if the callback\n                     * called a method on the controller, we might need to exit the\n                     * loop, so check for that and break accordingly.\n                     */\n                    if (broken) {\n                        break;\n                    }\n                }\n            }\n\n            // Update the stack.\n            end = segment.nextSegments.length - 1;\n            if (index < end) {\n\n                /*\n                 * If we haven't yet visited all of the next segments, update\n                 * the current top record on the stack to the next index to visit\n                 * and then push a record for the current segment on top.\n                 *\n                 * Setting the current top record's index lets us know how many\n                 * times we've been here and ensures that the segment won't be\n                 * reprocessed (because we only process segments with an index\n                 * of 0).\n                 */\n                record[1] += 1;\n                stack.push([segment.nextSegments[index], 0]);\n            } else if (index === end) {\n\n                /*\n                 * If we are at the last next segment, then reset the top record\n                 * in the stack to next segment and set its index to 0 so it will\n                 * be processed next.\n                 */\n                record[0] = segment.nextSegments[index];\n                record[1] = 0;\n            } else {\n\n                /*\n                 * If index > end, that means we have no more segments that need\n                 * processing. So, we pop that record off of the stack in order to\n                 * continue traversing at the next level up.\n                 */\n                stack.pop();\n            }\n        }\n    }\n}\n\nmodule.exports = CodePath;"
    }
}