{
    "1/1": {
        "lib/rules/implicit-arrow-linebreak.js": [
            {
                "SEARCH": [
                    "fixer.insertTextAfter(currentArrow, \" (\")"
                ],
                "REPLACE": [
                    "                        fixer.insertTextAfter(currentArrow, \"(\")"
                ]
            },
            {
                "SEARCH": [
                    "const whiteSpaces = \" \".repeat(paramsToken.loc.start.column);",
                    "",
                    "closingParentheses = `\\n${whiteSpaces})${closingParentheses}`;"
                ],
                "REPLACE": [
                    "                    closingParentheses = `)${closingParentheses}`;"
                ]
            },
            {
                "SEARCH": [
                    "if (comments.length) {",
                    "",
                    "// If the grandparent is not a variable declarator",
                    "if (",
                    "arrowBody.parent &&",
                    "arrowBody.parent.parent &&",
                    "arrowBody.parent.parent.type !== \"VariableDeclarator\"",
                    ") {",
                    "",
                    "// If any arrow functions follow, return the necessary parens fixes.",
                    "if (sourceCode.getTokenAfter(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                    "return addParentheses(fixer, arrowToken, arrowBody);",
                    "}",
                    "",
                    "// If any arrow functions precede, the necessary fixes have already been returned, so return null.",
                    "if (sourceCode.getTokenBefore(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                    "return null;",
                    "}",
                    "}",
                    "",
                    "const firstToken = findFirstToken(node);",
                    "",
                    "const commentText = formatComments(comments, firstToken.loc.start.column);",
                    "",
                    "const commentBeforeExpression = fixer.insertTextBeforeRange(",
                    "firstToken.range,",
                    "commentText",
                    ");",
                    "",
                    "return [placeBesides, commentBeforeExpression];",
                    "}"
                ],
                "REPLACE": [
                    "                if (comments.length) {",
                    "                    const firstToken = findFirstToken(node);",
                    "                    const commentText = formatComments(comments, firstToken.loc.start.column);",
                    "                    const commentBeforeExpression = fixer.insertTextBeforeRange(",
                    "                        firstToken.range,",
                    "                        commentText",
                    "                    );",
                    "                    return [placeBesides, commentBeforeExpression];",
                    "                }"
                ]
            }
        ]
    }
}