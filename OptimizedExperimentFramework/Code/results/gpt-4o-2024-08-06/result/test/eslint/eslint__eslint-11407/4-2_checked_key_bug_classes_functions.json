{
    "bug_classes": {
        "1": {
            "class_name": "module.exports (not found) ",
            "file_path": "lib/rules/implicit-arrow-linebreak.js",
            "class_details": [
                {
                    "name": "module.exports",
                    "start_line": 1,
                    "end_line": 236
                }
            ],
            "class_code": [
                "/**",
                " * @fileoverview enforce the location of arrow function bodies",
                " * @author Sharmila Jesupaul",
                " */",
                "\"use strict\";",
                "",
                "const {",
                "    isArrowToken,",
                "    isParenthesised,",
                "    isOpeningParenToken",
                "} = require(\"../util/ast-utils\");",
                "",
                "//------------------------------------------------------------------------------",
                "// Rule Definition",
                "//------------------------------------------------------------------------------",
                "module.exports = {",
                "    meta: {",
                "        type: \"layout\",",
                "",
                "        docs: {",
                "            description: \"enforce the location of arrow function bodies\",",
                "            category: \"Stylistic Issues\",",
                "            recommended: false,",
                "            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"",
                "        },",
                "",
                "        fixable: \"whitespace\",",
                "",
                "        schema: [",
                "            {",
                "                enum: [\"beside\", \"below\"]",
                "            }",
                "        ],",
                "        messages: {",
                "            expected: \"Expected a linebreak before this expression.\",",
                "            unexpected: \"Expected no linebreak before this expression.\"",
                "        }",
                "    },",
                "",
                "    create(context) {",
                "        const sourceCode = context.getSourceCode();",
                "",
                "        //----------------------------------------------------------------------",
                "        // Helpers",
                "        //----------------------------------------------------------------------",
                "        /**",
                "         * Gets the applicable preference for a particular keyword",
                "         * @returns {string} The applicable option for the keyword, e.g. 'beside'",
                "         */",
                "        function getOption() {",
                "            return context.options[0] || \"beside\";",
                "        }",
                "",
                "        /**",
                "         * Formats the comments depending on whether it's a line or block comment.",
                "         * @param {Comment[]} comments The array of comments between the arrow and body",
                "         * @param {Integer} column The column number of the first token",
                "         * @returns {string} A string of comment text joined by line breaks",
                "         */",
                "        function formatComments(comments, column) {",
                "            const whiteSpaces = \" \".repeat(column);",
                "",
                "            return `${comments.map(comment => {",
                "",
                "                if (comment.type === \"Line\") {",
                "                    return `//${comment.value}`;",
                "                }",
                "",
                "                return `/*${comment.value}*/`;",
                "            }).join(`\\n${whiteSpaces}`)}\\n${whiteSpaces}`;",
                "        }",
                "",
                "        /**",
                "         * Finds the first token to prepend comments to depending on the parent type",
                "         * @param {Node} node The validated node",
                "         * @returns {Token|Node} The node to prepend comments to",
                "         */",
                "        function findFirstToken(node) {",
                "            switch (node.parent.type) {",
                "                case \"VariableDeclarator\":",
                "",
                "                    // If the parent is first or only declarator, return the declaration, else, declarator",
                "                    return sourceCode.getFirstToken(",
                "                        node.parent.parent.declarations.length === 1 ||",
                "                        node.parent.parent.declarations[0].id.name === node.parent.id.name",
                "                            ? node.parent.parent : node.parent",
                "                    );",
                "                case \"CallExpression\":",
                "                case \"Property\":",
                "",
                "                    // find the object key",
                "                    return sourceCode.getFirstToken(node.parent);",
                "                default:",
                "                    return node;",
                "            }",
                "        }",
                "",
                "        /**",
                "         * Helper function for adding parentheses fixes for nodes containing nested arrow functions",
                "         * @param {Fixer} fixer Fixer",
                "         * @param {Token} arrow - The arrow token",
                "         * @param {ASTNode} arrowBody - The arrow function body",
                "         * @returns {Function[]} autofixer -- wraps function bodies with parentheses",
                "         */",
                "        function addParentheses(fixer, arrow, arrowBody) {",
                "            const parenthesesFixes = [];",
                "            let closingParentheses = \"\";",
                "",
                "            let followingBody = arrowBody;",
                "            let currentArrow = arrow;",
                "",
                "            while (currentArrow) {",
                "                if (!isParenthesised(sourceCode, followingBody)) {",
                "                    parenthesesFixes.push(",
                "                        fixer.insertTextAfter(currentArrow, \" (\")",
                "                    );",
                "",
                "                    const paramsToken = sourceCode.getTokenBefore(currentArrow, token =>",
                "                        isOpeningParenToken(token) || token.type === \"Identifier\");",
                "",
                "                    const whiteSpaces = \" \".repeat(paramsToken.loc.start.column);",
                "",
                "                    closingParentheses = `\\n${whiteSpaces})${closingParentheses}`;",
                "                }",
                "",
                "                currentArrow = sourceCode.getTokenAfter(currentArrow, isArrowToken);",
                "",
                "                if (currentArrow) {",
                "                    followingBody = sourceCode.getTokenAfter(currentArrow, token => !isOpeningParenToken(token));",
                "                }",
                "            }",
                "",
                "            return [...parenthesesFixes,",
                "                fixer.insertTextAfter(arrowBody, closingParentheses)",
                "            ];",
                "        }",
                "",
                "        /**",
                "         * Autofixes the function body to collapse onto the same line as the arrow.",
                "         * If comments exist, prepends the comments before the arrow function.",
                "         * If the function body contains arrow functions, appends the function bodies with parentheses.",
                "         * @param {Token} arrowToken The arrow token.",
                "         * @param {ASTNode} arrowBody the function body",
                "         * @param {ASTNode} node The evaluated node",
                "         * @returns {Function} autofixer -- validates the node to adhere to besides",
                "         */",
                "        function autoFixBesides(arrowToken, arrowBody, node) {",
                "            return fixer => {",
                "                const placeBesides = fixer.replaceTextRange([arrowToken.range[1], arrowBody.range[0]], \" \");",
                "",
                "                const comments = sourceCode.getCommentsInside(node).filter(comment =>",
                "                    comment.loc.start.line < arrowBody.loc.start.line);",
                "",
                "                if (comments.length) {",
                "",
                "                    // If the grandparent is not a variable declarator",
                "                    if (",
                "                        arrowBody.parent &&",
                "                        arrowBody.parent.parent &&",
                "                        arrowBody.parent.parent.type !== \"VariableDeclarator\"",
                "                    ) {",
                "",
                "                        // If any arrow functions follow, return the necessary parens fixes.",
                "                        if (sourceCode.getTokenAfter(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                "                            return addParentheses(fixer, arrowToken, arrowBody);",
                "                        }",
                "",
                "                        // If any arrow functions precede, the necessary fixes have already been returned, so return null.",
                "                        if (sourceCode.getTokenBefore(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                "                            return null;",
                "                        }",
                "                    }",
                "",
                "                    const firstToken = findFirstToken(node);",
                "",
                "                    const commentText = formatComments(comments, firstToken.loc.start.column);",
                "",
                "                    const commentBeforeExpression = fixer.insertTextBeforeRange(",
                "                        firstToken.range,",
                "                        commentText",
                "                    );",
                "",
                "                    return [placeBesides, commentBeforeExpression];",
                "                }",
                "",
                "                return placeBesides;",
                "            };",
                "        }",
                "",
                "        /**",
                "         * Validates the location of an arrow function body",
                "         * @param {ASTNode} node The arrow function body",
                "         * @returns {void}",
                "         */",
                "        function validateExpression(node) {",
                "            const option = getOption();",
                "",
                "            let tokenBefore = sourceCode.getTokenBefore(node.body);",
                "            const hasParens = tokenBefore.value === \"(\";",
                "",
                "            if (node.type === \"BlockStatement\") {",
                "                return;",
                "            }",
                "",
                "            let fixerTarget = node.body;",
                "",
                "            if (hasParens) {",
                "",
                "                // Gets the first token before the function body that is not an open paren",
                "                tokenBefore = sourceCode.getTokenBefore(node.body, token => token.value !== \"(\");",
                "                fixerTarget = sourceCode.getTokenAfter(tokenBefore);",
                "            }",
                "",
                "            if (tokenBefore.loc.end.line === fixerTarget.loc.start.line && option === \"below\") {",
                "                context.report({",
                "                    node: fixerTarget,",
                "                    messageId: \"expected\",",
                "                    fix: fixer => fixer.insertTextBefore(fixerTarget, \"\\n\")",
                "                });",
                "            } else if (tokenBefore.loc.end.line !== fixerTarget.loc.start.line && option === \"beside\") {",
                "                context.report({",
                "                    node: fixerTarget,",
                "                    messageId: \"unexpected\",",
                "                    fix: autoFixBesides(tokenBefore, fixerTarget, node)",
                "                });",
                "            }",
                "        }",
                "",
                "        //----------------------------------------------------------------------",
                "        // Public",
                "        //----------------------------------------------------------------------",
                "        return {",
                "            ArrowFunctionExpression: node => validateExpression(node)",
                "        };",
                "    }",
                "};"
            ]
        },
        "2": {
            "class_name": "SourceCodeFixer (not found) ",
            "file_path": "lib/util/source-code-fixer.js",
            "class_details": [
                {
                    "name": "SourceCodeFixer",
                    "start_line": 1,
                    "end_line": 152
                }
            ],
            "class_code": [
                "/**",
                " * @fileoverview An object that caches and applies source code fixes.",
                " * @author Nicholas C. Zakas",
                " */",
                "\"use strict\";",
                "",
                "//------------------------------------------------------------------------------",
                "// Requirements",
                "//------------------------------------------------------------------------------",
                "",
                "const debug = require(\"debug\")(\"eslint:source-code-fixer\");",
                "",
                "//------------------------------------------------------------------------------",
                "// Helpers",
                "//------------------------------------------------------------------------------",
                "",
                "const BOM = \"\\uFEFF\";",
                "",
                "/**",
                " * Compares items in a messages array by range.",
                " * @param {Message} a The first message.",
                " * @param {Message} b The second message.",
                " * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.",
                " * @private",
                " */",
                "function compareMessagesByFixRange(a, b) {",
                "    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];",
                "}",
                "",
                "/**",
                " * Compares items in a messages array by line and column.",
                " * @param {Message} a The first message.",
                " * @param {Message} b The second message.",
                " * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.",
                " * @private",
                " */",
                "function compareMessagesByLocation(a, b) {",
                "    return a.line - b.line || a.column - b.column;",
                "}",
                "",
                "//------------------------------------------------------------------------------",
                "// Public Interface",
                "//------------------------------------------------------------------------------",
                "",
                "/**",
                " * Utility for apply fixes to source code.",
                " * @constructor",
                " */",
                "function SourceCodeFixer() {",
                "    Object.freeze(this);",
                "}",
                "",
                "/**",
                " * Applies the fixes specified by the messages to the given text. Tries to be",
                " * smart about the fixes and won't apply fixes over the same area in the text.",
                " * @param {string} sourceText The text to apply the changes to.",
                " * @param {Message[]} messages The array of messages reported by ESLint.",
                " * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed",
                " * @returns {Object} An object containing the fixed text and any unfixed messages.",
                " */",
                "SourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {",
                "    debug(\"Applying fixes\");",
                "",
                "    if (shouldFix === false) {",
                "        debug(\"shouldFix parameter was false, not attempting fixes\");",
                "        return {",
                "            fixed: false,",
                "            messages,",
                "            output: sourceText",
                "        };",
                "    }",
                "",
                "    // clone the array",
                "    const remainingMessages = [],",
                "        fixes = [],",
                "        bom = sourceText.startsWith(BOM) ? BOM : \"\",",
                "        text = bom ? sourceText.slice(1) : sourceText;",
                "    let lastPos = Number.NEGATIVE_INFINITY,",
                "        output = bom;",
                "",
                "    /**",
                "     * Try to use the 'fix' from a problem.",
                "     * @param   {Message} problem The message object to apply fixes from",
                "     * @returns {boolean}         Whether fix was successfully applied",
                "     */",
                "    function attemptFix(problem) {",
                "        const fix = problem.fix;",
                "        const start = fix.range[0];",
                "        const end = fix.range[1];",
                "",
                "        // Remain it as a problem if it's overlapped or it's a negative range",
                "        if (lastPos >= start || start > end) {",
                "            remainingMessages.push(problem);",
                "            return false;",
                "        }",
                "",
                "        // Remove BOM.",
                "        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {",
                "            output = \"\";",
                "        }",
                "",
                "        // Make output to this fix.",
                "        output += text.slice(Math.max(0, lastPos), Math.max(0, start));",
                "        output += fix.text;",
                "        lastPos = end;",
                "        return true;",
                "    }",
                "",
                "    messages.forEach(problem => {",
                "        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {",
                "            fixes.push(problem);",
                "        } else {",
                "            remainingMessages.push(problem);",
                "        }",
                "    });",
                "",
                "    if (fixes.length) {",
                "        debug(\"Found fixes to apply\");",
                "        let fixesWereApplied = false;",
                "",
                "        for (const problem of fixes.sort(compareMessagesByFixRange)) {",
                "            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {",
                "                attemptFix(problem);",
                "",
                "                /*",
                "                 * The only time attemptFix will fail is if a previous fix was",
                "                 * applied which conflicts with it.  So we can mark this as true.",
                "                 */",
                "                fixesWereApplied = true;",
                "            } else {",
                "                remainingMessages.push(problem);",
                "            }",
                "        }",
                "        output += text.slice(Math.max(0, lastPos));",
                "",
                "        return {",
                "            fixed: fixesWereApplied,",
                "            messages: remainingMessages.sort(compareMessagesByLocation),",
                "            output",
                "        };",
                "    }",
                "",
                "    debug(\"No fixes to apply\");",
                "    return {",
                "        fixed: false,",
                "        messages,",
                "        output: bom + text",
                "    };",
                "",
                "};",
                "",
                "module.exports = SourceCodeFixer;"
            ]
        }
    },
    "bug_functions": {
        "3": {
            "function_name": "autoFixBesides (not found) ",
            "file_path": "lib/rules/implicit-arrow-linebreak.js",
            "function_details": [
                {
                    "name": "autoFixBesides",
                    "start_line": 1,
                    "end_line": 236
                }
            ],
            "function_code": [
                "/**",
                " * @fileoverview enforce the location of arrow function bodies",
                " * @author Sharmila Jesupaul",
                " */",
                "\"use strict\";",
                "",
                "const {",
                "    isArrowToken,",
                "    isParenthesised,",
                "    isOpeningParenToken",
                "} = require(\"../util/ast-utils\");",
                "",
                "//------------------------------------------------------------------------------",
                "// Rule Definition",
                "//------------------------------------------------------------------------------",
                "module.exports = {",
                "    meta: {",
                "        type: \"layout\",",
                "",
                "        docs: {",
                "            description: \"enforce the location of arrow function bodies\",",
                "            category: \"Stylistic Issues\",",
                "            recommended: false,",
                "            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"",
                "        },",
                "",
                "        fixable: \"whitespace\",",
                "",
                "        schema: [",
                "            {",
                "                enum: [\"beside\", \"below\"]",
                "            }",
                "        ],",
                "        messages: {",
                "            expected: \"Expected a linebreak before this expression.\",",
                "            unexpected: \"Expected no linebreak before this expression.\"",
                "        }",
                "    },",
                "",
                "    create(context) {",
                "        const sourceCode = context.getSourceCode();",
                "",
                "        //----------------------------------------------------------------------",
                "        // Helpers",
                "        //----------------------------------------------------------------------",
                "        /**",
                "         * Gets the applicable preference for a particular keyword",
                "         * @returns {string} The applicable option for the keyword, e.g. 'beside'",
                "         */",
                "        function getOption() {",
                "            return context.options[0] || \"beside\";",
                "        }",
                "",
                "        /**",
                "         * Formats the comments depending on whether it's a line or block comment.",
                "         * @param {Comment[]} comments The array of comments between the arrow and body",
                "         * @param {Integer} column The column number of the first token",
                "         * @returns {string} A string of comment text joined by line breaks",
                "         */",
                "        function formatComments(comments, column) {",
                "            const whiteSpaces = \" \".repeat(column);",
                "",
                "            return `${comments.map(comment => {",
                "",
                "                if (comment.type === \"Line\") {",
                "                    return `//${comment.value}`;",
                "                }",
                "",
                "                return `/*${comment.value}*/`;",
                "            }).join(`\\n${whiteSpaces}`)}\\n${whiteSpaces}`;",
                "        }",
                "",
                "        /**",
                "         * Finds the first token to prepend comments to depending on the parent type",
                "         * @param {Node} node The validated node",
                "         * @returns {Token|Node} The node to prepend comments to",
                "         */",
                "        function findFirstToken(node) {",
                "            switch (node.parent.type) {",
                "                case \"VariableDeclarator\":",
                "",
                "                    // If the parent is first or only declarator, return the declaration, else, declarator",
                "                    return sourceCode.getFirstToken(",
                "                        node.parent.parent.declarations.length === 1 ||",
                "                        node.parent.parent.declarations[0].id.name === node.parent.id.name",
                "                            ? node.parent.parent : node.parent",
                "                    );",
                "                case \"CallExpression\":",
                "                case \"Property\":",
                "",
                "                    // find the object key",
                "                    return sourceCode.getFirstToken(node.parent);",
                "                default:",
                "                    return node;",
                "            }",
                "        }",
                "",
                "        /**",
                "         * Helper function for adding parentheses fixes for nodes containing nested arrow functions",
                "         * @param {Fixer} fixer Fixer",
                "         * @param {Token} arrow - The arrow token",
                "         * @param {ASTNode} arrowBody - The arrow function body",
                "         * @returns {Function[]} autofixer -- wraps function bodies with parentheses",
                "         */",
                "        function addParentheses(fixer, arrow, arrowBody) {",
                "            const parenthesesFixes = [];",
                "            let closingParentheses = \"\";",
                "",
                "            let followingBody = arrowBody;",
                "            let currentArrow = arrow;",
                "",
                "            while (currentArrow) {",
                "                if (!isParenthesised(sourceCode, followingBody)) {",
                "                    parenthesesFixes.push(",
                "                        fixer.insertTextAfter(currentArrow, \" (\")",
                "                    );",
                "",
                "                    const paramsToken = sourceCode.getTokenBefore(currentArrow, token =>",
                "                        isOpeningParenToken(token) || token.type === \"Identifier\");",
                "",
                "                    const whiteSpaces = \" \".repeat(paramsToken.loc.start.column);",
                "",
                "                    closingParentheses = `\\n${whiteSpaces})${closingParentheses}`;",
                "                }",
                "",
                "                currentArrow = sourceCode.getTokenAfter(currentArrow, isArrowToken);",
                "",
                "                if (currentArrow) {",
                "                    followingBody = sourceCode.getTokenAfter(currentArrow, token => !isOpeningParenToken(token));",
                "                }",
                "            }",
                "",
                "            return [...parenthesesFixes,",
                "                fixer.insertTextAfter(arrowBody, closingParentheses)",
                "            ];",
                "        }",
                "",
                "        /**",
                "         * Autofixes the function body to collapse onto the same line as the arrow.",
                "         * If comments exist, prepends the comments before the arrow function.",
                "         * If the function body contains arrow functions, appends the function bodies with parentheses.",
                "         * @param {Token} arrowToken The arrow token.",
                "         * @param {ASTNode} arrowBody the function body",
                "         * @param {ASTNode} node The evaluated node",
                "         * @returns {Function} autofixer -- validates the node to adhere to besides",
                "         */",
                "        function autoFixBesides(arrowToken, arrowBody, node) {",
                "            return fixer => {",
                "                const placeBesides = fixer.replaceTextRange([arrowToken.range[1], arrowBody.range[0]], \" \");",
                "",
                "                const comments = sourceCode.getCommentsInside(node).filter(comment =>",
                "                    comment.loc.start.line < arrowBody.loc.start.line);",
                "",
                "                if (comments.length) {",
                "",
                "                    // If the grandparent is not a variable declarator",
                "                    if (",
                "                        arrowBody.parent &&",
                "                        arrowBody.parent.parent &&",
                "                        arrowBody.parent.parent.type !== \"VariableDeclarator\"",
                "                    ) {",
                "",
                "                        // If any arrow functions follow, return the necessary parens fixes.",
                "                        if (sourceCode.getTokenAfter(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                "                            return addParentheses(fixer, arrowToken, arrowBody);",
                "                        }",
                "",
                "                        // If any arrow functions precede, the necessary fixes have already been returned, so return null.",
                "                        if (sourceCode.getTokenBefore(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                "                            return null;",
                "                        }",
                "                    }",
                "",
                "                    const firstToken = findFirstToken(node);",
                "",
                "                    const commentText = formatComments(comments, firstToken.loc.start.column);",
                "",
                "                    const commentBeforeExpression = fixer.insertTextBeforeRange(",
                "                        firstToken.range,",
                "                        commentText",
                "                    );",
                "",
                "                    return [placeBesides, commentBeforeExpression];",
                "                }",
                "",
                "                return placeBesides;",
                "            };",
                "        }",
                "",
                "        /**",
                "         * Validates the location of an arrow function body",
                "         * @param {ASTNode} node The arrow function body",
                "         * @returns {void}",
                "         */",
                "        function validateExpression(node) {",
                "            const option = getOption();",
                "",
                "            let tokenBefore = sourceCode.getTokenBefore(node.body);",
                "            const hasParens = tokenBefore.value === \"(\";",
                "",
                "            if (node.type === \"BlockStatement\") {",
                "                return;",
                "            }",
                "",
                "            let fixerTarget = node.body;",
                "",
                "            if (hasParens) {",
                "",
                "                // Gets the first token before the function body that is not an open paren",
                "                tokenBefore = sourceCode.getTokenBefore(node.body, token => token.value !== \"(\");",
                "                fixerTarget = sourceCode.getTokenAfter(tokenBefore);",
                "            }",
                "",
                "            if (tokenBefore.loc.end.line === fixerTarget.loc.start.line && option === \"below\") {",
                "                context.report({",
                "                    node: fixerTarget,",
                "                    messageId: \"expected\",",
                "                    fix: fixer => fixer.insertTextBefore(fixerTarget, \"\\n\")",
                "                });",
                "            } else if (tokenBefore.loc.end.line !== fixerTarget.loc.start.line && option === \"beside\") {",
                "                context.report({",
                "                    node: fixerTarget,",
                "                    messageId: \"unexpected\",",
                "                    fix: autoFixBesides(tokenBefore, fixerTarget, node)",
                "                });",
                "            }",
                "        }",
                "",
                "        //----------------------------------------------------------------------",
                "        // Public",
                "        //----------------------------------------------------------------------",
                "        return {",
                "            ArrowFunctionExpression: node => validateExpression(node)",
                "        };",
                "    }",
                "};"
            ]
        },
        "4": {
            "function_name": "validateExpression (not found) ",
            "file_path": "lib/rules/implicit-arrow-linebreak.js",
            "function_details": [
                {
                    "name": "validateExpression",
                    "start_line": 1,
                    "end_line": 236
                }
            ],
            "function_code": [
                "/**",
                " * @fileoverview enforce the location of arrow function bodies",
                " * @author Sharmila Jesupaul",
                " */",
                "\"use strict\";",
                "",
                "const {",
                "    isArrowToken,",
                "    isParenthesised,",
                "    isOpeningParenToken",
                "} = require(\"../util/ast-utils\");",
                "",
                "//------------------------------------------------------------------------------",
                "// Rule Definition",
                "//------------------------------------------------------------------------------",
                "module.exports = {",
                "    meta: {",
                "        type: \"layout\",",
                "",
                "        docs: {",
                "            description: \"enforce the location of arrow function bodies\",",
                "            category: \"Stylistic Issues\",",
                "            recommended: false,",
                "            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"",
                "        },",
                "",
                "        fixable: \"whitespace\",",
                "",
                "        schema: [",
                "            {",
                "                enum: [\"beside\", \"below\"]",
                "            }",
                "        ],",
                "        messages: {",
                "            expected: \"Expected a linebreak before this expression.\",",
                "            unexpected: \"Expected no linebreak before this expression.\"",
                "        }",
                "    },",
                "",
                "    create(context) {",
                "        const sourceCode = context.getSourceCode();",
                "",
                "        //----------------------------------------------------------------------",
                "        // Helpers",
                "        //----------------------------------------------------------------------",
                "        /**",
                "         * Gets the applicable preference for a particular keyword",
                "         * @returns {string} The applicable option for the keyword, e.g. 'beside'",
                "         */",
                "        function getOption() {",
                "            return context.options[0] || \"beside\";",
                "        }",
                "",
                "        /**",
                "         * Formats the comments depending on whether it's a line or block comment.",
                "         * @param {Comment[]} comments The array of comments between the arrow and body",
                "         * @param {Integer} column The column number of the first token",
                "         * @returns {string} A string of comment text joined by line breaks",
                "         */",
                "        function formatComments(comments, column) {",
                "            const whiteSpaces = \" \".repeat(column);",
                "",
                "            return `${comments.map(comment => {",
                "",
                "                if (comment.type === \"Line\") {",
                "                    return `//${comment.value}`;",
                "                }",
                "",
                "                return `/*${comment.value}*/`;",
                "            }).join(`\\n${whiteSpaces}`)}\\n${whiteSpaces}`;",
                "        }",
                "",
                "        /**",
                "         * Finds the first token to prepend comments to depending on the parent type",
                "         * @param {Node} node The validated node",
                "         * @returns {Token|Node} The node to prepend comments to",
                "         */",
                "        function findFirstToken(node) {",
                "            switch (node.parent.type) {",
                "                case \"VariableDeclarator\":",
                "",
                "                    // If the parent is first or only declarator, return the declaration, else, declarator",
                "                    return sourceCode.getFirstToken(",
                "                        node.parent.parent.declarations.length === 1 ||",
                "                        node.parent.parent.declarations[0].id.name === node.parent.id.name",
                "                            ? node.parent.parent : node.parent",
                "                    );",
                "                case \"CallExpression\":",
                "                case \"Property\":",
                "",
                "                    // find the object key",
                "                    return sourceCode.getFirstToken(node.parent);",
                "                default:",
                "                    return node;",
                "            }",
                "        }",
                "",
                "        /**",
                "         * Helper function for adding parentheses fixes for nodes containing nested arrow functions",
                "         * @param {Fixer} fixer Fixer",
                "         * @param {Token} arrow - The arrow token",
                "         * @param {ASTNode} arrowBody - The arrow function body",
                "         * @returns {Function[]} autofixer -- wraps function bodies with parentheses",
                "         */",
                "        function addParentheses(fixer, arrow, arrowBody) {",
                "            const parenthesesFixes = [];",
                "            let closingParentheses = \"\";",
                "",
                "            let followingBody = arrowBody;",
                "            let currentArrow = arrow;",
                "",
                "            while (currentArrow) {",
                "                if (!isParenthesised(sourceCode, followingBody)) {",
                "                    parenthesesFixes.push(",
                "                        fixer.insertTextAfter(currentArrow, \" (\")",
                "                    );",
                "",
                "                    const paramsToken = sourceCode.getTokenBefore(currentArrow, token =>",
                "                        isOpeningParenToken(token) || token.type === \"Identifier\");",
                "",
                "                    const whiteSpaces = \" \".repeat(paramsToken.loc.start.column);",
                "",
                "                    closingParentheses = `\\n${whiteSpaces})${closingParentheses}`;",
                "                }",
                "",
                "                currentArrow = sourceCode.getTokenAfter(currentArrow, isArrowToken);",
                "",
                "                if (currentArrow) {",
                "                    followingBody = sourceCode.getTokenAfter(currentArrow, token => !isOpeningParenToken(token));",
                "                }",
                "            }",
                "",
                "            return [...parenthesesFixes,",
                "                fixer.insertTextAfter(arrowBody, closingParentheses)",
                "            ];",
                "        }",
                "",
                "        /**",
                "         * Autofixes the function body to collapse onto the same line as the arrow.",
                "         * If comments exist, prepends the comments before the arrow function.",
                "         * If the function body contains arrow functions, appends the function bodies with parentheses.",
                "         * @param {Token} arrowToken The arrow token.",
                "         * @param {ASTNode} arrowBody the function body",
                "         * @param {ASTNode} node The evaluated node",
                "         * @returns {Function} autofixer -- validates the node to adhere to besides",
                "         */",
                "        function autoFixBesides(arrowToken, arrowBody, node) {",
                "            return fixer => {",
                "                const placeBesides = fixer.replaceTextRange([arrowToken.range[1], arrowBody.range[0]], \" \");",
                "",
                "                const comments = sourceCode.getCommentsInside(node).filter(comment =>",
                "                    comment.loc.start.line < arrowBody.loc.start.line);",
                "",
                "                if (comments.length) {",
                "",
                "                    // If the grandparent is not a variable declarator",
                "                    if (",
                "                        arrowBody.parent &&",
                "                        arrowBody.parent.parent &&",
                "                        arrowBody.parent.parent.type !== \"VariableDeclarator\"",
                "                    ) {",
                "",
                "                        // If any arrow functions follow, return the necessary parens fixes.",
                "                        if (sourceCode.getTokenAfter(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                "                            return addParentheses(fixer, arrowToken, arrowBody);",
                "                        }",
                "",
                "                        // If any arrow functions precede, the necessary fixes have already been returned, so return null.",
                "                        if (sourceCode.getTokenBefore(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                "                            return null;",
                "                        }",
                "                    }",
                "",
                "                    const firstToken = findFirstToken(node);",
                "",
                "                    const commentText = formatComments(comments, firstToken.loc.start.column);",
                "",
                "                    const commentBeforeExpression = fixer.insertTextBeforeRange(",
                "                        firstToken.range,",
                "                        commentText",
                "                    );",
                "",
                "                    return [placeBesides, commentBeforeExpression];",
                "                }",
                "",
                "                return placeBesides;",
                "            };",
                "        }",
                "",
                "        /**",
                "         * Validates the location of an arrow function body",
                "         * @param {ASTNode} node The arrow function body",
                "         * @returns {void}",
                "         */",
                "        function validateExpression(node) {",
                "            const option = getOption();",
                "",
                "            let tokenBefore = sourceCode.getTokenBefore(node.body);",
                "            const hasParens = tokenBefore.value === \"(\";",
                "",
                "            if (node.type === \"BlockStatement\") {",
                "                return;",
                "            }",
                "",
                "            let fixerTarget = node.body;",
                "",
                "            if (hasParens) {",
                "",
                "                // Gets the first token before the function body that is not an open paren",
                "                tokenBefore = sourceCode.getTokenBefore(node.body, token => token.value !== \"(\");",
                "                fixerTarget = sourceCode.getTokenAfter(tokenBefore);",
                "            }",
                "",
                "            if (tokenBefore.loc.end.line === fixerTarget.loc.start.line && option === \"below\") {",
                "                context.report({",
                "                    node: fixerTarget,",
                "                    messageId: \"expected\",",
                "                    fix: fixer => fixer.insertTextBefore(fixerTarget, \"\\n\")",
                "                });",
                "            } else if (tokenBefore.loc.end.line !== fixerTarget.loc.start.line && option === \"beside\") {",
                "                context.report({",
                "                    node: fixerTarget,",
                "                    messageId: \"unexpected\",",
                "                    fix: autoFixBesides(tokenBefore, fixerTarget, node)",
                "                });",
                "            }",
                "        }",
                "",
                "        //----------------------------------------------------------------------",
                "        // Public",
                "        //----------------------------------------------------------------------",
                "        return {",
                "            ArrowFunctionExpression: node => validateExpression(node)",
                "        };",
                "    }",
                "};"
            ]
        },
        "5": {
            "function_name": "SourceCodeFixer.applyFixes (not found) ",
            "file_path": "lib/util/source-code-fixer.js",
            "function_details": [
                {
                    "name": "SourceCodeFixer.applyFixes",
                    "start_line": 1,
                    "end_line": 152
                }
            ],
            "function_code": [
                "/**",
                " * @fileoverview An object that caches and applies source code fixes.",
                " * @author Nicholas C. Zakas",
                " */",
                "\"use strict\";",
                "",
                "//------------------------------------------------------------------------------",
                "// Requirements",
                "//------------------------------------------------------------------------------",
                "",
                "const debug = require(\"debug\")(\"eslint:source-code-fixer\");",
                "",
                "//------------------------------------------------------------------------------",
                "// Helpers",
                "//------------------------------------------------------------------------------",
                "",
                "const BOM = \"\\uFEFF\";",
                "",
                "/**",
                " * Compares items in a messages array by range.",
                " * @param {Message} a The first message.",
                " * @param {Message} b The second message.",
                " * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.",
                " * @private",
                " */",
                "function compareMessagesByFixRange(a, b) {",
                "    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];",
                "}",
                "",
                "/**",
                " * Compares items in a messages array by line and column.",
                " * @param {Message} a The first message.",
                " * @param {Message} b The second message.",
                " * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.",
                " * @private",
                " */",
                "function compareMessagesByLocation(a, b) {",
                "    return a.line - b.line || a.column - b.column;",
                "}",
                "",
                "//------------------------------------------------------------------------------",
                "// Public Interface",
                "//------------------------------------------------------------------------------",
                "",
                "/**",
                " * Utility for apply fixes to source code.",
                " * @constructor",
                " */",
                "function SourceCodeFixer() {",
                "    Object.freeze(this);",
                "}",
                "",
                "/**",
                " * Applies the fixes specified by the messages to the given text. Tries to be",
                " * smart about the fixes and won't apply fixes over the same area in the text.",
                " * @param {string} sourceText The text to apply the changes to.",
                " * @param {Message[]} messages The array of messages reported by ESLint.",
                " * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed",
                " * @returns {Object} An object containing the fixed text and any unfixed messages.",
                " */",
                "SourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {",
                "    debug(\"Applying fixes\");",
                "",
                "    if (shouldFix === false) {",
                "        debug(\"shouldFix parameter was false, not attempting fixes\");",
                "        return {",
                "            fixed: false,",
                "            messages,",
                "            output: sourceText",
                "        };",
                "    }",
                "",
                "    // clone the array",
                "    const remainingMessages = [],",
                "        fixes = [],",
                "        bom = sourceText.startsWith(BOM) ? BOM : \"\",",
                "        text = bom ? sourceText.slice(1) : sourceText;",
                "    let lastPos = Number.NEGATIVE_INFINITY,",
                "        output = bom;",
                "",
                "    /**",
                "     * Try to use the 'fix' from a problem.",
                "     * @param   {Message} problem The message object to apply fixes from",
                "     * @returns {boolean}         Whether fix was successfully applied",
                "     */",
                "    function attemptFix(problem) {",
                "        const fix = problem.fix;",
                "        const start = fix.range[0];",
                "        const end = fix.range[1];",
                "",
                "        // Remain it as a problem if it's overlapped or it's a negative range",
                "        if (lastPos >= start || start > end) {",
                "            remainingMessages.push(problem);",
                "            return false;",
                "        }",
                "",
                "        // Remove BOM.",
                "        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {",
                "            output = \"\";",
                "        }",
                "",
                "        // Make output to this fix.",
                "        output += text.slice(Math.max(0, lastPos), Math.max(0, start));",
                "        output += fix.text;",
                "        lastPos = end;",
                "        return true;",
                "    }",
                "",
                "    messages.forEach(problem => {",
                "        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {",
                "            fixes.push(problem);",
                "        } else {",
                "            remainingMessages.push(problem);",
                "        }",
                "    });",
                "",
                "    if (fixes.length) {",
                "        debug(\"Found fixes to apply\");",
                "        let fixesWereApplied = false;",
                "",
                "        for (const problem of fixes.sort(compareMessagesByFixRange)) {",
                "            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {",
                "                attemptFix(problem);",
                "",
                "                /*",
                "                 * The only time attemptFix will fail is if a previous fix was",
                "                 * applied which conflicts with it.  So we can mark this as true.",
                "                 */",
                "                fixesWereApplied = true;",
                "            } else {",
                "                remainingMessages.push(problem);",
                "            }",
                "        }",
                "        output += text.slice(Math.max(0, lastPos));",
                "",
                "        return {",
                "            fixed: fixesWereApplied,",
                "            messages: remainingMessages.sort(compareMessagesByLocation),",
                "            output",
                "        };",
                "    }",
                "",
                "    debug(\"No fixes to apply\");",
                "    return {",
                "        fixed: false,",
                "        messages,",
                "        output: bom + text",
                "    };",
                "",
                "};",
                "",
                "module.exports = SourceCodeFixer;"
            ]
        },
        "6": {
            "function_name": "addParentheses (not found) ",
            "file_path": "lib/rules/implicit-arrow-linebreak.js",
            "function_details": [
                {
                    "name": "addParentheses",
                    "start_line": 1,
                    "end_line": 236
                }
            ],
            "function_code": [
                "/**",
                " * @fileoverview enforce the location of arrow function bodies",
                " * @author Sharmila Jesupaul",
                " */",
                "\"use strict\";",
                "",
                "const {",
                "    isArrowToken,",
                "    isParenthesised,",
                "    isOpeningParenToken",
                "} = require(\"../util/ast-utils\");",
                "",
                "//------------------------------------------------------------------------------",
                "// Rule Definition",
                "//------------------------------------------------------------------------------",
                "module.exports = {",
                "    meta: {",
                "        type: \"layout\",",
                "",
                "        docs: {",
                "            description: \"enforce the location of arrow function bodies\",",
                "            category: \"Stylistic Issues\",",
                "            recommended: false,",
                "            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"",
                "        },",
                "",
                "        fixable: \"whitespace\",",
                "",
                "        schema: [",
                "            {",
                "                enum: [\"beside\", \"below\"]",
                "            }",
                "        ],",
                "        messages: {",
                "            expected: \"Expected a linebreak before this expression.\",",
                "            unexpected: \"Expected no linebreak before this expression.\"",
                "        }",
                "    },",
                "",
                "    create(context) {",
                "        const sourceCode = context.getSourceCode();",
                "",
                "        //----------------------------------------------------------------------",
                "        // Helpers",
                "        //----------------------------------------------------------------------",
                "        /**",
                "         * Gets the applicable preference for a particular keyword",
                "         * @returns {string} The applicable option for the keyword, e.g. 'beside'",
                "         */",
                "        function getOption() {",
                "            return context.options[0] || \"beside\";",
                "        }",
                "",
                "        /**",
                "         * Formats the comments depending on whether it's a line or block comment.",
                "         * @param {Comment[]} comments The array of comments between the arrow and body",
                "         * @param {Integer} column The column number of the first token",
                "         * @returns {string} A string of comment text joined by line breaks",
                "         */",
                "        function formatComments(comments, column) {",
                "            const whiteSpaces = \" \".repeat(column);",
                "",
                "            return `${comments.map(comment => {",
                "",
                "                if (comment.type === \"Line\") {",
                "                    return `//${comment.value}`;",
                "                }",
                "",
                "                return `/*${comment.value}*/`;",
                "            }).join(`\\n${whiteSpaces}`)}\\n${whiteSpaces}`;",
                "        }",
                "",
                "        /**",
                "         * Finds the first token to prepend comments to depending on the parent type",
                "         * @param {Node} node The validated node",
                "         * @returns {Token|Node} The node to prepend comments to",
                "         */",
                "        function findFirstToken(node) {",
                "            switch (node.parent.type) {",
                "                case \"VariableDeclarator\":",
                "",
                "                    // If the parent is first or only declarator, return the declaration, else, declarator",
                "                    return sourceCode.getFirstToken(",
                "                        node.parent.parent.declarations.length === 1 ||",
                "                        node.parent.parent.declarations[0].id.name === node.parent.id.name",
                "                            ? node.parent.parent : node.parent",
                "                    );",
                "                case \"CallExpression\":",
                "                case \"Property\":",
                "",
                "                    // find the object key",
                "                    return sourceCode.getFirstToken(node.parent);",
                "                default:",
                "                    return node;",
                "            }",
                "        }",
                "",
                "        /**",
                "         * Helper function for adding parentheses fixes for nodes containing nested arrow functions",
                "         * @param {Fixer} fixer Fixer",
                "         * @param {Token} arrow - The arrow token",
                "         * @param {ASTNode} arrowBody - The arrow function body",
                "         * @returns {Function[]} autofixer -- wraps function bodies with parentheses",
                "         */",
                "        function addParentheses(fixer, arrow, arrowBody) {",
                "            const parenthesesFixes = [];",
                "            let closingParentheses = \"\";",
                "",
                "            let followingBody = arrowBody;",
                "            let currentArrow = arrow;",
                "",
                "            while (currentArrow) {",
                "                if (!isParenthesised(sourceCode, followingBody)) {",
                "                    parenthesesFixes.push(",
                "                        fixer.insertTextAfter(currentArrow, \" (\")",
                "                    );",
                "",
                "                    const paramsToken = sourceCode.getTokenBefore(currentArrow, token =>",
                "                        isOpeningParenToken(token) || token.type === \"Identifier\");",
                "",
                "                    const whiteSpaces = \" \".repeat(paramsToken.loc.start.column);",
                "",
                "                    closingParentheses = `\\n${whiteSpaces})${closingParentheses}`;",
                "                }",
                "",
                "                currentArrow = sourceCode.getTokenAfter(currentArrow, isArrowToken);",
                "",
                "                if (currentArrow) {",
                "                    followingBody = sourceCode.getTokenAfter(currentArrow, token => !isOpeningParenToken(token));",
                "                }",
                "            }",
                "",
                "            return [...parenthesesFixes,",
                "                fixer.insertTextAfter(arrowBody, closingParentheses)",
                "            ];",
                "        }",
                "",
                "        /**",
                "         * Autofixes the function body to collapse onto the same line as the arrow.",
                "         * If comments exist, prepends the comments before the arrow function.",
                "         * If the function body contains arrow functions, appends the function bodies with parentheses.",
                "         * @param {Token} arrowToken The arrow token.",
                "         * @param {ASTNode} arrowBody the function body",
                "         * @param {ASTNode} node The evaluated node",
                "         * @returns {Function} autofixer -- validates the node to adhere to besides",
                "         */",
                "        function autoFixBesides(arrowToken, arrowBody, node) {",
                "            return fixer => {",
                "                const placeBesides = fixer.replaceTextRange([arrowToken.range[1], arrowBody.range[0]], \" \");",
                "",
                "                const comments = sourceCode.getCommentsInside(node).filter(comment =>",
                "                    comment.loc.start.line < arrowBody.loc.start.line);",
                "",
                "                if (comments.length) {",
                "",
                "                    // If the grandparent is not a variable declarator",
                "                    if (",
                "                        arrowBody.parent &&",
                "                        arrowBody.parent.parent &&",
                "                        arrowBody.parent.parent.type !== \"VariableDeclarator\"",
                "                    ) {",
                "",
                "                        // If any arrow functions follow, return the necessary parens fixes.",
                "                        if (sourceCode.getTokenAfter(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                "                            return addParentheses(fixer, arrowToken, arrowBody);",
                "                        }",
                "",
                "                        // If any arrow functions precede, the necessary fixes have already been returned, so return null.",
                "                        if (sourceCode.getTokenBefore(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {",
                "                            return null;",
                "                        }",
                "                    }",
                "",
                "                    const firstToken = findFirstToken(node);",
                "",
                "                    const commentText = formatComments(comments, firstToken.loc.start.column);",
                "",
                "                    const commentBeforeExpression = fixer.insertTextBeforeRange(",
                "                        firstToken.range,",
                "                        commentText",
                "                    );",
                "",
                "                    return [placeBesides, commentBeforeExpression];",
                "                }",
                "",
                "                return placeBesides;",
                "            };",
                "        }",
                "",
                "        /**",
                "         * Validates the location of an arrow function body",
                "         * @param {ASTNode} node The arrow function body",
                "         * @returns {void}",
                "         */",
                "        function validateExpression(node) {",
                "            const option = getOption();",
                "",
                "            let tokenBefore = sourceCode.getTokenBefore(node.body);",
                "            const hasParens = tokenBefore.value === \"(\";",
                "",
                "            if (node.type === \"BlockStatement\") {",
                "                return;",
                "            }",
                "",
                "            let fixerTarget = node.body;",
                "",
                "            if (hasParens) {",
                "",
                "                // Gets the first token before the function body that is not an open paren",
                "                tokenBefore = sourceCode.getTokenBefore(node.body, token => token.value !== \"(\");",
                "                fixerTarget = sourceCode.getTokenAfter(tokenBefore);",
                "            }",
                "",
                "            if (tokenBefore.loc.end.line === fixerTarget.loc.start.line && option === \"below\") {",
                "                context.report({",
                "                    node: fixerTarget,",
                "                    messageId: \"expected\",",
                "                    fix: fixer => fixer.insertTextBefore(fixerTarget, \"\\n\")",
                "                });",
                "            } else if (tokenBefore.loc.end.line !== fixerTarget.loc.start.line && option === \"beside\") {",
                "                context.report({",
                "                    node: fixerTarget,",
                "                    messageId: \"unexpected\",",
                "                    fix: autoFixBesides(tokenBefore, fixerTarget, node)",
                "                });",
                "            }",
                "        }",
                "",
                "        //----------------------------------------------------------------------",
                "        // Public",
                "        //----------------------------------------------------------------------",
                "        return {",
                "            ArrowFunctionExpression: node => validateExpression(node)",
                "        };",
                "    }",
                "};"
            ]
        }
    }
}