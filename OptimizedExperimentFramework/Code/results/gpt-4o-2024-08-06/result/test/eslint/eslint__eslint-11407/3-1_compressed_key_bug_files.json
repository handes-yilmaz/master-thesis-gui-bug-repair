{
    "1": {
        "bug_file": "lib/rules/implicit-arrow-linebreak.js",
        "compressed": "NO",
        "line_numbers": 236,
        "compressed_line_numbers": 236,
        "compressed_bug_file_content": "/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\"use strict\";\n\nconst {\n    isArrowToken,\n    isParenthesised,\n    isOpeningParenToken\n} = require(\"../util/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce the location of arrow function bodies\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"beside\", \"below\"]\n            }\n        ],\n        messages: {\n            expected: \"Expected a linebreak before this expression.\",\n            unexpected: \"Expected no linebreak before this expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Helpers\n        //----------------------------------------------------------------------\n        /**\n         * Gets the applicable preference for a particular keyword\n         * @returns {string} The applicable option for the keyword, e.g. 'beside'\n         */\n        function getOption() {\n            return context.options[0] || \"beside\";\n        }\n\n        /**\n         * Formats the comments depending on whether it's a line or block comment.\n         * @param {Comment[]} comments The array of comments between the arrow and body\n         * @param {Integer} column The column number of the first token\n         * @returns {string} A string of comment text joined by line breaks\n         */\n        function formatComments(comments, column) {\n            const whiteSpaces = \" \".repeat(column);\n\n            return `${comments.map(comment => {\n\n                if (comment.type === \"Line\") {\n                    return `//${comment.value}`;\n                }\n\n                return `/*${comment.value}*/`;\n            }).join(`\\n${whiteSpaces}`)}\\n${whiteSpaces}`;\n        }\n\n        /**\n         * Finds the first token to prepend comments to depending on the parent type\n         * @param {Node} node The validated node\n         * @returns {Token|Node} The node to prepend comments to\n         */\n        function findFirstToken(node) {\n            switch (node.parent.type) {\n                case \"VariableDeclarator\":\n\n                    // If the parent is first or only declarator, return the declaration, else, declarator\n                    return sourceCode.getFirstToken(\n                        node.parent.parent.declarations.length === 1 ||\n                        node.parent.parent.declarations[0].id.name === node.parent.id.name\n                            ? node.parent.parent : node.parent\n                    );\n                case \"CallExpression\":\n                case \"Property\":\n\n                    // find the object key\n                    return sourceCode.getFirstToken(node.parent);\n                default:\n                    return node;\n            }\n        }\n\n        /**\n         * Helper function for adding parentheses fixes for nodes containing nested arrow functions\n         * @param {Fixer} fixer Fixer\n         * @param {Token} arrow - The arrow token\n         * @param {ASTNode} arrowBody - The arrow function body\n         * @returns {Function[]} autofixer -- wraps function bodies with parentheses\n         */\n        function addParentheses(fixer, arrow, arrowBody) {\n            const parenthesesFixes = [];\n            let closingParentheses = \"\";\n\n            let followingBody = arrowBody;\n            let currentArrow = arrow;\n\n            while (currentArrow) {\n                if (!isParenthesised(sourceCode, followingBody)) {\n                    parenthesesFixes.push(\n                        fixer.insertTextAfter(currentArrow, \" (\")\n                    );\n\n                    const paramsToken = sourceCode.getTokenBefore(currentArrow, token =>\n                        isOpeningParenToken(token) || token.type === \"Identifier\");\n\n                    const whiteSpaces = \" \".repeat(paramsToken.loc.start.column);\n\n                    closingParentheses = `\\n${whiteSpaces})${closingParentheses}`;\n                }\n\n                currentArrow = sourceCode.getTokenAfter(currentArrow, isArrowToken);\n\n                if (currentArrow) {\n                    followingBody = sourceCode.getTokenAfter(currentArrow, token => !isOpeningParenToken(token));\n                }\n            }\n\n            return [...parenthesesFixes,\n                fixer.insertTextAfter(arrowBody, closingParentheses)\n            ];\n        }\n\n        /**\n         * Autofixes the function body to collapse onto the same line as the arrow.\n         * If comments exist, prepends the comments before the arrow function.\n         * If the function body contains arrow functions, appends the function bodies with parentheses.\n         * @param {Token} arrowToken The arrow token.\n         * @param {ASTNode} arrowBody the function body\n         * @param {ASTNode} node The evaluated node\n         * @returns {Function} autofixer -- validates the node to adhere to besides\n         */\n        function autoFixBesides(arrowToken, arrowBody, node) {\n            return fixer => {\n                const placeBesides = fixer.replaceTextRange([arrowToken.range[1], arrowBody.range[0]], \" \");\n\n                const comments = sourceCode.getCommentsInside(node).filter(comment =>\n                    comment.loc.start.line < arrowBody.loc.start.line);\n\n                if (comments.length) {\n\n                    // If the grandparent is not a variable declarator\n                    if (\n                        arrowBody.parent &&\n                        arrowBody.parent.parent &&\n                        arrowBody.parent.parent.type !== \"VariableDeclarator\"\n                    ) {\n\n                        // If any arrow functions follow, return the necessary parens fixes.\n                        if (sourceCode.getTokenAfter(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {\n                            return addParentheses(fixer, arrowToken, arrowBody);\n                        }\n\n                        // If any arrow functions precede, the necessary fixes have already been returned, so return null.\n                        if (sourceCode.getTokenBefore(arrowToken, isArrowToken) && arrowBody.parent.parent.type !== \"VariableDeclarator\") {\n                            return null;\n                        }\n                    }\n\n                    const firstToken = findFirstToken(node);\n\n                    const commentText = formatComments(comments, firstToken.loc.start.column);\n\n                    const commentBeforeExpression = fixer.insertTextBeforeRange(\n                        firstToken.range,\n                        commentText\n                    );\n\n                    return [placeBesides, commentBeforeExpression];\n                }\n\n                return placeBesides;\n            };\n        }\n\n        /**\n         * Validates the location of an arrow function body\n         * @param {ASTNode} node The arrow function body\n         * @returns {void}\n         */\n        function validateExpression(node) {\n            const option = getOption();\n\n            let tokenBefore = sourceCode.getTokenBefore(node.body);\n            const hasParens = tokenBefore.value === \"(\";\n\n            if (node.type === \"BlockStatement\") {\n                return;\n            }\n\n            let fixerTarget = node.body;\n\n            if (hasParens) {\n\n                // Gets the first token before the function body that is not an open paren\n                tokenBefore = sourceCode.getTokenBefore(node.body, token => token.value !== \"(\");\n                fixerTarget = sourceCode.getTokenAfter(tokenBefore);\n            }\n\n            if (tokenBefore.loc.end.line === fixerTarget.loc.start.line && option === \"below\") {\n                context.report({\n                    node: fixerTarget,\n                    messageId: \"expected\",\n                    fix: fixer => fixer.insertTextBefore(fixerTarget, \"\\n\")\n                });\n            } else if (tokenBefore.loc.end.line !== fixerTarget.loc.start.line && option === \"beside\") {\n                context.report({\n                    node: fixerTarget,\n                    messageId: \"unexpected\",\n                    fix: autoFixBesides(tokenBefore, fixerTarget, node)\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n        return {\n            ArrowFunctionExpression: node => validateExpression(node)\n        };\n    }\n};"
    },
    "2": {
        "bug_file": "lib/util/source-code-fixer.js",
        "compressed": "NO",
        "line_numbers": 152,
        "compressed_line_numbers": 152,
        "compressed_bug_file_content": "/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {\n    debug(\"Applying fixes\");\n\n    if (shouldFix === false) {\n        debug(\"shouldFix parameter was false, not attempting fixes\");\n        return {\n            fixed: false,\n            messages,\n            output: sourceText\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    /**\n     * Try to use the 'fix' from a problem.\n     * @param   {Message} problem The message object to apply fixes from\n     * @returns {boolean}         Whether fix was successfully applied\n     */\n    function attemptFix(problem) {\n        const fix = problem.fix;\n        const start = fix.range[0];\n        const end = fix.range[1];\n\n        // Remain it as a problem if it's overlapped or it's a negative range\n        if (lastPos >= start || start > end) {\n            remainingMessages.push(problem);\n            return false;\n        }\n\n        // Remove BOM.\n        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n            output = \"\";\n        }\n\n        // Make output to this fix.\n        output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n        output += fix.text;\n        lastPos = end;\n        return true;\n    }\n\n    messages.forEach(problem => {\n        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n        let fixesWereApplied = false;\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n                attemptFix(problem);\n\n                /*\n                 * The only time attemptFix will fail is if a previous fix was\n                 * applied which conflicts with it.  So we can mark this as true.\n                 */\n                fixesWereApplied = true;\n            } else {\n                remainingMessages.push(problem);\n            }\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: fixesWereApplied,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;"
    }
}