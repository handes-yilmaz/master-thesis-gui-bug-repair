{
    "bug_classes": {
        "1": {
            "class_name": "OffsetStorage (not found) 106-606",
            "file_path": "lib/rules/indent.js",
            "class_details": [
                {
                    "name": "OffsetStorage",
                    "start_line": 106,
                    "end_line": 606
                }
            ],
            "class_code": [
                " * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another",
                " *    specified token or to the first column.",
                " * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a",
                " *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly",
                " *    brace of the BlockStatement.",
                " * 3. After traversing the AST, calculate the expected indentation levels of every token according to the",
                " *    OffsetStorage container.",
                " * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,",
                " *    and report the token if the two values are not equal.",
                " */",
                "",
                "/**",
                " * A helper class to get token-based info related to indentation",
                " */",
                "class TokenInfo {",
                "",
                "    /**",
                "     * @param {SourceCode} sourceCode A SourceCode object",
                "     */",
                "    constructor(sourceCode) {",
                "        this.sourceCode = sourceCode;",
                "        this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {",
                "            if (!map.has(token.loc.start.line)) {",
                "                map.set(token.loc.start.line, token);",
                "            }",
                "            if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {",
                "                map.set(token.loc.end.line, token);",
                "            }",
                "            return map;",
                "        }, new Map());",
                "    }",
                "",
                "    /**",
                "     * Gets all tokens and comments",
                "     * @returns {Token[]} A list of all tokens and comments",
                "     */",
                "    getAllTokens() {",
                "        return this.sourceCode.tokensAndComments;",
                "    }",
                "",
                "    /**",
                "    * Gets the first token on a given token's line",
                "    * @param {Token|ASTNode} token a node or token",
                "    * @returns {Token} The first token on the given line",
                "    */",
                "    getFirstTokenOfLine(token) {",
                "        return this.firstTokensByLineNumber.get(token.loc.start.line);",
                "    }",
                "",
                "    /**",
                "    * Determines whether a token is the first token in its line",
                "    * @param {Token} token The token",
                "    * @returns {boolean} `true` if the token is the first on its line",
                "    */",
                "    isFirstTokenOfLine(token) {",
                "        return this.getFirstTokenOfLine(token) === token;",
                "    }",
                "",
                "    /**",
                "     * Get the actual indent of a token",
                "     * @param {Token} token Token to examine. This should be the first token on its line.",
                "     * @returns {string} The indentation characters that precede the token",
                "     */",
                "    getTokenIndent(token) {",
                "        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);",
                "    }",
                "}",
                "",
                "/**",
                " * A class to store information on desired offsets of tokens from each other",
                " */",
                "class OffsetStorage {",
                "",
                "    /**",
                "     * @param {TokenInfo} tokenInfo a TokenInfo instance",
                "     * @param {string} indentType The desired type of indentation (either \"space\" or \"tab\")",
                "     * @param {number} indentSize The desired size of each indentation level",
                "     */",
                "    constructor(tokenInfo, indentType, indentSize) {",
                "        this.tokenInfo = tokenInfo;",
                "        this.indentType = indentType;",
                "        this.indentSize = indentSize;",
                "",
                "        /*",
                "         * desiredOffsets, lockedFirstTokens, and desiredIndentCache conceptually map tokens to something else.",
                "         * However, they're implemented as objects with range indices as keys because this improves performance as of Node 7.",
                "         * This uses the assumption that no two tokens start at the same index in the program.",
                "         *",
                "         * The values of the desiredOffsets map are objects with the schema { offset: number, from: Token|null }.",
                "         * These objects should not be mutated or exposed outside of OffsetStorage.",
                "         */",
                "        const NO_OFFSET = { offset: 0, from: null };",
                "",
                "        this.desiredOffsets = tokenInfo.getAllTokens().reduce((desiredOffsets, token) => {",
                "            desiredOffsets[token.range[0]] = NO_OFFSET;",
                "",
                "            return desiredOffsets;",
                "        }, Object.create(null));",
                "        this.lockedFirstTokens = Object.create(null);",
                "        this.desiredIndentCache = Object.create(null);",
                "        this.ignoredTokens = new WeakSet();",
                "    }",
                "",
                "    /**",
                "    * Sets the indent of one token to match the indent of another.",
                "    * @param {Token} baseToken The first token",
                "    * @param {Token} offsetToken The second token, whose indent should be matched to the first token",
                "    * @returns {void}",
                "    */",
                "    matchIndentOf(baseToken, offsetToken) {",
                "        if (baseToken !== offsetToken) {",
                "            this.desiredOffsets[offsetToken.range[0]] = { offset: 0, from: baseToken };",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Sets the offset column of token B to match the offset column of token A.",
                "     * **WARNING**: This is different from matchIndentOf because it matches a *column*, even if baseToken is not",
                "     * the first token on its line. In most cases, `matchIndentOf` should be used instead.",
                "     * @param {Token} baseToken The first token",
                "     * @param {Token} offsetToken The second token, whose offset should be matched to the first token",
                "     * @returns {void}",
                "     */",
                "    matchOffsetOf(baseToken, offsetToken) {",
                "",
                "        /*",
                "         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to",
                "         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first",
                "         * token of each element in the array after the first will be mapped to the first token of the first",
                "         * element. The desired indentation of each of these tokens is computed based on the desired indentation",
                "         * of the \"first\" element, rather than through the normal offset mechanism.",
                "         */",
                "        this.lockedFirstTokens[offsetToken.range[0]] = baseToken;",
                "    }",
                "",
                "    /**",
                "     * Sets the desired offset of a token.",
                "     *",
                "     * This uses a line-based offset collapsing behavior to handle tokens on the same line.",
                "     * For example, consider the following two cases:",
                "     *",
                "     * (",
                "     *     [",
                "     *         bar",
                "     *     ]",
                "     * )",
                "     *",
                "     * ([",
                "     *     bar",
                "     * ])",
                "     *",
                "     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from",
                "     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is",
                "     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)",
                "     * from the start of its line.",
                "     *",
                "     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level",
                "     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the",
                "     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented",
                "     * by 1 indent level from the start of the line.",
                "     *",
                "     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,",
                "     * without needing to check which lines those tokens are on.",
                "     *",
                "     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive",
                "     * behavior can occur. For example, consider the following cases:",
                "     *",
                "     * foo(",
                "     * ).",
                "     *     bar(",
                "     *         baz",
                "     *     )",
                "     *",
                "     * foo(",
                "     * ).bar(",
                "     *     baz",
                "     * )",
                "     *",
                "     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`",
                "     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`",
                "     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no",
                "     * collapsing would occur).",
                "     *",
                "     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and",
                "     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed",
                "     * in the second case.",
                "     *",
                "     * @param {Token} token The token",
                "     * @param {Token} offsetFrom The token that `token` should be offset from",
                "     * @param {number} offset The desired indent level",
                "     * @returns {void}",
                "     */",
                "    setDesiredOffset(token, offsetFrom, offset) {",
                "        if (offsetFrom && token.loc.start.line === offsetFrom.loc.start.line) {",
                "            this.matchIndentOf(offsetFrom, token);",
                "        } else {",
                "            this.desiredOffsets[token.range[0]] = { offset, from: offsetFrom };",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Sets the desired offset of a token, ignoring the usual collapsing behavior.",
                "     * **WARNING**: This is usually not what you want to use. See `setDesiredOffset` instead.",
                "     * @param {Token} token The token",
                "     * @param {Token} offsetFrom The token that `token` should be offset from",
                "     * @param {number} offset The desired indent level",
                "     * @returns {void}",
                "     */",
                "    forceSetDesiredOffset(token, offsetFrom, offset) {",
                "        this.desiredOffsets[token.range[0]] = { offset, from: offsetFrom };",
                "    }",
                "",
                "    /**",
                "    * Sets the desired offset of multiple tokens",
                "    * @param {Token[]} tokens A list of tokens. These tokens should be consecutive.",
                "    * @param {Token} offsetFrom The token that this is offset from",
                "    * @param {number} offset The desired indent level",
                "    * @returns {void}",
                "    */",
                "    setDesiredOffsets(tokens, offsetFrom, offset) {",
                "",
                "        /*",
                "         * TODO: (not-an-aardvark) This function is the main performance holdup for this rule. It works",
                "         * by setting the desired offset of each token to the given amount relative to the parent, but it's",
                "         * frequently called with a large list of tokens, and it takes time to set the offset for each token",
                "         * individually. Since the tokens are always consecutive, it might be possible to improve performance",
                "         * here by changing the data structure used to store offsets (e.g. allowing a *range* of tokens to",
                "         * be offset rather than offsetting each token individually).",
                "         */",
                "        tokens.forEach(token => this.setDesiredOffset(token, offsetFrom, offset));",
                "    }",
                "",
                "    /**",
                "    * Gets the desired indent of a token",
                "    * @param {Token} token The token",
                "    * @returns {number} The desired indent of the token",
                "    */",
                "    getDesiredIndent(token) {",
                "        if (!(token.range[0] in this.desiredIndentCache)) {",
                "",
                "            if (this.ignoredTokens.has(token)) {",
                "",
                "                // If the token is ignored, use the actual indent of the token as the desired indent.",
                "                // This ensures that no errors are reported for this token.",
                "                this.desiredIndentCache[token.range[0]] = this.tokenInfo.getTokenIndent(token).length / this.indentSize;",
                "            } else if (token.range[0] in this.lockedFirstTokens) {",
                "                const firstToken = this.lockedFirstTokens[token.range[0]];",
                "",
                "                this.desiredIndentCache[token.range[0]] =",
                "",
                "                    // (indentation for the first element's line)",
                "                    this.getDesiredIndent(this.tokenInfo.getFirstTokenOfLine(firstToken)) +",
                "",
                "                        // (space between the start of the first element's line and the first element)",
                "                        (firstToken.loc.start.column - this.tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column) / this.indentSize;",
                "            } else {",
                "                const offsetInfo = this.desiredOffsets[token.range[0]];",
                "",
                "                this.desiredIndentCache[token.range[0]] = offsetInfo.offset + (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : 0);",
                "            }",
                "        }",
                "        return this.desiredIndentCache[token.range[0]];",
                "    }",
                "",
                "    /**",
                "    * Ignores a token, preventing it from being reported.",
                "    * @param {Token} token The token",
                "    * @returns {void}",
                "    */",
                "    ignoreToken(token) {",
                "        if (this.tokenInfo.isFirstTokenOfLine(token)) {",
                "            this.ignoredTokens.add(token);",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Gets the first token that the given token's indentation is dependent on",
                "     * @param {Token} token The token",
                "     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level",
                "     */",
                "    getFirstDependency(token) {",
                "        return this.desiredOffsets[token.range[0]].from;",
                "    }",
                "",
                "    /**",
                "     * Increases the offset for a token from its parent by the given amount",
                "     * @param {Token} token The token whose offset should be increased",
                "     * @param {number} amount The number of indent levels that the offset should increase by",
                "     * @returns {void}",
                "     */",
                "    increaseOffset(token, amount) {",
                "        const currentOffsetInfo = this.desiredOffsets[token.range[0]];",
                "",
                "        this.desiredOffsets[token.range[0]] = { offset: currentOffsetInfo.offset + amount, from: currentOffsetInfo.from };",
                "    }",
                "}",
                "",
                "const ELEMENT_LIST_SCHEMA = {",
                "    oneOf: [",
                "        {",
                "            type: \"integer\",",
                "            minimum: 0",
                "        },",
                "        {",
                "            enum: [\"first\", \"off\"]",
                "        }",
                "    ]",
                "};",
                "",
                "module.exports = {",
                "    meta: {",
                "        docs: {",
                "            description: \"enforce consistent indentation\",",
                "            category: \"Stylistic Issues\",",
                "            recommended: false",
                "        },",
                "",
                "        fixable: \"whitespace\",",
                "",
                "        schema: [",
                "            {",
                "                oneOf: [",
                "                    {",
                "                        enum: [\"tab\"]",
                "                    },",
                "                    {",
                "                        type: \"integer\",",
                "                        minimum: 0",
                "                    }",
                "                ]",
                "            },",
                "            {",
                "                type: \"object\",",
                "                properties: {",
                "                    SwitchCase: {",
                "                        type: \"integer\",",
                "                        minimum: 0",
                "                    },",
                "                    VariableDeclarator: {",
                "                        oneOf: [",
                "                            {",
                "                                type: \"integer\",",
                "                                minimum: 0",
                "                            },",
                "                            {",
                "                                type: \"object\",",
                "                                properties: {",
                "                                    var: {",
                "                                        type: \"integer\",",
                "                                        minimum: 0",
                "                                    },",
                "                                    let: {",
                "                                        type: \"integer\",",
                "                                        minimum: 0",
                "                                    },",
                "                                    const: {",
                "                                        type: \"integer\",",
                "                                        minimum: 0",
                "                                    }",
                "                                },",
                "                                additionalProperties: false",
                "                            }",
                "                        ]",
                "                    },",
                "                    outerIIFEBody: {",
                "                        type: \"integer\",",
                "                        minimum: 0",
                "                    },",
                "                    MemberExpression: {",
                "                        oneOf: [",
                "                            {",
                "                                type: \"integer\",",
                "                                minimum: 0",
                "                            },",
                "                            {",
                "                                enum: [\"off\"]",
                "                            }",
                "                        ]",
                "                    },",
                "                    FunctionDeclaration: {",
                "                        type: \"object\",",
                "                        properties: {",
                "                            parameters: ELEMENT_LIST_SCHEMA,",
                "                            body: {",
                "                                type: \"integer\",",
                "                                minimum: 0",
                "                            }",
                "                        },",
                "                        additionalProperties: false",
                "                    },",
                "                    FunctionExpression: {",
                "                        type: \"object\",",
                "                        properties: {",
                "                            parameters: ELEMENT_LIST_SCHEMA,",
                "                            body: {",
                "                                type: \"integer\",",
                "                                minimum: 0",
                "                            }",
                "                        },",
                "                        additionalProperties: false",
                "                    },",
                "                    CallExpression: {",
                "                        type: \"object\",",
                "                        properties: {",
                "                            arguments: ELEMENT_LIST_SCHEMA",
                "                        },",
                "                        additionalProperties: false",
                "                    },",
                "                    ArrayExpression: ELEMENT_LIST_SCHEMA,",
                "                    ObjectExpression: ELEMENT_LIST_SCHEMA,",
                "                    flatTernaryExpressions: {",
                "                        type: \"boolean\"",
                "                    }",
                "                },",
                "                additionalProperties: false",
                "            }",
                "        ]",
                "    },",
                "",
                "    create(context) {",
                "        const DEFAULT_VARIABLE_INDENT = 1;",
                "        const DEFAULT_PARAMETER_INDENT = 1;",
                "        const DEFAULT_FUNCTION_BODY_INDENT = 1;",
                "",
                "        let indentType = \"space\";",
                "        let indentSize = 4;",
                "        const options = {",
                "            SwitchCase: 0,",
                "            VariableDeclarator: {",
                "                var: DEFAULT_VARIABLE_INDENT,",
                "                let: DEFAULT_VARIABLE_INDENT,",
                "                const: DEFAULT_VARIABLE_INDENT",
                "            },",
                "            outerIIFEBody: 1,",
                "            FunctionDeclaration: {",
                "                parameters: DEFAULT_PARAMETER_INDENT,",
                "                body: DEFAULT_FUNCTION_BODY_INDENT",
                "            },",
                "            FunctionExpression: {",
                "                parameters: DEFAULT_PARAMETER_INDENT,",
                "                body: DEFAULT_FUNCTION_BODY_INDENT",
                "            },",
                "            CallExpression: {",
                "                arguments: DEFAULT_PARAMETER_INDENT",
                "            },",
                "            MemberExpression: 1,",
                "            ArrayExpression: 1,",
                "            ObjectExpression: 1,",
                "            ArrayPattern: 1,",
                "            ObjectPattern: 1,",
                "            flatTernaryExpressions: false",
                "        };",
                "",
                "        if (context.options.length) {",
                "            if (context.options[0] === \"tab\") {",
                "                indentSize = 1;",
                "                indentType = \"tab\";",
                "            } else if (typeof context.options[0] === \"number\") {",
                "                indentSize = context.options[0];",
                "                indentType = \"space\";",
                "            }",
                "",
                "            if (context.options[1]) {",
                "                lodash.merge(options, context.options[1]);",
                "",
                "                if (typeof options.VariableDeclarator === \"number\") {",
                "                    options.VariableDeclarator = {",
                "                        var: options.VariableDeclarator,",
                "                        let: options.VariableDeclarator,",
                "                        const: options.VariableDeclarator",
                "                    };",
                "                }",
                "            }",
                "        }",
                "",
                "        const sourceCode = context.getSourceCode();",
                "        const tokenInfo = new TokenInfo(sourceCode);",
                "        const offsets = new OffsetStorage(tokenInfo, indentType, indentSize);",
                "        const parameterParens = new WeakSet();",
                "",
                "        /**",
                "         * Creates an error message for a line, given the expected/actual indentation.",
                "         * @param {int} expectedAmount The expected amount of indentation characters for this line",
                "         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line",
                "         * @param {int} actualTabs The actual number of indentation tabs that were found on this line",
                "         * @returns {string} An error message for this line",
                "         */",
                "        function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {",
                "            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"",
                "            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"",
                "            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"",
                "            let foundStatement;",
                "",
                "            if (actualSpaces > 0) {",
                "",
                "                // Abbreviate the message if the expected indentation is also spaces.",
                "                // e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'",
                "                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;",
                "            } else if (actualTabs > 0) {",
                "                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;",
                "            } else {"
            ]
        },
        "2": {
            "class_name": "  (not found) 2-502",
            "file_path": "lib/rules/indent.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 2,
                    "end_line": 502
                }
            ],
            "class_code": [
                " * @fileoverview This option sets a specific tab width for your code",
                " *",
                " * This rule has been ported and modified from nodeca.",
                " * @author Vitaly Puzrin",
                " * @author Gyandeep Singh",
                " */",
                "",
                "\"use strict\";",
                "",
                "//------------------------------------------------------------------------------",
                "// Requirements",
                "//------------------------------------------------------------------------------",
                "",
                "const lodash = require(\"lodash\");",
                "const astUtils = require(\"../ast-utils\");",
                "",
                "//------------------------------------------------------------------------------",
                "// Rule Definition",
                "//------------------------------------------------------------------------------",
                "",
                "const KNOWN_NODES = new Set([",
                "    \"AssignmentExpression\",",
                "    \"AssignmentPattern\",",
                "    \"ArrayExpression\",",
                "    \"ArrayPattern\",",
                "    \"ArrowFunctionExpression\",",
                "    \"AwaitExpression\",",
                "    \"BlockStatement\",",
                "    \"BinaryExpression\",",
                "    \"BreakStatement\",",
                "    \"CallExpression\",",
                "    \"CatchClause\",",
                "    \"ClassBody\",",
                "    \"ClassDeclaration\",",
                "    \"ClassExpression\",",
                "    \"ConditionalExpression\",",
                "    \"ContinueStatement\",",
                "    \"DoWhileStatement\",",
                "    \"DebuggerStatement\",",
                "    \"EmptyStatement\",",
                "    \"ExperimentalRestProperty\",",
                "    \"ExperimentalSpreadProperty\",",
                "    \"ExpressionStatement\",",
                "    \"ForStatement\",",
                "    \"ForInStatement\",",
                "    \"ForOfStatement\",",
                "    \"FunctionDeclaration\",",
                "    \"FunctionExpression\",",
                "    \"Identifier\",",
                "    \"IfStatement\",",
                "    \"Literal\",",
                "    \"LabeledStatement\",",
                "    \"LogicalExpression\",",
                "    \"MemberExpression\",",
                "    \"MetaProperty\",",
                "    \"MethodDefinition\",",
                "    \"NewExpression\",",
                "    \"ObjectExpression\",",
                "    \"ObjectPattern\",",
                "    \"Program\",",
                "    \"Property\",",
                "    \"RestElement\",",
                "    \"ReturnStatement\",",
                "    \"SequenceExpression\",",
                "    \"SpreadElement\",",
                "    \"Super\",",
                "    \"SwitchCase\",",
                "    \"SwitchStatement\",",
                "    \"TaggedTemplateExpression\",",
                "    \"TemplateElement\",",
                "    \"TemplateLiteral\",",
                "    \"ThisExpression\",",
                "    \"ThrowStatement\",",
                "    \"TryStatement\",",
                "    \"UnaryExpression\",",
                "    \"UpdateExpression\",",
                "    \"VariableDeclaration\",",
                "    \"VariableDeclarator\",",
                "    \"WhileStatement\",",
                "    \"WithStatement\",",
                "    \"YieldExpression\",",
                "    \"JSXIdentifier\",",
                "    \"JSXNamespacedName\",",
                "    \"JSXMemberExpression\",",
                "    \"JSXEmptyExpression\",",
                "    \"JSXExpressionContainer\",",
                "    \"JSXElement\",",
                "    \"JSXClosingElement\",",
                "    \"JSXOpeningElement\",",
                "    \"JSXAttribute\",",
                "    \"JSXSpreadAttribute\",",
                "    \"JSXText\",",
                "    \"ExportDefaultDeclaration\",",
                "    \"ExportNamedDeclaration\",",
                "    \"ExportAllDeclaration\",",
                "    \"ExportSpecifier\",",
                "    \"ImportDeclaration\",",
                "    \"ImportSpecifier\",",
                "    \"ImportDefaultSpecifier\",",
                "    \"ImportNamespaceSpecifier\"",
                "]);",
                "",
                "/*",
                " * General rule strategy:",
                " * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another",
                " *    specified token or to the first column.",
                " * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a",
                " *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly",
                " *    brace of the BlockStatement.",
                " * 3. After traversing the AST, calculate the expected indentation levels of every token according to the",
                " *    OffsetStorage container.",
                " * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,",
                " *    and report the token if the two values are not equal.",
                " */",
                "",
                "/**",
                " * A helper class to get token-based info related to indentation",
                " */",
                "class TokenInfo {",
                "",
                "    /**",
                "     * @param {SourceCode} sourceCode A SourceCode object",
                "     */",
                "    constructor(sourceCode) {",
                "        this.sourceCode = sourceCode;",
                "        this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {",
                "            if (!map.has(token.loc.start.line)) {",
                "                map.set(token.loc.start.line, token);",
                "            }",
                "            if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {",
                "                map.set(token.loc.end.line, token);",
                "            }",
                "            return map;",
                "        }, new Map());",
                "    }",
                "",
                "    /**",
                "     * Gets all tokens and comments",
                "     * @returns {Token[]} A list of all tokens and comments",
                "     */",
                "    getAllTokens() {",
                "        return this.sourceCode.tokensAndComments;",
                "    }",
                "",
                "    /**",
                "    * Gets the first token on a given token's line",
                "    * @param {Token|ASTNode} token a node or token",
                "    * @returns {Token} The first token on the given line",
                "    */",
                "    getFirstTokenOfLine(token) {",
                "        return this.firstTokensByLineNumber.get(token.loc.start.line);",
                "    }",
                "",
                "    /**",
                "    * Determines whether a token is the first token in its line",
                "    * @param {Token} token The token",
                "    * @returns {boolean} `true` if the token is the first on its line",
                "    */",
                "    isFirstTokenOfLine(token) {",
                "        return this.getFirstTokenOfLine(token) === token;",
                "    }",
                "",
                "    /**",
                "     * Get the actual indent of a token",
                "     * @param {Token} token Token to examine. This should be the first token on its line.",
                "     * @returns {string} The indentation characters that precede the token",
                "     */",
                "    getTokenIndent(token) {",
                "        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);",
                "    }",
                "}",
                "",
                "/**",
                " * A class to store information on desired offsets of tokens from each other",
                " */",
                "class OffsetStorage {",
                "",
                "    /**",
                "     * @param {TokenInfo} tokenInfo a TokenInfo instance",
                "     * @param {string} indentType The desired type of indentation (either \"space\" or \"tab\")",
                "     * @param {number} indentSize The desired size of each indentation level",
                "     */",
                "    constructor(tokenInfo, indentType, indentSize) {",
                "        this.tokenInfo = tokenInfo;",
                "        this.indentType = indentType;",
                "        this.indentSize = indentSize;",
                "",
                "        /*",
                "         * desiredOffsets, lockedFirstTokens, and desiredIndentCache conceptually map tokens to something else.",
                "         * However, they're implemented as objects with range indices as keys because this improves performance as of Node 7.",
                "         * This uses the assumption that no two tokens start at the same index in the program.",
                "         *",
                "         * The values of the desiredOffsets map are objects with the schema { offset: number, from: Token|null }.",
                "         * These objects should not be mutated or exposed outside of OffsetStorage.",
                "         */",
                "        const NO_OFFSET = { offset: 0, from: null };",
                "",
                "        this.desiredOffsets = tokenInfo.getAllTokens().reduce((desiredOffsets, token) => {",
                "            desiredOffsets[token.range[0]] = NO_OFFSET;",
                "",
                "            return desiredOffsets;",
                "        }, Object.create(null));",
                "        this.lockedFirstTokens = Object.create(null);",
                "        this.desiredIndentCache = Object.create(null);",
                "        this.ignoredTokens = new WeakSet();",
                "    }",
                "",
                "    /**",
                "    * Sets the indent of one token to match the indent of another.",
                "    * @param {Token} baseToken The first token",
                "    * @param {Token} offsetToken The second token, whose indent should be matched to the first token",
                "    * @returns {void}",
                "    */",
                "    matchIndentOf(baseToken, offsetToken) {",
                "        if (baseToken !== offsetToken) {",
                "            this.desiredOffsets[offsetToken.range[0]] = { offset: 0, from: baseToken };",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Sets the offset column of token B to match the offset column of token A.",
                "     * **WARNING**: This is different from matchIndentOf because it matches a *column*, even if baseToken is not",
                "     * the first token on its line. In most cases, `matchIndentOf` should be used instead.",
                "     * @param {Token} baseToken The first token",
                "     * @param {Token} offsetToken The second token, whose offset should be matched to the first token",
                "     * @returns {void}",
                "     */",
                "    matchOffsetOf(baseToken, offsetToken) {",
                "",
                "        /*",
                "         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to",
                "         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first",
                "         * token of each element in the array after the first will be mapped to the first token of the first",
                "         * element. The desired indentation of each of these tokens is computed based on the desired indentation",
                "         * of the \"first\" element, rather than through the normal offset mechanism.",
                "         */",
                "        this.lockedFirstTokens[offsetToken.range[0]] = baseToken;",
                "    }",
                "",
                "    /**",
                "     * Sets the desired offset of a token.",
                "     *",
                "     * This uses a line-based offset collapsing behavior to handle tokens on the same line.",
                "     * For example, consider the following two cases:",
                "     *",
                "     * (",
                "     *     [",
                "     *         bar",
                "     *     ]",
                "     * )",
                "     *",
                "     * ([",
                "     *     bar",
                "     * ])",
                "     *",
                "     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from",
                "     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is",
                "     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)",
                "     * from the start of its line.",
                "     *",
                "     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level",
                "     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the",
                "     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented",
                "     * by 1 indent level from the start of the line.",
                "     *",
                "     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,",
                "     * without needing to check which lines those tokens are on.",
                "     *",
                "     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive",
                "     * behavior can occur. For example, consider the following cases:",
                "     *",
                "     * foo(",
                "     * ).",
                "     *     bar(",
                "     *         baz",
                "     *     )",
                "     *",
                "     * foo(",
                "     * ).bar(",
                "     *     baz",
                "     * )",
                "     *",
                "     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`",
                "     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`",
                "     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no",
                "     * collapsing would occur).",
                "     *",
                "     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and",
                "     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed",
                "     * in the second case.",
                "     *",
                "     * @param {Token} token The token",
                "     * @param {Token} offsetFrom The token that `token` should be offset from",
                "     * @param {number} offset The desired indent level",
                "     * @returns {void}",
                "     */",
                "    setDesiredOffset(token, offsetFrom, offset) {",
                "        if (offsetFrom && token.loc.start.line === offsetFrom.loc.start.line) {",
                "            this.matchIndentOf(offsetFrom, token);",
                "        } else {",
                "            this.desiredOffsets[token.range[0]] = { offset, from: offsetFrom };",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Sets the desired offset of a token, ignoring the usual collapsing behavior.",
                "     * **WARNING**: This is usually not what you want to use. See `setDesiredOffset` instead.",
                "     * @param {Token} token The token",
                "     * @param {Token} offsetFrom The token that `token` should be offset from",
                "     * @param {number} offset The desired indent level",
                "     * @returns {void}",
                "     */",
                "    forceSetDesiredOffset(token, offsetFrom, offset) {",
                "        this.desiredOffsets[token.range[0]] = { offset, from: offsetFrom };",
                "    }",
                "",
                "    /**",
                "    * Sets the desired offset of multiple tokens",
                "    * @param {Token[]} tokens A list of tokens. These tokens should be consecutive.",
                "    * @param {Token} offsetFrom The token that this is offset from",
                "    * @param {number} offset The desired indent level",
                "    * @returns {void}",
                "    */",
                "    setDesiredOffsets(tokens, offsetFrom, offset) {",
                "",
                "        /*",
                "         * TODO: (not-an-aardvark) This function is the main performance holdup for this rule. It works",
                "         * by setting the desired offset of each token to the given amount relative to the parent, but it's",
                "         * frequently called with a large list of tokens, and it takes time to set the offset for each token",
                "         * individually. Since the tokens are always consecutive, it might be possible to improve performance",
                "         * here by changing the data structure used to store offsets (e.g. allowing a *range* of tokens to",
                "         * be offset rather than offsetting each token individually).",
                "         */",
                "        tokens.forEach(token => this.setDesiredOffset(token, offsetFrom, offset));",
                "    }",
                "",
                "    /**",
                "    * Gets the desired indent of a token",
                "    * @param {Token} token The token",
                "    * @returns {number} The desired indent of the token",
                "    */",
                "    getDesiredIndent(token) {",
                "        if (!(token.range[0] in this.desiredIndentCache)) {",
                "",
                "            if (this.ignoredTokens.has(token)) {",
                "",
                "                // If the token is ignored, use the actual indent of the token as the desired indent.",
                "                // This ensures that no errors are reported for this token.",
                "                this.desiredIndentCache[token.range[0]] = this.tokenInfo.getTokenIndent(token).length / this.indentSize;",
                "            } else if (token.range[0] in this.lockedFirstTokens) {",
                "                const firstToken = this.lockedFirstTokens[token.range[0]];",
                "",
                "                this.desiredIndentCache[token.range[0]] =",
                "",
                "                    // (indentation for the first element's line)",
                "                    this.getDesiredIndent(this.tokenInfo.getFirstTokenOfLine(firstToken)) +",
                "",
                "                        // (space between the start of the first element's line and the first element)",
                "                        (firstToken.loc.start.column - this.tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column) / this.indentSize;",
                "            } else {",
                "                const offsetInfo = this.desiredOffsets[token.range[0]];",
                "",
                "                this.desiredIndentCache[token.range[0]] = offsetInfo.offset + (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : 0);",
                "            }",
                "        }",
                "        return this.desiredIndentCache[token.range[0]];",
                "    }",
                "",
                "    /**",
                "    * Ignores a token, preventing it from being reported.",
                "    * @param {Token} token The token",
                "    * @returns {void}",
                "    */",
                "    ignoreToken(token) {",
                "        if (this.tokenInfo.isFirstTokenOfLine(token)) {",
                "            this.ignoredTokens.add(token);",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Gets the first token that the given token's indentation is dependent on",
                "     * @param {Token} token The token",
                "     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level",
                "     */",
                "    getFirstDependency(token) {",
                "        return this.desiredOffsets[token.range[0]].from;",
                "    }",
                "",
                "    /**",
                "     * Increases the offset for a token from its parent by the given amount",
                "     * @param {Token} token The token whose offset should be increased",
                "     * @param {number} amount The number of indent levels that the offset should increase by",
                "     * @returns {void}",
                "     */",
                "    increaseOffset(token, amount) {",
                "        const currentOffsetInfo = this.desiredOffsets[token.range[0]];",
                "",
                "        this.desiredOffsets[token.range[0]] = { offset: currentOffsetInfo.offset + amount, from: currentOffsetInfo.from };",
                "    }",
                "}",
                "",
                "const ELEMENT_LIST_SCHEMA = {",
                "    oneOf: [",
                "        {",
                "            type: \"integer\",",
                "            minimum: 0",
                "        },",
                "        {",
                "            enum: [\"first\", \"off\"]",
                "        }",
                "    ]",
                "};",
                "",
                "module.exports = {",
                "    meta: {",
                "        docs: {",
                "            description: \"enforce consistent indentation\",",
                "            category: \"Stylistic Issues\",",
                "            recommended: false",
                "        },",
                "",
                "        fixable: \"whitespace\",",
                "",
                "        schema: [",
                "            {",
                "                oneOf: [",
                "                    {",
                "                        enum: [\"tab\"]",
                "                    },",
                "                    {",
                "                        type: \"integer\",",
                "                        minimum: 0",
                "                    }",
                "                ]",
                "            },",
                "            {",
                "                type: \"object\",",
                "                properties: {",
                "                    SwitchCase: {",
                "                        type: \"integer\",",
                "                        minimum: 0",
                "                    },",
                "                    VariableDeclarator: {",
                "                        oneOf: [",
                "                            {",
                "                                type: \"integer\",",
                "                                minimum: 0",
                "                            },",
                "                            {",
                "                                type: \"object\",",
                "                                properties: {",
                "                                    var: {",
                "                                        type: \"integer\",",
                "                                        minimum: 0",
                "                                    },",
                "                                    let: {",
                "                                        type: \"integer\",",
                "                                        minimum: 0",
                "                                    },",
                "                                    const: {",
                "                                        type: \"integer\",",
                "                                        minimum: 0",
                "                                    }",
                "                                },",
                "                                additionalProperties: false",
                "                            }",
                "                        ]",
                "                    },",
                "                    outerIIFEBody: {",
                "                        type: \"integer\",",
                "                        minimum: 0",
                "                    },",
                "                    MemberExpression: {",
                "                        oneOf: [",
                "                            {",
                "                                type: \"integer\",",
                "                                minimum: 0",
                "                            },",
                "                            {",
                "                                enum: [\"off\"]",
                "                            }",
                "                        ]",
                "                    },",
                "                    FunctionDeclaration: {",
                "                        type: \"object\",",
                "                        properties: {",
                "                            parameters: ELEMENT_LIST_SCHEMA,",
                "                            body: {",
                "                                type: \"integer\",",
                "                                minimum: 0",
                "                            }",
                "                        },",
                "                        additionalProperties: false",
                "                    },",
                "                    FunctionExpression: {",
                "                        type: \"object\",",
                "                        properties: {",
                "                            parameters: ELEMENT_LIST_SCHEMA,",
                "                            body: {",
                "                                type: \"integer\",",
                "                                minimum: 0"
            ]
        }
    },
    "bug_functions": {}
}