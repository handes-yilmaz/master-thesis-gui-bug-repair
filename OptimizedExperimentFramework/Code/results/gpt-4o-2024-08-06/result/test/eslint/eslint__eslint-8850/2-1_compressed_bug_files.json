{
    "1": {
        "bug_file": "lib/rules/indent.js",
        "compressed": "YES",
        "line_numbers": 1443,
        "compressed_line_numbers": 550,
        "compressed_bug_file_content": "/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\n/*\n * General rule strategy:\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\n *    specified token or to the first column.\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\n *    brace of the BlockStatement.\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\n *    OffsetStorage container.\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\n *    and report the token if the two values are not equal.\n */\n\n/**\n * A helper class to get token-based info related to indentation\n */\n\n\n    /**\n     * @param {SourceCode} sourceCode A SourceCode object\n     */\n\n\n    /**\n     * Gets all tokens and comments\n     * @returns {Token[]} A list of all tokens and comments\n     */\n\n\n    /**\n    * Gets the first token on a given token's line\n    * @param {Token|ASTNode} token a node or token\n    * @returns {Token} The first token on the given line\n    */\n\n\n    /**\n    * Determines whether a token is the first token in its line\n    * @param {Token} token The token\n    * @returns {boolean} `true` if the token is the first on its line\n    */\n\n\n    /**\n     * Get the actual indent of a token\n     * @param {Token} token Token to examine. This should be the first token on its line.\n     * @returns {string} The indentation characters that precede the token\n     */\n\n\n/**\n * A class to store information on desired offsets of tokens from each other\n */\n\n\n    /**\n     * @param {TokenInfo} tokenInfo a TokenInfo instance\n     * @param {string} indentType The desired type of indentation (either \"space\" or \"tab\")\n     * @param {number} indentSize The desired size of each indentation level\n     */\n\n\n        /*\n         * desiredOffsets, lockedFirstTokens, and desiredIndentCache conceptually map tokens to something else.\n         * However, they're implemented as objects with range indices as keys because this improves performance as of Node 7.\n         * This uses the assumption that no two tokens start at the same index in the program.\n         *\n         * The values of the desiredOffsets map are objects with the schema { offset: number, from: Token|null }.\n         * These objects should not be mutated or exposed outside of OffsetStorage.\n         */\n\n\n    /**\n    * Sets the indent of one token to match the indent of another.\n    * @param {Token} baseToken The first token\n    * @param {Token} offsetToken The second token, whose indent should be matched to the first token\n    * @returns {void}\n    */\n\n\n    /**\n     * Sets the offset column of token B to match the offset column of token A.\n     * **WARNING**: This is different from matchIndentOf because it matches a *column*, even if baseToken is not\n     * the first token on its line. In most cases, `matchIndentOf` should be used instead.\n     * @param {Token} baseToken The first token\n     * @param {Token} offsetToken The second token, whose offset should be matched to the first token\n     * @returns {void}\n     */\n\n\n        /*\n         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\n         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\n         * token of each element in the array after the first will be mapped to the first token of the first\n         * element. The desired indentation of each of these tokens is computed based on the desired indentation\n         * of the \"first\" element, rather than through the normal offset mechanism.\n         */\n\n\n    /**\n     * Sets the desired offset of a token.\n     *\n     * This uses a line-based offset collapsing behavior to handle tokens on the same line.\n     * For example, consider the following two cases:\n     *\n     * (\n     *     [\n     *         bar\n     *     ]\n     * )\n     *\n     * ([\n     *     bar\n     * ])\n     *\n     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\n     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\n     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\n     * from the start of its line.\n     *\n     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\n     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\n     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\n     * by 1 indent level from the start of the line.\n     *\n     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\n     * without needing to check which lines those tokens are on.\n     *\n     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\n     * behavior can occur. For example, consider the following cases:\n     *\n     * foo(\n     * ).\n     *     bar(\n     *         baz\n     *     )\n     *\n     * foo(\n     * ).bar(\n     *     baz\n     * )\n     *\n     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\n     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\n     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\n     * collapsing would occur).\n     *\n     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\n     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\n     * in the second case.\n     *\n     * @param {Token} token The token\n     * @param {Token} offsetFrom The token that `token` should be offset from\n     * @param {number} offset The desired indent level\n     * @returns {void}\n     */\n\n\n    /**\n     * Sets the desired offset of a token, ignoring the usual collapsing behavior.\n     * **WARNING**: This is usually not what you want to use. See `setDesiredOffset` instead.\n     * @param {Token} token The token\n     * @param {Token} offsetFrom The token that `token` should be offset from\n     * @param {number} offset The desired indent level\n     * @returns {void}\n     */\n\n\n    /**\n    * Sets the desired offset of multiple tokens\n    * @param {Token[]} tokens A list of tokens. These tokens should be consecutive.\n    * @param {Token} offsetFrom The token that this is offset from\n    * @param {number} offset The desired indent level\n    * @returns {void}\n    */\n\n\n        /*\n         * TODO: (not-an-aardvark) This function is the main performance holdup for this rule. It works\n         * by setting the desired offset of each token to the given amount relative to the parent, but it's\n         * frequently called with a large list of tokens, and it takes time to set the offset for each token\n         * individually. Since the tokens are always consecutive, it might be possible to improve performance\n         * here by changing the data structure used to store offsets (e.g. allowing a *range* of tokens to\n         * be offset rather than offsetting each token individually).\n         */\n\n\n    /**\n    * Gets the desired indent of a token\n    * @param {Token} token The token\n    * @returns {number} The desired indent of the token\n    */\n\n\n                // If the token is ignored, use the actual indent of the token as the desired indent.\n                // This ensures that no errors are reported for this token.\n\n\n                    // (indentation for the first element's line)\n\n\n                        // (space between the start of the first element's line and the first element)\n\n\n    /**\n    * Ignores a token, preventing it from being reported.\n    * @param {Token} token The token\n    * @returns {void}\n    */\n\n\n    /**\n     * Gets the first token that the given token's indentation is dependent on\n     * @param {Token} token The token\n     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\n     */\n\n\n    /**\n     * Increases the offset for a token from its parent by the given amount\n     * @param {Token} token The token whose offset should be increased\n     * @param {number} amount The number of indent levels that the offset should increase by\n     * @returns {void}\n     */\n\n\n        /**\n         * Creates an error message for a line, given the expected/actual indentation.\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\n         * @returns {string} An error message for this line\n         */\n\n\n                // Abbreviate the message if the expected indentation is also spaces.\n                // e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\n\n\n        /**\n         * Reports a given indent violation\n         * @param {Token} token Node violating the indent rule\n         * @param {int} neededIndentLevel Expected indentation level\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\n         * @returns {void}\n         */\n\n\n        /**\n         * Checks if a token's indentation is correct\n         * @param {Token} token Token to examine\n         * @param {int} desiredIndentLevel needed indent level\n         * @returns {boolean} `true` if the token's indentation is correct\n         */\n\n\n                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\n\n\n        /**\n         * Check to see if the node is a file level IIFE\n         * @param {ASTNode} node The function node to check.\n         * @returns {boolean} True if the node is the outer IIFE\n         */\n\n\n            /*\n             * Verify that the node is an IIFE\n             */\n\n\n            /*\n             * Navigate legal ancestors to determine whether this IIFE is outer.\n             * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\n             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\n             */\n\n\n        /**\n        * Gets all tokens and comments for a node\n        * @param {ASTNode} node The node\n        * @returns {Token[]} A list of tokens and comments\n        */\n\n\n        /**\n        * Check indentation for lists of elements (arrays, objects, function params)\n        * @param {ASTNode[]} elements List of elements that should be offset\n        * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\n        * @param {Token} endToken The end token of the list, e.g. ']'\n        * @param {number|string} offset The amount that the elements should be offset\n        * @returns {void}\n        */\n\n\n            /**\n            * Gets the first token of a given element, including surrounding parentheses.\n            * @param {ASTNode} element A node in the `elements` list\n            * @returns {Token} The first token of this element\n            */\n\n\n            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\n            // FIXME: (not-an-aardvark) This isn't performant at all.\n\n\n            // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\n\n\n        /**\n         * Check indentation for blocks and class bodies\n         * @param {ASTNode} node The BlockStatement or ClassBody node to indent\n         * @returns {void}\n         */\n\n\n            /*\n             * For blocks that aren't lone statements, ensure that the opening curly brace\n             * is aligned with the parent.\n             */\n\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n\n\n                /*\n                 * For blockless nodes with semicolon-first style, don't indent the semicolon.\n                 * e.g.\n                 * if (foo) bar()\n                 * ; [1, 2, 3].map(foo)\n                 */\n\n\n        /**\n        * Checks the indentation of a function's parameters\n        * @param {ASTNode} node The node\n        * @param {number} paramsIndent The indentation level option for the parameters\n        * @returns {void}\n        */\n\n\n                // If there is no opening paren (e.g. for an arrow function with a single parameter), don't indent anything.\n\n\n        /**\n        * Adds indentation for the right-hand side of binary/logical expressions.\n        * @param {ASTNode} node A BinaryExpression or LogicalExpression node\n        * @returns {void}\n        */\n\n\n            /*\n             * For backwards compatibility, don't check BinaryExpression indents, e.g.\n             * var foo = bar &&\n             *                   baz;\n             */\n\n\n        /**\n        * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\n        * @param {ASTNode} node A CallExpression or NewExpression node\n        * @returns {void}\n        */\n\n\n        /**\n        * Checks the indentation of ClassDeclarations and ClassExpressions\n        * @param {ASTNode} node A ClassDeclaration or ClassExpression node\n        * @returns {void}\n        */\n\n\n        /**\n        * Checks the indentation of parenthesized values, given a list of tokens in a program\n        * @param {Token[]} tokens A list of tokens\n        * @returns {void}\n        */\n\n\n                // Accumulate a list of parenthesis pairs\n\n\n                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\n\n\n        /**\n        * Ignore all tokens within an unknown node whose offset do not depend\n        * on another token's offset within the unknown node\n        * @param {ASTNode} node Unknown Node\n        * @returns {void}\n        */\n\n\n        /**\n        * Ignore node if it is unknown\n        * @param {ASTNode} node Node\n        * @returns {void}\n        */\n\n\n        /**\n         * Check whether the given token is the first token of a statement.\n         * @param {Token} token The token to check.\n         * @param {ASTNode} leafNode The expression node that the token belongs directly.\n         * @returns {boolean} `true` if the token is the first token of a statement.\n         */\n\n\n                // `flatTernaryExpressions` option is for the following style:\n                // var a =\n                //     foo > 0 ? bar :\n                //     foo < 0 ? baz :\n                //     /*else*/ qiz ;\n\n\n                    /*\n                     * The alternate and the consequent should usually have the same indentation.\n                     * If they share part of a line, align the alternate against the first token of the consequent.\n                     * This allows the alternate to be indented correctly in cases like this:\n                     * foo ? (\n                     *   bar\n                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\n                     *   baz // as a result, `baz` is offset by 1 rather than 2\n                     * )\n                     */\n\n\n                        /**\n                         * If the alternate and consequent do not share part of a line, offset the alternate from the first\n                         * token of the conditional expression. For example:\n                         * foo ? bar\n                         *   : baz\n                         *\n                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\n                         * having no expected indentation.\n                         */\n\n\n                    // Indent the specifiers in `export {foo, bar, baz}`\n\n\n                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\n\n\n                    // For computed MemberExpressions, match the closing bracket with the opening bracket.\n\n\n                /*\n                 * If the object ends on the same line that the property starts, match against the last token\n                 * of the object, to ensure that the MemberExpression is not indented.\n                 *\n                 * Otherwise, match against the first token of the object, e.g.\n                 * foo\n                 *   .bar\n                 *   .baz // <-- offset by 1 from `foo`\n                 */\n\n\n                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\n\n\n                    /*\n                     * For computed MemberExpressions, match the first token of the property against the opening bracket.\n                     * Otherwise, match the first token of the property against the object.\n                     */\n\n\n                    // If the MemberExpression option is off, ignore the dot and the first token of the property.\n\n\n                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\n\n\n                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\n\n\n                    /*\n                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\n                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\n                     * the following indentations are correct:\n                     *\n                     * var foo = {\n                     *   ok: true\n                     * };\n                     *\n                     * var foo = {\n                     *     ok: true,\n                     *   },\n                     *   bar = 1;\n                     *\n                     * Account for when exiting the AST (after indentations have already been set for the nodes in\n                     * the declaration) by manually increasing the indentation level of the tokens in this declarator\n                     * on the same line as the start of the declaration, provided that there are declarators that\n                     * follow this one.\n                     */\n\n\n                /*\n                 * Create a Map from (tokenOrComment) => (precedingToken).\n                 * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\n                 */\n\n\n                        // Don't check indentation on blank lines\n\n\n                        // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\n\n\n                    // If the token matches the expected expected indentation, don't report it.\n\n\n                        // If a comment matches the expected indentation of the token immediately before or after, don't report it.\n\n\n                    // Otherwise, report the token/comment.\n\n\n"
    }
}