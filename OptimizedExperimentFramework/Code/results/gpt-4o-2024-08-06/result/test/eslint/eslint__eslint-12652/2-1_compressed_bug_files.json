{
    "1": {
        "bug_file": "lib/linter/linter.js",
        "compressed": "YES",
        "line_numbers": 1451,
        "compressed_line_numbers": 638,
        "compressed_bug_file_content": "/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n * @author aladdin-add\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\")[\"ConfigArray\"]>} ConfigArray */\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\")[\"ExtractedConfig\"]>} ExtractedConfig */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/**\n * @template T\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\n */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type\n * @property {number} line\n * @property {number} column\n * @property {(string|null)} ruleId\n */\n\n/**\n * The private data for `Linter` instance.\n * @typedef {Object} LinterInternalSlots\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\n * @property {Map<string, Parser>} parserMap The loaded parsers.\n * @property {Rules} ruleMap The loaded rules.\n */\n\n/**\n * @typedef {Object} VerifyOptions\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\n *      to change config once it is set. Defaults to true if not supplied.\n *      Useful if you want to validate JS without comments overriding rules.\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\n *      properties into the lint result.\n * @property {string} [filename] the filename of the source code.\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\n *      unused `eslint-disable` directives.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\n *      predicate function that selects adopt code blocks.\n * @property {Processor[\"postprocess\"]} [postprocess] postprocessor for report\n *      messages. If provided, this should accept an array of the message lists\n *      for each code block returned from the preprocessor, apply a mapping to\n *      the messages as appropriate, and return a one-dimensional array of\n *      messages.\n * @property {Processor[\"preprocess\"]} [preprocess] preprocessor for source text.\n *      If provided, this should accept a string of source text, and return an\n *      array of code blocks to lint.\n */\n\n/**\n * @typedef {Object} FixOptions\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\n *      whether fixes should be applied.\n */\n\n/**\n * @typedef {Object} InternalOptions\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\n\n\n    // Define configured global variables.\n\n\n        /*\n         * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n         */\n\n\n    // mark all exported variables as such\n\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n\n\n/**\n * creates a missing-rule message.\n * @param {string} ruleId the ruleId to create\n * @returns {string} created error message\n * @private\n */\n\n\n/**\n * creates a linting problem\n * @param {Object} options to create linting error\n * @param {string} [options.ruleId] the ruleId to report\n * @param {Object} [options.loc] the loc to report\n * @param {string} [options.message] the error message to report\n * @param {string} [options.severity] the error message to report\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\n * @private\n */\n\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {Object} options to create disable directives\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\n * @param {{line: number, column: number}} options.loc The 0-based location of the comment token\n * @param {string} options.value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\n * @returns {Object} Directives and problems from the comment\n */\n\n\n        // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\n\n\n                            // do not apply the config, if found invalid options.\n\n\n            // no default\n\n\n        exportedVariables,\n\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param  {number} ecmaVersion ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\n\n\n    /*\n     * Calculate ECMAScript edition number from official year version starting with\n     * ES2015, which corresponds with ES6 (or a difference of 2009).\n     */\n\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\n\n\n/**\n * Convert \"/path/to/<text>\" to \"<text>\".\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\n * was omitted because `configArray.extractConfig()` requires an absolute path.\n * But the linter should pass `<text>` to `RuleContext#getFilename()` in that\n * case.\n * Also, code blocks can have their virtual filename. If the parent filename was\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\n * it's not an absolute path).\n * @param {string} filename The filename to normalize.\n * @returns {string} The normalized filename.\n */\n\n\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {VerifyOptions} providedOptions Options\n * @param {ConfigData} config Config.\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\n */\n\n\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {string} parserName The parser name which uses this options.\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {ParserOptions} Resulting parser options after merge\n */\n\n\n        /*\n         * can't have global return inside of modules\n         * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\n         */\n\n\n    /*\n     * TODO: @aladdin-add\n     * 1. for a 3rd-party parser, do not normalize parserOptions\n     * 2. for espree, no need to do this (espree will do it)\n     */\n\n\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Record<string, GlobalConf>} The resolved globals object\n */\n\n\n/**\n * Strips Unicode BOM from a given text.\n * @param {string} text A text to strip.\n * @returns {string} The stripped text.\n */\n\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\n\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {ParserOptions} parserOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\n\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {Parser} parser The parser to parse.\n * @param {ParserOptions} providedParserOptions Options to pass to the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\n\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n\n\n            /*\n             * Save all values that `parseForESLint()` returned.\n             * If a `SourceCode` object is given as the first parameter instead of source code text,\n             * linter skips the parsing process and reuses the source code object.\n             * In that case, linter needs all the values that `parseForESLint()` returned.\n             */\n\n\n        // If the message includes a leading line number, strip it:\n\n\n/**\n * Gets the scope for the current node\n * @param {ScopeManager} scopeManager The scope manager for this AST\n * @param {ASTNode} currentNode The node to get the scope of\n * @returns {eslint-scope.Scope} The scope information for this node\n */\n\n\n    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n\n\n/**\n * Marks a variable as used in the current scope\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\n * @param {ASTNode} currentNode The node currently being traversed\n * @param {Object} parserOptions The options used to parse this text\n * @param {string} name The name of the variable that should be marked as used.\n * @returns {boolean} True if the variable was found and marked as used, false if not.\n */\n\n\n    // Special Node.js scope means we need to start one level deeper\n\n\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A normalized rule with a `create` method\n * @param {Context} ruleContext The context that should be passed to the rule\n * @returns {Object} A map of selector listeners provided by the rule\n */\n\n\n/**\n * Gets all the ancestors of a given node\n * @param {ASTNode} node The node\n * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting\n * from the root node and going inwards to the parent node.\n */\n\n\n// methods that exist on SourceCode object\n\n\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {Object} parserOptions The options that were passed to the parser\n * @param {string} parserName The name of the parser in the config\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\n * @param {string | undefined} cwd cwd of the cli\n * @returns {Problem[]} An array of reported problems\n */\n\n\n    /*\n     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n     * properties once for each rule.\n     */\n\n\n        // not load disabled rules\n\n\n                        /*\n                         * Create a report translator lazily.\n                         * In a vast majority of cases, any given rule reports zero errors on a given\n                         * piece of code. Creating a translator lazily avoids the performance cost of\n                         * creating a new translator function for each rule that usually doesn't get\n                         * called.\n                         *\n                         * Using lazy report translators improves end-to-end performance by about 3%\n                         * with Node 8.4.0.\n                         */\n\n\n        // add all the selectors from the rule as listeners\n\n\n/**\n * Ensure the source code to be a string.\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\n * @returns {string} The source code text.\n */\n\n\n/**\n * Get an environment.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} envId The environment ID to get.\n * @returns {Environment|null} The environment.\n */\n\n\n/**\n * Get a rule.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} ruleId The rule ID to get.\n * @returns {Rule|null} The rule.\n */\n\n\n/**\n * Normalize the value of the cwd\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\n * @returns {string | undefined} normalized cwd\n */\n\n\n    // It's more explicit to assign the undefined\n    // eslint-disable-next-line no-undefined\n\n\n/**\n * The map to store private data.\n * @type {WeakMap<Linter, LinterInternalSlots>}\n */\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\n\n\n    /**\n     * Initialize the Linter.\n     * @param {Object} [config] the config object\n     * @param {string} [config.cwd]  path to a directory that should be considered as the current working directory, can be undefined.\n     */\n\n\n    /**\n     * Getter for package version.\n     * @static\n     * @returns {string} The version from package.json.\n     */\n\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n\n\n        // evaluate arguments\n\n\n        // Resolve parser.\n\n\n        // search and apply \"eslint-env *\".\n\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n\n\n        // augment global scope with declared global variables\n\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\n     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n\n\n        // CLIEngine passes a `ConfigArray` object.\n\n\n        /*\n         * `Linter` doesn't support `overrides` property in configuration.\n         * So we cannot apply multiple processors.\n         */\n\n\n    /**\n     * Verify a given code with `ConfigArray`.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @returns {LintMessage[]} The found problems.\n     */\n\n\n        // Store the config array in order to get plugin envs and rules later.\n\n\n        // Extract the final config for this file.\n\n\n        // Verify.\n\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigData|ExtractedConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {ConfigArray} [configForRecursive] The `CofnigArray` object to apply multiple processors recursively.\n     * @returns {LintMessage[]} The found problems.\n     */\n\n\n            // Keep the legacy behavior.\n\n\n            // Skip this block if filtered.\n\n\n            // Resolve configuration again if the file extension was changed.\n\n\n            // Does lint.\n\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n\n\n    /**\n     * Defines many new linting rules.\n     * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map<string, Rule>} All loaded rules\n     */\n\n\n    /**\n     * Define a new parser module\n     * @param {string} parserId Name of the parser\n     * @param {Parser} parserModule The parser object\n     * @returns {void}\n     */\n\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {ConfigData|ConfigArray} config The ESLint config object to use.\n     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\n     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n\n\n            /*\n             * stop if there are any syntax errors.\n             * 'fixedResult.output' is a empty string.\n             */\n\n\n            // keep track if any fixes were ever applied - important for return value\n\n\n            // update to use the fixed output instead of the original text\n\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n\n\n        // ensure the last result properly reflects if fixes were done\n\n\n    /**\n     * Get the internal slots of a given Linter instance for tests.\n     * @param {Linter} instance The Linter instance to get.\n     * @returns {LinterInternalSlots} The internal slots.\n     */\n\n\n"
    },
    "2": {
        "bug_file": "lib/rules/key-spacing.js",
        "compressed": "YES",
        "line_numbers": 652,
        "compressed_line_numbers": 208,
        "compressed_bug_file_content": "/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\n\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\n\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\n\n\n/**\n * Initializes a single option property from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\n\n\n    // Set value of beforeColon\n\n\n    // Set value of afterColon\n\n\n    // Set align if exists\n\n\n/**\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\n\n\n        // Initialize the alignment configuration\n\n\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\n\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n\n\n        /**\n         * Checks whether a property is a member of the property group it follows.\n         * @param {ASTNode} lastMember The last Property known to be in the group.\n         * @param {ASTNode} candidate The next Property that might be in the group.\n         * @returns {boolean} True if the candidate property is part of the group.\n         */\n\n\n            /*\n             * Check that the first comment is adjacent to the end of the group, the\n             * last comment is adjacent to the candidate property, and that successive\n             * comments are adjacent to each other.\n             */\n\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {boolean} Whether the property is a key-value property.\n         */\n\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n\n\n                    // Remove whitespace\n\n\n                    // Add whitespace\n\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n\n\n            // Conditionally include one space before or after colon\n\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param  {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n\n        // Obey beforeColon and afterColon in each property as configured\n\n\n"
    },
    "3": {
        "bug_file": "lib/rules/object-curly-newline.js",
        "compressed": "NO",
        "line_numbers": 299,
        "compressed_line_numbers": 299,
        "compressed_bug_file_content": "/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                },\n                consistent: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n    let consistent = false;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n            consistent = Boolean(value.consistent);\n        }\n    } else {\n        consistent = true;\n    }\n\n    return { multiline, minProperties, consistent };\n}\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    const isNodeSpecificOption = lodash.overSome([lodash.isPlainObject, lodash.isString]);\n\n    if (lodash.isPlainObject(options) && lodash.some(options, isNodeSpecificOption)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };\n}\n\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\nfunction areLineBreaksRequired(node, options, first, last) {\n    let objectProperties;\n\n    if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n        objectProperties = node.properties;\n    } else {\n\n        // is ImportDeclaration or ExportNamedDeclaration\n        objectProperties = node.specifiers\n            .filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n    }\n\n    return objectProperties.length >= options.minProperties ||\n        (\n            options.multiline &&\n            objectProperties.length > 0 &&\n            first.loc.start.line !== last.loc.end.line\n        );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent line breaks inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE,\n                            ImportDeclaration: OPTION_VALUE,\n                            ExportDeclaration: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n\n            if (\n                (node.type === \"ImportDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) ||\n                (node.type === \"ExportNamedDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\"))\n            ) {\n                return;\n            }\n\n            const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n\n            let closeBrace;\n\n            if (node.typeAnnotation) {\n                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n            } else {\n                closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n            }\n\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLineBreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        message: \"Expected a line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        message: \"Expected a line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                const consistent = options.consistent;\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n                if (\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        message: \"Unexpected line break after this opening brace.\",\n                        node,\n                        loc: openBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        message: \"Unexpected line break before this closing brace.\",\n                        node,\n                        loc: closeBrace.loc.start,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check,\n            ImportDeclaration: check,\n            ExportNamedDeclaration: check\n        };\n    }\n};"
    },
    "4": {
        "bug_file": "lib/rules/object-property-newline.js",
        "compressed": "NO",
        "line_numbers": 94,
        "compressed_line_numbers": 94,
        "compressed_bug_file_content": "/**\n * @fileoverview Rule to enforce placing object properties on separate lines.\n * @author Vitor Balocco\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce placing object properties on separate lines\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-property-newline\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowAllPropertiesOnSameLine: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    allowMultiplePropertiesPerLine: { // Deprecated\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"whitespace\"\n    },\n\n    create(context) {\n        const allowSameLine = context.options[0] && (\n            (context.options[0].allowAllPropertiesOnSameLine || context.options[0].allowMultiplePropertiesPerLine /* Deprecated */)\n        );\n        const errorMessage = allowSameLine\n            ? \"Object properties must go on a new line if they aren't all on the same line.\"\n            : \"Object properties must go on a new line.\";\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n            ObjectExpression(node) {\n                if (allowSameLine) {\n                    if (node.properties.length > 1) {\n                        const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);\n                        const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);\n\n                        if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {\n\n                            // All keys and values are on the same line\n                            return;\n                        }\n                    }\n                }\n\n                for (let i = 1; i < node.properties.length; i++) {\n                    const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);\n                    const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);\n\n                    if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {\n                        context.report({\n                            node,\n                            loc: firstTokenOfCurrentProperty.loc.start,\n                            message: errorMessage,\n                            fix(fixer) {\n                                const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);\n                                const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];\n\n                                // Don't perform a fix if there are any comments between the comma and the next property.\n                                if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {\n                                    return null;\n                                }\n\n                                return fixer.replaceTextRange(rangeAfterComma, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};"
    },
    "5": {
        "bug_file": "lib/rules/object-curly-spacing.js",
        "compressed": "NO",
        "line_numbers": 301,
        "compressed_line_numbers": 301,
        "compressed_bug_file_content": "/**\n * @fileoverview Disallows or enforces spaces inside of object literals.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"enforce consistent spacing inside braces\",\n            category: \"Stylistic Issues\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-spacing\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    arraysInObjects: {\n                        type: \"boolean\"\n                    },\n                    objectsInObjects: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n        const spaced = context.options[0] === \"always\",\n            sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether an option is set, relative to the spacing option.\n         * If spaced is \"always\", then check whether option is set to false.\n         * If spaced is \"never\", then check whether option is set to true.\n         * @param {Object} option The option to exclude.\n         * @returns {boolean} Whether or not the property is excluded.\n         */\n        function isOptionSet(option) {\n            return context.options[1] ? context.options[1][option] === !spaced : false;\n        }\n\n        const options = {\n            spaced,\n            arraysInObjectsException: isOptionSet(\"arraysInObjects\"),\n            objectsInObjectsException: isOptionSet(\"objectsInObjects\")\n        };\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports that there shouldn't be a space after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoBeginningSpace(node, token) {\n            const nextToken = context.getSourceCode().getTokenAfter(token, { includeComments: true });\n\n            context.report({\n                node,\n                loc: { start: token.loc.end, end: nextToken.loc.start },\n                message: \"There should be no space after '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there shouldn't be a space before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportNoEndingSpace(node, token) {\n            const previousToken = context.getSourceCode().getTokenBefore(token, { includeComments: true });\n\n            context.report({\n                node,\n                loc: { start: previousToken.loc.end, end: token.loc.start },\n                message: \"There should be no space before '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.removeRange([previousToken.range[1], token.range[0]]);\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space after the first token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredBeginningSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                message: \"A space is required after '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextAfter(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Reports that there should be a space before the last token\n         * @param {ASTNode} node The node to report in the event of an error.\n         * @param {Token} token The token to use for the report.\n         * @returns {void}\n         */\n        function reportRequiredEndingSpace(node, token) {\n            context.report({\n                node,\n                loc: token.loc,\n                message: \"A space is required before '{{token}}'.\",\n                data: {\n                    token: token.value\n                },\n                fix(fixer) {\n                    return fixer.insertTextBefore(token, \" \");\n                }\n            });\n        }\n\n        /**\n         * Determines if spacing in curly braces is valid.\n         * @param {ASTNode} node The AST node to check.\n         * @param {Token} first The first token to check (should be the opening brace)\n         * @param {Token} second The second token to check (should be first after the opening brace)\n         * @param {Token} penultimate The penultimate token to check (should be last before closing brace)\n         * @param {Token} last The last token to check (should be closing brace)\n         * @returns {void}\n         */\n        function validateBraceSpacing(node, first, second, penultimate, last) {\n            if (astUtils.isTokenOnSameLine(first, second)) {\n                const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);\n\n                if (options.spaced && !firstSpaced) {\n                    reportRequiredBeginningSpace(node, first);\n                }\n                if (!options.spaced && firstSpaced && second.type !== \"Line\") {\n                    reportNoBeginningSpace(node, first);\n                }\n            }\n\n            if (astUtils.isTokenOnSameLine(penultimate, last)) {\n                const shouldCheckPenultimate = (\n                    options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) ||\n                    options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate)\n                );\n                const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;\n\n                const closingCurlyBraceMustBeSpaced = (\n                    options.arraysInObjectsException && penultimateType === \"ArrayExpression\" ||\n                    options.objectsInObjectsException && (penultimateType === \"ObjectExpression\" || penultimateType === \"ObjectPattern\")\n                ) ? !options.spaced : options.spaced;\n\n                const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);\n\n                if (closingCurlyBraceMustBeSpaced && !lastSpaced) {\n                    reportRequiredEndingSpace(node, last);\n                }\n                if (!closingCurlyBraceMustBeSpaced && lastSpaced) {\n                    reportNoEndingSpace(node, last);\n                }\n            }\n        }\n\n        /**\n         * Gets '}' token of an object node.\n         *\n         * Because the last token of object patterns might be a type annotation,\n         * this traverses tokens preceded by the last property, then returns the\n         * first '}' token.\n         * @param {ASTNode} node The node to get. This node is an\n         *      ObjectExpression or an ObjectPattern. And this node has one or\n         *      more properties.\n         * @returns {Token} '}' token.\n         */\n        function getClosingBraceOfObject(node) {\n            const lastProperty = node.properties[node.properties.length - 1];\n\n            return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);\n        }\n\n        /**\n         * Reports a given object node if spacing in curly braces is invalid.\n         * @param {ASTNode} node An ObjectExpression or ObjectPattern node to check.\n         * @returns {void}\n         */\n        function checkForObject(node) {\n            if (node.properties.length === 0) {\n                return;\n            }\n\n            const first = sourceCode.getFirstToken(node),\n                last = getClosingBraceOfObject(node),\n                second = sourceCode.getTokenAfter(first, { includeComments: true }),\n                penultimate = sourceCode.getTokenBefore(last, { includeComments: true });\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given import node if spacing in curly braces is invalid.\n         * @param {ASTNode} node An ImportDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForImport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            let firstSpecifier = node.specifiers[0];\n            const lastSpecifier = node.specifiers[node.specifiers.length - 1];\n\n            if (lastSpecifier.type !== \"ImportSpecifier\") {\n                return;\n            }\n            if (firstSpecifier.type !== \"ImportSpecifier\") {\n                firstSpecifier = node.specifiers[1];\n            }\n\n            const first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first, { includeComments: true }),\n                penultimate = sourceCode.getTokenBefore(last, { includeComments: true });\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        /**\n         * Reports a given export node if spacing in curly braces is invalid.\n         * @param {ASTNode} node An ExportNamedDeclaration node to check.\n         * @returns {void}\n         */\n        function checkForExport(node) {\n            if (node.specifiers.length === 0) {\n                return;\n            }\n\n            const firstSpecifier = node.specifiers[0],\n                lastSpecifier = node.specifiers[node.specifiers.length - 1],\n                first = sourceCode.getTokenBefore(firstSpecifier),\n                last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken),\n                second = sourceCode.getTokenAfter(first, { includeComments: true }),\n                penultimate = sourceCode.getTokenBefore(last, { includeComments: true });\n\n            validateBraceSpacing(node, first, second, penultimate, last);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            // var {x} = y;\n            ObjectPattern: checkForObject,\n\n            // var y = {x: 'y'}\n            ObjectExpression: checkForObject,\n\n            // import {y} from 'x';\n            ImportDeclaration: checkForImport,\n\n            // export {name} from 'yo';\n            ExportNamedDeclaration: checkForExport\n        };\n\n    }\n};"
    }
}