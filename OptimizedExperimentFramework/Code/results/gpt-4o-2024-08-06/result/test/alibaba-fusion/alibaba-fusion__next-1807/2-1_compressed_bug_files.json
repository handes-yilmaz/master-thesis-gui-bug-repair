{
    "1": {
        "bug_file": "src/menu/view/item.jsx",
        "compressed": "NO",
        "line_numbers": 229,
        "compressed_line_numbers": 229,
        "compressed_bug_file_content": "import React, { Component, Children, isValidElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { func, obj, KEYCODE } from '../../util';\n\nconst { bindCtx } = func;\nconst { pickOthers } = obj;\n\nexport default class Item extends Component {\n    static propTypes = {\n        _key: PropTypes.string,\n        level: PropTypes.number,\n        inlineLevel: PropTypes.number,\n        groupIndent: PropTypes.number,\n        root: PropTypes.object,\n        menu: PropTypes.any,\n        parent: PropTypes.object,\n        parentMode: PropTypes.oneOf(['inline', 'popup']),\n        type: PropTypes.oneOf(['submenu', 'item']),\n        component: PropTypes.string,\n        disabled: PropTypes.bool,\n        className: PropTypes.string,\n        onClick: PropTypes.func,\n        onKeyDown: PropTypes.func,\n        needIndent: PropTypes.bool,\n        replaceClassName: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        component: 'li',\n        groupIndent: 0,\n        replaceClassName: false,\n        needIndent: true,\n    };\n\n    constructor(props) {\n        super(props);\n\n        bindCtx(this, ['handleClick', 'handleKeyDown']);\n    }\n\n    componentDidMount() {\n        this.itemNode = findDOMNode(this);\n\n        const { parentMode, root, menu } = this.props;\n        if (menu) {\n            this.menuNode = findDOMNode(menu);\n        } else if (parentMode === 'popup') {\n            this.menuNode = this.itemNode.parentNode;\n        } else {\n            this.menuNode = findDOMNode(root);\n            const { prefix, header, footer } = root.props;\n            if (header || footer) {\n                this.menuNode = this.menuNode.querySelector(\n                    `.${prefix}menu-content`\n                );\n            }\n        }\n\n        this.setFocus();\n    }\n\n    componentDidUpdate() {\n        this.setFocus();\n    }\n\n    focusable() {\n        const { root, type, disabled } = this.props;\n        const { focusable } = root.props;\n        return focusable && (type === 'submenu' || !disabled);\n    }\n\n    getFocused() {\n        const { _key, root } = this.props;\n        const { focusedKey } = root.state;\n        return focusedKey === _key;\n    }\n\n    setFocus() {\n        const focused = this.getFocused();\n        if (focused) {\n            if (this.focusable()) {\n                this.itemNode.focus({ preventScroll: true });\n            }\n            if (\n                this.menuNode &&\n                this.menuNode.scrollHeight > this.menuNode.clientHeight\n            ) {\n                const scrollBottom =\n                    this.menuNode.clientHeight + this.menuNode.scrollTop;\n                const itemBottom =\n                    this.itemNode.offsetTop + this.itemNode.offsetHeight;\n                if (itemBottom > scrollBottom) {\n                    this.menuNode.scrollTop =\n                        itemBottom - this.menuNode.clientHeight;\n                } else if (this.itemNode.offsetTop < this.menuNode.scrollTop) {\n                    this.menuNode.scrollTop = this.itemNode.offsetTop;\n                }\n            }\n        }\n    }\n\n    handleClick(e) {\n        e.stopPropagation();\n\n        const { _key, root, disabled } = this.props;\n\n        if (!disabled) {\n            root.handleItemClick(_key, this, e);\n\n            this.props.onClick && this.props.onClick(e);\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    handleKeyDown(e) {\n        const { _key, root, type } = this.props;\n\n        if (this.focusable()) {\n            root.handleItemKeyDown(_key, type, this, e);\n\n            switch (e.keyCode) {\n                case KEYCODE.ENTER: {\n                    if (!(type === 'submenu')) {\n                        this.handleClick(e);\n                    }\n                    break;\n                }\n            }\n        }\n\n        this.props.onKeyDown && this.props.onKeyDown(e);\n    }\n\n    getTitle(children) {\n        let labelString = '';\n\n        const loop = children => {\n            Children.forEach(children, child => {\n                if (isValidElement(child) && child.props.children) {\n                    loop(child.props.children);\n                } else if (typeof child === 'string') {\n                    labelString += child;\n                }\n            });\n        };\n\n        loop(children);\n\n        return labelString;\n    }\n\n    render() {\n        const {\n            inlineLevel,\n            root,\n            replaceClassName,\n            groupIndent,\n            component,\n            disabled,\n            className,\n            children,\n            needIndent,\n            parentMode,\n            _key,\n        } = this.props;\n        const others = pickOthers(Object.keys(Item.propTypes), this.props);\n\n        const {\n            prefix,\n            focusable,\n            inlineIndent,\n            itemClassName,\n            rtl,\n        } = root.props;\n        const focused = this.getFocused();\n\n        const newClassName = replaceClassName\n            ? className\n            : cx({\n                  [`${prefix}menu-item`]: true,\n                  [`${prefix}disabled`]: disabled,\n                  [`${prefix}focused`]: !focusable && focused,\n                  [itemClassName]: !!itemClassName,\n                  [className]: !!className,\n              });\n        if (disabled) {\n            others['aria-disabled'] = true;\n            others['aria-hidden'] = true;\n        }\n\n        others.tabIndex = root.state.tabbableKey === _key ? '0' : '-1';\n\n        if (\n            parentMode === 'inline' &&\n            inlineLevel > 1 &&\n            inlineIndent > 0 &&\n            needIndent\n        ) {\n            const paddingProp = rtl ? 'paddingRight' : 'paddingLeft';\n            others.style = {\n                ...(others.style || {}),\n                [paddingProp]: `${inlineLevel * inlineIndent -\n                    (groupIndent || 0) * 0.4 * inlineIndent}px`,\n            };\n        }\n        const TagName = component;\n\n        let role = 'menuitem';\n        if ('selectMode' in root.props) {\n            role = 'option';\n        }\n\n        return (\n            <TagName\n                role={role}\n                title={this.getTitle(children)}\n                {...others}\n                className={newClassName}\n                onClick={this.handleClick}\n                onKeyDown={this.handleKeyDown}\n            >\n                <div className={`${prefix}menu-item-inner`}>{children}</div>\n            </TagName>\n        );\n    }\n}"
    },
    "2": {
        "bug_file": "src/menu/view/menu.jsx",
        "compressed": "YES",
        "line_numbers": 1075,
        "compressed_line_numbers": 191,
        "compressed_bug_file_content": "import React, { Component, Children, cloneElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\nimport SubMenu from './sub-menu';\nimport ConfigProvider from '../../config-provider';\nimport { func, obj, dom, events, KEYCODE } from '../../util';\nimport {\n\n\n    // keep placehold to get width\n\n\n        // indicators which not in use, just display: none\n\n\n                    // `React.forwardRef(render)` returns a forwarding\n                    // object that includes `render` method, and the specific\n                    // `child.type` will be an object instead of a class or\n                    // function.\n\n\n                    // filter out duplicate keys\n\n\n                // paddingLeft(or paddingRight in rtl) only make sense in inline mode\n                // parent know children's inlineLevel\n                // if parent's mode is popup, then children's inlineLevel must be 1;\n                // else inlineLevel should add 1\n\n\n/**\n * Menu\n */\n\n\n        /**\n         * 菜单项和子菜单\n         */\n\n        /**\n         * 点击菜单项触发的回调函数\n         * @param {String} key 点击的菜单项的 key 值\n         * @param {Object} item 点击的菜单项对象\n         * @param {Object} event 点击的事件对象\n         */\n\n        /**\n         * 当前打开的子菜单的 key 值\n         */\n\n        /**\n         * 初始打开的子菜单的 key 值\n         */\n\n\n        /**\n         * 初始展开所有的子菜单，只在 mode 设置为 'inline' 以及 openMode 设置为 'multiple' 下生效，优先级高于 defaultOpenKeys\n         */\n\n        /**\n         * 打开或关闭子菜单触发的回调函数\n         * @param {Array} key 打开的所有子菜单的 key 值\n         * @param {Object} extra 额外参数\n         * @param {String} extra.key 当前操作子菜单的 key 值\n         * @param {Boolean} extra.open 是否是打开\n         */\n\n        /**\n         * 子菜单打开的模式\n         */\n\n        /**\n         * 子菜单打开的触发行为\n         */\n\n        /**\n         * 展开内连子菜单的模式，同时可以展开一个子菜单还是多个子菜单，该属性仅在 mode 为 inline 时生效\n         */\n\n        /**\n         * 内连子菜单缩进距离\n         */\n\n\n        /**\n         * 是否自动让弹层的宽度和菜单项保持一致，如果弹层的宽度比菜单项小则和菜单项保持一致，如果宽度大于菜单项则不做处理\n         */\n\n        /**\n         * 弹层的对齐方式\n         */\n\n        /**\n         * 弹层自定义 props\n         */\n\n        /**\n         * 弹出子菜单自定义 className\n         */\n\n        /**\n         * 弹出子菜单自定义 style\n         */\n\n        /**\n         * 当前选中菜单项的 key 值\n         */\n\n        /**\n         * 初始选中菜单项的 key 值\n         */\n\n\n        /**\n         * 选中或取消选中菜单项触发的回调函数\n         * @param {Array} selectedKeys 选中的所有菜单项的值\n         * @param {Object} item 选中或取消选中的菜单项\n         * @param {Object} extra 额外参数\n         * @param {Boolean} extra.select 是否是选中\n         * @param {Array} extra.key 菜单项的 key\n         * @param {Object} extra.label 菜单项的文本\n         * @param {Array} extra.keyPath 菜单项 key 的路径\n         */\n\n        /**\n         * 选中模式，单选还是多选，默认无值，不可选\n         */\n\n        /**\n         * 是否只能选择第一层菜单项（不能选择子菜单中的菜单项）\n         */\n\n        /**\n         * 是否显示选中图标，如果设置为 false 需配合配置平台设置选中时的背景色以示区分\n         */\n\n\n        /**\n         * 是否将选中图标居右，仅当 hasSelectedIcon 为true 时生效。\n         * 注意：SubMenu 上的选中图标一直居左，不受此API控制\n         */\n\n        /**\n         * 菜单第一层展示方向\n         */\n\n        /**\n         * 横向菜单条 item 和 footer 的对齐方向，在 direction 设置为 'hoz' 并且 header 存在时生效\n         */\n\n        /**\n         * 横向菜单模式下，是否维持在一行，即超出一行折叠成 SubMenu 显示， 仅在 direction='hoz' mode='popup' 时生效\n         */\n\n\n        /**\n         * 自定义菜单头部\n         */\n\n        /**\n         * 自定义菜单尾部\n         */\n\n        /**\n         * 是否自动获得焦点\n         */\n\n        /**\n         * 当前获得焦点的子菜单或菜单项 key 值\n         */\n\n\n        /**\n         * 是否开启嵌入式模式，一般用于Layout的布局中，开启后没有默认背景、外层border、box-shadow，可以配合`<Menu style={{lineHeight: '100px'}}>` 自定义高度\n         */\n\n\n        /**\n         * 可配置的icons，包括 select 等\n         */\n\n\n        // keep placehold to get width\n\n\n            // indicators which not in use, just display: none\n\n\nexport default polyfill(Menu);\n"
    },
    "3": {
        "bug_file": "src/cascader/menu.jsx",
        "compressed": "NO",
        "line_numbers": 119,
        "compressed_line_numbers": 119,
        "compressed_bug_file_content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport Menu from '../menu';\nimport VirtualList from '../virtual-list';\n\nexport default class CascaderMenu extends Component {\n    static propTypes = {\n        prefix: PropTypes.string,\n        className: PropTypes.string,\n        useVirtual: PropTypes.bool,\n        children: PropTypes.node,\n    };\n\n    componentDidMount() {\n        this.scrollToSelectedItem();\n    }\n\n    scrollToSelectedItem() {\n        const { prefix, useVirtual, children } = this.props;\n        if (!children || children.length === 0) {\n            return;\n        }\n        const selectedIndex = children.findIndex(\n            item =>\n                !!item.props.checked ||\n                !!item.props.selected ||\n                !!item.props.expanded\n        );\n\n        if (selectedIndex === -1) {\n            return;\n        }\n\n        if (useVirtual) {\n            const instance = this.virtualEl.getInstance();\n            setTimeout(() => instance.scrollTo(selectedIndex), 0);\n        } else {\n            const itemSelector = `.${prefix}menu-item`;\n            const menu = findDOMNode(this.menuEl);\n            const targetItem = menu.querySelectorAll(itemSelector)[\n                selectedIndex\n            ];\n            if (targetItem) {\n                menu.scrollTop =\n                    targetItem.offsetTop -\n                    Math.floor(\n                        (menu.clientHeight / targetItem.clientHeight - 1) / 2\n                    ) *\n                        targetItem.clientHeight;\n            }\n        }\n    }\n\n    renderMenu(items, ref, props) {\n        return (\n            <Menu ref={ref} role=\"listbox\" {...props}>\n                {items.map(node => {\n                    if (\n                        React.isValidElement(node) &&\n                        node.type.menuChildType === 'item'\n                    ) {\n                        return React.cloneElement(node, {\n                            menu: this,\n                        });\n                    }\n\n                    return node;\n                })}\n            </Menu>\n        );\n    }\n\n    saveMenuRef = ref => {\n        this.menuEl = ref;\n    };\n\n    saveVirtualRef = ref => {\n        this.virtualEl = ref;\n    };\n\n    render() {\n        const {\n            prefix,\n            useVirtual,\n            className,\n            style,\n            children,\n            ...others\n        } = this.props;\n        const menuProps = {\n            labelToggleChecked: false,\n            className: `${prefix}cascader-menu`,\n            ...others,\n        };\n        return (\n            <div\n                ref={this.saveMenuRef}\n                className={`${prefix}cascader-menu-wrapper ${\n                    className ? className : ''\n                }`}\n                style={style}\n            >\n                {useVirtual ? (\n                    <VirtualList\n                        ref={this.saveVirtualRef}\n                        itemsRenderer={(items, ref) =>\n                            this.renderMenu(items, ref, menuProps)\n                        }\n                    >\n                        {children}\n                    </VirtualList>\n                ) : (\n                    this.renderMenu(children, undefined, menuProps)\n                )}\n            </div>\n        );\n    }\n}"
    },
    "4": {
        "bug_file": "src/config-provider/config.jsx",
        "compressed": "NO",
        "line_numbers": 254,
        "compressed_line_numbers": 254,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { obj, log } from '../util';\nimport getContextProps from './get-context-props';\nimport ErrorBoundary from './error-boundary';\n\nconst { shallowEqual } = obj;\n\nfunction getDisplayName(Component) {\n    return Component.displayName || Component.name || 'Component';\n}\n\nlet globalLocales;\nlet currentGlobalLanguage = 'zh-cn';\nlet currentGlobalLocale = {};\nlet currentGlobalRtl;\n\nexport function initLocales(locales) {\n    globalLocales = locales;\n\n    if (locales) {\n        currentGlobalLocale = locales[currentGlobalLanguage];\n\n        if (typeof currentGlobalRtl !== 'boolean') {\n            currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n        }\n    }\n}\n\nexport function setLanguage(language) {\n    if (globalLocales) {\n        currentGlobalLanguage = language;\n        currentGlobalLocale = globalLocales[language];\n\n        if (typeof currentGlobalRtl !== 'boolean') {\n            currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n        }\n    }\n}\n\nexport function setLocale(locale) {\n    currentGlobalLocale = {\n        ...(globalLocales ? globalLocales[currentGlobalLanguage] : {}),\n        ...locale,\n    };\n\n    if (typeof currentGlobalRtl !== 'boolean') {\n        currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n    }\n}\n\nexport function setDirection(dir) {\n    currentGlobalRtl = dir === 'rtl';\n}\n\nexport function getLocale() {\n    return currentGlobalLocale;\n}\n\nexport function getLanguage() {\n    return currentGlobalLanguage;\n}\n\nexport function getDirection() {\n    return currentGlobalRtl;\n}\n\nexport function config(Component, options = {}) {\n    // 非 forwardRef 创建的 class component\n    if (\n        obj.isClassComponent(Component) &&\n        Component.prototype.shouldComponentUpdate === undefined\n    ) {\n        // class component: 通过定义 shouldComponentUpdate 改写成 pure component, 有refs\n        Component.prototype.shouldComponentUpdate = function shouldComponentUpdate(\n            nextProps,\n            nextState\n        ) {\n            if (this.props.pure) {\n                return (\n                    !shallowEqual(this.props, nextProps) ||\n                    !shallowEqual(this.state, nextState)\n                );\n            }\n\n            return true;\n        };\n    }\n\n    class ConfigedComponent extends React.Component {\n        static propTypes = {\n            ...(Component.propTypes || {}),\n            prefix: PropTypes.string,\n            locale: PropTypes.object,\n            pure: PropTypes.bool,\n            rtl: PropTypes.bool,\n            device: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n            popupContainer: PropTypes.any,\n            errorBoundary: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.object,\n            ]),\n        };\n        static contextTypes = {\n            ...(Component.contextTypes || {}),\n            nextPrefix: PropTypes.string,\n            nextLocale: PropTypes.object,\n            nextPure: PropTypes.bool,\n            nextRtl: PropTypes.bool,\n            nextWarning: PropTypes.bool,\n            nextDevice: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n            nextPopupContainer: PropTypes.any,\n            nextErrorBoundary: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.object,\n            ]),\n        };\n\n        constructor(props, context) {\n            super(props, context);\n\n            this._getInstance = this._getInstance.bind(this);\n            this._deprecated = this._deprecated.bind(this);\n        }\n\n        _getInstance(ref) {\n            this._instance = ref;\n\n            if (this._instance && options.exportNames) {\n                options.exportNames.forEach(name => {\n                    const field = this._instance[name];\n                    if (typeof field === 'function') {\n                        this[name] = field.bind(this._instance);\n                    } else {\n                        this[name] = field;\n                    }\n                });\n            }\n        }\n\n        _deprecated(...args) {\n            if (this.context.nextWarning !== false) {\n                log.deprecated(...args);\n            }\n        }\n\n        getInstance() {\n            return this._instance;\n        }\n\n        render() {\n            const {\n                prefix,\n                locale,\n                pure,\n                rtl,\n                device,\n                popupContainer,\n                errorBoundary,\n                ...others\n            } = this.props;\n            const {\n                nextPrefix,\n                nextLocale = {},\n                nextPure,\n                nextRtl,\n                nextDevice,\n                nextPopupContainer,\n                nextErrorBoundary,\n            } = this.context;\n\n            const displayName =\n                options.componentName || getDisplayName(Component);\n            const contextProps = getContextProps(\n                {\n                    prefix,\n                    locale,\n                    pure,\n                    device,\n                    popupContainer,\n                    rtl,\n                    errorBoundary,\n                },\n                {\n                    nextPrefix,\n                    nextLocale: { ...currentGlobalLocale, ...nextLocale },\n                    nextPure,\n                    nextDevice,\n                    nextPopupContainer,\n                    nextRtl:\n                        typeof nextRtl === 'boolean'\n                            ? nextRtl\n                            : currentGlobalRtl === true\n                            ? true\n                            : undefined,\n                    nextErrorBoundary,\n                },\n                displayName\n            );\n\n            // errorBoundary is only for <ErrorBoundary>\n            const newContextProps = [\n                'prefix',\n                'locale',\n                'pure',\n                'rtl',\n                'device',\n                'popupContainer',\n            ].reduce((ret, name) => {\n                if (typeof contextProps[name] !== 'undefined') {\n                    ret[name] = contextProps[name];\n                }\n                return ret;\n            }, {});\n\n            if ('pure' in newContextProps && newContextProps.pure) {\n                log.warning(\n                    'pure of ConfigProvider is deprecated, use Function Component or React.PureComponent'\n                );\n            }\n\n            const newOthers = options.transform\n                ? options.transform(others, this._deprecated)\n                : others;\n\n            const content = (\n                <Component\n                    {...newOthers}\n                    {...newContextProps}\n                    ref={\n                        obj.isClassComponent(Component)\n                            ? this._getInstance\n                            : null\n                    }\n                />\n            );\n\n            const { open, ...othersBoundary } = contextProps.errorBoundary;\n\n            return open ? (\n                <ErrorBoundary {...othersBoundary}>{content}</ErrorBoundary>\n            ) : (\n                content\n            );\n        }\n    }\n\n    ConfigedComponent.displayName = `Config(${getDisplayName(Component)})`;\n\n    hoistNonReactStatic(ConfigedComponent, Component);\n\n    return ConfigedComponent;\n}"
    },
    "5": {
        "bug_file": "src/select/select.jsx",
        "compressed": "YES",
        "line_numbers": 1218,
        "compressed_line_numbers": 371,
        "compressed_bug_file_content": "/* eslint-disable valid-jsdoc */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\n\nimport { func, obj, KEYCODE, env, str } from '../util';\nimport Tag from '../tag';\nimport Input from '../input';\nimport Icon from '../icon';\nimport zhCN from '../locale/zh-cn';\nimport Base from './base';\nimport { isNull, getValueDataSource, valueToSelectKey } from './util';\n\n\n/**\n * 无障碍化注意事项:\n * 1. Select 无搜索情况下，不应该让 Input 可focus，此时外层wrap必须可focus，并且需要相应focus事件让外边框发生变化\n *\n * TODO: hightLight 后续改造注意点\n * 1. hightLight 跟随点击变化(fixed) 2. 弹窗打开时根据 是否高亮第一个选项的 api开关设置是否hightLight 第一项\n */\n\n// 自定义弹层：1. 不需要关心Menu的点击事件 2. 不需要关心dataSource变化\n\n/**\n * Select\n */\n\n\n        /**\n         * 选择器模式\n         */\n\n        /**\n         * 当前值，用于受控模式\n         */\n\n        /**\n         * 初始的默认值\n         */\n\n        /**\n         * Select发生改变时触发的回调\n         * @param {*} value 选中的值\n         * @param {String} actionType 触发的方式, 'itemClick', 'enter', 'tag'\n         * @param {*} item 选中的值的对象数据 (useDetailValue=false有效)\n         */\n\n        /**\n         * 传入的数据源，可以动态渲染子项，详见 [dataSource的使用](#dataSource的使用)\n         */\n\n\n        /**\n         * 是否有边框\n         */\n\n        /**\n         * 是否有下拉箭头\n         */\n\n        /**\n         * 展开后是否能搜索（tag 模式下固定为true）\n         */\n\n        /**\n         * 当搜索框值变化时回调\n         * @param {String} value 数据\n         */\n\n        /**\n         * 当搜索框值被清空时候的回调\n         * @param {String} actionType 触发的方式, 'select'(选择清空), 'popupClose'(弹窗关闭清空)\n         */\n\n        /**\n         * 多选模式下是否有全选功能\n         */\n\n        /**\n         * 填充到选择框里的值的 key\b\b\n         */\n\n        /**\n         * onChange 返回的 value 使用 dataSource 的对象\n         */\n\n        /**\n         * dataSource 变化的时是否保留已选的内容\n         */\n\n        /**\n         * 渲染 Select 展现内容的方法\n         * @param {Object} item 渲染节点的item\n         * @return {ReactNode} 展现内容\n         * @default item => item.label \\|\\| item.value\n         */\n\n        /**\n         * 渲染 MenuItem 内容的方法\n         * @param {Object} item 渲染节点的item\n         * @param {String} searchValue 搜索关键字（如果开启搜索）\n         * @return {ReactNode} item node\n         */\n\n        /**\n         * 弹层内容为空的文案\n         */\n\n\n        /**\n         * 受控搜索值，一般不需要设置\n         * @type {[type]}\n         */\n\n        /**\n         * 是否一行显示，仅在 mode 为 multiple 的时候生效\n         */\n\n        /**\n         * 最多显示多少个 tag\n         */\n\n        /**\n         * 隐藏多余 tag 时显示的内容，在 maxTagCount 生效时起作用\n         * @param {number} selectedValues 当前已选中的元素\n         * @param {number} totalValues 总待选元素\n         */\n\n        /**\n         * 选择后是否立即隐藏菜单 (mode=multiple/tag 模式生效)\n         */\n\n        /**\n         * tag 删除回调\n         * @param {object} item 渲染节点的item\n         */\n\n        /**\n         * 焦点事件\n         */\n\n        /**\n         * 是否自动高亮第一个选项\n         */\n        // highlightFirstItem: PropTypes.bool,\n        /**\n         * 失去焦点事件\n         */\n\n\n        /**\n         * 展开下拉菜单时是否自动焦点到弹层\n         */\n\n\n        // highlightFirstItem: true,\n\n\n        // because dataSource maybe updated while select a item, so we should cache choosen value's item\n\n\n        // 根据value和计算后的dataSource，更新value对应的详细数据valueDataSource\n\n\n            /* eslint-disable react/no-did-update-set-state */\n\n\n            // has defaultValue and value not changed and dataSource changed\n            // fix: set defaultValue first, then update dataSource.\n\n\n    // ie9 下 table-cell 布局不支持宽度超出隐藏\n\n\n            //\n\n\n    /**\n     * Menu.Item onSelect\n     * @private\n     * @param  {Array<string>} keys\n     * @\n     */\n\n\n            // 单选\n\n\n            // 正常多选\n\n\n    /**\n     * 单选模式\n     */\n\n        // TODO: 这里 cacheValue=false 有问题，dataSource 更新的时候就应该处理\n\n        // get data only from dataStore while cacheValue=false\n\n\n        // 清空搜索\n\n\n    /**\n     * 多选模式 multiple/tag\n     */\n\n\n        // cache those value maybe not exists in dataSource\n\n\n        // 因为搜索后会设置 hightLight 为第一个item，menu渲染会自动滚动到 hightLight 的元素上面。\n        // 所以设置 hightLight 为当前选中项避免滚动\n\n\n        // 清空搜索\n\n\n            // 因为 SearchValue 被 clear 后会重新渲染 Menu，所以在 Overlay 检测 safeNode 的时候 e.target 可能会找不到导致弹窗关闭\n\n\n        // multiple mode\n        // is current state select all or not\n\n\n    /**\n     * Handle search input change event\n     * @param {Event} e change Event\n     */\n\n\n        // inputing should trigger popup open\n\n\n    // 搜索框 keyDown 事件\n\n\n                    // 在多选并且有搜索的情况下，删除最后一个 tag\n\n\n                    // 单选、非展开、并且可清除的情况，允许按删除键清除\n\n\n            // unselect\n\n\n            // select\n\n\n    // 回车 选择高亮的 item\n\n\n            // input tag by itself\n\n\n        // 没有高亮选项 或者 没有可选菜单\n\n\n            // 阻止事件冒泡到最外层，让Popup 监听到触发弹层关闭\n\n\n    /**\n     * Handle Tag close event\n     * @param  {Object} item\n     * @return {Boolean} false  return false to prevent auto close\n     * ----\n     * It MUST be multiple mode, needn't additional judgement\n     */\n\n\n            // filter out current item, and then call handleMenuSelect\n\n\n        // prevent tag close\n\n\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * Handle BACKSPACE key event\n     * @param {Event} e keyDown event\n     * ---\n     * It MUST be multiple mode\n     */\n\n\n        // 手动调用 handleMenuSelect 时直接传入原生的 value，可以减少 toString 的操作\n\n\n    /**\n     * Handle SelectAll span click event\n     * @param {Event} e click event\n     */\n\n\n        // 直接传 values，减少 toString 操作\n\n\n        // 关闭的时候清空搜索值\n\n\n    /**\n     * 如果用户是自定义的弹层，则直接以 value 为准，不再校验 dataSource\n     * @param {object} props\n     */\n\n\n        // get detail value\n\n\n            // 0 => '0'\n\n\n    /**\n     * 1. fix flash while click <label/>\n     * 2. fix onBlur while has clear\n     * @returns\n     */\n\n        // ignore click on input to choose text\n\n\n        // because of can not close Popup by click Input while hasSearch.\n        // so when Popup open and hasSearch, we should close Popup intentionally\n\n\n    /**\n     * render arrow\n     * @param {object} props\n     * @param {function} [clickHandler]\n     */\n\n\n        // do not use this.hasClear() here, to make sure clear btn always exists, can not influenced by apis like `disabled` `readOnly`\n\n\n    /**\n     * 选择器\n     * @override\n     * @param {object} props\n     */\n\n\n        // compatible with selectPlaceHolder. TODO: removed in 2.0 version\n\n\n        // 弹窗展开时将当前的值作为 placeholder，这个功能的前提是 valueNode 必须是一个字符串\n\n\n        // 下拉箭头\n\n\n    /**\n     * 渲染弹层的 header 内容\n     * @override\n     * @param {object} props\n     */\n\n\n        // 多选模式下才有全选\n\n\n        // remove style={{'lineHeight': 'unset'}} in next Y\n        // remove style={{'display': 'none'}} in next Y\n\n\n        // forbid to close Popup by click Input while hasSearch\n\n\nexport default polyfill(Select);\n"
    },
    "6": {
        "bug_file": "src/select/option.jsx",
        "compressed": "NO",
        "line_numbers": 27,
        "compressed_line_numbers": 27,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\n\n/* istanbul ignore file */\n\n/**\n * Select.Option\n */\nexport default class Option extends React.Component {\n    static propTypes = {\n        /**\n         * 选项值\n         */\n        value: PropTypes.any.isRequired,\n        /**\n         * 是否禁用\n         */\n        disabled: PropTypes.bool,\n        children: PropTypes.any,\n    };\n\n    static _typeMark = 'next_select_option';\n\n    render() {\n        return this.props.children;\n    }\n}"
    }
}