{
    "src/tree-select/tree-select.jsx": [
        "...",
        " * TreeSelect",
        " */",
        "export default class TreeSelect extends Component {",
        "    static propTypes = {",
        "        prefix: PropTypes.string,",
        "        pure: PropTypes.bool,",
        "        className: PropTypes.string,",
        "        /**",
        "         * 树节点",
        "         */",
        "        children: PropTypes.node,",
        "        /**",
        "         * 选择框大小",
        "         */",
        "        size: PropTypes.oneOf(['small', 'medium', 'large']),",
        "        /**",
        "         * 选择框占位符",
        "         */",
        "        placeholder: PropTypes.string,",
        "        /**",
        "         * 是否禁用",
        "         */",
        "        disabled: PropTypes.bool,",
        "        /**",
        "         * 是否有下拉箭头",
        "         */",
        "        hasArrow: PropTypes.bool,",
        "        /**",
        "         * 是否有边框",
        "         */",
        "        hasBorder: PropTypes.bool,",
        "        /**",
        "         * 是否有清空按钮",
        "         */",
        "        hasClear: PropTypes.bool,",
        "        /**",
        "         * 自定义内联 label",
        "         */",
        "        label: PropTypes.node,",
        "        /**",
        "         * 是否只读，只读模式下可以展开弹层但不能选择",
        "         */",
        "        readOnly: PropTypes.bool,",
        "        /**",
        "         * 下拉框是否与选择器对齐",
        "         */",
        "        autoWidth: PropTypes.bool,",
        "        /**",
        "         * 数据源，该属性优先级高于 children",
        "         */",
        "        dataSource: PropTypes.arrayOf(PropTypes.object),",
        "        /**",
        "         * （受控）当前值",
        "         */",
        "        value: PropTypes.oneOfType([",
        "            PropTypes.string,",
        "            PropTypes.arrayOf(PropTypes.string),",
        "        ]),",
        "        /**",
        "         * （非受控）默认值",
        "         */",
        "        defaultValue: PropTypes.oneOfType([",
        "            PropTypes.string,",
        "            PropTypes.arrayOf(PropTypes.string),",
        "        ]),",
        "        /**",
        "         * 选中值改变时触发的回调函数",
        "         * @param {String|Array} value 选中的值，单选时返回单个值，多选时返回数组",
        "         * @param {Object|Array} data 选中的数据，包括 value, label, pos, key属性，单选时返回单个值，多选时返回数组，父子节点选中关联时，同时选中，只返回父节点",
        "         */",
        "        onChange: PropTypes.func,",
        "        /**",
        "         * 是否显示搜索框",
        "         */",
        "        showSearch: PropTypes.bool,",
        "        /**",
        "         * 在搜索框中输入时触发的回调函数",
        "         * @param {String} keyword 输入的关键字",
        "         */",
        "        onSearch: PropTypes.func,",
        "        onSearchClear: PropTypes.func,",
        "        /**",
        "         * 无数据时显示内容",
        "         */",
        "        notFoundContent: PropTypes.node,",
        "        /**",
        "         * 是否支持多选",
        "         */",
        "        multiple: PropTypes.bool,",
        "        /**",
        "         * 下拉框中的树是否支持勾选节点的复选框",
        "         */",
        "        treeCheckable: PropTypes.bool,",
        "        /**",
        "         * 下拉框中的树勾选节点复选框是否完全受控（父子节点选中状态不再关联）",
        "         */",
        "        treeCheckStrictly: PropTypes.bool,",
        "        /**",
        "         * 定义选中时回填的方式",
        "         * @enumdesc 返回所有选中的节点, 父子节点都选中时只返回父节点, 父子节点都选中时只返回子节点",
        "         */",
        "        treeCheckedStrategy: PropTypes.oneOf(['all', 'parent', 'child']),",
        "        /**",
        "         * 下拉框中的树是否默认展开所有节点",
        "         */",
        "        treeDefaultExpandAll: PropTypes.bool,",
        "        /**",
        "         * 下拉框中的树默认展开节点key的数组",
        "         */",
        "        treeDefaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 下拉框中的树异步加载数据的函数，使用请参考[Tree的异步加载数据Demo](https://fusion.design/component/tree)",
        "         * @param {ReactElement} node 被点击展开的节点",
        "         */",
        "        treeLoadData: PropTypes.func,",
        "        /**",
        "         * 透传到 Tree 的属性对象",
        "         */",
        "        treeProps: PropTypes.object,",
        "        /**",
        "         * 初始下拉框是否显示",
        "         */",
        "        defaultVisible: PropTypes.bool,",
        "        /**",
        "         * 当前下拉框是否显示",
        "         */",
        "        visible: PropTypes.bool,",
        "        /**",
        "         * 下拉框显示或关闭时触发事件的回调函数",
        "         * @param {Boolean} visible 是否显示",
        "         * @param {String} type 触发显示关闭的操作类型",
        "         */",
        "        onVisibleChange: PropTypes.func,",
        "        /**",
        "         * 下拉框自定义样式对象",
        "         */",
        "        popupStyle: PropTypes.object,",
        "        /**",
        "         * 下拉框样式自定义类名",
        "         */",
        "        popupClassName: PropTypes.string,",
        "        /**",
        "         * 下拉框挂载的容器节点",
        "         */",
        "        popupContainer: PropTypes.any,",
        "        /**",
        "         * 透传到 Popup 的属性对象",
        "         */",
        "        popupProps: PropTypes.object,",
        "        /**",
        "         * 是否跟随滚动",
        "         */",
        "        followTrigger: PropTypes.bool,",
        "        /**",
        "         * 是否为预览态",
        "         */",
        "        isPreview: PropTypes.bool,",
        "        /**",
        "         * 预览态模式下渲染的内容",
        "         * @param {Array<data>} value 选择值 { label: , value:}",
        "         */",
        "        renderPreview: PropTypes.func,",
        "    };",
        "",
        "    static defaultProps = {",
        "        prefix: 'next-',",
        "        pure: false,",
        "        size: 'medium',",
        "        disabled: false,",
        "        hasArrow: true,",
        "        hasBorder: true,",
        "        hasClear: false,",
        "        autoWidth: true,",
        "        defaultValue: null,",
        "        onChange: noop,",
        "        showSearch: false,",
        "        onSearch: noop,",
        "        onSearchClear: noop,",
        "        notFoundContent: 'Not Found',",
        "        multiple: false,",
        "        treeCheckable: false,",
        "        treeCheckStrictly: false,",
        "        treeCheckedStrategy: 'parent',",
        "        treeDefaultExpandAll: false,",
        "        treeDefaultExpandedKeys: [],",
        "        treeProps: {},",
        "        defaultVisible: false,",
        "        onVisibleChange: noop,",
        "    };",
        "",
        "    constructor(props, context) {",
        "        super(props, context);",
        "",
        "        const { defaultVisible, visible, defaultValue, value } = props;",
        "        this.state = {",
        "            visible: typeof visible === 'undefined' ? defaultVisible : visible,",
        "            value: normalizeToArray(",
        "                typeof value === 'undefined' ? defaultValue : value",
        "            ),",
        "            searchedValue: '',",
        "            expandedKeys: [],",
        "            autoExpandParent: false,",
        "        };",
        "",
        "        bindCtx(this, [",
        "            'handleSelect',",
        "            'handleCheck',",
        "            'handleSearch',",
        "            'handleSearchClear',",
        "            'handleVisibleChange',",
        "            'handleChange',",
        "            'handleRemove',",
        "            'handleExpand',",
        "            'handleKeyDown',",
        "            'saveTreeRef',",
        "            'saveSelectRef',",
        "        ]);",
        "",
        "        this.updateCache(props);",
        "    }",
        "",
        "    componentWillReceiveProps(nextProps) {",
        "        this.updateCache(nextProps);",
        "",
        "        const st = {};",
        "        if ('value' in nextProps) {",
        "            st.value = normalizeToArray(nextProps.value);",
        "        }",
        "        if ('visible' in nextProps) {",
        "            st.visible = nextProps.visible;",
        "        }",
        "",
        "        if (Object.keys(st).length) {",
        "            this.setState(st);",
        "        }",
        "    }",
        "",
        "    updateCache(props) {",
        "        this._k2n = {};",
        "        this._p2n = {};",
        "        this._v2n = {};",
        "",
        "        if ('dataSource' in props) {",
        "            const loop = (data, prefix = '0') =>",
        "                data.map((item, index) => {",
        "                    const { value, children } = item;",
        "                    const pos = `${prefix}-${index}`;",
        "                    const key = item.key || pos;",
        "                    const newItem = { ...item, key, pos };",
        "                    if (children && children.length) {",
        "                        newItem.children = loop(children, pos);",
        "                    }",
        "",
        "                    this._k2n[key] = this._p2n[pos] = this._v2n[",
        "                        value",
        "                    ] = newItem;",
        "                    return newItem;",
        "                });",
        "            loop(props.dataSource);",
        "        } else if ('children' in props) {",
        "            const loop = (children, prefix = '0') =>",
        "                Children.map(children, (node, index) => {",
        "                    if (!React.isValidElement(node)) {",
        "                        return;",
        "                    }",
        "",
        "                    const { value, children } = node.props;",
        "                    const pos = `${prefix}-${index}`;",
        "                    const key = node.key || pos;",
        "                    const newItem = { ...node.props, key, pos };",
        "                    if (children && Children.count(children)) {",
        "                        newItem.children = loop(children, pos);",
        "                    }",
        "",
        "                    this._k2n[key] = this._p2n[pos] = this._v2n[",
        "                        value",
        "                    ] = newItem;",
        "                    return newItem;",
        "                });",
        "            loop(props.children);",
        "        }",
        "    }",
        "",
        "    getKeysByValue(value) {",
        "        return value.reduce((ret, v) => {",
        "            const k = this._v2n[v] && this._v2n[v].key;",
        "            if (k) {",
        "                ret.push(k);",
        "            }",
        "",
        "            return ret;",
        "        }, []);",
        "    }",
        "",
        "    getValueByKeys(keys) {",
        "        return keys.map(k => this._k2n[k].value);",
        "    }",
        "",
        "    getValueForSelect(value) {",
        "        const { treeCheckedStrategy } = this.props;",
        "",
        "        let keys = this.getKeysByValue(value);",
        "        keys = getAllCheckedKeys(keys, this._k2n, this._p2n);",
        "",
        "        switch (treeCheckedStrategy) {",
        "            case 'parent':",
        "                keys = filterChildKey(keys, this._k2n, this._p2n);",
        "                break;",
        "            case 'child':",
        "                keys = filterParentKey(keys, this._k2n, this._p2n);",
        "                break;",
        "            default:",
        "                break;",
        "        }",
        "",
        "        return this.getValueByKeys(keys);",
        "    }",
        "",
        "    getData(value, forSelect) {",
        "        return value.reduce((ret, v) => {",
        "            const k = this._v2n[v] && this._v2n[v].key;",
        "            if (k) {",
        "                const { label, pos, disabled, checkboxDisabled } = this._k2n[k];",
        "                const d = {",
        "                    value: v,",
        "                    label,",
        "                    pos,",
        "                };",
        "                if (forSelect) {",
        "                    d.disabled = disabled || checkboxDisabled;",
        "                } else {",
        "                    d.key = k;",
        "                }",
        "                ret.push(d);",
        "            }",
        "",
        "            return ret;",
        "        }, []);",
        "    }",
        "",
        "    saveTreeRef(ref) {",
        "        this.tree = ref;",
        "    }",
        "",
        "    saveSelectRef(ref) {",
        "        this.select = ref;",
        "    }",
        "",
        "    handleVisibleChange(visible, type) {",
        "        if (!('visible' in this.props)) {",
        "            this.setState({",
        "                visible,",
        "            });",
        "        }",
        "",
        "        if (['fromTree', 'keyboard'].indexOf(type) !== -1 && !visible) {",
        "            this.select.focusInput();",
        "        }",
        "",
        "        this.props.onVisibleChange(visible, type);",
        "    }",
        "",
        "    handleSelect(selectedKeys, extra) {",
        "        const { multiple, onChange } = this.props;",
        "        const { selected } = extra;",
        "",
        "        if (multiple || selected) {",
        "            const value = this.getValueByKeys(selectedKeys);",
        "            if (!('value' in this.props)) {",
        "                this.setState({",
        "                    value,",
        "                });",
        "            }",
        "            if (!multiple) {",
        "                this.handleVisibleChange(false, 'fromTree');",
        "            }",
        "",
        "            const data = this.getData(value);",
        "            multiple ? onChange(value, data) : onChange(value[0], data[0]);",
        "        } else {",
        "            this.handleVisibleChange(false, 'fromTree');",
        "        }",
        "    }",
        "",
        "    handleCheck(checkedKeys) {",
        "        const { onChange } = this.props;",
        "",
        "        const value = this.getValueByKeys(checkedKeys);",
        "        if (!('value' in this.props)) {",
        "            this.setState({",
        "                value,",
        "            });",
        "        }",
        "",
        "        onChange(value, this.getData(value));",
        "    }",
        "",
        "    handleRemove(removedItem) {",
        "        const { value: removedValue } = removedItem;",
        "        const {",
        "            treeCheckable,",
        "            treeCheckStrictly,",
        "            treeCheckedStrategy,",
        "            onChange,",
        "        } = this.props;",
        "",
        "        let value;",
        "        if (",
        "            treeCheckable &&",
        "            !treeCheckStrictly &&",
        "            ['parent', 'all'].indexOf(treeCheckedStrategy) !== -1",
        "        ) {",
        "            const removedPos = this._v2n[removedValue].pos;",
        "            value = this.state.value.filter(v => {",
        "                const p = this._v2n[v].pos;",
        "                return !isDescendantOrSelf(removedPos, p);",
        "            });",
        "",
        "            const nums = removedPos.split('-');",
        "            for (let i = nums.length; i > 2; i--) {",
        "                const parentPos = nums.slice(0, i - 1).join('-');",
        "                const parentValue = this._p2n[parentPos].value;",
        "                const parentIndex = value.indexOf(parentValue);",
        "                if (parentIndex > -1) {",
        "                    value.splice(parentIndex, 1);",
        "                } else {",
        "                    break;",
        "                }",
        "            }",
        "        } else {",
        "            value = this.state.value.filter(v => v !== removedValue);",
        "        }",
        "",
        "        if (!('value' in this.props)) {",
        "            this.setState({",
        "                value,",
        "            });",
        "        }",
        "",
        "        const data = this.getData(value);",
        "        onChange(value, data);",
        "    }",
        "",
        "    handleSearch(searchedValue) {",
        "        const searchedKeys = [];",
        "        const retainedKeys = [];",
        "        Object.keys(this._k2n).forEach(k => {",
        "            const { label, pos } = this._k2n[k];",
        "            if (this.isSearched(label, searchedValue)) {",
        "                searchedKeys.push(k);",
        "                const posArr = pos.split('-');",
        "                posArr.forEach((n, i) => {",
        "                    if (i > 0) {",
        "                        const p = posArr.slice(0, i + 1).join('-');",
        "                        const kk = this._p2n[p].key;",
        "                        if (retainedKeys.indexOf(kk) === -1) {",
        "                            retainedKeys.push(kk);",
        "                        }",
        "                    }",
        "                });",
        "            }",
        "        });",
        "",
        "        this.setState({",
        "            searchedValue,",
        "            expandedKeys: searchedKeys,",
        "            autoExpandParent: true,",
        "        });",
        "        this.searchedKeys = searchedKeys;",
        "        this.retainedKeys = retainedKeys;",
        "",
        "        this.props.onSearch(searchedValue);",
        "    }",
        "",
        "    handleSearchClear(triggerType) {",
        "        this.setState({",
        "            searchedValue: '',",
        "            expandedKeys: [],",
        "        });",
        "        this.props.onSearchClear(triggerType);",
        "    }",
        "",
        "    handleExpand(expandedKeys) {",
        "        this.setState({",
        "            expandedKeys,",
        "            autoExpandParent: false,",
        "        });",
        "    }",
        "",
        "    handleKeyDown(e) {",
        "        const { onKeyDown } = this.props;",
        "        const { visible } = this.state;",
        "",
        "        if (onKeyDown) {",
        "            onKeyDown(e);",
        "        }",
        "",
        "        if (!visible) {",
        "            return;",
        "        }",
        "",
        "..."
    ],
    "src/tree/view/tree-node.jsx": [
        "...",
        "import TreeNodeInput from './tree-node-input';",
        "",
        "const { Expand } = Animate;",
        "const { bindCtx } = func;",
        "const { isPromise, pickOthers, pickAttrsWith } = obj;",
        "const isRoot = pos => /^0-(\\d)+$/.test(pos);",
        "",
        "/**",
        " * Tree.Node",
        " */",
        "export default class TreeNode extends Component {",
        "    static propTypes = {",
        "        _key: PropTypes.string,",
        "        prefix: PropTypes.string,",
        "        rtl: PropTypes.bool,",
        "        className: PropTypes.string,",
        "        /**",
        "         * 树节点",
        "         */",
        "        children: PropTypes.node,",
        "        /**",
        "         * 节点文本内容",
        "         */",
        "        label: PropTypes.node,",
        "        /**",
        "         * 单独设置是否支持选中，覆盖 Tree 的 selectable",
        "         */",
        "        selectable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否出现复选框，覆盖 Tree 的 checkable",
        "         */",
        "        checkable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否支持编辑，覆盖 Tree 的 editable",
        "         */",
        "        editable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否支持拖拽，覆盖 Tree 的 draggable",
        "         */",
        "        draggable: PropTypes.bool,",
        "        /**",
        "         * 是否禁止节点响应",
        "         */",
        "        disabled: PropTypes.bool,",
        "        /**",
        "         * 是否禁止勾选节点复选框",
        "         */",
        "        checkboxDisabled: PropTypes.bool,",
        "        /**",
        "         * 是否是叶子节点，设置loadData时生效",
        "         */",
        "        isLeaf: PropTypes.bool,",
        "        root: PropTypes.object,",
        "        eventKey: PropTypes.string,",
        "        pos: PropTypes.string,",
        "        expanded: PropTypes.bool,",
        "        selected: PropTypes.bool,",
        "        checked: PropTypes.bool,",
        "        indeterminate: PropTypes.bool,",
        "        dragOver: PropTypes.bool,",
        "        dragOverGapTop: PropTypes.bool,",
        "        dragOverGapBottom: PropTypes.bool,",
        "        parentNode: PropTypes.object,",
        "        onKeyDown: PropTypes.func,",
        "        size: PropTypes.number,",
        "    };",
        "",
        "    static defaultProps = {",
        "        label: '---',",
        "        rtl: false,",
        "        disabled: false,",
        "        checkboxDisabled: false,",
        "        isLeaf: false,",
        "        size: 1,",
        "    };",
        "",
        "    constructor(props) {",
        "        super(props);",
        "",
        "        this.state = {",
        "            editing: false,",
        "            loading: false,",
        "            label: props.label,",
        "        };",
        "",
        "        bindCtx(this, [",
        "            'handleExpand',",
        "            'handleSelect',",
        "            'handleCheck',",
        "            'handleEditStart',",
        "            'handleEditFinish',",
        "            'handleRightClick',",
        "            'handleDragStart',",
        "            'handleDragEnter',",
        "            'handleDragOver',",
        "            'handleDragLeave',",
        "            'handleDragEnd',",
        "            'handleDrop',",
        "            'handleInputKeyDown',",
        "            'handleKeyDown',",
        "        ]);",
        "    }",
        "",
        "    componentDidMount() {",
        "        this.itemNode = findDOMNode(this.refs.node);",
        "        this.setFocus();",
        "    }",
        "",
        "    componentWillReceiveProps(nextProps) {",
        "        if ('label' in nextProps) {",
        "            this.setState({",
        "                label: nextProps.label,",
        "            });",
        "        }",
        "    }",
        "",
        "    componentDidUpdate() {",
        "        this.setFocus();",
        "    }",
        "",
        "    getParentNode() {",
        "        return this.props.root.getParentNode(this.props.pos);",
        "    }",
        "",
        "    focusable() {",
        "        const { root, disabled } = this.props;",
        "        const { focusable } = root.props;",
        "        return focusable && !disabled;",
        "    }",
        "",
        "    getFocused() {",
        "        const { _key, root } = this.props;",
        "        const { focusedKey } = root.state;",
        "        return focusedKey === _key;",
        "    }",
        "",
        "    setFocus() {",
        "        const focused = this.getFocused();",
        "        if (focused && this.focusable()) {",
        "            this.itemNode.focus({ preventScroll: true });",
        "        }",
        "    }",
        "",
        "    handleExpand(e) {",
        "        const { root, expanded, eventKey } = this.props;",
        "",
        "        if (root.props.isNodeBlock) {",
        "            e.stopPropagation();",
        "        }",
        "",
        "        const { loading } = this.state;",
        "        if (loading) {",
        "            return;",
        "        }",
        "",
        "        const returnValue = root.handleExpand(!expanded, eventKey, this);",
        "        if (isPromise(returnValue)) {",
        "            this.setLoading(true);",
        "            return returnValue.then(",
        "                () => {",
        "                    this.setLoading(false);",
        "                },",
        "                () => {",
        "                    this.setLoading(false);",
        "                }",
        "            );",
        "        }",
        "    }",
        "",
        "    setLoading(loading) {",
        "        this.setState({ loading });",
        "    }",
        "",
        "    handleSelect(e) {",
        "        e.preventDefault();",
        "",
        "        const { root, selected, eventKey } = this.props;",
        "        root.handleSelect(!selected, eventKey, this, e);",
        "    }",
        "",
        "    handleCheck() {",
        "        const { root, checked, eventKey } = this.props;",
        "        root.handleCheck(!checked, eventKey, this);",
        "    }",
        "",
        "    handleEditStart(e) {",
        "        e.preventDefault();",
        "",
        "        this.setState({",
        "            editing: true,",
        "        });",
        "    }",
        "",
        "    handleEditFinish(e) {",
        "        const label = e.target.value;",
        "",
        "        this.setState({",
        "            editing: false,",
        "            label,",
        "        });",
        "",
        "        const { root, eventKey } = this.props;",
        "        root.props.onEditFinish(eventKey, label, this);",
        "    }",
        "",
        "    handleRightClick(e) {",
        "        this.props.root.props.onRightClick({",
        "            event: e,",
        "            node: this,",
        "        });",
        "    }",
        "",
        "    handleDragStart(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragStart(e, this);",
        "    }",
        "",
        "    handleDragEnter(e) {",
        "        e.preventDefault();",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragEnter(e, this);",
        "    }",
        "",
        "    handleDragOver(e) {",
        "        if (this.props.root.canDrop(this)) {",
        "            e.preventDefault();",
        "",
        "            this.props.root.handleDragOver(e, this);",
        "        }",
        "        e.stopPropagation();",
        "    }",
        "",
        "    handleDragLeave(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragLeave(e, this);",
        "    }",
        "",
        "    handleDragEnd(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragEnd(e, this);",
        "    }",
        "",
        "    handleDrop(e) {",
        "        e.preventDefault();",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDrop(e, this);",
        "    }",
        "",
        "    handleInputKeyDown(e) {",
        "        if (e.keyCode === KEYCODE.ENTER) {",
        "            this.handleEditFinish(e);",
        "        }",
        "    }",
        "",
        "    handleKeyDown(e) {",
        "        const { _key, root, disabled } = this.props;",
        "        if (disabled) {",
        "            return;",
        "        }",
        "",
        "        if (this.focusable()) {",
        "            root.handleItemKeyDown(_key, this, e);",
        "        }",
        "",
        "        this.props.onKeyDown && this.props.onKeyDown(e);",
        "    }",
        "",
        "    addCallbacks(props) {",
        "        const { disabled, root } = this.props;",
        "        if (!disabled) {",
        "            const selectable =",
        "                typeof this.props.selectable !== 'undefined'",
        "                    ? this.props.selectable",
        "                    : root.props.selectable;",
        "            if (selectable) {",
        "                props.onClick = this.handleSelect;",
        "            }",
        "            const editable =",
        "                typeof this.props.editable !== 'undefined'",
        "                    ? this.props.editable",
        "                    : root.props.editable;",
        "            if (editable) {",
        "                props.onDoubleClick = this.handleEditStart;",
        "            }",
        "            const draggable =",
        "                typeof this.props.draggable !== 'undefined'",
        "                    ? this.props.draggable",
        "                    : root.props.draggable;",
        "            if (draggable) {",
        "                props.draggable = true;",
        "                props.onDragStart = this.handleDragStart;",
        "                props.onDragEnd = this.handleDragEnd;",
        "            }",
        "            props.onContextMenu = this.handleRightClick;",
        "        }",
        "    }",
        "",
        "    renderSwitcher() {",
        "        const { prefix, disabled, expanded, root } = this.props;",
        "        const { loadData } = root.props;",
        "        const { loading } = this.state;",
        "        const showLine = this.showLine;",
        "",
        "        const lineState = showLine ? 'line' : 'noline';",
        "        const className = cx({",
        "            [`${prefix}tree-switcher`]: true,",
        "            [`${prefix}${lineState}`]: !loading,",
        "            [`${prefix}close`]: !loading && !showLine && !expanded,",
        "            [`${prefix}disabled`]: disabled,",
        "            [`${prefix}loading`]: loading,",
        "            [`${prefix}loading-${lineState}`]: loading,",
        "        });",
        "        const iconType =",
        "            loadData && loading",
        "                ? 'loading'",
        "                : showLine",
        "                ? expanded",
        "                    ? 'minus'",
        "                    : 'add'",
        "                : 'arrow-down';",
        "",
        "        return (",
        "            // eslint-disable-next-line jsx-a11y/click-events-have-key-events",
        "            <span",
        "                className={className}",
        "                onClick={disabled ? null : this.handleExpand}",
        "            >",
        "                {this.renderRightAngle()}",
        "                <Icon",
        "                    className={`${prefix}tree-switcher-icon`}",
        "                    type={iconType}",
        "                />",
        "            </span>",
        "        );",
        "    }",
        "",
        "    renderNoopSwitcher() {",
        "        const { prefix, pos } = this.props;",
        "        const showLine = this.showLine;",
        "",
        "        const lineState = showLine ? 'line' : 'noline';",
        "        const className = cx({",
        "            [`${prefix}tree-switcher`]: true,",
        "            [`${prefix}noop-${lineState}`]: true,",
        "            [`${prefix}noop-line-noroot`]: showLine && !isRoot(pos),",
        "        });",
        "",
        "        return <span className={className}>{this.renderRightAngle()}</span>;",
        "    }",
        "",
        "    renderRightAngle() {",
        "        const { prefix, pos } = this.props;",
        "        return this.showLine && !isRoot(pos) ? (",
        "            <span className={`${prefix}tree-right-angle`} />",
        "        ) : null;",
        "    }",
        "",
        "    renderCheckbox() {",
        "        const {",
        "            checked,",
        "            indeterminate,",
        "            disabled,",
        "            checkboxDisabled,",
        "        } = this.props;",
        "        const { label } = this.state;",
        "",
        "        return (",
        "            <Checkbox",
        "                aria-label={typeof label === 'string' ? label : null}",
        "                checked={checked}",
        "                tabIndex={-1}",
        "                indeterminate={indeterminate}",
        "                disabled={disabled || checkboxDisabled}",
        "                onChange={this.handleCheck}",
        "            />",
        "        );",
        "    }",
        "",
        "    renderLabel() {",
        "        const { prefix, root, disabled } = this.props;",
        "        const { isNodeBlock } = root.props;",
        "        const { label } = this.state;",
        "        const selectable =",
        "            typeof this.props.selectable !== 'undefined'",
        "                ? this.props.selectable",
        "                : root.props.selectable;",
        "        const labelProps = {",
        "            className: cx({",
        "                [`${prefix}tree-node-label`]: true,",
        "                [`${prefix}tree-node-label-selectable`]:",
        "                    selectable && !disabled,",
        "            }),",
        "        };",
        "",
        "        if (!isNodeBlock) {",
        "            this.addCallbacks(labelProps);",
        "        }",
        "",
        "        return (",
        "            <div",
        "                className={`${prefix}tree-node-label-wrapper`}",
        "                ref=\"labelWrapper\"",
        "            >",
        "                <div {...labelProps}>{label}</div>",
        "            </div>",
        "        );",
        "    }",
        "",
        "    renderInput() {",
        "        const { prefix } = this.props;",
        "        const { label } = this.state;",
        "        return (",
        "            <div",
        "                className={`${prefix}tree-node-label-wrapper`}",
        "                ref=\"labelWrapper\"",
        "            >",
        "                <TreeNodeInput",
        "                    prefix={prefix}",
        "                    defaultValue={label}",
        "                    onBlur={this.handleEditFinish}",
        "                    onKeyDown={this.handleInputKeyDown}",
        "                />",
        "            </div>",
        "        );",
        "    }",
        "",
        "    renderChildTree(hasChildTree) {",
        "        const { prefix, children, expanded, root } = this.props;",
        "        const { animation, renderChildNodes } = root.props;",
        "",
        "        if (!expanded || !hasChildTree) {",
        "            return null;",
        "        }",
        "",
        "        let childTree;",
        "",
        "        if (renderChildNodes) {",
        "            childTree = renderChildNodes(children);",
        "        } else {",
        "            childTree = (",
        "                <ul role=\"group\" className={`${prefix}tree-child-tree`}>",
        "                    {children}",
        "                </ul>",
        "            );",
        "        }",
        "",
        "        if (animation) {",
        "            childTree = <Expand animationAppear={false}>{childTree}</Expand>;",
        "        }",
        "",
        "        return childTree;",
        "    }",
        "",
        "    render() {",
        "        const {",
        "            prefix,",
        "            rtl,",
        "            className,",
        "            children,",
        "            isLeaf,",
        "            root,",
        "            pos,",
        "            selected,",
        "            checked,",
        "            disabled,",
        "            expanded,",
        "            dragOver,",
        "            dragOverGapTop,",
        "            dragOverGapBottom,",
        "            _key,",
        "            size,",
        "        } = this.props;",
        "        const {",
        "            loadData,",
        "            isNodeBlock,",
        "            showLine,",
        "            draggable: rootDraggable,",
        "            filterTreeNode,",
        "        } = root.props;",
        "        const { label } = this.state;",
        "",
        "        this.showLine = !isNodeBlock && showLine;",
        "        const indexArr = pos.split('-');",
        "",
        "        const ARIA_PREFIX = 'aria-';",
        "        const ariaProps = pickAttrsWith(this.props, ARIA_PREFIX);",
        "        const others = pickOthers(Object.keys(TreeNode.propTypes), this.props);",
        "",
        "        // remove aria keys",
        "        Object.keys(others).forEach(key => {",
        "            if (key.match(ARIA_PREFIX)) {",
        "                delete others[key];",
        "            }",
        "        });",
        "",
        "        if (rootDraggable) {",
        "..."
    ],
    "src/tree/view/util.js": [
        "/* eslint-disable valid-jsdoc */",
        "export function normalizeToArray(keys) {",
        "    if (keys !== undefined && keys !== null) {",
        "        if (Array.isArray(keys)) {",
        "            return [...keys];",
        "        }",
        "",
        "        return [keys];",
        "    }",
        "",
        "    return [];",
        "}",
        "",
        "/**",
        " * 判断子节点是否是选中状态，如果 checkable={false} 则向下递归，",
        " * @param {Node} child",
        " * @param {Array} checkedKeys",
        " */",
        "export function isNodeChecked(node, checkedKeys) {",
        "    if (node.disabled || node.checkboxDisabled) return true;",
        "    /* istanbul ignore next */",
        "    if (node.checkable === false) {",
        "        return (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(c => isNodeChecked(c, checkedKeys))",
        "        );",
        "    }",
        "    return checkedKeys.indexOf(node.key) > -1;",
        "}",
        "",
        "/**",
        " * 遍历所有可用的子节点",
        " * @param {Node}",
        " * @param {Function} callback",
        " */",
        "export function forEachEnableNode(node, callback = () => {}) {",
        "    if (node.disabled || node.checkboxDisabled) return;",
        "    // eslint-disable-next-line callback-return",
        "    callback(node);",
        "    if (node.children && node.children.length > 0) {",
        "        node.children.forEach(child => forEachEnableNode(child, callback));",
        "    }",
        "}",
        "/**",
        " * 判断节点是否禁用checked",
        " * @param {Node} node",
        " * @returns {Boolean}",
        " */",
        "export function isNodeDisabledChecked(node) {",
        "    if (node.disabled || node.checkboxDisabled) return true;",
        "    /* istanbul ignore next */",
        "    if (node.checkable === false) {",
        "        return (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(isNodeDisabledChecked)",
        "        );",
        "    }",
        "",
        "    return false;",
        "}",
        "",
        "/**",
        " * 递归获取一个 checkable = {true} 的父节点，当 checkable={false} 时继续往上查找",
        " * @param {Node} node",
        " * @param {Map} _p2n",
        " * @return {Node}",
        " */",
        "export function getCheckableParentNode(node, _p2n) {",
        "    let parentPos = node.pos.split(['-']);",
        "    if (parentPos.length === 2) return node;",
        "    parentPos.splice(parentPos.length - 1, 1);",
        "    parentPos = parentPos.join('-');",
        "    const parentNode = _p2n[parentPos];",
        "    if (parentNode.disabled || parentNode.checkboxDisabled) return false;",
        "    /* istanbul ignore next */",
        "    if (parentNode.checkable === false) {",
        "        return getCheckableParentNode(parentNode, _p2n);",
        "    }",
        "",
        "    return parentNode;",
        "}",
        "/**",
        " * 过滤子节点",
        " * @param {Array} keys",
        " * @param {Object} _k2n",
        " */",
        "export function filterChildKey(keys, _k2n, _p2n) {",
        "    const newKeys = [];",
        "    keys.forEach(key => {",
        "        const node = getCheckableParentNode(_k2n[key], _p2n);",
        "        if (",
        "            !node ||",
        "            node.checkable === false ||",
        "            node === _k2n[key] ||",
        "            keys.indexOf(node.key) === -1",
        "        ) {",
        "            newKeys.push(key);",
        "        }",
        "    });",
        "    return newKeys;",
        "}",
        "",
        "export function filterParentKey(keys, _k2n) {",
        "    const newKeys = [];",
        "",
        "    for (let i = 0; i < keys.length; i++) {",
        "        const node = _k2n[keys[i]];",
        "        if (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(isNodeDisabledChecked)",
        "        ) {",
        "            newKeys.push(keys[i]);",
        "        }",
        "    }",
        "",
        "    return newKeys;",
        "}",
        "",
        "export function isDescendantOrSelf(currentPos, targetPos) {",
        "    if (!currentPos || !targetPos) {",
        "        return false;",
        "    }",
        "",
        "    const currentNums = currentPos.split('-');",
        "    const targetNums = targetPos.split('-');",
        "",
        "    return (",
        "        currentNums.length <= targetNums.length &&",
        "        currentNums.every((num, index) => {",
        "            return num === targetNums[index];",
        "        })",
        "    );",
        "}",
        "",
        "export function isSiblingOrSelf(currentPos, targetPos) {",
        "    const currentNums = currentPos.split('-').slice(0, -1);",
        "    const targetNums = targetPos.split('-').slice(0, -1);",
        "",
        "    return (",
        "        currentNums.length === targetNums.length &&",
        "        currentNums.every((num, index) => {",
        "            return num === targetNums[index];",
        "        })",
        "    );",
        "}",
        "",
        "// eslint-disable-next-line max-statements",
        "export function getAllCheckedKeys(checkedKeys, _k2n, _p2n) {",
        "    checkedKeys = normalizeToArray(checkedKeys);",
        "    const filteredKeys = checkedKeys.filter(key => !!_k2n[key]);",
        "    const flatKeys = [",
        "        ...filterChildKey(filteredKeys, _k2n, _p2n),",
        "        ...filteredKeys.filter(",
        "            key => _k2n[key].disabled || _k2n[key].checkboxDisabled",
        "        ),",
        "    ];",
        "    const removeKey = child => {",
        "        if (child.disabled || child.checkboxDisabled) return;",
        "        if (",
        "            child.checkable === false &&",
        "            child.children &&",
        "            child.children.length > 0",
        "        ) {",
        "            return child.children.forEach(removeKey);",
        "        }",
        "        flatKeys.splice(flatKeys.indexOf(child.key), 1);",
        "    };",
        "",
        "    const addParentKey = (i, parent) => flatKeys.splice(i, 0, parent.key);",
        "",
        "    const keys = [...flatKeys];",
        "    for (let i = 0; i < keys.length; i++) {",
        "        const pos = _k2n[keys[i]].pos;",
        "        const nums = pos.split('-');",
        "        if (nums.length === 2) {",
        "            break;",
        "        }",
        "        for (let j = nums.length - 2; j > 0; j--) {",
        "            const parentPos = nums.slice(0, j + 1).join('-');",
        "            const parent = _p2n[parentPos];",
        "            if (",
        "                parent.checkable === false ||",
        "                parent.disabled ||",
        "                parent.checkboxDisabled",
        "            )",
        "                continue;",
        "            const parentChecked = parent.children.every(child =>",
        "                isNodeChecked(child, flatKeys)",
        "            );",
        "            if (parentChecked) {",
        "                parent.children.forEach(removeKey);",
        "                addParentKey(i, parent);",
        "            } else {",
        "                break;",
        "            }",
        "        }",
        "    }",
        "",
        "    const newKeys = [];",
        "    flatKeys.forEach(key => {",
        "        if (_k2n[key].disabled || _k2n[key].checkboxDisabled) {",
        "            newKeys.push(key);",
        "            return;",
        "        }",
        "        forEachEnableNode(_k2n[key], node => {",
        "            if (node.checkable === false) return;",
        "            newKeys.push(node.key);",
        "        });",
        "    });",
        "",
        "    return newKeys;",
        "}"
    ]
}