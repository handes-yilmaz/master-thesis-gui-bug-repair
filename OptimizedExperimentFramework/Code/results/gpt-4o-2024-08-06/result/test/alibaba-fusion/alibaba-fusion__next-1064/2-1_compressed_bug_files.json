{
    "1": {
        "bug_file": "src/field/index.js",
        "compressed": "YES",
        "line_numbers": 796,
        "compressed_line_numbers": 170,
        "compressed_bug_file_content": "import ReactDOM from 'react-dom';\nimport { log, func } from '../util';\nimport Validate from '../validate';\n\nimport {\n\n\n        // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.\n        // Also used caching values when using `parseName: true` before a field is initialized\n\n\n    /**\n     * Controlled Component\n     * @param {String} name\n     * @param {Object} fieldOption\n     * @returns {Object} {value, onChange}\n     */\n\n\n            // here use typeof, in case of defaultValue={0}\n\n\n        // Controlled Component, should alwasy equal props.value\n\n\n            // When rerendering set the values from props.value\n\n\n        // should get value from this.values\n        /**\n         * a new field (value not in field)\n         * step 1: get value from this.values\n         * step 2: from defaultValue\n         */\n\n\n        // Component props\n\n\n            // trigger map\n\n\n            // validate hook\n\n\n        // onChange hack\n\n\n    /**\n     * event on props\n     * props.onChange props.onBlur\n     */\n\n\n    /**\n     * update field.value and validate\n     */\n\n\n        // validate while onChange\n\n\n    /**\n     * ref must always be the same function, or if not it will be triggerd every time.\n     * @param {String} name name of component\n     * @param {String} action key to find ref\n     * @param {Function} fn saveRef\n     */\n\n\n    /**\n     * NOTE: saveRef is async function. it will be called after render\n     * @param {String} name name of component\n     * @param {Function} component ref\n     */\n\n\n            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)\n            // while type changed, B will render before A unmount. so we should cached value for B\n            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render\n            // 1. _saveRef(A, null)\n\n\n            // after destroy, delete data\n\n\n        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)\n\n\n        // only one time here\n\n\n    /**\n     * validate one Component\n     * @param {String} name name of Component\n     * @param {Array} rule\n     * @param {String} trigger onChange/onBlur/onItemClick/...\n     */\n\n\n    /**\n     * 1. get values by names.\n     * 2. If no names passed, return shallow copy of `field.values`\n     * @param {Array} names\n     */\n\n\n            // NOTE: this is a shallow merge\n            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}\n\n\n                    // copy over values that are in this.values\n\n\n                    // if no value then copy values from fieldsMeta to keep initialized component data\n\n\n    /**\n     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate\n     * @param {Array} fieldNames\n     * @return {Object || null} map of inputs and their errors\n     */\n\n\n    /**\n     * validate by trigger\n     * @param {Array} ns names\n     * @param {Function} cb callback after validate\n     */\n\n\n                // clear error\n\n\n                // update error in every Field\n\n\n            // update to success which has no error\n\n\n            // eslint-disable-next-line callback-return\n\n\n    // deprecated. TODO: remove in 2.0 version\n\n\n    /**\n     * splice in a Array\n     * @param {String} keyMatch like name.{index}\n     * @param {Number} startIndex index\n     */\n\n\n        // regex to match field names in the same target array\n\n\n            // is name in the target array?\n\n\n        // should be continuous array\n\n\n                // if parseName=true then parent is an Array object but does not know an element was removed\n                // this manually decrements the array length\n\n\n    //trigger rerender\n\n\nexport default Field;\n"
    },
    "2": {
        "bug_file": "src/field/utils.js",
        "compressed": "NO",
        "line_numbers": 186,
        "compressed_line_numbers": 186,
        "compressed_bug_file_content": "import { isValidElement, cloneElement } from 'react';\n\n/**\n * 从组件事件中获取数据\n * @param e Event或者value\n * @returns value\n */\nexport function getValueFromEvent(e) {\n    // support custom element\n    if (!e || !e.target) {\n        return e;\n    }\n    const { target } = e;\n\n    if (target.type === 'checkbox') {\n        return target.checked;\n    } else if (target.type === 'radio') {\n        //兼容原生radioGroup\n        if (target.value) {\n            return target.value;\n        } else {\n            return target.checked;\n        }\n    }\n    return target.value;\n}\n\nfunction cloneAndAddKey(element) {\n    if (element && isValidElement(element)) {\n        return cloneElement(element, { key: 'error' });\n    }\n    return element;\n}\n\nexport function getErrorStrs(errors) {\n    if (errors) {\n        return errors.map(function(e) {\n            const message = e.message || e;\n            return cloneAndAddKey(message);\n        });\n    }\n    return errors;\n}\n\nexport function getParams(ns, cb) {\n    let names = typeof ns === 'string' ? [ns] : ns;\n    let callback = cb;\n    if (cb === undefined && typeof names === 'function') {\n        callback = names;\n        names = undefined;\n    }\n    return {\n        names,\n        callback,\n    };\n}\n\nconst setInWithPath = (state, value, path, pathIndex) => {\n    if (pathIndex >= path.length) {\n        return value;\n    }\n\n    const first = path[pathIndex];\n    const next = setInWithPath(\n        state && state[first],\n        value,\n        path,\n        pathIndex + 1\n    );\n\n    if (!state) {\n        const initialized = isNaN(first) ? {} : [];\n        initialized[first] = next;\n        return initialized;\n    }\n\n    if (Array.isArray(state)) {\n        const copy = [].concat(state);\n        copy[first] = next;\n        return copy;\n    }\n\n    return Object.assign({}, state, {\n        [first]: next,\n    });\n};\n\nexport function setIn(state, name, value) {\n    return setInWithPath(\n        state,\n        value,\n        name\n            .replace(/\\[/, '.')\n            .replace(/\\]/, '')\n            .split('.'),\n        0\n    );\n}\n\nexport function getIn(state, name) {\n    if (!state) {\n        return state;\n    }\n\n    const path = name\n        .replace(/\\[/, '.')\n        .replace(/\\]/, '')\n        .split('.');\n    const length = path.length;\n    if (!length) {\n        return undefined;\n    }\n\n    let result = state;\n    for (let i = 0; i < length && !!result; ++i) {\n        result = result[path[i]];\n    }\n\n    return result;\n}\n\nexport function deleteIn(state, name) {\n    if (!state) {\n        return;\n    }\n\n    const path = name\n        .replace(/\\[/, '.')\n        .replace(/\\]/, '')\n        .split('.');\n    const length = path.length;\n    if (!length) {\n        return state;\n    }\n\n    let result = state;\n    for (let i = 0; i < length && !!result; ++i) {\n        if (i === length - 1) {\n            delete result[path[i]];\n        } else {\n            result = result[path[i]];\n        }\n    }\n\n    return state;\n}\n\nfunction validateMap(rulesMap, rule, defaultTrigger) {\n    const nrule = Object.assign({}, rule);\n\n    if (!nrule.trigger) {\n        nrule.trigger = [defaultTrigger];\n    }\n\n    if (typeof nrule.trigger === 'string') {\n        nrule.trigger = [nrule.trigger];\n    }\n\n    for (let i = 0; i < nrule.trigger.length; i++) {\n        const trigger = nrule.trigger[i];\n\n        if (trigger in rulesMap) {\n            rulesMap[trigger].push(nrule);\n        } else {\n            rulesMap[trigger] = [nrule];\n        }\n    }\n\n    delete nrule.trigger;\n}\n\n/**\n * 提取rule里面的trigger并且做映射\n * @param  {Array} rules   规则\n * @param  {String} defaultTrigger 默认触发\n * @return {Object} {onChange:rule1, onBlur: rule2}\n */\nexport function mapValidateRules(rules, defaultTrigger) {\n    const rulesMap = {};\n\n    rules.forEach(rule => {\n        validateMap(rulesMap, rule, defaultTrigger);\n    });\n\n    return rulesMap;\n}"
    }
}