{
    "1": {
        "bug_file": "src/menu/view/group.jsx",
        "compressed": "NO",
        "line_numbers": 70,
        "compressed_line_numbers": 70,
        "compressed_bug_file_content": "import React, { Component, cloneElement } from 'react';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport Item from './item';\n\n/**\n * Menu.Group\n * @order 5\n */\nexport default class Group extends Component {\n    static menuChildType = 'group';\n\n    static propTypes = {\n        root: PropTypes.object,\n        className: PropTypes.string,\n        /**\n         * 标签内容\n         */\n        label: PropTypes.node,\n        /**\n         * 菜单项\n         */\n        children: PropTypes.node,\n        parentMode: PropTypes.oneOf(['inline', 'popup']),\n    };\n\n    render() {\n        const {\n            root,\n            className,\n            label,\n            children,\n            parentMode,\n            ...others\n        } = this.props;\n        const { prefix } = root.props;\n\n        const newClassName = cx({\n            [`${prefix}menu-group-label`]: true,\n            [className]: !!className,\n        });\n\n        const newChildren = children.map(child => {\n            const { className } = child.props;\n            const newChildClassName = cx({\n                [`${prefix}menu-group-item`]: true,\n                [className]: !!className,\n            });\n\n            return cloneElement(child, {\n                parentMode,\n                className: newChildClassName,\n            });\n        });\n\n        return [\n            <Item\n                key=\"menu-group-label\"\n                className={newClassName}\n                replaceClassName\n                root={root}\n                parentMode={parentMode}\n                {...others}\n            >\n                {label}\n            </Item>,\n            ...newChildren,\n        ];\n    }\n}"
    },
    "2": {
        "bug_file": "src/menu/view/item.jsx",
        "compressed": "NO",
        "line_numbers": 228,
        "compressed_line_numbers": 228,
        "compressed_bug_file_content": "import React, { Component, Children, isValidElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { func, obj, KEYCODE } from '../../util';\n\nconst { bindCtx } = func;\nconst { pickOthers } = obj;\n\nexport default class Item extends Component {\n    static propTypes = {\n        _key: PropTypes.string,\n        level: PropTypes.number,\n        groupIndent: PropTypes.number,\n        root: PropTypes.object,\n        menu: PropTypes.any,\n        parent: PropTypes.object,\n        parentMode: PropTypes.oneOf(['inline', 'popup']),\n        type: PropTypes.oneOf(['submenu', 'item']),\n        component: PropTypes.string,\n        disabled: PropTypes.bool,\n        className: PropTypes.string,\n        onClick: PropTypes.func,\n        onKeyDown: PropTypes.func,\n        needIndent: PropTypes.bool,\n        replaceClassName: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        component: 'li',\n        groupIndent: 0,\n        replaceClassName: false,\n        needIndent: true,\n    };\n\n    constructor(props) {\n        super(props);\n\n        bindCtx(this, ['handleClick', 'handleKeyDown']);\n    }\n\n    componentDidMount() {\n        this.itemNode = findDOMNode(this);\n\n        const { parentMode, root, menu } = this.props;\n        if (menu) {\n            this.menuNode = findDOMNode(menu);\n        } else if (parentMode === 'popup') {\n            this.menuNode = this.itemNode.parentNode;\n        } else {\n            this.menuNode = findDOMNode(root);\n            const { prefix, header, footer } = root.props;\n            if (header || footer) {\n                this.menuNode = this.menuNode.querySelector(\n                    `.${prefix}menu-content`\n                );\n            }\n        }\n\n        this.setFocus();\n    }\n\n    componentDidUpdate() {\n        this.setFocus();\n    }\n\n    focusable() {\n        const { root, type, disabled } = this.props;\n        const { focusable } = root.props;\n        return focusable && (type === 'submenu' || !disabled);\n    }\n\n    getFocused() {\n        const { _key, root } = this.props;\n        const { focusedKey } = root.state;\n        return focusedKey === _key;\n    }\n\n    setFocus() {\n        const focused = this.getFocused();\n        if (focused) {\n            if (this.focusable()) {\n                this.itemNode.focus({ preventScroll: true });\n            }\n            if (\n                this.menuNode &&\n                this.menuNode.scrollHeight > this.menuNode.clientHeight\n            ) {\n                const scrollBottom =\n                    this.menuNode.clientHeight + this.menuNode.scrollTop;\n                const itemBottom =\n                    this.itemNode.offsetTop + this.itemNode.offsetHeight;\n                if (itemBottom > scrollBottom) {\n                    this.menuNode.scrollTop =\n                        itemBottom - this.menuNode.clientHeight;\n                } else if (this.itemNode.offsetTop < this.menuNode.scrollTop) {\n                    this.menuNode.scrollTop = this.itemNode.offsetTop;\n                }\n            }\n        }\n    }\n\n    handleClick(e) {\n        e.stopPropagation();\n\n        const { _key, root, disabled } = this.props;\n\n        if (!disabled) {\n            root.handleItemClick(_key, this, e);\n\n            this.props.onClick && this.props.onClick(e);\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    handleKeyDown(e) {\n        const { _key, root, type } = this.props;\n\n        if (this.focusable()) {\n            root.handleItemKeyDown(_key, type, this, e);\n\n            switch (e.keyCode) {\n                case KEYCODE.ENTER: {\n                    if (!(type === 'submenu')) {\n                        this.handleClick(e);\n                    }\n                    break;\n                }\n            }\n        }\n\n        this.props.onKeyDown && this.props.onKeyDown(e);\n    }\n\n    getTitle(children) {\n        let labelString = '';\n\n        const loop = children => {\n            Children.forEach(children, child => {\n                if (isValidElement(child) && child.props.children) {\n                    loop(child.props.children);\n                } else if (typeof child === 'string') {\n                    labelString += child;\n                }\n            });\n        };\n\n        loop(children);\n\n        return labelString;\n    }\n\n    render() {\n        const {\n            level,\n            root,\n            replaceClassName,\n            groupIndent,\n            component,\n            disabled,\n            className,\n            children,\n            needIndent,\n            parentMode,\n            _key,\n        } = this.props;\n        const others = pickOthers(Object.keys(Item.propTypes), this.props);\n\n        const {\n            prefix,\n            focusable,\n            inlineIndent,\n            itemClassName,\n            rtl,\n        } = root.props;\n        const focused = this.getFocused();\n\n        const newClassName = replaceClassName\n            ? className\n            : cx({\n                  [`${prefix}menu-item`]: true,\n                  [`${prefix}disabled`]: disabled,\n                  [`${prefix}focused`]: !focusable && focused,\n                  [itemClassName]: !!itemClassName,\n                  [className]: !!className,\n              });\n        if (disabled) {\n            others['aria-disabled'] = true;\n            others['aria-hidden'] = true;\n        }\n\n        others.tabIndex = root.tabbableKey === _key ? '0' : '-1';\n\n        if (\n            parentMode === 'inline' &&\n            level > 1 &&\n            inlineIndent > 0 &&\n            needIndent\n        ) {\n            const paddingProp = rtl ? 'paddingRight' : 'paddingLeft';\n            others.style = {\n                ...(others.style || {}),\n                [paddingProp]: `${level * inlineIndent -\n                    (groupIndent || 0) * 0.4 * inlineIndent}px`,\n            };\n        }\n        const TagName = component;\n\n        let role = 'menuitem';\n        if ('selectMode' in root.props) {\n            role = 'listitem';\n        }\n\n        return (\n            <TagName\n                role={role}\n                title={this.getTitle(children)}\n                {...others}\n                className={newClassName}\n                onClick={this.handleClick}\n                onKeyDown={this.handleKeyDown}\n            >\n                <div className={`${prefix}menu-item-inner`}>{children}</div>\n            </TagName>\n        );\n    }\n}"
    },
    "3": {
        "bug_file": "src/menu/view/menu.jsx",
        "compressed": "YES",
        "line_numbers": 963,
        "compressed_line_numbers": 171,
        "compressed_bug_file_content": "import React, { Component, Children, cloneElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport SubMenu from './sub-menu';\nimport { func, obj, dom, events, KEYCODE } from '../../util';\nimport { getWidth } from './util';\n\n\n/**\n * Menu\n */\nexport default class Menu extends Component {\n\n\n        /**\n         * 菜单项和子菜单\n         */\n\n        /**\n         * 点击菜单项触发的回调函数\n         * @param {String} key 点击的菜单项的 key 值\n         * @param {Object} item 点击的菜单项对象\n         * @param {Object} event 点击的事件对象\n         */\n\n        /**\n         * 当前打开的子菜单的 key 值\n         */\n\n        /**\n         * 初始打开的子菜单的 key 值\n         */\n\n\n        /**\n         * 初始展开所有的子菜单，只在 mode 设置为 'inline' 以及 openMode 设置为 'multiple' 下生效，优先级高于 defaultOpenKeys\n         */\n\n        /**\n         * 打开或关闭子菜单触发的回调函数\n         * @param {String} key 打开的所有子菜单的 key 值\n         * @param {Object} extra 额外参数\n         * @param {String} extra.key 当前操作子菜单的 key 值\n         * @param {Boolean} extra.open 是否是打开\n         */\n\n        /**\n         * 子菜单打开的模式\n         */\n\n        /**\n         * 子菜单打开的触发行为\n         */\n\n        /**\n         * 展开内连子菜单的模式，同时可以展开一个子菜单还是多个子菜单，该属性仅在 mode 为 inline 时生效\n         */\n\n        /**\n         * 内连子菜单缩进距离\n         */\n\n\n        /**\n         * 是否自动让弹层的宽度和菜单项保持一致，如果弹层的宽度比菜单项小则和菜单项保持一致，如果宽度大于菜单项则不做处理\n         */\n\n        /**\n         * 弹层的对齐方式\n         */\n\n        /**\n         * 弹层自定义 props\n         */\n\n        /**\n         * 弹出子菜单自定义 className\n         */\n\n        /**\n         * 弹出子菜单自定义 style\n         */\n\n        /**\n         * 当前选中菜单项的 key 值\n         */\n\n        /**\n         * 初始选中菜单项的 key 值\n         */\n\n\n        /**\n         * 选中或取消选中菜单项触发的回调函数\n         * @param {Array} selectedKeys 选中的所有菜单项的值\n         * @param {Object} item 选中或取消选中的菜单项\n         * @param {Object} extra 额外参数\n         * @param {Boolean} extra.select 是否是选中\n         * @param {Array} extra.key 菜单项的 key\n         * @param {Object} extra.label 菜单项的文本\n         * @param {Array} extra.keyPath 菜单项 key 的路径\n         */\n\n        /**\n         * 选中模式，单选还是多选，默认无值，不可选\n         */\n\n        /**\n         * 是否只能选择第一层菜单项（不能选择子菜单中的菜单项）\n         */\n\n        /**\n         * 是否显示选中图标，如果设置为 false 需配合配置平台设置选中时的背景色以示区分\n         */\n\n\n        /**\n         * 是否将选中图标居右，仅当 hasSelectedIcon 为true 时生效。\n         * 注意：SubMenu 上的选中图标一直居左，不受此API控制\n         */\n\n        /**\n         * 菜单第一层展示方向\n         */\n\n        /**\n         * 横向菜单条 item 和 footer 的对齐方向，在 direction 设置为 'hoz' 并且 header 存在时生效\n         */\n\n        /**\n         * 横向菜单模式下，是否维持在一行，即超出一行折叠成 SubMenu 显示， 仅在 direction='hoz' mode='popup' 时生效\n         */\n\n        /**\n         * 自定义菜单头部\n         */\n\n        /**\n         * 自定义菜单尾部\n         */\n\n        /**\n         * 是否自动获得焦点\n         */\n\n        /**\n         * 当前获得焦点的子菜单或菜单项 key 值\n         */\n\n\n        /**\n         * 是否开启嵌入式模式，一般用于Layout的布局中，开启后没有默认背景、外层border、box-shadow，可以配合`<Menu style={{lineHeight: '100px'}}>` 自定义高度\n         */\n\n\n        // keep placehold to get width\n\n\n            // indicators which not in use, just display: none\n\n\n                        // `React.forwardRef(render)` returns a forwarding\n                        // object that includes `render` method, and the specific\n                        // `child.type` will be an object instead of a class or\n                        // function.\n\n\n                        // filter out duplicate keys\n\n\n"
    },
    "4": {
        "bug_file": "src/menu/view/sub-menu.jsx",
        "compressed": "NO",
        "line_numbers": 283,
        "compressed_line_numbers": 283,
        "compressed_bug_file_content": "import React, { Component, Children, cloneElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport Animate from '../../animate';\nimport Icon from '../../icon';\nimport { func, obj } from '../../util';\nimport Item from './item';\nimport SelectabelItem from './selectable-item';\nimport PopupItem from './popup-item';\n\nconst { Expand } = Animate;\nconst { bindCtx } = func;\n\n/**\n * Menu.SubMenu\n * @order 1\n */\nexport default class SubMenu extends Component {\n    static menuChildType = 'submenu';\n\n    static propTypes = {\n        _key: PropTypes.string,\n        root: PropTypes.object,\n        level: PropTypes.number,\n        groupIndent: PropTypes.number,\n        noIcon: PropTypes.bool,\n        /**\n         * 标签内容\n         */\n        label: PropTypes.node,\n        /**\n         * 是否可选，该属性仅在设置 Menu 组件 selectMode 属性后生效\n         */\n        selectable: PropTypes.bool,\n        /**\n         * 子菜单打开方式，如果设置会覆盖 Menu 上的同名属性\n         * @default Menu 的 mode 属性值\n         */\n        mode: PropTypes.oneOf(['inline', 'popup']),\n        /**\n         * 菜单项或下一级子菜单\n         */\n        children: PropTypes.node,\n        onMouseEnter: PropTypes.func,\n        onMouseLeave: PropTypes.func,\n        subMenuContentClassName: PropTypes.string,\n        triggerType: PropTypes.oneOf(['click', 'hover']),\n        align: PropTypes.oneOf(['outside', 'follow']),\n        parentMode: PropTypes.oneOf(['inline', 'popup']),\n    };\n\n    static defaultProps = {\n        groupIndent: 0,\n        noIcon: false,\n        selectable: false,\n    };\n\n    constructor(props) {\n        super(props);\n\n        bindCtx(this, [\n            'handleMouseEnter',\n            'handleMouseLeave',\n            'handleClick',\n            'handleOpen',\n            'afterLeave',\n        ]);\n    }\n\n    componentDidMount() {\n        this.itemNode = findDOMNode(this);\n    }\n\n    afterLeave() {\n        const { focused, root } = this.props;\n        const { focusable } = root.props;\n        if (focusable && focused) {\n            this.itemNode.focus();\n        }\n    }\n\n    getOpen() {\n        const { _key, root } = this.props;\n        const { openKeys } = root.state;\n\n        return openKeys.indexOf(_key) > -1;\n    }\n\n    handleMouseEnter(e) {\n        this.handleOpen(true);\n\n        this.props.onMouseEnter && this.props.onMouseEnter(e);\n    }\n\n    handleMouseLeave(e) {\n        this.handleOpen(false);\n\n        this.props.onMouseLeave && this.props.onMouseLeave(e);\n    }\n\n    handleClick(e) {\n        const { root, selectable } = this.props;\n        const { selectMode } = root.props;\n        if (selectMode && selectable) {\n            e.stopPropagation();\n        }\n\n        const open = this.getOpen();\n        this.handleOpen(!open);\n    }\n\n    handleOpen(open, triggerType, e) {\n        const { _key, root } = this.props;\n        root.handleOpen(_key, open, triggerType, e);\n    }\n\n    passParentToChildren(children) {\n        const { mode, root } = this.props;\n\n        return Children.map(children, child => {\n            return cloneElement(child, {\n                parent: this,\n                parentMode: mode || root.props.mode,\n            });\n        });\n    }\n\n    renderInline() {\n        const {\n            _key,\n            level,\n            root,\n            className,\n            selectable: selectableFromProps,\n            label,\n            children,\n            noIcon,\n            subMenuContentClassName,\n            triggerType: propsTriggerType,\n            parentMode,\n        } = this.props;\n        const {\n            prefix,\n            selectMode,\n            triggerType: rootTriggerType,\n            inlineArrowDirection,\n            expandAnimation,\n            rtl,\n        } = root.props;\n        const triggerType = propsTriggerType || rootTriggerType;\n        const open = this.getOpen();\n        const others = obj.pickOthers(\n            Object.keys(SubMenu.propTypes),\n            this.props\n        );\n\n        const liProps = {\n            className: cx({\n                [`${prefix}menu-sub-menu-wrapper`]: true,\n                [className]: !!className,\n            }),\n        };\n        const itemProps = {\n            'aria-expanded': open,\n            _key,\n            level,\n            root,\n            type: 'submenu',\n            component: 'div',\n            parentMode,\n        };\n        const arrorProps = {\n            type:\n                inlineArrowDirection === 'right' ? 'arrow-right' : 'arrow-down',\n            className: cx({\n                [`${prefix}menu-icon-arrow`]: true,\n                [`${prefix}menu-icon-arrow-down`]:\n                    inlineArrowDirection === 'down',\n                [`${prefix}menu-icon-arrow-right`]:\n                    inlineArrowDirection === 'right',\n                [`${prefix}open`]: open,\n            }),\n        };\n\n        const selectable = !!selectMode && selectableFromProps;\n        const NewItem = selectable ? SelectabelItem : Item;\n\n        if (triggerType === 'hover') {\n            liProps.onMouseEnter = this.handleMouseEnter;\n            liProps.onMouseLeave = this.handleMouseLeave;\n        } else if (selectable) {\n            arrorProps.onClick = this.handleClick;\n        } else {\n            itemProps.onClick = this.handleClick;\n        }\n        if (open) {\n            itemProps.className = `${prefix}opened`;\n        }\n\n        const newSubMenuContentClassName = cx({\n            [`${prefix}menu-sub-menu`]: true,\n            [subMenuContentClassName]: !!subMenuContentClassName,\n        });\n\n        let roleMenu = 'menu',\n            roleItem = 'menuitem';\n        if ('selectMode' in root.props) {\n            roleMenu = 'listbox';\n            roleItem = 'listitem';\n        }\n\n        const subMenu = open ? (\n            <ul\n                role={roleMenu}\n                dir={rtl ? 'rtl' : undefined}\n                ref=\"subMenu\"\n                className={newSubMenuContentClassName}\n            >\n                {this.passParentToChildren(children)}\n            </ul>\n        ) : null;\n\n        return (\n            <li role={roleItem} {...others} {...liProps}>\n                <NewItem {...itemProps}>\n                    <span className={`${prefix}menu-item-text`}>{label}</span>\n                    {noIcon ? null : <Icon {...arrorProps} />}\n                </NewItem>\n                {expandAnimation ? (\n                    <Expand\n                        animationAppear={false}\n                        afterLeave={this.afterLeave}\n                    >\n                        {subMenu}\n                    </Expand>\n                ) : (\n                    subMenu\n                )}\n            </li>\n        );\n    }\n\n    renderPopup() {\n        const {\n            children,\n            subMenuContentClassName,\n            noIcon,\n            ...others\n        } = this.props;\n        const root = this.props.root;\n        const { prefix, popupClassName, popupStyle, rtl } = root.props;\n\n        const newClassName = cx({\n            [`${prefix}menu`]: true,\n            [`${prefix}ver`]: true,\n            [popupClassName]: !!popupClassName,\n            [subMenuContentClassName]: !!subMenuContentClassName,\n        });\n\n        others.rtl = rtl;\n\n        return (\n            <PopupItem {...others} noIcon={noIcon} hasSubMenu>\n                <ul\n                    role=\"menu\"\n                    dir={rtl ? 'rtl' : undefined}\n                    className={newClassName}\n                    style={popupStyle}\n                >\n                    {this.passParentToChildren(children)}\n                </ul>\n            </PopupItem>\n        );\n    }\n\n    render() {\n        const { mode, root } = this.props;\n        const newMode = mode || root.props.mode;\n\n        return newMode === 'popup' ? this.renderPopup() : this.renderInline();\n    }\n}"
    },
    "5": {
        "bug_file": "src/menu/view/util.js",
        "compressed": "NO",
        "line_numbers": 10,
        "compressed_line_numbers": 10,
        "compressed_bug_file_content": "export const getWidth = elem => {\n    let width =\n        elem &&\n        typeof elem.getBoundingClientRect === 'function' &&\n        elem.getBoundingClientRect().width;\n    if (width) {\n        width = +width.toFixed(6);\n    }\n    return width || 0;\n};"
    }
}