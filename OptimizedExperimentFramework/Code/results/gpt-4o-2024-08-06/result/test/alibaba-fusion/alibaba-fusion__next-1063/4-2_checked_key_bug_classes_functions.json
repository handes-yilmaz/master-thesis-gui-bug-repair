{
    "bug_classes": {
        "1": {
            "class_name": "Field (not found) 21-521",
            "file_path": "src/field/index.js",
            "class_details": [
                {
                    "name": "Field",
                    "start_line": 21,
                    "end_line": 521
                }
            ],
            "class_code": [
                "class Field {",
                "    constructor(com, options = {}) {",
                "        if (!com) {",
                "            log.warning(",
                "                '`this` is missing in `Field`, you should use like `new Field(this)`'",
                "            );",
                "        }",
                "",
                "        this.com = com;",
                "        this.fieldsMeta = {};",
                "        this.cachedBind = {};",
                "        this.instance = {};",
                "        // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.",
                "        // Also used caching values when using `parseName: true` before a field is initialized",
                "        this.values = options.values || {};",
                "",
                "        this.options = Object.assign(",
                "            {",
                "                parseName: false,",
                "                forceUpdate: false,",
                "                scrollToFirstError: true,",
                "                first: false,",
                "                onChange: func.noop,",
                "                autoUnmount: true,",
                "                autoValidate: true,",
                "            },",
                "            options",
                "        );",
                "",
                "        [",
                "            'init',",
                "            'getValue',",
                "            'getValues',",
                "            'setValue',",
                "            'setValues',",
                "            'getError',",
                "            'getErrors',",
                "            'setError',",
                "            'setErrors',",
                "            'validate',",
                "            'getState',",
                "            'reset',",
                "            'resetToDefault',",
                "            'remove',",
                "            'spliceArray',",
                "        ].forEach(m => {",
                "            this[m] = this[m].bind(this);",
                "        });",
                "",
                "        if (options.values) {",
                "            this.setValues(options.values, false);",
                "        }",
                "    }",
                "",
                "    setOptions(options) {",
                "        Object.assign(this.options, options);",
                "    }",
                "",
                "    /**",
                "     * Controlled Component",
                "     * @param {String} name",
                "     * @param {Object} fieldOption",
                "     * @returns {Object} {value, onChange}",
                "     */",
                "    init(name, fieldOption = {}, rprops) {",
                "        const {",
                "            initValue,",
                "            valueName = 'value',",
                "            trigger = 'onChange',",
                "            rules = [],",
                "            props = {},",
                "            getValueFromEvent = null,",
                "            autoValidate = true,",
                "        } = fieldOption;",
                "        const { parseName } = this.options;",
                "",
                "        const originalProps = Object.assign({}, props, rprops);",
                "        const defaultValueName = `default${valueName[0].toUpperCase()}${valueName.slice(",
                "            1",
                "        )}`;",
                "",
                "        const field = this._getInitMeta(name);",
                "        let defaultValue;",
                "        if (typeof initValue !== 'undefined') {",
                "            defaultValue = initValue;",
                "        } else if (typeof originalProps[defaultValueName] !== 'undefined') {",
                "            // here use typeof, in case of defaultValue={0}",
                "            defaultValue = originalProps[defaultValueName];",
                "        }",
                "",
                "        Object.assign(field, {",
                "            valueName,",
                "            initValue: defaultValue,",
                "            disabled:",
                "                'disabled' in originalProps ? originalProps.disabled : false,",
                "            getValueFromEvent,",
                "            rules: Array.isArray(rules) ? rules : [rules],",
                "            ref: originalProps.ref,",
                "        });",
                "",
                "        // Controlled Component, should alwasy equal props.value",
                "        if (valueName in originalProps) {",
                "            field.value = originalProps[valueName];",
                "",
                "            // When rerendering set the values from props.value",
                "            if (parseName) {",
                "                this.values = setIn(this.values, name, field.value);",
                "            } else {",
                "                this.values[name] = field.value;",
                "            }",
                "        }",
                "",
                "        // should get value from this.values",
                "        /**",
                "         * a new field (value not in field)",
                "         * step 1: get value from this.values",
                "         * step 2: from defaultValue",
                "         */",
                "        if (!('value' in field)) {",
                "            if (parseName) {",
                "                const cachedValue = getIn(this.values, name);",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            } else {",
                "                const cachedValue = this.values[name];",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            }",
                "        }",
                "",
                "        if (parseName && !getIn(this.values, name)) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else if (!parseName && !this.values[name]) {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        // Component props",
                "        const inputProps = {",
                "            'data-meta': 'Field',",
                "            id: name,",
                "            ref: this._getCacheBind(name, `${name}__ref`, this._saveRef),",
                "            [valueName]: field.value,",
                "        };",
                "",
                "        let rulesMap = {};",
                "",
                "        if (this.options.autoValidate && autoValidate !== false) {",
                "            // trigger map",
                "            rulesMap = mapValidateRules(field.rules, trigger);",
                "",
                "            // validate hook",
                "            for (const action in rulesMap) {",
                "                if (action === trigger) {",
                "                    continue;",
                "                }",
                "",
                "                const actionRule = rulesMap[action];",
                "                inputProps[action] = (...args) => {",
                "                    this._validate(name, actionRule, action);",
                "                    this._callPropsEvent(action, originalProps, ...args);",
                "                    this._reRender();",
                "                };",
                "            }",
                "        }",
                "",
                "        // onChange hack",
                "        inputProps[trigger] = (...args) => {",
                "            this._callOnChange(name, rulesMap[trigger], trigger, ...args);",
                "            this._callPropsEvent(trigger, originalProps, ...args);",
                "            this.options.onChange(name, field.value);",
                "            this._reRender();",
                "        };",
                "",
                "        delete originalProps[defaultValueName];",
                "",
                "        return Object.assign({}, originalProps, inputProps);",
                "    }",
                "",
                "    /**",
                "     * event on props",
                "     * props.onChange props.onBlur",
                "     */",
                "    _callPropsEvent(action, props, ...args) {",
                "        action in props &&",
                "            typeof props[action] === 'function' &&",
                "            props[action](...args);",
                "    }",
                "",
                "    _getInitMeta(name) {",
                "        if (!(name in this.fieldsMeta)) {",
                "            this.fieldsMeta[name] = Object.assign({}, initMeta);",
                "        }",
                "",
                "        return this.fieldsMeta[name];",
                "    }",
                "",
                "    /**",
                "     * update field.value and validate",
                "     */",
                "    _callOnChange(name, rule, trigger, ...others) {",
                "        const e = others[0];",
                "        const field = this._get(name);",
                "",
                "        if (!field) {",
                "            return;",
                "        }",
                "",
                "        field.value = field.getValueFromEvent",
                "            ? field.getValueFromEvent.apply(this, others)",
                "            : getValueFromEvent(e);",
                "",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        this._resetError(name);",
                "",
                "        // validate while onChange",
                "        rule && this._validate(name, rule, trigger);",
                "    }",
                "",
                "    /**",
                "     * ref must always be the same function, or if not it will be triggerd every time.",
                "     * @param {String} name name of component",
                "     * @param {String} action key to find ref",
                "     * @param {Function} fn saveRef",
                "     */",
                "    _getCacheBind(name, action, fn) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        if (!cache[action]) {",
                "            cache[action] = fn.bind(this, name);",
                "        }",
                "        return cache[action];",
                "    }",
                "",
                "    _setCache(name, action, hander) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        cache[action] = hander;",
                "    }",
                "",
                "    _getCache(name, action) {",
                "        const cache = this.cachedBind[name] || {};",
                "        return cache[action];",
                "    }",
                "",
                "    /**",
                "     * NOTE: saveRef is async function. it will be called after render",
                "     * @param {String} name name of component",
                "     * @param {Function} component ref",
                "     */",
                "    _saveRef(name, component) {",
                "        const key = `${name}_field`;",
                "        const autoUnmount = this.options.autoUnmount;",
                "",
                "        if (!component && autoUnmount) {",
                "            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)",
                "            // while type changed, B will render before A unmount. so we should cached value for B",
                "            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render",
                "            // 1. _saveRef(A, null)",
                "            const cache = this.fieldsMeta[name];",
                "            this._setCache(name, key, cache);",
                "            // after destroy, delete data",
                "            delete this.instance[name];",
                "            this.remove(name);",
                "            return;",
                "        }",
                "",
                "        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)",
                "        if (autoUnmount && !this.fieldsMeta[name]) {",
                "            this.fieldsMeta[name] = this._getCache(name, key);",
                "            this.setValue(",
                "                name,",
                "                this.fieldsMeta[name] && this.fieldsMeta[name].value,",
                "                false",
                "            );",
                "        }",
                "",
                "        // only one time here",
                "        const field = this._get(name);",
                "        if (field) {",
                "            const ref = field.ref;",
                "            if (ref) {",
                "                if (typeof ref === 'string') {",
                "                    throw new Error(`can not set string ref for ${name}`);",
                "                }",
                "                ref(component);",
                "            }",
                "",
                "            this.instance[name] = component;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * validate one Component",
                "     * @param {String} name name of Component",
                "     * @param {Array} rule",
                "     * @param {String} trigger onChange/onBlur/onItemClick/...",
                "     */",
                "    _validate(name, rule, trigger) {",
                "        const field = this._get(name);",
                "        const value = field.value;",
                "",
                "        field.state = 'loading';",
                "",
                "        let validate = this._getCache(name, trigger);",
                "        validate && validate.abort();",
                "",
                "        validate = new Validate({",
                "            [name]: rule,",
                "        });",
                "        this._setCache(name, trigger, validate);",
                "",
                "        validate.validate(",
                "            {",
                "                [name]: value,",
                "            },",
                "            errors => {",
                "                if (errors && errors.length) {",
                "                    field.errors = getErrorStrs(errors);",
                "                    field.state = 'error';",
                "                } else {",
                "                    field.errors = [];",
                "                    field.state = 'success';",
                "                }",
                "",
                "                this._reRender();",
                "            }",
                "        );",
                "    }",
                "",
                "    getValue(name) {",
                "        if (this.options.parseName) {",
                "            return getIn(this.values, name);",
                "        }",
                "        return this.values[name];",
                "    }",
                "",
                "    /**",
                "     * 1. get values by names.",
                "     * 2. If no names passed, return shallow copy of `field.values`",
                "     * @param {Array} names",
                "     */",
                "    getValues(names) {",
                "        const allValues = {};",
                "",
                "        if (names && names.length) {",
                "            names.forEach(name => {",
                "                allValues[name] = this.getValue(name);",
                "            });",
                "        } else {",
                "            Object.assign(allValues, this.values);",
                "        }",
                "",
                "        return allValues;",
                "    }",
                "",
                "    setValue(name, value, reRender = true) {",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].value = value;",
                "        }",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, value);",
                "        } else {",
                "            this.values[name] = value;",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setValues(fieldsValue = {}, reRender = true) {",
                "        if (!this.options.parseName) {",
                "            Object.keys(fieldsValue).forEach(name => {",
                "                this.setValue(name, fieldsValue[name], false);",
                "            });",
                "        } else {",
                "            // NOTE: this is a shallow merge",
                "            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}",
                "            this.values = Object.assign({}, this.values, fieldsValue);",
                "            const fields = this.getNames();",
                "            fields.forEach(name => {",
                "                const value = getIn(this.values, name);",
                "                if (value !== undefined) {",
                "                    // copy over values that are in this.values",
                "                    this.fieldsMeta[name].value = value;",
                "                } else {",
                "                    // if no value then copy values from fieldsMeta to keep initialized component data",
                "                    this.values = setIn(",
                "                        this.values,",
                "                        name,",
                "                        this.fieldsMeta[name].value",
                "                    );",
                "                }",
                "            });",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setError(name, errors) {",
                "        const err = Array.isArray(errors) ? errors : errors ? [errors] : [];",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].errors = err;",
                "        } else {",
                "            this.fieldsMeta[name] = {",
                "                errors: err,",
                "            };",
                "        }",
                "",
                "        if (",
                "            this.fieldsMeta[name].errors &&",
                "            this.fieldsMeta[name].errors.length > 0",
                "        ) {",
                "            this.fieldsMeta[name].state = 'error';",
                "        } else {",
                "            this.fieldsMeta[name].state = '';",
                "        }",
                "",
                "        this._reRender();",
                "    }",
                "",
                "    setErrors(fieldsErrors = {}) {",
                "        Object.keys(fieldsErrors).forEach(name => {",
                "            this.setError(name, fieldsErrors[name]);",
                "        });",
                "    }",
                "",
                "    getError(name) {",
                "        const field = this._get(name);",
                "        if (field && field.errors && field.errors.length) {",
                "            return field.errors;",
                "        }",
                "",
                "        return null;",
                "    }",
                "",
                "    getErrors(names) {",
                "        const fields = names || this.getNames();",
                "        const allErrors = {};",
                "        fields.forEach(f => {",
                "            allErrors[f] = this.getError(f);",
                "        });",
                "        return allErrors;",
                "    }",
                "",
                "    getState(name) {",
                "        const field = this._get(name);",
                "",
                "        if (field && field.state) {",
                "            return field.state;",
                "        }",
                "",
                "        return '';",
                "    }",
                "",
                "    /**",
                "     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate",
                "     * @param {Array} fieldNames",
                "     * @return {Object || null} map of inputs and their errors",
                "     */",
                "    formatGetErrors(fieldNames) {",
                "        const errors = this.getErrors(fieldNames);",
                "        let formattedErrors = null;",
                "        for (const field in errors) {",
                "            if (errors.hasOwnProperty(field) && errors[field]) {",
                "                const errorsObj = errors[field];",
                "                if (!formattedErrors) {",
                "                    formattedErrors = {};",
                "                }",
                "                formattedErrors[field] = { errors: errorsObj };",
                "            }",
                "        }",
                "        return formattedErrors;",
                "    }",
                "",
                "    /**",
                "     * validate by trigger",
                "     * @param {Array} ns names",
                "     * @param {Function} cb callback after validate",
                "     */",
                "    validate(ns, cb) {",
                "        const { names, callback } = getParams(ns, cb);",
                "        const fieldNames = names || this.getNames();",
                "",
                "        const descriptor = {};",
                "        const values = {};",
                "",
                "        let hasRule = false;",
                "        for (let i = 0; i < fieldNames.length; i++) {",
                "            const name = fieldNames[i];",
                "            const field = this._get(name);",
                "",
                "            if (!field) {",
                "                continue;",
                "            }",
                "",
                "            if (field.rules && field.rules.length) {",
                "                descriptor[name] = field.rules;"
            ]
        }
    },
    "bug_functions": {
        "2": {
            "function_name": "Field (not found) 21-521",
            "file_path": "src/field/index.js",
            "function_details": [
                {
                    "name": "Field",
                    "start_line": 21,
                    "end_line": 521
                }
            ],
            "function_code": [
                "class Field {",
                "    constructor(com, options = {}) {",
                "        if (!com) {",
                "            log.warning(",
                "                '`this` is missing in `Field`, you should use like `new Field(this)`'",
                "            );",
                "        }",
                "",
                "        this.com = com;",
                "        this.fieldsMeta = {};",
                "        this.cachedBind = {};",
                "        this.instance = {};",
                "        // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.",
                "        // Also used caching values when using `parseName: true` before a field is initialized",
                "        this.values = options.values || {};",
                "",
                "        this.options = Object.assign(",
                "            {",
                "                parseName: false,",
                "                forceUpdate: false,",
                "                scrollToFirstError: true,",
                "                first: false,",
                "                onChange: func.noop,",
                "                autoUnmount: true,",
                "                autoValidate: true,",
                "            },",
                "            options",
                "        );",
                "",
                "        [",
                "            'init',",
                "            'getValue',",
                "            'getValues',",
                "            'setValue',",
                "            'setValues',",
                "            'getError',",
                "            'getErrors',",
                "            'setError',",
                "            'setErrors',",
                "            'validate',",
                "            'getState',",
                "            'reset',",
                "            'resetToDefault',",
                "            'remove',",
                "            'spliceArray',",
                "        ].forEach(m => {",
                "            this[m] = this[m].bind(this);",
                "        });",
                "",
                "        if (options.values) {",
                "            this.setValues(options.values, false);",
                "        }",
                "    }",
                "",
                "    setOptions(options) {",
                "        Object.assign(this.options, options);",
                "    }",
                "",
                "    /**",
                "     * Controlled Component",
                "     * @param {String} name",
                "     * @param {Object} fieldOption",
                "     * @returns {Object} {value, onChange}",
                "     */",
                "    init(name, fieldOption = {}, rprops) {",
                "        const {",
                "            initValue,",
                "            valueName = 'value',",
                "            trigger = 'onChange',",
                "            rules = [],",
                "            props = {},",
                "            getValueFromEvent = null,",
                "            autoValidate = true,",
                "        } = fieldOption;",
                "        const { parseName } = this.options;",
                "",
                "        const originalProps = Object.assign({}, props, rprops);",
                "        const defaultValueName = `default${valueName[0].toUpperCase()}${valueName.slice(",
                "            1",
                "        )}`;",
                "",
                "        const field = this._getInitMeta(name);",
                "        let defaultValue;",
                "        if (typeof initValue !== 'undefined') {",
                "            defaultValue = initValue;",
                "        } else if (typeof originalProps[defaultValueName] !== 'undefined') {",
                "            // here use typeof, in case of defaultValue={0}",
                "            defaultValue = originalProps[defaultValueName];",
                "        }",
                "",
                "        Object.assign(field, {",
                "            valueName,",
                "            initValue: defaultValue,",
                "            disabled:",
                "                'disabled' in originalProps ? originalProps.disabled : false,",
                "            getValueFromEvent,",
                "            rules: Array.isArray(rules) ? rules : [rules],",
                "            ref: originalProps.ref,",
                "        });",
                "",
                "        // Controlled Component, should alwasy equal props.value",
                "        if (valueName in originalProps) {",
                "            field.value = originalProps[valueName];",
                "",
                "            // When rerendering set the values from props.value",
                "            if (parseName) {",
                "                this.values = setIn(this.values, name, field.value);",
                "            } else {",
                "                this.values[name] = field.value;",
                "            }",
                "        }",
                "",
                "        // should get value from this.values",
                "        /**",
                "         * a new field (value not in field)",
                "         * step 1: get value from this.values",
                "         * step 2: from defaultValue",
                "         */",
                "        if (!('value' in field)) {",
                "            if (parseName) {",
                "                const cachedValue = getIn(this.values, name);",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            } else {",
                "                const cachedValue = this.values[name];",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            }",
                "        }",
                "",
                "        if (parseName && !getIn(this.values, name)) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else if (!parseName && !this.values[name]) {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        // Component props",
                "        const inputProps = {",
                "            'data-meta': 'Field',",
                "            id: name,",
                "            ref: this._getCacheBind(name, `${name}__ref`, this._saveRef),",
                "            [valueName]: field.value,",
                "        };",
                "",
                "        let rulesMap = {};",
                "",
                "        if (this.options.autoValidate && autoValidate !== false) {",
                "            // trigger map",
                "            rulesMap = mapValidateRules(field.rules, trigger);",
                "",
                "            // validate hook",
                "            for (const action in rulesMap) {",
                "                if (action === trigger) {",
                "                    continue;",
                "                }",
                "",
                "                const actionRule = rulesMap[action];",
                "                inputProps[action] = (...args) => {",
                "                    this._validate(name, actionRule, action);",
                "                    this._callPropsEvent(action, originalProps, ...args);",
                "                    this._reRender();",
                "                };",
                "            }",
                "        }",
                "",
                "        // onChange hack",
                "        inputProps[trigger] = (...args) => {",
                "            this._callOnChange(name, rulesMap[trigger], trigger, ...args);",
                "            this._callPropsEvent(trigger, originalProps, ...args);",
                "            this.options.onChange(name, field.value);",
                "            this._reRender();",
                "        };",
                "",
                "        delete originalProps[defaultValueName];",
                "",
                "        return Object.assign({}, originalProps, inputProps);",
                "    }",
                "",
                "    /**",
                "     * event on props",
                "     * props.onChange props.onBlur",
                "     */",
                "    _callPropsEvent(action, props, ...args) {",
                "        action in props &&",
                "            typeof props[action] === 'function' &&",
                "            props[action](...args);",
                "    }",
                "",
                "    _getInitMeta(name) {",
                "        if (!(name in this.fieldsMeta)) {",
                "            this.fieldsMeta[name] = Object.assign({}, initMeta);",
                "        }",
                "",
                "        return this.fieldsMeta[name];",
                "    }",
                "",
                "    /**",
                "     * update field.value and validate",
                "     */",
                "    _callOnChange(name, rule, trigger, ...others) {",
                "        const e = others[0];",
                "        const field = this._get(name);",
                "",
                "        if (!field) {",
                "            return;",
                "        }",
                "",
                "        field.value = field.getValueFromEvent",
                "            ? field.getValueFromEvent.apply(this, others)",
                "            : getValueFromEvent(e);",
                "",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        this._resetError(name);",
                "",
                "        // validate while onChange",
                "        rule && this._validate(name, rule, trigger);",
                "    }",
                "",
                "    /**",
                "     * ref must always be the same function, or if not it will be triggerd every time.",
                "     * @param {String} name name of component",
                "     * @param {String} action key to find ref",
                "     * @param {Function} fn saveRef",
                "     */",
                "    _getCacheBind(name, action, fn) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        if (!cache[action]) {",
                "            cache[action] = fn.bind(this, name);",
                "        }",
                "        return cache[action];",
                "    }",
                "",
                "    _setCache(name, action, hander) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        cache[action] = hander;",
                "    }",
                "",
                "    _getCache(name, action) {",
                "        const cache = this.cachedBind[name] || {};",
                "        return cache[action];",
                "    }",
                "",
                "    /**",
                "     * NOTE: saveRef is async function. it will be called after render",
                "     * @param {String} name name of component",
                "     * @param {Function} component ref",
                "     */",
                "    _saveRef(name, component) {",
                "        const key = `${name}_field`;",
                "        const autoUnmount = this.options.autoUnmount;",
                "",
                "        if (!component && autoUnmount) {",
                "            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)",
                "            // while type changed, B will render before A unmount. so we should cached value for B",
                "            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render",
                "            // 1. _saveRef(A, null)",
                "            const cache = this.fieldsMeta[name];",
                "            this._setCache(name, key, cache);",
                "            // after destroy, delete data",
                "            delete this.instance[name];",
                "            this.remove(name);",
                "            return;",
                "        }",
                "",
                "        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)",
                "        if (autoUnmount && !this.fieldsMeta[name]) {",
                "            this.fieldsMeta[name] = this._getCache(name, key);",
                "            this.setValue(",
                "                name,",
                "                this.fieldsMeta[name] && this.fieldsMeta[name].value,",
                "                false",
                "            );",
                "        }",
                "",
                "        // only one time here",
                "        const field = this._get(name);",
                "        if (field) {",
                "            const ref = field.ref;",
                "            if (ref) {",
                "                if (typeof ref === 'string') {",
                "                    throw new Error(`can not set string ref for ${name}`);",
                "                }",
                "                ref(component);",
                "            }",
                "",
                "            this.instance[name] = component;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * validate one Component",
                "     * @param {String} name name of Component",
                "     * @param {Array} rule",
                "     * @param {String} trigger onChange/onBlur/onItemClick/...",
                "     */",
                "    _validate(name, rule, trigger) {",
                "        const field = this._get(name);",
                "        const value = field.value;",
                "",
                "        field.state = 'loading';",
                "",
                "        let validate = this._getCache(name, trigger);",
                "        validate && validate.abort();",
                "",
                "        validate = new Validate({",
                "            [name]: rule,",
                "        });",
                "        this._setCache(name, trigger, validate);",
                "",
                "        validate.validate(",
                "            {",
                "                [name]: value,",
                "            },",
                "            errors => {",
                "                if (errors && errors.length) {",
                "                    field.errors = getErrorStrs(errors);",
                "                    field.state = 'error';",
                "                } else {",
                "                    field.errors = [];",
                "                    field.state = 'success';",
                "                }",
                "",
                "                this._reRender();",
                "            }",
                "        );",
                "    }",
                "",
                "    getValue(name) {",
                "        if (this.options.parseName) {",
                "            return getIn(this.values, name);",
                "        }",
                "        return this.values[name];",
                "    }",
                "",
                "    /**",
                "     * 1. get values by names.",
                "     * 2. If no names passed, return shallow copy of `field.values`",
                "     * @param {Array} names",
                "     */",
                "    getValues(names) {",
                "        const allValues = {};",
                "",
                "        if (names && names.length) {",
                "            names.forEach(name => {",
                "                allValues[name] = this.getValue(name);",
                "            });",
                "        } else {",
                "            Object.assign(allValues, this.values);",
                "        }",
                "",
                "        return allValues;",
                "    }",
                "",
                "    setValue(name, value, reRender = true) {",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].value = value;",
                "        }",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, value);",
                "        } else {",
                "            this.values[name] = value;",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setValues(fieldsValue = {}, reRender = true) {",
                "        if (!this.options.parseName) {",
                "            Object.keys(fieldsValue).forEach(name => {",
                "                this.setValue(name, fieldsValue[name], false);",
                "            });",
                "        } else {",
                "            // NOTE: this is a shallow merge",
                "            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}",
                "            this.values = Object.assign({}, this.values, fieldsValue);",
                "            const fields = this.getNames();",
                "            fields.forEach(name => {",
                "                const value = getIn(this.values, name);",
                "                if (value !== undefined) {",
                "                    // copy over values that are in this.values",
                "                    this.fieldsMeta[name].value = value;",
                "                } else {",
                "                    // if no value then copy values from fieldsMeta to keep initialized component data",
                "                    this.values = setIn(",
                "                        this.values,",
                "                        name,",
                "                        this.fieldsMeta[name].value",
                "                    );",
                "                }",
                "            });",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setError(name, errors) {",
                "        const err = Array.isArray(errors) ? errors : errors ? [errors] : [];",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].errors = err;",
                "        } else {",
                "            this.fieldsMeta[name] = {",
                "                errors: err,",
                "            };",
                "        }",
                "",
                "        if (",
                "            this.fieldsMeta[name].errors &&",
                "            this.fieldsMeta[name].errors.length > 0",
                "        ) {",
                "            this.fieldsMeta[name].state = 'error';",
                "        } else {",
                "            this.fieldsMeta[name].state = '';",
                "        }",
                "",
                "        this._reRender();",
                "    }",
                "",
                "    setErrors(fieldsErrors = {}) {",
                "        Object.keys(fieldsErrors).forEach(name => {",
                "            this.setError(name, fieldsErrors[name]);",
                "        });",
                "    }",
                "",
                "    getError(name) {",
                "        const field = this._get(name);",
                "        if (field && field.errors && field.errors.length) {",
                "            return field.errors;",
                "        }",
                "",
                "        return null;",
                "    }",
                "",
                "    getErrors(names) {",
                "        const fields = names || this.getNames();",
                "        const allErrors = {};",
                "        fields.forEach(f => {",
                "            allErrors[f] = this.getError(f);",
                "        });",
                "        return allErrors;",
                "    }",
                "",
                "    getState(name) {",
                "        const field = this._get(name);",
                "",
                "        if (field && field.state) {",
                "            return field.state;",
                "        }",
                "",
                "        return '';",
                "    }",
                "",
                "    /**",
                "     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate",
                "     * @param {Array} fieldNames",
                "     * @return {Object || null} map of inputs and their errors",
                "     */",
                "    formatGetErrors(fieldNames) {",
                "        const errors = this.getErrors(fieldNames);",
                "        let formattedErrors = null;",
                "        for (const field in errors) {",
                "            if (errors.hasOwnProperty(field) && errors[field]) {",
                "                const errorsObj = errors[field];",
                "                if (!formattedErrors) {",
                "                    formattedErrors = {};",
                "                }",
                "                formattedErrors[field] = { errors: errorsObj };",
                "            }",
                "        }",
                "        return formattedErrors;",
                "    }",
                "",
                "    /**",
                "     * validate by trigger",
                "     * @param {Array} ns names",
                "     * @param {Function} cb callback after validate",
                "     */",
                "    validate(ns, cb) {",
                "        const { names, callback } = getParams(ns, cb);",
                "        const fieldNames = names || this.getNames();",
                "",
                "        const descriptor = {};",
                "        const values = {};",
                "",
                "        let hasRule = false;",
                "        for (let i = 0; i < fieldNames.length; i++) {",
                "            const name = fieldNames[i];",
                "            const field = this._get(name);",
                "",
                "            if (!field) {",
                "                continue;",
                "            }",
                "",
                "            if (field.rules && field.rules.length) {",
                "                descriptor[name] = field.rules;"
            ]
        }
    }
}