{
    "src/tree/view/tree-node.jsx": [
        "...",
        "import TreeNodeInput from './tree-node-input';",
        "",
        "const { Expand } = Animate;",
        "const { bindCtx } = func;",
        "const { isPromise, pickOthers, pickAttrsWith } = obj;",
        "const isRoot = pos => /^0-(\\d)+$/.test(pos);",
        "",
        "/**",
        " * Tree.Node",
        " */",
        "export default class TreeNode extends Component {",
        "    static propTypes = {",
        "        _key: PropTypes.string,",
        "        prefix: PropTypes.string,",
        "        rtl: PropTypes.bool,",
        "        className: PropTypes.string,",
        "        /**",
        "         * 树节点",
        "         */",
        "        children: PropTypes.node,",
        "        /**",
        "         * 节点文本内容",
        "         */",
        "        label: PropTypes.node,",
        "        /**",
        "         * 单独设置是否支持选中，覆盖 Tree 的 selectable",
        "         */",
        "        selectable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否出现复选框，覆盖 Tree 的 checkable",
        "         */",
        "        checkable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否支持编辑，覆盖 Tree 的 editable",
        "         */",
        "        editable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否支持拖拽，覆盖 Tree 的 draggable",
        "         */",
        "        draggable: PropTypes.bool,",
        "        /**",
        "         * 是否禁止节点响应",
        "         */",
        "        disabled: PropTypes.bool,",
        "        /**",
        "         * 是否禁止勾选节点复选框",
        "         */",
        "        checkboxDisabled: PropTypes.bool,",
        "        /**",
        "         * 是否是叶子节点，设置loadData时生效",
        "         */",
        "        isLeaf: PropTypes.bool,",
        "        root: PropTypes.object,",
        "        eventKey: PropTypes.string,",
        "        pos: PropTypes.string,",
        "        expanded: PropTypes.bool,",
        "        selected: PropTypes.bool,",
        "        checked: PropTypes.bool,",
        "        indeterminate: PropTypes.bool,",
        "        dragOver: PropTypes.bool,",
        "        dragOverGapTop: PropTypes.bool,",
        "        dragOverGapBottom: PropTypes.bool,",
        "        parentNode: PropTypes.object,",
        "        onKeyDown: PropTypes.func,",
        "        size: PropTypes.number,",
        "    };",
        "",
        "    static defaultProps = {",
        "        label: '---',",
        "        rtl: false,",
        "        disabled: false,",
        "        checkboxDisabled: false,",
        "        isLeaf: false,",
        "        size: 1,",
        "    };",
        "",
        "    constructor(props) {",
        "        super(props);",
        "",
        "        this.state = {",
        "            editing: false,",
        "            loading: false,",
        "            label: props.label,",
        "        };",
        "",
        "        bindCtx(this, [",
        "            'handleExpand',",
        "            'handleSelect',",
        "            'handleCheck',",
        "            'handleEditStart',",
        "            'handleEditFinish',",
        "            'handleRightClick',",
        "            'handleDragStart',",
        "            'handleDragEnter',",
        "            'handleDragOver',",
        "            'handleDragLeave',",
        "            'handleDragEnd',",
        "            'handleDrop',",
        "            'handleInputKeyDown',",
        "            'handleKeyDown',",
        "        ]);",
        "    }",
        "",
        "    componentDidMount() {",
        "        this.itemNode = findDOMNode(this.refs.node);",
        "        this.setFocus();",
        "    }",
        "",
        "    componentWillReceiveProps(nextProps) {",
        "        if ('label' in nextProps) {",
        "            this.setState({",
        "                label: nextProps.label,",
        "            });",
        "        }",
        "    }",
        "",
        "    componentDidUpdate() {",
        "        this.setFocus();",
        "    }",
        "",
        "    getParentNode() {",
        "        return this.props.root.getParentNode(this.props.pos);",
        "    }",
        "",
        "    focusable() {",
        "        const { root, disabled } = this.props;",
        "        const { focusable } = root.props;",
        "        return focusable && !disabled;",
        "    }",
        "",
        "    getFocused() {",
        "        const { _key, root } = this.props;",
        "        const { focusedKey } = root.state;",
        "        return focusedKey === _key;",
        "    }",
        "",
        "    setFocus() {",
        "        const focused = this.getFocused();",
        "        if (focused && this.focusable()) {",
        "            this.itemNode.focus({ preventScroll: true });",
        "        }",
        "    }",
        "",
        "    handleExpand(e) {",
        "        const { root, expanded, eventKey } = this.props;",
        "",
        "        if (root.props.isNodeBlock) {",
        "            e.stopPropagation();",
        "        }",
        "",
        "        const { loading } = this.state;",
        "        if (loading) {",
        "            return;",
        "        }",
        "",
        "        const returnValue = root.handleExpand(!expanded, eventKey, this);",
        "        if (isPromise(returnValue)) {",
        "            this.setLoading(true);",
        "            return returnValue.then(",
        "                () => {",
        "                    this.setLoading(false);",
        "                },",
        "                () => {",
        "                    this.setLoading(false);",
        "                }",
        "            );",
        "        }",
        "    }",
        "",
        "    setLoading(loading) {",
        "        this.setState({ loading });",
        "    }",
        "",
        "    handleSelect(e) {",
        "        e.preventDefault();",
        "",
        "        const { root, selected, eventKey } = this.props;",
        "        root.handleSelect(!selected, eventKey, this, e);",
        "    }",
        "",
        "    handleCheck() {",
        "        const { root, checked, eventKey } = this.props;",
        "        root.handleCheck(!checked, eventKey, this);",
        "    }",
        "",
        "    handleEditStart(e) {",
        "        e.preventDefault();",
        "",
        "        this.setState({",
        "            editing: true,",
        "        });",
        "    }",
        "",
        "    handleEditFinish(e) {",
        "        const label = e.target.value;",
        "",
        "        this.setState({",
        "            editing: false,",
        "            label,",
        "        });",
        "",
        "        const { root, eventKey } = this.props;",
        "        root.props.onEditFinish(eventKey, label, this);",
        "    }",
        "",
        "    handleRightClick(e) {",
        "        this.props.root.props.onRightClick({",
        "            event: e,",
        "            node: this,",
        "        });",
        "    }",
        "",
        "    handleDragStart(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragStart(e, this);",
        "    }",
        "",
        "    handleDragEnter(e) {",
        "        e.preventDefault();",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragEnter(e, this);",
        "    }",
        "",
        "    handleDragOver(e) {",
        "        if (this.props.root.canDrop(this)) {",
        "            e.preventDefault();",
        "            e.stopPropagation();",
        "",
        "            this.props.root.handleDragOver(e, this);",
        "        }",
        "    }",
        "",
        "    handleDragLeave(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragLeave(e, this);",
        "    }",
        "",
        "    handleDragEnd(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragEnd(e, this);",
        "    }",
        "",
        "    handleDrop(e) {",
        "        e.preventDefault();",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDrop(e, this);",
        "    }",
        "",
        "    handleInputKeyDown(e) {",
        "        if (e.keyCode === KEYCODE.ENTER) {",
        "            this.handleEditFinish(e);",
        "        }",
        "    }",
        "",
        "    handleKeyDown(e) {",
        "        const { _key, root, disabled } = this.props;",
        "        if (disabled) {",
        "            return;",
        "        }",
        "",
        "        if (this.focusable()) {",
        "            root.handleItemKeyDown(_key, this, e);",
        "        }",
        "",
        "        this.props.onKeyDown && this.props.onKeyDown(e);",
        "    }",
        "",
        "    addCallbacks(props) {",
        "        const { disabled, root } = this.props;",
        "        if (!disabled) {",
        "            const selectable =",
        "                typeof this.props.selectable !== 'undefined'",
        "                    ? this.props.selectable",
        "                    : root.props.selectable;",
        "            if (selectable) {",
        "                props.onClick = this.handleSelect;",
        "            }",
        "            const editable =",
        "                typeof this.props.editable !== 'undefined'",
        "                    ? this.props.editable",
        "                    : root.props.editable;",
        "            if (editable) {",
        "                props.onDoubleClick = this.handleEditStart;",
        "            }",
        "            const draggable =",
        "                typeof this.props.draggable !== 'undefined'",
        "                    ? this.props.draggable",
        "                    : root.props.draggable;",
        "            if (draggable) {",
        "                props.draggable = true;",
        "                props.onDragStart = this.handleDragStart;",
        "                props.onDragEnd = this.handleDragEnd;",
        "            }",
        "            props.onContextMenu = this.handleRightClick;",
        "        }",
        "    }",
        "",
        "    renderSwitcher() {",
        "        const { prefix, disabled, expanded, root } = this.props;",
        "        const { loadData } = root.props;",
        "        const { loading } = this.state;",
        "        const showLine = this.showLine;",
        "",
        "        const lineState = showLine ? 'line' : 'noline';",
        "        const className = cx({",
        "            [`${prefix}tree-switcher`]: true,",
        "            [`${prefix}${lineState}`]: !loading,",
        "            [`${prefix}close`]: !loading && !showLine && !expanded,",
        "            [`${prefix}disabled`]: disabled,",
        "            [`${prefix}loading`]: loading,",
        "            [`${prefix}loading-${lineState}`]: loading,",
        "        });",
        "        const iconType =",
        "            loadData && loading",
        "                ? 'loading'",
        "                : showLine",
        "                ? expanded",
        "                    ? 'minus'",
        "                    : 'add'",
        "                : 'arrow-down';",
        "",
        "        return (",
        "            // eslint-disable-next-line jsx-a11y/click-events-have-key-events",
        "            <span",
        "                className={className}",
        "                onClick={disabled ? null : this.handleExpand}",
        "            >",
        "                {this.renderRightAngle()}",
        "                <Icon",
        "                    className={`${prefix}tree-switcher-icon`}",
        "                    type={iconType}",
        "                />",
        "            </span>",
        "        );",
        "    }",
        "",
        "    renderNoopSwitcher() {",
        "        const { prefix, pos } = this.props;",
        "        const showLine = this.showLine;",
        "",
        "        const lineState = showLine ? 'line' : 'noline';",
        "        const className = cx({",
        "            [`${prefix}tree-switcher`]: true,",
        "            [`${prefix}noop-${lineState}`]: true,",
        "            [`${prefix}noop-line-noroot`]: showLine && !isRoot(pos),",
        "        });",
        "",
        "        return <span className={className}>{this.renderRightAngle()}</span>;",
        "    }",
        "",
        "    renderRightAngle() {",
        "        const { prefix, pos } = this.props;",
        "        return this.showLine && !isRoot(pos) ? (",
        "            <span className={`${prefix}tree-right-angle`} />",
        "        ) : null;",
        "    }",
        "",
        "    renderCheckbox() {",
        "        const {",
        "            checked,",
        "            indeterminate,",
        "            disabled,",
        "            checkboxDisabled,",
        "        } = this.props;",
        "        const { label } = this.state;",
        "",
        "        return (",
        "            <Checkbox",
        "                aria-label={typeof label === 'string' ? label : null}",
        "                checked={checked}",
        "                tabIndex={-1}",
        "                indeterminate={indeterminate}",
        "                disabled={disabled || checkboxDisabled}",
        "                onChange={this.handleCheck}",
        "            />",
        "        );",
        "    }",
        "",
        "    renderLabel() {",
        "        const { prefix, root, disabled } = this.props;",
        "        const { isNodeBlock } = root.props;",
        "        const { label } = this.state;",
        "        const selectable =",
        "            typeof this.props.selectable !== 'undefined'",
        "                ? this.props.selectable",
        "                : root.props.selectable;",
        "        const labelProps = {",
        "            className: cx({",
        "                [`${prefix}tree-node-label`]: true,",
        "                [`${prefix}tree-node-label-selectable`]:",
        "                    selectable && !disabled,",
        "            }),",
        "        };",
        "",
        "        if (!isNodeBlock) {",
        "            this.addCallbacks(labelProps);",
        "        }",
        "",
        "        return (",
        "            <div",
        "                className={`${prefix}tree-node-label-wrapper`}",
        "                ref=\"labelWrapper\"",
        "            >",
        "                <div {...labelProps}>{label}</div>",
        "            </div>",
        "        );",
        "    }",
        "",
        "    renderInput() {",
        "        const { prefix } = this.props;",
        "        const { label } = this.state;",
        "        return (",
        "            <div",
        "                className={`${prefix}tree-node-label-wrapper`}",
        "                ref=\"labelWrapper\"",
        "            >",
        "                <TreeNodeInput",
        "                    prefix={prefix}",
        "                    defaultValue={label}",
        "                    onBlur={this.handleEditFinish}",
        "                    onKeyDown={this.handleInputKeyDown}",
        "                />",
        "            </div>",
        "        );",
        "    }",
        "",
        "    renderChildTree(hasChildTree) {",
        "        const { prefix, children, expanded, root } = this.props;",
        "        const { animation, renderChildNodes } = root.props;",
        "",
        "        if (!expanded || !hasChildTree) {",
        "            return null;",
        "        }",
        "",
        "        let childTree;",
        "",
        "        if (renderChildNodes) {",
        "            childTree = renderChildNodes(children);",
        "        } else {",
        "            childTree = (",
        "                <ul role=\"group\" className={`${prefix}tree-child-tree`}>",
        "                    {children}",
        "                </ul>",
        "            );",
        "        }",
        "",
        "        if (animation) {",
        "            childTree = <Expand animationAppear={false}>{childTree}</Expand>;",
        "        }",
        "",
        "        return childTree;",
        "    }",
        "",
        "    render() {",
        "        const {",
        "            prefix,",
        "            rtl,",
        "            className,",
        "            children,",
        "            isLeaf,",
        "            root,",
        "            pos,",
        "            selected,",
        "            checked,",
        "            disabled,",
        "            expanded,",
        "            dragOver,",
        "            dragOverGapTop,",
        "            dragOverGapBottom,",
        "            _key,",
        "            size,",
        "        } = this.props;",
        "        const {",
        "            loadData,",
        "            isNodeBlock,",
        "            showLine,",
        "            draggable: rootDraggable,",
        "            filterTreeNode,",
        "        } = root.props;",
        "        const { label } = this.state;",
        "",
        "        this.showLine = !isNodeBlock && showLine;",
        "        const indexArr = pos.split('-');",
        "",
        "        const ARIA_PREFIX = 'aria-';",
        "        const ariaProps = pickAttrsWith(this.props, ARIA_PREFIX);",
        "        const others = pickOthers(Object.keys(TreeNode.propTypes), this.props);",
        "",
        "        // remove aria keys",
        "        Object.keys(others).forEach(key => {",
        "            if (key.match(ARIA_PREFIX)) {",
        "                delete others[key];",
        "            }",
        "        });",
        "",
        "        if (rootDraggable) {",
        "..."
    ],
    "src/tree/view/tree.jsx": [
        "...",
        "import TreeNode from './tree-node';",
        "import {",
        "    normalizeToArray,",
        "    isDescendantOrSelf,",
        "    isSiblingOrSelf,",
        "    filterChildKey,",
        "    filterParentKey,",
        "    getAllCheckedKeys,",
        "    forEachEnableNode,",
        "    isNodeChecked,",
        "} from './util';",
        "",
        "const { bindCtx, noop } = func;",
        "const { getOffset } = dom;",
        "const { pickOthers, isPlainObject } = obj;",
        "",
        "/**",
        " * Tree",
        " */",
        "export default class Tree extends Component {",
        "    static propTypes = {",
        "        prefix: PropTypes.string,",
        "        rtl: PropTypes.bool,",
        "        pure: PropTypes.bool,",
        "        className: PropTypes.string,",
        "        /**",
        "         * 树节点",
        "         */",
        "        children: PropTypes.node,",
        "        /**",
        "         * 数据源，该属性优先级高于 children",
        "         */",
        "        dataSource: PropTypes.array,",
        "        /**",
        "         * 是否显示树的线",
        "         */",
        "        showLine: PropTypes.bool,",
        "        /**",
        "         * 是否支持选中节点",
        "         */",
        "        selectable: PropTypes.bool,",
        "        /**",
        "         * （用于受控）当前选中节点 key 的数组",
        "         */",
        "        selectedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * （用于非受控）默认选中节点 key 的数组",
        "         */",
        "        defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 选中或取消选中节点时触发的回调函数",
        "         * @param {Array} selectedKeys 选中节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Array} extra.selectedNodes 选中节点的数组",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.selected 当前操作是否是选中",
        "         */",
        "        onSelect: PropTypes.func,",
        "        /**",
        "         * 是否支持多选",
        "         */",
        "        multiple: PropTypes.bool,",
        "        /**",
        "         * 是否支持勾选节点的复选框",
        "         */",
        "        checkable: PropTypes.bool,",
        "        /**",
        "         * （用于受控）当前勾选复选框节点 key 的数组或 `{checked: Array, indeterminate: Array}` 的对象",
        "         */",
        "        checkedKeys: PropTypes.oneOfType([",
        "            PropTypes.arrayOf(PropTypes.string),",
        "            PropTypes.object,",
        "        ]),",
        "        /**",
        "         * （用于非受控）默认勾选复选框节点 key 的数组",
        "         */",
        "        defaultCheckedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 勾选节点复选框是否完全受控（父子节点选中状态不再关联）",
        "         */",
        "        checkStrictly: PropTypes.bool,",
        "        /**",
        "         * 定义选中时回填的方式",
        "         * @enumdesc 返回所有选中的节点, 父子节点都选中时只返回父节点, 父子节点都选中时只返回子节点",
        "         */",
        "        checkedStrategy: PropTypes.oneOf(['all', 'parent', 'child']),",
        "        /**",
        "         * 勾选或取消勾选复选框时触发的回调函数",
        "         * @param {Array} checkedKeys 勾选复选框节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Array} extra.checkedNodes 勾选复选框节点的数组",
        "         * @param {Array} extra.checkedNodesPositions 包含有勾选复选框节点和其位置的对象的数组",
        "         * @param {Array} extra.indeterminateKeys 半选复选框节点 key 的数组",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.checked 当前操作是否是勾选",
        "         */",
        "        onCheck: PropTypes.func,",
        "        /**",
        "         * （用于受控）当前展开的节点 key 的数组",
        "         */",
        "        expandedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * （用于非受控）默认展开的节点 key 的数组",
        "         */",
        "        defaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 是否默认展开所有节点",
        "         */",
        "        defaultExpandAll: PropTypes.bool,",
        "        /**",
        "         * 是否自动展开父节点，建议受控时设置为false",
        "         */",
        "        autoExpandParent: PropTypes.bool,",
        "        /**",
        "         * 展开或收起节点时触发的回调函数",
        "         * @param {Array} expandedKeys 展开的节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.expanded 当前操作是否是展开",
        "         */",
        "        onExpand: PropTypes.func,",
        "        /**",
        "         * 是否支持编辑节点内容",
        "         */",
        "        editable: PropTypes.bool,",
        "        /**",
        "         * 编辑节点内容完成时触发的回调函数",
        "         * @param {String} key 编辑节点的 key",
        "         * @param {String} label 编辑节点完成时节点的文本",
        "         * @param {Object} node 当前编辑的节点",
        "         */",
        "        onEditFinish: PropTypes.func,",
        "        /**",
        "         * 是否支持拖拽节点",
        "         */",
        "        draggable: PropTypes.bool,",
        "        /**",
        "         * 开始拖拽节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 拖拽的节点",
        "         */",
        "        onDragStart: PropTypes.func,",
        "        /**",
        "         * 拖拽节点进入目标节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Array} info.expandedKeys 当前展开的节点key的数组",
        "         */",
        "        onDragEnter: PropTypes.func,",
        "        /**",
        "         * 拖拽节点在目标节点上移动的时候触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragOver: PropTypes.func,",
        "        /**",
        "         * 拖拽节点离开目标节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragLeave: PropTypes.func,",
        "        /**",
        "         * 拖拽节点拖拽结束时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragEnd: PropTypes.func,",
        "        /**",
        "         * 拖拽节点放入目标节点内或前后触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Object} info.dragNode 拖拽的节点",
        "         * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点 key 的数组",
        "         * @param {Number} info.dropPosition 放置位置，-1代表当前节点前，0代表当前节点里，1代表当前节点后",
        "         */",
        "        onDrop: PropTypes.func,",
        "        /**",
        "         * 节点是否可被作为拖拽的目标节点",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Object} info.dragNode 拖拽的节点",
        "         * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点 key 的数组",
        "         * @param {Number} info.dropPosition 放置位置，-1代表当前节点前，0代表当前节点里，1代表当前节点后",
        "         * @return {Boolean} 是否可以被当作目标节点",
        "         */",
        "        canDrop: PropTypes.func,",
        "        /**",
        "         * 异步加载数据的函数",
        "         * @param {Object} node 被点击展开的节点",
        "         */",
        "        loadData: PropTypes.func,",
        "        /**",
        "         * 按需筛选高亮节点",
        "         * @param {Object} node 待筛选的节点",
        "         * @return {Boolean} 是否被筛选中",
        "         */",
        "        filterTreeNode: PropTypes.func,",
        "        /**",
        "         * 右键点击节点时触发的回调函数",
        "         * @param {Object} info 信息对象",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 点击的节点",
        "         */",
        "        onRightClick: PropTypes.func,",
        "        /**",
        "         * 设置节点是否占满剩余空间，一般用于统一在各节点右侧添加元素(借助 flex 实现，暂时只支持 ie10+)",
        "         */",
        "        isLabelBlock: PropTypes.bool,",
        "        /**",
        "         * 设置节点是否占满一行",
        "         */",
        "        isNodeBlock: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),",
        "        /**",
        "         * 是否开启展开收起动画",
        "         */",
        "        animation: PropTypes.bool,",
        "        /**",
        "         * 当前获得焦点的子菜单或菜单项 key 值",
        "         */",
        "        focusedKey: PropTypes.string,",
        "        /**",
        "         * 渲染子节点",
        "         * @param {Array<ReactNode>} nodes 所有的子节点",
        "         * @return {ReactNode} 返回节点",
        "         */",
        "        renderChildNodes: PropTypes.func,",
        "        focusable: PropTypes.bool,",
        "        autoFocus: PropTypes.bool,",
        "        onItemFocus: PropTypes.func,",
        "        onBlur: PropTypes.func,",
        "        onItemKeyDown: PropTypes.func,",
        "    };",
        "",
        "    static defaultProps = {",
        "        prefix: 'next-',",
        "        rtl: false,",
        "        pure: false,",
        "        showLine: false,",
        "        selectable: true,",
        "        editable: false,",
        "        multiple: false,",
        "        checkable: false,",
        "        checkStrictly: false,",
        "        checkedStrategy: 'all',",
        "        draggable: false,",
        "        autoExpandParent: true,",
        "        defaultExpandAll: false,",
        "        defaultExpandedKeys: [],",
        "        defaultCheckedKeys: [],",
        "        defaultSelectedKeys: [],",
        "        onExpand: noop,",
        "        onCheck: noop,",
        "        onSelect: noop,",
        "        onDragStart: noop,",
        "        onDragEnter: noop,",
        "        onDragOver: noop,",
        "        onDragLeave: noop,",
        "        onDragEnd: noop,",
        "        onDrop: noop,",
        "        canDrop: () => true,",
        "        onEditFinish: noop,",
        "        onRightClick: noop,",
        "        isLabelBlock: false,",
        "        isNodeBlock: false,",
        "        animation: true,",
        "        focusable: true,",
        "        autoFocus: false,",
        "        onItemFocus: noop,",
        "        onItemKeyDown: noop,",
        "    };",
        "",
        "    constructor(props) {",
        "        super(props);",
        "",
        "        this.updateCache(props);",
        "",
        "        const { focusable, autoFocus, focusedKey } = this.props;",
        "",
        "        if (focusable) {",
        "            this.tabbableKey = this.getFirstAvaliablelChildKey('0');",
        "        }",
        "",
        "        this.indeterminateKeys = [];",
        "        this.state = {",
        "            expandedKeys: this.getExpandedKeys(props),",
        "            selectedKeys: this.getSelectedKeys(props),",
        "            checkedKeys: this.getCheckedKeys(props),",
        "            focusedKey:",
        "                'focusedKey' in this.props",
        "                    ? focusedKey",
        "                    : focusable && autoFocus",
        "                    ? this.tabbableKey",
        "                    : null,",
        "        };",
        "",
        "        bindCtx(this, [",
        "            'handleExpand',",
        "            'handleSelect',",
        "            'handleCheck',",
        "            'handleBlur',",
        "        ]);",
        "    }",
        "",
        "    componentWillReceiveProps(nextProps) {",
        "        this.updateCache(nextProps);",
        "",
        "        const st = {};",
        "",
        "        if ('expandedKeys' in nextProps) {",
        "            st.expandedKeys = this.getExpandedKeys(nextProps, true);",
        "        }",
        "        if ('selectedKeys' in nextProps) {",
        "            st.selectedKeys = this.getSelectedKeys(nextProps, true);",
        "        }",
        "        if ('checkedKeys' in nextProps) {",
        "            st.checkedKeys = this.getCheckedKeys(nextProps, true);",
        "        }",
        "",
        "        this.indeterminateKeys = this.getIndeterminateKeys(",
        "            st.checkedKeys || this.state.checkedKeys || []",
        "        );",
        "",
        "        if (Object.keys(st).length) {",
        "            this.setState(st);",
        "        }",
        "    }",
        "",
        "    updateCache(props) {",
        "        this._k2n = {};",
        "        this._p2n = {};",
        "",
        "        if ('dataSource' in props) {",
        "            const loop = (data, prefix = '0') =>",
        "                data.forEach((item, index) => {",
        "                    const pos = `${prefix}-${index}`;",
        "                    let { key } = item;",
        "                    key = key || pos;",
        "                    const newItem = { ...item, key, pos };",
        "                    const { children } = item;",
        "                    if (children && children.length) {",
        "                        loop(children, pos);",
        "                    }",
        "                    this._k2n[key] = this._p2n[pos] = newItem;",
        "                });",
        "            loop(props.dataSource);",
        "        } else if ('children' in props) {",
        "            const loop = (children, prefix = '0') =>",
        "                Children.map(children, (node, index) => {",
        "                    if (!React.isValidElement(node)) {",
        "                        return;",
        "                    }",
        "",
        "                    const pos = `${prefix}-${index}`;",
        "                    let { key } = node;",
        "                    key = key || pos;",
        "                    const newItem = { ...node.props, key, pos };",
        "",
        "                    const { children } = node.props;",
        "                    if (children && Children.count(children)) {",
        "                        newItem.children = loop(children, pos);",
        "                    }",
        "                    this._k2n[key] = this._p2n[pos] = newItem;",
        "                    return newItem;",
        "                });",
        "            loop(props.children);",
        "        }",
        "    }",
        "",
        "    setFocusKey() {",
        "        const { selectedKeys = [] } = this.state;",
        "        this.setState({",
        "            focusedKey:",
        "                selectedKeys.length > 0",
        "                    ? selectedKeys[0]",
        "                    : this.getFirstAvaliablelChildKey('0'),",
        "        });",
        "    }",
        "",
        "    getExpandedKeys(props, willReceiveProps) {",
        "        let expandedKeys;",
        "",
        "        if (!willReceiveProps && props.defaultExpandAll) {",
        "            expandedKeys = Object.keys(this._k2n).filter(key => {",
        "                const children = this._k2n[key].children;",
        "                return children && children.length;",
        "            });",
        "        } else {",
        "            expandedKeys =",
        "                'expandedKeys' in props",
        "                    ? props.expandedKeys",
        "                    : willReceiveProps",
        "                    ? []",
        "                    : props.defaultExpandedKeys;",
        "            expandedKeys = normalizeToArray(expandedKeys);",
        "",
        "            if (props.autoExpandParent) {",
        "                const newExpandedKeys = [];",
        "",
        "                const expandedPoss = expandedKeys.reduce((ret, key) => {",
        "                    const pos = this._k2n[key] && this._k2n[key].pos;",
        "                    if (pos) {",
        "                        ret.push(pos);",
        "                        newExpandedKeys.push(key);",
        "                    }",
        "                    return ret;",
        "                }, []);",
        "",
        "                expandedPoss.forEach(pos => {",
        "                    const nums = pos.split('-');",
        "                    if (nums.length === 2) {",
        "                        return;",
        "                    }",
        "                    for (let i = 1; i <= nums.length - 2; i++) {",
        "                        const ancestorPos = nums.slice(0, i + 1).join('-');",
        "                        const ancestorKey = this._p2n[ancestorPos].key;",
        "                        if (newExpandedKeys.indexOf(ancestorKey) === -1) {",
        "                            newExpandedKeys.push(ancestorKey);",
        "                        }",
        "                    }",
        "                });",
        "",
        "                return newExpandedKeys;",
        "            }",
        "        }",
        "",
        "        return expandedKeys;",
        "    }",
        "",
        "    getAvailableKey(pos, prev) {",
        "        const ps = Object.keys(this._p2n).filter(p =>",
        "            this.isAvailablePos(pos, p)",
        "        );",
        "        if (ps.length > 1) {",
        "            const index = ps.indexOf(pos);",
        "            let targetIndex;",
        "            if (prev) {",
        "                targetIndex = index === 0 ? ps.length - 1 : index - 1;",
        "            } else {",
        "                targetIndex = index === ps.length - 1 ? 0 : index + 1;",
        "            }",
        "",
        "            return this._p2n[ps[targetIndex]].key;",
        "        }",
        "",
        "        return null;",
        "    }",
        "",
        "    getFirstAvaliablelChildKey(parentPos) {",
        "        const pos = Object.keys(this._p2n).find(p =>",
        "            this.isAvailablePos(`${parentPos}-0`, p)",
        "        );",
        "        return pos ? this._p2n[pos].key : null;",
        "    }",
        "",
        "    isAvailablePos(refPos, targetPos) {",
        "        const { disabled } = this._p2n[targetPos];",
        "",
        "        return this.isSibling(refPos, targetPos) && !disabled;",
        "    }",
        "",
        "    isSibling(currentPos, targetPos) {",
        "        const currentNums = currentPos.split('-').slice(0, -1);",
        "        const targetNums = targetPos.split('-').slice(0, -1);",
        "",
        "        return (",
        "            currentNums.length === targetNums.length &&",
        "            currentNums.every((num, index) => {",
        "                return num === targetNums[index];",
        "            })",
        "        );",
        "    }",
        "",
        "    getParentKey(pos) {",
        "        return this._p2n[pos.slice(0, pos.length - 2)].key;",
        "    }",
        "",
        "    getSelectedKeys(props, willReceiveProps) {",
        "        let selectedKeys =",
        "            'selectedKeys' in props",
        "                ? props.selectedKeys",
        "                : willReceiveProps",
        "                ? []",
        "                : props.defaultSelectedKeys;",
        "        selectedKeys = normalizeToArray(selectedKeys);",
        "",
        "        const newSelectKeys = selectedKeys.filter(key => {",
        "            return this._k2n[key];",
        "        });",
        "        return newSelectKeys;",
        "    }",
        "",
        "    /* istanbul ignore next */",
        "    getCheckedKeys(props, willReceiveProps) {",
        "        let checkedKeys = props.defaultCheckedKeys;",
        "",
        "..."
    ],
    "src/tree/view/util.js": [
        "/* eslint-disable valid-jsdoc */",
        "export function normalizeToArray(keys) {",
        "    if (keys !== undefined && keys !== null) {",
        "        if (Array.isArray(keys)) {",
        "            return [...keys];",
        "        }",
        "",
        "        return [keys];",
        "    }",
        "",
        "    return [];",
        "}",
        "",
        "/**",
        " * 判断子节点是否是选中状态，如果 checkable={false} 则向下递归，",
        " * @param {Node} child",
        " * @param {Array} checkedKeys",
        " */",
        "export function isNodeChecked(node, checkedKeys) {",
        "    if (node.disabled || node.checkboxDisabled) return true;",
        "    /* istanbul ignore next */",
        "    if (node.checkable === false) {",
        "        return (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(c => isNodeChecked(c, checkedKeys))",
        "        );",
        "    }",
        "    return checkedKeys.indexOf(node.key) > -1;",
        "}",
        "",
        "/**",
        " * 遍历所有可用的子节点",
        " * @param {Node}",
        " * @param {Function} callback",
        " */",
        "export function forEachEnableNode(node, callback = () => {}) {",
        "    if (node.disabled || node.checkboxDisabled) return;",
        "    // eslint-disable-next-line callback-return",
        "    callback(node);",
        "    if (node.children && node.children.length > 0) {",
        "        node.children.forEach(child => forEachEnableNode(child, callback));",
        "    }",
        "}",
        "/**",
        " * 判断节点是否禁用checked",
        " * @param {Node} node",
        " * @returns {Boolean}",
        " */",
        "export function isNodeDisabledChecked(node) {",
        "    if (node.disabled || node.checkboxDisabled) return true;",
        "    /* istanbul ignore next */",
        "    if (node.checkable === false) {",
        "        return (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(isNodeDisabledChecked)",
        "        );",
        "    }",
        "",
        "    return false;",
        "}",
        "",
        "/**",
        " * 递归获取一个 checkable = {true} 的父节点，当 checkable={false} 时继续往上查找",
        " * @param {Node} node",
        " * @param {Map} _p2n",
        " * @return {Node}",
        " */",
        "export function getCheckableParentNode(node, _p2n) {",
        "    let parentPos = node.pos.split(['-']);",
        "    if (parentPos.length === 2) return node;",
        "    parentPos.splice(parentPos.length - 1, 1);",
        "    parentPos = parentPos.join('-');",
        "    const parentNode = _p2n[parentPos];",
        "    if (parentNode.disabled || parentNode.checkboxDisabled) return false;",
        "    /* istanbul ignore next */",
        "    if (parentNode.checkable === false) {",
        "        return getCheckableParentNode(parentNode, _p2n);",
        "    }",
        "",
        "    return parentNode;",
        "}",
        "/**",
        " * 过滤子节点",
        " * @param {Array} keys",
        " * @param {Object} _k2n",
        " */",
        "export function filterChildKey(keys, _k2n, _p2n) {",
        "    const newKeys = [];",
        "    keys.forEach(key => {",
        "        const node = getCheckableParentNode(_k2n[key], _p2n);",
        "        if (",
        "            !node ||",
        "            node.checkable === false ||",
        "            node === _k2n[key] ||",
        "            keys.indexOf(node.key) === -1",
        "        ) {",
        "            newKeys.push(key);",
        "        }",
        "    });",
        "    return newKeys;",
        "}",
        "",
        "export function filterParentKey(keys, _k2n) {",
        "    const newKeys = [];",
        "",
        "    for (let i = 0; i < keys.length; i++) {",
        "        const node = _k2n[keys[i]];",
        "        if (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(isNodeDisabledChecked)",
        "        ) {",
        "            newKeys.push(keys[i]);",
        "        }",
        "    }",
        "",
        "    return newKeys;",
        "}",
        "",
        "export function isDescendantOrSelf(currentPos, targetPos) {",
        "    if (!currentPos || !targetPos) {",
        "        return false;",
        "    }",
        "",
        "    const currentNums = currentPos.split('-');",
        "    const targetNums = targetPos.split('-');",
        "",
        "    return (",
        "        currentNums.length <= targetNums.length &&",
        "        currentNums.every((num, index) => {",
        "            return num === targetNums[index];",
        "        })",
        "    );",
        "}",
        "",
        "export function isSiblingOrSelf(currentPos, targetPos) {",
        "    const currentNums = currentPos.split('-').slice(0, -1);",
        "    const targetNums = targetPos.split('-').slice(0, -1);",
        "",
        "    return (",
        "        currentNums.length === targetNums.length &&",
        "        currentNums.every((num, index) => {",
        "            return num === targetNums[index];",
        "        })",
        "    );",
        "}",
        "",
        "// eslint-disable-next-line max-statements",
        "export function getAllCheckedKeys(checkedKeys, _k2n, _p2n) {",
        "    checkedKeys = normalizeToArray(checkedKeys);",
        "    const filteredKeys = checkedKeys.filter(key => !!_k2n[key]);",
        "    const flatKeys = [",
        "        ...filterChildKey(filteredKeys, _k2n, _p2n),",
        "        ...filteredKeys.filter(",
        "            key => _k2n[key].disabled || _k2n[key].checkboxDisabled",
        "        ),",
        "    ];",
        "    const removeKey = child => {",
        "        if (child.disabled || child.checkboxDisabled) return;",
        "        if (",
        "            child.checkable === false &&",
        "            child.children &&",
        "            child.children.length > 0",
        "        ) {",
        "            return child.children.forEach(removeKey);",
        "        }",
        "        flatKeys.splice(flatKeys.indexOf(child.key), 1);",
        "    };",
        "",
        "    const addParentKey = (i, parent) => flatKeys.splice(i, 0, parent.key);",
        "",
        "    const keys = [...flatKeys];",
        "    for (let i = 0; i < keys.length; i++) {",
        "        const pos = _k2n[keys[i]].pos;",
        "        const nums = pos.split('-');",
        "        if (nums.length === 2) {",
        "            break;",
        "        }",
        "        for (let j = nums.length - 2; j > 0; j--) {",
        "            const parentPos = nums.slice(0, j + 1).join('-');",
        "            const parent = _p2n[parentPos];",
        "            if (",
        "                parent.checkable === false ||",
        "                parent.disabled ||",
        "                parent.checkboxDisabled",
        "            )",
        "                continue;",
        "            const parentChecked = parent.children.every(child =>",
        "                isNodeChecked(child, flatKeys)",
        "            );",
        "            if (parentChecked) {",
        "                parent.children.forEach(removeKey);",
        "                addParentKey(i, parent);",
        "            } else {",
        "                break;",
        "            }",
        "        }",
        "    }",
        "",
        "    const newKeys = [];",
        "    flatKeys.forEach(key => {",
        "        if (_k2n[key].disabled || _k2n[key].checkboxDisabled) {",
        "            newKeys.push(key);",
        "            return;",
        "        }",
        "        forEachEnableNode(_k2n[key], node => {",
        "            if (node.checkable === false) return;",
        "            newKeys.push(node.key);",
        "        });",
        "    });",
        "",
        "    return newKeys;",
        "}"
    ]
}