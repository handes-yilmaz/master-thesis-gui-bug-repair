{
    "bug_classes": {
        "1": {
            "class_name": "Popup (not found) ",
            "file_path": "src/overlay/popup.jsx",
            "class_details": [
                {
                    "name": "Popup",
                    "start_line": 1,
                    "end_line": 381
                }
            ],
            "class_code": [
                "import React, { Component, Children } from 'react';",
                "import { findDOMNode } from 'react-dom';",
                "import PropTypes from 'prop-types';",
                "import { func, KEYCODE } from '../util';",
                "import Overlay from './overlay';",
                "",
                "const { noop, makeChain, bindCtx } = func;",
                "",
                "/**",
                " * Overlay.Popup",
                " * @description 继承 Overlay 的 API，除非特别说明",
                " * */",
                "export default class Popup extends Component {",
                "    static propTypes = {",
                "        /**",
                "         * 弹层内容",
                "         */",
                "        children: PropTypes.node,",
                "        /**",
                "         * 触发弹层显示或隐藏的元素",
                "         */",
                "        trigger: PropTypes.element,",
                "        /**",
                "         * 触发弹层显示或隐藏的操作类型，可以是 'click'，'hover'，'focus'，或者它们组成的数组，如 ['hover', 'focus']",
                "         */",
                "        triggerType: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),",
                "        /**",
                "         * 当 triggerType 为 click 时才生效，可自定义触发弹层显示的键盘码",
                "         */",
                "",
                "        triggerClickKeycode: PropTypes.oneOfType([",
                "            PropTypes.number,",
                "            PropTypes.array,",
                "        ]),",
                "        /**",
                "         * 弹层当前是否显示",
                "         */",
                "        visible: PropTypes.bool,",
                "        /**",
                "         * 弹层默认是否显示",
                "         */",
                "        defaultVisible: PropTypes.bool,",
                "        /**",
                "         * 弹层显示或隐藏时触发的回调函数",
                "         * @param {Boolean} visible 弹层是否显示",
                "         * @param {String} type 触发弹层显示或隐藏的来源 fromTrigger 表示由trigger的点击触发； docClick 表示由document的点击触发",
                "         * @param {Object} e DOM事件",
                "         */",
                "        onVisibleChange: PropTypes.func,",
                "        /**",
                "         * 设置此属性，弹层无法显示或隐藏",
                "         */",
                "        disabled: PropTypes.bool,",
                "        /**",
                "         * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效",
                "         */",
                "        delay: PropTypes.number,",
                "        /**",
                "         * trigger 是否可以关闭弹层",
                "         */",
                "        canCloseByTrigger: PropTypes.bool,",
                "        /**",
                "         * 弹层定位的参照元素",
                "         * @default target 属性，即触发元素",
                "         */",
                "        target: PropTypes.any,",
                "        safeNode: PropTypes.any,",
                "        /**",
                "         * 是否跟随trigger滚动",
                "         */",
                "        followTrigger: PropTypes.bool,",
                "        container: PropTypes.any,",
                "        hasMask: PropTypes.bool,",
                "        wrapperStyle: PropTypes.object,",
                "        rtl: PropTypes.bool,",
                "    };",
                "",
                "    static defaultProps = {",
                "        triggerType: 'hover',",
                "        triggerClickKeycode: [KEYCODE.SPACE, KEYCODE.ENTER],",
                "        defaultVisible: false,",
                "        onVisibleChange: noop,",
                "        disabled: false,",
                "        delay: 200,",
                "        canCloseByTrigger: true,",
                "        followTrigger: false,",
                "        container: () => document.body,",
                "        rtl: false,",
                "    };",
                "",
                "    constructor(props) {",
                "        super(props);",
                "",
                "        this.state = {",
                "            visible:",
                "                typeof props.visible === 'undefined'",
                "                    ? props.defaultVisible",
                "                    : props.visible,",
                "        };",
                "",
                "        bindCtx(this, [",
                "            'handleTriggerClick',",
                "            'handleTriggerKeyDown',",
                "            'handleTriggerMouseEnter',",
                "            'handleTriggerMouseLeave',",
                "            'handleTriggerFocus',",
                "            'handleTriggerBlur',",
                "            'handleContentMouseEnter',",
                "            'handleContentMouseLeave',",
                "            'handleContentMouseDown',",
                "            'handleRequestClose',",
                "            'handleMaskMouseEnter',",
                "            'handleMaskMouseLeave',",
                "        ]);",
                "    }",
                "",
                "    componentWillReceiveProps(nextProps) {",
                "        if ('visible' in nextProps) {",
                "            this.setState({",
                "                visible: nextProps.visible,",
                "            });",
                "        }",
                "    }",
                "",
                "    componentWillUnmount() {",
                "        ['_timer', '_hideTimer', '_showTimer'].forEach(time => {",
                "            this[time] && clearTimeout(this[time]);",
                "        });",
                "    }",
                "",
                "    handleVisibleChange(visible, type, e) {",
                "        if (!('visible' in this.props)) {",
                "            this.setState({",
                "                visible,",
                "            });",
                "        }",
                "",
                "        this.props.onVisibleChange(visible, type, e);",
                "    }",
                "",
                "    handleTriggerClick(e) {",
                "        if (this.state.visible && !this.props.canCloseByTrigger) {",
                "            return;",
                "        }",
                "",
                "        this.handleVisibleChange(!this.state.visible, 'fromTrigger', e);",
                "    }",
                "",
                "    handleTriggerKeyDown(e) {",
                "        const { triggerClickKeycode } = this.props;",
                "        const keycodes = Array.isArray(triggerClickKeycode)",
                "            ? triggerClickKeycode",
                "            : [triggerClickKeycode];",
                "        if (keycodes.includes(e.keyCode)) {",
                "            e.preventDefault();",
                "            this.handleTriggerClick(e);",
                "        }",
                "    }",
                "",
                "    handleTriggerMouseEnter(e) {",
                "        this._mouseNotFirstOnMask = false;",
                "",
                "        if (this._hideTimer) {",
                "            clearTimeout(this._hideTimer);",
                "            this._hideTimer = null;",
                "        }",
                "        if (this._showTimer) {",
                "            clearTimeout(this._showTimer);",
                "            this._showTimer = null;",
                "        }",
                "        if (!this.state.visible) {",
                "            this._showTimer = setTimeout(() => {",
                "                this.handleVisibleChange(true, 'fromTrigger', e);",
                "            }, this.props.delay);",
                "        }",
                "    }",
                "",
                "    handleTriggerMouseLeave(e, type) {",
                "        if (this._showTimer) {",
                "            clearTimeout(this._showTimer);",
                "            this._showTimer = null;",
                "        }",
                "        if (this.state.visible) {",
                "            this._hideTimer = setTimeout(() => {",
                "                this.handleVisibleChange(false, type || 'fromTrigger', e);",
                "            }, this.props.delay);",
                "        }",
                "    }",
                "",
                "    handleTriggerFocus(e) {",
                "        this.handleVisibleChange(true, 'fromTrigger', e);",
                "    }",
                "",
                "    handleTriggerBlur(e) {",
                "        if (!this._isForwardContent) {",
                "            this.handleVisibleChange(false, 'fromTrigger', e);",
                "        }",
                "        this._isForwardContent = false;",
                "    }",
                "",
                "    handleContentMouseDown() {",
                "        this._isForwardContent = true;",
                "    }",
                "",
                "    handleContentMouseEnter() {",
                "        clearTimeout(this._hideTimer);",
                "    }",
                "",
                "    handleContentMouseLeave(e) {",
                "        this.handleTriggerMouseLeave(e, 'fromContent');",
                "    }",
                "",
                "    handleMaskMouseEnter() {",
                "        if (!this._mouseNotFirstOnMask) {",
                "            clearTimeout(this._hideTimer);",
                "            this._hideTimer = null;",
                "            this._mouseNotFirstOnMask = false;",
                "        }",
                "    }",
                "",
                "    handleMaskMouseLeave() {",
                "        this._mouseNotFirstOnMask = true;",
                "    }",
                "",
                "    handleRequestClose(type, e) {",
                "        this.handleVisibleChange(false, type, e);",
                "    }",
                "",
                "    renderTrigger() {",
                "        const { trigger, disabled } = this.props;",
                "        const props = {",
                "            key: 'trigger',",
                "            'aria-haspopup': true,",
                "            'aria-expanded': this.state.visible,",
                "        };",
                "",
                "        if (!this.state.visible) {",
                "            props['aria-describedby'] = undefined;",
                "        }",
                "",
                "        if (!disabled) {",
                "            const { triggerType } = this.props;",
                "            const triggerTypes = Array.isArray(triggerType)",
                "                ? triggerType",
                "                : [triggerType];",
                "            const {",
                "                onClick,",
                "                onKeyDown,",
                "                onMouseEnter,",
                "                onMouseLeave,",
                "                onFocus,",
                "                onBlur,",
                "            } = trigger.props;",
                "            triggerTypes.forEach(triggerType => {",
                "                switch (triggerType) {",
                "                    case 'click':",
                "                        props.onClick = makeChain(",
                "                            this.handleTriggerClick,",
                "                            onClick",
                "                        );",
                "                        props.onKeyDown = makeChain(",
                "                            this.handleTriggerKeyDown,",
                "                            onKeyDown",
                "                        );",
                "                        break;",
                "                    case 'hover':",
                "                        props.onMouseEnter = makeChain(",
                "                            this.handleTriggerMouseEnter,",
                "                            onMouseEnter",
                "                        );",
                "                        props.onMouseLeave = makeChain(",
                "                            this.handleTriggerMouseLeave,",
                "                            onMouseLeave",
                "                        );",
                "                        break;",
                "                    case 'focus':",
                "                        props.onFocus = makeChain(",
                "                            this.handleTriggerFocus,",
                "                            onFocus",
                "                        );",
                "                        props.onBlur = makeChain(",
                "                            this.handleTriggerBlur,",
                "                            onBlur",
                "                        );",
                "                        break;",
                "                    default:",
                "                        break;",
                "                }",
                "            });",
                "        }",
                "",
                "        return React.cloneElement(trigger, props);",
                "    }",
                "",
                "    renderContent() {",
                "        const { children, triggerType } = this.props;",
                "        const triggerTypes = Array.isArray(triggerType)",
                "            ? triggerType",
                "            : [triggerType];",
                "        const content = Children.only(children);",
                "        const { onMouseDown, onMouseEnter, onMouseLeave } = content.props;",
                "        const props = {",
                "            key: 'portal',",
                "        };",
                "",
                "        triggerTypes.forEach(triggerType => {",
                "            switch (triggerType) {",
                "                case 'focus':",
                "                    props.onMouseDown = makeChain(",
                "                        this.handleContentMouseDown,",
                "                        onMouseDown",
                "                    );",
                "                    break;",
                "                case 'hover':",
                "                    props.onMouseEnter = makeChain(",
                "                        this.handleContentMouseEnter,",
                "                        onMouseEnter",
                "                    );",
                "                    props.onMouseLeave = makeChain(",
                "                        this.handleContentMouseLeave,",
                "                        onMouseLeave",
                "                    );",
                "                    break;",
                "                default:",
                "                    break;",
                "            }",
                "        });",
                "",
                "        return React.cloneElement(content, props);",
                "    }",
                "",
                "    renderPortal() {",
                "        const {",
                "            target,",
                "            safeNode,",
                "            followTrigger,",
                "            triggerType,",
                "            hasMask,",
                "            wrapperStyle,",
                "            ...others",
                "        } = this.props;",
                "        let { container } = this.props;",
                "        const findTriggerNode = () => findDOMNode(this) || {};",
                "        const safeNodes = Array.isArray(safeNode) ? [...safeNode] : [safeNode];",
                "        safeNodes.unshift(findTriggerNode);",
                "",
                "        const newWrapperStyle = wrapperStyle || {};",
                "",
                "        if (followTrigger) {",
                "            container = trigger => (trigger && trigger.parentNode) || trigger;",
                "            newWrapperStyle.position = 'relative';",
                "        }",
                "",
                "        if (triggerType === 'hover' && hasMask) {",
                "            others.onMaskMouseEnter = this.handleMaskMouseEnter;",
                "            others.onMaskMouseLeave = this.handleMaskMouseLeave;",
                "        }",
                "",
                "        return (",
                "            <Overlay",
                "                {...others}",
                "                key=\"overlay\"",
                "                ref={overlay => (this.overlay = overlay)}",
                "                visible={this.state.visible}",
                "                target={target || findTriggerNode}",
                "                container={container}",
                "                safeNode={safeNodes}",
                "                wrapperStyle={newWrapperStyle}",
                "                triggerType={triggerType}",
                "                hasMask={hasMask}",
                "                onRequestClose={this.handleRequestClose}",
                "            >",
                "                {this.renderContent()}",
                "            </Overlay>",
                "        );",
                "    }",
                "",
                "    render() {",
                "        return [this.renderTrigger(), this.renderPortal()];",
                "    }",
                "}"
            ]
        },
        "2": {
            "class_name": "Position (not found) ",
            "file_path": "src/overlay/utils/position.js",
            "class_details": [
                {
                    "name": "Position",
                    "start_line": 1,
                    "end_line": 388
                }
            ],
            "class_code": [
                "import { dom } from '../../util';",
                "",
                "const VIEWPORT = 'viewport';",
                "",
                "// IE8 not support pageXOffset",
                "const getPageX = () =>",
                "    window.pageXOffset || document.documentElement.scrollLeft;",
                "const getPageY = () => window.pageYOffset || document.documentElement.scrollTop;",
                "",
                "/**",
                " * @private get element rect",
                " * @param       {Element} elem",
                " * @return      {Object}",
                " */",
                "function _getElementRect(elem) {",
                "    let offsetTop = 0,",
                "        offsetLeft = 0,",
                "        scrollTop = 0,",
                "        scrollLeft = 0;",
                "",
                "    const offsetHeight = elem.offsetHeight;",
                "    const offsetWidth = elem.offsetWidth;",
                "",
                "    do {",
                "        if (!isNaN(elem.offsetTop)) {",
                "            offsetTop += elem.offsetTop;",
                "        }",
                "        if (!isNaN(elem.offsetLeft)) {",
                "            offsetLeft += elem.offsetLeft;",
                "        }",
                "        if (!isNaN(elem.scrollTop)) {",
                "            scrollTop += elem.scrollTop;",
                "        }",
                "        if (!isNaN(elem.scrollLeft)) {",
                "            scrollLeft += elem.scrollLeft;",
                "        }",
                "    } while ((elem = elem.offsetParent) !== null);",
                "",
                "    return {",
                "        top:",
                "            offsetTop -",
                "            scrollTop -",
                "            (document.documentElement.scrollTop || document.body.scrollTop),",
                "        left:",
                "            offsetLeft -",
                "            scrollLeft -",
                "            (document.documentElement.scrollLeft || document.body.scrollLeft),",
                "        height: offsetHeight,",
                "        width: offsetWidth,",
                "    };",
                "}",
                "",
                "/**",
                " * @private get viewport size",
                " * @return {Object}",
                " */",
                "function _getViewportSize() {",
                "    return {",
                "        width: document.documentElement.clientWidth,",
                "        height: document.documentElement.clientHeight,",
                "    };",
                "}",
                "export default class Position {",
                "    static VIEWPORT = VIEWPORT;",
                "",
                "    /**",
                "     * @public static place method",
                "     * @param  {Object}       props",
                "     *     @param  {DOM}      props.pinElement",
                "     *     @param  {DOM}      props.baseElement",
                "     *     @param  {String}   props.align",
                "     *     @param  {Number}   props.offset",
                "     *     @param  {Boolean}  props.needAdjust",
                "     *     @param  {Boolean}  props.isRtl",
                "     * @return {Position}",
                "     */",
                "    static place = props => new Position(props).setPosition();",
                "",
                "    constructor(props) {",
                "        this.pinElement = props.pinElement;",
                "        this.baseElement = props.baseElement;",
                "        this.align = props.align || 'tl tl';",
                "        this.offset = props.offset || [0, 0];",
                "        this.needAdjust = props.needAdjust || false;",
                "        this.isRtl = props.isRtl || false;",
                "    }",
                "",
                "    setPosition() {",
                "        const pinElement = this.pinElement;",
                "        const baseElement = this.baseElement;",
                "        const expectedAlign = this._getExpectedAlign();",
                "        let isPinFixed, isBaseFixed, firstPositionResult;",
                "        if (pinElement === VIEWPORT) {",
                "            return;",
                "        }",
                "        if (dom.getStyle(pinElement, 'position') !== 'fixed') {",
                "            dom.setStyle(pinElement, 'position', 'absolute');",
                "            isPinFixed = false;",
                "        } else {",
                "            isPinFixed = true;",
                "        }",
                "        if (",
                "            baseElement === VIEWPORT ||",
                "            dom.getStyle(baseElement, 'position') !== 'fixed'",
                "        ) {",
                "            isBaseFixed = false;",
                "        } else {",
                "            isBaseFixed = true;",
                "        }",
                "        // 根据期望的定位",
                "        for (let i = 0; i < expectedAlign.length; i++) {",
                "            const align = expectedAlign[i];",
                "            const pinElementPoints = this._normalizePosition(",
                "                pinElement,",
                "                align.split(' ')[0],",
                "                isPinFixed",
                "            );",
                "            const baseElementPoints = this._normalizePosition(",
                "                baseElement,",
                "                align.split(' ')[1],",
                "                isPinFixed",
                "            );",
                "            const pinElementParentOffset = this._getParentOffset(pinElement);",
                "            const baseElementOffset =",
                "                isPinFixed && isBaseFixed",
                "                    ? this._getLeftTop(baseElement)",
                "                    : baseElementPoints.offset();",
                "            const top =",
                "                baseElementOffset.top +",
                "                baseElementPoints.y -",
                "                pinElementParentOffset.top -",
                "                pinElementPoints.y;",
                "            const left =",
                "                baseElementOffset.left +",
                "                baseElementPoints.x -",
                "                pinElementParentOffset.left -",
                "                pinElementPoints.x;",
                "            this._setPinElementPostion(pinElement, { left, top }, this.offset);",
                "",
                "            if (!firstPositionResult) {",
                "                firstPositionResult = { left, top };",
                "            }",
                "            if (this._isInViewport(pinElement)) {",
                "                return align;",
                "            }",
                "        }",
                "",
                "        // This will only execute if `pinElement` could not be placed entirely in the Viewport",
                "        const inViewportLeft = this._makeElementInViewport(",
                "            pinElement,",
                "            firstPositionResult.left,",
                "            'Left',",
                "            isPinFixed",
                "        );",
                "        const inViewportTop = this._makeElementInViewport(",
                "            pinElement,",
                "            firstPositionResult.top,",
                "            'Top',",
                "            isPinFixed",
                "        );",
                "        this._setPinElementPostion(",
                "            pinElement,",
                "            { left: inViewportLeft, top: inViewportTop },",
                "            this.offset",
                "        );",
                "        return expectedAlign[0];",
                "    }",
                "",
                "    _getParentOffset(element) {",
                "        const parent = element.offsetParent || document.documentElement;",
                "        let offset;",
                "        if (",
                "            parent === document.body &&",
                "            dom.getStyle(parent, 'position') === 'static'",
                "        ) {",
                "            offset = {",
                "                top: 0,",
                "                left: 0,",
                "            };",
                "        } else {",
                "            offset = this._getElementOffset(parent);",
                "        }",
                "",
                "        offset.top += parseFloat(dom.getStyle(parent, 'border-top-width'), 10);",
                "        offset.left += parseFloat(",
                "            dom.getStyle(parent, 'border-left-width'),",
                "            10",
                "        );",
                "        offset.offsetParent = parent;",
                "        return offset;",
                "    }",
                "",
                "    _makeElementInViewport(pinElement, number, type, isPinFixed) {",
                "        let result = number;",
                "        const docElement = document.documentElement;",
                "        const offsetParent =",
                "            pinElement.offsetParent || document.documentElement;",
                "",
                "        if (result < 0) {",
                "            if (isPinFixed) {",
                "                result = 0;",
                "            } else if (",
                "                offsetParent === document.body &&",
                "                dom.getStyle(offsetParent, 'position') === 'static'",
                "            ) {",
                "                // Only when div's offsetParent is document.body, we set new position result.",
                "                result = Math.max(",
                "                    docElement[`scroll${type}`],",
                "                    document.body[`scroll${type}`]",
                "                );",
                "            }",
                "        }",
                "",
                "        return result;",
                "    }",
                "",
                "    _normalizePosition(element, align, isPinFixed) {",
                "        const points = this._normalizeElement(element, isPinFixed);",
                "        this._normalizeXY(points, align);",
                "",
                "        return points;",
                "    }",
                "",
                "    _normalizeXY(points, align) {",
                "        const x = align.split('')[1];",
                "        const y = align.split('')[0];",
                "",
                "        points.x = this._xyConverter(x, points, 'width');",
                "        points.y = this._xyConverter(y, points, 'height');",
                "",
                "        return points;",
                "    }",
                "",
                "    _xyConverter(align, points, type) {",
                "        const res = align",
                "            .replace(/t|l/gi, '0%')",
                "            .replace(/c/gi, '50%')",
                "            .replace(/b|r/gi, '100%')",
                "            .replace(/(\\d+)%/gi, function(m, d) {",
                "                return points.size()[type] * (d / 100);",
                "            });",
                "",
                "        return parseFloat(res, 10) || 0;",
                "    }",
                "",
                "    _getLeftTop(element) {",
                "        return {",
                "            left: parseFloat(dom.getStyle(element, 'left')) || 0,",
                "            top: parseFloat(dom.getStyle(element, 'top')) || 0,",
                "        };",
                "    }",
                "",
                "    _normalizeElement(element, isPinFixed) {",
                "        const result = {",
                "                element: element,",
                "                x: 0,",
                "                y: 0,",
                "            },",
                "            isViewport = element === VIEWPORT,",
                "            docElement = document.documentElement;",
                "",
                "        result.offset = () => {",
                "            if (isPinFixed) {",
                "                return {",
                "                    left: 0,",
                "                    top: 0,",
                "                };",
                "            } else if (isViewport) {",
                "                return {",
                "                    left: getPageX(),",
                "                    top: getPageY(),",
                "                };",
                "            } else {",
                "                return this._getElementOffset(element);",
                "            }",
                "        };",
                "",
                "        result.size = () => {",
                "            if (isViewport) {",
                "                return {",
                "                    width: docElement.clientWidth,",
                "                    height: docElement.clientHeight,",
                "                };",
                "            } else {",
                "                return {",
                "                    width: element.offsetWidth,",
                "                    height: element.offsetHeight,",
                "                };",
                "            }",
                "        };",
                "",
                "        return result;",
                "    }",
                "",
                "    _getElementOffset(element) {",
                "        const rect = element.getBoundingClientRect();",
                "        const docElement = document.documentElement;",
                "        const body = document.body;",
                "        const docClientLeft = docElement.clientLeft || body.clientLeft || 0;",
                "        const docClientTop = docElement.clientTop || body.clientTop || 0;",
                "",
                "        return {",
                "            left: rect.left + (getPageX() - docClientLeft),",
                "            top: rect.top + (getPageY() - docClientTop),",
                "        };",
                "    }",
                "",
                "    // According to the location of the overflow to calculate the desired positioning",
                "    _getExpectedAlign() {",
                "        const align = this.isRtl",
                "            ? this._replaceAlignDir(this.align, /l|r/g, { l: 'r', r: 'l' })",
                "            : this.align;",
                "        const expectedAlign = [align];",
                "        if (this.needAdjust) {",
                "            if (/t|b/g.test(align)) {",
                "                expectedAlign.push(",
                "                    this._replaceAlignDir(align, /t|b/g, { t: 'b', b: 't' })",
                "                );",
                "            }",
                "            if (/l|r/g.test(align)) {",
                "                expectedAlign.push(",
                "                    this._replaceAlignDir(align, /l|r/g, { l: 'r', r: 'l' })",
                "                );",
                "            }",
                "            if (/c/g.test(align)) {",
                "                expectedAlign.push(",
                "                    this._replaceAlignDir(align, /c(?= |$)/g, { c: 'l' })",
                "                );",
                "                expectedAlign.push(",
                "                    this._replaceAlignDir(align, /c(?= |$)/g, { c: 'r' })",
                "                );",
                "            }",
                "            expectedAlign.push(",
                "                this._replaceAlignDir(align, /l|r|t|b/g, {",
                "                    l: 'r',",
                "                    r: 'l',",
                "                    t: 'b',",
                "                    b: 't',",
                "                })",
                "            );",
                "        }",
                "        return expectedAlign;",
                "    }",
                "",
                "    // Transform align order.",
                "    _replaceAlignDir(align, regExp, map) {",
                "        return align.replace(regExp, res => {",
                "            return map[res];",
                "        });",
                "    }",
                "",
                "    // Detecting element is in the window， we want to adjust position later.",
                "    _isInViewport(element) {",
                "        const viewportSize = _getViewportSize();",
                "        // Avoid animate problem that use offsetWidth instead of getBoundingClientRect.",
                "        const elementRect = _getElementRect(element);",
                "        return (",
                "            elementRect.left >= 0 &&",
                "            elementRect.left + element.offsetWidth <= viewportSize.width &&",
                "            elementRect.top >= 0 &&",
                "            elementRect.top + element.offsetHeight <= viewportSize.height",
                "        );",
                "    }",
                "    // 在这里做RTL判断 top-left 定位转化为等效的 top-right定位",
                "    _setPinElementPostion(pinElement, postion, offset = [0, 0]) {",
                "        const { top, left } = postion;",
                "        if (!this.isRtl) {",
                "            dom.setStyle(pinElement, {",
                "                left: `${left + offset[0]}px`,",
                "                top: `${top + offset[1]}px`,",
                "            });",
                "            return;",
                "        }",
                "",
                "        // transfer {left,top} equaly to {right,top}",
                "        const pinElementParentOffset = this._getParentOffset(pinElement);",
                "        const { width: offsetParentWidth } = _getElementRect(",
                "            pinElementParentOffset.offsetParent",
                "        );",
                "        const { width } = _getElementRect(pinElement);",
                "        const right = offsetParentWidth - (left + width);",
                "        dom.setStyle(pinElement, {",
                "            left: 'auto',",
                "            right: `${right + offset[0]}px`,",
                "            top: `${top + offset[1]}px`,",
                "        });",
                "    }",
                "}"
            ]
        }
    },
    "bug_functions": {}
}