{
    "1": {
        "bug_file": "src/js/components/Form/Form.js",
        "compressed": "YES",
        "line_numbers": 604,
        "compressed_line_numbers": 172,
        "compressed_bug_file_content": "import React, {\n\n\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\n\n\n// Apply validation rule to field value and send correct messaging.\n\n\n// Validates particular key in formValue\n\n\n      // false is for CheckBox\n\n\n// Validates all keys in formValue\n\n\n      // input() a validation function supplied through useFormInput()\n\n\n      // field() a validation function supplied through useFormField()\n\n\n    // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n\n\n    // maintain a copy of validationResults in a ref for useEffects\n    // which can't depend on validationResults directly without\n    // causing infinite renders.\n\n    // Simulated onMount state. Consider Form to be mounted once it has\n    // accounted for values originating from controlled inputs (available\n    // at second rendering).\n\n\n    // `pendingValidation` is the name of the FormField awaiting validation.\n\n\n    // Only keep validation results for current form fields. In the case of a\n    // dynamic form, a field possessing an error may have been removed from the\n    // form; need to clean up any previous related validation results.\n\n\n          // Keep any previous errors and infos for untouched keys,\n          // these may have come from a Submit.\n\n\n          // Remove previous errors and infos for keys no longer in the\n          // form, these may have been fields removed from a dynamic form.\n\n\n    // Validate all fields holding values onMount if set to\n    // validate when blur or change.\n\n\n      // Use simulated onMount state to account for values provided by\n      // controlled inputs.\n\n\n            // Exlude empty arrays which may be initial values in\n            // an input such as DateInput.\n\n\n    // Run validation against fields with pendingValidations from onBlur\n    // and/or onChange.\n\n\n        // Complete any potential click events before running onBlur validation.\n        // Otherwise, click events like reset, etc. may not be registered. For a\n        // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863\n        // Values empirically tested; 120 was selected because it is the largest\n        // Chrome: 100, Safari: 120, Firefox: 80\n\n\n    // Re-run validation rules for all fields with prior errors.\n    // if validate=blur this helps re-validate if there are errors\n    // as the user fixes them (basically act like validate=change for that)\n\n\n    // There are three basic patterns of handling form input value state:\n    //\n    // 1 - form controlled\n    //\n    // In this model, the caller sets `value` and `onChange` properties\n    // on the Form component to supply the values used by the input fields.\n    // In useFormContext(), componentValue would be undefined and formValue\n    // is be set to whatever the form state has. Whenever the form state\n    // changes, we update the contextValue so the input component will use\n    // that. When the input component changes, we will call update() to\n    // update the form state.\n    //\n    // 2 - input controlled\n    //\n    // In this model, the caller sets `value` and `onChange` properties\n    // on the input components, like TextInput, to supply the value for it.\n    // In useFormContext(), componentValue is this value and we ensure to\n    // update the form state, via update(), and set the contextValue from\n    // the componentValue. When the input component changes, we will\n    // call update() to update the form state.\n    //\n    // 3 - uncontrolled\n    //\n    // In this model, the caller doesn't set a `value` or `onChange` property\n    // at either the form or input component levels.\n    // In useFormContext(), componentValue is undefined and valueProp is\n    // undefined and nothing much happens here. That is, unless the\n    // calling component needs to know the state in order to work, such\n    // as CheckBox or Select. In this case, those components supply\n    // an initialValue, which will trigger updating the contextValue so\n    // they can have access to it.\n    //\n\n\n        // for dynamic forms, we need to track when an input has been added to\n        // the form value. if the input is unmounted, we will delete its\n        // key/value from the form value.\n\n\n        // This effect is for pattern #2, where the controlled input\n        // component is driving the value via componentValue.\n\n\n            // don't onChange on programmatic changes\n\n\n        // on unmount, if the form is uncontrolled, remove the key/value\n        // from the form value\n\n\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n\n\n        // Create validation rules for fields\n\n\n          // input component drives, pattern #2\n\n\n          // form drives, pattern #1\n\n\n          // form has reset, so reset input value as well\n\n\n              // we have somewhere to put this\n\n\n                // don't update if not needed\n\n\n              // if nextValue doesn't have a key for name, this must be\n              // uncontrolled form. we will flag this field was added so\n              // we know to remove its value from the form if it is dynamically\n              // removed\n\n\n        // Create validation rules for field\n\n\n          // Don't submit the form via browser form action. We don't want it\n          // if the validation fails. And, we assume a javascript action handler\n          // otherwise.\n\n\n              // Show form's validity when clicking on Submit\n\n\nexport { Form };\n"
    },
    "2": {
        "bug_file": "src/js/components/Form/stories/DynamicFields.js",
        "compressed": "NO",
        "line_numbers": 52,
        "compressed_line_numbers": 52,
        "compressed_bug_file_content": "import React, { useState } from 'react';\n\nimport { Box, Button, CheckBox, Form, FormField, TextInput } from 'grommet';\n\nexport const DynamicFields = () => {\n  const [haveAlias, setHaveAlias] = useState();\n  return (\n    // Uncomment <Grommet> lines when using outside of storybook\n    // <Grommet theme={...}>\n    <Box fill align=\"center\" justify=\"center\">\n      <Box width=\"medium\">\n        <Form\n          validate=\"blur\"\n          onReset={(event) => console.log(event)}\n          onValidate={(event) => console.log('Validate', event)}\n          onSubmit={({ value }) => console.log('Submit', value)}\n        >\n          <FormField label=\"Name\" name=\"name\" required>\n            <TextInput name=\"name\" />\n          </FormField>\n          <FormField name=\"haveAlias\">\n            <CheckBox\n              name=\"haveAlias\"\n              label=\"alias?\"\n              checked={haveAlias}\n              onChange={() => setHaveAlias(!haveAlias)}\n            />\n          </FormField>\n          {haveAlias && (\n            <FormField label=\"Alias\" name=\"alias\" required>\n              <TextInput name=\"alias\" />\n            </FormField>\n          )}\n          <Box direction=\"row\" justify=\"between\" margin={{ top: 'medium' }}>\n            <Button type=\"reset\" label=\"Reset\" />\n            <Button type=\"submit\" label=\"Update\" primary />\n          </Box>\n        </Form>\n      </Box>\n    </Box>\n    // </Grommet>\n  );\n};\n\nDynamicFields.storyName = 'Dynamic fields';\nDynamicFields.args = {\n  full: true,\n};\n\nexport default {\n  title: 'Input/Form/Dynamic fields',\n};"
    },
    "3": {
        "bug_file": "src/js/components/Form/FormContext.js",
        "compressed": "NO",
        "line_numbers": 24,
        "compressed_line_numbers": 24,
        "compressed_bug_file_content": "import React, { useState } from 'react';\n\n// When not a descendant of a Form, FormContext still provides a basic\n// useFormInput. It doesn't do anything for components like TextInput.\n// But, it does store the value for components like CheckBox or Select\n// where the grommet component needs to know the value in order to\n// render custom visuals.\nconst useFormInput = ({ value: valueProp, initialValue }) => {\n  const [value, setValue] = useState(\n    valueProp !== undefined ? valueProp : initialValue,\n  );\n\n  // Returns an array [value and function to set the value]\n  return [\n    valueProp !== undefined ? valueProp : value,\n    (nextValue) => {\n      if (initialValue !== undefined) setValue(nextValue);\n    },\n  ];\n};\n\nconst useFormField = ({ error, info, disabled }) => ({ error, info, disabled });\n\nexport const FormContext = React.createContext({ useFormField, useFormInput });"
    }
}