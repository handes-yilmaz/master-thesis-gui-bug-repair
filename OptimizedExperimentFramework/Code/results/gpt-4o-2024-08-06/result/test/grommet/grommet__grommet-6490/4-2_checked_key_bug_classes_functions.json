{
    "bug_classes": {
        "1": {
            "class_name": "Box (not found) ",
            "file_path": "src/js/components/Box/Box.js",
            "class_details": [
                {
                    "name": "Box",
                    "start_line": 1,
                    "end_line": 231
                }
            ],
            "class_code": [
                "import React, {",
                "  Children,",
                "  forwardRef,",
                "  useContext,",
                "  useEffect,",
                "  useMemo,",
                "  useState,",
                "} from 'react';",
                "",
                "import { ThemeContext } from 'styled-components';",
                "import { defaultProps } from '../../default-props';",
                "import { backgroundIsDark } from '../../utils';",
                "import { Keyboard } from '../Keyboard';",
                "",
                "import { StyledBox, StyledBoxGap } from './StyledBox';",
                "import { BoxPropTypes } from './propTypes';",
                "import { SkeletonContext, useSkeleton } from '../Skeleton';",
                "import { AnnounceContext } from '../../contexts/AnnounceContext';",
                "",
                "const Box = forwardRef(",
                "  (",
                "    {",
                "      a11yTitle,",
                "      background: backgroundProp,",
                "      border,",
                "      children,",
                "      direction = 'column',",
                "      elevation, // munged to avoid styled-components putting it in the DOM",
                "      fill, // munged to avoid styled-components putting it in the DOM",
                "      gap,",
                "      kind, // munged to avoid styled-components putting it in the DOM",
                "      onBlur,",
                "      onClick,",
                "      onFocus,",
                "      overflow, // munged to avoid styled-components putting it in the DOM",
                "      responsive = true,",
                "      tag,",
                "      as,",
                "      wrap, // munged to avoid styled-components putting it in the DOM,",
                "      width, // munged to avoid styled-components putting it in the DOM",
                "      height, // munged to avoid styled-components putting it in the DOM",
                "      tabIndex,",
                "      skeleton: skeletonProp,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const theme = useContext(ThemeContext) || defaultProps.theme;",
                "",
                "    const skeleton = useSkeleton();",
                "",
                "    let background = backgroundProp;",
                "",
                "    const announce = useContext(AnnounceContext);",
                "",
                "    useEffect(() => {",
                "      if (skeletonProp?.message?.start) announce(skeletonProp.message.start);",
                "      else if (typeof skeletonProp?.message === 'string')",
                "        announce(skeletonProp.message);",
                "      return () =>",
                "        skeletonProp?.message?.end && announce(skeletonProp.message.end);",
                "    }, [announce, skeletonProp]);",
                "",
                "    const focusable = useMemo(",
                "      () => onClick && !(tabIndex < 0),",
                "      [onClick, tabIndex],",
                "    );",
                "",
                "    const [focus, setFocus] = useState();",
                "",
                "    const clickProps = useMemo(() => {",
                "      if (focusable) {",
                "        return {",
                "          onClick,",
                "          onFocus: (event) => {",
                "            setFocus(true);",
                "            if (onFocus) onFocus(event);",
                "          },",
                "          onBlur: (event) => {",
                "            setFocus(false);",
                "            if (onBlur) onBlur(event);",
                "          },",
                "        };",
                "      }",
                "      const result = {};",
                "      if (onBlur) result.onBlur = onBlur;",
                "      if (onClick) result.onClick = onClick;",
                "      if (onFocus) result.onFocus = onFocus;",
                "      return result;",
                "    }, [focusable, onClick, onFocus, onBlur]);",
                "",
                "    const adjustedTabIndex = useMemo(() => {",
                "      if (tabIndex !== undefined) return tabIndex;",
                "      if (focusable) return 0;",
                "      return undefined;",
                "    }, [focusable, tabIndex]);",
                "",
                "    if (",
                "      (border === 'between' || (border && border.side === 'between')) &&",
                "      !gap",
                "    ) {",
                "      console.warn('Box must have a gap to use border between');",
                "    }",
                "",
                "    let contents = children;",
                "    if (gap && gap !== 'none') {",
                "      const boxAs = !as && tag ? tag : as;",
                "      contents = [];",
                "      let firstIndex;",
                "      Children.forEach(children, (child, index) => {",
                "        if (child) {",
                "          if (firstIndex === undefined) {",
                "            firstIndex = index;",
                "          } else {",
                "            contents.push(",
                "              <StyledBoxGap",
                "                // eslint-disable-next-line react/no-array-index-key",
                "                key={`gap-${index}`}",
                "                as={boxAs === 'span' ? boxAs : 'div'}",
                "                gap={gap}",
                "                directionProp={direction}",
                "                responsive={responsive}",
                "                border={border}",
                "              />,",
                "            );",
                "          }",
                "        }",
                "        contents.push(child);",
                "      });",
                "    }",
                "",
                "    const nextSkeleton = useMemo(() => {",
                "      // Decide if we need to add a new SkeletonContext. We need one if:",
                "      //   1. skeleton info was set in a property OR",
                "      //   2. there already is a SkeletonContext but this box has a",
                "      //      background or border. This means the box probably is more",
                "      //      distinguishable from the area around it.",
                "      // We keep track of a depth so we know how to alternate backgrounds.",
                "      if (skeletonProp || ((background || border) && skeleton)) {",
                "        const depth = skeleton ? skeleton.depth + 1 : 0;",
                "        return {",
                "          ...skeleton,",
                "          depth,",
                "          ...(typeof skeletonProp === 'object' ? skeletonProp : {}),",
                "        };",
                "      }",
                "      return undefined;",
                "    }, [background, border, skeleton, skeletonProp]);",
                "",
                "    let skeletonProps = {};",
                "    if (nextSkeleton) {",
                "      const {",
                "        colors: skeletonThemeColors,",
                "        size: skeletonThemeSize,",
                "        ...skeletonThemeProps",
                "      } = theme.skeleton;",
                "      const skeletonColors = nextSkeleton.colors",
                "        ? nextSkeleton.colors[theme.dark ? 'dark' : 'light']",
                "        : skeletonThemeColors?.[theme.dark ? 'dark' : 'light'];",
                "      skeletonProps = { ...skeletonThemeProps };",
                "      background = skeletonColors[nextSkeleton.depth % skeletonColors.length];",
                "      if (skeletonProp?.animation) {",
                "        skeletonProps.animation = skeletonProp.animation;",
                "      }",
                "      contents = (",
                "        <SkeletonContext.Provider value={nextSkeleton}>",
                "          {contents}",
                "        </SkeletonContext.Provider>",
                "      );",
                "    }",
                "",
                "    // construct a new theme object in case we have a background that wants",
                "    // to change the background color context",
                "    const nextTheme = useMemo(() => {",
                "      let result;",
                "      if (background || theme.darkChanged) {",
                "        const dark = backgroundIsDark(background, theme);",
                "        const darkChanged = dark !== undefined && dark !== theme.dark;",
                "        if (darkChanged || theme.darkChanged) {",
                "          result = { ...theme };",
                "          result.dark = dark === undefined ? theme.dark : dark;",
                "          result.background = background;",
                "        } else if (background) {",
                "          // This allows DataTable to intelligently set the background",
                "          // of a pinned header or footer.",
                "          result = { ...theme };",
                "          result.background = background;",
                "        }",
                "      }",
                "      return result || theme;",
                "    }, [background, theme]);",
                "",
                "    let content = (",
                "      <StyledBox",
                "        as={!as && tag ? tag : as}",
                "        aria-label={a11yTitle}",
                "        background={background}",
                "        border={border}",
                "        ref={ref}",
                "        directionProp={direction}",
                "        elevationProp={elevation}",
                "        fillProp={fill}",
                "        focus={focus}",
                "        kindProp={kind}",
                "        overflowProp={overflow}",
                "        wrapProp={wrap}",
                "        widthProp={width}",
                "        heightProp={height}",
                "        responsive={responsive}",
                "        tabIndex={adjustedTabIndex}",
                "        {...clickProps}",
                "        {...rest}",
                "        {...skeletonProps}",
                "      >",
                "        <ThemeContext.Provider value={nextTheme}>",
                "          {contents}",
                "        </ThemeContext.Provider>",
                "      </StyledBox>",
                "    );",
                "",
                "    if (onClick) {",
                "      content = <Keyboard onEnter={onClick}>{content}</Keyboard>;",
                "    }",
                "",
                "    return content;",
                "  },",
                ");",
                "",
                "Box.displayName = 'Box';",
                "Box.propTypes = BoxPropTypes;",
                "export { Box };"
            ]
        },
        "2": {
            "class_name": "StyledBoxGap (not found) ",
            "file_path": "src/js/components/Box/StyledBox.js",
            "class_details": [
                {
                    "name": "StyledBoxGap",
                    "start_line": 1,
                    "end_line": 396
                }
            ],
            "class_code": [
                "import styled, { css } from 'styled-components';",
                "",
                "import { defaultProps } from '../../default-props';",
                "import {",
                "  alignContentStyle,",
                "  alignStyle,",
                "  backgroundStyle,",
                "  borderStyle,",
                "  breakpointStyle,",
                "  edgeStyle,",
                "  fillStyle,",
                "  focusStyle,",
                "  genericStyles,",
                "  getBreakpointStyle,",
                "  getHoverIndicatorStyle,",
                "  heightStyle,",
                "  overflowStyle,",
                "  parseMetricToNum,",
                "  responsiveBorderStyle,",
                "  widthStyle,",
                "} from '../../utils';",
                "",
                "import { roundStyle } from '../../utils/styles';",
                "",
                "import { animationBounds, animationObjectStyle } from '../../utils/animation';",
                "",
                "const BASIS_MAP = {",
                "  auto: 'auto',",
                "  full: '100%',",
                "  '1/2': '50%',",
                "  '1/4': '25%',",
                "  '2/4': '50%',",
                "  '3/4': '75%',",
                "  '1/3': '33.33%',",
                "  '2/3': '66.66%',",
                "};",
                "",
                "const basisStyle = css`",
                "  flex-basis: ${(props) =>",
                "    BASIS_MAP[props.basis] ||",
                "    props.theme.global.size[props.basis] ||",
                "    props.basis};",
                "`;",
                "",
                "// min-width and min-height needed because of this",
                "// https://stackoverflow.com/questions/36247140/why-doesnt-flex-item-shrink-past-content-size",
                "// we assume we are in the context of a Box going the other direction",
                "// TODO: revisit this",
                "const directionStyle = (direction, theme) => {",
                "  const styles = [",
                "    css`",
                "      min-width: 0;",
                "      min-height: 0;",
                "      flex-direction: ${direction === 'row-responsive' ? 'row' : direction};",
                "    `,",
                "  ];",
                "  if (direction === 'row-responsive' && theme.box.responsiveBreakpoint) {",
                "    const breakpoint = getBreakpointStyle(",
                "      theme,",
                "      theme.box.responsiveBreakpoint,",
                "    );",
                "    if (breakpoint) {",
                "      styles.push(",
                "        breakpointStyle(",
                "          breakpoint,",
                "          `",
                "        flex-direction: column;",
                "        flex-basis: auto;",
                "        justify-content: flex-start;",
                "        align-items: stretch;",
                "      `,",
                "        ),",
                "      );",
                "    }",
                "  }",
                "  return styles;",
                "};",
                "",
                "const elevationStyle = (elevation) => css`",
                "  box-shadow: ${(props) =>",
                "    props.theme.global.elevation[props.theme.dark ? 'dark' : 'light'][",
                "      elevation",
                "    ]};",
                "`;",
                "",
                "const FLEX_MAP = {",
                "  [true]: '1 1',",
                "  [false]: '0 0',",
                "  grow: '1 0',",
                "  shrink: '0 1',",
                "};",
                "",
                "const flexGrowShrinkProp = (flex) => {",
                "  if (typeof flex === 'boolean' || typeof flex === 'string') {",
                "    return FLEX_MAP[flex];",
                "  }",
                "",
                "  return `${flex.grow ? flex.grow : 0} ${flex.shrink ? flex.shrink : 0}`;",
                "};",
                "",
                "const flexStyle = css`",
                "  flex: ${(props) =>",
                "    `${flexGrowShrinkProp(props.flex)}${",
                "      props.flex !== true && !props.basis ? ' auto' : ''",
                "    }`};",
                "`;",
                "",
                "const JUSTIFY_MAP = {",
                "  around: 'space-around',",
                "  between: 'space-between',",
                "  center: 'center',",
                "  end: 'flex-end',",
                "  evenly: 'space-evenly',",
                "  start: 'flex-start',",
                "};",
                "",
                "const justifyStyle = css`",
                "  justify-content: ${(props) => JUSTIFY_MAP[props.justify]};",
                "`;",
                "",
                "const WRAP_MAP = {",
                "  true: 'wrap',",
                "  reverse: 'wrap-reverse',",
                "};",
                "",
                "const wrapStyle = css`",
                "  flex-wrap: ${(props) => WRAP_MAP[props.wrapProp]};",
                "`;",
                "",
                "const animationItemStyle = (item, theme) => {",
                "  if (typeof item === 'string') {",
                "    return animationObjectStyle({ type: item }, theme);",
                "  }",
                "  if (Array.isArray(item)) {",
                "    return item.reduce(",
                "      (style, a, index) =>",
                "        css`",
                "          ${style}${index > 0 ? ',' : ''} ${animationItemStyle(a, theme)}",
                "        `,",
                "      '',",
                "    );",
                "  }",
                "  if (typeof item === 'object') {",
                "    return animationObjectStyle(item, theme);",
                "  }",
                "  return '';",
                "};",
                "",
                "const animationAncilaries = (animation) => {",
                "  if (animation.type === 'flipIn' || animation.type === 'flipOut') {",
                "    return 'perspective: 1000px; transform-style: preserve-3d;';",
                "  }",
                "  return '';",
                "};",
                "",
                "const animationObjectInitialStyle = (animation) => {",
                "  const bounds = animationBounds(animation.type, animation.size);",
                "  if (bounds) {",
                "    return `${bounds[0]} ${animationAncilaries(animation)}`;",
                "  }",
                "  return '';",
                "};",
                "",
                "const animationInitialStyle = (item) => {",
                "  if (typeof item === 'string') {",
                "    return animationObjectInitialStyle({ type: item });",
                "  }",
                "  if (Array.isArray(item)) {",
                "    return item",
                "      .map((a) =>",
                "        typeof a === 'string'",
                "          ? animationObjectInitialStyle({ type: a })",
                "          : animationObjectInitialStyle(a),",
                "      )",
                "      .join('');",
                "  }",
                "  if (typeof item === 'object') {",
                "    return animationObjectInitialStyle(item);",
                "  }",
                "  return '';",
                "};",
                "",
                "const animationStyle = css`",
                "  ${(props) => css`",
                "    ${animationInitialStyle(props.animation)}",
                "    animation: ${animationItemStyle(props.animation, props.theme)};",
                "  `};",
                "`;",
                "",
                "const interactiveStyle = css`",
                "  cursor: pointer;",
                "",
                "  &:hover {",
                "    ${(props) =>",
                "      props.kindProp?.hover &&",
                "      getHoverIndicatorStyle(props.kindProp.hover, props.theme)}",
                "    ${(props) =>",
                "      props.hoverIndicator &&",
                "      getHoverIndicatorStyle(props.hoverIndicator, props.theme)}",
                "  }",
                "`;",
                "",
                "// NOTE: basis must be after flex! Otherwise, flex overrides basis",
                "const StyledBox = styled.div`",
                "  display: flex;",
                "  box-sizing: border-box;",
                "  ${(props) => !props.basis && 'max-width: 100%;'};",
                "",
                "  ${genericStyles}",
                "  ${(props) => props.align && alignStyle}",
                "  ${(props) => props.alignContent && alignContentStyle}",
                "  ${(props) =>",
                "    props.background && backgroundStyle(props.background, props.theme)}",
                "  ${(props) =>",
                "    props.border && borderStyle(props.border, props.responsive, props.theme)}",
                "  ${(props) =>",
                "    props.directionProp && directionStyle(props.directionProp, props.theme)}",
                "  ${(props) => props.heightProp && heightStyle(props.heightProp, props.theme)}",
                "  ${(props) => props.widthProp && widthStyle(props.widthProp, props.theme)}",
                "  ${(props) => props.flex !== undefined && flexStyle}",
                "  ${(props) => props.basis && basisStyle}",
                "  ${(props) => props.fillProp && fillStyle(props.fillProp)}",
                "  ${(props) => props.justify && justifyStyle}",
                "  ${(props) =>",
                "    props.pad &&",
                "    edgeStyle(",
                "      'padding',",
                "      props.pad,",
                "      props.responsive,",
                "      props.theme.box.responsiveBreakpoint,",
                "      props.theme,",
                "    )}",
                "  ${(props) =>",
                "    props.round && roundStyle(props.round, props.responsive, props.theme)}",
                "  ${(props) => props.wrapProp && wrapStyle}",
                "  ${(props) => props.overflowProp && overflowStyle(props.overflowProp)}",
                "  ${(props) => props.elevationProp && elevationStyle(props.elevationProp)}",
                "  ${(props) => props.animation && animationStyle}",
                "  ${(props) => props.onClick && interactiveStyle}",
                "  ${(props) =>",
                "    props.onClick &&",
                "    props.focus &&",
                "    props.focusIndicator !== false &&",
                "    focusStyle()}",
                "  ${(props) => props.theme.box && props.theme.box.extend}",
                "  ${(props) => props.kindProp && props.kindProp.extend}",
                "`;",
                "",
                "const gapStyle = (directionProp, gap, responsive, border, theme) => {",
                "  const metric = theme.global.edgeSize[gap] || gap;",
                "  const breakpoint = getBreakpointStyle(theme, theme.box.responsiveBreakpoint);",
                "  const responsiveMetric = responsive && breakpoint && breakpoint.edgeSize[gap];",
                "",
                "  const styles = [];",
                "  if (directionProp === 'column' || directionProp === 'column-reverse') {",
                "    styles.push(`height: ${metric};`);",
                "    if (responsiveMetric) {",
                "      styles.push(breakpointStyle(breakpoint, `height: ${responsiveMetric};`));",
                "    }",
                "  } else {",
                "    styles.push(`width: ${metric};`);",
                "    if (responsiveMetric) {",
                "      if (directionProp === 'row' || directionProp === 'row-reverse') {",
                "        styles.push(breakpointStyle(breakpoint, `width: ${responsiveMetric};`));",
                "      } else if (directionProp === 'row-responsive') {",
                "        styles.push(",
                "          breakpointStyle(",
                "            breakpoint,",
                "            `",
                "          width: auto;",
                "          height: ${responsiveMetric};",
                "        `,",
                "          ),",
                "        );",
                "      }",
                "    }",
                "  }",
                "",
                "  if (border === 'between' || (border && border.side === 'between')) {",
                "    const borderSize = border.size || 'xsmall';",
                "    const borderMetric = theme.global.borderSize[borderSize] || borderSize;",
                "    const borderOffset = `${",
                "      parseMetricToNum(metric) / 2 - parseMetricToNum(borderMetric) / 2",
                "    }px`;",
                "    const responsiveBorderMetric =",
                "      responsive &&",
                "      breakpoint &&",
                "      (breakpoint.borderSize[borderSize] || borderSize);",
                "    const responsiveBorderOffset =",
                "      responsiveBorderMetric &&",
                "      `${",
                "        parseMetricToNum(responsiveMetric) / 2 -",
                "        parseMetricToNum(responsiveBorderMetric) / 2",
                "      }px`;",
                "",
                "    if (directionProp === 'column' || directionProp === 'column-reverse') {",
                "      const adjustedBorder =",
                "        typeof border === 'string' ? 'top' : { ...border, side: 'top' };",
                "      styles.push(css`",
                "        position: relative;",
                "        &:after {",
                "          content: '';",
                "          position: absolute;",
                "          width: 100%;",
                "          top: ${borderOffset};",
                "          ${borderStyle(adjustedBorder, responsive, theme)}",
                "        }",
                "      `);",
                "      if (responsiveBorderOffset) {",
                "        styles.push(",
                "          breakpointStyle(",
                "            breakpoint,",
                "            `",
                "            &:after {",
                "              content: '';",
                "              top: ${responsiveBorderOffset};",
                "            }`,",
                "          ),",
                "        );",
                "      }",
                "    } else {",
                "      const adjustedBorder =",
                "        typeof border === 'string' ? 'left' : { ...border, side: 'left' };",
                "      styles.push(css`",
                "        position: relative;",
                "        &:after {",
                "          content: '';",
                "          position: absolute;",
                "          height: 100%;",
                "          left: ${borderOffset};",
                "          ${borderStyle(",
                "            adjustedBorder,",
                "            directionProp !== 'row-responsive' && responsive,",
                "            theme,",
                "          )}",
                "        }",
                "      `);",
                "      if (responsiveBorderOffset) {",
                "        if (directionProp === 'row' || directionProp === 'row-reverse') {",
                "          styles.push(",
                "            breakpointStyle(",
                "              breakpoint,",
                "              `",
                "              &:after {",
                "                content: '';",
                "                left: ${responsiveBorderOffset};",
                "              }`,",
                "            ),",
                "          );",
                "        } else if (directionProp === 'row-responsive') {",
                "          const adjustedBorder2 =",
                "            typeof border === 'string' ? 'top' : { ...border, side: 'top' };",
                "          styles.push(",
                "            breakpointStyle(",
                "              breakpoint,",
                "              `",
                "              &:after {",
                "                content: '';",
                "                height: auto;",
                "                left: unset;",
                "                width: 100%;",
                "                top: ${responsiveBorderOffset};",
                "                border-left: none;",
                "                ${responsiveBorderStyle(adjustedBorder2, theme)}",
                "              }`,",
                "            ),",
                "          );",
                "        }",
                "      }",
                "    }",
                "  }",
                "",
                "  return styles;",
                "};",
                "",
                "StyledBox.defaultProps = {};",
                "Object.setPrototypeOf(StyledBox.defaultProps, defaultProps);",
                "",
                "const StyledBoxGap = styled.div`",
                "  flex: 0 0 auto;",
                "  align-self: stretch;",
                "  ${(props) =>",
                "    props.gap &&",
                "    gapStyle(",
                "      props.directionProp,",
                "      props.gap,",
                "      props.responsive,",
                "      props.border,",
                "      props.theme,",
                "    )};",
                "`;",
                "",
                "StyledBoxGap.defaultProps = {};",
                "Object.setPrototypeOf(StyledBoxGap.defaultProps, defaultProps);",
                "",
                "export { StyledBox, StyledBoxGap };"
            ]
        }
    },
    "bug_functions": {
        "3": {
            "function_name": "Box (not found) ",
            "file_path": "src/js/components/Box/Box.js",
            "function_details": [
                {
                    "name": "Box",
                    "start_line": 1,
                    "end_line": 231
                }
            ],
            "function_code": [
                "import React, {",
                "  Children,",
                "  forwardRef,",
                "  useContext,",
                "  useEffect,",
                "  useMemo,",
                "  useState,",
                "} from 'react';",
                "",
                "import { ThemeContext } from 'styled-components';",
                "import { defaultProps } from '../../default-props';",
                "import { backgroundIsDark } from '../../utils';",
                "import { Keyboard } from '../Keyboard';",
                "",
                "import { StyledBox, StyledBoxGap } from './StyledBox';",
                "import { BoxPropTypes } from './propTypes';",
                "import { SkeletonContext, useSkeleton } from '../Skeleton';",
                "import { AnnounceContext } from '../../contexts/AnnounceContext';",
                "",
                "const Box = forwardRef(",
                "  (",
                "    {",
                "      a11yTitle,",
                "      background: backgroundProp,",
                "      border,",
                "      children,",
                "      direction = 'column',",
                "      elevation, // munged to avoid styled-components putting it in the DOM",
                "      fill, // munged to avoid styled-components putting it in the DOM",
                "      gap,",
                "      kind, // munged to avoid styled-components putting it in the DOM",
                "      onBlur,",
                "      onClick,",
                "      onFocus,",
                "      overflow, // munged to avoid styled-components putting it in the DOM",
                "      responsive = true,",
                "      tag,",
                "      as,",
                "      wrap, // munged to avoid styled-components putting it in the DOM,",
                "      width, // munged to avoid styled-components putting it in the DOM",
                "      height, // munged to avoid styled-components putting it in the DOM",
                "      tabIndex,",
                "      skeleton: skeletonProp,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const theme = useContext(ThemeContext) || defaultProps.theme;",
                "",
                "    const skeleton = useSkeleton();",
                "",
                "    let background = backgroundProp;",
                "",
                "    const announce = useContext(AnnounceContext);",
                "",
                "    useEffect(() => {",
                "      if (skeletonProp?.message?.start) announce(skeletonProp.message.start);",
                "      else if (typeof skeletonProp?.message === 'string')",
                "        announce(skeletonProp.message);",
                "      return () =>",
                "        skeletonProp?.message?.end && announce(skeletonProp.message.end);",
                "    }, [announce, skeletonProp]);",
                "",
                "    const focusable = useMemo(",
                "      () => onClick && !(tabIndex < 0),",
                "      [onClick, tabIndex],",
                "    );",
                "",
                "    const [focus, setFocus] = useState();",
                "",
                "    const clickProps = useMemo(() => {",
                "      if (focusable) {",
                "        return {",
                "          onClick,",
                "          onFocus: (event) => {",
                "            setFocus(true);",
                "            if (onFocus) onFocus(event);",
                "          },",
                "          onBlur: (event) => {",
                "            setFocus(false);",
                "            if (onBlur) onBlur(event);",
                "          },",
                "        };",
                "      }",
                "      const result = {};",
                "      if (onBlur) result.onBlur = onBlur;",
                "      if (onClick) result.onClick = onClick;",
                "      if (onFocus) result.onFocus = onFocus;",
                "      return result;",
                "    }, [focusable, onClick, onFocus, onBlur]);",
                "",
                "    const adjustedTabIndex = useMemo(() => {",
                "      if (tabIndex !== undefined) return tabIndex;",
                "      if (focusable) return 0;",
                "      return undefined;",
                "    }, [focusable, tabIndex]);",
                "",
                "    if (",
                "      (border === 'between' || (border && border.side === 'between')) &&",
                "      !gap",
                "    ) {",
                "      console.warn('Box must have a gap to use border between');",
                "    }",
                "",
                "    let contents = children;",
                "    if (gap && gap !== 'none') {",
                "      const boxAs = !as && tag ? tag : as;",
                "      contents = [];",
                "      let firstIndex;",
                "      Children.forEach(children, (child, index) => {",
                "        if (child) {",
                "          if (firstIndex === undefined) {",
                "            firstIndex = index;",
                "          } else {",
                "            contents.push(",
                "              <StyledBoxGap",
                "                // eslint-disable-next-line react/no-array-index-key",
                "                key={`gap-${index}`}",
                "                as={boxAs === 'span' ? boxAs : 'div'}",
                "                gap={gap}",
                "                directionProp={direction}",
                "                responsive={responsive}",
                "                border={border}",
                "              />,",
                "            );",
                "          }",
                "        }",
                "        contents.push(child);",
                "      });",
                "    }",
                "",
                "    const nextSkeleton = useMemo(() => {",
                "      // Decide if we need to add a new SkeletonContext. We need one if:",
                "      //   1. skeleton info was set in a property OR",
                "      //   2. there already is a SkeletonContext but this box has a",
                "      //      background or border. This means the box probably is more",
                "      //      distinguishable from the area around it.",
                "      // We keep track of a depth so we know how to alternate backgrounds.",
                "      if (skeletonProp || ((background || border) && skeleton)) {",
                "        const depth = skeleton ? skeleton.depth + 1 : 0;",
                "        return {",
                "          ...skeleton,",
                "          depth,",
                "          ...(typeof skeletonProp === 'object' ? skeletonProp : {}),",
                "        };",
                "      }",
                "      return undefined;",
                "    }, [background, border, skeleton, skeletonProp]);",
                "",
                "    let skeletonProps = {};",
                "    if (nextSkeleton) {",
                "      const {",
                "        colors: skeletonThemeColors,",
                "        size: skeletonThemeSize,",
                "        ...skeletonThemeProps",
                "      } = theme.skeleton;",
                "      const skeletonColors = nextSkeleton.colors",
                "        ? nextSkeleton.colors[theme.dark ? 'dark' : 'light']",
                "        : skeletonThemeColors?.[theme.dark ? 'dark' : 'light'];",
                "      skeletonProps = { ...skeletonThemeProps };",
                "      background = skeletonColors[nextSkeleton.depth % skeletonColors.length];",
                "      if (skeletonProp?.animation) {",
                "        skeletonProps.animation = skeletonProp.animation;",
                "      }",
                "      contents = (",
                "        <SkeletonContext.Provider value={nextSkeleton}>",
                "          {contents}",
                "        </SkeletonContext.Provider>",
                "      );",
                "    }",
                "",
                "    // construct a new theme object in case we have a background that wants",
                "    // to change the background color context",
                "    const nextTheme = useMemo(() => {",
                "      let result;",
                "      if (background || theme.darkChanged) {",
                "        const dark = backgroundIsDark(background, theme);",
                "        const darkChanged = dark !== undefined && dark !== theme.dark;",
                "        if (darkChanged || theme.darkChanged) {",
                "          result = { ...theme };",
                "          result.dark = dark === undefined ? theme.dark : dark;",
                "          result.background = background;",
                "        } else if (background) {",
                "          // This allows DataTable to intelligently set the background",
                "          // of a pinned header or footer.",
                "          result = { ...theme };",
                "          result.background = background;",
                "        }",
                "      }",
                "      return result || theme;",
                "    }, [background, theme]);",
                "",
                "    let content = (",
                "      <StyledBox",
                "        as={!as && tag ? tag : as}",
                "        aria-label={a11yTitle}",
                "        background={background}",
                "        border={border}",
                "        ref={ref}",
                "        directionProp={direction}",
                "        elevationProp={elevation}",
                "        fillProp={fill}",
                "        focus={focus}",
                "        kindProp={kind}",
                "        overflowProp={overflow}",
                "        wrapProp={wrap}",
                "        widthProp={width}",
                "        heightProp={height}",
                "        responsive={responsive}",
                "        tabIndex={adjustedTabIndex}",
                "        {...clickProps}",
                "        {...rest}",
                "        {...skeletonProps}",
                "      >",
                "        <ThemeContext.Provider value={nextTheme}>",
                "          {contents}",
                "        </ThemeContext.Provider>",
                "      </StyledBox>",
                "    );",
                "",
                "    if (onClick) {",
                "      content = <Keyboard onEnter={onClick}>{content}</Keyboard>;",
                "    }",
                "",
                "    return content;",
                "  },",
                ");",
                "",
                "Box.displayName = 'Box';",
                "Box.propTypes = BoxPropTypes;",
                "export { Box };"
            ]
        },
        "4": {
            "function_name": "gapStyle (not found) ",
            "file_path": "src/js/components/Box/StyledBox.js",
            "function_details": [
                {
                    "name": "gapStyle",
                    "start_line": 1,
                    "end_line": 396
                }
            ],
            "function_code": [
                "import styled, { css } from 'styled-components';",
                "",
                "import { defaultProps } from '../../default-props';",
                "import {",
                "  alignContentStyle,",
                "  alignStyle,",
                "  backgroundStyle,",
                "  borderStyle,",
                "  breakpointStyle,",
                "  edgeStyle,",
                "  fillStyle,",
                "  focusStyle,",
                "  genericStyles,",
                "  getBreakpointStyle,",
                "  getHoverIndicatorStyle,",
                "  heightStyle,",
                "  overflowStyle,",
                "  parseMetricToNum,",
                "  responsiveBorderStyle,",
                "  widthStyle,",
                "} from '../../utils';",
                "",
                "import { roundStyle } from '../../utils/styles';",
                "",
                "import { animationBounds, animationObjectStyle } from '../../utils/animation';",
                "",
                "const BASIS_MAP = {",
                "  auto: 'auto',",
                "  full: '100%',",
                "  '1/2': '50%',",
                "  '1/4': '25%',",
                "  '2/4': '50%',",
                "  '3/4': '75%',",
                "  '1/3': '33.33%',",
                "  '2/3': '66.66%',",
                "};",
                "",
                "const basisStyle = css`",
                "  flex-basis: ${(props) =>",
                "    BASIS_MAP[props.basis] ||",
                "    props.theme.global.size[props.basis] ||",
                "    props.basis};",
                "`;",
                "",
                "// min-width and min-height needed because of this",
                "// https://stackoverflow.com/questions/36247140/why-doesnt-flex-item-shrink-past-content-size",
                "// we assume we are in the context of a Box going the other direction",
                "// TODO: revisit this",
                "const directionStyle = (direction, theme) => {",
                "  const styles = [",
                "    css`",
                "      min-width: 0;",
                "      min-height: 0;",
                "      flex-direction: ${direction === 'row-responsive' ? 'row' : direction};",
                "    `,",
                "  ];",
                "  if (direction === 'row-responsive' && theme.box.responsiveBreakpoint) {",
                "    const breakpoint = getBreakpointStyle(",
                "      theme,",
                "      theme.box.responsiveBreakpoint,",
                "    );",
                "    if (breakpoint) {",
                "      styles.push(",
                "        breakpointStyle(",
                "          breakpoint,",
                "          `",
                "        flex-direction: column;",
                "        flex-basis: auto;",
                "        justify-content: flex-start;",
                "        align-items: stretch;",
                "      `,",
                "        ),",
                "      );",
                "    }",
                "  }",
                "  return styles;",
                "};",
                "",
                "const elevationStyle = (elevation) => css`",
                "  box-shadow: ${(props) =>",
                "    props.theme.global.elevation[props.theme.dark ? 'dark' : 'light'][",
                "      elevation",
                "    ]};",
                "`;",
                "",
                "const FLEX_MAP = {",
                "  [true]: '1 1',",
                "  [false]: '0 0',",
                "  grow: '1 0',",
                "  shrink: '0 1',",
                "};",
                "",
                "const flexGrowShrinkProp = (flex) => {",
                "  if (typeof flex === 'boolean' || typeof flex === 'string') {",
                "    return FLEX_MAP[flex];",
                "  }",
                "",
                "  return `${flex.grow ? flex.grow : 0} ${flex.shrink ? flex.shrink : 0}`;",
                "};",
                "",
                "const flexStyle = css`",
                "  flex: ${(props) =>",
                "    `${flexGrowShrinkProp(props.flex)}${",
                "      props.flex !== true && !props.basis ? ' auto' : ''",
                "    }`};",
                "`;",
                "",
                "const JUSTIFY_MAP = {",
                "  around: 'space-around',",
                "  between: 'space-between',",
                "  center: 'center',",
                "  end: 'flex-end',",
                "  evenly: 'space-evenly',",
                "  start: 'flex-start',",
                "};",
                "",
                "const justifyStyle = css`",
                "  justify-content: ${(props) => JUSTIFY_MAP[props.justify]};",
                "`;",
                "",
                "const WRAP_MAP = {",
                "  true: 'wrap',",
                "  reverse: 'wrap-reverse',",
                "};",
                "",
                "const wrapStyle = css`",
                "  flex-wrap: ${(props) => WRAP_MAP[props.wrapProp]};",
                "`;",
                "",
                "const animationItemStyle = (item, theme) => {",
                "  if (typeof item === 'string') {",
                "    return animationObjectStyle({ type: item }, theme);",
                "  }",
                "  if (Array.isArray(item)) {",
                "    return item.reduce(",
                "      (style, a, index) =>",
                "        css`",
                "          ${style}${index > 0 ? ',' : ''} ${animationItemStyle(a, theme)}",
                "        `,",
                "      '',",
                "    );",
                "  }",
                "  if (typeof item === 'object') {",
                "    return animationObjectStyle(item, theme);",
                "  }",
                "  return '';",
                "};",
                "",
                "const animationAncilaries = (animation) => {",
                "  if (animation.type === 'flipIn' || animation.type === 'flipOut') {",
                "    return 'perspective: 1000px; transform-style: preserve-3d;';",
                "  }",
                "  return '';",
                "};",
                "",
                "const animationObjectInitialStyle = (animation) => {",
                "  const bounds = animationBounds(animation.type, animation.size);",
                "  if (bounds) {",
                "    return `${bounds[0]} ${animationAncilaries(animation)}`;",
                "  }",
                "  return '';",
                "};",
                "",
                "const animationInitialStyle = (item) => {",
                "  if (typeof item === 'string') {",
                "    return animationObjectInitialStyle({ type: item });",
                "  }",
                "  if (Array.isArray(item)) {",
                "    return item",
                "      .map((a) =>",
                "        typeof a === 'string'",
                "          ? animationObjectInitialStyle({ type: a })",
                "          : animationObjectInitialStyle(a),",
                "      )",
                "      .join('');",
                "  }",
                "  if (typeof item === 'object') {",
                "    return animationObjectInitialStyle(item);",
                "  }",
                "  return '';",
                "};",
                "",
                "const animationStyle = css`",
                "  ${(props) => css`",
                "    ${animationInitialStyle(props.animation)}",
                "    animation: ${animationItemStyle(props.animation, props.theme)};",
                "  `};",
                "`;",
                "",
                "const interactiveStyle = css`",
                "  cursor: pointer;",
                "",
                "  &:hover {",
                "    ${(props) =>",
                "      props.kindProp?.hover &&",
                "      getHoverIndicatorStyle(props.kindProp.hover, props.theme)}",
                "    ${(props) =>",
                "      props.hoverIndicator &&",
                "      getHoverIndicatorStyle(props.hoverIndicator, props.theme)}",
                "  }",
                "`;",
                "",
                "// NOTE: basis must be after flex! Otherwise, flex overrides basis",
                "const StyledBox = styled.div`",
                "  display: flex;",
                "  box-sizing: border-box;",
                "  ${(props) => !props.basis && 'max-width: 100%;'};",
                "",
                "  ${genericStyles}",
                "  ${(props) => props.align && alignStyle}",
                "  ${(props) => props.alignContent && alignContentStyle}",
                "  ${(props) =>",
                "    props.background && backgroundStyle(props.background, props.theme)}",
                "  ${(props) =>",
                "    props.border && borderStyle(props.border, props.responsive, props.theme)}",
                "  ${(props) =>",
                "    props.directionProp && directionStyle(props.directionProp, props.theme)}",
                "  ${(props) => props.heightProp && heightStyle(props.heightProp, props.theme)}",
                "  ${(props) => props.widthProp && widthStyle(props.widthProp, props.theme)}",
                "  ${(props) => props.flex !== undefined && flexStyle}",
                "  ${(props) => props.basis && basisStyle}",
                "  ${(props) => props.fillProp && fillStyle(props.fillProp)}",
                "  ${(props) => props.justify && justifyStyle}",
                "  ${(props) =>",
                "    props.pad &&",
                "    edgeStyle(",
                "      'padding',",
                "      props.pad,",
                "      props.responsive,",
                "      props.theme.box.responsiveBreakpoint,",
                "      props.theme,",
                "    )}",
                "  ${(props) =>",
                "    props.round && roundStyle(props.round, props.responsive, props.theme)}",
                "  ${(props) => props.wrapProp && wrapStyle}",
                "  ${(props) => props.overflowProp && overflowStyle(props.overflowProp)}",
                "  ${(props) => props.elevationProp && elevationStyle(props.elevationProp)}",
                "  ${(props) => props.animation && animationStyle}",
                "  ${(props) => props.onClick && interactiveStyle}",
                "  ${(props) =>",
                "    props.onClick &&",
                "    props.focus &&",
                "    props.focusIndicator !== false &&",
                "    focusStyle()}",
                "  ${(props) => props.theme.box && props.theme.box.extend}",
                "  ${(props) => props.kindProp && props.kindProp.extend}",
                "`;",
                "",
                "const gapStyle = (directionProp, gap, responsive, border, theme) => {",
                "  const metric = theme.global.edgeSize[gap] || gap;",
                "  const breakpoint = getBreakpointStyle(theme, theme.box.responsiveBreakpoint);",
                "  const responsiveMetric = responsive && breakpoint && breakpoint.edgeSize[gap];",
                "",
                "  const styles = [];",
                "  if (directionProp === 'column' || directionProp === 'column-reverse') {",
                "    styles.push(`height: ${metric};`);",
                "    if (responsiveMetric) {",
                "      styles.push(breakpointStyle(breakpoint, `height: ${responsiveMetric};`));",
                "    }",
                "  } else {",
                "    styles.push(`width: ${metric};`);",
                "    if (responsiveMetric) {",
                "      if (directionProp === 'row' || directionProp === 'row-reverse') {",
                "        styles.push(breakpointStyle(breakpoint, `width: ${responsiveMetric};`));",
                "      } else if (directionProp === 'row-responsive') {",
                "        styles.push(",
                "          breakpointStyle(",
                "            breakpoint,",
                "            `",
                "          width: auto;",
                "          height: ${responsiveMetric};",
                "        `,",
                "          ),",
                "        );",
                "      }",
                "    }",
                "  }",
                "",
                "  if (border === 'between' || (border && border.side === 'between')) {",
                "    const borderSize = border.size || 'xsmall';",
                "    const borderMetric = theme.global.borderSize[borderSize] || borderSize;",
                "    const borderOffset = `${",
                "      parseMetricToNum(metric) / 2 - parseMetricToNum(borderMetric) / 2",
                "    }px`;",
                "    const responsiveBorderMetric =",
                "      responsive &&",
                "      breakpoint &&",
                "      (breakpoint.borderSize[borderSize] || borderSize);",
                "    const responsiveBorderOffset =",
                "      responsiveBorderMetric &&",
                "      `${",
                "        parseMetricToNum(responsiveMetric) / 2 -",
                "        parseMetricToNum(responsiveBorderMetric) / 2",
                "      }px`;",
                "",
                "    if (directionProp === 'column' || directionProp === 'column-reverse') {",
                "      const adjustedBorder =",
                "        typeof border === 'string' ? 'top' : { ...border, side: 'top' };",
                "      styles.push(css`",
                "        position: relative;",
                "        &:after {",
                "          content: '';",
                "          position: absolute;",
                "          width: 100%;",
                "          top: ${borderOffset};",
                "          ${borderStyle(adjustedBorder, responsive, theme)}",
                "        }",
                "      `);",
                "      if (responsiveBorderOffset) {",
                "        styles.push(",
                "          breakpointStyle(",
                "            breakpoint,",
                "            `",
                "            &:after {",
                "              content: '';",
                "              top: ${responsiveBorderOffset};",
                "            }`,",
                "          ),",
                "        );",
                "      }",
                "    } else {",
                "      const adjustedBorder =",
                "        typeof border === 'string' ? 'left' : { ...border, side: 'left' };",
                "      styles.push(css`",
                "        position: relative;",
                "        &:after {",
                "          content: '';",
                "          position: absolute;",
                "          height: 100%;",
                "          left: ${borderOffset};",
                "          ${borderStyle(",
                "            adjustedBorder,",
                "            directionProp !== 'row-responsive' && responsive,",
                "            theme,",
                "          )}",
                "        }",
                "      `);",
                "      if (responsiveBorderOffset) {",
                "        if (directionProp === 'row' || directionProp === 'row-reverse') {",
                "          styles.push(",
                "            breakpointStyle(",
                "              breakpoint,",
                "              `",
                "              &:after {",
                "                content: '';",
                "                left: ${responsiveBorderOffset};",
                "              }`,",
                "            ),",
                "          );",
                "        } else if (directionProp === 'row-responsive') {",
                "          const adjustedBorder2 =",
                "            typeof border === 'string' ? 'top' : { ...border, side: 'top' };",
                "          styles.push(",
                "            breakpointStyle(",
                "              breakpoint,",
                "              `",
                "              &:after {",
                "                content: '';",
                "                height: auto;",
                "                left: unset;",
                "                width: 100%;",
                "                top: ${responsiveBorderOffset};",
                "                border-left: none;",
                "                ${responsiveBorderStyle(adjustedBorder2, theme)}",
                "              }`,",
                "            ),",
                "          );",
                "        }",
                "      }",
                "    }",
                "  }",
                "",
                "  return styles;",
                "};",
                "",
                "StyledBox.defaultProps = {};",
                "Object.setPrototypeOf(StyledBox.defaultProps, defaultProps);",
                "",
                "const StyledBoxGap = styled.div`",
                "  flex: 0 0 auto;",
                "  align-self: stretch;",
                "  ${(props) =>",
                "    props.gap &&",
                "    gapStyle(",
                "      props.directionProp,",
                "      props.gap,",
                "      props.responsive,",
                "      props.border,",
                "      props.theme,",
                "    )};",
                "`;",
                "",
                "StyledBoxGap.defaultProps = {};",
                "Object.setPrototypeOf(StyledBoxGap.defaultProps, defaultProps);",
                "",
                "export { StyledBox, StyledBoxGap };"
            ]
        }
    }
}