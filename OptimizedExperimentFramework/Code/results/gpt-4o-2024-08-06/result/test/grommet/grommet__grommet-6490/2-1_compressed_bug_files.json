{
    "1": {
        "bug_file": "src/js/components/Box/Box.js",
        "compressed": "NO",
        "line_numbers": 231,
        "compressed_line_numbers": 231,
        "compressed_bug_file_content": "import React, {\n  Children,\n  forwardRef,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react';\n\nimport { ThemeContext } from 'styled-components';\nimport { defaultProps } from '../../default-props';\nimport { backgroundIsDark } from '../../utils';\nimport { Keyboard } from '../Keyboard';\n\nimport { StyledBox, StyledBoxGap } from './StyledBox';\nimport { BoxPropTypes } from './propTypes';\nimport { SkeletonContext, useSkeleton } from '../Skeleton';\nimport { AnnounceContext } from '../../contexts/AnnounceContext';\n\nconst Box = forwardRef(\n  (\n    {\n      a11yTitle,\n      background: backgroundProp,\n      border,\n      children,\n      direction = 'column',\n      elevation, // munged to avoid styled-components putting it in the DOM\n      fill, // munged to avoid styled-components putting it in the DOM\n      gap,\n      kind, // munged to avoid styled-components putting it in the DOM\n      onBlur,\n      onClick,\n      onFocus,\n      overflow, // munged to avoid styled-components putting it in the DOM\n      responsive = true,\n      tag,\n      as,\n      wrap, // munged to avoid styled-components putting it in the DOM,\n      width, // munged to avoid styled-components putting it in the DOM\n      height, // munged to avoid styled-components putting it in the DOM\n      tabIndex,\n      skeleton: skeletonProp,\n      ...rest\n    },\n    ref,\n  ) => {\n    const theme = useContext(ThemeContext) || defaultProps.theme;\n\n    const skeleton = useSkeleton();\n\n    let background = backgroundProp;\n\n    const announce = useContext(AnnounceContext);\n\n    useEffect(() => {\n      if (skeletonProp?.message?.start) announce(skeletonProp.message.start);\n      else if (typeof skeletonProp?.message === 'string')\n        announce(skeletonProp.message);\n      return () =>\n        skeletonProp?.message?.end && announce(skeletonProp.message.end);\n    }, [announce, skeletonProp]);\n\n    const focusable = useMemo(\n      () => onClick && !(tabIndex < 0),\n      [onClick, tabIndex],\n    );\n\n    const [focus, setFocus] = useState();\n\n    const clickProps = useMemo(() => {\n      if (focusable) {\n        return {\n          onClick,\n          onFocus: (event) => {\n            setFocus(true);\n            if (onFocus) onFocus(event);\n          },\n          onBlur: (event) => {\n            setFocus(false);\n            if (onBlur) onBlur(event);\n          },\n        };\n      }\n      const result = {};\n      if (onBlur) result.onBlur = onBlur;\n      if (onClick) result.onClick = onClick;\n      if (onFocus) result.onFocus = onFocus;\n      return result;\n    }, [focusable, onClick, onFocus, onBlur]);\n\n    const adjustedTabIndex = useMemo(() => {\n      if (tabIndex !== undefined) return tabIndex;\n      if (focusable) return 0;\n      return undefined;\n    }, [focusable, tabIndex]);\n\n    if (\n      (border === 'between' || (border && border.side === 'between')) &&\n      !gap\n    ) {\n      console.warn('Box must have a gap to use border between');\n    }\n\n    let contents = children;\n    if (gap && gap !== 'none') {\n      const boxAs = !as && tag ? tag : as;\n      contents = [];\n      let firstIndex;\n      Children.forEach(children, (child, index) => {\n        if (child) {\n          if (firstIndex === undefined) {\n            firstIndex = index;\n          } else {\n            contents.push(\n              <StyledBoxGap\n                // eslint-disable-next-line react/no-array-index-key\n                key={`gap-${index}`}\n                as={boxAs === 'span' ? boxAs : 'div'}\n                gap={gap}\n                directionProp={direction}\n                responsive={responsive}\n                border={border}\n              />,\n            );\n          }\n        }\n        contents.push(child);\n      });\n    }\n\n    const nextSkeleton = useMemo(() => {\n      // Decide if we need to add a new SkeletonContext. We need one if:\n      //   1. skeleton info was set in a property OR\n      //   2. there already is a SkeletonContext but this box has a\n      //      background or border. This means the box probably is more\n      //      distinguishable from the area around it.\n      // We keep track of a depth so we know how to alternate backgrounds.\n      if (skeletonProp || ((background || border) && skeleton)) {\n        const depth = skeleton ? skeleton.depth + 1 : 0;\n        return {\n          ...skeleton,\n          depth,\n          ...(typeof skeletonProp === 'object' ? skeletonProp : {}),\n        };\n      }\n      return undefined;\n    }, [background, border, skeleton, skeletonProp]);\n\n    let skeletonProps = {};\n    if (nextSkeleton) {\n      const {\n        colors: skeletonThemeColors,\n        size: skeletonThemeSize,\n        ...skeletonThemeProps\n      } = theme.skeleton;\n      const skeletonColors = nextSkeleton.colors\n        ? nextSkeleton.colors[theme.dark ? 'dark' : 'light']\n        : skeletonThemeColors?.[theme.dark ? 'dark' : 'light'];\n      skeletonProps = { ...skeletonThemeProps };\n      background = skeletonColors[nextSkeleton.depth % skeletonColors.length];\n      if (skeletonProp?.animation) {\n        skeletonProps.animation = skeletonProp.animation;\n      }\n      contents = (\n        <SkeletonContext.Provider value={nextSkeleton}>\n          {contents}\n        </SkeletonContext.Provider>\n      );\n    }\n\n    // construct a new theme object in case we have a background that wants\n    // to change the background color context\n    const nextTheme = useMemo(() => {\n      let result;\n      if (background || theme.darkChanged) {\n        const dark = backgroundIsDark(background, theme);\n        const darkChanged = dark !== undefined && dark !== theme.dark;\n        if (darkChanged || theme.darkChanged) {\n          result = { ...theme };\n          result.dark = dark === undefined ? theme.dark : dark;\n          result.background = background;\n        } else if (background) {\n          // This allows DataTable to intelligently set the background\n          // of a pinned header or footer.\n          result = { ...theme };\n          result.background = background;\n        }\n      }\n      return result || theme;\n    }, [background, theme]);\n\n    let content = (\n      <StyledBox\n        as={!as && tag ? tag : as}\n        aria-label={a11yTitle}\n        background={background}\n        border={border}\n        ref={ref}\n        directionProp={direction}\n        elevationProp={elevation}\n        fillProp={fill}\n        focus={focus}\n        kindProp={kind}\n        overflowProp={overflow}\n        wrapProp={wrap}\n        widthProp={width}\n        heightProp={height}\n        responsive={responsive}\n        tabIndex={adjustedTabIndex}\n        {...clickProps}\n        {...rest}\n        {...skeletonProps}\n      >\n        <ThemeContext.Provider value={nextTheme}>\n          {contents}\n        </ThemeContext.Provider>\n      </StyledBox>\n    );\n\n    if (onClick) {\n      content = <Keyboard onEnter={onClick}>{content}</Keyboard>;\n    }\n\n    return content;\n  },\n);\n\nBox.displayName = 'Box';\nBox.propTypes = BoxPropTypes;\nexport { Box };"
    },
    "2": {
        "bug_file": "src/js/components/Box/StyledBox.js",
        "compressed": "NO",
        "line_numbers": 396,
        "compressed_line_numbers": 396,
        "compressed_bug_file_content": "import styled, { css } from 'styled-components';\n\nimport { defaultProps } from '../../default-props';\nimport {\n  alignContentStyle,\n  alignStyle,\n  backgroundStyle,\n  borderStyle,\n  breakpointStyle,\n  edgeStyle,\n  fillStyle,\n  focusStyle,\n  genericStyles,\n  getBreakpointStyle,\n  getHoverIndicatorStyle,\n  heightStyle,\n  overflowStyle,\n  parseMetricToNum,\n  responsiveBorderStyle,\n  widthStyle,\n} from '../../utils';\n\nimport { roundStyle } from '../../utils/styles';\n\nimport { animationBounds, animationObjectStyle } from '../../utils/animation';\n\nconst BASIS_MAP = {\n  auto: 'auto',\n  full: '100%',\n  '1/2': '50%',\n  '1/4': '25%',\n  '2/4': '50%',\n  '3/4': '75%',\n  '1/3': '33.33%',\n  '2/3': '66.66%',\n};\n\nconst basisStyle = css`\n  flex-basis: ${(props) =>\n    BASIS_MAP[props.basis] ||\n    props.theme.global.size[props.basis] ||\n    props.basis};\n`;\n\n// min-width and min-height needed because of this\n// https://stackoverflow.com/questions/36247140/why-doesnt-flex-item-shrink-past-content-size\n// we assume we are in the context of a Box going the other direction\n// TODO: revisit this\nconst directionStyle = (direction, theme) => {\n  const styles = [\n    css`\n      min-width: 0;\n      min-height: 0;\n      flex-direction: ${direction === 'row-responsive' ? 'row' : direction};\n    `,\n  ];\n  if (direction === 'row-responsive' && theme.box.responsiveBreakpoint) {\n    const breakpoint = getBreakpointStyle(\n      theme,\n      theme.box.responsiveBreakpoint,\n    );\n    if (breakpoint) {\n      styles.push(\n        breakpointStyle(\n          breakpoint,\n          `\n        flex-direction: column;\n        flex-basis: auto;\n        justify-content: flex-start;\n        align-items: stretch;\n      `,\n        ),\n      );\n    }\n  }\n  return styles;\n};\n\nconst elevationStyle = (elevation) => css`\n  box-shadow: ${(props) =>\n    props.theme.global.elevation[props.theme.dark ? 'dark' : 'light'][\n      elevation\n    ]};\n`;\n\nconst FLEX_MAP = {\n  [true]: '1 1',\n  [false]: '0 0',\n  grow: '1 0',\n  shrink: '0 1',\n};\n\nconst flexGrowShrinkProp = (flex) => {\n  if (typeof flex === 'boolean' || typeof flex === 'string') {\n    return FLEX_MAP[flex];\n  }\n\n  return `${flex.grow ? flex.grow : 0} ${flex.shrink ? flex.shrink : 0}`;\n};\n\nconst flexStyle = css`\n  flex: ${(props) =>\n    `${flexGrowShrinkProp(props.flex)}${\n      props.flex !== true && !props.basis ? ' auto' : ''\n    }`};\n`;\n\nconst JUSTIFY_MAP = {\n  around: 'space-around',\n  between: 'space-between',\n  center: 'center',\n  end: 'flex-end',\n  evenly: 'space-evenly',\n  start: 'flex-start',\n};\n\nconst justifyStyle = css`\n  justify-content: ${(props) => JUSTIFY_MAP[props.justify]};\n`;\n\nconst WRAP_MAP = {\n  true: 'wrap',\n  reverse: 'wrap-reverse',\n};\n\nconst wrapStyle = css`\n  flex-wrap: ${(props) => WRAP_MAP[props.wrapProp]};\n`;\n\nconst animationItemStyle = (item, theme) => {\n  if (typeof item === 'string') {\n    return animationObjectStyle({ type: item }, theme);\n  }\n  if (Array.isArray(item)) {\n    return item.reduce(\n      (style, a, index) =>\n        css`\n          ${style}${index > 0 ? ',' : ''} ${animationItemStyle(a, theme)}\n        `,\n      '',\n    );\n  }\n  if (typeof item === 'object') {\n    return animationObjectStyle(item, theme);\n  }\n  return '';\n};\n\nconst animationAncilaries = (animation) => {\n  if (animation.type === 'flipIn' || animation.type === 'flipOut') {\n    return 'perspective: 1000px; transform-style: preserve-3d;';\n  }\n  return '';\n};\n\nconst animationObjectInitialStyle = (animation) => {\n  const bounds = animationBounds(animation.type, animation.size);\n  if (bounds) {\n    return `${bounds[0]} ${animationAncilaries(animation)}`;\n  }\n  return '';\n};\n\nconst animationInitialStyle = (item) => {\n  if (typeof item === 'string') {\n    return animationObjectInitialStyle({ type: item });\n  }\n  if (Array.isArray(item)) {\n    return item\n      .map((a) =>\n        typeof a === 'string'\n          ? animationObjectInitialStyle({ type: a })\n          : animationObjectInitialStyle(a),\n      )\n      .join('');\n  }\n  if (typeof item === 'object') {\n    return animationObjectInitialStyle(item);\n  }\n  return '';\n};\n\nconst animationStyle = css`\n  ${(props) => css`\n    ${animationInitialStyle(props.animation)}\n    animation: ${animationItemStyle(props.animation, props.theme)};\n  `};\n`;\n\nconst interactiveStyle = css`\n  cursor: pointer;\n\n  &:hover {\n    ${(props) =>\n      props.kindProp?.hover &&\n      getHoverIndicatorStyle(props.kindProp.hover, props.theme)}\n    ${(props) =>\n      props.hoverIndicator &&\n      getHoverIndicatorStyle(props.hoverIndicator, props.theme)}\n  }\n`;\n\n// NOTE: basis must be after flex! Otherwise, flex overrides basis\nconst StyledBox = styled.div`\n  display: flex;\n  box-sizing: border-box;\n  ${(props) => !props.basis && 'max-width: 100%;'};\n\n  ${genericStyles}\n  ${(props) => props.align && alignStyle}\n  ${(props) => props.alignContent && alignContentStyle}\n  ${(props) =>\n    props.background && backgroundStyle(props.background, props.theme)}\n  ${(props) =>\n    props.border && borderStyle(props.border, props.responsive, props.theme)}\n  ${(props) =>\n    props.directionProp && directionStyle(props.directionProp, props.theme)}\n  ${(props) => props.heightProp && heightStyle(props.heightProp, props.theme)}\n  ${(props) => props.widthProp && widthStyle(props.widthProp, props.theme)}\n  ${(props) => props.flex !== undefined && flexStyle}\n  ${(props) => props.basis && basisStyle}\n  ${(props) => props.fillProp && fillStyle(props.fillProp)}\n  ${(props) => props.justify && justifyStyle}\n  ${(props) =>\n    props.pad &&\n    edgeStyle(\n      'padding',\n      props.pad,\n      props.responsive,\n      props.theme.box.responsiveBreakpoint,\n      props.theme,\n    )}\n  ${(props) =>\n    props.round && roundStyle(props.round, props.responsive, props.theme)}\n  ${(props) => props.wrapProp && wrapStyle}\n  ${(props) => props.overflowProp && overflowStyle(props.overflowProp)}\n  ${(props) => props.elevationProp && elevationStyle(props.elevationProp)}\n  ${(props) => props.animation && animationStyle}\n  ${(props) => props.onClick && interactiveStyle}\n  ${(props) =>\n    props.onClick &&\n    props.focus &&\n    props.focusIndicator !== false &&\n    focusStyle()}\n  ${(props) => props.theme.box && props.theme.box.extend}\n  ${(props) => props.kindProp && props.kindProp.extend}\n`;\n\nconst gapStyle = (directionProp, gap, responsive, border, theme) => {\n  const metric = theme.global.edgeSize[gap] || gap;\n  const breakpoint = getBreakpointStyle(theme, theme.box.responsiveBreakpoint);\n  const responsiveMetric = responsive && breakpoint && breakpoint.edgeSize[gap];\n\n  const styles = [];\n  if (directionProp === 'column' || directionProp === 'column-reverse') {\n    styles.push(`height: ${metric};`);\n    if (responsiveMetric) {\n      styles.push(breakpointStyle(breakpoint, `height: ${responsiveMetric};`));\n    }\n  } else {\n    styles.push(`width: ${metric};`);\n    if (responsiveMetric) {\n      if (directionProp === 'row' || directionProp === 'row-reverse') {\n        styles.push(breakpointStyle(breakpoint, `width: ${responsiveMetric};`));\n      } else if (directionProp === 'row-responsive') {\n        styles.push(\n          breakpointStyle(\n            breakpoint,\n            `\n          width: auto;\n          height: ${responsiveMetric};\n        `,\n          ),\n        );\n      }\n    }\n  }\n\n  if (border === 'between' || (border && border.side === 'between')) {\n    const borderSize = border.size || 'xsmall';\n    const borderMetric = theme.global.borderSize[borderSize] || borderSize;\n    const borderOffset = `${\n      parseMetricToNum(metric) / 2 - parseMetricToNum(borderMetric) / 2\n    }px`;\n    const responsiveBorderMetric =\n      responsive &&\n      breakpoint &&\n      (breakpoint.borderSize[borderSize] || borderSize);\n    const responsiveBorderOffset =\n      responsiveBorderMetric &&\n      `${\n        parseMetricToNum(responsiveMetric) / 2 -\n        parseMetricToNum(responsiveBorderMetric) / 2\n      }px`;\n\n    if (directionProp === 'column' || directionProp === 'column-reverse') {\n      const adjustedBorder =\n        typeof border === 'string' ? 'top' : { ...border, side: 'top' };\n      styles.push(css`\n        position: relative;\n        &:after {\n          content: '';\n          position: absolute;\n          width: 100%;\n          top: ${borderOffset};\n          ${borderStyle(adjustedBorder, responsive, theme)}\n        }\n      `);\n      if (responsiveBorderOffset) {\n        styles.push(\n          breakpointStyle(\n            breakpoint,\n            `\n            &:after {\n              content: '';\n              top: ${responsiveBorderOffset};\n            }`,\n          ),\n        );\n      }\n    } else {\n      const adjustedBorder =\n        typeof border === 'string' ? 'left' : { ...border, side: 'left' };\n      styles.push(css`\n        position: relative;\n        &:after {\n          content: '';\n          position: absolute;\n          height: 100%;\n          left: ${borderOffset};\n          ${borderStyle(\n            adjustedBorder,\n            directionProp !== 'row-responsive' && responsive,\n            theme,\n          )}\n        }\n      `);\n      if (responsiveBorderOffset) {\n        if (directionProp === 'row' || directionProp === 'row-reverse') {\n          styles.push(\n            breakpointStyle(\n              breakpoint,\n              `\n              &:after {\n                content: '';\n                left: ${responsiveBorderOffset};\n              }`,\n            ),\n          );\n        } else if (directionProp === 'row-responsive') {\n          const adjustedBorder2 =\n            typeof border === 'string' ? 'top' : { ...border, side: 'top' };\n          styles.push(\n            breakpointStyle(\n              breakpoint,\n              `\n              &:after {\n                content: '';\n                height: auto;\n                left: unset;\n                width: 100%;\n                top: ${responsiveBorderOffset};\n                border-left: none;\n                ${responsiveBorderStyle(adjustedBorder2, theme)}\n              }`,\n            ),\n          );\n        }\n      }\n    }\n  }\n\n  return styles;\n};\n\nStyledBox.defaultProps = {};\nObject.setPrototypeOf(StyledBox.defaultProps, defaultProps);\n\nconst StyledBoxGap = styled.div`\n  flex: 0 0 auto;\n  align-self: stretch;\n  ${(props) =>\n    props.gap &&\n    gapStyle(\n      props.directionProp,\n      props.gap,\n      props.responsive,\n      props.border,\n      props.theme,\n    )};\n`;\n\nStyledBoxGap.defaultProps = {};\nObject.setPrototypeOf(StyledBoxGap.defaultProps, defaultProps);\n\nexport { StyledBox, StyledBoxGap };"
    },
    "3": {
        "bug_file": "src/js/components/Box/propTypes.js",
        "compressed": "NO",
        "line_numbers": 184,
        "compressed_line_numbers": 184,
        "compressed_bug_file_content": "import PropTypes from 'prop-types';\nimport {\n  animationPropType,\n  backgroundDoc,\n  elevationPropType,\n  genericProps,\n  heightPropType,\n  hoverIndicatorPropType,\n  padPropType,\n  roundPropType,\n  skeletonPropType,\n  widthPropType,\n} from '../../utils/general-prop-types';\n\nconst OVERFLOW_VALUES = ['auto', 'hidden', 'scroll', 'visible'];\n\nconst BORDER_SHAPE = PropTypes.shape({\n  color: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.shape({\n      dark: PropTypes.string,\n      light: PropTypes.string,\n    }),\n  ]),\n  side: PropTypes.oneOf([\n    'top',\n    'left',\n    'bottom',\n    'right',\n    'start',\n    'end',\n    'horizontal',\n    'vertical',\n    'all',\n    'between',\n  ]),\n  size: PropTypes.oneOfType([\n    PropTypes.oneOf(['xsmall', 'small', 'medium', 'large', 'xlarge']),\n    PropTypes.string,\n  ]),\n  style: PropTypes.oneOf([\n    'solid',\n    'dashed',\n    'dotted',\n    'double',\n    'groove',\n    'ridge',\n    'inset',\n    'outset',\n    'hidden',\n  ]),\n});\n\n// if you update values here, make sure to update in Drop/doc too.\nconst overflowPropType = PropTypes.oneOfType([\n  PropTypes.oneOf(OVERFLOW_VALUES),\n  PropTypes.shape({\n    horizontal: PropTypes.oneOf(OVERFLOW_VALUES),\n    vertical: PropTypes.oneOf(OVERFLOW_VALUES),\n  }),\n  PropTypes.string,\n]);\n\nlet PropType = {};\nif (process.env.NODE_ENV !== 'production') {\n  PropType = {\n    ...genericProps,\n    align: PropTypes.oneOfType([\n      PropTypes.oneOf(['baseline', 'center', 'end', 'start', 'stretch']),\n      PropTypes.string,\n    ]),\n    alignContent: PropTypes.oneOfType([\n      PropTypes.oneOf([\n        'around',\n        'baseline',\n        'between',\n        'center',\n        'evenly',\n        'end',\n        'start',\n        'stretch',\n      ]),\n      PropTypes.string,\n    ]),\n    animation: animationPropType,\n    background: backgroundDoc,\n    basis: PropTypes.oneOfType([\n      PropTypes.oneOf([\n        'xxsmall',\n        'xsmall',\n        'small',\n        'medium',\n        'large',\n        'xlarge',\n        'xxlarge',\n        'full',\n        '1/2',\n        '1/3',\n        '2/3',\n        '1/4',\n        '2/4',\n        '3/4',\n        'auto',\n      ]),\n      PropTypes.string,\n    ]),\n    border: PropTypes.oneOfType([\n      PropTypes.bool,\n      PropTypes.oneOf([\n        'top',\n        'left',\n        'bottom',\n        'right',\n        'start',\n        'end',\n        'horizontal',\n        'vertical',\n        'all',\n        'between',\n      ]),\n      BORDER_SHAPE,\n      PropTypes.arrayOf(BORDER_SHAPE),\n    ]),\n    direction: PropTypes.oneOf([\n      'row',\n      'column',\n      'row-responsive',\n      'row-reverse',\n      'column-reverse',\n    ]),\n    elevation: elevationPropType,\n    flex: PropTypes.oneOfType([\n      PropTypes.oneOf(['grow', 'shrink']),\n      PropTypes.bool,\n      PropTypes.shape({\n        grow: PropTypes.number,\n        shrink: PropTypes.number,\n      }),\n    ]),\n    fill: PropTypes.oneOfType([\n      PropTypes.oneOf(['horizontal', 'vertical']),\n      PropTypes.bool,\n    ]),\n    focusIndicator: PropTypes.bool,\n    gap: PropTypes.oneOfType([\n      PropTypes.oneOf([\n        'none',\n        'xxsmall',\n        'xsmall',\n        'small',\n        'medium',\n        'large',\n        'xlarge',\n      ]),\n      PropTypes.string,\n    ]),\n    height: heightPropType,\n    hoverIndicator: hoverIndicatorPropType,\n    justify: PropTypes.oneOf([\n      'around',\n      'between',\n      'center',\n      'end',\n      'evenly',\n      'start',\n      'stretch',\n    ]),\n    onClick: PropTypes.func,\n    overflow: overflowPropType,\n    pad: padPropType,\n    responsive: PropTypes.bool,\n    round: roundPropType,\n    skeleton: skeletonPropType,\n    tag: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    as: PropTypes.oneOfType([\n      PropTypes.string,\n      PropTypes.func,\n      PropTypes.elementType,\n    ]),\n    width: widthPropType,\n    wrap: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['reverse'])]),\n  };\n}\nexport const BoxPropTypes = PropType;"
    }
}