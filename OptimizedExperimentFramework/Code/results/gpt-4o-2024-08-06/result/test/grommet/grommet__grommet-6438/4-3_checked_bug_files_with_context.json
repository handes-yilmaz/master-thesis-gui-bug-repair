{
    "src/js/components/DateInput/DateInput.js": [
        "import React, {",
        "  useRef,",
        "  forwardRef,",
        "  useContext,",
        "  useEffect,",
        "  useMemo,",
        "  useState,",
        "  useCallback,",
        "} from 'react';",
        "import { ThemeContext } from 'styled-components';",
        "import { Calendar as CalendarIcon } from 'grommet-icons/icons/Calendar';",
        "import { defaultProps } from '../../default-props';",
        "import { AnnounceContext } from '../../contexts/AnnounceContext';",
        "import { MessageContext } from '../../contexts/MessageContext';",
        "import { Box } from '../Box';",
        "import { Button } from '../Button';",
        "import { Calendar } from '../Calendar';",
        "import { Drop } from '../Drop';",
        "import { DropButton } from '../DropButton';",
        "import { FormContext } from '../Form';",
        "import { Keyboard } from '../Keyboard';",
        "import { MaskedInput } from '../MaskedInput';",
        "import { useForwardedRef, setHoursWithOffset } from '../../utils';",
        "import {",
        "  formatToSchema,",
        "  schemaToMask,",
        "  valuesAreEqual,",
        "  valueToText,",
        "  textToValue,",
        "} from './utils';",
        "import { DateInputPropTypes } from './propTypes';",
        "import { getOutputFormat } from '../Calendar/Calendar';",
        "",
        "const getReference = (value) => {",
        "  let adjustedDate;",
        "  let res;",
        "  if (typeof value === 'string') res = value;",
        "  else if (Array.isArray(value) && Array.isArray(value[0]))",
        "    res = value[0].find((date) => date);",
        "  else if (Array.isArray(value) && value.length) [res] = value;",
        "",
        "  if (res) {",
        "    adjustedDate = setHoursWithOffset(res);",
        "  }",
        "  return adjustedDate;",
        "};",
        "",
        "const DateInput = forwardRef(",
        "  (",
        "    {",
        "      buttonProps, // when no format and not inline",
        "      calendarProps,",
        "      defaultValue,",
        "      disabled,",
        "      dropProps, // when inline isn't true",
        "      format,",
        "      id,",
        "      icon,",
        "      inline = false,",
        "      inputProps, // for MaskedInput, when format is specified",
        "      name,",
        "      onChange,",
        "      onFocus,",
        "      plain,",
        "      reverse: reverseProp = false,",
        "      value: valueArg,",
        "      messages,",
        "      ...rest",
        "    },",
        "    refArg,",
        "  ) => {",
        "    const theme = useContext(ThemeContext) || defaultProps.theme;",
        "    const announce = useContext(AnnounceContext);",
        "    const { format: formatMessage } = useContext(MessageContext);",
        "    const iconSize =",
        "      (theme.dateInput.icon && theme.dateInput.icon.size) || 'medium';",
        "    const { useFormInput } = useContext(FormContext);",
        "    const ref = useForwardedRef(refArg);",
        "    const containerRef = useRef();",
        "    const [value, setValue] = useFormInput({",
        "      name,",
        "      value: valueArg,",
        "      initialValue: defaultValue,",
        "    });",
        "",
        "    const [outputFormat, setOutputFormat] = useState(getOutputFormat(value));",
        "    useEffect(() => {",
        "      setOutputFormat((previousFormat) => {",
        "        const nextFormat = getOutputFormat(value);",
        "        // when user types, date could become something like 07//2020",
        "        // and value becomes undefined. don't lose the format from the",
        "        // previous valid date",
        "        return previousFormat !== nextFormat ? previousFormat : nextFormat;",
        "      });",
        "    }, [value]);",
        "",
        "    // keep track of timestamp from original date(s)",
        "    const [reference, setReference] = useState(getReference(value));",
        "",
        "    // do we expect multiple dates?",
        "    const range = Array.isArray(value) || (format && format.includes('-'));",
        "",
        "    // parse format and build a formal schema we can use elsewhere",
        "    const schema = useMemo(() => formatToSchema(format), [format]);",
        "",
        "    // mask is only used when a format is provided",
        "    const mask = useMemo(() => schemaToMask(schema), [schema]);",
        "",
        "    // textValue is only used when a format is provided",
        "    const [textValue, setTextValue] = useState(",
        "      schema ? valueToText(value, schema) : undefined,",
        "    );",
        "",
        "    // Setting the icon through `inputProps` is deprecated.",
        "    // The `icon` prop should be used instead.",
        "    const { icon: MaskedInputIcon, ...restOfInputProps } = inputProps || {};",
        "    if (MaskedInputIcon) {",
        "      console.warn(",
        "        `Customizing the DateInput icon through inputProps is deprecated.",
        "Use the icon prop instead.`,",
        "      );",
        "    }",
        "",
        "    const reverse = reverseProp || restOfInputProps.reverse;",
        "",
        "    const calendarDropdownAlign = { top: 'bottom', left: 'left' };",
        "",
        "    // We need to distinguish between the caller changing a Form value",
        "    // and the user typing a date that he isn't finished with yet.",
        "    // To handle this, we see if we have a value and the text value",
        "    // associated with it doesn't align to it, then we update the text value.",
        "    // We compare using textToValue to avoid \"06/01/2021\" not",
        "    // matching \"06/1/2021\".",
        "    useEffect(() => {",
        "      if (schema && value !== undefined) {",
        "        const nextTextValue = valueToText(value, schema);",
        "        if (",
        "          !valuesAreEqual(",
        "            textToValue(textValue, schema, range, reference),",
        "            textToValue(nextTextValue, schema, range, reference),",
        "          ) ||",
        "          (textValue === '' && nextTextValue !== '')",
        "        ) {",
        "          setTextValue(nextTextValue);",
        "        }",
        "      }",
        "    }, [range, schema, textValue, reference, value]);",
        "",
        "    // when format and not inline, whether to show the Calendar in a Drop",
        "    const [open, setOpen] = useState();",
        "",
        "    const openCalendar = useCallback(() => {",
        "      setOpen(true);",
        "      announce(formatMessage({ id: 'dateInput.enterCalendar', messages }));",
        "    }, [announce, formatMessage, messages]);",
        "",
        "    const closeCalendar = useCallback(() => {",
        "      setOpen(false);",
        "      announce(formatMessage({ id: 'dateInput.exitCalendar', messages }));",
        "    }, [announce, formatMessage, messages]);",
        "",
        "    const dates = useMemo(",
        "      () => (range && value?.length ? [value] : undefined),",
        "      [range, value],",
        "    );",
        "",
        "    const calendar = (",
        "      <Calendar",
        "        ref={inline ? ref : undefined}",
        "        id={inline && !format ? id : undefined}",
        "        range={range}",
        "        date={range ? undefined : value}",
        "        // when caller initializes with empty array, dates should be undefined",
        "        // allowing the user to select both begin and end of the range",
        "        dates={dates}",
        "        // places focus on days grid when Calendar opens",
        "        initialFocus={open ? 'days' : undefined}",
        "        onSelect={",
        "          disabled",
        "            ? undefined",
        "            : (nextValue) => {",
        "                let normalizedValue;",
        "                if (range && Array.isArray(nextValue))",
        "                  [normalizedValue] = nextValue;",
        "                // clicking an edge date removes it",
        "                else if (range) normalizedValue = [nextValue, nextValue];",
        "                else normalizedValue = nextValue;",
        "",
        "                if (schema) setTextValue(valueToText(normalizedValue, schema));",
        "                setValue(normalizedValue);",
        "                setReference(getReference(nextValue));",
        "                if (onChange) onChange({ value: normalizedValue });",
        "                if (open && !range) {",
        "                  closeCalendar();",
        "                  setTimeout(() => ref.current.focus(), 1);",
        "                }",
        "              }",
        "        }",
        "        {...calendarProps}",
        "      />",
        "    );",
        "",
        "    const formContextValue = useMemo(",
        "      () => ({",
        "        useFormInput: ({ value: valueProp }) => [valueProp, () => {}],",
        "      }),",
        "      [],",
        "    );",
        "",
        "    if (!format) {",
        "      // When no format is specified, we don't give the user a way to type",
        "      if (inline) return calendar;",
        "",
        "      return (",
        "        <DropButton",
        "          ref={ref}",
        "          id={id}",
        "          dropProps={{ align: calendarDropdownAlign, ...dropProps }}",
        "          dropContent={calendar}",
        "          icon={icon || MaskedInputIcon || <CalendarIcon size={iconSize} />}",
        "          {...buttonProps}",
        "        />",
        "      );",
        "    }",
        "",
        "    const calendarButton = (",
        "      <Button",
        "        onClick={open ? closeCalendar : openCalendar}",
        "        plain",
        "        icon={icon || MaskedInputIcon || <CalendarIcon size={iconSize} />}",
        "        margin={reverse ? { left: 'small' } : { right: 'small' }}",
        "      />",
        "    );",
        "",
        "    const input = (",
        "      <FormContext.Provider",
        "        key=\"input\"",
        "        // don't let MaskedInput drive the Form",
        "        value={formContextValue}",
        "      >",
        "        <Keyboard",
        "          onEsc={open ? () => closeCalendar() : undefined}",
        "          onSpace={(event) => {",
        "            event.preventDefault();",
        "            openCalendar();",
        "          }}",
        "        >",
        "          <Box",
        "            ref={containerRef}",
        "            border={!plain}",
        "            round={theme.dateInput.container.round}",
        "            direction=\"row\"",
        "            fill",
        "          >",
        "            {reverse && calendarButton}",
        "            <MaskedInput",
        "              ref={ref}",
        "              id={id}",
        "              name={name}",
        "              reverse",
        "              disabled={disabled}",
        "              mask={mask}",
        "              plain",
        "              {...restOfInputProps}",
        "              {...rest}",
        "              value={textValue}",
        "              onChange={(event) => {",
        "                const nextTextValue = event.target.value;",
        "                setTextValue(nextTextValue);",
        "                const nextValue = textToValue(",
        "                  nextTextValue,",
        "                  schema,",
        "                  range,",
        "                  reference,",
        "                  outputFormat,",
        "                );",
        "                if (nextValue !== undefined)",
        "                  setReference(getReference(nextValue));",
        "                // update value even when undefined",
        "                setValue(nextValue);",
        "                if (onChange) {",
        "                  event.persist(); // extract from React synthetic event pool",
        "                  const adjustedEvent = event;",
        "                  adjustedEvent.value = nextValue;",
        "                  onChange(adjustedEvent);",
        "                }",
        "              }}",
        "              onFocus={(event) => {",
        "                announce(",
        "                  formatMessage({ id: 'dateInput.openCalendar', messages }),",
        "                );",
        "                if (onFocus) onFocus(event);",
        "              }}",
        "            />",
        "            {!reverse && calendarButton}",
        "          </Box>",
        "        </Keyboard>",
        "      </FormContext.Provider>",
        "    );",
        "",
        "    if (inline) {",
        "      return (",
        "        <Box>",
        "          {input}",
        "          {calendar}",
        "        </Box>",
        "      );",
        "    }",
        "",
        "    if (open) {",
        "      return [",
        "        input,",
        "        <Keyboard key=\"drop\" onEsc={() => ref.current.focus()}>",
        "          <Drop",
        "            overflow=\"visible\"",
        "            id={id ? `${id}__drop` : undefined}",
        "            target={containerRef.current}",
        "            align={{ ...calendarDropdownAlign, ...dropProps }}",
        "            onEsc={closeCalendar}",
        "            onClickOutside={({ target }) => {",
        "              if (",
        "                target !== containerRef.current &&",
        "                !containerRef.current.contains(target)",
        "              ) {",
        "                closeCalendar();",
        "              }",
        "            }}",
        "            {...dropProps}",
        "          >",
        "            {calendar}",
        "          </Drop>",
        "        </Keyboard>,",
        "      ];",
        "    }",
        "",
        "    return input;",
        "  },",
        ");",
        "",
        "DateInput.displayName = 'DateInput';",
        "DateInput.propTypes = DateInputPropTypes;",
        "",
        "export { DateInput };"
    ],
    "src/js/components/DateInput/utils.js": [
        "import { setHoursWithOffset } from '../../utils';",
        "import { handleOffset } from '../Calendar/utils';",
        "",
        "// Converting between Date and String types is handled via a \"schema\".",
        "// The schema is an array of strings, split into strings with identical",
        "// characters. So, 'mm/dd/yyyy' will be ['mm', '/', 'dd', '/', 'yyyyy'].",
        "export const formatToSchema = (format) => {",
        "  if (!format) return undefined;",
        "  const result = [];",
        "",
        "  let i = 0;",
        "  let part;",
        "  while (i < format.length) {",
        "    if (!part || part[0] !== format[i]) {",
        "      if (part) result.push(part);",
        "      part = format[i];",
        "    } else {",
        "      part += format[i];",
        "    }",
        "    i += 1;",
        "  }",
        "  if (part) result.push(part);",
        "",
        "  return result;",
        "};",
        "",
        "const masks = {",
        "  m: { length: [1, 2], regexp: /^[1-9]$|^1[0-2]$/ },",
        "  mm: { length: [1, 2], regexp: /^[0-1]$|^0[1-9]$|^1[0-2]$/ },",
        "  d: { length: [1, 2], regexp: /^[1-9]$|^[1-2][0-9]$|^3[0-1]$/ },",
        "  dd: {",
        "    length: [1, 2],",
        "    regexp: /^[0-3]$|^0[1-9]$|^[1-2][0-9]$|^3[0-1]$/,",
        "  },",
        "  yy: { length: [1, 2], regexp: /^[0-9]{1,2}$/ },",
        "  yyyy: { length: [1, 4], regexp: /^[0-9]{1,4}$/ },",
        "};",
        "",
        "export const schemaToMask = (schema) => {",
        "  if (!schema) return undefined;",
        "  return schema.map((part) => {",
        "    const lower = part.toLowerCase();",
        "    const char = lower[0];",
        "    if (char === 'm' || char === 'd' || char === 'y')",
        "      return { placeholder: part, ...masks[lower] };",
        "    return { fixed: part };",
        "  });",
        "};",
        "",
        "// convert value into text representation using the schema",
        "export const valueToText = (value, schema) => {",
        "  let text = '';",
        "  // when user initializes dates as empty array, we want to still",
        "  // show the placeholder text",
        "  if (!value || (Array.isArray(value) && !value.length)) return text;",
        "",
        "  const dates = (Array.isArray(value) ? value : [value]).map((v) =>",
        "    setHoursWithOffset(v),",
        "  );",
        "",
        "  let dateIndex = 0;",
        "  let parts = {};",
        "  schema.every((part) => {",
        "    const char = part[0].toLowerCase();",
        "    // advance dateIndex if we already have this part",
        "    while (",
        "      dateIndex < dates.length &&",
        "      (Number.isNaN(dates[dateIndex].date) ||",
        "        ((char === 'm' || char === 'd' || char === 'y') && parts[part]))",
        "    ) {",
        "      dateIndex += 1;",
        "      parts = {};",
        "    }",
        "    const date = dates[dateIndex];",
        "",
        "    if (date && part === 'm') {",
        "      text += date.getMonth() + 1;",
        "      parts[part] = true;",
        "    } else if (date && part === 'mm') {",
        "      text += `0${date.getMonth() + 1}`.slice(-2);",
        "      parts[part] = true;",
        "    } else if (date && part === 'd') {",
        "      text += date.getDate();",
        "      parts[part] = true;",
        "    } else if (date && part === 'dd') {",
        "      text += `0${date.getDate()}`.slice(-2);",
        "      parts[part] = true;",
        "    } else if (date && part === 'yy') {",
        "      text += date.getFullYear().toString().slice(-2);",
        "      parts[part] = true;",
        "    } else if (date && part === 'yyyy') {",
        "      text += date.getFullYear();",
        "      parts[part] = true;",
        "    } else if (",
        "      !date &&",
        "      (part[0] === 'm' || part[0] === 'd' || part[0] === 'y')",
        "    ) {",
        "      return false;",
        "    } else {",
        "      text += part;",
        "    }",
        "    return true;",
        "  });",
        "",
        "  return text;",
        "};",
        "",
        "const charCodeZero = '0'.charCodeAt(0);",
        "const charCodeNine = '9'.charCodeAt(0);",
        "",
        "const pullDigits = (text, index) => {",
        "  let end = index;",
        "  while (",
        "    text.charCodeAt(end) >= charCodeZero &&",
        "    text.charCodeAt(end) <= charCodeNine",
        "  )",
        "    end += 1;",
        "  return text.slice(index, end);",
        "};",
        "",
        "export const textToValue = (text, schema, range, reference, outputFormat) => {",
        "  if (!text) return range ? [] : undefined;",
        "",
        "  let result;",
        "",
        "  const addDate = (parts) => {",
        "    const leapYear =",
        "      (parts.y % 4 === 0 && parts.y % 100 !== 0) || parts.y % 400 === 0;",
        "",
        "    // Do a little sanity checking on the parts first.",
        "    // If not valid, leave as is.",
        "    if (",
        "      !parts.m ||",
        "      !parts.d ||",
        "      !parts.y ||",
        "      parts.y.length < 4 ||",
        "      parts.m.length > 2 ||",
        "      parts.d.length > 2 ||",
        "      parts.m > 12 ||",
        "      parts.d > 31 ||",
        "      ((parts.m === `02` || parts.m === `2`) && parts.d > (leapYear ? 29 : 28))",
        "    )",
        "      return parts;",
        "",
        "    // use time info from reference date",
        "    const time = reference",
        "      ? [",
        "          reference.getHours(),",
        "          reference.getMinutes(),",
        "          reference.getSeconds(),",
        "          reference.getMilliseconds(),",
        "        ]",
        "      : null;",
        "",
        "    let date = new Date(parts.y, parts.m - 1, parts.d, ...time).toISOString();",
        "",
        "    if (date && outputFormat === 'no timezone') {",
        "      [date] = handleOffset(date).toISOString().split('T');",
        "    }",
        "",
        "    if (!range) {",
        "      if (!result) result = date;",
        "    } else {",
        "      if (!result) result = [];",
        "      result.push(date);",
        "    }",
        "    // we've consumed these parts, return an empty object in case we need",
        "    // to start building up another one for a range",
        "    return {};",
        "  };",
        "",
        "  let parts = {};",
        "  let index = 0;",
        "  schema.forEach((part) => {",
        "    if (index < text.length) {",
        "      const lower = part.toLowerCase();",
        "      const char = lower[0];",
        "      if (parts[char] !== undefined) parts = addDate(parts);",
        "",
        "      if (char === 'm') {",
        "        parts.m = pullDigits(text, index);",
        "        index += parts.m.length;",
        "      } else if (char === 'd') {",
        "        parts.d = pullDigits(text, index);",
        "        // when format is something like yyyy/mm/dd,",
        "        // '0' as incomplete day can cause date to be",
        "        // prematurely calculated.",
        "        // ex: 2022/01/0 would reutrn 2021/12/31 in addDate()",
        "        if (parts.d === '0') delete parts.d;",
        "        index += parts?.d?.length || 0;",
        "      } else if (char === 'y') {",
        "        parts.y = pullDigits(text, index);",
        "        index += parts.y.length;",
        "        if (lower === 'yy' && parts.y.length === 2) {",
        "          // convert to full year, pivot at 69 based on POSIX strptime()",
        "          parts.y = `${parts.y < 69 ? 20 : 19}${parts.y}`;",
        "        }",
        "      } else if (text.slice(index, index + part.length) === part) {",
        "        index += part.length;",
        "      } else {",
        "        // syntax error",
        "        index = text.length;",
        "        result = undefined;",
        "      }",
        "    }",
        "  });",
        "  parts = addDate(parts);",
        "",
        "  if (!result) return range ? [] : undefined;",
        "  return result;",
        "};",
        "",
        "export const valuesAreEqual = (value1, value2) =>",
        "  (Array.isArray(value1) &&",
        "    Array.isArray(value2) &&",
        "    value1.every((d1, i) => d1 === value2[i])) ||",
        "  value1 === value2;"
    ]
}