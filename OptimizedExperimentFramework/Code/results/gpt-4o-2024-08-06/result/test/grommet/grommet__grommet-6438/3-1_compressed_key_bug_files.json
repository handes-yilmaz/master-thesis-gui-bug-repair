{
    "1": {
        "bug_file": "src/js/components/DateInput/DateInput.js",
        "compressed": "NO",
        "line_numbers": 343,
        "compressed_line_numbers": 343,
        "compressed_bug_file_content": "import React, {\n  useRef,\n  forwardRef,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n  useCallback,\n} from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { Calendar as CalendarIcon } from 'grommet-icons/icons/Calendar';\nimport { defaultProps } from '../../default-props';\nimport { AnnounceContext } from '../../contexts/AnnounceContext';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { Box } from '../Box';\nimport { Button } from '../Button';\nimport { Calendar } from '../Calendar';\nimport { Drop } from '../Drop';\nimport { DropButton } from '../DropButton';\nimport { FormContext } from '../Form';\nimport { Keyboard } from '../Keyboard';\nimport { MaskedInput } from '../MaskedInput';\nimport { useForwardedRef, setHoursWithOffset } from '../../utils';\nimport {\n  formatToSchema,\n  schemaToMask,\n  valuesAreEqual,\n  valueToText,\n  textToValue,\n} from './utils';\nimport { DateInputPropTypes } from './propTypes';\nimport { getOutputFormat } from '../Calendar/Calendar';\n\nconst getReference = (value) => {\n  let adjustedDate;\n  let res;\n  if (typeof value === 'string') res = value;\n  else if (Array.isArray(value) && Array.isArray(value[0]))\n    res = value[0].find((date) => date);\n  else if (Array.isArray(value) && value.length) [res] = value;\n\n  if (res) {\n    adjustedDate = setHoursWithOffset(res);\n  }\n  return adjustedDate;\n};\n\nconst DateInput = forwardRef(\n  (\n    {\n      buttonProps, // when no format and not inline\n      calendarProps,\n      defaultValue,\n      disabled,\n      dropProps, // when inline isn't true\n      format,\n      id,\n      icon,\n      inline = false,\n      inputProps, // for MaskedInput, when format is specified\n      name,\n      onChange,\n      onFocus,\n      plain,\n      reverse: reverseProp = false,\n      value: valueArg,\n      messages,\n      ...rest\n    },\n    refArg,\n  ) => {\n    const theme = useContext(ThemeContext) || defaultProps.theme;\n    const announce = useContext(AnnounceContext);\n    const { format: formatMessage } = useContext(MessageContext);\n    const iconSize =\n      (theme.dateInput.icon && theme.dateInput.icon.size) || 'medium';\n    const { useFormInput } = useContext(FormContext);\n    const ref = useForwardedRef(refArg);\n    const containerRef = useRef();\n    const [value, setValue] = useFormInput({\n      name,\n      value: valueArg,\n      initialValue: defaultValue,\n    });\n\n    const [outputFormat, setOutputFormat] = useState(getOutputFormat(value));\n    useEffect(() => {\n      setOutputFormat((previousFormat) => {\n        const nextFormat = getOutputFormat(value);\n        // when user types, date could become something like 07//2020\n        // and value becomes undefined. don't lose the format from the\n        // previous valid date\n        return previousFormat !== nextFormat ? previousFormat : nextFormat;\n      });\n    }, [value]);\n\n    // keep track of timestamp from original date(s)\n    const [reference, setReference] = useState(getReference(value));\n\n    // do we expect multiple dates?\n    const range = Array.isArray(value) || (format && format.includes('-'));\n\n    // parse format and build a formal schema we can use elsewhere\n    const schema = useMemo(() => formatToSchema(format), [format]);\n\n    // mask is only used when a format is provided\n    const mask = useMemo(() => schemaToMask(schema), [schema]);\n\n    // textValue is only used when a format is provided\n    const [textValue, setTextValue] = useState(\n      schema ? valueToText(value, schema) : undefined,\n    );\n\n    // Setting the icon through `inputProps` is deprecated.\n    // The `icon` prop should be used instead.\n    const { icon: MaskedInputIcon, ...restOfInputProps } = inputProps || {};\n    if (MaskedInputIcon) {\n      console.warn(\n        `Customizing the DateInput icon through inputProps is deprecated.\nUse the icon prop instead.`,\n      );\n    }\n\n    const reverse = reverseProp || restOfInputProps.reverse;\n\n    const calendarDropdownAlign = { top: 'bottom', left: 'left' };\n\n    // We need to distinguish between the caller changing a Form value\n    // and the user typing a date that he isn't finished with yet.\n    // To handle this, we see if we have a value and the text value\n    // associated with it doesn't align to it, then we update the text value.\n    // We compare using textToValue to avoid \"06/01/2021\" not\n    // matching \"06/1/2021\".\n    useEffect(() => {\n      if (schema && value !== undefined) {\n        const nextTextValue = valueToText(value, schema);\n        if (\n          !valuesAreEqual(\n            textToValue(textValue, schema, range, reference),\n            textToValue(nextTextValue, schema, range, reference),\n          ) ||\n          (textValue === '' && nextTextValue !== '')\n        ) {\n          setTextValue(nextTextValue);\n        }\n      }\n    }, [range, schema, textValue, reference, value]);\n\n    // when format and not inline, whether to show the Calendar in a Drop\n    const [open, setOpen] = useState();\n\n    const openCalendar = useCallback(() => {\n      setOpen(true);\n      announce(formatMessage({ id: 'dateInput.enterCalendar', messages }));\n    }, [announce, formatMessage, messages]);\n\n    const closeCalendar = useCallback(() => {\n      setOpen(false);\n      announce(formatMessage({ id: 'dateInput.exitCalendar', messages }));\n    }, [announce, formatMessage, messages]);\n\n    const dates = useMemo(\n      () => (range && value?.length ? [value] : undefined),\n      [range, value],\n    );\n\n    const calendar = (\n      <Calendar\n        ref={inline ? ref : undefined}\n        id={inline && !format ? id : undefined}\n        range={range}\n        date={range ? undefined : value}\n        // when caller initializes with empty array, dates should be undefined\n        // allowing the user to select both begin and end of the range\n        dates={dates}\n        // places focus on days grid when Calendar opens\n        initialFocus={open ? 'days' : undefined}\n        onSelect={\n          disabled\n            ? undefined\n            : (nextValue) => {\n                let normalizedValue;\n                if (range && Array.isArray(nextValue))\n                  [normalizedValue] = nextValue;\n                // clicking an edge date removes it\n                else if (range) normalizedValue = [nextValue, nextValue];\n                else normalizedValue = nextValue;\n\n                if (schema) setTextValue(valueToText(normalizedValue, schema));\n                setValue(normalizedValue);\n                setReference(getReference(nextValue));\n                if (onChange) onChange({ value: normalizedValue });\n                if (open && !range) {\n                  closeCalendar();\n                  setTimeout(() => ref.current.focus(), 1);\n                }\n              }\n        }\n        {...calendarProps}\n      />\n    );\n\n    const formContextValue = useMemo(\n      () => ({\n        useFormInput: ({ value: valueProp }) => [valueProp, () => {}],\n      }),\n      [],\n    );\n\n    if (!format) {\n      // When no format is specified, we don't give the user a way to type\n      if (inline) return calendar;\n\n      return (\n        <DropButton\n          ref={ref}\n          id={id}\n          dropProps={{ align: calendarDropdownAlign, ...dropProps }}\n          dropContent={calendar}\n          icon={icon || MaskedInputIcon || <CalendarIcon size={iconSize} />}\n          {...buttonProps}\n        />\n      );\n    }\n\n    const calendarButton = (\n      <Button\n        onClick={open ? closeCalendar : openCalendar}\n        plain\n        icon={icon || MaskedInputIcon || <CalendarIcon size={iconSize} />}\n        margin={reverse ? { left: 'small' } : { right: 'small' }}\n      />\n    );\n\n    const input = (\n      <FormContext.Provider\n        key=\"input\"\n        // don't let MaskedInput drive the Form\n        value={formContextValue}\n      >\n        <Keyboard\n          onEsc={open ? () => closeCalendar() : undefined}\n          onSpace={(event) => {\n            event.preventDefault();\n            openCalendar();\n          }}\n        >\n          <Box\n            ref={containerRef}\n            border={!plain}\n            round={theme.dateInput.container.round}\n            direction=\"row\"\n            fill\n          >\n            {reverse && calendarButton}\n            <MaskedInput\n              ref={ref}\n              id={id}\n              name={name}\n              reverse\n              disabled={disabled}\n              mask={mask}\n              plain\n              {...restOfInputProps}\n              {...rest}\n              value={textValue}\n              onChange={(event) => {\n                const nextTextValue = event.target.value;\n                setTextValue(nextTextValue);\n                const nextValue = textToValue(\n                  nextTextValue,\n                  schema,\n                  range,\n                  reference,\n                  outputFormat,\n                );\n                if (nextValue !== undefined)\n                  setReference(getReference(nextValue));\n                // update value even when undefined\n                setValue(nextValue);\n                if (onChange) {\n                  event.persist(); // extract from React synthetic event pool\n                  const adjustedEvent = event;\n                  adjustedEvent.value = nextValue;\n                  onChange(adjustedEvent);\n                }\n              }}\n              onFocus={(event) => {\n                announce(\n                  formatMessage({ id: 'dateInput.openCalendar', messages }),\n                );\n                if (onFocus) onFocus(event);\n              }}\n            />\n            {!reverse && calendarButton}\n          </Box>\n        </Keyboard>\n      </FormContext.Provider>\n    );\n\n    if (inline) {\n      return (\n        <Box>\n          {input}\n          {calendar}\n        </Box>\n      );\n    }\n\n    if (open) {\n      return [\n        input,\n        <Keyboard key=\"drop\" onEsc={() => ref.current.focus()}>\n          <Drop\n            overflow=\"visible\"\n            id={id ? `${id}__drop` : undefined}\n            target={containerRef.current}\n            align={{ ...calendarDropdownAlign, ...dropProps }}\n            onEsc={closeCalendar}\n            onClickOutside={({ target }) => {\n              if (\n                target !== containerRef.current &&\n                !containerRef.current.contains(target)\n              ) {\n                closeCalendar();\n              }\n            }}\n            {...dropProps}\n          >\n            {calendar}\n          </Drop>\n        </Keyboard>,\n      ];\n    }\n\n    return input;\n  },\n);\n\nDateInput.displayName = 'DateInput';\nDateInput.propTypes = DateInputPropTypes;\n\nexport { DateInput };"
    },
    "2": {
        "bug_file": "src/js/components/DateInput/utils.js",
        "compressed": "NO",
        "line_numbers": 217,
        "compressed_line_numbers": 217,
        "compressed_bug_file_content": "import { setHoursWithOffset } from '../../utils';\nimport { handleOffset } from '../Calendar/utils';\n\n// Converting between Date and String types is handled via a \"schema\".\n// The schema is an array of strings, split into strings with identical\n// characters. So, 'mm/dd/yyyy' will be ['mm', '/', 'dd', '/', 'yyyyy'].\nexport const formatToSchema = (format) => {\n  if (!format) return undefined;\n  const result = [];\n\n  let i = 0;\n  let part;\n  while (i < format.length) {\n    if (!part || part[0] !== format[i]) {\n      if (part) result.push(part);\n      part = format[i];\n    } else {\n      part += format[i];\n    }\n    i += 1;\n  }\n  if (part) result.push(part);\n\n  return result;\n};\n\nconst masks = {\n  m: { length: [1, 2], regexp: /^[1-9]$|^1[0-2]$/ },\n  mm: { length: [1, 2], regexp: /^[0-1]$|^0[1-9]$|^1[0-2]$/ },\n  d: { length: [1, 2], regexp: /^[1-9]$|^[1-2][0-9]$|^3[0-1]$/ },\n  dd: {\n    length: [1, 2],\n    regexp: /^[0-3]$|^0[1-9]$|^[1-2][0-9]$|^3[0-1]$/,\n  },\n  yy: { length: [1, 2], regexp: /^[0-9]{1,2}$/ },\n  yyyy: { length: [1, 4], regexp: /^[0-9]{1,4}$/ },\n};\n\nexport const schemaToMask = (schema) => {\n  if (!schema) return undefined;\n  return schema.map((part) => {\n    const lower = part.toLowerCase();\n    const char = lower[0];\n    if (char === 'm' || char === 'd' || char === 'y')\n      return { placeholder: part, ...masks[lower] };\n    return { fixed: part };\n  });\n};\n\n// convert value into text representation using the schema\nexport const valueToText = (value, schema) => {\n  let text = '';\n  // when user initializes dates as empty array, we want to still\n  // show the placeholder text\n  if (!value || (Array.isArray(value) && !value.length)) return text;\n\n  const dates = (Array.isArray(value) ? value : [value]).map((v) =>\n    setHoursWithOffset(v),\n  );\n\n  let dateIndex = 0;\n  let parts = {};\n  schema.every((part) => {\n    const char = part[0].toLowerCase();\n    // advance dateIndex if we already have this part\n    while (\n      dateIndex < dates.length &&\n      (Number.isNaN(dates[dateIndex].date) ||\n        ((char === 'm' || char === 'd' || char === 'y') && parts[part]))\n    ) {\n      dateIndex += 1;\n      parts = {};\n    }\n    const date = dates[dateIndex];\n\n    if (date && part === 'm') {\n      text += date.getMonth() + 1;\n      parts[part] = true;\n    } else if (date && part === 'mm') {\n      text += `0${date.getMonth() + 1}`.slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'd') {\n      text += date.getDate();\n      parts[part] = true;\n    } else if (date && part === 'dd') {\n      text += `0${date.getDate()}`.slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yy') {\n      text += date.getFullYear().toString().slice(-2);\n      parts[part] = true;\n    } else if (date && part === 'yyyy') {\n      text += date.getFullYear();\n      parts[part] = true;\n    } else if (\n      !date &&\n      (part[0] === 'm' || part[0] === 'd' || part[0] === 'y')\n    ) {\n      return false;\n    } else {\n      text += part;\n    }\n    return true;\n  });\n\n  return text;\n};\n\nconst charCodeZero = '0'.charCodeAt(0);\nconst charCodeNine = '9'.charCodeAt(0);\n\nconst pullDigits = (text, index) => {\n  let end = index;\n  while (\n    text.charCodeAt(end) >= charCodeZero &&\n    text.charCodeAt(end) <= charCodeNine\n  )\n    end += 1;\n  return text.slice(index, end);\n};\n\nexport const textToValue = (text, schema, range, reference, outputFormat) => {\n  if (!text) return range ? [] : undefined;\n\n  let result;\n\n  const addDate = (parts) => {\n    const leapYear =\n      (parts.y % 4 === 0 && parts.y % 100 !== 0) || parts.y % 400 === 0;\n\n    // Do a little sanity checking on the parts first.\n    // If not valid, leave as is.\n    if (\n      !parts.m ||\n      !parts.d ||\n      !parts.y ||\n      parts.y.length < 4 ||\n      parts.m.length > 2 ||\n      parts.d.length > 2 ||\n      parts.m > 12 ||\n      parts.d > 31 ||\n      ((parts.m === `02` || parts.m === `2`) && parts.d > (leapYear ? 29 : 28))\n    )\n      return parts;\n\n    // use time info from reference date\n    const time = reference\n      ? [\n          reference.getHours(),\n          reference.getMinutes(),\n          reference.getSeconds(),\n          reference.getMilliseconds(),\n        ]\n      : null;\n\n    let date = new Date(parts.y, parts.m - 1, parts.d, ...time).toISOString();\n\n    if (date && outputFormat === 'no timezone') {\n      [date] = handleOffset(date).toISOString().split('T');\n    }\n\n    if (!range) {\n      if (!result) result = date;\n    } else {\n      if (!result) result = [];\n      result.push(date);\n    }\n    // we've consumed these parts, return an empty object in case we need\n    // to start building up another one for a range\n    return {};\n  };\n\n  let parts = {};\n  let index = 0;\n  schema.forEach((part) => {\n    if (index < text.length) {\n      const lower = part.toLowerCase();\n      const char = lower[0];\n      if (parts[char] !== undefined) parts = addDate(parts);\n\n      if (char === 'm') {\n        parts.m = pullDigits(text, index);\n        index += parts.m.length;\n      } else if (char === 'd') {\n        parts.d = pullDigits(text, index);\n        // when format is something like yyyy/mm/dd,\n        // '0' as incomplete day can cause date to be\n        // prematurely calculated.\n        // ex: 2022/01/0 would reutrn 2021/12/31 in addDate()\n        if (parts.d === '0') delete parts.d;\n        index += parts?.d?.length || 0;\n      } else if (char === 'y') {\n        parts.y = pullDigits(text, index);\n        index += parts.y.length;\n        if (lower === 'yy' && parts.y.length === 2) {\n          // convert to full year, pivot at 69 based on POSIX strptime()\n          parts.y = `${parts.y < 69 ? 20 : 19}${parts.y}`;\n        }\n      } else if (text.slice(index, index + part.length) === part) {\n        index += part.length;\n      } else {\n        // syntax error\n        index = text.length;\n        result = undefined;\n      }\n    }\n  });\n  parts = addDate(parts);\n\n  if (!result) return range ? [] : undefined;\n  return result;\n};\n\nexport const valuesAreEqual = (value1, value2) =>\n  (Array.isArray(value1) &&\n    Array.isArray(value2) &&\n    value1.every((d1, i) => d1 === value2[i])) ||\n  value1 === value2;"
    },
    "3": {
        "bug_file": "src/js/components/Calendar/Calendar.js",
        "compressed": "YES",
        "line_numbers": 913,
        "compressed_line_numbers": 128,
        "compressed_bug_file_content": "import React, {\n\n\nimport { ThemeContext } from 'styled-components';\nimport { defaultProps } from '../../default-props';\nimport { AnnounceContext } from '../../contexts/AnnounceContext';\nimport { MessageContext } from '../../contexts/MessageContext';\n\nimport { Box } from '../Box';\nimport { Button } from '../Button';\nimport { Heading } from '../Heading';\nimport { Keyboard } from '../Keyboard';\n\nimport {\n\n\nimport {\n\n\nimport { CalendarPropTypes } from './propTypes';\nimport { setHoursWithOffset } from '../../utils/dates';\n\n\n// calendar value may be a single date, multiple dates, a range of dates\n// supplied as ISOstrings.\n\n\n  // date may be an empty string ''\n\n\n// format value to [[]] for internal functions\n\n\n  // In case Sunday is the first day of the month, and the user asked for Monday\n  // to be the first day of the week, then we need to include Sunday and six\n  // days prior.\n\n\nexport const getOutputFormat = (dates) => {\n\n\n    // when mousedown, we don't want to let Calendar set\n    // active date to firstInMonth\n\n\n    // set activeDate when caller changes it, allows us to change\n    // it internally too\n\n\n    // normalize bounds\n\n\n    // calculate the bounds we display based on the reference\n\n\n    // When the reference changes, we need to update the displayBounds.\n    // This is easy when we aren't animating. If we are animating,\n    // we temporarily increase the displayBounds to be the union of the old\n    // and new ones and set slide to drive the animation. We keep track\n    // of where we are heading via targetDisplayBounds. When the animation\n    // finishes, we prune displayBounds down to where we are headed and\n    // clear the slide and targetDisplayBounds.\n\n\n      // Checks if the difference between the current and next DisplayBounds is\n      // greater than a year. If that's the case, calendar should update without\n      // animation.\n\n\n      // if the reference timezone has changed (e.g., controlled component),\n      // both ends of the displayBounds should inherit that new timestamp\n\n\n          // only animate if the duration is within a year\n\n\n    // Last step in updating the displayBounds. Allows for pruning\n    // displayBounds and cleaning up states to occur after animation.\n\n\n        // Wait for animation to finish before cleaning up.\n\n\n    // We have to deal with reference being the end of a month with more\n    // days than the month we are changing to. So, we always set reference\n    // to the first of the month before changing the month.\n\n\n        // deselect when date clicked was the start/end of the range\n\n\n        // selecting start date\n\n\n        // selecting end date\n\n\n        // If no dates selected, always return undefined; else format\n        // result according to specified range value.\n\n\n      // Chrome moves the focus indicator to this button. Set\n      // the focus to the grid of days instead.\n\n\n          /* If the length days array is less than the current getDate()\n          we know that all days in the array are from the next month. */\n\n\n        /* Do not show adjacent days in 6th row if all days\n        fall in the next month */\n\n\n        /* If the length days array is less than the current getDate()\n        we know that all days in the array are from the next month. */\n\n\n        // this.dayRefs[dateObject] = React.createRef();\n\n\n        // if a week contains only blank days, for screen reader accessibility\n        // we don't want to set role=\"row\"\n\n\n                // caller focused onto Calendar via keyboard\n\n\nexport { Calendar };\n"
    },
    "4": {
        "bug_file": "src/js/utils/dates.js",
        "compressed": "NO",
        "line_numbers": 11,
        "compressed_line_numbers": 11,
        "compressed_bug_file_content": "export const setHoursWithOffset = (date) => {\n  const newDate = new Date(date);\n\n  if (date?.indexOf('T') === -1) {\n    const offset = newDate.getTimezoneOffset();\n    const hour = newDate.getHours();\n    newDate.setHours(hour, offset < 0 ? -offset : offset);\n  }\n\n  return newDate;\n};"
    }
}