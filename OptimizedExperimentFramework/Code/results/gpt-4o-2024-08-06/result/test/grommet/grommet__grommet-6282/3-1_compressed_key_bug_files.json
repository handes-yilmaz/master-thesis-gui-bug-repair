{
    "1": {
        "bug_file": "src/js/components/DataTable/DataTable.js",
        "compressed": "YES",
        "line_numbers": 575,
        "compressed_line_numbers": 104,
        "compressed_bug_file_content": "import React, {\n\n\nimport { ThemeContext } from 'styled-components';\n\nimport { defaultProps } from '../../default-props';\n\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { Box } from '../Box';\nimport { Text } from '../Text';\nimport { Header } from './Header';\nimport { Footer } from './Footer';\nimport { Body } from './Body';\nimport { GroupedBody } from './GroupedBody';\nimport { Pagination } from '../Pagination';\nimport {\n\n\nimport { normalizeShow, usePagination } from '../../utils';\nimport {\n\n\nimport { DataTablePropTypes } from './propTypes';\nimport { PlaceholderBody } from './PlaceholderBody';\n\n\n  // property name of the primary property\n\n\n  // whether or not we should show a footer\n\n\n  // what column we are actively capturing filter input on\n\n\n  // the currently active filters\n\n\n  // which column we are sorting on, with direction\n\n\n  // the data filtered and sorted, if needed\n  // Note: onUpdate mode expects the data to be passed\n  //   in completely filtered and sorted already.\n\n\n  // the values to put in the footer cells\n\n\n  // cell styling properties: background, border, pad\n\n\n  // if groupBy, an array with one item per unique groupBy key value\n\n\n  // an object indicating which group values are expanded\n\n\n  // any customized column widths\n\n\n  // placeholder placement stuff\n\n\n  // offset compensation when body overflows\n\n\n  // multiple pinned columns offset\n\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n\n  // remember that we are filtering on this property\n\n\n  // remember the search text we should filter this property by\n\n\n    // Let caller know about search, if interested\n\n\n  // toggle the sort direction on this property\n\n\n  // toggle whether the group is expanded\n\n\n  // toggle whether all groups are expanded\n\n\n  // remember the width this property's column should be\n\n\n  // DataTable should overflow if paginating but pagination component\n  // should remain in its location\n\n\n  // necessary for Firefox, otherwise paginated DataTable will\n  // not fill its container like it does by default on other\n  // browsers like Chrome/Safari\n\n\nexport { DataTable };\n"
    },
    "2": {
        "bug_file": "src/js/components/DataTable/Sorter.js",
        "compressed": "NO",
        "line_numbers": 60,
        "compressed_line_numbers": 60,
        "compressed_bug_file_content": "import React, { useContext } from 'react';\nimport styled, { ThemeContext } from 'styled-components';\n\nimport { defaultProps } from '../../default-props';\n\nimport { Button } from '../Button';\nimport { Box } from '../Box';\n\nconst SorterButton = styled(Button)`\n  flex-shrink: 1;\n  height: 100%;\n`;\n\nconst Sorter = ({\n  align,\n  children,\n  fill,\n  onSort,\n  property,\n  sort,\n  themeProps,\n}) => {\n  const theme = useContext(ThemeContext) || defaultProps.theme;\n  let icon;\n  if (sort && sort.property === property) {\n    const Icon =\n      theme.dataTable.icons[sort.ascending ? 'ascending' : 'descending'];\n    icon = <Icon />;\n  }\n  let content = (\n    <Box\n      {...themeProps}\n      flex=\"shrink\"\n      direction=\"row\"\n      justify={align}\n      align=\"center\"\n      gap=\"xsmall\"\n      fill={fill}\n    >\n      {children}\n      {icon}\n    </Box>\n  );\n  if (onSort) {\n    content = (\n      <SorterButton fill={fill} hoverIndicator onClick={onSort(property)}>\n        {content}\n      </SorterButton>\n    );\n  }\n\n  return content;\n};\n\nSorter.displayName = 'Sorter';\n\nSorter.defaultProps = {};\nObject.setPrototypeOf(Sorter.defaultProps, defaultProps);\n\nexport { Sorter };"
    },
    "3": {
        "bug_file": "src/js/components/DataTable/buildState.js",
        "compressed": "NO",
        "line_numbers": 325,
        "compressed_line_numbers": 325,
        "compressed_bug_file_content": "// This file contains helper functions for DataTable, to keep the component\n// files simpler.\n\nexport const set = (obj, path, value) => {\n  let parts = path;\n  if (Object(obj) !== obj) return obj;\n  if (!Array.isArray(path)) parts = path.toString().match(/[^.[\\]]+/g) || [];\n\n  parts.slice(0, -1).reduce((acc, item, index) => {\n    if (Object(acc[item]) === acc[item]) {\n      return acc[item];\n    }\n    acc[item] = Math.abs(parts[index + 1]) > 0 === +parts[index + 1] ? [] : {};\n    return acc[item];\n  }, obj)[parts[parts.length - 1]] = value;\n\n  return obj;\n};\n\n// get the value for the property in the datum object\nexport const datumValue = (datum, property) => {\n  if (!property) return undefined;\n  const parts = property.split('.');\n  if (parts.length === 1) {\n    return datum[property];\n  }\n  if (!datum[parts[0]]) {\n    return undefined;\n  }\n  return datumValue(datum[parts[0]], parts.slice(1).join('.'));\n};\n\n// get the primary property name\nexport const normalizePrimaryProperty = (columns, primaryKey) => {\n  let result;\n  columns.forEach((column) => {\n    // remember the first key property\n    if (column.primary && !result) {\n      result = column.property;\n    }\n  });\n  if (!result) {\n    if (primaryKey === false) result = undefined;\n    else if (primaryKey) result = primaryKey;\n    else if (columns.length > 0) result = columns[0].property;\n  }\n  return result;\n};\n\n// initialize filters with empty strings\nexport const initializeFilters = (columns) => {\n  const result = {};\n  columns.forEach((column) => {\n    if (column.search) {\n      result[column.property] = '';\n    }\n  });\n  return result;\n};\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\nconst escapeRegExp = (input) => input.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n// filter data based on filters then sort\nexport const filterAndSortData = (data, filters, onSearch, sort) => {\n  let result = data;\n  if (!onSearch) {\n    const regexps = {};\n    Object.keys(filters)\n      .filter((n) => filters[n])\n      .forEach((n) => {\n        regexps[n] = new RegExp(escapeRegExp(filters[n]), 'i');\n      });\n    if (Object.keys(regexps).length > 0) {\n      result = data.filter(\n        (datum) =>\n          !Object.keys(regexps).some(\n            (property) => !regexps[property].test(datumValue(datum, property)),\n          ),\n      );\n    }\n  }\n\n  if (sort && !sort.external) {\n    const { property, direction } = sort;\n    result = result === data ? [...data] : result; // don't sort caller's data\n    const sortAsc = direction === 'asc';\n    const before = sortAsc ? 1 : -1;\n    const after = sortAsc ? -1 : 1;\n    result.sort((d1, d2) => {\n      const d1Val = datumValue(d1, property);\n      const d2Val = datumValue(d2, property);\n      if (typeof d1Val === 'string' && typeof d2Val === 'string') {\n        const sortResult = d1Val.localeCompare(d2Val, undefined, {\n          sensitivity: 'base',\n        });\n        return sortAsc ? sortResult : -sortResult;\n      }\n      if (d1Val > d2Val) return before;\n      if (d1Val < d2Val) return after;\n      return 0;\n    });\n  }\n\n  return result;\n};\n\n// aggregate reducers\nconst sumReducer = (accumulated, next) => accumulated + next;\nconst minReducer = (accumulated, next) =>\n  accumulated === undefined ? next : Math.min(accumulated, next);\nconst maxReducer = (accumulated, next) =>\n  accumulated === undefined ? next : Math.max(accumulated, next);\n\nconst reducers = {\n  max: maxReducer,\n  min: minReducer,\n  sum: sumReducer,\n};\n\n// aggregate reducers init values\nconst reducersInitValues = {\n  min: Number.MAX_VALUE,\n  max: Number.MIN_VALUE,\n  sum: 0,\n};\n\n// aggregate a single column\nconst aggregateColumn = (column, data) => {\n  let value;\n  if (column.aggregate === 'avg') {\n    value = data.map((d) => datumValue(d, column.property)).reduce(sumReducer);\n    value /= data.length;\n  } else {\n    value = data\n      .map((d) => datumValue(d, column.property))\n      .reduce(reducers[column.aggregate], reducersInitValues[column.aggregate]);\n  }\n  return value;\n};\n\n// aggregate all columns that can\nconst aggregate = (columns, data) => {\n  let result = {};\n  columns.forEach((column) => {\n    if (column.aggregate) {\n      const value = aggregateColumn(column, data);\n      result = set(result, column.property, value);\n    }\n  });\n\n  return result;\n};\n\n// build the values for the footer cells\nexport const buildFooterValues = (columns, data) => {\n  const aggregateValues = aggregate(columns, data);\n\n  let result = {};\n  columns.forEach((column) => {\n    if (column.footer) {\n      if (column.footer.aggregate) {\n        const value = datumValue(aggregateValues, column.property);\n        result = set(result, column.property, value);\n      } else {\n        result = set(result, column.property, column.footer);\n      }\n    }\n  });\n\n  return result;\n};\n\n// looks at the groupBy property of each data object and returns an\n// array with one item for each unique value of that property.\nexport const buildGroups = (columns, data, groupBy, primaryProperty) => {\n  let result;\n  if (groupBy?.property || typeof groupBy === 'string') {\n    result = [];\n    const groupMap = {};\n    data.forEach((datum) => {\n      const key = datumValue(datum, primaryProperty);\n      const isGroup = key && groupBy.expandable?.includes(key);\n\n      const groupByProperty = groupBy.property ? groupBy.property : groupBy;\n      const groupValue = isGroup ? key : datumValue(datum, groupByProperty);\n      if (!groupMap[groupValue]) {\n        const group = {\n          data: [],\n          datum: isGroup ? datum : {},\n          key: groupValue,\n        };\n        group.datum[groupByProperty] = groupValue;\n        result.push(group);\n        groupMap[groupValue] = group;\n      }\n      if (!isGroup) groupMap[groupValue].data.push(datum);\n    });\n\n    // include any aggregate column values across the data for each group\n    // If expandable was specified we let the onUpdate callback do it since\n    // we may not have access to all the data to aggregate it.\n    if (!groupBy.expandable) {\n      columns.forEach((column) => {\n        if (column.aggregate) {\n          result.forEach((group) => {\n            const { datum } = group;\n            datum[column.property] = aggregateColumn(column, group.data);\n          });\n        }\n      });\n    }\n  } else if (groupBy?.expandable) {\n    result = groupBy.expandable.map((key) => ({ data: [], datum: {}, key }));\n  }\n\n  return result;\n};\n\n// build group expanded state, expanding any in groupBy.expand\nexport const buildGroupState = (groups, groupBy) => {\n  const result = {};\n  if (groups) {\n    groups.forEach(({ key }) => {\n      if (key) result[key] = { expanded: false };\n    });\n  }\n  if (groupBy && groupBy.expand) {\n    groupBy.expand.forEach((value) => {\n      result[value] = { expanded: true };\n    });\n  }\n  return result;\n};\n\nexport const normalizeBackgroundColor = (theme) => {\n  const { background } = theme; // context background\n  if (typeof background === 'string') return background;\n  if (background.light && background.dark) return background;\n  if (background.color) return background.color;\n  return undefined;\n};\n\nexport const normalizeRowProp = (name, rowProp, prop) => {\n  if (rowProp && rowProp[name]) return rowProp[name];\n  return prop;\n};\n\nconst tableContextNames = ['header', 'body', 'footer'];\nconst cellPropertyNames = ['background', 'border', 'pad'];\n\n// Convert property specific cell props to context specific cell props.\n// For example, background={{ header: { background } }}\n// will become cellProps.header.background\nexport const normalizeCellProps = (props, theme) => {\n  const result = {};\n  tableContextNames.forEach((context) => {\n    result[context] = { pinned: {} };\n    cellPropertyNames.forEach((propName) => {\n      let value =\n        props?.[propName]?.[context] ||\n        // if the propName is used without context, it applies to all contexts\n        (tableContextNames.every((n) => !props?.[propName]?.[n]) &&\n          props?.[propName]) ||\n        theme?.dataTable?.[context]?.[propName] ||\n        theme?.table?.[context]?.[propName];\n      if (value !== undefined) result[context][propName] = value;\n\n      // pinned case\n      value =\n        props?.[propName]?.pinned?.[context] ||\n        (context === 'body' &&\n          tableContextNames.every((n) => !props?.[propName]?.pinned?.[n]) &&\n          props?.[propName]?.pinned) ||\n        theme?.dataTable?.pinned?.[context]?.[propName];\n      if (value !== undefined) {\n        if (\n          propName === 'background' &&\n          theme.background &&\n          value.opacity &&\n          !value.color\n        )\n          // theme context has an active background color but the\n          // theme doesn't set an explicit color, repeat the context\n          // background explicitly\n          value.color = normalizeBackgroundColor(theme);\n\n        if (context === 'body')\n          // in case we have pinned columns, store the pinned stuff in\n          // cellProps.body.pinned\n          result[context].pinned[propName] = value;\n        else if (props.pin === true || props.pin === context)\n          // this context is pinned, use the pinned value directly\n          result[context][propName] = value;\n      }\n    });\n  });\n  return result;\n};\n\nexport const normalizeRowCellProps = (\n  rowProps,\n  cellProps,\n  primaryKey,\n  index,\n) => {\n  const result = { pinned: {} };\n  ['background', 'border', 'pad'].forEach((propName) => {\n    const row = primaryKey && rowProps && rowProps?.[primaryKey]?.[propName];\n    const cell = cellProps[propName];\n    let value =\n      (row && (Array.isArray(row) ? row[index % row.length] : row)) ||\n      (Array.isArray(cell) ? cell[index % cell.length] : cell);\n    if (value !== undefined) result[propName] = value;\n\n    const rowPin = rowProps && rowProps.pinned && rowProps.pinned[propName];\n    const cellPin = cellProps.pinned[propName];\n    value =\n      (rowPin &&\n        (Array.isArray(rowPin) ? rowPin[index % rowPin.length] : rowPin)) ||\n      (Array.isArray(cellPin) ? cellPin[index % cellPin.length] : cellPin);\n    if (value !== undefined) result.pinned[propName] = value;\n  });\n  return result;\n};"
    }
}