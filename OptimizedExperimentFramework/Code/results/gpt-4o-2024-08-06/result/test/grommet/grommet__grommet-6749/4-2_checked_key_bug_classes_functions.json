{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/js/components/DataTable/DataTable.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "import React, {",
                "  useCallback,",
                "  useContext,",
                "  useEffect,",
                "  useMemo,",
                "  useRef,",
                "  useState,",
                "  Fragment,",
                "} from 'react';",
                "import { ThemeContext } from 'styled-components';",
                "",
                "import { defaultProps } from '../../default-props';",
                "",
                "import { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';",
                "import { DataContext } from '../../contexts/DataContext';",
                "import { Box } from '../Box';",
                "import { Text } from '../Text';",
                "import { Header } from './Header';",
                "import { Footer } from './Footer';",
                "import { Body } from './Body';",
                "import { GroupedBody } from './GroupedBody';",
                "import { Pagination } from '../Pagination';",
                "import {",
                "  buildFooterValues,",
                "  buildGroups,",
                "  buildGroupState,",
                "  filterAndSortData,",
                "  initializeFilters,",
                "  normalizeCellProps,",
                "  normalizePrimaryProperty,",
                "} from './buildState';",
                "import { normalizeShow, usePagination } from '../../utils';",
                "import {",
                "  StyledContainer,",
                "  StyledDataTable,",
                "  StyledPlaceholder,",
                "} from './StyledDataTable';",
                "import { DataTablePropTypes } from './propTypes';",
                "import { PlaceholderBody } from './PlaceholderBody';",
                "",
                "const emptyData = [];",
                "",
                "function useGroupState(groups, groupBy) {",
                "  const [groupState, setGroupState] = useState(() =>",
                "    buildGroupState(groups, groupBy),",
                "  );",
                "  const [prevDeps, setPrevDeps] = useState({ groups, groupBy });",
                "",
                "  const { groups: prevGroups, groupBy: prevGroupBy } = prevDeps;",
                "  if (groups !== prevGroups || groupBy !== prevGroupBy) {",
                "    setPrevDeps({ groups, groupBy });",
                "    const nextGroupState = buildGroupState(groups, groupBy);",
                "    setGroupState(nextGroupState);",
                "    return [nextGroupState, setGroupState];",
                "  }",
                "",
                "  return [groupState, setGroupState];",
                "}",
                "",
                "const DataTable = ({",
                "  background,",
                "  border,",
                "  columns: columnsProp,",
                "  data: dataProp,",
                "  disabled,",
                "  fill,",
                "  groupBy,",
                "  onClickRow, // removing unknown DOM attributes",
                "  onMore,",
                "  onSearch, // removing unknown DOM attributes",
                "  onSelect,",
                "  onSort: onSortProp,",
                "  onUpdate,",
                "  replace,",
                "  pad,",
                "  paginate,",
                "  pin,",
                "  placeholder,",
                "  primaryKey,",
                "  resizeable,",
                "  rowProps,",
                "  select,",
                "  show: showProp,",
                "  size,",
                "  sort: sortProp,",
                "  sortable,",
                "  rowDetails,",
                "  step = 50,",
                "  verticalAlign,",
                "  ...rest",
                "}) => {",
                "  const theme = useContext(ThemeContext) || defaultProps.theme;",
                "  const {",
                "    view,",
                "    data: contextData,",
                "    properties,",
                "    onView,",
                "  } = useContext(DataContext);",
                "  const data = dataProp || contextData || emptyData;",
                "",
                "  const columns = useMemo(() => {",
                "    let result = [];",
                "    if (columnsProp) result = columnsProp;",
                "    else if (properties)",
                "      result = Object.keys(properties).map((p) => ({",
                "        property: p,",
                "        ...properties[p],",
                "      }));",
                "    else if (data.length)",
                "      result = Object.keys(data[0]).map((p) => ({ property: p }));",
                "    if (view?.columns)",
                "      result = result",
                "        .filter((c) => view.columns.includes(c.property))",
                "        .sort(",
                "          (c1, c2) =>",
                "            view.columns.indexOf(c1.property) -",
                "            view.columns.indexOf(c2.property),",
                "        );",
                "    return result;",
                "  }, [columnsProp, data, properties, view]);",
                "",
                "  // property name of the primary property",
                "  const primaryProperty = useMemo(",
                "    () => normalizePrimaryProperty(columns, primaryKey),",
                "    [columns, primaryKey],",
                "  );",
                "",
                "  // whether or not we should show a footer",
                "  const showFooter = useMemo(",
                "    () => columns.filter((c) => c.footer).length > 0,",
                "    [columns],",
                "  );",
                "",
                "  // what column we are actively capturing filter input on",
                "  const [filtering, setFiltering] = useState();",
                "",
                "  // the currently active filters",
                "  const [filters, setFilters] = useState(initializeFilters(columns));",
                "",
                "  // which column we are sorting on, with direction",
                "  const [sort, setSort] = useState(sortProp || {});",
                "  useEffect(() => {",
                "    if (sortProp) setSort(sortProp);",
                "    else if (view?.sort) setSort(view.sort);",
                "  }, [sortProp, view]);",
                "",
                "  // the data filtered and sorted, if needed",
                "  // Note: onUpdate mode expects the data to be passed",
                "  //   in completely filtered and sorted already.",
                "  const adjustedData = useMemo(",
                "    () => (onUpdate ? data : filterAndSortData(data, filters, onSearch, sort)),",
                "    [data, filters, onSearch, onUpdate, sort],",
                "  );",
                "",
                "  // the values to put in the footer cells",
                "  const footerValues = useMemo(",
                "    () => buildFooterValues(columns, adjustedData),",
                "    [adjustedData, columns],",
                "  );",
                "",
                "  // cell styling properties: background, border, pad",
                "  const cellProps = useMemo(",
                "    () => normalizeCellProps({ background, border, pad, pin }, theme),",
                "    [background, border, pad, pin, theme],",
                "  );",
                "",
                "  // if groupBy, an array with one item per unique groupBy key value",
                "  const groups = useMemo(",
                "    () => buildGroups(columns, adjustedData, groupBy, primaryProperty),",
                "    [adjustedData, columns, groupBy, primaryProperty],",
                "  );",
                "",
                "  // an object indicating which group values are expanded",
                "  const [groupState, setGroupState] = useGroupState(groups, groupBy);",
                "",
                "  const [limit, setLimit] = useState(step);",
                "",
                "  const [selected, setSelected] = useState(",
                "    select || (onSelect && []) || undefined,",
                "  );",
                "  useEffect(",
                "    () => setSelected(select || (onSelect && []) || undefined),",
                "    [onSelect, select],",
                "  );",
                "",
                "  const [rowExpand, setRowExpand] = useState([]);",
                "",
                "  // any customized column widths",
                "  const [widths, setWidths] = useState({});",
                "",
                "  // placeholder placement stuff",
                "  const headerRef = useRef();",
                "  const bodyRef = useRef();",
                "  const footerRef = useRef();",
                "  const [headerHeight, setHeaderHeight] = useState();",
                "  const [footerHeight, setFooterHeight] = useState();",
                "",
                "  // offset compensation when body overflows",
                "  const [scrollOffset, setScrollOffset] = useState(0);",
                "",
                "  // multiple pinned columns offset",
                "  const [pinnedOffset, setPinnedOffset] = useState();",
                "",
                "  const onHeaderWidths = useCallback(",
                "    (columnWidths) => {",
                "      const hasSelectColumn = Boolean(select || onSelect);",
                "      let pinnedProperties = columns",
                "        .map((pinnedColumn) => pinnedColumn.pin && pinnedColumn.property)",
                "        .filter((n) => n);",
                "      if (hasSelectColumn && pinnedProperties.length > 0) {",
                "        pinnedProperties = ['_grommetDataTableSelect', ...pinnedProperties];",
                "      }",
                "      const nextPinnedOffset = {};",
                "",
                "      if (columnWidths !== []) {",
                "        pinnedProperties.forEach((property, index) => {",
                "          const columnIndex =",
                "            property === '_grommetDataTableSelect'",
                "              ? 0",
                "              : columns.findIndex((column) => column.property === property) +",
                "                hasSelectColumn;",
                "          if (columnWidths[columnIndex]) {",
                "            nextPinnedOffset[property] = {",
                "              width: columnWidths[columnIndex],",
                "              left:",
                "                index === 0",
                "                  ? 0",
                "                  : nextPinnedOffset[pinnedProperties[index - 1]].left +",
                "                    nextPinnedOffset[pinnedProperties[index - 1]].width,",
                "            };",
                "          }",
                "        });",
                "        setPinnedOffset(nextPinnedOffset);",
                "      }",
                "    },",
                "    [columns, setPinnedOffset, select, onSelect],",
                "  );",
                "",
                "  // eslint-disable-next-line react-hooks/exhaustive-deps",
                "  useLayoutEffect(() => {",
                "    const nextScrollOffset =",
                "      (bodyRef.current.parentElement?.clientWidth || 0) -",
                "      bodyRef.current.clientWidth;",
                "    if (nextScrollOffset !== scrollOffset) setScrollOffset(nextScrollOffset);",
                "  });",
                "",
                "  useLayoutEffect(() => {",
                "    if (placeholder) {",
                "      if (headerRef.current) {",
                "        const nextHeaderHeight =",
                "          headerRef.current.getBoundingClientRect().height;",
                "        setHeaderHeight(nextHeaderHeight);",
                "      } else setHeaderHeight(0);",
                "      if (footerRef.current) {",
                "        const nextFooterHeight =",
                "          footerRef.current.getBoundingClientRect().height;",
                "        setFooterHeight(nextFooterHeight);",
                "      } else setFooterHeight(0);",
                "    }",
                "  }, [footerRef, headerRef, placeholder]);",
                "",
                "  // remember that we are filtering on this property",
                "  const onFiltering = (property) => setFiltering(property);",
                "",
                "  // remember the search text we should filter this property by",
                "  const onFilter = (property, value) => {",
                "    const nextFilters = { ...filters };",
                "    nextFilters[property] = value;",
                "    setFilters(nextFilters);",
                "    // Let caller know about search, if interested",
                "    if (onSearch) onSearch(nextFilters);",
                "  };",
                "",
                "  // toggle the sort direction on this property",
                "  const onSort = (property) => () => {",
                "    const external = sort ? sort.external : false;",
                "    let direction;",
                "    if (!sort || property !== sort.property) direction = 'asc';",
                "    else if (sort.direction === 'asc') direction = 'desc';",
                "    else direction = 'asc';",
                "    const nextSort = { property, direction, external };",
                "    setSort(nextSort);",
                "    if (onView) {",
                "      onView({ ...view, sort: { property, direction } });",
                "    }",
                "    if (onUpdate) {",
                "      const opts = {",
                "        count: limit,",
                "        sort: nextSort,",
                "      };",
                "      if (groups) {",
                "        opts.expanded = Object.keys(groupState).filter(",
                "          (k) => groupState[k].expanded,",
                "        );",
                "      }",
                "      if (showProp) opts.show = showProp;",
                "      onUpdate(opts);",
                "    }",
                "    if (onSortProp) onSortProp(nextSort);",
                "  };",
                "",
                "  // toggle whether the group is expanded",
                "  const onToggleGroup = (groupValue) => () => {",
                "    const nextGroupState = { ...groupState };",
                "    nextGroupState[groupValue] = {",
                "      ...nextGroupState[groupValue],",
                "      expanded: !nextGroupState[groupValue].expanded,",
                "    };",
                "    setGroupState(nextGroupState);",
                "    const expandedKeys = Object.keys(nextGroupState).filter(",
                "      (k) => nextGroupState[k].expanded,",
                "    );",
                "    if (onUpdate) {",
                "      const opts = {",
                "        expanded: expandedKeys,",
                "        count: limit,",
                "      };",
                "      if (sort?.property) opts.sort = sort;",
                "      if (showProp) opts.show = showProp;",
                "      onUpdate(opts);",
                "    }",
                "    if (groupBy.onExpand) {",
                "      groupBy.onExpand(expandedKeys);",
                "    }",
                "  };",
                "",
                "  // toggle whether all groups are expanded",
                "  const onToggleGroups = () => {",
                "    const expanded =",
                "      Object.keys(groupState).filter((k) => !groupState[k].expanded).length ===",
                "      0;",
                "    const nextGroupState = {};",
                "    Object.keys(groupState).forEach((k) => {",
                "      nextGroupState[k] = { ...groupState[k], expanded: !expanded };",
                "    });",
                "    setGroupState(nextGroupState);",
                "    const expandedKeys = Object.keys(nextGroupState).filter(",
                "      (k) => nextGroupState[k].expanded,",
                "    );",
                "    if (onUpdate) {",
                "      const opts = {",
                "        expanded: expandedKeys,",
                "        count: limit,",
                "      };",
                "      if (showProp) opts.show = showProp;",
                "      if (sort?.property) opts.sort = sort;",
                "      onUpdate(opts);",
                "    }",
                "    if (groupBy.onExpand) {",
                "      groupBy.onExpand(expandedKeys);",
                "    }",
                "  };",
                "",
                "  // remember the width this property's column should be",
                "  const onResize = useCallback(",
                "    (property, width) => {",
                "      if (widths[property] !== width) {",
                "        const nextWidths = { ...widths };",
                "        nextWidths[property] = width;",
                "        setWidths(nextWidths);",
                "      }",
                "    },",
                "    [widths],",
                "  );",
                "",
                "  if (size && resizeable) {",
                "    console.warn('DataTable cannot combine \"size\" and \"resizeble\".');",
                "  }",
                "  if (onUpdate && onMore) {",
                "    console.warn('DataTable cannot combine \"onUpdate\" and \"onMore\".');",
                "  }",
                "",
                "  const [items, paginationProps] = usePagination({",
                "    data: adjustedData,",
                "    page: normalizeShow(showProp, step),",
                "    step,",
                "    ...paginate, // let any specifications from paginate prop override component",
                "  });",
                "  const { step: paginationStep } = paginationProps;",
                "",
                "  const Container = paginate ? StyledContainer : Fragment;",
                "  const containterProps = paginate",
                "    ? { ...theme.dataTable.container, fill }",
                "    : undefined;",
                "",
                "  // DataTable should overflow if paginating but pagination component",
                "  // should remain in its location",
                "  const OverflowContainer = paginate ? Box : Fragment;",
                "  const overflowContainerProps = paginate",
                "    ? { overflow: { horizontal: 'auto' } }",
                "    : undefined;",
                "",
                "  // necessary for Firefox, otherwise paginated DataTable will",
                "  // not fill its container like it does by default on other",
                "  // browsers like Chrome/Safari",
                "  const paginatedDataTableProps =",
                "    paginate && (fill === true || fill === 'horizontal')",
                "      ? { style: { minWidth: '100%' } }",
                "      : undefined;",
                "",
                "  let placeholderContent = placeholder;",
                "  if (placeholder && typeof placeholder === 'string') {",
                "    placeholderContent = (",
                "      <Box",
                "        background={{ color: 'background-front', opacity: 'strong' }}",
                "        align=\"center\"",
                "        justify=\"center\"",
                "        fill=\"vertical\"",
                "      >",
                "        <Text>{placeholder}</Text>",
                "      </Box>",
                "    );",
                "  }",
                "",
                "  const bodyContent = groups ? (",
                "    <GroupedBody",
                "      ref={bodyRef}",
                "      cellProps={cellProps.body}",
                "      columns={columns}",
                "      disabled={disabled}",
                "      groupBy={typeof groupBy === 'string' ? { property: groupBy } : groupBy}",
                "      groups={groups}",
                "      groupState={groupState}",
                "      pinnedOffset={pinnedOffset}",
                "      primaryProperty={primaryProperty}",
                "      onMore={",
                "        onUpdate",
                "          ? () => {",
                "              if (adjustedData.length === limit) {",
                "                const opts = {",
                "                  expanded: Object.keys(groupState).filter(",
                "                    (k) => groupState[k].expanded,",
                "                  ),",
                "                  count: limit + paginationStep,",
                "                };",
                "                if (sort?.property) opts.sort = sort;",
                "                if (showProp) opts.show = showProp;",
                "                onUpdate(opts);",
                "                setLimit((prev) => prev + paginationStep);",
                "              }",
                "            }",
                "          : onMore",
                "      }",
                "      onSelect={",
                "        onSelect",
                "          ? (nextSelected, row) => {",
                "              setSelected(nextSelected);",
                "              if (onSelect) onSelect(nextSelected, row);",
                "            }",
                "          : undefined",
                "      }",
                "      onToggle={onToggleGroup}",
                "      onUpdate={onUpdate}",
                "      replace={replace}",
                "      rowProps={rowProps}",
                "      selected={selected}",
                "      size={size}",
                "      step={paginationStep}",
                "      verticalAlign={",
                "        typeof verticalAlign === 'string' ? verticalAlign : verticalAlign?.body",
                "      }",
                "    />",
                "  ) : (",
                "    <Body",
                "      ref={bodyRef}",
                "      cellProps={cellProps.body}",
                "      columns={columns}",
                "      data={!paginate ? adjustedData : items}",
                "      disabled={disabled}",
                "      onMore={",
                "        onUpdate",
                "          ? () => {",
                "              if (adjustedData.length === limit) {",
                "                const opts = {",
                "                  count: limit + paginationStep,",
                "                };",
                "                if (sort?.property) opts.sort = sort;",
                "                if (showProp) opts.show = showProp;",
                "                onUpdate(opts);",
                "                setLimit((prev) => prev + paginationStep);",
                "              }",
                "            }",
                "          : onMore",
                "      }",
                "      replace={replace}",
                "      onClickRow={onClickRow}",
                "      onSelect={",
                "        onSelect",
                "          ? (nextSelected, row) => {",
                "              setSelected(nextSelected);",
                "              if (onSelect) onSelect(nextSelected, row);",
                "            }",
                "          : undefined",
                "      }",
                "      pinnedCellProps={cellProps.pinned}",
                "      pinnedOffset={pinnedOffset}",
                "      primaryProperty={primaryProperty}",
                "      rowProps={rowProps}",
                "      selected={selected}",
                "      show={!paginate ? showProp : undefined}",
                "      size={size}"
            ]
        },
        "2": {
            "class_name": "  (not found) ",
            "file_path": "src/js/components/DataTable/GroupedBody.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 241
                }
            ],
            "class_code": [
                "import React, { forwardRef, useMemo } from 'react';",
                "",
                "import { Cell } from './Cell';",
                "import { ExpanderCell } from './ExpanderCell';",
                "import { StyledDataTableBody, StyledDataTableRow } from './StyledDataTable';",
                "import { CheckBox } from '../CheckBox/CheckBox';",
                "import { InfiniteScroll } from '../InfiniteScroll';",
                "import { TableRow } from '../TableRow';",
                "import { TableCell } from '../TableCell';",
                "import { datumValue, normalizeRowCellProps } from './buildState';",
                "",
                "export const GroupedBody = forwardRef(",
                "  (",
                "    {",
                "      cellProps: cellPropsProp,",
                "      columns,",
                "      data,",
                "      disabled,",
                "      groupBy,",
                "      groups,",
                "      groupState,",
                "      pinnedOffset,",
                "      primaryProperty,",
                "      onMore,",
                "      onSelect,",
                "      onToggle,",
                "      onUpdate,",
                "      replace,",
                "      rowProps,",
                "      selected,",
                "      size,",
                "      step,",
                "      verticalAlign,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const items = useMemo(() => {",
                "      const nextItems = [];",
                "      groups.forEach((group) => {",
                "        const { expanded } = groupState[group.key] || { expanded: true };",
                "        const memberCount = group.data.length;",
                "        let groupSelected = [];",
                "        let isGroupSelected = false;",
                "        let groupDisabled = [];",
                "        let isGroupDisabled = false;",
                "",
                "        if (memberCount > 1 || (onUpdate && group.key)) {",
                "          // need a header",
                "          const primaryKeys = group.data.map((datum) => datum[primaryProperty]);",
                "",
                "          groupSelected =",
                "            primaryKeys && selected",
                "              ? primaryKeys.filter((val) => selected.includes(val))",
                "              : [];",
                "",
                "          isGroupSelected = groupBy.select",
                "            ? groupBy.select[group.key] === 'all'",
                "            : groupSelected.length === group.data.length &&",
                "              groupSelected.length > 0;",
                "",
                "          const indeterminate = groupBy.select",
                "            ? groupBy.select[group.key] === 'some'",
                "            : groupSelected.length > 0 &&",
                "              groupSelected.length < group.data.length;",
                "",
                "          groupDisabled =",
                "            primaryKeys && disabled",
                "              ? primaryKeys.filter((val) => disabled.includes(val))",
                "              : [];",
                "",
                "          isGroupDisabled = groupBy.disable",
                "            ? groupBy.disable[group.key] === 'all'",
                "            : groupDisabled.length === group.data.length &&",
                "              groupDisabled.length > 0;",
                "",
                "          nextItems.push({",
                "            expanded,",
                "            key: group.key,",
                "            primaryValue: group.key,",
                "            datum: group.datum,",
                "            context: 'groupHeader',",
                "            isDisabled: isGroupDisabled,",
                "            isSelected: isGroupSelected,",
                "            indeterminate,",
                "            onChange: () => {",
                "              const nextSelected =",
                "                isGroupSelected || indeterminate",
                "                  ? selected.filter((s) => !groupSelected.includes(s))",
                "                  : [...selected, ...primaryKeys];",
                "              if (groupBy.onSelect) {",
                "                groupBy.onSelect(nextSelected, group.datum, groupBy.select);",
                "              } else {",
                "                onSelect(nextSelected, group.datum);",
                "              }",
                "            },",
                "          });",
                "        }",
                "        if ((!onUpdate && memberCount === 1) || expanded) {",
                "          // add the group members",
                "          group.data.forEach((datum, index) => {",
                "            const primaryValue = primaryProperty",
                "              ? datumValue(datum, primaryProperty)",
                "              : undefined;",
                "            const isSelected = selected?.includes(primaryValue);",
                "            const isDisabled = disabled?.includes(primaryValue);",
                "            nextItems.push({",
                "              key: datum[primaryProperty],",
                "              primaryValue: primaryProperty",
                "                ? datumValue(datum, primaryProperty)",
                "                : undefined,",
                "              datum,",
                "              context:",
                "                memberCount > 1 && index === memberCount - 1",
                "                  ? 'groupEnd'",
                "                  : 'body',",
                "              isDisabled,",
                "              isSelected,",
                "              onChange: () => {",
                "                const nextSelected = isSelected",
                "                  ? selected.filter((s) => s !== primaryValue)",
                "                  : [...selected, primaryValue];",
                "                onSelect(nextSelected, datum);",
                "              },",
                "            });",
                "          });",
                "        }",
                "      });",
                "      return nextItems;",
                "    }, [",
                "      disabled,",
                "      groups,",
                "      groupBy,",
                "      groupState,",
                "      primaryProperty,",
                "      selected,",
                "      onSelect,",
                "      onUpdate,",
                "    ]);",
                "",
                "    return (",
                "      <StyledDataTableBody ref={ref} size={size} {...rest}>",
                "        <InfiniteScroll",
                "          items={items}",
                "          onMore={onMore}",
                "          replace={replace}",
                "          renderMarker={(marker) => (",
                "            <TableRow>",
                "              <TableCell>{marker}</TableCell>",
                "            </TableRow>",
                "          )}",
                "          step={step}",
                "        >",
                "          {(row, index, rowRef) => {",
                "            const {",
                "              context,",
                "              datum,",
                "              expanded,",
                "              indeterminate,",
                "              isDisabled,",
                "              isSelected,",
                "              key,",
                "              onChange,",
                "              primaryValue,",
                "            } = row;",
                "            const cellProps = normalizeRowCellProps(",
                "              rowProps,",
                "              cellPropsProp,",
                "              primaryValue,",
                "              index,",
                "            );",
                "",
                "            return (",
                "              <StyledDataTableRow ref={rowRef} key={key} size={size}>",
                "                <ExpanderCell",
                "                  background={cellProps.background}",
                "                  border={cellProps.border}",
                "                  context={context}",
                "                  pad={cellProps.pad}",
                "                  onToggle={",
                "                    context === 'groupHeader' ? onToggle(key) : undefined",
                "                  }",
                "                  expanded={expanded}",
                "                  verticalAlign={verticalAlign}",
                "                />",
                "                {(selected || onSelect) && (",
                "                  <TableCell",
                "                    background={cellProps.background}",
                "                    border={cellProps.pinned.border || cellProps.border}",
                "                    plain=\"noPad\"",
                "                    size=\"auto\"",
                "                    verticalAlign={verticalAlign}",
                "                    aria-disabled={isDisabled || !onSelect || undefined}",
                "                  >",
                "                    <CheckBox",
                "                      a11yTitle={`${isSelected ? 'unselect' : 'select'} ${",
                "                        context === 'groupHeader' ? key : primaryValue",
                "                      }`}",
                "                      checked={isSelected}",
                "                      indeterminate={indeterminate}",
                "                      disabled={isDisabled || !onSelect}",
                "                      onChange={onChange}",
                "                      pad={cellProps.pad}",
                "                    />",
                "                  </TableCell>",
                "                )}",
                "                {columns.map((column) => {",
                "                  let scope;",
                "                  if (context === 'groupHeader') {",
                "                    scope =",
                "                      column.property === groupBy.property ? 'row' : undefined;",
                "                  } else {",
                "                    scope = column.primary ? 'row' : undefined;",
                "                  }",
                "                  return (",
                "                    <Cell",
                "                      key={column.property}",
                "                      background={cellProps.background}",
                "                      border={cellProps.border}",
                "                      context={context}",
                "                      column={column}",
                "                      datum={datum}",
                "                      pad={cellProps.pad}",
                "                      scope={scope}",
                "                      pinnedOffset={",
                "                        context === 'groupHeader' &&",
                "                        pinnedOffset &&",
                "                        pinnedOffset[column.property]",
                "                      }",
                "                      verticalAlign={verticalAlign}",
                "                    />",
                "                  );",
                "                })}",
                "              </StyledDataTableRow>",
                "            );",
                "          }}",
                "        </InfiniteScroll>",
                "      </StyledDataTableBody>",
                "    );",
                "  },",
                ");"
            ]
        },
        "3": {
            "class_name": "  (not found) ",
            "file_path": "src/js/components/Select/Select.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 410
                }
            ],
            "class_code": [
                "import React, {",
                "  forwardRef,",
                "  isValidElement,",
                "  useCallback,",
                "  useContext,",
                "  useMemo,",
                "  useState,",
                "  useRef,",
                "  useEffect,",
                "} from 'react';",
                "import { ThemeContext } from 'styled-components';",
                "",
                "import { useKeyboard } from '../../utils';",
                "import { defaultProps } from '../../default-props';",
                "",
                "import { Box } from '../Box';",
                "import { Keyboard } from '../Keyboard';",
                "import { FormContext } from '../Form/FormContext';",
                "",
                "import { SelectContainer } from './SelectContainer';",
                "import { HiddenInput, StyledSelectDropButton } from './StyledSelect';",
                "import {",
                "  applyKey,",
                "  getNormalizedValue,",
                "  changeEvent,",
                "  getSelectIcon,",
                "  getDisplayLabelKey,",
                "  getIconColor,",
                "} from './utils';",
                "import { DefaultSelectTextInput } from './DefaultSelectTextInput';",
                "import { MessageContext } from '../../contexts/MessageContext';",
                "import { SelectPropTypes } from './propTypes';",
                "",
                "StyledSelectDropButton.defaultProps = {};",
                "Object.setPrototypeOf(StyledSelectDropButton.defaultProps, defaultProps);",
                "",
                "const defaultDropAlign = { top: 'bottom', left: 'left' };",
                "",
                "const Select = forwardRef(",
                "  (",
                "    {",
                "      a11yTitle,",
                "      'aria-label': ariaLabel,",
                "      alignSelf,",
                "      children,",
                "      clear = false,",
                "      closeOnChange = true,",
                "      defaultValue,",
                "      disabled,",
                "      disabledKey,",
                "      dropAlign = defaultDropAlign,",
                "      dropHeight,",
                "      dropProps,",
                "      dropTarget,",
                "      emptySearchMessage,",
                "      focusIndicator,",
                "      gridArea,",
                "      id,",
                "      icon,",
                "      labelKey: labelKeyProp,",
                "      margin,",
                "      messages,",
                "      multiple,",
                "      name,",
                "      onBlur,",
                "      onChange,",
                "      onClick,",
                "      onClose,",
                "      onFocus,",
                "      onKeyDown,",
                "      onMore,",
                "      onOpen,",
                "      onSearch,",
                "      open: propOpen,",
                "      options: optionsProp,",
                "      placeholder,",
                "      plain,",
                "      replace,",
                "      searchPlaceholder,",
                "      selected,",
                "      size,",
                "      value: valueProp,",
                "      valueKey: valueKeyProp,",
                "      valueLabel,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const theme = useContext(ThemeContext) || defaultProps.theme;",
                "    const inputRef = useRef();",
                "    const formContext = useContext(FormContext);",
                "    const { format } = useContext(MessageContext);",
                "    // For greater resilience, use labelKey if valueKey isn't provided and",
                "    // vice versa. https://github.com/grommet/grommet/pull/6299",
                "    const valueKey = valueKeyProp || labelKeyProp;",
                "    const labelKey = labelKeyProp || valueKeyProp;",
                "",
                "    // Determine if the Select is opened with the keyboard. If so,",
                "    // focus should be set on the first option when the drop opens",
                "    // see set initial focus code in SelectContainer.js",
                "    const usingKeyboard = useKeyboard();",
                "",
                "    // value is used for what we receive in valueProp and the basis for",
                "    // what we send with onChange",
                "    // When 'valueKey' sets 'reduce', the value(s) here should match",
                "    // what the 'valueKey' would return for the corresponding",
                "    // selected option object.",
                "    // Otherwise, the value(s) should match the selected options.",
                "",
                "    const [value, setValue] = formContext.useFormInput({",
                "      name,",
                "      value: valueProp,",
                "      initialValue: defaultValue || '',",
                "    });",
                "",
                "    // normalizedValue is the value mapped with any valueKey applied",
                "    // When the options array contains objects, this property indicates how",
                "    // to retrieve the value of each option.",
                "    // If a string is provided, it is used as the key to retrieve a",
                "    // property of an option object.",
                "    // If a function is provided, it is called with the option and should",
                "    // return the value.",
                "    // If reduce is true, this value will be used for the 'value'",
                "    // delivered via 'onChange'.",
                "    const normalizedValue = useMemo(",
                "      () => getNormalizedValue(value, valueKey),",
                "      [value, valueKey],",
                "    );",
                "    // search input value",
                "    const [search, setSearch] = useState();",
                "    // All select option indices and values",
                "    const [allOptions, setAllOptions] = useState(optionsProp);",
                "    // Track changes to options property, except when options are being",
                "    // updated due to search activity. Allows option's initial index value",
                "    // to be referenced when filtered by search.",
                "    useEffect(() => {",
                "      if (!search) setAllOptions(optionsProp);",
                "    }, [optionsProp, search]);",
                "",
                "    // the option indexes present in the value",
                "    const optionIndexesInValue = useMemo(() => {",
                "      const result = [];",
                "      allOptions.forEach((option, index) => {",
                "        if (selected !== undefined) {",
                "          if (Array.isArray(selected)) {",
                "            if (selected.indexOf(index) !== -1) result.push(index);",
                "          } else if (index === selected) {",
                "            result.push(index);",
                "          }",
                "        } else if (Array.isArray(normalizedValue)) {",
                "          if (normalizedValue.some((v) => v === applyKey(option, valueKey))) {",
                "            result.push(index);",
                "          }",
                "        } else if (normalizedValue === applyKey(option, valueKey)) {",
                "          result.push(index);",
                "        }",
                "      });",
                "      return result;",
                "    }, [allOptions, selected, valueKey, normalizedValue]);",
                "",
                "    const [open, setOpen] = useState(propOpen);",
                "    useEffect(() => setOpen(propOpen), [propOpen]);",
                "",
                "    const onRequestOpen = useCallback(() => {",
                "      if (open) return;",
                "      setOpen(true);",
                "      if (onOpen) onOpen();",
                "    }, [onOpen, open]);",
                "",
                "    const onRequestClose = useCallback(() => {",
                "      setOpen(false);",
                "      if (onClose) onClose();",
                "      setSearch();",
                "    }, [onClose]);",
                "",
                "    const triggerChangeEvent = useCallback(",
                "      (nextValue) => changeEvent(inputRef, nextValue),",
                "      [],",
                "    );",
                "",
                "    const onSelectChange = useCallback(",
                "      (event, { option, value: nextValue, selected: nextSelected }) => {",
                "        if (closeOnChange) onRequestClose();",
                "        // nextValue must not be of type object to set value directly on the",
                "        // input. if it is an object, then the user has not provided necessary",
                "        // props to reduce object option",
                "        if (",
                "          (typeof nextValue !== 'object' || multiple) &&",
                "          nextValue !== event.target.value &&",
                "          inputRef.current",
                "        ) {",
                "          // select registers changing option as a click event or keydown.",
                "          // when in a form, we need to programatically trigger a change",
                "          // event in order for the change event to be registered upstream",
                "          // necessary for change validation in form",
                "          triggerChangeEvent(nextValue);",
                "        }",
                "        setValue(nextValue);",
                "        if (onChange) {",
                "          event.persist();",
                "          let adjustedEvent;",
                "          // support for native event used by Preact",
                "          if (event instanceof Event) {",
                "            adjustedEvent = new event.constructor(event.type, event);",
                "            Object.defineProperties(adjustedEvent, {",
                "              target: { value: inputRef.current },",
                "              value: { value: nextValue },",
                "              option: { value: option },",
                "              selected: { value: nextSelected },",
                "            });",
                "          } else {",
                "            adjustedEvent = event;",
                "            adjustedEvent.target = inputRef.current;",
                "            adjustedEvent.value = nextValue;",
                "            adjustedEvent.option = option;",
                "            adjustedEvent.selected = nextSelected;",
                "          }",
                "          onChange(adjustedEvent);",
                "        }",
                "      },",
                "      [",
                "        closeOnChange,",
                "        multiple,",
                "        onChange,",
                "        onRequestClose,",
                "        setValue,",
                "        triggerChangeEvent,",
                "      ],",
                "    );",
                "",
                "    const SelectIcon = getSelectIcon(icon, theme, open);",
                "",
                "    // element to show, trumps inputValue",
                "    const selectValue = useMemo(() => {",
                "      if (valueLabel instanceof Function) {",
                "        if (value) return valueLabel(value);",
                "      } else if (valueLabel) return valueLabel;",
                "      else if (React.isValidElement(value)) return value; // deprecated",
                "      return undefined;",
                "    }, [value, valueLabel]);",
                "",
                "    const displayLabelKey = useMemo(",
                "      () =>",
                "        getDisplayLabelKey(",
                "          labelKey,",
                "          allOptions,",
                "          optionIndexesInValue,",
                "          selectValue,",
                "        ),",
                "      [labelKey, allOptions, optionIndexesInValue, selectValue],",
                "    );",
                "",
                "    // text to show",
                "    // When the options array contains objects, this property indicates how",
                "    // to retrieve the value of each option.",
                "    // If a string is provided, it is used as the key to retrieve a",
                "    // property of an option object.",
                "    // If a function is provided, it is called with the option and should",
                "    // return the value.",
                "    // If reduce is true, this value will be used for the 'value'",
                "    // delivered via 'onChange'.",
                "    const inputValue = useMemo(() => {",
                "      if (!selectValue) {",
                "        if (optionIndexesInValue.length === 0) return '';",
                "        if (optionIndexesInValue.length === 1)",
                "          return applyKey(allOptions[optionIndexesInValue[0]], labelKey);",
                "        return format({ id: 'select.multiple', messages });",
                "      }",
                "      return undefined;",
                "    }, [",
                "      labelKey,",
                "      messages,",
                "      format,",
                "      optionIndexesInValue,",
                "      allOptions,",
                "      selectValue,",
                "    ]);",
                "",
                "    const iconColor = getIconColor(theme);",
                "",
                "    return (",
                "      <Keyboard onDown={onRequestOpen} onUp={onRequestOpen}>",
                "        <StyledSelectDropButton",
                "          ref={ref}",
                "          a11yTitle={`${ariaLabel || a11yTitle || placeholder || 'Open Drop'}${",
                "            value",
                "              ? format({",
                "                  id: 'select.selected',",
                "                  messages,",
                "                  values: { currentSelectedValue: value },",
                "                })",
                "              : ''",
                "          }`}",
                "          aria-expanded={Boolean(open)}",
                "          aria-haspopup=\"listbox\"",
                "          id={id}",
                "          disabled={disabled === true || undefined}",
                "          dropAlign={dropAlign}",
                "          dropTarget={dropTarget}",
                "          open={open}",
                "          alignSelf={alignSelf}",
                "          focusIndicator={focusIndicator}",
                "          onFocus={onFocus}",
                "          onBlur={onBlur}",
                "          gridArea={gridArea}",
                "          margin={margin}",
                "          onOpen={onRequestOpen}",
                "          onClose={onRequestClose}",
                "          onClick={onClick}",
                "          dropContent={",
                "            <SelectContainer",
                "              clear={clear}",
                "              disabled={disabled}",
                "              disabledKey={disabledKey}",
                "              dropHeight={dropHeight}",
                "              emptySearchMessage={emptySearchMessage}",
                "              id={id}",
                "              labelKey={labelKey}",
                "              multiple={multiple}",
                "              name={name}",
                "              onChange={onSelectChange}",
                "              onKeyDown={onKeyDown}",
                "              onMore={onMore}",
                "              onSearch={onSearch}",
                "              options={optionsProp}",
                "              allOptions={allOptions}",
                "              optionIndexesInValue={optionIndexesInValue}",
                "              replace={replace}",
                "              searchPlaceholder={searchPlaceholder}",
                "              search={search}",
                "              setSearch={setSearch}",
                "              selected={selected}",
                "              usingKeyboard={usingKeyboard}",
                "              value={value}",
                "              valueKey={valueKey}",
                "            >",
                "              {children}",
                "            </SelectContainer>",
                "          }",
                "          // StyledDropButton needs to know if the border should be shown",
                "          plainSelect={plain}",
                "          plain // Button should be plain",
                "          dropProps={dropProps}",
                "          theme={theme}",
                "        >",
                "          <Box",
                "            align=\"center\"",
                "            direction=\"row\"",
                "            justify=\"between\"",
                "            background={theme.select.background}",
                "          >",
                "            <Box direction=\"row\" flex basis=\"auto\">",
                "              {selectValue || displayLabelKey ? (",
                "                <>",
                "                  {selectValue || displayLabelKey}",
                "                  <HiddenInput",
                "                    type=\"text\"",
                "                    name={name}",
                "                    id={id ? `${id}__input` : undefined}",
                "                    value={inputValue}",
                "                    ref={inputRef}",
                "                    readOnly",
                "                  />",
                "                </>",
                "              ) : (",
                "                <DefaultSelectTextInput",
                "                  a11yTitle={",
                "                    (ariaLabel || a11yTitle) &&",
                "                    `${ariaLabel || a11yTitle}${",
                "                      value && typeof value === 'string' ? `, ${value}` : ''",
                "                    }`",
                "                  }",
                "                  disabled={disabled}",
                "                  id={id}",
                "                  name={name}",
                "                  ref={inputRef}",
                "                  placeholder={placeholder}",
                "                  value={inputValue}",
                "                  size={size}",
                "                  theme={theme}",
                "                  {...rest}",
                "                />",
                "              )}",
                "            </Box>",
                "            {SelectIcon && (",
                "              <Box",
                "                margin={theme.select.icons.margin}",
                "                flex={false}",
                "                style={{ minWidth: 'auto' }}",
                "              >",
                "                {isValidElement(SelectIcon) ? (",
                "                  SelectIcon",
                "                ) : (",
                "                  <SelectIcon color={iconColor} size={size} />",
                "                )}",
                "              </Box>",
                "            )}",
                "          </Box>",
                "        </StyledSelectDropButton>",
                "      </Keyboard>",
                "    );",
                "  },",
                ");",
                "",
                "Select.defaultProps = { ...defaultProps };",
                "",
                "Select.displayName = 'Select';",
                "Select.propTypes = SelectPropTypes;",
                "",
                "export { Select };"
            ]
        },
        "4": {
            "class_name": "GroupedBody (not found) ",
            "file_path": "src/js/components/DataTable/GroupedBody.js",
            "class_details": [
                {
                    "name": "GroupedBody",
                    "start_line": 1,
                    "end_line": 241
                }
            ],
            "class_code": [
                "import React, { forwardRef, useMemo } from 'react';",
                "",
                "import { Cell } from './Cell';",
                "import { ExpanderCell } from './ExpanderCell';",
                "import { StyledDataTableBody, StyledDataTableRow } from './StyledDataTable';",
                "import { CheckBox } from '../CheckBox/CheckBox';",
                "import { InfiniteScroll } from '../InfiniteScroll';",
                "import { TableRow } from '../TableRow';",
                "import { TableCell } from '../TableCell';",
                "import { datumValue, normalizeRowCellProps } from './buildState';",
                "",
                "export const GroupedBody = forwardRef(",
                "  (",
                "    {",
                "      cellProps: cellPropsProp,",
                "      columns,",
                "      data,",
                "      disabled,",
                "      groupBy,",
                "      groups,",
                "      groupState,",
                "      pinnedOffset,",
                "      primaryProperty,",
                "      onMore,",
                "      onSelect,",
                "      onToggle,",
                "      onUpdate,",
                "      replace,",
                "      rowProps,",
                "      selected,",
                "      size,",
                "      step,",
                "      verticalAlign,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const items = useMemo(() => {",
                "      const nextItems = [];",
                "      groups.forEach((group) => {",
                "        const { expanded } = groupState[group.key] || { expanded: true };",
                "        const memberCount = group.data.length;",
                "        let groupSelected = [];",
                "        let isGroupSelected = false;",
                "        let groupDisabled = [];",
                "        let isGroupDisabled = false;",
                "",
                "        if (memberCount > 1 || (onUpdate && group.key)) {",
                "          // need a header",
                "          const primaryKeys = group.data.map((datum) => datum[primaryProperty]);",
                "",
                "          groupSelected =",
                "            primaryKeys && selected",
                "              ? primaryKeys.filter((val) => selected.includes(val))",
                "              : [];",
                "",
                "          isGroupSelected = groupBy.select",
                "            ? groupBy.select[group.key] === 'all'",
                "            : groupSelected.length === group.data.length &&",
                "              groupSelected.length > 0;",
                "",
                "          const indeterminate = groupBy.select",
                "            ? groupBy.select[group.key] === 'some'",
                "            : groupSelected.length > 0 &&",
                "              groupSelected.length < group.data.length;",
                "",
                "          groupDisabled =",
                "            primaryKeys && disabled",
                "              ? primaryKeys.filter((val) => disabled.includes(val))",
                "              : [];",
                "",
                "          isGroupDisabled = groupBy.disable",
                "            ? groupBy.disable[group.key] === 'all'",
                "            : groupDisabled.length === group.data.length &&",
                "              groupDisabled.length > 0;",
                "",
                "          nextItems.push({",
                "            expanded,",
                "            key: group.key,",
                "            primaryValue: group.key,",
                "            datum: group.datum,",
                "            context: 'groupHeader',",
                "            isDisabled: isGroupDisabled,",
                "            isSelected: isGroupSelected,",
                "            indeterminate,",
                "            onChange: () => {",
                "              const nextSelected =",
                "                isGroupSelected || indeterminate",
                "                  ? selected.filter((s) => !groupSelected.includes(s))",
                "                  : [...selected, ...primaryKeys];",
                "              if (groupBy.onSelect) {",
                "                groupBy.onSelect(nextSelected, group.datum, groupBy.select);",
                "              } else {",
                "                onSelect(nextSelected, group.datum);",
                "              }",
                "            },",
                "          });",
                "        }",
                "        if ((!onUpdate && memberCount === 1) || expanded) {",
                "          // add the group members",
                "          group.data.forEach((datum, index) => {",
                "            const primaryValue = primaryProperty",
                "              ? datumValue(datum, primaryProperty)",
                "              : undefined;",
                "            const isSelected = selected?.includes(primaryValue);",
                "            const isDisabled = disabled?.includes(primaryValue);",
                "            nextItems.push({",
                "              key: datum[primaryProperty],",
                "              primaryValue: primaryProperty",
                "                ? datumValue(datum, primaryProperty)",
                "                : undefined,",
                "              datum,",
                "              context:",
                "                memberCount > 1 && index === memberCount - 1",
                "                  ? 'groupEnd'",
                "                  : 'body',",
                "              isDisabled,",
                "              isSelected,",
                "              onChange: () => {",
                "                const nextSelected = isSelected",
                "                  ? selected.filter((s) => s !== primaryValue)",
                "                  : [...selected, primaryValue];",
                "                onSelect(nextSelected, datum);",
                "              },",
                "            });",
                "          });",
                "        }",
                "      });",
                "      return nextItems;",
                "    }, [",
                "      disabled,",
                "      groups,",
                "      groupBy,",
                "      groupState,",
                "      primaryProperty,",
                "      selected,",
                "      onSelect,",
                "      onUpdate,",
                "    ]);",
                "",
                "    return (",
                "      <StyledDataTableBody ref={ref} size={size} {...rest}>",
                "        <InfiniteScroll",
                "          items={items}",
                "          onMore={onMore}",
                "          replace={replace}",
                "          renderMarker={(marker) => (",
                "            <TableRow>",
                "              <TableCell>{marker}</TableCell>",
                "            </TableRow>",
                "          )}",
                "          step={step}",
                "        >",
                "          {(row, index, rowRef) => {",
                "            const {",
                "              context,",
                "              datum,",
                "              expanded,",
                "              indeterminate,",
                "              isDisabled,",
                "              isSelected,",
                "              key,",
                "              onChange,",
                "              primaryValue,",
                "            } = row;",
                "            const cellProps = normalizeRowCellProps(",
                "              rowProps,",
                "              cellPropsProp,",
                "              primaryValue,",
                "              index,",
                "            );",
                "",
                "            return (",
                "              <StyledDataTableRow ref={rowRef} key={key} size={size}>",
                "                <ExpanderCell",
                "                  background={cellProps.background}",
                "                  border={cellProps.border}",
                "                  context={context}",
                "                  pad={cellProps.pad}",
                "                  onToggle={",
                "                    context === 'groupHeader' ? onToggle(key) : undefined",
                "                  }",
                "                  expanded={expanded}",
                "                  verticalAlign={verticalAlign}",
                "                />",
                "                {(selected || onSelect) && (",
                "                  <TableCell",
                "                    background={cellProps.background}",
                "                    border={cellProps.pinned.border || cellProps.border}",
                "                    plain=\"noPad\"",
                "                    size=\"auto\"",
                "                    verticalAlign={verticalAlign}",
                "                    aria-disabled={isDisabled || !onSelect || undefined}",
                "                  >",
                "                    <CheckBox",
                "                      a11yTitle={`${isSelected ? 'unselect' : 'select'} ${",
                "                        context === 'groupHeader' ? key : primaryValue",
                "                      }`}",
                "                      checked={isSelected}",
                "                      indeterminate={indeterminate}",
                "                      disabled={isDisabled || !onSelect}",
                "                      onChange={onChange}",
                "                      pad={cellProps.pad}",
                "                    />",
                "                  </TableCell>",
                "                )}",
                "                {columns.map((column) => {",
                "                  let scope;",
                "                  if (context === 'groupHeader') {",
                "                    scope =",
                "                      column.property === groupBy.property ? 'row' : undefined;",
                "                  } else {",
                "                    scope = column.primary ? 'row' : undefined;",
                "                  }",
                "                  return (",
                "                    <Cell",
                "                      key={column.property}",
                "                      background={cellProps.background}",
                "                      border={cellProps.border}",
                "                      context={context}",
                "                      column={column}",
                "                      datum={datum}",
                "                      pad={cellProps.pad}",
                "                      scope={scope}",
                "                      pinnedOffset={",
                "                        context === 'groupHeader' &&",
                "                        pinnedOffset &&",
                "                        pinnedOffset[column.property]",
                "                      }",
                "                      verticalAlign={verticalAlign}",
                "                    />",
                "                  );",
                "                })}",
                "              </StyledDataTableRow>",
                "            );",
                "          }}",
                "        </InfiniteScroll>",
                "      </StyledDataTableBody>",
                "    );",
                "  },",
                ");"
            ]
        },
        "5": {
            "class_name": "Select (not found) ",
            "file_path": "src/js/components/Select/Select.js",
            "class_details": [
                {
                    "name": "Select",
                    "start_line": 1,
                    "end_line": 410
                }
            ],
            "class_code": [
                "import React, {",
                "  forwardRef,",
                "  isValidElement,",
                "  useCallback,",
                "  useContext,",
                "  useMemo,",
                "  useState,",
                "  useRef,",
                "  useEffect,",
                "} from 'react';",
                "import { ThemeContext } from 'styled-components';",
                "",
                "import { useKeyboard } from '../../utils';",
                "import { defaultProps } from '../../default-props';",
                "",
                "import { Box } from '../Box';",
                "import { Keyboard } from '../Keyboard';",
                "import { FormContext } from '../Form/FormContext';",
                "",
                "import { SelectContainer } from './SelectContainer';",
                "import { HiddenInput, StyledSelectDropButton } from './StyledSelect';",
                "import {",
                "  applyKey,",
                "  getNormalizedValue,",
                "  changeEvent,",
                "  getSelectIcon,",
                "  getDisplayLabelKey,",
                "  getIconColor,",
                "} from './utils';",
                "import { DefaultSelectTextInput } from './DefaultSelectTextInput';",
                "import { MessageContext } from '../../contexts/MessageContext';",
                "import { SelectPropTypes } from './propTypes';",
                "",
                "StyledSelectDropButton.defaultProps = {};",
                "Object.setPrototypeOf(StyledSelectDropButton.defaultProps, defaultProps);",
                "",
                "const defaultDropAlign = { top: 'bottom', left: 'left' };",
                "",
                "const Select = forwardRef(",
                "  (",
                "    {",
                "      a11yTitle,",
                "      'aria-label': ariaLabel,",
                "      alignSelf,",
                "      children,",
                "      clear = false,",
                "      closeOnChange = true,",
                "      defaultValue,",
                "      disabled,",
                "      disabledKey,",
                "      dropAlign = defaultDropAlign,",
                "      dropHeight,",
                "      dropProps,",
                "      dropTarget,",
                "      emptySearchMessage,",
                "      focusIndicator,",
                "      gridArea,",
                "      id,",
                "      icon,",
                "      labelKey: labelKeyProp,",
                "      margin,",
                "      messages,",
                "      multiple,",
                "      name,",
                "      onBlur,",
                "      onChange,",
                "      onClick,",
                "      onClose,",
                "      onFocus,",
                "      onKeyDown,",
                "      onMore,",
                "      onOpen,",
                "      onSearch,",
                "      open: propOpen,",
                "      options: optionsProp,",
                "      placeholder,",
                "      plain,",
                "      replace,",
                "      searchPlaceholder,",
                "      selected,",
                "      size,",
                "      value: valueProp,",
                "      valueKey: valueKeyProp,",
                "      valueLabel,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const theme = useContext(ThemeContext) || defaultProps.theme;",
                "    const inputRef = useRef();",
                "    const formContext = useContext(FormContext);",
                "    const { format } = useContext(MessageContext);",
                "    // For greater resilience, use labelKey if valueKey isn't provided and",
                "    // vice versa. https://github.com/grommet/grommet/pull/6299",
                "    const valueKey = valueKeyProp || labelKeyProp;",
                "    const labelKey = labelKeyProp || valueKeyProp;",
                "",
                "    // Determine if the Select is opened with the keyboard. If so,",
                "    // focus should be set on the first option when the drop opens",
                "    // see set initial focus code in SelectContainer.js",
                "    const usingKeyboard = useKeyboard();",
                "",
                "    // value is used for what we receive in valueProp and the basis for",
                "    // what we send with onChange",
                "    // When 'valueKey' sets 'reduce', the value(s) here should match",
                "    // what the 'valueKey' would return for the corresponding",
                "    // selected option object.",
                "    // Otherwise, the value(s) should match the selected options.",
                "",
                "    const [value, setValue] = formContext.useFormInput({",
                "      name,",
                "      value: valueProp,",
                "      initialValue: defaultValue || '',",
                "    });",
                "",
                "    // normalizedValue is the value mapped with any valueKey applied",
                "    // When the options array contains objects, this property indicates how",
                "    // to retrieve the value of each option.",
                "    // If a string is provided, it is used as the key to retrieve a",
                "    // property of an option object.",
                "    // If a function is provided, it is called with the option and should",
                "    // return the value.",
                "    // If reduce is true, this value will be used for the 'value'",
                "    // delivered via 'onChange'.",
                "    const normalizedValue = useMemo(",
                "      () => getNormalizedValue(value, valueKey),",
                "      [value, valueKey],",
                "    );",
                "    // search input value",
                "    const [search, setSearch] = useState();",
                "    // All select option indices and values",
                "    const [allOptions, setAllOptions] = useState(optionsProp);",
                "    // Track changes to options property, except when options are being",
                "    // updated due to search activity. Allows option's initial index value",
                "    // to be referenced when filtered by search.",
                "    useEffect(() => {",
                "      if (!search) setAllOptions(optionsProp);",
                "    }, [optionsProp, search]);",
                "",
                "    // the option indexes present in the value",
                "    const optionIndexesInValue = useMemo(() => {",
                "      const result = [];",
                "      allOptions.forEach((option, index) => {",
                "        if (selected !== undefined) {",
                "          if (Array.isArray(selected)) {",
                "            if (selected.indexOf(index) !== -1) result.push(index);",
                "          } else if (index === selected) {",
                "            result.push(index);",
                "          }",
                "        } else if (Array.isArray(normalizedValue)) {",
                "          if (normalizedValue.some((v) => v === applyKey(option, valueKey))) {",
                "            result.push(index);",
                "          }",
                "        } else if (normalizedValue === applyKey(option, valueKey)) {",
                "          result.push(index);",
                "        }",
                "      });",
                "      return result;",
                "    }, [allOptions, selected, valueKey, normalizedValue]);",
                "",
                "    const [open, setOpen] = useState(propOpen);",
                "    useEffect(() => setOpen(propOpen), [propOpen]);",
                "",
                "    const onRequestOpen = useCallback(() => {",
                "      if (open) return;",
                "      setOpen(true);",
                "      if (onOpen) onOpen();",
                "    }, [onOpen, open]);",
                "",
                "    const onRequestClose = useCallback(() => {",
                "      setOpen(false);",
                "      if (onClose) onClose();",
                "      setSearch();",
                "    }, [onClose]);",
                "",
                "    const triggerChangeEvent = useCallback(",
                "      (nextValue) => changeEvent(inputRef, nextValue),",
                "      [],",
                "    );",
                "",
                "    const onSelectChange = useCallback(",
                "      (event, { option, value: nextValue, selected: nextSelected }) => {",
                "        if (closeOnChange) onRequestClose();",
                "        // nextValue must not be of type object to set value directly on the",
                "        // input. if it is an object, then the user has not provided necessary",
                "        // props to reduce object option",
                "        if (",
                "          (typeof nextValue !== 'object' || multiple) &&",
                "          nextValue !== event.target.value &&",
                "          inputRef.current",
                "        ) {",
                "          // select registers changing option as a click event or keydown.",
                "          // when in a form, we need to programatically trigger a change",
                "          // event in order for the change event to be registered upstream",
                "          // necessary for change validation in form",
                "          triggerChangeEvent(nextValue);",
                "        }",
                "        setValue(nextValue);",
                "        if (onChange) {",
                "          event.persist();",
                "          let adjustedEvent;",
                "          // support for native event used by Preact",
                "          if (event instanceof Event) {",
                "            adjustedEvent = new event.constructor(event.type, event);",
                "            Object.defineProperties(adjustedEvent, {",
                "              target: { value: inputRef.current },",
                "              value: { value: nextValue },",
                "              option: { value: option },",
                "              selected: { value: nextSelected },",
                "            });",
                "          } else {",
                "            adjustedEvent = event;",
                "            adjustedEvent.target = inputRef.current;",
                "            adjustedEvent.value = nextValue;",
                "            adjustedEvent.option = option;",
                "            adjustedEvent.selected = nextSelected;",
                "          }",
                "          onChange(adjustedEvent);",
                "        }",
                "      },",
                "      [",
                "        closeOnChange,",
                "        multiple,",
                "        onChange,",
                "        onRequestClose,",
                "        setValue,",
                "        triggerChangeEvent,",
                "      ],",
                "    );",
                "",
                "    const SelectIcon = getSelectIcon(icon, theme, open);",
                "",
                "    // element to show, trumps inputValue",
                "    const selectValue = useMemo(() => {",
                "      if (valueLabel instanceof Function) {",
                "        if (value) return valueLabel(value);",
                "      } else if (valueLabel) return valueLabel;",
                "      else if (React.isValidElement(value)) return value; // deprecated",
                "      return undefined;",
                "    }, [value, valueLabel]);",
                "",
                "    const displayLabelKey = useMemo(",
                "      () =>",
                "        getDisplayLabelKey(",
                "          labelKey,",
                "          allOptions,",
                "          optionIndexesInValue,",
                "          selectValue,",
                "        ),",
                "      [labelKey, allOptions, optionIndexesInValue, selectValue],",
                "    );",
                "",
                "    // text to show",
                "    // When the options array contains objects, this property indicates how",
                "    // to retrieve the value of each option.",
                "    // If a string is provided, it is used as the key to retrieve a",
                "    // property of an option object.",
                "    // If a function is provided, it is called with the option and should",
                "    // return the value.",
                "    // If reduce is true, this value will be used for the 'value'",
                "    // delivered via 'onChange'.",
                "    const inputValue = useMemo(() => {",
                "      if (!selectValue) {",
                "        if (optionIndexesInValue.length === 0) return '';",
                "        if (optionIndexesInValue.length === 1)",
                "          return applyKey(allOptions[optionIndexesInValue[0]], labelKey);",
                "        return format({ id: 'select.multiple', messages });",
                "      }",
                "      return undefined;",
                "    }, [",
                "      labelKey,",
                "      messages,",
                "      format,",
                "      optionIndexesInValue,",
                "      allOptions,",
                "      selectValue,",
                "    ]);",
                "",
                "    const iconColor = getIconColor(theme);",
                "",
                "    return (",
                "      <Keyboard onDown={onRequestOpen} onUp={onRequestOpen}>",
                "        <StyledSelectDropButton",
                "          ref={ref}",
                "          a11yTitle={`${ariaLabel || a11yTitle || placeholder || 'Open Drop'}${",
                "            value",
                "              ? format({",
                "                  id: 'select.selected',",
                "                  messages,",
                "                  values: { currentSelectedValue: value },",
                "                })",
                "              : ''",
                "          }`}",
                "          aria-expanded={Boolean(open)}",
                "          aria-haspopup=\"listbox\"",
                "          id={id}",
                "          disabled={disabled === true || undefined}",
                "          dropAlign={dropAlign}",
                "          dropTarget={dropTarget}",
                "          open={open}",
                "          alignSelf={alignSelf}",
                "          focusIndicator={focusIndicator}",
                "          onFocus={onFocus}",
                "          onBlur={onBlur}",
                "          gridArea={gridArea}",
                "          margin={margin}",
                "          onOpen={onRequestOpen}",
                "          onClose={onRequestClose}",
                "          onClick={onClick}",
                "          dropContent={",
                "            <SelectContainer",
                "              clear={clear}",
                "              disabled={disabled}",
                "              disabledKey={disabledKey}",
                "              dropHeight={dropHeight}",
                "              emptySearchMessage={emptySearchMessage}",
                "              id={id}",
                "              labelKey={labelKey}",
                "              multiple={multiple}",
                "              name={name}",
                "              onChange={onSelectChange}",
                "              onKeyDown={onKeyDown}",
                "              onMore={onMore}",
                "              onSearch={onSearch}",
                "              options={optionsProp}",
                "              allOptions={allOptions}",
                "              optionIndexesInValue={optionIndexesInValue}",
                "              replace={replace}",
                "              searchPlaceholder={searchPlaceholder}",
                "              search={search}",
                "              setSearch={setSearch}",
                "              selected={selected}",
                "              usingKeyboard={usingKeyboard}",
                "              value={value}",
                "              valueKey={valueKey}",
                "            >",
                "              {children}",
                "            </SelectContainer>",
                "          }",
                "          // StyledDropButton needs to know if the border should be shown",
                "          plainSelect={plain}",
                "          plain // Button should be plain",
                "          dropProps={dropProps}",
                "          theme={theme}",
                "        >",
                "          <Box",
                "            align=\"center\"",
                "            direction=\"row\"",
                "            justify=\"between\"",
                "            background={theme.select.background}",
                "          >",
                "            <Box direction=\"row\" flex basis=\"auto\">",
                "              {selectValue || displayLabelKey ? (",
                "                <>",
                "                  {selectValue || displayLabelKey}",
                "                  <HiddenInput",
                "                    type=\"text\"",
                "                    name={name}",
                "                    id={id ? `${id}__input` : undefined}",
                "                    value={inputValue}",
                "                    ref={inputRef}",
                "                    readOnly",
                "                  />",
                "                </>",
                "              ) : (",
                "                <DefaultSelectTextInput",
                "                  a11yTitle={",
                "                    (ariaLabel || a11yTitle) &&",
                "                    `${ariaLabel || a11yTitle}${",
                "                      value && typeof value === 'string' ? `, ${value}` : ''",
                "                    }`",
                "                  }",
                "                  disabled={disabled}",
                "                  id={id}",
                "                  name={name}",
                "                  ref={inputRef}",
                "                  placeholder={placeholder}",
                "                  value={inputValue}",
                "                  size={size}",
                "                  theme={theme}",
                "                  {...rest}",
                "                />",
                "              )}",
                "            </Box>",
                "            {SelectIcon && (",
                "              <Box",
                "                margin={theme.select.icons.margin}",
                "                flex={false}",
                "                style={{ minWidth: 'auto' }}",
                "              >",
                "                {isValidElement(SelectIcon) ? (",
                "                  SelectIcon",
                "                ) : (",
                "                  <SelectIcon color={iconColor} size={size} />",
                "                )}",
                "              </Box>",
                "            )}",
                "          </Box>",
                "        </StyledSelectDropButton>",
                "      </Keyboard>",
                "    );",
                "  },",
                ");",
                "",
                "Select.defaultProps = { ...defaultProps };",
                "",
                "Select.displayName = 'Select';",
                "Select.propTypes = SelectPropTypes;",
                "",
                "export { Select };"
            ]
        }
    },
    "bug_functions": {}
}