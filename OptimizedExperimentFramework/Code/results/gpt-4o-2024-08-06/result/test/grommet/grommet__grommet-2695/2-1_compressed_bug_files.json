{
    "1": {
        "bug_file": "src/js/components/Meter/Meter.js",
        "compressed": "NO",
        "line_numbers": 57,
        "compressed_line_numbers": 57,
        "compressed_bug_file_content": "import React, { Component } from 'react';\n\nimport { Bar } from './Bar';\nimport { Circle } from './Circle';\n\nconst deriveMax = values => {\n  let max = 100;\n  if (values && values.length > 1) {\n    max = 0;\n    values.forEach(v => {\n      max += v.value;\n    });\n  }\n  return max;\n};\n\nclass Meter extends Component {\n  static defaultProps = {\n    background: { color: 'light-2', opacity: 'medium' },\n    size: 'medium',\n    thickness: 'medium',\n    type: 'bar',\n  };\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const { max } = prevState;\n    const nextMax = deriveMax(nextProps.values);\n    if (!max || nextMax !== max) {\n      return { max: nextMax };\n    }\n    return null;\n  }\n\n  state = {};\n\n  render() {\n    const { type, ...rest } = this.props;\n    const { max } = this.state;\n\n    let content;\n    if (type === 'bar') {\n      content = <Bar max={max} {...rest} />;\n    } else if (type === 'circle') {\n      content = <Circle max={max} {...rest} />;\n    }\n\n    return content;\n  }\n}\n\nlet MeterDoc;\nif (process.env.NODE_ENV !== 'production') {\n  MeterDoc = require('./doc').doc(Meter); // eslint-disable-line global-require\n}\nconst MeterWrapper = MeterDoc || Meter;\n\nexport { MeterWrapper as Meter };"
    },
    "2": {
        "bug_file": "src/js/components/Meter/Circle.js",
        "compressed": "NO",
        "line_numbers": 168,
        "compressed_line_numbers": 168,
        "compressed_bug_file_content": "import React from 'react';\nimport { compose } from 'recompose';\n\nimport { withTheme } from 'styled-components';\n\nimport { defaultProps } from '../../default-props';\nimport { arcCommands, parseMetricToNum, translateEndAngle } from '../../utils';\n\nimport { StyledMeter } from './StyledMeter';\nimport { strokeProps, defaultColor } from './utils';\n\nconst Circle = props => {\n  const {\n    background,\n    max,\n    round,\n    size,\n    theme,\n    thickness,\n    values,\n    ...rest\n  } = props;\n  const width =\n    size === 'full' ? 288 : parseMetricToNum(theme.global.size[size]);\n  const height = parseMetricToNum(\n    theme.global.edgeSize[thickness] || thickness,\n  );\n  const mid = width / 2;\n  const radius = width / 2 - height / 2;\n  const anglePer = 360 / max;\n  const someHighlight = (values || []).some(v => v.highlight);\n\n  let startValue = 0;\n  let startAngle = 0;\n  const paths = [];\n  let pathCaps = [];\n  (values || [])\n    .filter(v => v.value > 0)\n    .forEach((valueArg, index) => {\n      const { color, highlight, label, onHover, value, ...pathRest } = valueArg;\n      const key = `p-${index}`;\n      const colorName =\n        color ||\n        (index === values.length - 1 ? 'accent-1' : defaultColor(index, theme));\n\n      let endAngle;\n      if (startValue + value >= max) {\n        endAngle = 360;\n      } else {\n        endAngle = Math.min(\n          360,\n          translateEndAngle(startAngle, anglePer, value),\n        );\n      }\n      let hoverProps;\n      if (onHover) {\n        hoverProps = {\n          onMouseOver: () => onHover(true),\n          onMouseLeave: () => onHover(false),\n        };\n      }\n      const stroke = strokeProps(\n        someHighlight && !highlight ? background : colorName,\n        theme,\n      );\n\n      if (round) {\n        const d1 = arcCommands(\n          width / 2,\n          width / 2,\n          radius,\n          startAngle,\n          endAngle,\n        );\n        paths.unshift(\n          <path\n            key={key}\n            d={d1}\n            fill=\"none\"\n            {...stroke}\n            strokeWidth={height}\n            strokeLinecap=\"round\"\n            {...hoverProps}\n            {...pathRest}\n          />,\n        );\n\n        // To handle situations where the last values are small, redraw\n        // a dot at the end. Give just a bit of angle to avoid anti-aliasing\n        // leakage around the edge.\n        const d2 = arcCommands(\n          width / 2,\n          width / 2,\n          radius,\n          endAngle - 0.5,\n          endAngle,\n        );\n        const pathCap = (\n          <path\n            key={`${key}-`}\n            d={d2}\n            fill=\"none\"\n            {...stroke}\n            strokeWidth={height}\n            strokeLinecap=\"round\"\n            {...hoverProps}\n            {...pathRest}\n          />\n        );\n        // If we are on a large enough path to not need re-drawing previous ones,\n        // clear the pathCaps we've collected already.\n        if (endAngle - startAngle > 2 * anglePer) {\n          pathCaps = [];\n        }\n        pathCaps.unshift(pathCap);\n      } else {\n        const d = arcCommands(\n          width / 2,\n          width / 2,\n          radius,\n          startAngle,\n          endAngle,\n        );\n        paths.push(\n          <path\n            key={key}\n            d={d}\n            fill=\"none\"\n            {...stroke}\n            strokeWidth={height}\n            strokeLinecap=\"butt\"\n            {...hoverProps}\n            {...pathRest}\n          />,\n        );\n      }\n      startValue += value;\n      startAngle = endAngle;\n    });\n\n  return (\n    <StyledMeter\n      viewBox={`0 0 ${width} ${width}`}\n      width={size === 'full' ? '100%' : width}\n      height={size === 'full' ? '100%' : width}\n      {...rest}\n    >\n      <circle\n        cx={mid}\n        cy={mid}\n        r={radius}\n        {...strokeProps(background, theme)}\n        strokeWidth={height}\n        strokeLinecap={round ? 'round' : 'square'}\n        fill=\"none\"\n      />\n      {paths}\n      {pathCaps}\n    </StyledMeter>\n  );\n};\n\nCircle.defaultProps = {};\nObject.setPrototypeOf(Circle.defaultProps, defaultProps);\n\nconst CircleWrapper = compose(withTheme)(Circle);\n\nexport { CircleWrapper as Circle };"
    },
    "3": {
        "bug_file": "src/js/components/Meter/utils.js",
        "compressed": "NO",
        "line_numbers": 29,
        "compressed_line_numbers": 29,
        "compressed_bug_file_content": "import { normalizeColor } from '../../utils';\n\nexport const strokeProps = (color, theme) => {\n  const result = {};\n  if (color) {\n    if (typeof color === 'object') {\n      result.stroke = normalizeColor(color.color, theme);\n      if (color.opacity) {\n        result.strokeOpacity = `${\n          color.opacity === true\n            ? theme.global.opacity.medium\n            : theme.global.opacity[color.opacity]\n        }`;\n      }\n    } else {\n      result.stroke = normalizeColor(color, theme);\n    }\n  }\n  return result;\n};\n\nconst neutralExp = /^neutral-\\d+/;\n\nexport const defaultColor = (index, theme) => {\n  const neutralColors = Object.keys(theme.global.colors).filter(k =>\n    neutralExp.test(k),\n  );\n  return neutralColors[index % neutralColors.length];\n};"
    },
    "4": {
        "bug_file": "src/js/components/Meter/StyledMeter.js",
        "compressed": "NO",
        "line_numbers": 27,
        "compressed_line_numbers": 27,
        "compressed_bug_file_content": "import styled, { css } from 'styled-components';\n\nimport { genericStyles } from '../../utils';\nimport { defaultProps } from '../../default-props';\n\nconst roundStyle = css`\n  border-radius: ${props => props.theme.global.edgeSize[props.round.size]};\n`;\n\n// overflow: hidden is needed for ie11\nconst StyledMeter = styled.svg`\n  max-width: 100%;\n  overflow: hidden;\n\n  ${genericStyles} ${props => props.round && roundStyle}\n\n  path {\n    transition: all 0.3s;\n  }\n\n  ${props => props.theme.meter && props.theme.meter.extend};\n`;\n\nStyledMeter.defaultProps = {};\nObject.setPrototypeOf(StyledMeter.defaultProps, defaultProps);\n\nexport { StyledMeter };"
    }
}