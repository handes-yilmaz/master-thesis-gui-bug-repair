{
    "1/1": {
        "src/js/components/DataChart/DataChart.js": [
            {
                "SEARCH": [
                    "let chartBounds = chartValues.map((_, index) => {",
                    "const { type } = charts[index];",
                    "if (stackedChartType[type]) {",
                    "// merge values for bars, areas, and lines cases",
                    "let mergedValues = chartValues[index]?.[0]?.slice(0) || [];",
                    "chartValues[index]",
                    ".slice(1) // skip first index as that is the x value",
                    ".filter((values) => values) // property name isn't valid",
                    ".forEach((values) => {",
                    "mergedValues = mergedValues.map((__, i) =>",
                    "type === 'lines'",
                    "? [",
                    "i,",
                    "Math.min(mergedValues[i][1], values[i][1]),",
                    "Math.max(mergedValues[i][1], values[i][1]),",
                    "]",
                    ": [",
                    "i,",
                    "Math.min(mergedValues[i][1], values[i][1]),",
                    "Math.max(mergedValues[i][2], values[i][2]),",
                    "],",
                    ");",
                    "});",
                    "return calcBounds(mergedValues, { coarseness, steps });",
                    "}",
                    "// if this is a data driven x chart, set coarseness for x",
                    "return calcBounds(chartValues[index], {",
                    "coarseness: charts[index].property.x ? [5, 5] : coarseness,",
                    "steps,",
                    "});",
                    "});"
                ],
                "REPLACE": [
                    "      let chartBounds = chartValues.map((_, index) => {",
                    "        const { type } = charts[index];",
                    "        if (stackedChartType[type]) {",
                    "          // merge values for bars, areas, and lines cases",
                    "          let mergedValues = chartValues[index]?.[0]?.slice(0) || [];",
                    "          chartValues[index]",
                    "            .slice(1) // skip first index as that is the x value",
                    "            .filter((values) => values) // property name isn't valid",
                    "            .forEach((values) => {",
                    "              mergedValues = mergedValues.map((__, i) =>",
                    "                type === 'lines'",
                    "                  ? [",
                    "                      i,",
                    "                      Math.min(mergedValues[i][1], values[i][1]),",
                    "                      Math.max(mergedValues[i][1], values[i][1]),",
                    "                    ]",
                    "                  : [",
                    "                      i,",
                    "                      Math.min(mergedValues[i][1], values[i][1]),",
                    "                      Math.max(mergedValues[i][2], values[i][2]),",
                    "                    ],",
                    "              );",
                    "            });",
                    "          return calcBounds(mergedValues, { coarseness, steps });",
                    "        }",
                    "        // if this is a data driven x chart, set coarseness for x",
                    "        return calcBounds(chartValues[index], {",
                    "          coarseness: charts[index].property.x ? [5, 5] : coarseness,",
                    "          steps,",
                    "        });",
                    "      });",
                    "",
                    "      // Ensure bounds include zero for negative values",
                    "      chartBounds = chartBounds.map(bounds => {",
                    "        bounds[1][0] = Math.min(bounds[1][0], 0);",
                    "        return bounds;",
                    "      });"
                ]
            }
        ]
    }
}