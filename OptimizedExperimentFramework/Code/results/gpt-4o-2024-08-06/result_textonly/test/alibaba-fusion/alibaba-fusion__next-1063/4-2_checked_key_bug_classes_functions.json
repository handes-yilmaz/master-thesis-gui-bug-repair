{
    "bug_classes": {
        "1": {
            "class_name": "Field (not found) 21-521",
            "file_path": "src/field/index.js",
            "class_details": [
                {
                    "name": "Field",
                    "start_line": 21,
                    "end_line": 521
                }
            ],
            "class_code": [
                "class Field {",
                "    constructor(com, options = {}) {",
                "        if (!com) {",
                "            log.warning(",
                "                '`this` is missing in `Field`, you should use like `new Field(this)`'",
                "            );",
                "        }",
                "",
                "        this.com = com;",
                "        this.fieldsMeta = {};",
                "        this.cachedBind = {};",
                "        this.instance = {};",
                "        // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.",
                "        // Also used caching values when using `parseName: true` before a field is initialized",
                "        this.values = options.values || {};",
                "",
                "        this.options = Object.assign(",
                "            {",
                "                parseName: false,",
                "                forceUpdate: false,",
                "                scrollToFirstError: true,",
                "                first: false,",
                "                onChange: func.noop,",
                "                autoUnmount: true,",
                "                autoValidate: true,",
                "            },",
                "            options",
                "        );",
                "",
                "        [",
                "            'init',",
                "            'getValue',",
                "            'getValues',",
                "            'setValue',",
                "            'setValues',",
                "            'getError',",
                "            'getErrors',",
                "            'setError',",
                "            'setErrors',",
                "            'validate',",
                "            'getState',",
                "            'reset',",
                "            'resetToDefault',",
                "            'remove',",
                "            'spliceArray',",
                "        ].forEach(m => {",
                "            this[m] = this[m].bind(this);",
                "        });",
                "",
                "        if (options.values) {",
                "            this.setValues(options.values, false);",
                "        }",
                "    }",
                "",
                "    setOptions(options) {",
                "        Object.assign(this.options, options);",
                "    }",
                "",
                "    /**",
                "     * Controlled Component",
                "     * @param {String} name",
                "     * @param {Object} fieldOption",
                "     * @returns {Object} {value, onChange}",
                "     */",
                "    init(name, fieldOption = {}, rprops) {",
                "        const {",
                "            initValue,",
                "            valueName = 'value',",
                "            trigger = 'onChange',",
                "            rules = [],",
                "            props = {},",
                "            getValueFromEvent = null,",
                "            autoValidate = true,",
                "        } = fieldOption;",
                "        const { parseName } = this.options;",
                "",
                "        const originalProps = Object.assign({}, props, rprops);",
                "        const defaultValueName = `default${valueName[0].toUpperCase()}${valueName.slice(",
                "            1",
                "        )}`;",
                "",
                "        const field = this._getInitMeta(name);",
                "        let defaultValue;",
                "        if (typeof initValue !== 'undefined') {",
                "            defaultValue = initValue;",
                "        } else if (typeof originalProps[defaultValueName] !== 'undefined') {",
                "            // here use typeof, in case of defaultValue={0}",
                "            defaultValue = originalProps[defaultValueName];",
                "        }",
                "",
                "        Object.assign(field, {",
                "            valueName,",
                "            initValue: defaultValue,",
                "            disabled:",
                "                'disabled' in originalProps ? originalProps.disabled : false,",
                "            getValueFromEvent,",
                "            rules: Array.isArray(rules) ? rules : [rules],",
                "            ref: originalProps.ref,",
                "        });",
                "",
                "        // Controlled Component, should alwasy equal props.value",
                "        if (valueName in originalProps) {",
                "            field.value = originalProps[valueName];",
                "",
                "            // When rerendering set the values from props.value",
                "            if (parseName) {",
                "                this.values = setIn(this.values, name, field.value);",
                "            } else {",
                "                this.values[name] = field.value;",
                "            }",
                "        }",
                "",
                "        // should get value from this.values",
                "        /**",
                "         * a new field (value not in field)",
                "         * step 1: get value from this.values",
                "         * step 2: from defaultValue",
                "         */",
                "        if (!('value' in field)) {",
                "            if (parseName) {",
                "                const cachedValue = getIn(this.values, name);",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            } else {",
                "                const cachedValue = this.values[name];",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            }",
                "        }",
                "",
                "        if (parseName && !getIn(this.values, name)) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else if (!parseName && !this.values[name]) {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        // Component props",
                "        const inputProps = {",
                "            'data-meta': 'Field',",
                "            id: name,",
                "            ref: this._getCacheBind(name, `${name}__ref`, this._saveRef),",
                "            [valueName]: field.value,",
                "        };",
                "",
                "        let rulesMap = {};",
                "",
                "        if (this.options.autoValidate && autoValidate !== false) {",
                "            // trigger map",
                "            rulesMap = mapValidateRules(field.rules, trigger);",
                "",
                "            // validate hook",
                "            for (const action in rulesMap) {",
                "                if (action === trigger) {",
                "                    continue;",
                "                }",
                "",
                "                const actionRule = rulesMap[action];",
                "                inputProps[action] = (...args) => {",
                "                    this._validate(name, actionRule, action);",
                "                    this._callPropsEvent(action, originalProps, ...args);",
                "                    this._reRender();",
                "                };",
                "            }",
                "        }",
                "",
                "        // onChange hack",
                "        inputProps[trigger] = (...args) => {",
                "            this._callOnChange(name, rulesMap[trigger], trigger, ...args);",
                "            this._callPropsEvent(trigger, originalProps, ...args);",
                "            this.options.onChange(name, field.value);",
                "            this._reRender();",
                "        };",
                "",
                "        delete originalProps[defaultValueName];",
                "",
                "        return Object.assign({}, originalProps, inputProps);",
                "    }",
                "",
                "    /**",
                "     * event on props",
                "     * props.onChange props.onBlur",
                "     */",
                "    _callPropsEvent(action, props, ...args) {",
                "        action in props &&",
                "            typeof props[action] === 'function' &&",
                "            props[action](...args);",
                "    }",
                "",
                "    _getInitMeta(name) {",
                "        if (!(name in this.fieldsMeta)) {",
                "            this.fieldsMeta[name] = Object.assign({}, initMeta);",
                "        }",
                "",
                "        return this.fieldsMeta[name];",
                "    }",
                "",
                "    /**",
                "     * update field.value and validate",
                "     */",
                "    _callOnChange(name, rule, trigger, ...others) {",
                "        const e = others[0];",
                "        const field = this._get(name);",
                "",
                "        if (!field) {",
                "            return;",
                "        }",
                "",
                "        field.value = field.getValueFromEvent",
                "            ? field.getValueFromEvent.apply(this, others)",
                "            : getValueFromEvent(e);",
                "",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        this._resetError(name);",
                "",
                "        // validate while onChange",
                "        rule && this._validate(name, rule, trigger);",
                "    }",
                "",
                "    /**",
                "     * ref must always be the same function, or if not it will be triggerd every time.",
                "     * @param {String} name name of component",
                "     * @param {String} action key to find ref",
                "     * @param {Function} fn saveRef",
                "     */",
                "    _getCacheBind(name, action, fn) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        if (!cache[action]) {",
                "            cache[action] = fn.bind(this, name);",
                "        }",
                "        return cache[action];",
                "    }",
                "",
                "    _setCache(name, action, hander) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        cache[action] = hander;",
                "    }",
                "",
                "    _getCache(name, action) {",
                "        const cache = this.cachedBind[name] || {};",
                "        return cache[action];",
                "    }",
                "",
                "    /**",
                "     * NOTE: saveRef is async function. it will be called after render",
                "     * @param {String} name name of component",
                "     * @param {Function} component ref",
                "     */",
                "    _saveRef(name, component) {",
                "        const key = `${name}_field`;",
                "        const autoUnmount = this.options.autoUnmount;",
                "",
                "        if (!component && autoUnmount) {",
                "            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)",
                "            // while type changed, B will render before A unmount. so we should cached value for B",
                "            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render",
                "            // 1. _saveRef(A, null)",
                "            const cache = this.fieldsMeta[name];",
                "            this._setCache(name, key, cache);",
                "            // after destroy, delete data",
                "            delete this.instance[name];",
                "            this.remove(name);",
                "            return;",
                "        }",
                "",
                "        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)",
                "        if (autoUnmount && !this.fieldsMeta[name]) {",
                "            this.fieldsMeta[name] = this._getCache(name, key);",
                "            this.setValue(",
                "                name,",
                "                this.fieldsMeta[name] && this.fieldsMeta[name].value,",
                "                false",
                "            );",
                "        }",
                "",
                "        // only one time here",
                "        const field = this._get(name);",
                "        if (field) {",
                "            const ref = field.ref;",
                "            if (ref) {",
                "                if (typeof ref === 'string') {",
                "                    throw new Error(`can not set string ref for ${name}`);",
                "                }",
                "                ref(component);",
                "            }",
                "",
                "            this.instance[name] = component;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * validate one Component",
                "     * @param {String} name name of Component",
                "     * @param {Array} rule",
                "     * @param {String} trigger onChange/onBlur/onItemClick/...",
                "     */",
                "    _validate(name, rule, trigger) {",
                "        const field = this._get(name);",
                "        const value = field.value;",
                "",
                "        field.state = 'loading';",
                "",
                "        let validate = this._getCache(name, trigger);",
                "        validate && validate.abort();",
                "",
                "        validate = new Validate({",
                "            [name]: rule,",
                "        });",
                "        this._setCache(name, trigger, validate);",
                "",
                "        validate.validate(",
                "            {",
                "                [name]: value,",
                "            },",
                "            errors => {",
                "                if (errors && errors.length) {",
                "                    field.errors = getErrorStrs(errors);",
                "                    field.state = 'error';",
                "                } else {",
                "                    field.errors = [];",
                "                    field.state = 'success';",
                "                }",
                "",
                "                this._reRender();",
                "            }",
                "        );",
                "    }",
                "",
                "    getValue(name) {",
                "        if (this.options.parseName) {",
                "            return getIn(this.values, name);",
                "        }",
                "        return this.values[name];",
                "    }",
                "",
                "    /**",
                "     * 1. get values by names.",
                "     * 2. If no names passed, return shallow copy of `field.values`",
                "     * @param {Array} names",
                "     */",
                "    getValues(names) {",
                "        const allValues = {};",
                "",
                "        if (names && names.length) {",
                "            names.forEach(name => {",
                "                allValues[name] = this.getValue(name);",
                "            });",
                "        } else {",
                "            Object.assign(allValues, this.values);",
                "        }",
                "",
                "        return allValues;",
                "    }",
                "",
                "    setValue(name, value, reRender = true) {",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].value = value;",
                "        }",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, value);",
                "        } else {",
                "            this.values[name] = value;",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setValues(fieldsValue = {}, reRender = true) {",
                "        if (!this.options.parseName) {",
                "            Object.keys(fieldsValue).forEach(name => {",
                "                this.setValue(name, fieldsValue[name], false);",
                "            });",
                "        } else {",
                "            // NOTE: this is a shallow merge",
                "            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}",
                "            this.values = Object.assign({}, this.values, fieldsValue);",
                "            const fields = this.getNames();",
                "            fields.forEach(name => {",
                "                const value = getIn(this.values, name);",
                "                if (value !== undefined) {",
                "                    // copy over values that are in this.values",
                "                    this.fieldsMeta[name].value = value;",
                "                } else {",
                "                    // if no value then copy values from fieldsMeta to keep initialized component data",
                "                    this.values = setIn(",
                "                        this.values,",
                "                        name,",
                "                        this.fieldsMeta[name].value",
                "                    );",
                "                }",
                "            });",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setError(name, errors) {",
                "        const err = Array.isArray(errors) ? errors : errors ? [errors] : [];",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].errors = err;",
                "        } else {",
                "            this.fieldsMeta[name] = {",
                "                errors: err,",
                "            };",
                "        }",
                "",
                "        if (",
                "            this.fieldsMeta[name].errors &&",
                "            this.fieldsMeta[name].errors.length > 0",
                "        ) {",
                "            this.fieldsMeta[name].state = 'error';",
                "        } else {",
                "            this.fieldsMeta[name].state = '';",
                "        }",
                "",
                "        this._reRender();",
                "    }",
                "",
                "    setErrors(fieldsErrors = {}) {",
                "        Object.keys(fieldsErrors).forEach(name => {",
                "            this.setError(name, fieldsErrors[name]);",
                "        });",
                "    }",
                "",
                "    getError(name) {",
                "        const field = this._get(name);",
                "        if (field && field.errors && field.errors.length) {",
                "            return field.errors;",
                "        }",
                "",
                "        return null;",
                "    }",
                "",
                "    getErrors(names) {",
                "        const fields = names || this.getNames();",
                "        const allErrors = {};",
                "        fields.forEach(f => {",
                "            allErrors[f] = this.getError(f);",
                "        });",
                "        return allErrors;",
                "    }",
                "",
                "    getState(name) {",
                "        const field = this._get(name);",
                "",
                "        if (field && field.state) {",
                "            return field.state;",
                "        }",
                "",
                "        return '';",
                "    }",
                "",
                "    /**",
                "     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate",
                "     * @param {Array} fieldNames",
                "     * @return {Object || null} map of inputs and their errors",
                "     */",
                "    formatGetErrors(fieldNames) {",
                "        const errors = this.getErrors(fieldNames);",
                "        let formattedErrors = null;",
                "        for (const field in errors) {",
                "            if (errors.hasOwnProperty(field) && errors[field]) {",
                "                const errorsObj = errors[field];",
                "                if (!formattedErrors) {",
                "                    formattedErrors = {};",
                "                }",
                "                formattedErrors[field] = { errors: errorsObj };",
                "            }",
                "        }",
                "        return formattedErrors;",
                "    }",
                "",
                "    /**",
                "     * validate by trigger",
                "     * @param {Array} ns names",
                "     * @param {Function} cb callback after validate",
                "     */",
                "    validate(ns, cb) {",
                "        const { names, callback } = getParams(ns, cb);",
                "        const fieldNames = names || this.getNames();",
                "",
                "        const descriptor = {};",
                "        const values = {};",
                "",
                "        let hasRule = false;",
                "        for (let i = 0; i < fieldNames.length; i++) {",
                "            const name = fieldNames[i];",
                "            const field = this._get(name);",
                "",
                "            if (!field) {",
                "                continue;",
                "            }",
                "",
                "            if (field.rules && field.rules.length) {",
                "                descriptor[name] = field.rules;"
            ]
        },
        "2": {
            "class_name": "  (not found) ",
            "file_path": "src/field/utils.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 186
                }
            ],
            "class_code": [
                "import { isValidElement, cloneElement } from 'react';",
                "",
                "/**",
                " * 从组件事件中获取数据",
                " * @param e Event或者value",
                " * @returns value",
                " */",
                "export function getValueFromEvent(e) {",
                "    // support custom element",
                "    if (!e || !e.target) {",
                "        return e;",
                "    }",
                "    const { target } = e;",
                "",
                "    if (target.type === 'checkbox') {",
                "        return target.checked;",
                "    } else if (target.type === 'radio') {",
                "        //兼容原生radioGroup",
                "        if (target.value) {",
                "            return target.value;",
                "        } else {",
                "            return target.checked;",
                "        }",
                "    }",
                "    return target.value;",
                "}",
                "",
                "function cloneAndAddKey(element) {",
                "    if (element && isValidElement(element)) {",
                "        return cloneElement(element, { key: 'error' });",
                "    }",
                "    return element;",
                "}",
                "",
                "export function getErrorStrs(errors) {",
                "    if (errors) {",
                "        return errors.map(function(e) {",
                "            const message = e.message || e;",
                "            return cloneAndAddKey(message);",
                "        });",
                "    }",
                "    return errors;",
                "}",
                "",
                "export function getParams(ns, cb) {",
                "    let names = typeof ns === 'string' ? [ns] : ns;",
                "    let callback = cb;",
                "    if (cb === undefined && typeof names === 'function') {",
                "        callback = names;",
                "        names = undefined;",
                "    }",
                "    return {",
                "        names,",
                "        callback,",
                "    };",
                "}",
                "",
                "const setInWithPath = (state, value, path, pathIndex) => {",
                "    if (pathIndex >= path.length) {",
                "        return value;",
                "    }",
                "",
                "    const first = path[pathIndex];",
                "    const next = setInWithPath(",
                "        state && state[first],",
                "        value,",
                "        path,",
                "        pathIndex + 1",
                "    );",
                "",
                "    if (!state) {",
                "        const initialized = isNaN(first) ? {} : [];",
                "        initialized[first] = next;",
                "        return initialized;",
                "    }",
                "",
                "    if (Array.isArray(state)) {",
                "        const copy = [].concat(state);",
                "        copy[first] = next;",
                "        return copy;",
                "    }",
                "",
                "    return Object.assign({}, state, {",
                "        [first]: next,",
                "    });",
                "};",
                "",
                "export function setIn(state, name, value) {",
                "    return setInWithPath(",
                "        state,",
                "        value,",
                "        name",
                "            .replace(/\\[/, '.')",
                "            .replace(/\\]/, '')",
                "            .split('.'),",
                "        0",
                "    );",
                "}",
                "",
                "export function getIn(state, name) {",
                "    if (!state) {",
                "        return state;",
                "    }",
                "",
                "    const path = name",
                "        .replace(/\\[/, '.')",
                "        .replace(/\\]/, '')",
                "        .split('.');",
                "    const length = path.length;",
                "    if (!length) {",
                "        return undefined;",
                "    }",
                "",
                "    let result = state;",
                "    for (let i = 0; i < length && !!result; ++i) {",
                "        result = result[path[i]];",
                "    }",
                "",
                "    return result;",
                "}",
                "",
                "export function deleteIn(state, name) {",
                "    if (!state) {",
                "        return;",
                "    }",
                "",
                "    const path = name",
                "        .replace(/\\[/, '.')",
                "        .replace(/\\]/, '')",
                "        .split('.');",
                "    const length = path.length;",
                "    if (!length) {",
                "        return state;",
                "    }",
                "",
                "    let result = state;",
                "    for (let i = 0; i < length && !!result; ++i) {",
                "        if (i === length - 1) {",
                "            delete result[path[i]];",
                "        } else {",
                "            result = result[path[i]];",
                "        }",
                "    }",
                "",
                "    return state;",
                "}",
                "",
                "function validateMap(rulesMap, rule, defaultTrigger) {",
                "    const nrule = Object.assign({}, rule);",
                "",
                "    if (!nrule.trigger) {",
                "        nrule.trigger = [defaultTrigger];",
                "    }",
                "",
                "    if (typeof nrule.trigger === 'string') {",
                "        nrule.trigger = [nrule.trigger];",
                "    }",
                "",
                "    for (let i = 0; i < nrule.trigger.length; i++) {",
                "        const trigger = nrule.trigger[i];",
                "",
                "        if (trigger in rulesMap) {",
                "            rulesMap[trigger].push(nrule);",
                "        } else {",
                "            rulesMap[trigger] = [nrule];",
                "        }",
                "    }",
                "",
                "    delete nrule.trigger;",
                "}",
                "",
                "/**",
                " * 提取rule里面的trigger并且做映射",
                " * @param  {Array} rules   规则",
                " * @param  {String} defaultTrigger 默认触发",
                " * @return {Object} {onChange:rule1, onBlur: rule2}",
                " */",
                "export function mapValidateRules(rules, defaultTrigger) {",
                "    const rulesMap = {};",
                "",
                "    rules.forEach(rule => {",
                "        validateMap(rulesMap, rule, defaultTrigger);",
                "    });",
                "",
                "    return rulesMap;",
                "}"
            ]
        }
    },
    "bug_functions": {
        "3": {
            "function_name": "get (not found) 6-506",
            "file_path": "src/field/index.js",
            "function_details": [
                {
                    "name": "get",
                    "start_line": 6,
                    "end_line": 506
                }
            ],
            "function_code": [
                "    getValueFromEvent,",
                "    getErrorStrs,",
                "    getParams,",
                "    setIn,",
                "    getIn,",
                "    deleteIn,",
                "    mapValidateRules,",
                "} from './utils';",
                "",
                "const initMeta = {",
                "    state: '',",
                "    valueName: 'value',",
                "    trigger: 'onChange',",
                "};",
                "",
                "class Field {",
                "    constructor(com, options = {}) {",
                "        if (!com) {",
                "            log.warning(",
                "                '`this` is missing in `Field`, you should use like `new Field(this)`'",
                "            );",
                "        }",
                "",
                "        this.com = com;",
                "        this.fieldsMeta = {};",
                "        this.cachedBind = {};",
                "        this.instance = {};",
                "        // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.",
                "        // Also used caching values when using `parseName: true` before a field is initialized",
                "        this.values = options.values || {};",
                "",
                "        this.options = Object.assign(",
                "            {",
                "                parseName: false,",
                "                forceUpdate: false,",
                "                scrollToFirstError: true,",
                "                first: false,",
                "                onChange: func.noop,",
                "                autoUnmount: true,",
                "                autoValidate: true,",
                "            },",
                "            options",
                "        );",
                "",
                "        [",
                "            'init',",
                "            'getValue',",
                "            'getValues',",
                "            'setValue',",
                "            'setValues',",
                "            'getError',",
                "            'getErrors',",
                "            'setError',",
                "            'setErrors',",
                "            'validate',",
                "            'getState',",
                "            'reset',",
                "            'resetToDefault',",
                "            'remove',",
                "            'spliceArray',",
                "        ].forEach(m => {",
                "            this[m] = this[m].bind(this);",
                "        });",
                "",
                "        if (options.values) {",
                "            this.setValues(options.values, false);",
                "        }",
                "    }",
                "",
                "    setOptions(options) {",
                "        Object.assign(this.options, options);",
                "    }",
                "",
                "    /**",
                "     * Controlled Component",
                "     * @param {String} name",
                "     * @param {Object} fieldOption",
                "     * @returns {Object} {value, onChange}",
                "     */",
                "    init(name, fieldOption = {}, rprops) {",
                "        const {",
                "            initValue,",
                "            valueName = 'value',",
                "            trigger = 'onChange',",
                "            rules = [],",
                "            props = {},",
                "            getValueFromEvent = null,",
                "            autoValidate = true,",
                "        } = fieldOption;",
                "        const { parseName } = this.options;",
                "",
                "        const originalProps = Object.assign({}, props, rprops);",
                "        const defaultValueName = `default${valueName[0].toUpperCase()}${valueName.slice(",
                "            1",
                "        )}`;",
                "",
                "        const field = this._getInitMeta(name);",
                "        let defaultValue;",
                "        if (typeof initValue !== 'undefined') {",
                "            defaultValue = initValue;",
                "        } else if (typeof originalProps[defaultValueName] !== 'undefined') {",
                "            // here use typeof, in case of defaultValue={0}",
                "            defaultValue = originalProps[defaultValueName];",
                "        }",
                "",
                "        Object.assign(field, {",
                "            valueName,",
                "            initValue: defaultValue,",
                "            disabled:",
                "                'disabled' in originalProps ? originalProps.disabled : false,",
                "            getValueFromEvent,",
                "            rules: Array.isArray(rules) ? rules : [rules],",
                "            ref: originalProps.ref,",
                "        });",
                "",
                "        // Controlled Component, should alwasy equal props.value",
                "        if (valueName in originalProps) {",
                "            field.value = originalProps[valueName];",
                "",
                "            // When rerendering set the values from props.value",
                "            if (parseName) {",
                "                this.values = setIn(this.values, name, field.value);",
                "            } else {",
                "                this.values[name] = field.value;",
                "            }",
                "        }",
                "",
                "        // should get value from this.values",
                "        /**",
                "         * a new field (value not in field)",
                "         * step 1: get value from this.values",
                "         * step 2: from defaultValue",
                "         */",
                "        if (!('value' in field)) {",
                "            if (parseName) {",
                "                const cachedValue = getIn(this.values, name);",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            } else {",
                "                const cachedValue = this.values[name];",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            }",
                "        }",
                "",
                "        if (parseName && !getIn(this.values, name)) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else if (!parseName && !this.values[name]) {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        // Component props",
                "        const inputProps = {",
                "            'data-meta': 'Field',",
                "            id: name,",
                "            ref: this._getCacheBind(name, `${name}__ref`, this._saveRef),",
                "            [valueName]: field.value,",
                "        };",
                "",
                "        let rulesMap = {};",
                "",
                "        if (this.options.autoValidate && autoValidate !== false) {",
                "            // trigger map",
                "            rulesMap = mapValidateRules(field.rules, trigger);",
                "",
                "            // validate hook",
                "            for (const action in rulesMap) {",
                "                if (action === trigger) {",
                "                    continue;",
                "                }",
                "",
                "                const actionRule = rulesMap[action];",
                "                inputProps[action] = (...args) => {",
                "                    this._validate(name, actionRule, action);",
                "                    this._callPropsEvent(action, originalProps, ...args);",
                "                    this._reRender();",
                "                };",
                "            }",
                "        }",
                "",
                "        // onChange hack",
                "        inputProps[trigger] = (...args) => {",
                "            this._callOnChange(name, rulesMap[trigger], trigger, ...args);",
                "            this._callPropsEvent(trigger, originalProps, ...args);",
                "            this.options.onChange(name, field.value);",
                "            this._reRender();",
                "        };",
                "",
                "        delete originalProps[defaultValueName];",
                "",
                "        return Object.assign({}, originalProps, inputProps);",
                "    }",
                "",
                "    /**",
                "     * event on props",
                "     * props.onChange props.onBlur",
                "     */",
                "    _callPropsEvent(action, props, ...args) {",
                "        action in props &&",
                "            typeof props[action] === 'function' &&",
                "            props[action](...args);",
                "    }",
                "",
                "    _getInitMeta(name) {",
                "        if (!(name in this.fieldsMeta)) {",
                "            this.fieldsMeta[name] = Object.assign({}, initMeta);",
                "        }",
                "",
                "        return this.fieldsMeta[name];",
                "    }",
                "",
                "    /**",
                "     * update field.value and validate",
                "     */",
                "    _callOnChange(name, rule, trigger, ...others) {",
                "        const e = others[0];",
                "        const field = this._get(name);",
                "",
                "        if (!field) {",
                "            return;",
                "        }",
                "",
                "        field.value = field.getValueFromEvent",
                "            ? field.getValueFromEvent.apply(this, others)",
                "            : getValueFromEvent(e);",
                "",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        this._resetError(name);",
                "",
                "        // validate while onChange",
                "        rule && this._validate(name, rule, trigger);",
                "    }",
                "",
                "    /**",
                "     * ref must always be the same function, or if not it will be triggerd every time.",
                "     * @param {String} name name of component",
                "     * @param {String} action key to find ref",
                "     * @param {Function} fn saveRef",
                "     */",
                "    _getCacheBind(name, action, fn) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        if (!cache[action]) {",
                "            cache[action] = fn.bind(this, name);",
                "        }",
                "        return cache[action];",
                "    }",
                "",
                "    _setCache(name, action, hander) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        cache[action] = hander;",
                "    }",
                "",
                "    _getCache(name, action) {",
                "        const cache = this.cachedBind[name] || {};",
                "        return cache[action];",
                "    }",
                "",
                "    /**",
                "     * NOTE: saveRef is async function. it will be called after render",
                "     * @param {String} name name of component",
                "     * @param {Function} component ref",
                "     */",
                "    _saveRef(name, component) {",
                "        const key = `${name}_field`;",
                "        const autoUnmount = this.options.autoUnmount;",
                "",
                "        if (!component && autoUnmount) {",
                "            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)",
                "            // while type changed, B will render before A unmount. so we should cached value for B",
                "            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render",
                "            // 1. _saveRef(A, null)",
                "            const cache = this.fieldsMeta[name];",
                "            this._setCache(name, key, cache);",
                "            // after destroy, delete data",
                "            delete this.instance[name];",
                "            this.remove(name);",
                "            return;",
                "        }",
                "",
                "        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)",
                "        if (autoUnmount && !this.fieldsMeta[name]) {",
                "            this.fieldsMeta[name] = this._getCache(name, key);",
                "            this.setValue(",
                "                name,",
                "                this.fieldsMeta[name] && this.fieldsMeta[name].value,",
                "                false",
                "            );",
                "        }",
                "",
                "        // only one time here",
                "        const field = this._get(name);",
                "        if (field) {",
                "            const ref = field.ref;",
                "            if (ref) {",
                "                if (typeof ref === 'string') {",
                "                    throw new Error(`can not set string ref for ${name}`);",
                "                }",
                "                ref(component);",
                "            }",
                "",
                "            this.instance[name] = component;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * validate one Component",
                "     * @param {String} name name of Component",
                "     * @param {Array} rule",
                "     * @param {String} trigger onChange/onBlur/onItemClick/...",
                "     */",
                "    _validate(name, rule, trigger) {",
                "        const field = this._get(name);",
                "        const value = field.value;",
                "",
                "        field.state = 'loading';",
                "",
                "        let validate = this._getCache(name, trigger);",
                "        validate && validate.abort();",
                "",
                "        validate = new Validate({",
                "            [name]: rule,",
                "        });",
                "        this._setCache(name, trigger, validate);",
                "",
                "        validate.validate(",
                "            {",
                "                [name]: value,",
                "            },",
                "            errors => {",
                "                if (errors && errors.length) {",
                "                    field.errors = getErrorStrs(errors);",
                "                    field.state = 'error';",
                "                } else {",
                "                    field.errors = [];",
                "                    field.state = 'success';",
                "                }",
                "",
                "                this._reRender();",
                "            }",
                "        );",
                "    }",
                "",
                "    getValue(name) {",
                "        if (this.options.parseName) {",
                "            return getIn(this.values, name);",
                "        }",
                "        return this.values[name];",
                "    }",
                "",
                "    /**",
                "     * 1. get values by names.",
                "     * 2. If no names passed, return shallow copy of `field.values`",
                "     * @param {Array} names",
                "     */",
                "    getValues(names) {",
                "        const allValues = {};",
                "",
                "        if (names && names.length) {",
                "            names.forEach(name => {",
                "                allValues[name] = this.getValue(name);",
                "            });",
                "        } else {",
                "            Object.assign(allValues, this.values);",
                "        }",
                "",
                "        return allValues;",
                "    }",
                "",
                "    setValue(name, value, reRender = true) {",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].value = value;",
                "        }",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, value);",
                "        } else {",
                "            this.values[name] = value;",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setValues(fieldsValue = {}, reRender = true) {",
                "        if (!this.options.parseName) {",
                "            Object.keys(fieldsValue).forEach(name => {",
                "                this.setValue(name, fieldsValue[name], false);",
                "            });",
                "        } else {",
                "            // NOTE: this is a shallow merge",
                "            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}",
                "            this.values = Object.assign({}, this.values, fieldsValue);",
                "            const fields = this.getNames();",
                "            fields.forEach(name => {",
                "                const value = getIn(this.values, name);",
                "                if (value !== undefined) {",
                "                    // copy over values that are in this.values",
                "                    this.fieldsMeta[name].value = value;",
                "                } else {",
                "                    // if no value then copy values from fieldsMeta to keep initialized component data",
                "                    this.values = setIn(",
                "                        this.values,",
                "                        name,",
                "                        this.fieldsMeta[name].value",
                "                    );",
                "                }",
                "            });",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setError(name, errors) {",
                "        const err = Array.isArray(errors) ? errors : errors ? [errors] : [];",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].errors = err;",
                "        } else {",
                "            this.fieldsMeta[name] = {",
                "                errors: err,",
                "            };",
                "        }",
                "",
                "        if (",
                "            this.fieldsMeta[name].errors &&",
                "            this.fieldsMeta[name].errors.length > 0",
                "        ) {",
                "            this.fieldsMeta[name].state = 'error';",
                "        } else {",
                "            this.fieldsMeta[name].state = '';",
                "        }",
                "",
                "        this._reRender();",
                "    }",
                "",
                "    setErrors(fieldsErrors = {}) {",
                "        Object.keys(fieldsErrors).forEach(name => {",
                "            this.setError(name, fieldsErrors[name]);",
                "        });",
                "    }",
                "",
                "    getError(name) {",
                "        const field = this._get(name);",
                "        if (field && field.errors && field.errors.length) {",
                "            return field.errors;",
                "        }",
                "",
                "        return null;",
                "    }",
                "",
                "    getErrors(names) {",
                "        const fields = names || this.getNames();",
                "        const allErrors = {};",
                "        fields.forEach(f => {",
                "            allErrors[f] = this.getError(f);",
                "        });",
                "        return allErrors;",
                "    }",
                "",
                "    getState(name) {",
                "        const field = this._get(name);",
                "",
                "        if (field && field.state) {",
                "            return field.state;",
                "        }",
                "",
                "        return '';",
                "    }",
                "",
                "    /**",
                "     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate",
                "     * @param {Array} fieldNames",
                "     * @return {Object || null} map of inputs and their errors",
                "     */",
                "    formatGetErrors(fieldNames) {",
                "        const errors = this.getErrors(fieldNames);",
                "        let formattedErrors = null;",
                "        for (const field in errors) {",
                "            if (errors.hasOwnProperty(field) && errors[field]) {",
                "                const errorsObj = errors[field];",
                "                if (!formattedErrors) {",
                "                    formattedErrors = {};",
                "                }",
                "                formattedErrors[field] = { errors: errorsObj };",
                "            }",
                "        }",
                "        return formattedErrors;",
                "    }",
                "",
                "    /**",
                "     * validate by trigger",
                "     * @param {Array} ns names",
                "     * @param {Function} cb callback after validate",
                "     */",
                "    validate(ns, cb) {",
                "        const { names, callback } = getParams(ns, cb);",
                "        const fieldNames = names || this.getNames();"
            ]
        },
        "4": {
            "function_name": "set (not found) 9-509",
            "file_path": "src/field/index.js",
            "function_details": [
                {
                    "name": "set",
                    "start_line": 9,
                    "end_line": 509
                }
            ],
            "function_code": [
                "    setIn,",
                "    getIn,",
                "    deleteIn,",
                "    mapValidateRules,",
                "} from './utils';",
                "",
                "const initMeta = {",
                "    state: '',",
                "    valueName: 'value',",
                "    trigger: 'onChange',",
                "};",
                "",
                "class Field {",
                "    constructor(com, options = {}) {",
                "        if (!com) {",
                "            log.warning(",
                "                '`this` is missing in `Field`, you should use like `new Field(this)`'",
                "            );",
                "        }",
                "",
                "        this.com = com;",
                "        this.fieldsMeta = {};",
                "        this.cachedBind = {};",
                "        this.instance = {};",
                "        // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.",
                "        // Also used caching values when using `parseName: true` before a field is initialized",
                "        this.values = options.values || {};",
                "",
                "        this.options = Object.assign(",
                "            {",
                "                parseName: false,",
                "                forceUpdate: false,",
                "                scrollToFirstError: true,",
                "                first: false,",
                "                onChange: func.noop,",
                "                autoUnmount: true,",
                "                autoValidate: true,",
                "            },",
                "            options",
                "        );",
                "",
                "        [",
                "            'init',",
                "            'getValue',",
                "            'getValues',",
                "            'setValue',",
                "            'setValues',",
                "            'getError',",
                "            'getErrors',",
                "            'setError',",
                "            'setErrors',",
                "            'validate',",
                "            'getState',",
                "            'reset',",
                "            'resetToDefault',",
                "            'remove',",
                "            'spliceArray',",
                "        ].forEach(m => {",
                "            this[m] = this[m].bind(this);",
                "        });",
                "",
                "        if (options.values) {",
                "            this.setValues(options.values, false);",
                "        }",
                "    }",
                "",
                "    setOptions(options) {",
                "        Object.assign(this.options, options);",
                "    }",
                "",
                "    /**",
                "     * Controlled Component",
                "     * @param {String} name",
                "     * @param {Object} fieldOption",
                "     * @returns {Object} {value, onChange}",
                "     */",
                "    init(name, fieldOption = {}, rprops) {",
                "        const {",
                "            initValue,",
                "            valueName = 'value',",
                "            trigger = 'onChange',",
                "            rules = [],",
                "            props = {},",
                "            getValueFromEvent = null,",
                "            autoValidate = true,",
                "        } = fieldOption;",
                "        const { parseName } = this.options;",
                "",
                "        const originalProps = Object.assign({}, props, rprops);",
                "        const defaultValueName = `default${valueName[0].toUpperCase()}${valueName.slice(",
                "            1",
                "        )}`;",
                "",
                "        const field = this._getInitMeta(name);",
                "        let defaultValue;",
                "        if (typeof initValue !== 'undefined') {",
                "            defaultValue = initValue;",
                "        } else if (typeof originalProps[defaultValueName] !== 'undefined') {",
                "            // here use typeof, in case of defaultValue={0}",
                "            defaultValue = originalProps[defaultValueName];",
                "        }",
                "",
                "        Object.assign(field, {",
                "            valueName,",
                "            initValue: defaultValue,",
                "            disabled:",
                "                'disabled' in originalProps ? originalProps.disabled : false,",
                "            getValueFromEvent,",
                "            rules: Array.isArray(rules) ? rules : [rules],",
                "            ref: originalProps.ref,",
                "        });",
                "",
                "        // Controlled Component, should alwasy equal props.value",
                "        if (valueName in originalProps) {",
                "            field.value = originalProps[valueName];",
                "",
                "            // When rerendering set the values from props.value",
                "            if (parseName) {",
                "                this.values = setIn(this.values, name, field.value);",
                "            } else {",
                "                this.values[name] = field.value;",
                "            }",
                "        }",
                "",
                "        // should get value from this.values",
                "        /**",
                "         * a new field (value not in field)",
                "         * step 1: get value from this.values",
                "         * step 2: from defaultValue",
                "         */",
                "        if (!('value' in field)) {",
                "            if (parseName) {",
                "                const cachedValue = getIn(this.values, name);",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            } else {",
                "                const cachedValue = this.values[name];",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            }",
                "        }",
                "",
                "        if (parseName && !getIn(this.values, name)) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else if (!parseName && !this.values[name]) {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        // Component props",
                "        const inputProps = {",
                "            'data-meta': 'Field',",
                "            id: name,",
                "            ref: this._getCacheBind(name, `${name}__ref`, this._saveRef),",
                "            [valueName]: field.value,",
                "        };",
                "",
                "        let rulesMap = {};",
                "",
                "        if (this.options.autoValidate && autoValidate !== false) {",
                "            // trigger map",
                "            rulesMap = mapValidateRules(field.rules, trigger);",
                "",
                "            // validate hook",
                "            for (const action in rulesMap) {",
                "                if (action === trigger) {",
                "                    continue;",
                "                }",
                "",
                "                const actionRule = rulesMap[action];",
                "                inputProps[action] = (...args) => {",
                "                    this._validate(name, actionRule, action);",
                "                    this._callPropsEvent(action, originalProps, ...args);",
                "                    this._reRender();",
                "                };",
                "            }",
                "        }",
                "",
                "        // onChange hack",
                "        inputProps[trigger] = (...args) => {",
                "            this._callOnChange(name, rulesMap[trigger], trigger, ...args);",
                "            this._callPropsEvent(trigger, originalProps, ...args);",
                "            this.options.onChange(name, field.value);",
                "            this._reRender();",
                "        };",
                "",
                "        delete originalProps[defaultValueName];",
                "",
                "        return Object.assign({}, originalProps, inputProps);",
                "    }",
                "",
                "    /**",
                "     * event on props",
                "     * props.onChange props.onBlur",
                "     */",
                "    _callPropsEvent(action, props, ...args) {",
                "        action in props &&",
                "            typeof props[action] === 'function' &&",
                "            props[action](...args);",
                "    }",
                "",
                "    _getInitMeta(name) {",
                "        if (!(name in this.fieldsMeta)) {",
                "            this.fieldsMeta[name] = Object.assign({}, initMeta);",
                "        }",
                "",
                "        return this.fieldsMeta[name];",
                "    }",
                "",
                "    /**",
                "     * update field.value and validate",
                "     */",
                "    _callOnChange(name, rule, trigger, ...others) {",
                "        const e = others[0];",
                "        const field = this._get(name);",
                "",
                "        if (!field) {",
                "            return;",
                "        }",
                "",
                "        field.value = field.getValueFromEvent",
                "            ? field.getValueFromEvent.apply(this, others)",
                "            : getValueFromEvent(e);",
                "",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        this._resetError(name);",
                "",
                "        // validate while onChange",
                "        rule && this._validate(name, rule, trigger);",
                "    }",
                "",
                "    /**",
                "     * ref must always be the same function, or if not it will be triggerd every time.",
                "     * @param {String} name name of component",
                "     * @param {String} action key to find ref",
                "     * @param {Function} fn saveRef",
                "     */",
                "    _getCacheBind(name, action, fn) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        if (!cache[action]) {",
                "            cache[action] = fn.bind(this, name);",
                "        }",
                "        return cache[action];",
                "    }",
                "",
                "    _setCache(name, action, hander) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        cache[action] = hander;",
                "    }",
                "",
                "    _getCache(name, action) {",
                "        const cache = this.cachedBind[name] || {};",
                "        return cache[action];",
                "    }",
                "",
                "    /**",
                "     * NOTE: saveRef is async function. it will be called after render",
                "     * @param {String} name name of component",
                "     * @param {Function} component ref",
                "     */",
                "    _saveRef(name, component) {",
                "        const key = `${name}_field`;",
                "        const autoUnmount = this.options.autoUnmount;",
                "",
                "        if (!component && autoUnmount) {",
                "            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)",
                "            // while type changed, B will render before A unmount. so we should cached value for B",
                "            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render",
                "            // 1. _saveRef(A, null)",
                "            const cache = this.fieldsMeta[name];",
                "            this._setCache(name, key, cache);",
                "            // after destroy, delete data",
                "            delete this.instance[name];",
                "            this.remove(name);",
                "            return;",
                "        }",
                "",
                "        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)",
                "        if (autoUnmount && !this.fieldsMeta[name]) {",
                "            this.fieldsMeta[name] = this._getCache(name, key);",
                "            this.setValue(",
                "                name,",
                "                this.fieldsMeta[name] && this.fieldsMeta[name].value,",
                "                false",
                "            );",
                "        }",
                "",
                "        // only one time here",
                "        const field = this._get(name);",
                "        if (field) {",
                "            const ref = field.ref;",
                "            if (ref) {",
                "                if (typeof ref === 'string') {",
                "                    throw new Error(`can not set string ref for ${name}`);",
                "                }",
                "                ref(component);",
                "            }",
                "",
                "            this.instance[name] = component;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * validate one Component",
                "     * @param {String} name name of Component",
                "     * @param {Array} rule",
                "     * @param {String} trigger onChange/onBlur/onItemClick/...",
                "     */",
                "    _validate(name, rule, trigger) {",
                "        const field = this._get(name);",
                "        const value = field.value;",
                "",
                "        field.state = 'loading';",
                "",
                "        let validate = this._getCache(name, trigger);",
                "        validate && validate.abort();",
                "",
                "        validate = new Validate({",
                "            [name]: rule,",
                "        });",
                "        this._setCache(name, trigger, validate);",
                "",
                "        validate.validate(",
                "            {",
                "                [name]: value,",
                "            },",
                "            errors => {",
                "                if (errors && errors.length) {",
                "                    field.errors = getErrorStrs(errors);",
                "                    field.state = 'error';",
                "                } else {",
                "                    field.errors = [];",
                "                    field.state = 'success';",
                "                }",
                "",
                "                this._reRender();",
                "            }",
                "        );",
                "    }",
                "",
                "    getValue(name) {",
                "        if (this.options.parseName) {",
                "            return getIn(this.values, name);",
                "        }",
                "        return this.values[name];",
                "    }",
                "",
                "    /**",
                "     * 1. get values by names.",
                "     * 2. If no names passed, return shallow copy of `field.values`",
                "     * @param {Array} names",
                "     */",
                "    getValues(names) {",
                "        const allValues = {};",
                "",
                "        if (names && names.length) {",
                "            names.forEach(name => {",
                "                allValues[name] = this.getValue(name);",
                "            });",
                "        } else {",
                "            Object.assign(allValues, this.values);",
                "        }",
                "",
                "        return allValues;",
                "    }",
                "",
                "    setValue(name, value, reRender = true) {",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].value = value;",
                "        }",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, value);",
                "        } else {",
                "            this.values[name] = value;",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setValues(fieldsValue = {}, reRender = true) {",
                "        if (!this.options.parseName) {",
                "            Object.keys(fieldsValue).forEach(name => {",
                "                this.setValue(name, fieldsValue[name], false);",
                "            });",
                "        } else {",
                "            // NOTE: this is a shallow merge",
                "            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}",
                "            this.values = Object.assign({}, this.values, fieldsValue);",
                "            const fields = this.getNames();",
                "            fields.forEach(name => {",
                "                const value = getIn(this.values, name);",
                "                if (value !== undefined) {",
                "                    // copy over values that are in this.values",
                "                    this.fieldsMeta[name].value = value;",
                "                } else {",
                "                    // if no value then copy values from fieldsMeta to keep initialized component data",
                "                    this.values = setIn(",
                "                        this.values,",
                "                        name,",
                "                        this.fieldsMeta[name].value",
                "                    );",
                "                }",
                "            });",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setError(name, errors) {",
                "        const err = Array.isArray(errors) ? errors : errors ? [errors] : [];",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].errors = err;",
                "        } else {",
                "            this.fieldsMeta[name] = {",
                "                errors: err,",
                "            };",
                "        }",
                "",
                "        if (",
                "            this.fieldsMeta[name].errors &&",
                "            this.fieldsMeta[name].errors.length > 0",
                "        ) {",
                "            this.fieldsMeta[name].state = 'error';",
                "        } else {",
                "            this.fieldsMeta[name].state = '';",
                "        }",
                "",
                "        this._reRender();",
                "    }",
                "",
                "    setErrors(fieldsErrors = {}) {",
                "        Object.keys(fieldsErrors).forEach(name => {",
                "            this.setError(name, fieldsErrors[name]);",
                "        });",
                "    }",
                "",
                "    getError(name) {",
                "        const field = this._get(name);",
                "        if (field && field.errors && field.errors.length) {",
                "            return field.errors;",
                "        }",
                "",
                "        return null;",
                "    }",
                "",
                "    getErrors(names) {",
                "        const fields = names || this.getNames();",
                "        const allErrors = {};",
                "        fields.forEach(f => {",
                "            allErrors[f] = this.getError(f);",
                "        });",
                "        return allErrors;",
                "    }",
                "",
                "    getState(name) {",
                "        const field = this._get(name);",
                "",
                "        if (field && field.state) {",
                "            return field.state;",
                "        }",
                "",
                "        return '';",
                "    }",
                "",
                "    /**",
                "     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate",
                "     * @param {Array} fieldNames",
                "     * @return {Object || null} map of inputs and their errors",
                "     */",
                "    formatGetErrors(fieldNames) {",
                "        const errors = this.getErrors(fieldNames);",
                "        let formattedErrors = null;",
                "        for (const field in errors) {",
                "            if (errors.hasOwnProperty(field) && errors[field]) {",
                "                const errorsObj = errors[field];",
                "                if (!formattedErrors) {",
                "                    formattedErrors = {};",
                "                }",
                "                formattedErrors[field] = { errors: errorsObj };",
                "            }",
                "        }",
                "        return formattedErrors;",
                "    }",
                "",
                "    /**",
                "     * validate by trigger",
                "     * @param {Array} ns names",
                "     * @param {Function} cb callback after validate",
                "     */",
                "    validate(ns, cb) {",
                "        const { names, callback } = getParams(ns, cb);",
                "        const fieldNames = names || this.getNames();",
                "",
                "        const descriptor = {};",
                "        const values = {};"
            ]
        },
        "5": {
            "function_name": "validate (not found) 3-503",
            "file_path": "src/field/index.js",
            "function_details": [
                {
                    "name": "validate",
                    "start_line": 3,
                    "end_line": 503
                }
            ],
            "function_code": [
                "import Validate from '../validate';",
                "",
                "import {",
                "    getValueFromEvent,",
                "    getErrorStrs,",
                "    getParams,",
                "    setIn,",
                "    getIn,",
                "    deleteIn,",
                "    mapValidateRules,",
                "} from './utils';",
                "",
                "const initMeta = {",
                "    state: '',",
                "    valueName: 'value',",
                "    trigger: 'onChange',",
                "};",
                "",
                "class Field {",
                "    constructor(com, options = {}) {",
                "        if (!com) {",
                "            log.warning(",
                "                '`this` is missing in `Field`, you should use like `new Field(this)`'",
                "            );",
                "        }",
                "",
                "        this.com = com;",
                "        this.fieldsMeta = {};",
                "        this.cachedBind = {};",
                "        this.instance = {};",
                "        // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.",
                "        // Also used caching values when using `parseName: true` before a field is initialized",
                "        this.values = options.values || {};",
                "",
                "        this.options = Object.assign(",
                "            {",
                "                parseName: false,",
                "                forceUpdate: false,",
                "                scrollToFirstError: true,",
                "                first: false,",
                "                onChange: func.noop,",
                "                autoUnmount: true,",
                "                autoValidate: true,",
                "            },",
                "            options",
                "        );",
                "",
                "        [",
                "            'init',",
                "            'getValue',",
                "            'getValues',",
                "            'setValue',",
                "            'setValues',",
                "            'getError',",
                "            'getErrors',",
                "            'setError',",
                "            'setErrors',",
                "            'validate',",
                "            'getState',",
                "            'reset',",
                "            'resetToDefault',",
                "            'remove',",
                "            'spliceArray',",
                "        ].forEach(m => {",
                "            this[m] = this[m].bind(this);",
                "        });",
                "",
                "        if (options.values) {",
                "            this.setValues(options.values, false);",
                "        }",
                "    }",
                "",
                "    setOptions(options) {",
                "        Object.assign(this.options, options);",
                "    }",
                "",
                "    /**",
                "     * Controlled Component",
                "     * @param {String} name",
                "     * @param {Object} fieldOption",
                "     * @returns {Object} {value, onChange}",
                "     */",
                "    init(name, fieldOption = {}, rprops) {",
                "        const {",
                "            initValue,",
                "            valueName = 'value',",
                "            trigger = 'onChange',",
                "            rules = [],",
                "            props = {},",
                "            getValueFromEvent = null,",
                "            autoValidate = true,",
                "        } = fieldOption;",
                "        const { parseName } = this.options;",
                "",
                "        const originalProps = Object.assign({}, props, rprops);",
                "        const defaultValueName = `default${valueName[0].toUpperCase()}${valueName.slice(",
                "            1",
                "        )}`;",
                "",
                "        const field = this._getInitMeta(name);",
                "        let defaultValue;",
                "        if (typeof initValue !== 'undefined') {",
                "            defaultValue = initValue;",
                "        } else if (typeof originalProps[defaultValueName] !== 'undefined') {",
                "            // here use typeof, in case of defaultValue={0}",
                "            defaultValue = originalProps[defaultValueName];",
                "        }",
                "",
                "        Object.assign(field, {",
                "            valueName,",
                "            initValue: defaultValue,",
                "            disabled:",
                "                'disabled' in originalProps ? originalProps.disabled : false,",
                "            getValueFromEvent,",
                "            rules: Array.isArray(rules) ? rules : [rules],",
                "            ref: originalProps.ref,",
                "        });",
                "",
                "        // Controlled Component, should alwasy equal props.value",
                "        if (valueName in originalProps) {",
                "            field.value = originalProps[valueName];",
                "",
                "            // When rerendering set the values from props.value",
                "            if (parseName) {",
                "                this.values = setIn(this.values, name, field.value);",
                "            } else {",
                "                this.values[name] = field.value;",
                "            }",
                "        }",
                "",
                "        // should get value from this.values",
                "        /**",
                "         * a new field (value not in field)",
                "         * step 1: get value from this.values",
                "         * step 2: from defaultValue",
                "         */",
                "        if (!('value' in field)) {",
                "            if (parseName) {",
                "                const cachedValue = getIn(this.values, name);",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            } else {",
                "                const cachedValue = this.values[name];",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            }",
                "        }",
                "",
                "        if (parseName && !getIn(this.values, name)) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else if (!parseName && !this.values[name]) {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        // Component props",
                "        const inputProps = {",
                "            'data-meta': 'Field',",
                "            id: name,",
                "            ref: this._getCacheBind(name, `${name}__ref`, this._saveRef),",
                "            [valueName]: field.value,",
                "        };",
                "",
                "        let rulesMap = {};",
                "",
                "        if (this.options.autoValidate && autoValidate !== false) {",
                "            // trigger map",
                "            rulesMap = mapValidateRules(field.rules, trigger);",
                "",
                "            // validate hook",
                "            for (const action in rulesMap) {",
                "                if (action === trigger) {",
                "                    continue;",
                "                }",
                "",
                "                const actionRule = rulesMap[action];",
                "                inputProps[action] = (...args) => {",
                "                    this._validate(name, actionRule, action);",
                "                    this._callPropsEvent(action, originalProps, ...args);",
                "                    this._reRender();",
                "                };",
                "            }",
                "        }",
                "",
                "        // onChange hack",
                "        inputProps[trigger] = (...args) => {",
                "            this._callOnChange(name, rulesMap[trigger], trigger, ...args);",
                "            this._callPropsEvent(trigger, originalProps, ...args);",
                "            this.options.onChange(name, field.value);",
                "            this._reRender();",
                "        };",
                "",
                "        delete originalProps[defaultValueName];",
                "",
                "        return Object.assign({}, originalProps, inputProps);",
                "    }",
                "",
                "    /**",
                "     * event on props",
                "     * props.onChange props.onBlur",
                "     */",
                "    _callPropsEvent(action, props, ...args) {",
                "        action in props &&",
                "            typeof props[action] === 'function' &&",
                "            props[action](...args);",
                "    }",
                "",
                "    _getInitMeta(name) {",
                "        if (!(name in this.fieldsMeta)) {",
                "            this.fieldsMeta[name] = Object.assign({}, initMeta);",
                "        }",
                "",
                "        return this.fieldsMeta[name];",
                "    }",
                "",
                "    /**",
                "     * update field.value and validate",
                "     */",
                "    _callOnChange(name, rule, trigger, ...others) {",
                "        const e = others[0];",
                "        const field = this._get(name);",
                "",
                "        if (!field) {",
                "            return;",
                "        }",
                "",
                "        field.value = field.getValueFromEvent",
                "            ? field.getValueFromEvent.apply(this, others)",
                "            : getValueFromEvent(e);",
                "",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        this._resetError(name);",
                "",
                "        // validate while onChange",
                "        rule && this._validate(name, rule, trigger);",
                "    }",
                "",
                "    /**",
                "     * ref must always be the same function, or if not it will be triggerd every time.",
                "     * @param {String} name name of component",
                "     * @param {String} action key to find ref",
                "     * @param {Function} fn saveRef",
                "     */",
                "    _getCacheBind(name, action, fn) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        if (!cache[action]) {",
                "            cache[action] = fn.bind(this, name);",
                "        }",
                "        return cache[action];",
                "    }",
                "",
                "    _setCache(name, action, hander) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        cache[action] = hander;",
                "    }",
                "",
                "    _getCache(name, action) {",
                "        const cache = this.cachedBind[name] || {};",
                "        return cache[action];",
                "    }",
                "",
                "    /**",
                "     * NOTE: saveRef is async function. it will be called after render",
                "     * @param {String} name name of component",
                "     * @param {Function} component ref",
                "     */",
                "    _saveRef(name, component) {",
                "        const key = `${name}_field`;",
                "        const autoUnmount = this.options.autoUnmount;",
                "",
                "        if (!component && autoUnmount) {",
                "            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)",
                "            // while type changed, B will render before A unmount. so we should cached value for B",
                "            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render",
                "            // 1. _saveRef(A, null)",
                "            const cache = this.fieldsMeta[name];",
                "            this._setCache(name, key, cache);",
                "            // after destroy, delete data",
                "            delete this.instance[name];",
                "            this.remove(name);",
                "            return;",
                "        }",
                "",
                "        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)",
                "        if (autoUnmount && !this.fieldsMeta[name]) {",
                "            this.fieldsMeta[name] = this._getCache(name, key);",
                "            this.setValue(",
                "                name,",
                "                this.fieldsMeta[name] && this.fieldsMeta[name].value,",
                "                false",
                "            );",
                "        }",
                "",
                "        // only one time here",
                "        const field = this._get(name);",
                "        if (field) {",
                "            const ref = field.ref;",
                "            if (ref) {",
                "                if (typeof ref === 'string') {",
                "                    throw new Error(`can not set string ref for ${name}`);",
                "                }",
                "                ref(component);",
                "            }",
                "",
                "            this.instance[name] = component;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * validate one Component",
                "     * @param {String} name name of Component",
                "     * @param {Array} rule",
                "     * @param {String} trigger onChange/onBlur/onItemClick/...",
                "     */",
                "    _validate(name, rule, trigger) {",
                "        const field = this._get(name);",
                "        const value = field.value;",
                "",
                "        field.state = 'loading';",
                "",
                "        let validate = this._getCache(name, trigger);",
                "        validate && validate.abort();",
                "",
                "        validate = new Validate({",
                "            [name]: rule,",
                "        });",
                "        this._setCache(name, trigger, validate);",
                "",
                "        validate.validate(",
                "            {",
                "                [name]: value,",
                "            },",
                "            errors => {",
                "                if (errors && errors.length) {",
                "                    field.errors = getErrorStrs(errors);",
                "                    field.state = 'error';",
                "                } else {",
                "                    field.errors = [];",
                "                    field.state = 'success';",
                "                }",
                "",
                "                this._reRender();",
                "            }",
                "        );",
                "    }",
                "",
                "    getValue(name) {",
                "        if (this.options.parseName) {",
                "            return getIn(this.values, name);",
                "        }",
                "        return this.values[name];",
                "    }",
                "",
                "    /**",
                "     * 1. get values by names.",
                "     * 2. If no names passed, return shallow copy of `field.values`",
                "     * @param {Array} names",
                "     */",
                "    getValues(names) {",
                "        const allValues = {};",
                "",
                "        if (names && names.length) {",
                "            names.forEach(name => {",
                "                allValues[name] = this.getValue(name);",
                "            });",
                "        } else {",
                "            Object.assign(allValues, this.values);",
                "        }",
                "",
                "        return allValues;",
                "    }",
                "",
                "    setValue(name, value, reRender = true) {",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].value = value;",
                "        }",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, value);",
                "        } else {",
                "            this.values[name] = value;",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setValues(fieldsValue = {}, reRender = true) {",
                "        if (!this.options.parseName) {",
                "            Object.keys(fieldsValue).forEach(name => {",
                "                this.setValue(name, fieldsValue[name], false);",
                "            });",
                "        } else {",
                "            // NOTE: this is a shallow merge",
                "            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}",
                "            this.values = Object.assign({}, this.values, fieldsValue);",
                "            const fields = this.getNames();",
                "            fields.forEach(name => {",
                "                const value = getIn(this.values, name);",
                "                if (value !== undefined) {",
                "                    // copy over values that are in this.values",
                "                    this.fieldsMeta[name].value = value;",
                "                } else {",
                "                    // if no value then copy values from fieldsMeta to keep initialized component data",
                "                    this.values = setIn(",
                "                        this.values,",
                "                        name,",
                "                        this.fieldsMeta[name].value",
                "                    );",
                "                }",
                "            });",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setError(name, errors) {",
                "        const err = Array.isArray(errors) ? errors : errors ? [errors] : [];",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].errors = err;",
                "        } else {",
                "            this.fieldsMeta[name] = {",
                "                errors: err,",
                "            };",
                "        }",
                "",
                "        if (",
                "            this.fieldsMeta[name].errors &&",
                "            this.fieldsMeta[name].errors.length > 0",
                "        ) {",
                "            this.fieldsMeta[name].state = 'error';",
                "        } else {",
                "            this.fieldsMeta[name].state = '';",
                "        }",
                "",
                "        this._reRender();",
                "    }",
                "",
                "    setErrors(fieldsErrors = {}) {",
                "        Object.keys(fieldsErrors).forEach(name => {",
                "            this.setError(name, fieldsErrors[name]);",
                "        });",
                "    }",
                "",
                "    getError(name) {",
                "        const field = this._get(name);",
                "        if (field && field.errors && field.errors.length) {",
                "            return field.errors;",
                "        }",
                "",
                "        return null;",
                "    }",
                "",
                "    getErrors(names) {",
                "        const fields = names || this.getNames();",
                "        const allErrors = {};",
                "        fields.forEach(f => {",
                "            allErrors[f] = this.getError(f);",
                "        });",
                "        return allErrors;",
                "    }",
                "",
                "    getState(name) {",
                "        const field = this._get(name);",
                "",
                "        if (field && field.state) {",
                "            return field.state;",
                "        }",
                "",
                "        return '';",
                "    }",
                "",
                "    /**",
                "     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate",
                "     * @param {Array} fieldNames",
                "     * @return {Object || null} map of inputs and their errors",
                "     */",
                "    formatGetErrors(fieldNames) {",
                "        const errors = this.getErrors(fieldNames);",
                "        let formattedErrors = null;",
                "        for (const field in errors) {",
                "            if (errors.hasOwnProperty(field) && errors[field]) {",
                "                const errorsObj = errors[field];",
                "                if (!formattedErrors) {",
                "                    formattedErrors = {};",
                "                }",
                "                formattedErrors[field] = { errors: errorsObj };",
                "            }",
                "        }",
                "        return formattedErrors;",
                "    }",
                "",
                "    /**",
                "     * validate by trigger",
                "     * @param {Array} ns names",
                "     * @param {Function} cb callback after validate",
                "     */"
            ]
        },
        "6": {
            "function_name": "getValues (not found) 53-553",
            "file_path": "src/field/index.js",
            "function_details": [
                {
                    "name": "getValues",
                    "start_line": 53,
                    "end_line": 553
                }
            ],
            "function_code": [
                "            'getValues',",
                "            'setValue',",
                "            'setValues',",
                "            'getError',",
                "            'getErrors',",
                "            'setError',",
                "            'setErrors',",
                "            'validate',",
                "            'getState',",
                "            'reset',",
                "            'resetToDefault',",
                "            'remove',",
                "            'spliceArray',",
                "        ].forEach(m => {",
                "            this[m] = this[m].bind(this);",
                "        });",
                "",
                "        if (options.values) {",
                "            this.setValues(options.values, false);",
                "        }",
                "    }",
                "",
                "    setOptions(options) {",
                "        Object.assign(this.options, options);",
                "    }",
                "",
                "    /**",
                "     * Controlled Component",
                "     * @param {String} name",
                "     * @param {Object} fieldOption",
                "     * @returns {Object} {value, onChange}",
                "     */",
                "    init(name, fieldOption = {}, rprops) {",
                "        const {",
                "            initValue,",
                "            valueName = 'value',",
                "            trigger = 'onChange',",
                "            rules = [],",
                "            props = {},",
                "            getValueFromEvent = null,",
                "            autoValidate = true,",
                "        } = fieldOption;",
                "        const { parseName } = this.options;",
                "",
                "        const originalProps = Object.assign({}, props, rprops);",
                "        const defaultValueName = `default${valueName[0].toUpperCase()}${valueName.slice(",
                "            1",
                "        )}`;",
                "",
                "        const field = this._getInitMeta(name);",
                "        let defaultValue;",
                "        if (typeof initValue !== 'undefined') {",
                "            defaultValue = initValue;",
                "        } else if (typeof originalProps[defaultValueName] !== 'undefined') {",
                "            // here use typeof, in case of defaultValue={0}",
                "            defaultValue = originalProps[defaultValueName];",
                "        }",
                "",
                "        Object.assign(field, {",
                "            valueName,",
                "            initValue: defaultValue,",
                "            disabled:",
                "                'disabled' in originalProps ? originalProps.disabled : false,",
                "            getValueFromEvent,",
                "            rules: Array.isArray(rules) ? rules : [rules],",
                "            ref: originalProps.ref,",
                "        });",
                "",
                "        // Controlled Component, should alwasy equal props.value",
                "        if (valueName in originalProps) {",
                "            field.value = originalProps[valueName];",
                "",
                "            // When rerendering set the values from props.value",
                "            if (parseName) {",
                "                this.values = setIn(this.values, name, field.value);",
                "            } else {",
                "                this.values[name] = field.value;",
                "            }",
                "        }",
                "",
                "        // should get value from this.values",
                "        /**",
                "         * a new field (value not in field)",
                "         * step 1: get value from this.values",
                "         * step 2: from defaultValue",
                "         */",
                "        if (!('value' in field)) {",
                "            if (parseName) {",
                "                const cachedValue = getIn(this.values, name);",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            } else {",
                "                const cachedValue = this.values[name];",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            }",
                "        }",
                "",
                "        if (parseName && !getIn(this.values, name)) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else if (!parseName && !this.values[name]) {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        // Component props",
                "        const inputProps = {",
                "            'data-meta': 'Field',",
                "            id: name,",
                "            ref: this._getCacheBind(name, `${name}__ref`, this._saveRef),",
                "            [valueName]: field.value,",
                "        };",
                "",
                "        let rulesMap = {};",
                "",
                "        if (this.options.autoValidate && autoValidate !== false) {",
                "            // trigger map",
                "            rulesMap = mapValidateRules(field.rules, trigger);",
                "",
                "            // validate hook",
                "            for (const action in rulesMap) {",
                "                if (action === trigger) {",
                "                    continue;",
                "                }",
                "",
                "                const actionRule = rulesMap[action];",
                "                inputProps[action] = (...args) => {",
                "                    this._validate(name, actionRule, action);",
                "                    this._callPropsEvent(action, originalProps, ...args);",
                "                    this._reRender();",
                "                };",
                "            }",
                "        }",
                "",
                "        // onChange hack",
                "        inputProps[trigger] = (...args) => {",
                "            this._callOnChange(name, rulesMap[trigger], trigger, ...args);",
                "            this._callPropsEvent(trigger, originalProps, ...args);",
                "            this.options.onChange(name, field.value);",
                "            this._reRender();",
                "        };",
                "",
                "        delete originalProps[defaultValueName];",
                "",
                "        return Object.assign({}, originalProps, inputProps);",
                "    }",
                "",
                "    /**",
                "     * event on props",
                "     * props.onChange props.onBlur",
                "     */",
                "    _callPropsEvent(action, props, ...args) {",
                "        action in props &&",
                "            typeof props[action] === 'function' &&",
                "            props[action](...args);",
                "    }",
                "",
                "    _getInitMeta(name) {",
                "        if (!(name in this.fieldsMeta)) {",
                "            this.fieldsMeta[name] = Object.assign({}, initMeta);",
                "        }",
                "",
                "        return this.fieldsMeta[name];",
                "    }",
                "",
                "    /**",
                "     * update field.value and validate",
                "     */",
                "    _callOnChange(name, rule, trigger, ...others) {",
                "        const e = others[0];",
                "        const field = this._get(name);",
                "",
                "        if (!field) {",
                "            return;",
                "        }",
                "",
                "        field.value = field.getValueFromEvent",
                "            ? field.getValueFromEvent.apply(this, others)",
                "            : getValueFromEvent(e);",
                "",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        this._resetError(name);",
                "",
                "        // validate while onChange",
                "        rule && this._validate(name, rule, trigger);",
                "    }",
                "",
                "    /**",
                "     * ref must always be the same function, or if not it will be triggerd every time.",
                "     * @param {String} name name of component",
                "     * @param {String} action key to find ref",
                "     * @param {Function} fn saveRef",
                "     */",
                "    _getCacheBind(name, action, fn) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        if (!cache[action]) {",
                "            cache[action] = fn.bind(this, name);",
                "        }",
                "        return cache[action];",
                "    }",
                "",
                "    _setCache(name, action, hander) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        cache[action] = hander;",
                "    }",
                "",
                "    _getCache(name, action) {",
                "        const cache = this.cachedBind[name] || {};",
                "        return cache[action];",
                "    }",
                "",
                "    /**",
                "     * NOTE: saveRef is async function. it will be called after render",
                "     * @param {String} name name of component",
                "     * @param {Function} component ref",
                "     */",
                "    _saveRef(name, component) {",
                "        const key = `${name}_field`;",
                "        const autoUnmount = this.options.autoUnmount;",
                "",
                "        if (!component && autoUnmount) {",
                "            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)",
                "            // while type changed, B will render before A unmount. so we should cached value for B",
                "            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render",
                "            // 1. _saveRef(A, null)",
                "            const cache = this.fieldsMeta[name];",
                "            this._setCache(name, key, cache);",
                "            // after destroy, delete data",
                "            delete this.instance[name];",
                "            this.remove(name);",
                "            return;",
                "        }",
                "",
                "        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)",
                "        if (autoUnmount && !this.fieldsMeta[name]) {",
                "            this.fieldsMeta[name] = this._getCache(name, key);",
                "            this.setValue(",
                "                name,",
                "                this.fieldsMeta[name] && this.fieldsMeta[name].value,",
                "                false",
                "            );",
                "        }",
                "",
                "        // only one time here",
                "        const field = this._get(name);",
                "        if (field) {",
                "            const ref = field.ref;",
                "            if (ref) {",
                "                if (typeof ref === 'string') {",
                "                    throw new Error(`can not set string ref for ${name}`);",
                "                }",
                "                ref(component);",
                "            }",
                "",
                "            this.instance[name] = component;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * validate one Component",
                "     * @param {String} name name of Component",
                "     * @param {Array} rule",
                "     * @param {String} trigger onChange/onBlur/onItemClick/...",
                "     */",
                "    _validate(name, rule, trigger) {",
                "        const field = this._get(name);",
                "        const value = field.value;",
                "",
                "        field.state = 'loading';",
                "",
                "        let validate = this._getCache(name, trigger);",
                "        validate && validate.abort();",
                "",
                "        validate = new Validate({",
                "            [name]: rule,",
                "        });",
                "        this._setCache(name, trigger, validate);",
                "",
                "        validate.validate(",
                "            {",
                "                [name]: value,",
                "            },",
                "            errors => {",
                "                if (errors && errors.length) {",
                "                    field.errors = getErrorStrs(errors);",
                "                    field.state = 'error';",
                "                } else {",
                "                    field.errors = [];",
                "                    field.state = 'success';",
                "                }",
                "",
                "                this._reRender();",
                "            }",
                "        );",
                "    }",
                "",
                "    getValue(name) {",
                "        if (this.options.parseName) {",
                "            return getIn(this.values, name);",
                "        }",
                "        return this.values[name];",
                "    }",
                "",
                "    /**",
                "     * 1. get values by names.",
                "     * 2. If no names passed, return shallow copy of `field.values`",
                "     * @param {Array} names",
                "     */",
                "    getValues(names) {",
                "        const allValues = {};",
                "",
                "        if (names && names.length) {",
                "            names.forEach(name => {",
                "                allValues[name] = this.getValue(name);",
                "            });",
                "        } else {",
                "            Object.assign(allValues, this.values);",
                "        }",
                "",
                "        return allValues;",
                "    }",
                "",
                "    setValue(name, value, reRender = true) {",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].value = value;",
                "        }",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, value);",
                "        } else {",
                "            this.values[name] = value;",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setValues(fieldsValue = {}, reRender = true) {",
                "        if (!this.options.parseName) {",
                "            Object.keys(fieldsValue).forEach(name => {",
                "                this.setValue(name, fieldsValue[name], false);",
                "            });",
                "        } else {",
                "            // NOTE: this is a shallow merge",
                "            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}",
                "            this.values = Object.assign({}, this.values, fieldsValue);",
                "            const fields = this.getNames();",
                "            fields.forEach(name => {",
                "                const value = getIn(this.values, name);",
                "                if (value !== undefined) {",
                "                    // copy over values that are in this.values",
                "                    this.fieldsMeta[name].value = value;",
                "                } else {",
                "                    // if no value then copy values from fieldsMeta to keep initialized component data",
                "                    this.values = setIn(",
                "                        this.values,",
                "                        name,",
                "                        this.fieldsMeta[name].value",
                "                    );",
                "                }",
                "            });",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setError(name, errors) {",
                "        const err = Array.isArray(errors) ? errors : errors ? [errors] : [];",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].errors = err;",
                "        } else {",
                "            this.fieldsMeta[name] = {",
                "                errors: err,",
                "            };",
                "        }",
                "",
                "        if (",
                "            this.fieldsMeta[name].errors &&",
                "            this.fieldsMeta[name].errors.length > 0",
                "        ) {",
                "            this.fieldsMeta[name].state = 'error';",
                "        } else {",
                "            this.fieldsMeta[name].state = '';",
                "        }",
                "",
                "        this._reRender();",
                "    }",
                "",
                "    setErrors(fieldsErrors = {}) {",
                "        Object.keys(fieldsErrors).forEach(name => {",
                "            this.setError(name, fieldsErrors[name]);",
                "        });",
                "    }",
                "",
                "    getError(name) {",
                "        const field = this._get(name);",
                "        if (field && field.errors && field.errors.length) {",
                "            return field.errors;",
                "        }",
                "",
                "        return null;",
                "    }",
                "",
                "    getErrors(names) {",
                "        const fields = names || this.getNames();",
                "        const allErrors = {};",
                "        fields.forEach(f => {",
                "            allErrors[f] = this.getError(f);",
                "        });",
                "        return allErrors;",
                "    }",
                "",
                "    getState(name) {",
                "        const field = this._get(name);",
                "",
                "        if (field && field.state) {",
                "            return field.state;",
                "        }",
                "",
                "        return '';",
                "    }",
                "",
                "    /**",
                "     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate",
                "     * @param {Array} fieldNames",
                "     * @return {Object || null} map of inputs and their errors",
                "     */",
                "    formatGetErrors(fieldNames) {",
                "        const errors = this.getErrors(fieldNames);",
                "        let formattedErrors = null;",
                "        for (const field in errors) {",
                "            if (errors.hasOwnProperty(field) && errors[field]) {",
                "                const errorsObj = errors[field];",
                "                if (!formattedErrors) {",
                "                    formattedErrors = {};",
                "                }",
                "                formattedErrors[field] = { errors: errorsObj };",
                "            }",
                "        }",
                "        return formattedErrors;",
                "    }",
                "",
                "    /**",
                "     * validate by trigger",
                "     * @param {Array} ns names",
                "     * @param {Function} cb callback after validate",
                "     */",
                "    validate(ns, cb) {",
                "        const { names, callback } = getParams(ns, cb);",
                "        const fieldNames = names || this.getNames();",
                "",
                "        const descriptor = {};",
                "        const values = {};",
                "",
                "        let hasRule = false;",
                "        for (let i = 0; i < fieldNames.length; i++) {",
                "            const name = fieldNames[i];",
                "            const field = this._get(name);",
                "",
                "            if (!field) {",
                "                continue;",
                "            }",
                "",
                "            if (field.rules && field.rules.length) {",
                "                descriptor[name] = field.rules;",
                "                values[name] = this.getValue(name);",
                "                hasRule = true;",
                "",
                "                // clear error",
                "                field.errors = [];",
                "                field.state = '';",
                "            }",
                "        }",
                "",
                "        if (!hasRule) {",
                "            const errors = this.formatGetErrors(fieldNames);",
                "            callback &&",
                "                callback(errors, this.getValues(names ? fieldNames : []));",
                "            return;",
                "        }",
                "",
                "        const validate = new Validate(descriptor, {",
                "            first: this.options.first,",
                "        });",
                "",
                "        validate.validate(values, errors => {",
                "            let errorsGroup = null;",
                "            if (errors && errors.length) {",
                "                errorsGroup = {};",
                "                errors.forEach(e => {",
                "                    const fieldName = e.field;",
                "                    if (!errorsGroup[fieldName]) {",
                "                        errorsGroup[fieldName] = {",
                "                            errors: [],",
                "                        };",
                "                    }",
                "                    const fieldErrors = errorsGroup[fieldName].errors;"
            ]
        },
        "7": {
            "function_name": "setValues (not found) 55-555",
            "file_path": "src/field/index.js",
            "function_details": [
                {
                    "name": "setValues",
                    "start_line": 55,
                    "end_line": 555
                }
            ],
            "function_code": [
                "            'setValues',",
                "            'getError',",
                "            'getErrors',",
                "            'setError',",
                "            'setErrors',",
                "            'validate',",
                "            'getState',",
                "            'reset',",
                "            'resetToDefault',",
                "            'remove',",
                "            'spliceArray',",
                "        ].forEach(m => {",
                "            this[m] = this[m].bind(this);",
                "        });",
                "",
                "        if (options.values) {",
                "            this.setValues(options.values, false);",
                "        }",
                "    }",
                "",
                "    setOptions(options) {",
                "        Object.assign(this.options, options);",
                "    }",
                "",
                "    /**",
                "     * Controlled Component",
                "     * @param {String} name",
                "     * @param {Object} fieldOption",
                "     * @returns {Object} {value, onChange}",
                "     */",
                "    init(name, fieldOption = {}, rprops) {",
                "        const {",
                "            initValue,",
                "            valueName = 'value',",
                "            trigger = 'onChange',",
                "            rules = [],",
                "            props = {},",
                "            getValueFromEvent = null,",
                "            autoValidate = true,",
                "        } = fieldOption;",
                "        const { parseName } = this.options;",
                "",
                "        const originalProps = Object.assign({}, props, rprops);",
                "        const defaultValueName = `default${valueName[0].toUpperCase()}${valueName.slice(",
                "            1",
                "        )}`;",
                "",
                "        const field = this._getInitMeta(name);",
                "        let defaultValue;",
                "        if (typeof initValue !== 'undefined') {",
                "            defaultValue = initValue;",
                "        } else if (typeof originalProps[defaultValueName] !== 'undefined') {",
                "            // here use typeof, in case of defaultValue={0}",
                "            defaultValue = originalProps[defaultValueName];",
                "        }",
                "",
                "        Object.assign(field, {",
                "            valueName,",
                "            initValue: defaultValue,",
                "            disabled:",
                "                'disabled' in originalProps ? originalProps.disabled : false,",
                "            getValueFromEvent,",
                "            rules: Array.isArray(rules) ? rules : [rules],",
                "            ref: originalProps.ref,",
                "        });",
                "",
                "        // Controlled Component, should alwasy equal props.value",
                "        if (valueName in originalProps) {",
                "            field.value = originalProps[valueName];",
                "",
                "            // When rerendering set the values from props.value",
                "            if (parseName) {",
                "                this.values = setIn(this.values, name, field.value);",
                "            } else {",
                "                this.values[name] = field.value;",
                "            }",
                "        }",
                "",
                "        // should get value from this.values",
                "        /**",
                "         * a new field (value not in field)",
                "         * step 1: get value from this.values",
                "         * step 2: from defaultValue",
                "         */",
                "        if (!('value' in field)) {",
                "            if (parseName) {",
                "                const cachedValue = getIn(this.values, name);",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            } else {",
                "                const cachedValue = this.values[name];",
                "                field.value =",
                "                    typeof cachedValue !== 'undefined'",
                "                        ? cachedValue",
                "                        : defaultValue;",
                "            }",
                "        }",
                "",
                "        if (parseName && !getIn(this.values, name)) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else if (!parseName && !this.values[name]) {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        // Component props",
                "        const inputProps = {",
                "            'data-meta': 'Field',",
                "            id: name,",
                "            ref: this._getCacheBind(name, `${name}__ref`, this._saveRef),",
                "            [valueName]: field.value,",
                "        };",
                "",
                "        let rulesMap = {};",
                "",
                "        if (this.options.autoValidate && autoValidate !== false) {",
                "            // trigger map",
                "            rulesMap = mapValidateRules(field.rules, trigger);",
                "",
                "            // validate hook",
                "            for (const action in rulesMap) {",
                "                if (action === trigger) {",
                "                    continue;",
                "                }",
                "",
                "                const actionRule = rulesMap[action];",
                "                inputProps[action] = (...args) => {",
                "                    this._validate(name, actionRule, action);",
                "                    this._callPropsEvent(action, originalProps, ...args);",
                "                    this._reRender();",
                "                };",
                "            }",
                "        }",
                "",
                "        // onChange hack",
                "        inputProps[trigger] = (...args) => {",
                "            this._callOnChange(name, rulesMap[trigger], trigger, ...args);",
                "            this._callPropsEvent(trigger, originalProps, ...args);",
                "            this.options.onChange(name, field.value);",
                "            this._reRender();",
                "        };",
                "",
                "        delete originalProps[defaultValueName];",
                "",
                "        return Object.assign({}, originalProps, inputProps);",
                "    }",
                "",
                "    /**",
                "     * event on props",
                "     * props.onChange props.onBlur",
                "     */",
                "    _callPropsEvent(action, props, ...args) {",
                "        action in props &&",
                "            typeof props[action] === 'function' &&",
                "            props[action](...args);",
                "    }",
                "",
                "    _getInitMeta(name) {",
                "        if (!(name in this.fieldsMeta)) {",
                "            this.fieldsMeta[name] = Object.assign({}, initMeta);",
                "        }",
                "",
                "        return this.fieldsMeta[name];",
                "    }",
                "",
                "    /**",
                "     * update field.value and validate",
                "     */",
                "    _callOnChange(name, rule, trigger, ...others) {",
                "        const e = others[0];",
                "        const field = this._get(name);",
                "",
                "        if (!field) {",
                "            return;",
                "        }",
                "",
                "        field.value = field.getValueFromEvent",
                "            ? field.getValueFromEvent.apply(this, others)",
                "            : getValueFromEvent(e);",
                "",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, field.value);",
                "        } else {",
                "            this.values[name] = field.value;",
                "        }",
                "",
                "        this._resetError(name);",
                "",
                "        // validate while onChange",
                "        rule && this._validate(name, rule, trigger);",
                "    }",
                "",
                "    /**",
                "     * ref must always be the same function, or if not it will be triggerd every time.",
                "     * @param {String} name name of component",
                "     * @param {String} action key to find ref",
                "     * @param {Function} fn saveRef",
                "     */",
                "    _getCacheBind(name, action, fn) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        if (!cache[action]) {",
                "            cache[action] = fn.bind(this, name);",
                "        }",
                "        return cache[action];",
                "    }",
                "",
                "    _setCache(name, action, hander) {",
                "        const cache = (this.cachedBind[name] = this.cachedBind[name] || {});",
                "        cache[action] = hander;",
                "    }",
                "",
                "    _getCache(name, action) {",
                "        const cache = this.cachedBind[name] || {};",
                "        return cache[action];",
                "    }",
                "",
                "    /**",
                "     * NOTE: saveRef is async function. it will be called after render",
                "     * @param {String} name name of component",
                "     * @param {Function} component ref",
                "     */",
                "    _saveRef(name, component) {",
                "        const key = `${name}_field`;",
                "        const autoUnmount = this.options.autoUnmount;",
                "",
                "        if (!component && autoUnmount) {",
                "            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)",
                "            // while type changed, B will render before A unmount. so we should cached value for B",
                "            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render",
                "            // 1. _saveRef(A, null)",
                "            const cache = this.fieldsMeta[name];",
                "            this._setCache(name, key, cache);",
                "            // after destroy, delete data",
                "            delete this.instance[name];",
                "            this.remove(name);",
                "            return;",
                "        }",
                "",
                "        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)",
                "        if (autoUnmount && !this.fieldsMeta[name]) {",
                "            this.fieldsMeta[name] = this._getCache(name, key);",
                "            this.setValue(",
                "                name,",
                "                this.fieldsMeta[name] && this.fieldsMeta[name].value,",
                "                false",
                "            );",
                "        }",
                "",
                "        // only one time here",
                "        const field = this._get(name);",
                "        if (field) {",
                "            const ref = field.ref;",
                "            if (ref) {",
                "                if (typeof ref === 'string') {",
                "                    throw new Error(`can not set string ref for ${name}`);",
                "                }",
                "                ref(component);",
                "            }",
                "",
                "            this.instance[name] = component;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * validate one Component",
                "     * @param {String} name name of Component",
                "     * @param {Array} rule",
                "     * @param {String} trigger onChange/onBlur/onItemClick/...",
                "     */",
                "    _validate(name, rule, trigger) {",
                "        const field = this._get(name);",
                "        const value = field.value;",
                "",
                "        field.state = 'loading';",
                "",
                "        let validate = this._getCache(name, trigger);",
                "        validate && validate.abort();",
                "",
                "        validate = new Validate({",
                "            [name]: rule,",
                "        });",
                "        this._setCache(name, trigger, validate);",
                "",
                "        validate.validate(",
                "            {",
                "                [name]: value,",
                "            },",
                "            errors => {",
                "                if (errors && errors.length) {",
                "                    field.errors = getErrorStrs(errors);",
                "                    field.state = 'error';",
                "                } else {",
                "                    field.errors = [];",
                "                    field.state = 'success';",
                "                }",
                "",
                "                this._reRender();",
                "            }",
                "        );",
                "    }",
                "",
                "    getValue(name) {",
                "        if (this.options.parseName) {",
                "            return getIn(this.values, name);",
                "        }",
                "        return this.values[name];",
                "    }",
                "",
                "    /**",
                "     * 1. get values by names.",
                "     * 2. If no names passed, return shallow copy of `field.values`",
                "     * @param {Array} names",
                "     */",
                "    getValues(names) {",
                "        const allValues = {};",
                "",
                "        if (names && names.length) {",
                "            names.forEach(name => {",
                "                allValues[name] = this.getValue(name);",
                "            });",
                "        } else {",
                "            Object.assign(allValues, this.values);",
                "        }",
                "",
                "        return allValues;",
                "    }",
                "",
                "    setValue(name, value, reRender = true) {",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].value = value;",
                "        }",
                "        if (this.options.parseName) {",
                "            this.values = setIn(this.values, name, value);",
                "        } else {",
                "            this.values[name] = value;",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setValues(fieldsValue = {}, reRender = true) {",
                "        if (!this.options.parseName) {",
                "            Object.keys(fieldsValue).forEach(name => {",
                "                this.setValue(name, fieldsValue[name], false);",
                "            });",
                "        } else {",
                "            // NOTE: this is a shallow merge",
                "            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}",
                "            this.values = Object.assign({}, this.values, fieldsValue);",
                "            const fields = this.getNames();",
                "            fields.forEach(name => {",
                "                const value = getIn(this.values, name);",
                "                if (value !== undefined) {",
                "                    // copy over values that are in this.values",
                "                    this.fieldsMeta[name].value = value;",
                "                } else {",
                "                    // if no value then copy values from fieldsMeta to keep initialized component data",
                "                    this.values = setIn(",
                "                        this.values,",
                "                        name,",
                "                        this.fieldsMeta[name].value",
                "                    );",
                "                }",
                "            });",
                "        }",
                "        reRender && this._reRender();",
                "    }",
                "",
                "    setError(name, errors) {",
                "        const err = Array.isArray(errors) ? errors : errors ? [errors] : [];",
                "        if (name in this.fieldsMeta) {",
                "            this.fieldsMeta[name].errors = err;",
                "        } else {",
                "            this.fieldsMeta[name] = {",
                "                errors: err,",
                "            };",
                "        }",
                "",
                "        if (",
                "            this.fieldsMeta[name].errors &&",
                "            this.fieldsMeta[name].errors.length > 0",
                "        ) {",
                "            this.fieldsMeta[name].state = 'error';",
                "        } else {",
                "            this.fieldsMeta[name].state = '';",
                "        }",
                "",
                "        this._reRender();",
                "    }",
                "",
                "    setErrors(fieldsErrors = {}) {",
                "        Object.keys(fieldsErrors).forEach(name => {",
                "            this.setError(name, fieldsErrors[name]);",
                "        });",
                "    }",
                "",
                "    getError(name) {",
                "        const field = this._get(name);",
                "        if (field && field.errors && field.errors.length) {",
                "            return field.errors;",
                "        }",
                "",
                "        return null;",
                "    }",
                "",
                "    getErrors(names) {",
                "        const fields = names || this.getNames();",
                "        const allErrors = {};",
                "        fields.forEach(f => {",
                "            allErrors[f] = this.getError(f);",
                "        });",
                "        return allErrors;",
                "    }",
                "",
                "    getState(name) {",
                "        const field = this._get(name);",
                "",
                "        if (field && field.state) {",
                "            return field.state;",
                "        }",
                "",
                "        return '';",
                "    }",
                "",
                "    /**",
                "     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate",
                "     * @param {Array} fieldNames",
                "     * @return {Object || null} map of inputs and their errors",
                "     */",
                "    formatGetErrors(fieldNames) {",
                "        const errors = this.getErrors(fieldNames);",
                "        let formattedErrors = null;",
                "        for (const field in errors) {",
                "            if (errors.hasOwnProperty(field) && errors[field]) {",
                "                const errorsObj = errors[field];",
                "                if (!formattedErrors) {",
                "                    formattedErrors = {};",
                "                }",
                "                formattedErrors[field] = { errors: errorsObj };",
                "            }",
                "        }",
                "        return formattedErrors;",
                "    }",
                "",
                "    /**",
                "     * validate by trigger",
                "     * @param {Array} ns names",
                "     * @param {Function} cb callback after validate",
                "     */",
                "    validate(ns, cb) {",
                "        const { names, callback } = getParams(ns, cb);",
                "        const fieldNames = names || this.getNames();",
                "",
                "        const descriptor = {};",
                "        const values = {};",
                "",
                "        let hasRule = false;",
                "        for (let i = 0; i < fieldNames.length; i++) {",
                "            const name = fieldNames[i];",
                "            const field = this._get(name);",
                "",
                "            if (!field) {",
                "                continue;",
                "            }",
                "",
                "            if (field.rules && field.rules.length) {",
                "                descriptor[name] = field.rules;",
                "                values[name] = this.getValue(name);",
                "                hasRule = true;",
                "",
                "                // clear error",
                "                field.errors = [];",
                "                field.state = '';",
                "            }",
                "        }",
                "",
                "        if (!hasRule) {",
                "            const errors = this.formatGetErrors(fieldNames);",
                "            callback &&",
                "                callback(errors, this.getValues(names ? fieldNames : []));",
                "            return;",
                "        }",
                "",
                "        const validate = new Validate(descriptor, {",
                "            first: this.options.first,",
                "        });",
                "",
                "        validate.validate(values, errors => {",
                "            let errorsGroup = null;",
                "            if (errors && errors.length) {",
                "                errorsGroup = {};",
                "                errors.forEach(e => {",
                "                    const fieldName = e.field;",
                "                    if (!errorsGroup[fieldName]) {",
                "                        errorsGroup[fieldName] = {",
                "                            errors: [],",
                "                        };",
                "                    }",
                "                    const fieldErrors = errorsGroup[fieldName].errors;",
                "                    fieldErrors.push(e.message);",
                "                });"
            ]
        },
        "8": {
            "function_name": "getValueFromEvent (not found) ",
            "file_path": "src/field/utils.js",
            "function_details": [
                {
                    "name": "getValueFromEvent",
                    "start_line": 1,
                    "end_line": 186
                }
            ],
            "function_code": [
                "import { isValidElement, cloneElement } from 'react';",
                "",
                "/**",
                " * 从组件事件中获取数据",
                " * @param e Event或者value",
                " * @returns value",
                " */",
                "export function getValueFromEvent(e) {",
                "    // support custom element",
                "    if (!e || !e.target) {",
                "        return e;",
                "    }",
                "    const { target } = e;",
                "",
                "    if (target.type === 'checkbox') {",
                "        return target.checked;",
                "    } else if (target.type === 'radio') {",
                "        //兼容原生radioGroup",
                "        if (target.value) {",
                "            return target.value;",
                "        } else {",
                "            return target.checked;",
                "        }",
                "    }",
                "    return target.value;",
                "}",
                "",
                "function cloneAndAddKey(element) {",
                "    if (element && isValidElement(element)) {",
                "        return cloneElement(element, { key: 'error' });",
                "    }",
                "    return element;",
                "}",
                "",
                "export function getErrorStrs(errors) {",
                "    if (errors) {",
                "        return errors.map(function(e) {",
                "            const message = e.message || e;",
                "            return cloneAndAddKey(message);",
                "        });",
                "    }",
                "    return errors;",
                "}",
                "",
                "export function getParams(ns, cb) {",
                "    let names = typeof ns === 'string' ? [ns] : ns;",
                "    let callback = cb;",
                "    if (cb === undefined && typeof names === 'function') {",
                "        callback = names;",
                "        names = undefined;",
                "    }",
                "    return {",
                "        names,",
                "        callback,",
                "    };",
                "}",
                "",
                "const setInWithPath = (state, value, path, pathIndex) => {",
                "    if (pathIndex >= path.length) {",
                "        return value;",
                "    }",
                "",
                "    const first = path[pathIndex];",
                "    const next = setInWithPath(",
                "        state && state[first],",
                "        value,",
                "        path,",
                "        pathIndex + 1",
                "    );",
                "",
                "    if (!state) {",
                "        const initialized = isNaN(first) ? {} : [];",
                "        initialized[first] = next;",
                "        return initialized;",
                "    }",
                "",
                "    if (Array.isArray(state)) {",
                "        const copy = [].concat(state);",
                "        copy[first] = next;",
                "        return copy;",
                "    }",
                "",
                "    return Object.assign({}, state, {",
                "        [first]: next,",
                "    });",
                "};",
                "",
                "export function setIn(state, name, value) {",
                "    return setInWithPath(",
                "        state,",
                "        value,",
                "        name",
                "            .replace(/\\[/, '.')",
                "            .replace(/\\]/, '')",
                "            .split('.'),",
                "        0",
                "    );",
                "}",
                "",
                "export function getIn(state, name) {",
                "    if (!state) {",
                "        return state;",
                "    }",
                "",
                "    const path = name",
                "        .replace(/\\[/, '.')",
                "        .replace(/\\]/, '')",
                "        .split('.');",
                "    const length = path.length;",
                "    if (!length) {",
                "        return undefined;",
                "    }",
                "",
                "    let result = state;",
                "    for (let i = 0; i < length && !!result; ++i) {",
                "        result = result[path[i]];",
                "    }",
                "",
                "    return result;",
                "}",
                "",
                "export function deleteIn(state, name) {",
                "    if (!state) {",
                "        return;",
                "    }",
                "",
                "    const path = name",
                "        .replace(/\\[/, '.')",
                "        .replace(/\\]/, '')",
                "        .split('.');",
                "    const length = path.length;",
                "    if (!length) {",
                "        return state;",
                "    }",
                "",
                "    let result = state;",
                "    for (let i = 0; i < length && !!result; ++i) {",
                "        if (i === length - 1) {",
                "            delete result[path[i]];",
                "        } else {",
                "            result = result[path[i]];",
                "        }",
                "    }",
                "",
                "    return state;",
                "}",
                "",
                "function validateMap(rulesMap, rule, defaultTrigger) {",
                "    const nrule = Object.assign({}, rule);",
                "",
                "    if (!nrule.trigger) {",
                "        nrule.trigger = [defaultTrigger];",
                "    }",
                "",
                "    if (typeof nrule.trigger === 'string') {",
                "        nrule.trigger = [nrule.trigger];",
                "    }",
                "",
                "    for (let i = 0; i < nrule.trigger.length; i++) {",
                "        const trigger = nrule.trigger[i];",
                "",
                "        if (trigger in rulesMap) {",
                "            rulesMap[trigger].push(nrule);",
                "        } else {",
                "            rulesMap[trigger] = [nrule];",
                "        }",
                "    }",
                "",
                "    delete nrule.trigger;",
                "}",
                "",
                "/**",
                " * 提取rule里面的trigger并且做映射",
                " * @param  {Array} rules   规则",
                " * @param  {String} defaultTrigger 默认触发",
                " * @return {Object} {onChange:rule1, onBlur: rule2}",
                " */",
                "export function mapValidateRules(rules, defaultTrigger) {",
                "    const rulesMap = {};",
                "",
                "    rules.forEach(rule => {",
                "        validateMap(rulesMap, rule, defaultTrigger);",
                "    });",
                "",
                "    return rulesMap;",
                "}"
            ]
        },
        "9": {
            "function_name": "setIn (not found) ",
            "file_path": "src/field/utils.js",
            "function_details": [
                {
                    "name": "setIn",
                    "start_line": 1,
                    "end_line": 186
                }
            ],
            "function_code": [
                "import { isValidElement, cloneElement } from 'react';",
                "",
                "/**",
                " * 从组件事件中获取数据",
                " * @param e Event或者value",
                " * @returns value",
                " */",
                "export function getValueFromEvent(e) {",
                "    // support custom element",
                "    if (!e || !e.target) {",
                "        return e;",
                "    }",
                "    const { target } = e;",
                "",
                "    if (target.type === 'checkbox') {",
                "        return target.checked;",
                "    } else if (target.type === 'radio') {",
                "        //兼容原生radioGroup",
                "        if (target.value) {",
                "            return target.value;",
                "        } else {",
                "            return target.checked;",
                "        }",
                "    }",
                "    return target.value;",
                "}",
                "",
                "function cloneAndAddKey(element) {",
                "    if (element && isValidElement(element)) {",
                "        return cloneElement(element, { key: 'error' });",
                "    }",
                "    return element;",
                "}",
                "",
                "export function getErrorStrs(errors) {",
                "    if (errors) {",
                "        return errors.map(function(e) {",
                "            const message = e.message || e;",
                "            return cloneAndAddKey(message);",
                "        });",
                "    }",
                "    return errors;",
                "}",
                "",
                "export function getParams(ns, cb) {",
                "    let names = typeof ns === 'string' ? [ns] : ns;",
                "    let callback = cb;",
                "    if (cb === undefined && typeof names === 'function') {",
                "        callback = names;",
                "        names = undefined;",
                "    }",
                "    return {",
                "        names,",
                "        callback,",
                "    };",
                "}",
                "",
                "const setInWithPath = (state, value, path, pathIndex) => {",
                "    if (pathIndex >= path.length) {",
                "        return value;",
                "    }",
                "",
                "    const first = path[pathIndex];",
                "    const next = setInWithPath(",
                "        state && state[first],",
                "        value,",
                "        path,",
                "        pathIndex + 1",
                "    );",
                "",
                "    if (!state) {",
                "        const initialized = isNaN(first) ? {} : [];",
                "        initialized[first] = next;",
                "        return initialized;",
                "    }",
                "",
                "    if (Array.isArray(state)) {",
                "        const copy = [].concat(state);",
                "        copy[first] = next;",
                "        return copy;",
                "    }",
                "",
                "    return Object.assign({}, state, {",
                "        [first]: next,",
                "    });",
                "};",
                "",
                "export function setIn(state, name, value) {",
                "    return setInWithPath(",
                "        state,",
                "        value,",
                "        name",
                "            .replace(/\\[/, '.')",
                "            .replace(/\\]/, '')",
                "            .split('.'),",
                "        0",
                "    );",
                "}",
                "",
                "export function getIn(state, name) {",
                "    if (!state) {",
                "        return state;",
                "    }",
                "",
                "    const path = name",
                "        .replace(/\\[/, '.')",
                "        .replace(/\\]/, '')",
                "        .split('.');",
                "    const length = path.length;",
                "    if (!length) {",
                "        return undefined;",
                "    }",
                "",
                "    let result = state;",
                "    for (let i = 0; i < length && !!result; ++i) {",
                "        result = result[path[i]];",
                "    }",
                "",
                "    return result;",
                "}",
                "",
                "export function deleteIn(state, name) {",
                "    if (!state) {",
                "        return;",
                "    }",
                "",
                "    const path = name",
                "        .replace(/\\[/, '.')",
                "        .replace(/\\]/, '')",
                "        .split('.');",
                "    const length = path.length;",
                "    if (!length) {",
                "        return state;",
                "    }",
                "",
                "    let result = state;",
                "    for (let i = 0; i < length && !!result; ++i) {",
                "        if (i === length - 1) {",
                "            delete result[path[i]];",
                "        } else {",
                "            result = result[path[i]];",
                "        }",
                "    }",
                "",
                "    return state;",
                "}",
                "",
                "function validateMap(rulesMap, rule, defaultTrigger) {",
                "    const nrule = Object.assign({}, rule);",
                "",
                "    if (!nrule.trigger) {",
                "        nrule.trigger = [defaultTrigger];",
                "    }",
                "",
                "    if (typeof nrule.trigger === 'string') {",
                "        nrule.trigger = [nrule.trigger];",
                "    }",
                "",
                "    for (let i = 0; i < nrule.trigger.length; i++) {",
                "        const trigger = nrule.trigger[i];",
                "",
                "        if (trigger in rulesMap) {",
                "            rulesMap[trigger].push(nrule);",
                "        } else {",
                "            rulesMap[trigger] = [nrule];",
                "        }",
                "    }",
                "",
                "    delete nrule.trigger;",
                "}",
                "",
                "/**",
                " * 提取rule里面的trigger并且做映射",
                " * @param  {Array} rules   规则",
                " * @param  {String} defaultTrigger 默认触发",
                " * @return {Object} {onChange:rule1, onBlur: rule2}",
                " */",
                "export function mapValidateRules(rules, defaultTrigger) {",
                "    const rulesMap = {};",
                "",
                "    rules.forEach(rule => {",
                "        validateMap(rulesMap, rule, defaultTrigger);",
                "    });",
                "",
                "    return rulesMap;",
                "}"
            ]
        },
        "10": {
            "function_name": "getIn (not found) ",
            "file_path": "src/field/utils.js",
            "function_details": [
                {
                    "name": "getIn",
                    "start_line": 1,
                    "end_line": 186
                }
            ],
            "function_code": [
                "import { isValidElement, cloneElement } from 'react';",
                "",
                "/**",
                " * 从组件事件中获取数据",
                " * @param e Event或者value",
                " * @returns value",
                " */",
                "export function getValueFromEvent(e) {",
                "    // support custom element",
                "    if (!e || !e.target) {",
                "        return e;",
                "    }",
                "    const { target } = e;",
                "",
                "    if (target.type === 'checkbox') {",
                "        return target.checked;",
                "    } else if (target.type === 'radio') {",
                "        //兼容原生radioGroup",
                "        if (target.value) {",
                "            return target.value;",
                "        } else {",
                "            return target.checked;",
                "        }",
                "    }",
                "    return target.value;",
                "}",
                "",
                "function cloneAndAddKey(element) {",
                "    if (element && isValidElement(element)) {",
                "        return cloneElement(element, { key: 'error' });",
                "    }",
                "    return element;",
                "}",
                "",
                "export function getErrorStrs(errors) {",
                "    if (errors) {",
                "        return errors.map(function(e) {",
                "            const message = e.message || e;",
                "            return cloneAndAddKey(message);",
                "        });",
                "    }",
                "    return errors;",
                "}",
                "",
                "export function getParams(ns, cb) {",
                "    let names = typeof ns === 'string' ? [ns] : ns;",
                "    let callback = cb;",
                "    if (cb === undefined && typeof names === 'function') {",
                "        callback = names;",
                "        names = undefined;",
                "    }",
                "    return {",
                "        names,",
                "        callback,",
                "    };",
                "}",
                "",
                "const setInWithPath = (state, value, path, pathIndex) => {",
                "    if (pathIndex >= path.length) {",
                "        return value;",
                "    }",
                "",
                "    const first = path[pathIndex];",
                "    const next = setInWithPath(",
                "        state && state[first],",
                "        value,",
                "        path,",
                "        pathIndex + 1",
                "    );",
                "",
                "    if (!state) {",
                "        const initialized = isNaN(first) ? {} : [];",
                "        initialized[first] = next;",
                "        return initialized;",
                "    }",
                "",
                "    if (Array.isArray(state)) {",
                "        const copy = [].concat(state);",
                "        copy[first] = next;",
                "        return copy;",
                "    }",
                "",
                "    return Object.assign({}, state, {",
                "        [first]: next,",
                "    });",
                "};",
                "",
                "export function setIn(state, name, value) {",
                "    return setInWithPath(",
                "        state,",
                "        value,",
                "        name",
                "            .replace(/\\[/, '.')",
                "            .replace(/\\]/, '')",
                "            .split('.'),",
                "        0",
                "    );",
                "}",
                "",
                "export function getIn(state, name) {",
                "    if (!state) {",
                "        return state;",
                "    }",
                "",
                "    const path = name",
                "        .replace(/\\[/, '.')",
                "        .replace(/\\]/, '')",
                "        .split('.');",
                "    const length = path.length;",
                "    if (!length) {",
                "        return undefined;",
                "    }",
                "",
                "    let result = state;",
                "    for (let i = 0; i < length && !!result; ++i) {",
                "        result = result[path[i]];",
                "    }",
                "",
                "    return result;",
                "}",
                "",
                "export function deleteIn(state, name) {",
                "    if (!state) {",
                "        return;",
                "    }",
                "",
                "    const path = name",
                "        .replace(/\\[/, '.')",
                "        .replace(/\\]/, '')",
                "        .split('.');",
                "    const length = path.length;",
                "    if (!length) {",
                "        return state;",
                "    }",
                "",
                "    let result = state;",
                "    for (let i = 0; i < length && !!result; ++i) {",
                "        if (i === length - 1) {",
                "            delete result[path[i]];",
                "        } else {",
                "            result = result[path[i]];",
                "        }",
                "    }",
                "",
                "    return state;",
                "}",
                "",
                "function validateMap(rulesMap, rule, defaultTrigger) {",
                "    const nrule = Object.assign({}, rule);",
                "",
                "    if (!nrule.trigger) {",
                "        nrule.trigger = [defaultTrigger];",
                "    }",
                "",
                "    if (typeof nrule.trigger === 'string') {",
                "        nrule.trigger = [nrule.trigger];",
                "    }",
                "",
                "    for (let i = 0; i < nrule.trigger.length; i++) {",
                "        const trigger = nrule.trigger[i];",
                "",
                "        if (trigger in rulesMap) {",
                "            rulesMap[trigger].push(nrule);",
                "        } else {",
                "            rulesMap[trigger] = [nrule];",
                "        }",
                "    }",
                "",
                "    delete nrule.trigger;",
                "}",
                "",
                "/**",
                " * 提取rule里面的trigger并且做映射",
                " * @param  {Array} rules   规则",
                " * @param  {String} defaultTrigger 默认触发",
                " * @return {Object} {onChange:rule1, onBlur: rule2}",
                " */",
                "export function mapValidateRules(rules, defaultTrigger) {",
                "    const rulesMap = {};",
                "",
                "    rules.forEach(rule => {",
                "        validateMap(rulesMap, rule, defaultTrigger);",
                "    });",
                "",
                "    return rulesMap;",
                "}"
            ]
        }
    }
}