{
    "1/1": "To address the bug described in the report, we need to ensure that the `NumberPicker` component does not allow input beyond the maximum value. The current behavior is that when the input exceeds the maximum value, it does not trigger `onChange`, and the value is corrected on `onBlur`, which can be confusing for users.\n\n### Bug Scenario Analysis\nThe bug report indicates that when the user inputs a value greater than the maximum allowed value, the `onChange` event is not triggered, and the value is only corrected when the input loses focus (`onBlur`). This behavior can lead to confusion as the user might see the value increasing without any effect on the associated price or other dependent values.\n\n### Bug Root Cause\nThe root cause of the issue is that the `onChange` event is not being triggered when the input value exceeds the maximum limit. The correction is only applied during the `onBlur` event, which is not immediate and can lead to a mismatch between the displayed value and the actual value used in calculations.\n\n### Bug Location and Fix\nThe bug is located in the `onChange` method of the `NumberPicker` component. We need to ensure that the `onChange` event is triggered even when the input value exceeds the maximum limit, and the value is corrected immediately.\n\n### Patch\nWe will modify the `onChange` method to trigger the `onChange` event and correct the value immediately if it exceeds the maximum limit.\n\n```javascript\n### src/number-picker/number-picker.jsx\n<<<<<<< SEARCH\n    onChange(value, e) {\n        // ignore space & Compatible Chinese Input Method\n        value = value.replace('。', '.').trim();\n        let onlyDisplay = false;\n        if (this.props.editable === true && this.shouldFireOnChange(value)) {\n            let valueCorrected = this.correctValue(value);\n            if (this.state.value !== valueCorrected) {\n                this.setValue({ value: valueCorrected, e });\n            }\n        } else {\n            onlyDisplay = true;\n        }\n\n        // 【不应支持】如果输入为满足精度要求的纯数字，底层input.value设置为数字类型而非string\n        // if (`${valueCorrected}` === value) value = valueCorrected;\n\n        this.setDisplayValue({ displayValue: value, onlyDisplay });\n    }\n=======\n    onChange(value, e) {\n        // ignore space & Compatible Chinese Input Method\n        value = value.replace('。', '.').trim();\n        let onlyDisplay = false;\n        let valueCorrected = this.correctValue(value);\n        \n        if (this.props.editable === true) {\n            if (this.shouldFireOnChange(valueCorrected)) {\n                if (this.state.value !== valueCorrected) {\n                    this.setValue({ value: valueCorrected, e });\n                }\n            } else {\n                onlyDisplay = true;\n            }\n        }\n\n        this.setDisplayValue({ displayValue: valueCorrected, onlyDisplay });\n    }\n>>>>>>> REPLACE\n```\n\n### Explanation\n- We moved the `valueCorrected` calculation outside the conditional block to ensure it is always calculated.\n- We use `valueCorrected` in the `shouldFireOnChange` check to ensure that the corrected value is used for validation.\n- The `setDisplayValue` method now uses `valueCorrected` to immediately reflect the corrected value in the UI, even if the input exceeds the maximum limit. This ensures that the user sees the corrected value immediately, and the `onChange` event is triggered with the corrected value."
}