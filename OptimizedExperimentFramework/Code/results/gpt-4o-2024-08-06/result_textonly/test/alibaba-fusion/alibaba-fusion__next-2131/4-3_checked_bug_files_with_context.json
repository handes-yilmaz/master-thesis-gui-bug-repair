{
    "src/tree/view/tree.jsx": [
        "...",
        "import TreeNode from './tree-node';",
        "import VirtualList from '../../virtual-list';",
        "import {",
        "    normalizeToArray,",
        "    isDescendantOrSelf,",
        "    isSiblingOrSelf,",
        "    filterChildKey,",
        "    filterParentKey,",
        "    getAllCheckedKeys,",
        "    forEachEnableNode,",
        "    isNodeChecked,",
        "    getAllDescendantKeys,",
        "    convertChildren2Data,",
        "} from './util';",
        "",
        "const { bindCtx, noop } = func;",
        "const { getOffset } = dom;",
        "const { pickOthers, isPlainObject } = obj;",
        "",
        "const getExpandedKeys = (props, willReceiveProps, _k2n, _p2n) => {",
        "    let expandedKeys;",
        "",
        "    if (!willReceiveProps && props.defaultExpandAll) {",
        "        expandedKeys = Object.keys(_k2n).filter(key => {",
        "            const children = _k2n[key].children;",
        "            return children && children.length;",
        "        });",
        "    } else {",
        "        expandedKeys = 'expandedKeys' in props ? props.expandedKeys : willReceiveProps ? [] : props.defaultExpandedKeys;",
        "        expandedKeys = normalizeToArray(expandedKeys);",
        "",
        "        if (props.autoExpandParent) {",
        "            const newExpandedKeys = [];",
        "",
        "            const expandedPoss = expandedKeys.reduce((ret, key) => {",
        "                const pos = _k2n[key] && _k2n[key].pos;",
        "                if (pos) {",
        "                    ret.push(pos);",
        "                    newExpandedKeys.push(key);",
        "                }",
        "                return ret;",
        "            }, []);",
        "",
        "            expandedPoss.forEach(pos => {",
        "                const nums = pos.split('-');",
        "                if (nums.length === 2) {",
        "                    return;",
        "                }",
        "                for (let i = 1; i <= nums.length - 2; i++) {",
        "                    const ancestorPos = nums.slice(0, i + 1).join('-');",
        "                    const ancestorKey = _p2n[ancestorPos].key;",
        "                    if (newExpandedKeys.indexOf(ancestorKey) === -1) {",
        "                        newExpandedKeys.push(ancestorKey);",
        "                    }",
        "                }",
        "            });",
        "",
        "            return newExpandedKeys;",
        "        }",
        "    }",
        "",
        "    return expandedKeys;",
        "};",
        "",
        "const getSelectedKeys = (props, willReceiveProps, _k2n) => {",
        "    let selectedKeys = 'selectedKeys' in props ? props.selectedKeys : willReceiveProps ? [] : props.defaultSelectedKeys;",
        "    selectedKeys = normalizeToArray(selectedKeys);",
        "",
        "    return selectedKeys.filter(key => _k2n[key]);",
        "};",
        "",
        "const getIndeterminateKeys = (checkedKeys, checkStrictly, _k2n, _p2n) => {",
        "    if (checkStrictly) {",
        "        return [];",
        "    }",
        "",
        "    const indeterminateKeys = [];",
        "",
        "    const poss = filterChildKey(",
        "        checkedKeys",
        "            .filter(key => !!_k2n[key])",
        "            .filter(key => !_k2n[key].disabled && !_k2n[key].checkboxDisabled && _k2n[key].checkable !== false),",
        "        _k2n,",
        "        _p2n",
        "    ).map(key => _k2n[key].pos);",
        "",
        "    poss.forEach(pos => {",
        "        const nums = pos.split('-');",
        "        for (let i = nums.length; i > 2; i--) {",
        "            const parentPos = nums.slice(0, i - 1).join('-');",
        "            const parent = _p2n[parentPos];",
        "            if (parent.disabled || parent.checkboxDisabled) break;",
        "            const parentKey = parent.key;",
        "            if (indeterminateKeys.indexOf(parentKey) === -1) {",
        "                indeterminateKeys.push(parentKey);",
        "            }",
        "        }",
        "    });",
        "",
        "    return indeterminateKeys;",
        "};",
        "",
        "const getCheckedKeys = (props, willReceiveProps, _k2n, _p2n) => {",
        "    let checkedKeys = props.defaultCheckedKeys;",
        "    let indeterminateKeys;",
        "",
        "    if ('checkedKeys' in props) {",
        "        checkedKeys = props.checkedKeys;",
        "    } else if (willReceiveProps) {",
        "        checkedKeys = [];",
        "    }",
        "",
        "    const { checkStrictly } = props; // TODO TEST",
        "    if (checkStrictly) {",
        "        if (isPlainObject(checkedKeys)) {",
        "            const { checked, indeterminate } = checkedKeys;",
        "            checkedKeys = normalizeToArray(checked);",
        "            indeterminateKeys = normalizeToArray(indeterminate);",
        "        } else {",
        "            checkedKeys = normalizeToArray(checkedKeys);",
        "        }",
        "",
        "        checkedKeys = checkedKeys.filter(key => !!_k2n[key]);",
        "    } else {",
        "        checkedKeys = getAllCheckedKeys(checkedKeys, _k2n, _p2n);",
        "        checkedKeys = checkedKeys.filter(key => !!_k2n[key]);",
        "",
        "        indeterminateKeys = getIndeterminateKeys(checkedKeys, props.checkStrictly, _k2n, _p2n);",
        "    }",
        "",
        "    return { checkedKeys, indeterminateKeys };",
        "};",
        "",
        "const preHandleData = (dataSource, props) => {",
        "    const k2n = {};",
        "    const p2n = {};",
        "",
        "    const drill = (data = [], level = 1, prefix = '0', parent) =>",
        "        data.map((item, index) => {",
        "            // 为了兼容之前的实现 保留非法节点",
        "            if (item.illegalFlag) {",
        "                return item;",
        "            }",
        "",
        "            const { children } = item;",
        "            const pos = `${prefix}-${index}`;",
        "            let { key } = item;",
        "",
        "            item.pos = pos;",
        "            item.level = level;",
        "",
        "            // 判断为叶子节点",
        "            // - 指定isLeaf属性",
        "            // - loadData模式下 没有指定isLeaf为true",
        "            // - 存在children元素",
        "            if (!('isLeaf' in item)) {",
        "                item.isLeaf = !((children && children.length) || props.loadData);",
        "            }",
        "            item.isLastChild = parent ? [].concat(parent.isLastChild || [], index === data.length - 1) : [];",
        "",
        "            if (key === undefined || key === null) {",
        "                item.key = key = pos;",
        "            }",
        "",
        "            !item.isLeaf && drill(children, level + 1, pos, item);",
        "",
        "            k2n[key] = p2n[pos] = { ...item };",
        "",
        "            return item;",
        "        });",
        "",
        "    return { dataSource: drill(dataSource), k2n, p2n };",
        "};",
        "",
        "const preHandleChildren = props => {",
        "    const k2n = {};",
        "    const p2n = {};",
        "",
        "    const loop = (children, prefix = '0', level = 1) =>",
        "        Children.map(children, (node, index) => {",
        "            if (!React.isValidElement(node)) {",
        "                return;",
        "            }",
        "            const pos = `${prefix}-${index}`;",
        "            let { key } = node;",
        "",
        "            key = key || pos;",
        "",
        "            const item = { ...node.props, key, pos, level };",
        "            const { children } = node.props;",
        "            const hasChildren = children && Children.count(children);",
        "",
        "            if (!('isLeaf' in item)) {",
        "                item.isLeaf = !(hasChildren || props.loadData);",
        "            }",
        "",
        "            if (hasChildren) {",
        "                item.children = loop(children, pos, level + 1);",
        "            }",
        "",
        "            k2n[key] = p2n[pos] = item;",
        "            return item;",
        "        });",
        "    loop(props.children);",
        "",
        "    return { k2n, p2n };",
        "};",
        "",
        "const getData = props => {",
        "    const { dataSource, renderChildNodes, children = [], useVirtual } = props;",
        "    let data = dataSource;",
        "",
        "    if ((renderChildNodes || useVirtual) && !(data && data.length)) {",
        "        data = convertChildren2Data(children);",
        "    }",
        "    return data && data.length ? preHandleData(data, props) : preHandleChildren(props);",
        "};",
        "",
        "/**",
        " * Tree",
        " */",
        "class Tree extends Component {",
        "    static propTypes = {",
        "        prefix: PropTypes.string,",
        "        rtl: PropTypes.bool,",
        "        pure: PropTypes.bool,",
        "        className: PropTypes.string,",
        "        /**",
        "         * 树节点",
        "         */",
        "        children: PropTypes.node,",
        "        /**",
        "         * 数据源，该属性优先级高于 children",
        "         */",
        "        dataSource: PropTypes.array,",
        "        /**",
        "         * 是否显示树的线",
        "         */",
        "        showLine: PropTypes.bool,",
        "        /**",
        "         * 是否支持选中节点",
        "         */",
        "        selectable: PropTypes.bool,",
        "        /**",
        "         * （用于受控）当前选中节点 key 的数组",
        "         */",
        "        selectedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * （用于非受控）默认选中节点 key 的数组",
        "         */",
        "        defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 选中或取消选中节点时触发的回调函数",
        "         * @param {Array} selectedKeys 选中节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Array} extra.selectedNodes 选中节点的数组",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.selected 当前操作是否是选中",
        "         */",
        "        onSelect: PropTypes.func,",
        "        /**",
        "         * 是否支持多选",
        "         */",
        "        multiple: PropTypes.bool,",
        "        /**",
        "         * 是否支持勾选节点的复选框",
        "         */",
        "        checkable: PropTypes.bool,",
        "        /**",
        "         * （用于受控）当前勾选复选框节点 key 的数组或 `{checked: Array, indeterminate: Array}` 的对象",
        "         */",
        "        checkedKeys: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.object]),",
        "        /**",
        "         * （用于非受控）默认勾选复选框节点 key 的数组",
        "         */",
        "        defaultCheckedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 勾选节点复选框是否完全受控（父子节点选中状态不再关联）",
        "         */",
        "        checkStrictly: PropTypes.bool,",
        "        /**",
        "         * 定义选中时回填的方式",
        "         * @enumdesc 返回所有选中的节点, 父子节点都选中时只返回父节点, 父子节点都选中时只返回子节点",
        "         */",
        "        checkedStrategy: PropTypes.oneOf(['all', 'parent', 'child']),",
        "        /**",
        "         * 勾选或取消勾选复选框时触发的回调函数",
        "         * @param {Array} checkedKeys 勾选复选框节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Array} extra.checkedNodes 勾选复选框节点的数组",
        "         * @param {Array} extra.checkedNodesPositions 包含有勾选复选框节点和其位置的对象的数组",
        "         * @param {Array} extra.indeterminateKeys 半选复选框节点 key 的数组",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.checked 当前操作是否是勾选",
        "         */",
        "        onCheck: PropTypes.func,",
        "        /**",
        "         * （用于受控）当前展开的节点 key 的数组",
        "         */",
        "        expandedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * （用于非受控）默认展开的节点 key 的数组",
        "         */",
        "        defaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 是否默认展开所有节点",
        "         */",
        "        defaultExpandAll: PropTypes.bool,",
        "        /**",
        "         * 是否自动展开父节点，建议受控时设置为false",
        "         */",
        "        autoExpandParent: PropTypes.bool,",
        "        /**",
        "         * 展开或收起节点时触发的回调函数",
        "         * @param {Array} expandedKeys 展开的节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.expanded 当前操作是否是展开",
        "         */",
        "        onExpand: PropTypes.func,",
        "        /**",
        "         * 是否支持编辑节点内容",
        "         */",
        "        editable: PropTypes.bool,",
        "        /**",
        "         * 编辑节点内容完成时触发的回调函数",
        "         * @param {String} key 编辑节点的 key",
        "         * @param {String} label 编辑节点完成时节点的文本",
        "         * @param {Object} node 当前编辑的节点",
        "         */",
        "        onEditFinish: PropTypes.func,",
        "        /**",
        "         * 是否支持拖拽节点",
        "         */",
        "        draggable: PropTypes.bool,",
        "        /**",
        "         * 开始拖拽节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 拖拽的节点",
        "         */",
        "        onDragStart: PropTypes.func,",
        "        /**",
        "         * 拖拽节点进入目标节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Array} info.expandedKeys 当前展开的节点key的数组",
        "         */",
        "        onDragEnter: PropTypes.func,",
        "        /**",
        "         * 拖拽节点在目标节点上移动的时候触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragOver: PropTypes.func,",
        "        /**",
        "         * 拖拽节点离开目标节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragLeave: PropTypes.func,",
        "        /**",
        "         * 拖拽节点拖拽结束时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragEnd: PropTypes.func,",
        "        /**",
        "         * 拖拽节点放入目标节点内或前后触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Object} info.dragNode 拖拽的节点",
        "         * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点 key 的数组",
        "         * @param {Number} info.dropPosition 放置位置，-1代表当前节点前，0代表当前节点里，1代表当前节点后",
        "         */",
        "        onDrop: PropTypes.func,",
        "        /**",
        "         * 节点是否可被作为拖拽的目标节点",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Object} info.dragNode 拖拽的节点",
        "         * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点 key 的数组",
        "         * @param {Number} info.dropPosition 放置位置，-1代表当前节点前，0代表当前节点里，1代表当前节点后",
        "         * @return {Boolean} 是否可以被当作目标节点",
        "         */",
        "        canDrop: PropTypes.func,",
        "        /**",
        "         * 异步加载数据的函数",
        "         * @param {Object} node 被点击展开的节点",
        "         */",
        "        loadData: PropTypes.func,",
        "        /**",
        "         * 按需筛选高亮节点",
        "         * @param {Object} node 待筛选的节点",
        "         * @return {Boolean} 是否被筛选中",
        "         */",
        "        filterTreeNode: PropTypes.func,",
        "        /**",
        "         * 右键点击节点时触发的回调函数",
        "         * @param {Object} info 信息对象",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 点击的节点",
        "         */",
        "        onRightClick: PropTypes.func,",
        "        /**",
        "         * 设置节点是否占满剩余空间，一般用于统一在各节点右侧添加元素(借助 flex 实现，暂时只支持 ie10+)",
        "         */",
        "        isLabelBlock: PropTypes.bool,",
        "        /**",
        "         * 设置节点是否占满一行",
        "         */",
        "        isNodeBlock: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),",
        "        /**",
        "         * 是否开启展开收起动画",
        "         */",
        "        animation: PropTypes.bool,",
        "        /**",
        "         * 当前获得焦点的子菜单或菜单项 key 值",
        "         */",
        "        focusedKey: PropTypes.string,",
        "        /**",
        "         * 渲染子节点",
        "         * @param {Array<ReactNode>} nodes 所有的子节点",
        "         * @return {ReactNode} 返回节点",
        "         */",
        "        renderChildNodes: PropTypes.func,",
        "        focusable: PropTypes.bool,",
        "        autoFocus: PropTypes.bool,",
        "        onItemFocus: PropTypes.func,",
        "        onBlur: PropTypes.func,",
        "        onItemKeyDown: PropTypes.func,",
        "        /**",
        "         * 是否开启虚拟滚动",
        "         */",
        "        useVirtual: PropTypes.bool,",
        "    };",
        "",
        "    static defaultProps = {",
        "        prefix: 'next-',",
        "        rtl: false,",
        "        pure: false,",
        "        showLine: false,",
        "        selectable: true,",
        "        editable: false,",
        "        multiple: false,",
        "        checkable: false,",
        "        checkStrictly: false,",
        "        checkedStrategy: 'all',",
        "        draggable: false,",
        "        autoExpandParent: true,",
        "        defaultExpandAll: false,",
        "        defaultExpandedKeys: [],",
        "        defaultCheckedKeys: [],",
        "        defaultSelectedKeys: [],",
        "        onExpand: noop,",
        "        onCheck: noop,",
        "        onSelect: noop,",
        "        onDragStart: noop,",
        "        onDragEnter: noop,",
        "        onDragOver: noop,",
        "        onDragLeave: noop,",
        "        onDragEnd: noop,",
        "        onDrop: noop,",
        "        canDrop: () => true,",
        "        onEditFinish: noop,",
        "        onRightClick: noop,",
        "        isLabelBlock: false,",
        "        isNodeBlock: false,",
        "        animation: true,",
        "        focusable: true,",
        "        autoFocus: false,",
        "        onItemFocus: noop,",
        "        onItemKeyDown: noop,",
        "        useVirtual: false,",
        "    };",
        "",
        "    constructor(props) {",
        "        super(props);",
        "",
        "        const { dataSource = [], k2n, p2n } = getData(props);",
        "        const { focusable, autoFocus, focusedKey } = this.props;",
        "        const willReceiveProps = false;",
        "        const { checkedKeys, indeterminateKeys = [] } = getCheckedKeys(props, willReceiveProps, k2n, p2n);",
        "",
        "        this.state = {",
        "            _k2n: k2n,",
        "            _p2n: p2n,",
        "            dataSource,",
        "            willReceiveProps,",
        "            expandedKeys: getExpandedKeys(props, willReceiveProps, k2n, p2n),",
        "            selectedKeys: getSelectedKeys(props, willReceiveProps, k2n, p2n),",
        "            checkedKeys,",
        "            indeterminateKeys,",
        "        };",
        "",
        "        if (focusable) {",
        "..."
    ],
    "src/tree/view/tree-node.jsx": [
        "...",
        "import TreeNodeInput from './tree-node-input';",
        "import TreeNodeIndent from './tree-node-indent';",
        "",
        "const { Expand } = Animate;",
        "const { bindCtx } = func;",
        "const { isPromise, pickOthers, pickAttrsWith } = obj;",
        "const isRoot = pos => /^0-(\\d)+$/.test(pos);",
        "",
        "/**",
        " * Tree.Node",
        " */",
        "class TreeNode extends Component {",
        "    static propTypes = {",
        "        prefix: PropTypes.string,",
        "        rtl: PropTypes.bool,",
        "        _key: PropTypes.string,",
        "        className: PropTypes.string,",
        "        /**",
        "         * 树节点",
        "         */",
        "        children: PropTypes.node,",
        "        /**",
        "         * 节点文本内容",
        "         */",
        "        label: PropTypes.node,",
        "        /**",
        "         * 单独设置是否支持选中，覆盖 Tree 的 selectable",
        "         */",
        "        selectable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否出现复选框，覆盖 Tree 的 checkable",
        "         */",
        "        checkable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否支持编辑，覆盖 Tree 的 editable",
        "         */",
        "        editable: PropTypes.bool,",
        "        /**",
        "         * 单独设置是否支持拖拽，覆盖 Tree 的 draggable",
        "         */",
        "        draggable: PropTypes.bool,",
        "        /**",
        "         * 是否禁止节点响应",
        "         */",
        "        disabled: PropTypes.bool,",
        "        /**",
        "         * 是否禁止勾选节点复选框",
        "         */",
        "        checkboxDisabled: PropTypes.bool,",
        "        /**",
        "         * 是否是叶子节点，设置loadData时生效",
        "         */",
        "        isLeaf: PropTypes.bool,",
        "        root: PropTypes.object,",
        "        eventKey: PropTypes.string,",
        "        pos: PropTypes.string,",
        "        expanded: PropTypes.bool,",
        "        selected: PropTypes.bool,",
        "        checked: PropTypes.bool,",
        "        indeterminate: PropTypes.bool,",
        "        dragOver: PropTypes.bool,",
        "        dragOverGapTop: PropTypes.bool,",
        "        dragOverGapBottom: PropTypes.bool,",
        "        parentNode: PropTypes.object,",
        "        onKeyDown: PropTypes.func,",
        "        // 无障碍化属性：aria-setsize",
        "        size: PropTypes.number,",
        "        // 无障碍化属性：aria-posinset",
        "        posinset: PropTypes.number,",
        "        // 是否是最后一个子节点，数组类型，包含对祖先节点的判断",
        "        isLastChild: PropTypes.arrayOf(PropTypes.bool),",
        "    };",
        "",
        "    static defaultProps = {",
        "        label: '---',",
        "        rtl: false,",
        "        disabled: false,",
        "        checkboxDisabled: false,",
        "        size: 1,",
        "        posinset: 1,",
        "    };",
        "",
        "    constructor(props) {",
        "        super(props);",
        "",
        "        this.state = {",
        "            editing: false,",
        "            loading: false,",
        "            label: props.label,",
        "        };",
        "",
        "        bindCtx(this, [",
        "            'handleExpand',",
        "            'handleSelect',",
        "            'handleCheck',",
        "            'handleEditStart',",
        "            'handleEditFinish',",
        "            'handleRightClick',",
        "            'handleDragStart',",
        "            'handleDragEnter',",
        "            'handleDragOver',",
        "            'handleDragLeave',",
        "            'handleDragEnd',",
        "            'handleDrop',",
        "            'handleInputKeyDown',",
        "            'handleKeyDown',",
        "        ]);",
        "    }",
        "",
        "    static getDerivedStateFromProps(props) {",
        "        if ('label' in props) {",
        "            return {",
        "                label: props.label,",
        "            };",
        "        }",
        "",
        "        return null;",
        "    }",
        "",
        "    componentDidMount() {",
        "        this.itemNode = findDOMNode(this.nodeEl);",
        "        this.setFocus();",
        "    }",
        "",
        "    componentDidUpdate() {",
        "        this.setFocus();",
        "    }",
        "",
        "    getParentNode() {",
        "        return this.props.root.getParentNode(this.props.pos);",
        "    }",
        "",
        "    focusable() {",
        "        const { root, disabled } = this.props;",
        "        const { focusable } = root.props;",
        "        return focusable && !disabled;",
        "    }",
        "",
        "    getFocused() {",
        "        const { _key, root } = this.props;",
        "        const { focusedKey } = root.state;",
        "        return focusedKey === _key;",
        "    }",
        "",
        "    setFocus() {",
        "        const focused = this.getFocused();",
        "        if (focused && this.focusable()) {",
        "            this.itemNode.focus({ preventScroll: true });",
        "        }",
        "    }",
        "",
        "    handleExpand(e) {",
        "        const { root, expanded, eventKey } = this.props;",
        "",
        "        if (root.props.isNodeBlock) {",
        "            e.stopPropagation();",
        "        }",
        "",
        "        const { loading } = this.state;",
        "        if (loading) {",
        "            return;",
        "        }",
        "",
        "        const returnValue = root.handleExpand(!expanded, eventKey, this);",
        "        if (isPromise(returnValue)) {",
        "            this.setLoading(true);",
        "            return returnValue.then(",
        "                () => {",
        "                    this.setLoading(false);",
        "                },",
        "                () => {",
        "                    this.setLoading(false);",
        "                }",
        "            );",
        "        }",
        "    }",
        "",
        "    setLoading(loading) {",
        "        this.setState({ loading });",
        "    }",
        "",
        "    handleSelect(e) {",
        "        e.preventDefault();",
        "",
        "        const { root, selected, eventKey } = this.props;",
        "        root.handleSelect(!selected, eventKey, this, e);",
        "    }",
        "",
        "    handleCheck() {",
        "        const { root, checked, eventKey } = this.props;",
        "        root.handleCheck(!checked, eventKey, this);",
        "    }",
        "",
        "    handleEditStart(e) {",
        "        e.preventDefault();",
        "",
        "        this.setState({",
        "            editing: true,",
        "        });",
        "    }",
        "",
        "    handleEditFinish(e) {",
        "        const label = e.target.value;",
        "",
        "        this.setState({",
        "            editing: false,",
        "        });",
        "",
        "        const { root, eventKey } = this.props;",
        "        root.props.onEditFinish(eventKey, label, this);",
        "    }",
        "",
        "    handleRightClick(e) {",
        "        this.props.root.props.onRightClick({",
        "            event: e,",
        "            node: this,",
        "        });",
        "    }",
        "",
        "    handleDragStart(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragStart(e, this);",
        "    }",
        "",
        "    handleDragEnter(e) {",
        "        e.preventDefault();",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragEnter(e, this);",
        "    }",
        "",
        "    handleDragOver(e) {",
        "        if (this.props.root.canDrop(this)) {",
        "            e.preventDefault();",
        "",
        "            this.props.root.handleDragOver(e, this);",
        "        }",
        "        e.stopPropagation();",
        "    }",
        "",
        "    handleDragLeave(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragLeave(e, this);",
        "    }",
        "",
        "    handleDragEnd(e) {",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDragEnd(e, this);",
        "    }",
        "",
        "    handleDrop(e) {",
        "        e.preventDefault();",
        "        e.stopPropagation();",
        "",
        "        this.props.root.handleDrop(e, this);",
        "    }",
        "",
        "    handleInputKeyDown(e) {",
        "        if (e.keyCode === KEYCODE.ENTER) {",
        "            this.handleEditFinish(e);",
        "        }",
        "        e.stopPropagation();",
        "    }",
        "",
        "    handleKeyDown(e) {",
        "        const { _key, root, disabled } = this.props;",
        "        if (disabled) {",
        "            return;",
        "        }",
        "",
        "        if (this.focusable()) {",
        "            root.handleItemKeyDown(_key, this, e);",
        "        }",
        "",
        "        this.props.onKeyDown && this.props.onKeyDown(e);",
        "    }",
        "",
        "    addCallbacks(props) {",
        "        const { disabled, root } = this.props;",
        "        if (!disabled) {",
        "            const selectable =",
        "                typeof this.props.selectable !== 'undefined' ? this.props.selectable : root.props.selectable;",
        "            if (selectable) {",
        "                props.onClick = this.handleSelect;",
        "            }",
        "            const editable = typeof this.props.editable !== 'undefined' ? this.props.editable : root.props.editable;",
        "            if (editable) {",
        "                props.onDoubleClick = this.handleEditStart;",
        "            }",
        "            const draggable = typeof this.props.draggable !== 'undefined' ? this.props.draggable : root.props.draggable;",
        "            if (draggable) {",
        "                props.draggable = true;",
        "                props.onDragStart = this.handleDragStart;",
        "                props.onDragEnd = this.handleDragEnd;",
        "            }",
        "            props.onContextMenu = this.handleRightClick;",
        "        }",
        "    }",
        "",
        "    renderSwitcher(showLine) {",
        "        const { prefix, disabled, expanded, root } = this.props;",
        "        const { loadData } = root.props;",
        "        const { loading } = this.state;",
        "",
        "        const lineState = showLine ? 'line' : 'noline';",
        "        const className = cx({",
        "            [`${prefix}tree-switcher`]: true,",
        "            [`${prefix}${lineState}`]: !loading,",
        "            [`${prefix}close`]: !loading && !showLine && !expanded,",
        "            [`${prefix}disabled`]: disabled,",
        "            [`${prefix}loading`]: loading,",
        "            [`${prefix}loading-${lineState}`]: loading,",
        "        });",
        "        const iconType = loadData && loading ? 'loading' : showLine ? (expanded ? 'minus' : 'add') : 'arrow-down';",
        "        const iconCls = cx({",
        "            [`${prefix}tree-switcher-icon`]: true,",
        "            [`${prefix}tree-fold-icon`]: iconType === 'arrow-down',",
        "        });",
        "",
        "        return (",
        "            // eslint-disable-next-line jsx-a11y/click-events-have-key-events",
        "            <span className={className} onClick={disabled ? null : this.handleExpand}>",
        "                {this.renderRightAngle(showLine)}",
        "                <Icon className={iconCls} type={iconType} />",
        "            </span>",
        "        );",
        "    }",
        "",
        "    renderNoopSwitcher(showLine) {",
        "        const { prefix, pos } = this.props;",
        "",
        "        const lineState = showLine ? 'line' : 'noline';",
        "        const className = cx({",
        "            [`${prefix}tree-switcher`]: true,",
        "            [`${prefix}noop-${lineState}`]: true,",
        "            [`${prefix}noop-line-noroot`]: showLine && !isRoot(pos),",
        "        });",
        "",
        "        return <span className={className}>{this.renderRightAngle(showLine)}</span>;",
        "    }",
        "",
        "    renderRightAngle(showLine) {",
        "        const { prefix, pos } = this.props;",
        "",
        "        return showLine && !isRoot(pos) ? <span className={`${prefix}tree-right-angle`} /> : null;",
        "    }",
        "",
        "    renderCheckbox() {",
        "        const { checked, indeterminate, disabled, checkboxDisabled } = this.props;",
        "        const { label } = this.state;",
        "",
        "        return (",
        "            <Checkbox",
        "                aria-label={typeof label === 'string' ? label : null}",
        "                checked={checked}",
        "                tabIndex={-1}",
        "                indeterminate={indeterminate}",
        "                disabled={disabled || checkboxDisabled}",
        "                onChange={this.handleCheck}",
        "            />",
        "        );",
        "    }",
        "",
        "    renderLabel() {",
        "        const { prefix, root, disabled } = this.props;",
        "        const { isNodeBlock } = root.props;",
        "        const { label } = this.state;",
        "        const selectable = typeof this.props.selectable !== 'undefined' ? this.props.selectable : root.props.selectable;",
        "        const labelProps = {",
        "            className: cx({",
        "                [`${prefix}tree-node-label`]: true,",
        "                [`${prefix}tree-node-label-selectable`]: selectable && !disabled,",
        "            }),",
        "        };",
        "",
        "        if (!isNodeBlock) {",
        "            this.addCallbacks(labelProps);",
        "        }",
        "",
        "        return (",
        "            <div className={`${prefix}tree-node-label-wrapper`} ref={this.saveLabelWrapperRef}>",
        "                <div {...labelProps}>{label}</div>",
        "            </div>",
        "        );",
        "    }",
        "",
        "    renderInput() {",
        "        const { prefix } = this.props;",
        "        const { label } = this.state;",
        "        return (",
        "            <div className={`${prefix}tree-node-label-wrapper`} ref={this.saveLabelWrapperRef}>",
        "                <TreeNodeInput",
        "                    prefix={prefix}",
        "                    defaultValue={label}",
        "                    onBlur={this.handleEditFinish}",
        "                    onKeyDown={this.handleInputKeyDown}",
        "                />",
        "            </div>",
        "        );",
        "    }",
        "",
        "    renderChildTree() {",
        "        const { prefix, children } = this.props;",
        "",
        "        return (",
        "            children &&",
        "            this.addAnimationIfNeeded(",
        "                <ul role=\"group\" className={`${prefix}tree-child-tree`}>",
        "                    {children}",
        "                </ul>",
        "            )",
        "        );",
        "    }",
        "",
        "    addAnimationIfNeeded(node) {",
        "        const { root } = this.props;",
        "",
        "        return root && root.props.animation ? <Expand animationAppear={false}>{node}</Expand> : node;",
        "    }",
        "",
        "    saveRef = ref => {",
        "        this.nodeEl = ref;",
        "    };",
        "",
        "    saveLabelWrapperRef = ref => {",
        "        this.labelWrapperEl = ref;",
        "    };",
        "",
        "    render() {",
        "        const {",
        "            prefix,",
        "            rtl,",
        "            className,",
        "            isLeaf,",
        "            level,",
        "            root,",
        "            selected,",
        "            checked,",
        "            disabled,",
        "            dragOver,",
        "            dragOverGapTop,",
        "            dragOverGapBottom,",
        "            _key,",
        "            size,",
        "            posinset,",
        "            children,",
        "            expanded,",
        "            isLastChild,",
        "        } = this.props;",
        "        const { isNodeBlock, showLine, draggable: rootDraggable, filterTreeNode } = root.props;",
        "        const { label } = this.state;",
        "",
        "        const ARIA_PREFIX = 'aria-';",
        "        const ariaProps = pickAttrsWith(this.props, ARIA_PREFIX);",
        "        const others = pickOthers(Object.keys(TreeNode.propTypes), this.props);",
        "",
        "        const hasRenderChildNodes = root && root.props.renderChildNodes;",
        "        const shouldShouldLine = !isNodeBlock && showLine && !hasRenderChildNodes;",
        "        const useVirtual = root && root.props.useVirtual;",
        "",
        "        // remove aria keys",
        "        Object.keys(others).forEach(key => {",
        "            if (key.match(ARIA_PREFIX)) {",
        "                delete others[key];",
        "            }",
        "        });",
        "",
        "        if (rootDraggable) {",
        "            others.onDragEnter = this.handleDragEnter;",
        "            others.onDragOver = this.handleDragOver;",
        "            others.onDragLeave = this.handleDragLeave;",
        "            others.onDrop = this.handleDrop;",
        "        }",
        "        const newClassName = cx({",
        "            [`${prefix}tree-node`]: true,",
        "            [`${prefix}filtered`]: !!filterTreeNode && !!root.filterTreeNode(this),",
        "            [className]: !!className,",
        "        });",
        "",
        "        const innerClassName = cx({",
        "            [`${prefix}tree-node-inner`]: true,",
        "            [`${prefix}selected`]: selected,",
        "            [`${prefix}disabled`]: disabled,",
        "            [`${prefix}drag-over`]: dragOver,",
        "            [`${prefix}drag-over-gap-top`]: dragOverGapTop,",
        "            [`${prefix}drag-over-gap-bottom`]: dragOverGapBottom,",
        "        });",
        "",
        "        const defaultPaddingLeft = typeof isNodeBlock === 'object' ? parseInt(isNodeBlock.defaultPaddingLeft || 0) : 0;",
        "        const paddingLeftProp = rtl ? 'paddingRight' : 'paddingLeft';",
        "",
        "        const indent = typeof isNodeBlock === 'object' ? parseInt(isNodeBlock.indent || 24) : 24;",
        "        const innerStyle = isNodeBlock",
        "            ? {",
        "                  [paddingLeftProp]: `${(useVirtual ? 0 : indent * (level - 1)) + defaultPaddingLeft}px`,",
        "              }",
        "            : null;",
        "",
        "..."
    ],
    "src/tree/view/util.js": [
        "import TreeNode from './tree-node';",
        "",
        "/* eslint-disable valid-jsdoc */",
        "export function normalizeToArray(keys) {",
        "    if (keys !== undefined && keys !== null) {",
        "        if (Array.isArray(keys)) {",
        "            return [...keys];",
        "        }",
        "",
        "        return [keys];",
        "    }",
        "",
        "    return [];",
        "}",
        "",
        "/**",
        " * 判断子节点是否是选中状态，如果 checkable={false} 则向下递归，",
        " * @param {Node} child",
        " * @param {Array} checkedKeys",
        " */",
        "export function isNodeChecked(node, checkedKeys) {",
        "    if (node.disabled || node.checkboxDisabled) return true;",
        "    /* istanbul ignore next */",
        "    if (node.checkable === false) {",
        "        return (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(c => isNodeChecked(c, checkedKeys))",
        "        );",
        "    }",
        "    return checkedKeys.indexOf(node.key) > -1;",
        "}",
        "",
        "/**",
        " * 遍历所有可用的子节点",
        " * @param {Node}",
        " * @param {Function} callback",
        " */",
        "export function forEachEnableNode(node, callback = () => {}) {",
        "    if (node.disabled || node.checkboxDisabled) return;",
        "    // eslint-disable-next-line callback-return",
        "    callback(node);",
        "    if (node.children && node.children.length > 0) {",
        "        node.children.forEach(child => forEachEnableNode(child, callback));",
        "    }",
        "}",
        "/**",
        " * 判断节点是否禁用checked",
        " * @param {Node} node",
        " * @returns {Boolean}",
        " */",
        "export function isNodeDisabledChecked(node) {",
        "    if (node.disabled || node.checkboxDisabled) return true;",
        "    /* istanbul ignore next */",
        "    if (node.checkable === false) {",
        "        return (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(isNodeDisabledChecked)",
        "        );",
        "    }",
        "",
        "    return false;",
        "}",
        "",
        "/**",
        " * 递归获取一个 checkable = {true} 的父节点，当 checkable={false} 时继续往上查找",
        " * @param {Node} node",
        " * @param {Map} _p2n",
        " * @return {Node}",
        " */",
        "export function getCheckableParentNode(node, _p2n) {",
        "    let parentPos = node.pos.split(['-']);",
        "    if (parentPos.length === 2) return node;",
        "    parentPos.splice(parentPos.length - 1, 1);",
        "    parentPos = parentPos.join('-');",
        "    const parentNode = _p2n[parentPos];",
        "    if (parentNode.disabled || parentNode.checkboxDisabled) return false;",
        "    /* istanbul ignore next */",
        "    if (parentNode.checkable === false) {",
        "        return getCheckableParentNode(parentNode, _p2n);",
        "    }",
        "",
        "    return parentNode;",
        "}",
        "/**",
        " * 过滤子节点",
        " * @param {Array} keys",
        " * @param {Object} _k2n",
        " */",
        "export function filterChildKey(keys, _k2n, _p2n) {",
        "    const newKeys = [];",
        "    keys.forEach(key => {",
        "        const node = getCheckableParentNode(_k2n[key], _p2n);",
        "        if (",
        "            !node ||",
        "            node.checkable === false ||",
        "            node === _k2n[key] ||",
        "            keys.indexOf(node.key) === -1",
        "        ) {",
        "            newKeys.push(key);",
        "        }",
        "    });",
        "    return newKeys;",
        "}",
        "",
        "export function filterParentKey(keys, _k2n) {",
        "    const newKeys = [];",
        "",
        "    for (let i = 0; i < keys.length; i++) {",
        "        const node = _k2n[keys[i]];",
        "        if (",
        "            !node.children ||",
        "            node.children.length === 0 ||",
        "            node.children.every(isNodeDisabledChecked)",
        "        ) {",
        "            newKeys.push(keys[i]);",
        "        }",
        "    }",
        "",
        "    return newKeys;",
        "}",
        "",
        "export function isDescendantOrSelf(currentPos, targetPos) {",
        "    if (!currentPos || !targetPos) {",
        "        return false;",
        "    }",
        "",
        "    const currentNums = currentPos.split('-');",
        "    const targetNums = targetPos.split('-');",
        "",
        "    return (",
        "        currentNums.length <= targetNums.length &&",
        "        currentNums.every((num, index) => {",
        "            return num === targetNums[index];",
        "        })",
        "    );",
        "}",
        "",
        "export function isSiblingOrSelf(currentPos, targetPos) {",
        "    const currentNums = currentPos.split('-').slice(0, -1);",
        "    const targetNums = targetPos.split('-').slice(0, -1);",
        "",
        "    return (",
        "        currentNums.length === targetNums.length &&",
        "        currentNums.every((num, index) => {",
        "            return num === targetNums[index];",
        "        })",
        "    );",
        "}",
        "",
        "// eslint-disable-next-line max-statements",
        "export function getAllCheckedKeys(checkedKeys, _k2n, _p2n) {",
        "    checkedKeys = normalizeToArray(checkedKeys);",
        "    const filteredKeys = checkedKeys.filter(key => !!_k2n[key]);",
        "    const flatKeys = [",
        "        ...filterChildKey(filteredKeys, _k2n, _p2n).filter(",
        "            key => !(_k2n[key].disabled || _k2n[key].checkboxDisabled)",
        "        ),",
        "        ...filteredKeys.filter(",
        "            key => _k2n[key].disabled || _k2n[key].checkboxDisabled",
        "        ),",
        "    ];",
        "    const removeKey = child => {",
        "        if (child.disabled || child.checkboxDisabled) return;",
        "        if (",
        "            child.checkable === false &&",
        "            child.children &&",
        "            child.children.length > 0",
        "        ) {",
        "            return child.children.forEach(removeKey);",
        "        }",
        "        flatKeys.splice(flatKeys.indexOf(child.key), 1);",
        "    };",
        "",
        "    const addParentKey = (i, parent) => flatKeys.splice(i, 0, parent.key);",
        "",
        "    const keys = [...flatKeys];",
        "    for (let i = 0; i < keys.length; i++) {",
        "        const pos = _k2n[keys[i]].pos;",
        "        const nums = pos.split('-');",
        "        if (nums.length === 2) {",
        "            break;",
        "        }",
        "        for (let j = nums.length - 2; j > 0; j--) {",
        "            const parentPos = nums.slice(0, j + 1).join('-');",
        "            const parent = _p2n[parentPos];",
        "            if (",
        "                parent.checkable === false ||",
        "                parent.disabled ||",
        "                parent.checkboxDisabled",
        "            )",
        "                continue;",
        "            const parentChecked = parent.children.every(child =>",
        "                isNodeChecked(child, flatKeys)",
        "            );",
        "            if (parentChecked) {",
        "                parent.children.forEach(removeKey);",
        "                addParentKey(i, parent);",
        "            } else {",
        "                break;",
        "            }",
        "        }",
        "    }",
        "",
        "    const newKeys = [];",
        "    flatKeys.forEach(key => {",
        "        if (_k2n[key].disabled || _k2n[key].checkboxDisabled) {",
        "            newKeys.push(key);",
        "            return;",
        "        }",
        "        forEachEnableNode(_k2n[key], node => {",
        "            if (node.checkable === false) return;",
        "            newKeys.push(node.key);",
        "        });",
        "    });",
        "",
        "    return newKeys;",
        "}",
        "",
        "/**",
        " * Convert children of Tree into DataSource",
        " * @param  {React.ReactNode} children",
        " * @return {Array}",
        " */",
        "export function convertChildren2Data(children) {",
        "    function convert(treeNodes) {",
        "        treeNodes = normalizeToArray(treeNodes);",
        "",
        "        return treeNodes",
        "            .map(node => {",
        "                if (",
        "                    node.type &&",
        "                    node.type !== TreeNode &&",
        "                    node.type.target !== TreeNode",
        "                ) {",
        "                    // 为了兼容之前的实现 保留非法节点",
        "                    return {",
        "                        illegalFlag: true,",
        "                        node: node,",
        "                    };",
        "                }",
        "                const {",
        "                    key,",
        "                    props: { children, ...rest },",
        "                } = node;",
        "",
        "                const nodeData = { key, ...rest };",
        "",
        "                if (",
        "                    children &&",
        "                    !(Array.isArray(children) && !children.length)",
        "                ) {",
        "                    nodeData.children = convert(children);",
        "                }",
        "",
        "                return nodeData;",
        "            })",
        "            .filter(treeNodeData => treeNodeData);",
        "    }",
        "    return convert(children);",
        "}",
        "",
        "/**",
        " * get all descendant`s keys of current node",
        " * @param  {Object} nodeData",
        " * @param  {Object} p2n",
        " * @return {Array}",
        " */",
        "export function getAllDescendantKeys(nodeData, p2n) {",
        "    const posList = nodeData.pos.split('-');",
        "    const keys = [];",
        "    let pos = posList[0];",
        "",
        "    for (let i = 1; i < posList.length - 1; i++) {",
        "        pos = [pos, posList[i]].join('-');",
        "        keys.push(p2n[pos].key);",
        "    }",
        "",
        "    return keys;",
        "}"
    ]
}