{
    "bug_classes": {
        "1": {
            "class_name": "Overlay (not found) 56-556",
            "file_path": "src/overlay/overlay.jsx",
            "class_details": [
                {
                    "name": "Overlay",
                    "start_line": 56,
                    "end_line": 556
                }
            ],
            "class_code": [
                " * Overlay",
                " * */",
                "export default class Overlay extends Component {",
                "    static propTypes = {",
                "        prefix: PropTypes.string,",
                "        pure: PropTypes.bool,",
                "        rtl: PropTypes.bool,",
                "        className: PropTypes.string,",
                "        style: PropTypes.object,",
                "        /**",
                "         * 弹层内容",
                "         */",
                "        children: PropTypes.any,",
                "        /**",
                "         * 是否显示弹层",
                "         */",
                "        visible: PropTypes.bool,",
                "        /**",
                "         * 弹层请求关闭时触发事件的回调函数",
                "         * @param {String} type 弹层关闭的来源",
                "         * @param {Object} e DOM 事件",
                "         */",
                "        onRequestClose: PropTypes.func,",
                "        /**",
                "         * 弹层定位的参照元素",
                "         */",
                "        target: PropTypes.any,",
                "        /**",
                "         * 弹层相对于参照元素的定位, 详见开发指南的[定位部分](#定位)",
                "         */",
                "        align: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),",
                "        /**",
                "         * 弹层相对于trigger的定位的微调, 接收数组[hoz, ver], 表示弹层在 left / top 上的增量",
                "         * e.g. [100, 100] 表示往右(RTL 模式下是往左) 、下分布偏移100px",
                "         */",
                "        offset: PropTypes.array,",
                "        /**",
                "         * 渲染组件的容器，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点",
                "         */",
                "        container: PropTypes.any,",
                "        /**",
                "         * 是否显示遮罩",
                "         */",
                "        hasMask: PropTypes.bool,",
                "        /**",
                "         * 是否支持 esc 按键关闭弹层",
                "         */",
                "        canCloseByEsc: PropTypes.bool,",
                "        /**",
                "         * 点击弹层外的区域是否关闭弹层，不显示遮罩时生效",
                "         */",
                "        canCloseByOutSideClick: PropTypes.bool,",
                "        /**",
                "         * 点击遮罩区域是否关闭弹层，显示遮罩时生效",
                "         */",
                "        canCloseByMask: PropTypes.bool,",
                "        /**",
                "         * 弹层打开前触发事件的回调函数",
                "         */",
                "        beforeOpen: PropTypes.func,",
                "        /**",
                "         * 弹层打开时触发事件的回调函数",
                "         */",
                "        onOpen: PropTypes.func,",
                "        /**",
                "         * 弹层打开后触发事件的回调函数, 如果有动画，则在动画结束后触发",
                "         */",
                "        afterOpen: PropTypes.func,",
                "        /**",
                "         * 弹层关闭前触发事件的回调函数",
                "         */",
                "        beforeClose: PropTypes.func,",
                "        /**",
                "         * 弹层关闭时触发事件的回调函数",
                "         */",
                "        onClose: PropTypes.func,",
                "        /**",
                "         * 弹层关闭后触发事件的回调函数, 如果有动画，则在动画结束后触发",
                "         */",
                "        afterClose: PropTypes.func,",
                "        /**",
                "         * 弹层定位完成前触发的事件",
                "         */",
                "        beforePosition: PropTypes.func,",
                "        /**",
                "         * 弹层定位完成时触发的事件",
                "         * @param {Object} config 定位的参数",
                "         * @param {Array} config.align 对齐方式，如 ['cc', 'cc']（如果开启 needAdjust，可能和预先设置的 align 不同）",
                "         * @param {Number} config.top 距离视口顶部距离",
                "         * @param {Number} config.left 距离视口左侧距离",
                "         * @param {Object} node 定位参照的容器节点",
                "         */",
                "        onPosition: PropTypes.func,",
                "        /**",
                "         * 是否在每次弹层重新渲染后强制更新定位信息，一般用于弹层内容区域大小发生变化时，仍需保持原来的定位方式",
                "         */",
                "        shouldUpdatePosition: PropTypes.bool,",
                "        /**",
                "         * 弹层打开时是否让其中的元素自动获取焦点",
                "         */",
                "        autoFocus: PropTypes.bool,",
                "        /**",
                "         * 当弹层由于页面滚动等情况不在可视区域时，是否自动调整定位以出现在可视区域",
                "         */",
                "        needAdjust: PropTypes.bool,",
                "        /**",
                "         * 是否禁用页面滚动",
                "         */",
                "        disableScroll: PropTypes.bool,",
                "        /**",
                "         * 隐藏时是否保留子节点",
                "         */",
                "        cache: PropTypes.bool,",
                "        /**",
                "         * 安全节点，当点击 document 的时候，如果包含该节点则不会关闭弹层，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点，或者以上值组成的数组",
                "         */",
                "        safeNode: PropTypes.any,",
                "        /**",
                "         * 弹层的根节点的样式类",
                "         */",
                "        wrapperClassName: PropTypes.string,",
                "        /**",
                "         * 弹层的根节点的内联样式",
                "         */",
                "        wrapperStyle: PropTypes.object,",
                "        /**",
                "         * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画。 请参考 Animate 组件的文档获取可用的动画名",
                "         * @default { in: 'expandInDown', out: 'expandOutUp' }",
                "         */",
                "        animation: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),",
                "        onMaskMouseEnter: PropTypes.func,",
                "        onMaskMouseLeave: PropTypes.func,",
                "        onClick: PropTypes.func,",
                "    };",
                "",
                "    static defaultProps = {",
                "        prefix: 'next-',",
                "        pure: false,",
                "        visible: false,",
                "        onRequestClose: noop,",
                "        target: Position.VIEWPORT,",
                "        align: 'tl bl',",
                "        offset: [0, 0],",
                "        hasMask: false,",
                "        canCloseByEsc: true,",
                "        canCloseByOutSideClick: true,",
                "        canCloseByMask: true,",
                "        beforeOpen: noop,",
                "        onOpen: noop,",
                "        afterOpen: noop,",
                "        beforeClose: noop,",
                "        onClose: noop,",
                "        afterClose: noop,",
                "        beforePosition: noop,",
                "        onPosition: noop,",
                "        onMaskMouseEnter: noop,",
                "        onMaskMouseLeave: noop,",
                "        shouldUpdatePosition: false,",
                "        autoFocus: false,",
                "        needAdjust: true,",
                "        disableScroll: false,",
                "        cache: false,",
                "        onClick: e => e.stopPropagation(),",
                "    };",
                "",
                "    constructor(props) {",
                "        super(props);",
                "",
                "        this.state = {",
                "            visible: props.visible,",
                "            status: 'none',",
                "            animation: this.getAnimation(props),",
                "        };",
                "",
                "        this.lastAlign = props.align;",
                "",
                "        bindCtx(this, [",
                "            'handlePosition',",
                "            'handleAnimateEnd',",
                "            'handleDocumentKeyDown',",
                "            'handleDocumentClick',",
                "            'handleMaskClick',",
                "            'beforeOpen',",
                "            'beforeClose',",
                "        ]);",
                "",
                "        this.timeoutMap = {};",
                "    }",
                "",
                "    componentWillMount() {",
                "        if (this.props.visible) {",
                "            this.beforeOpen();",
                "            this.props.beforeOpen();",
                "",
                "            if (this.state.animation && support.animation) {",
                "                this.enter();",
                "            }",
                "        }",
                "    }",
                "",
                "    componentDidMount() {",
                "        this.componentDidUpdate({ visible: false });",
                "        this.addDocumentEvents();",
                "",
                "        overlayManager.addOverlay(this);",
                "",
                "        if (this.state.visible) {",
                "            this._isMounted = true;",
                "        }",
                "    }",
                "",
                "    componentWillReceiveProps(nextProps) {",
                "        if (!this._isMounted && nextProps.visible) {",
                "            this._isMounted = true;",
                "        }",
                "",
                "        const willOpen = !this.props.visible && nextProps.visible;",
                "        const willClose = this.props.visible && !nextProps.visible;",
                "        if (willOpen) {",
                "            this.beforeOpen();",
                "            nextProps.beforeOpen();",
                "        } else if (willClose) {",
                "            this.beforeClose();",
                "            nextProps.beforeClose();",
                "        }",
                "",
                "        if (nextProps.animation || nextProps.animation === false) {",
                "            this.setState({",
                "                animation: nextProps.animation,",
                "            });",
                "        }",
                "",
                "        if (nextProps.animation !== false && support.animation) {",
                "            if (willOpen) {",
                "                this.enter();",
                "            } else if (willClose) {",
                "                this.leave();",
                "            }",
                "        } else {",
                "            this.setState({",
                "                visible: nextProps.visible,",
                "            });",
                "        }",
                "    }",
                "",
                "    componentDidUpdate(prevProps) {",
                "        const open = !prevProps.visible && this.props.visible;",
                "        const close = prevProps.visible && !this.props.visible;",
                "        if (this.state.animation && support.animation) {",
                "            if (open || close) {",
                "                this.addAnimationEvents();",
                "            }",
                "        } else {",
                "            const wrapperNode = this.getWrapperNode();",
                "            if (open) {",
                "                setTimeout(() => {",
                "                    this.props.onOpen();",
                "                    this.props.afterOpen();",
                "                    dom.addClass(wrapperNode, 'opened');",
                "                    overlayManager.addOverlay(this);",
                "                });",
                "            } else if (close) {",
                "                this.props.onClose();",
                "                this.props.afterClose();",
                "                dom.removeClass(wrapperNode, 'opened');",
                "                overlayManager.removeOverlay(this);",
                "            }",
                "            this.setFocusNode();",
                "        }",
                "    }",
                "",
                "    componentWillUnmount() {",
                "        this._isDestroyed = true;",
                "        this._isMounted = false;",
                "        overlayManager.removeOverlay(this);",
                "        this.removeDocumentEvents();",
                "        if (this.focusTimeout) {",
                "            clearTimeout(this.focusTimeout);",
                "        }",
                "        if (this._animation) {",
                "            this._animation.off();",
                "            this._animation = null;",
                "        }",
                "        this.beforeClose();",
                "    }",
                "",
                "    getAnimation(props) {",
                "        if (props.animation === false) {",
                "            return false;",
                "        }",
                "",
                "        if (props.animation) {",
                "            return props.animation;",
                "        }",
                "",
                "        return this.getAnimationByAlign(props.align);",
                "    }",
                "",
                "    getAnimationByAlign(align) {",
                "        switch (align[0]) {",
                "            case 't':",
                "                return {",
                "                    in: 'expandInDown',",
                "                    out: 'expandOutUp',",
                "                };",
                "            case 'b':",
                "                return {",
                "                    in: 'expandInUp',",
                "                    out: 'expandOutDown',",
                "                };",
                "            default:",
                "                return {",
                "                    in: 'expandInDown',",
                "                    out: 'expandOutUp',",
                "                };",
                "        }",
                "    }",
                "",
                "    addAnimationEvents() {",
                "        setTimeout(() => {",
                "            const node = this.getContentNode();",
                "            if (node) {",
                "                const id = guid();",
                "",
                "                this._animation = events.on(",
                "                    node,",
                "                    support.animation.end,",
                "                    this.handleAnimateEnd.bind(this, id)",
                "                );",
                "",
                "                const animationDelay =",
                "                    parseFloat(getStyleProperty(node, 'animation-delay')) || 0;",
                "                const animationDuration =",
                "                    parseFloat(getStyleProperty(node, 'animation-duration')) ||",
                "                    0;",
                "                const time = animationDelay + animationDuration;",
                "                if (time) {",
                "                    this.timeoutMap[id] = setTimeout(() => {",
                "                        this.handleAnimateEnd(id);",
                "                    }, time * 1000 + 200);",
                "                }",
                "            }",
                "        });",
                "    }",
                "",
                "    handlePosition(config) {",
                "        const align = config.align.join(' ');",
                "",
                "        if (",
                "            !('animation' in this.props) &&",
                "            this.props.needAdjust &&",
                "            this.lastAlign !== align",
                "        ) {",
                "            this.setState({",
                "                animation: this.getAnimationByAlign(align),",
                "            });",
                "        }",
                "",
                "        this.lastAlign = align;",
                "    }",
                "",
                "    handleAnimateEnd(id) {",
                "        if (this.timeoutMap[id]) {",
                "            clearTimeout(this.timeoutMap[id]);",
                "        }",
                "        delete this.timeoutMap[id];",
                "",
                "        if (this._animation) {",
                "            this._animation.off();",
                "            this._animation = null;",
                "        }",
                "",
                "        if (!this._isMounted) {",
                "            return;",
                "        }",
                "",
                "        if (this.state.status === 'leaving') {",
                "            this.setState({",
                "                visible: false,",
                "                status: 'none',",
                "            });",
                "",
                "            this.onLeaved();",
                "        } else if (this.state.status === 'entering') {",
                "            this.setState({",
                "                status: 'none',",
                "            });",
                "",
                "            this.onEntered();",
                "        }",
                "    }",
                "",
                "    enter() {",
                "        this.setState(",
                "            {",
                "                visible: true,",
                "                status: 'entering',",
                "            },",
                "            () => {",
                "                // NOTE: setState callback (second argument) now fires immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.",
                "                setTimeout(() => {",
                "                    if (!this._isDestroyed) {",
                "                        this.onEntering();",
                "                    }",
                "                });",
                "            }",
                "        );",
                "    }",
                "",
                "    leave() {",
                "        this.setState({",
                "            status: 'leaving',",
                "        });",
                "",
                "        this.onLeaving();",
                "    }",
                "",
                "    onEntering() {",
                "        const wrapperNode = this.getWrapperNode();",
                "        dom.addClass(wrapperNode, 'opened');",
                "        this.props.onOpen();",
                "    }",
                "",
                "    onLeaving() {",
                "        const wrapperNode = this.getWrapperNode();",
                "        dom.removeClass(wrapperNode, 'opened');",
                "        this.props.onClose();",
                "    }",
                "",
                "    onEntered() {",
                "        overlayManager.addOverlay(this);",
                "        this.setFocusNode();",
                "        this.props.afterOpen();",
                "    }",
                "",
                "    onLeaved() {",
                "        overlayManager.removeOverlay(this);",
                "        this.setFocusNode();",
                "        this.props.afterClose();",
                "    }",
                "",
                "    beforeOpen() {",
                "        if (this.props.disableScroll) {",
                "            if (modals.length === 0) {",
                "                const style = {",
                "                    overflowY: 'hidden',",
                "                };",
                "                const body = document.body;",
                "                bodyOverflowY = body.style.overflowY;",
                "                if (hasScroll()) {",
                "                    bodyPaddingRight = body.style.paddingRight;",
                "                    style.paddingRight = `${dom.getStyle(body, 'paddingRight') +",
                "                        dom.scrollbar().width}px`;",
                "                }",
                "",
                "                dom.setStyle(body, style);",
                "            }",
                "            modals.push(this);",
                "        }",
                "    }",
                "",
                "    beforeClose() {",
                "        if (this.props.disableScroll) {",
                "            const index = modals.indexOf(this);",
                "            if (index > -1) {",
                "                if (modals.length === 1) {",
                "                    const style = {",
                "                        overflowY: bodyOverflowY,",
                "                    };",
                "                    if (hasScroll()) {",
                "                        style.paddingRight = bodyPaddingRight;",
                "                    }",
                "",
                "                    dom.setStyle(document.body, style);",
                "",
                "                    bodyOverflowY = undefined;",
                "                    bodyPaddingRight = undefined;",
                "                }",
                "",
                "                modals.splice(index, 1);",
                "            }",
                "        }",
                "    }",
                "",
                "    setFocusNode() {",
                "        if (!this.props.autoFocus) {",
                "            return;",
                "        }",
                "",
                "        if (this.state.visible && !this._hasFocused) {",
                "            saveLastFocusNode();",
                "            // 这个时候很可能上一个弹层的关闭事件还未触发，导致焦点已经回到触发的元素",
                "            // 这里延时处理一下，延时的时间为 document.click 捕获触发的延时时间",
                "            this.focusTimeout = setTimeout(() => {",
                "                const node = this.getContentNode();",
                "                if (node) {",
                "                    const focusNodeList = getFocusNodeList(node);",
                "                    if (focusNodeList.length) {",
                "                        focusNodeList[0].focus();",
                "                    }",
                "                    this._hasFocused = true;"
            ]
        },
        "2": {
            "class_name": "Popup (not found) ",
            "file_path": "src/overlay/popup.jsx",
            "class_details": [
                {
                    "name": "Popup",
                    "start_line": 1,
                    "end_line": 381
                }
            ],
            "class_code": [
                "import React, { Component, Children } from 'react';",
                "import { findDOMNode } from 'react-dom';",
                "import PropTypes from 'prop-types';",
                "import { func, KEYCODE } from '../util';",
                "import Overlay from './overlay';",
                "",
                "const { noop, makeChain, bindCtx } = func;",
                "",
                "/**",
                " * Overlay.Popup",
                " * @description 继承 Overlay 的 API，除非特别说明",
                " * */",
                "export default class Popup extends Component {",
                "    static propTypes = {",
                "        /**",
                "         * 弹层内容",
                "         */",
                "        children: PropTypes.node,",
                "        /**",
                "         * 触发弹层显示或隐藏的元素",
                "         */",
                "        trigger: PropTypes.element,",
                "        /**",
                "         * 触发弹层显示或隐藏的操作类型，可以是 'click'，'hover'，'focus'，或者它们组成的数组，如 ['hover', 'focus']",
                "         */",
                "        triggerType: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),",
                "        /**",
                "         * 当 triggerType 为 click 时才生效，可自定义触发弹层显示的键盘码",
                "         */",
                "",
                "        triggerClickKeycode: PropTypes.oneOfType([",
                "            PropTypes.number,",
                "            PropTypes.array,",
                "        ]),",
                "        /**",
                "         * 弹层当前是否显示",
                "         */",
                "        visible: PropTypes.bool,",
                "        /**",
                "         * 弹层默认是否显示",
                "         */",
                "        defaultVisible: PropTypes.bool,",
                "        /**",
                "         * 弹层显示或隐藏时触发的回调函数",
                "         * @param {Boolean} visible 弹层是否显示",
                "         * @param {String} type 触发弹层显示或隐藏的来源 fromTrigger 表示由trigger的点击触发； docClick 表示由document的点击触发",
                "         * @param {Object} e DOM事件",
                "         */",
                "        onVisibleChange: PropTypes.func,",
                "        /**",
                "         * 设置此属性，弹层无法显示或隐藏",
                "         */",
                "        disabled: PropTypes.bool,",
                "        /**",
                "         * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效",
                "         */",
                "        delay: PropTypes.number,",
                "        /**",
                "         * trigger 是否可以关闭弹层",
                "         */",
                "        canCloseByTrigger: PropTypes.bool,",
                "        /**",
                "         * 弹层定位的参照元素",
                "         * @default target 属性，即触发元素",
                "         */",
                "        target: PropTypes.any,",
                "        safeNode: PropTypes.any,",
                "        /**",
                "         * 是否跟随trigger滚动",
                "         */",
                "        followTrigger: PropTypes.bool,",
                "        container: PropTypes.any,",
                "        hasMask: PropTypes.bool,",
                "        wrapperStyle: PropTypes.object,",
                "        rtl: PropTypes.bool,",
                "    };",
                "",
                "    static defaultProps = {",
                "        triggerType: 'hover',",
                "        triggerClickKeycode: [KEYCODE.SPACE, KEYCODE.ENTER],",
                "        defaultVisible: false,",
                "        onVisibleChange: noop,",
                "        disabled: false,",
                "        delay: 200,",
                "        canCloseByTrigger: true,",
                "        followTrigger: false,",
                "        container: () => document.body,",
                "        rtl: false,",
                "    };",
                "",
                "    constructor(props) {",
                "        super(props);",
                "",
                "        this.state = {",
                "            visible:",
                "                typeof props.visible === 'undefined'",
                "                    ? props.defaultVisible",
                "                    : props.visible,",
                "        };",
                "",
                "        bindCtx(this, [",
                "            'handleTriggerClick',",
                "            'handleTriggerKeyDown',",
                "            'handleTriggerMouseEnter',",
                "            'handleTriggerMouseLeave',",
                "            'handleTriggerFocus',",
                "            'handleTriggerBlur',",
                "            'handleContentMouseEnter',",
                "            'handleContentMouseLeave',",
                "            'handleContentMouseDown',",
                "            'handleRequestClose',",
                "            'handleMaskMouseEnter',",
                "            'handleMaskMouseLeave',",
                "        ]);",
                "    }",
                "",
                "    componentWillReceiveProps(nextProps) {",
                "        if ('visible' in nextProps) {",
                "            this.setState({",
                "                visible: nextProps.visible,",
                "            });",
                "        }",
                "    }",
                "",
                "    componentWillUnmount() {",
                "        ['_timer', '_hideTimer', '_showTimer'].forEach(time => {",
                "            this[time] && clearTimeout(this[time]);",
                "        });",
                "    }",
                "",
                "    handleVisibleChange(visible, type, e) {",
                "        if (!('visible' in this.props)) {",
                "            this.setState({",
                "                visible,",
                "            });",
                "        }",
                "",
                "        this.props.onVisibleChange(visible, type, e);",
                "    }",
                "",
                "    handleTriggerClick(e) {",
                "        if (this.state.visible && !this.props.canCloseByTrigger) {",
                "            return;",
                "        }",
                "",
                "        this.handleVisibleChange(!this.state.visible, 'fromTrigger', e);",
                "    }",
                "",
                "    handleTriggerKeyDown(e) {",
                "        const { triggerClickKeycode } = this.props;",
                "        const keycodes = Array.isArray(triggerClickKeycode)",
                "            ? triggerClickKeycode",
                "            : [triggerClickKeycode];",
                "        if (keycodes.includes(e.keyCode)) {",
                "            e.preventDefault();",
                "            this.handleTriggerClick(e);",
                "        }",
                "    }",
                "",
                "    handleTriggerMouseEnter(e) {",
                "        this._mouseNotFirstOnMask = false;",
                "",
                "        if (this._hideTimer) {",
                "            clearTimeout(this._hideTimer);",
                "            this._hideTimer = null;",
                "        }",
                "        if (this._showTimer) {",
                "            clearTimeout(this._showTimer);",
                "            this._showTimer = null;",
                "        }",
                "        if (!this.state.visible) {",
                "            this._showTimer = setTimeout(() => {",
                "                this.handleVisibleChange(true, 'fromTrigger', e);",
                "            }, this.props.delay);",
                "        }",
                "    }",
                "",
                "    handleTriggerMouseLeave(e, type) {",
                "        if (this._showTimer) {",
                "            clearTimeout(this._showTimer);",
                "            this._showTimer = null;",
                "        }",
                "        if (this.state.visible) {",
                "            this._hideTimer = setTimeout(() => {",
                "                this.handleVisibleChange(false, type || 'fromTrigger', e);",
                "            }, this.props.delay);",
                "        }",
                "    }",
                "",
                "    handleTriggerFocus(e) {",
                "        this.handleVisibleChange(true, 'fromTrigger', e);",
                "    }",
                "",
                "    handleTriggerBlur(e) {",
                "        if (!this._isForwardContent) {",
                "            this.handleVisibleChange(false, 'fromTrigger', e);",
                "        }",
                "        this._isForwardContent = false;",
                "    }",
                "",
                "    handleContentMouseDown() {",
                "        this._isForwardContent = true;",
                "    }",
                "",
                "    handleContentMouseEnter() {",
                "        clearTimeout(this._hideTimer);",
                "    }",
                "",
                "    handleContentMouseLeave(e) {",
                "        this.handleTriggerMouseLeave(e, 'fromContent');",
                "    }",
                "",
                "    handleMaskMouseEnter() {",
                "        if (!this._mouseNotFirstOnMask) {",
                "            clearTimeout(this._hideTimer);",
                "            this._hideTimer = null;",
                "            this._mouseNotFirstOnMask = false;",
                "        }",
                "    }",
                "",
                "    handleMaskMouseLeave() {",
                "        this._mouseNotFirstOnMask = true;",
                "    }",
                "",
                "    handleRequestClose(type, e) {",
                "        this.handleVisibleChange(false, type, e);",
                "    }",
                "",
                "    renderTrigger() {",
                "        const { trigger, disabled } = this.props;",
                "        const props = {",
                "            key: 'trigger',",
                "            'aria-haspopup': true,",
                "            'aria-expanded': this.state.visible,",
                "        };",
                "",
                "        if (!this.state.visible) {",
                "            props['aria-describedby'] = undefined;",
                "        }",
                "",
                "        if (!disabled) {",
                "            const { triggerType } = this.props;",
                "            const triggerTypes = Array.isArray(triggerType)",
                "                ? triggerType",
                "                : [triggerType];",
                "            const {",
                "                onClick,",
                "                onKeyDown,",
                "                onMouseEnter,",
                "                onMouseLeave,",
                "                onFocus,",
                "                onBlur,",
                "            } = trigger.props;",
                "            triggerTypes.forEach(triggerType => {",
                "                switch (triggerType) {",
                "                    case 'click':",
                "                        props.onClick = makeChain(",
                "                            this.handleTriggerClick,",
                "                            onClick",
                "                        );",
                "                        props.onKeyDown = makeChain(",
                "                            this.handleTriggerKeyDown,",
                "                            onKeyDown",
                "                        );",
                "                        break;",
                "                    case 'hover':",
                "                        props.onMouseEnter = makeChain(",
                "                            this.handleTriggerMouseEnter,",
                "                            onMouseEnter",
                "                        );",
                "                        props.onMouseLeave = makeChain(",
                "                            this.handleTriggerMouseLeave,",
                "                            onMouseLeave",
                "                        );",
                "                        break;",
                "                    case 'focus':",
                "                        props.onFocus = makeChain(",
                "                            this.handleTriggerFocus,",
                "                            onFocus",
                "                        );",
                "                        props.onBlur = makeChain(",
                "                            this.handleTriggerBlur,",
                "                            onBlur",
                "                        );",
                "                        break;",
                "                    default:",
                "                        break;",
                "                }",
                "            });",
                "        }",
                "",
                "        return React.cloneElement(trigger, props);",
                "    }",
                "",
                "    renderContent() {",
                "        const { children, triggerType } = this.props;",
                "        const triggerTypes = Array.isArray(triggerType)",
                "            ? triggerType",
                "            : [triggerType];",
                "        const content = Children.only(children);",
                "        const { onMouseDown, onMouseEnter, onMouseLeave } = content.props;",
                "        const props = {",
                "            key: 'portal',",
                "        };",
                "",
                "        triggerTypes.forEach(triggerType => {",
                "            switch (triggerType) {",
                "                case 'focus':",
                "                    props.onMouseDown = makeChain(",
                "                        this.handleContentMouseDown,",
                "                        onMouseDown",
                "                    );",
                "                    break;",
                "                case 'hover':",
                "                    props.onMouseEnter = makeChain(",
                "                        this.handleContentMouseEnter,",
                "                        onMouseEnter",
                "                    );",
                "                    props.onMouseLeave = makeChain(",
                "                        this.handleContentMouseLeave,",
                "                        onMouseLeave",
                "                    );",
                "                    break;",
                "                default:",
                "                    break;",
                "            }",
                "        });",
                "",
                "        return React.cloneElement(content, props);",
                "    }",
                "",
                "    renderPortal() {",
                "        const {",
                "            target,",
                "            safeNode,",
                "            followTrigger,",
                "            triggerType,",
                "            hasMask,",
                "            wrapperStyle,",
                "            ...others",
                "        } = this.props;",
                "        let { container } = this.props;",
                "        const findTriggerNode = () => findDOMNode(this) || {};",
                "        const safeNodes = Array.isArray(safeNode) ? [...safeNode] : [safeNode];",
                "        safeNodes.unshift(findTriggerNode);",
                "",
                "        const newWrapperStyle = wrapperStyle || {};",
                "",
                "        if (followTrigger) {",
                "            container = trigger => (trigger && trigger.parentNode) || trigger;",
                "            newWrapperStyle.position = 'relative';",
                "        }",
                "",
                "        if (triggerType === 'hover' && hasMask) {",
                "            others.onMaskMouseEnter = this.handleMaskMouseEnter;",
                "            others.onMaskMouseLeave = this.handleMaskMouseLeave;",
                "        }",
                "",
                "        return (",
                "            <Overlay",
                "                {...others}",
                "                key=\"overlay\"",
                "                ref={overlay => (this.overlay = overlay)}",
                "                visible={this.state.visible}",
                "                target={target || findTriggerNode}",
                "                container={container}",
                "                safeNode={safeNodes}",
                "                wrapperStyle={newWrapperStyle}",
                "                triggerType={triggerType}",
                "                hasMask={hasMask}",
                "                onRequestClose={this.handleRequestClose}",
                "            >",
                "                {this.renderContent()}",
                "            </Overlay>",
                "        );",
                "    }",
                "",
                "    render() {",
                "        return [this.renderTrigger(), this.renderPortal()];",
                "    }",
                "}"
            ]
        },
        "3": {
            "class_name": "Position (not found) ",
            "file_path": "src/overlay/position.jsx",
            "class_details": [
                {
                    "name": "Position",
                    "start_line": 1,
                    "end_line": 137
                }
            ],
            "class_code": [
                "import { Component, Children } from 'react';",
                "import { findDOMNode } from 'react-dom';",
                "import PropTypes from 'prop-types';",
                "import { func, dom, events } from '../util';",
                "import position from './utils/position';",
                "import findNode from './utils/find-node';",
                "",
                "const { noop, bindCtx } = func;",
                "const { getStyle } = dom;",
                "const place = position.place;",
                "",
                "export default class Position extends Component {",
                "    static VIEWPORT = position.VIEWPORT;",
                "",
                "    static propTypes = {",
                "        children: PropTypes.node,",
                "        target: PropTypes.any,",
                "        align: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),",
                "        offset: PropTypes.array,",
                "        beforePosition: PropTypes.func,",
                "        onPosition: PropTypes.func,",
                "        needAdjust: PropTypes.bool,",
                "        needListenResize: PropTypes.bool,",
                "        shouldUpdatePosition: PropTypes.bool,",
                "        rtl: PropTypes.bool,",
                "    };",
                "",
                "    static defaultProps = {",
                "        align: 'tl bl',",
                "        offset: [0, 0],",
                "        beforePosition: noop,",
                "        onPosition: noop,",
                "        needAdjust: true,",
                "        needListenResize: true,",
                "        shouldUpdatePosition: false,",
                "        rtl: false,",
                "    };",
                "",
                "    constructor(props) {",
                "        super(props);",
                "",
                "        bindCtx(this, ['handleResize']);",
                "    }",
                "",
                "    componentDidMount() {",
                "        this.setPosition();",
                "",
                "        if (this.props.needListenResize) {",
                "            events.on(window, 'resize', this.handleResize);",
                "        }",
                "    }",
                "",
                "    componentWillReceiveProps(nextProps) {",
                "        if (",
                "            ('align' in nextProps && nextProps.align !== this.props.align) ||",
                "            nextProps.shouldUpdatePosition",
                "        ) {",
                "            this.shouldUpdatePosition = true;",
                "        }",
                "    }",
                "",
                "    componentDidUpdate() {",
                "        if (this.shouldUpdatePosition) {",
                "            this.setPosition();",
                "            this.shouldUpdatePosition = false;",
                "        }",
                "    }",
                "",
                "    componentWillUnmount() {",
                "        if (this.props.needListenResize) {",
                "            events.off(window, 'resize', this.handleResize);",
                "        }",
                "",
                "        clearTimeout(this.resizeTimeout);",
                "    }",
                "",
                "    setPosition() {",
                "        const {",
                "            align,",
                "            offset,",
                "            beforePosition,",
                "            onPosition,",
                "            needAdjust,",
                "            rtl,",
                "        } = this.props;",
                "",
                "        beforePosition();",
                "",
                "        const contentNode = this.getContentNode();",
                "        const targetNode = this.getTargetNode();",
                "        if (contentNode && targetNode) {",
                "            const resultAlign = place({",
                "                pinElement: contentNode,",
                "                baseElement: targetNode,",
                "                align,",
                "                offset,",
                "                needAdjust,",
                "                isRtl: rtl,",
                "            });",
                "            const top = getStyle(contentNode, 'top');",
                "            const left = getStyle(contentNode, 'left');",
                "",
                "            onPosition(",
                "                {",
                "                    align: resultAlign.split(' '),",
                "                    top,",
                "                    left,",
                "                },",
                "                contentNode",
                "            );",
                "        }",
                "    }",
                "",
                "    getContentNode() {",
                "        return findDOMNode(this);",
                "    }",
                "",
                "    getTargetNode() {",
                "        const { target } = this.props;",
                "",
                "        return target === position.VIEWPORT",
                "            ? position.VIEWPORT",
                "            : findNode(target, this.props);",
                "    }",
                "",
                "    handleResize() {",
                "        clearTimeout(this.resizeTimeout);",
                "",
                "        this.resizeTimeout = setTimeout(() => {",
                "            this.setPosition();",
                "        }, 200);",
                "    }",
                "",
                "    render() {",
                "        return Children.only(this.props.children);",
                "    }",
                "}"
            ]
        },
        "4": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/number-picker/number-picker.jsx",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "import React from 'react';",
                "import PropTypes from 'prop-types';",
                "import classNames from 'classnames';",
                "import Icon from '../icon';",
                "import Button from '../button';",
                "import Input from '../input';",
                "import ConfigProvider from '../config-provider';",
                "import { func, obj } from '../util';",
                "",
                "/** NumberPicker */",
                "class NumberPicker extends React.Component {",
                "    static propTypes = {",
                "        /**",
                "         * 样式前缀",
                "         */",
                "        prefix: PropTypes.string,",
                "        /**",
                "         * 设置类型",
                "         * @enumdesc 普通, 内联",
                "         */",
                "        type: PropTypes.oneOf(['normal', 'inline']),",
                "        /**",
                "         * 大小",
                "         */",
                "        size: PropTypes.oneOf(['large', 'medium']),",
                "        /**",
                "         * 当前值",
                "         */",
                "        value: PropTypes.number,",
                "        /**",
                "         * 默认值",
                "         */",
                "        defaultValue: PropTypes.number,",
                "        /**",
                "         * 是否禁用",
                "         */",
                "        disabled: PropTypes.bool,",
                "        /**",
                "         * 步长",
                "         */",
                "        step: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),",
                "        /**",
                "         * 保留小数点后位数",
                "         */",
                "        precision: PropTypes.number,",
                "        /**",
                "         * 用户是否可以输入",
                "         */",
                "        editable: PropTypes.bool,",
                "        /**",
                "         * 自动焦点",
                "         */",
                "        autoFocus: PropTypes.bool,",
                "        /**",
                "         * 数值被改变的事件",
                "         * @param {Number} value 数据",
                "         * @param {Event} e DOM事件对象",
                "         */",
                "        onChange: PropTypes.func,",
                "        /**",
                "         * 键盘按下",
                "         */",
                "        onKeyDown: PropTypes.func,",
                "        /**",
                "         * 焦点获得",
                "         */",
                "        onFocus: PropTypes.func,",
                "        /**",
                "         * 焦点失去",
                "         */",
                "        onBlur: PropTypes.func,",
                "        /**",
                "         * 数值订正后的回调",
                "         * @param {Object} obj {currentValue,oldValue:String}",
                "         */",
                "        onCorrect: PropTypes.func,",
                "        onDisabled: PropTypes.func, // 兼容0.x onDisabled",
                "        /**",
                "         * 最大值",
                "         */",
                "        max: PropTypes.number,",
                "        /**",
                "         * 最小值",
                "         */",
                "        min: PropTypes.number,",
                "        /**",
                "         * 自定义class",
                "         */",
                "        className: PropTypes.string,",
                "        /**",
                "         * 自定义内联样式",
                "         */",
                "        style: PropTypes.object,",
                "        state: PropTypes.oneOf(['error']),",
                "        /**",
                "         * 格式化当前值",
                "         * @param {Number} value",
                "         * @return {String|Number}",
                "         */",
                "        format: PropTypes.func,",
                "        /**",
                "         * 增加按钮的props",
                "         */",
                "        upBtnProps: PropTypes.object,",
                "        /**",
                "         * 减少按钮的props",
                "         */",
                "        downBtnProps: PropTypes.object,",
                "        rtl: PropTypes.bool,",
                "    };",
                "",
                "    static defaultProps = {",
                "        prefix: 'next-',",
                "        max: Infinity,",
                "        min: -Infinity,",
                "        type: 'normal',",
                "        size: 'medium',",
                "        step: 1,",
                "        style: {},",
                "        precision: 0,",
                "        editable: true,",
                "        onChange: func.noop,",
                "        onKeyDown: func.noop,",
                "        onBlur: func.noop,",
                "        onCorrect: func.noop,",
                "        onDisabled: func.noop,",
                "    };",
                "",
                "    constructor(props) {",
                "        super(props);",
                "",
                "        let value;",
                "        if ('value' in props) {",
                "            value = props.value;",
                "        } else {",
                "            value = props.defaultValue;",
                "        }",
                "",
                "        this.state = {",
                "            value: typeof value === 'undefined' ? '' : value,",
                "            hasFocused: false,",
                "        };",
                "    }",
                "",
                "    componentWillReceiveProps(nextProps) {",
                "        if ('value' in nextProps) {",
                "            const value = nextProps.value;",
                "            this.setState({",
                "                value: value === undefined || value === null ? '' : value,",
                "            });",
                "        }",
                "    }",
                "",
                "    onChange(value, e) {",
                "        if (this.props.editable === true) {",
                "            value = value.trim();",
                "            // Compatible Chinese Input Method",
                "            value = value.replace('。', '.');",
                "            // ignore space",
                "            if (this.state.value === value) {",
                "                return;",
                "            }",
                "",
                "            // in case of autoCorrect ('0.'=>0, '0.0'=>0) , we have these steps",
                "            if (value) {",
                "                // ignore when input start form '-'",
                "                if (value === '-' || this.state.value === '-') {",
                "                    this.setState({",
                "                        value,",
                "                    });",
                "                    return;",
                "                }",
                "                // ignore when next value = prev value.",
                "                // ps: Number('0.')=0 ; Number('0.0')=0;",
                "                // but take care of Number('')=0;",
                "                if (Number(this.state.value) === Number(value)) {",
                "                    this.setState({",
                "                        value,",
                "                    });",
                "                    return;",
                "                }",
                "                // ignore when value < min (because number is inputted one by one)",
                "                if (!isNaN(value) && Number(value) < this.props.min) {",
                "                    this.setState({",
                "                        value,",
                "                    });",
                "                    return;",
                "                }",
                "            }",
                "",
                "            this.setInputValue(value, e);",
                "        }",
                "    }",
                "",
                "    /**",
                "     * @param {Float} currentValue correct value",
                "     * @param {String} oldValue input value",
                "     */",
                "    onCorrect(currentValue, oldValue) {",
                "        this.props.onCorrect({",
                "            currentValue,",
                "            oldValue,",
                "        });",
                "    }",
                "",
                "    onKeyDown(e, ...args) {",
                "        if (e.keyCode === 38) {",
                "            this.up(e);",
                "        } else if (e.keyCode === 40) {",
                "            this.down(e);",
                "        }",
                "        this.props.onKeyDown(e, ...args);",
                "    }",
                "",
                "    onFocus(e, ...args) {",
                "        const { onFocus } = this.props;",
                "        this.setFocus(true);",
                "        onFocus && onFocus(e, ...args);",
                "    }",
                "",
                "    onBlur(e, ...args) {",
                "        const value = this.getCurrentValidValue(e.target.value.trim());",
                "        if (this.state.value !== value) {",
                "            this.setValue(value, e);",
                "        }",
                "        this.setFocus(false);",
                "        const { onBlur } = this.props;",
                "        onBlur && onBlur(e, ...args);",
                "    }",
                "",
                "    getCurrentValidValue(value) {",
                "        let val = value;",
                "        const props = this.props;",
                "        if (val === '') {",
                "            val = '';",
                "        } else if (!isNaN(val)) {",
                "            val = Number(val);",
                "            if (val < props.min) {",
                "                val = props.min;",
                "            }",
                "            if (val > props.max) {",
                "                val = props.max;",
                "            }",
                "",
                "            // precision=2  and input from 1.99 to 1.999, should stay with 1.99 not 2",
                "            const strValue = `${val}`;",
                "            const pointPos = strValue.indexOf('.');",
                "            const cutPos = pointPos + 1 + this.getPrecision();",
                "            if (pointPos !== -1 && strValue.length > cutPos) {",
                "                val = Number(strValue.substr(0, cutPos));",
                "            }",
                "        } else {",
                "            val = this.state.value;",
                "        }",
                "",
                "        if (`${val}` !== `${value}`) {",
                "            this.onCorrect(val, value);",
                "        }",
                "",
                "        return val;",
                "    }",
                "",
                "    setValue(v, e, triggerType) {",
                "        if (!('value' in this.props)) {",
                "            this.setState({",
                "                value: v,",
                "            });",
                "        }",
                "",
                "        this.props.onChange(isNaN(v) || v === '' ? undefined : v, {",
                "            ...e,",
                "            triggerType,",
                "        });",
                "    }",
                "",
                "    setInputValue(v, e) {",
                "        const value = this.getCurrentValidValue(v);",
                "        if (this.state.value !== value) {",
                "            this.setValue(value, e);",
                "        }",
                "    }",
                "",
                "    setFocus(status) {",
                "        const { format } = this.props;",
                "        // Only trigger `setState` if `format` is settled to avoid unnecessary rendering",
                "        if (typeof format === 'function') {",
                "            this.setState({",
                "                hasFocused: status,",
                "            });",
                "        }",
                "    }",
                "",
                "    getPrecision() {",
                "        const props = this.props;",
                "        const stepString = props.step.toString();",
                "        if (stepString.indexOf('e-') >= 0) {",
                "            return parseInt(stepString.slice(stepString.indexOf('e-')), 10);",
                "        }",
                "        let precision = 0;",
                "        if (stepString.indexOf('.') >= 0) {",
                "            precision = stepString.length - stepString.indexOf('.') - 1;",
                "        }",
                "",
                "        return Math.max(precision, this.props.precision);",
                "    }",
                "",
                "    getPrecisionFactor() {",
                "        const precision = this.getPrecision();",
                "        return Math.pow(10, precision);",
                "    }",
                "",
                "    upStep(val) {",
                "        const { step, min } = this.props;",
                "        const precisionFactor = this.getPrecisionFactor();",
                "        let result;",
                "        if (typeof val === 'number') {",
                "            result =",
                "                (precisionFactor * val + precisionFactor * step) /",
                "                precisionFactor;",
                "",
                "            result = this.hackChrome(result);",
                "        } else {",
                "            result = min === -Infinity ? step : min;",
                "        }",
                "        return result;",
                "    }",
                "",
                "    downStep(val) {",
                "        const { step, min } = this.props;",
                "        const precisionFactor = this.getPrecisionFactor();",
                "        let result;",
                "        if (typeof val === 'number') {",
                "            result =",
                "                (precisionFactor * val - precisionFactor * step) /",
                "                precisionFactor;",
                "",
                "            result = this.hackChrome(result);",
                "        } else {",
                "            result = min === -Infinity ? -step : min;",
                "        }",
                "        return result;",
                "    }",
                "",
                "    /**",
                "     * fix bug in chrome browser",
                "     * 0.28 + 0.01 = 0.29000000000000004",
                "     * 0.29 - 0.01 = 0.27999999999999997",
                "     * @param {Number} value value",
                "     */",
                "    hackChrome(value) {",
                "        const precision = this.getPrecision();",
                "        if (precision > 0) {",
                "            return Number(Number(value).toFixed(precision));",
                "        }",
                "        return value;",
                "    }",
                "",
                "    step(type, disabled, e) {",
                "        if (e) {",
                "            e.preventDefault();",
                "        }",
                "",
                "        const { onDisabled, min, max } = this.props;",
                "        if (disabled) {",
                "            return onDisabled(e);",
                "        }",
                "",
                "        const value = this.state.value;",
                "        if (isNaN(value)) {",
                "            return;",
                "        }",
                "",
                "        let val = this[`${type}Step`](value);",
                "        if (val > max) {",
                "            val = max;",
                "        }",
                "        if (val < min) {",
                "            val = min;",
                "        }",
                "        this.setValue(val, e, type);",
                "    }",
                "",
                "    down(disabled, e) {",
                "        this.step('down', disabled, e);",
                "    }",
                "",
                "    up(disabled, e) {",
                "        this.step('up', disabled, e);",
                "    }",
                "",
                "    renderValue() {",
                "        const { value, hasFocused } = this.state;",
                "        const { format } = this.props;",
                "        return typeof format === 'function' && !hasFocused",
                "            ? format(value)",
                "            : value;",
                "    }",
                "",
                "    focus() {",
                "        this.inputRef.getInstance().focus();",
                "    }",
                "",
                "    saveInputRef(ref) {",
                "        this.inputRef = ref;",
                "    }",
                "",
                "    handleMouseDown(e) {",
                "        e.preventDefault();",
                "    }",
                "",
                "    render() {",
                "        const {",
                "            type,",
                "            prefix,",
                "            rtl,",
                "            disabled,",
                "            style,",
                "            className,",
                "            size,",
                "            max,",
                "            min,",
                "            autoFocus,",
                "            editable,",
                "            state,",
                "            upBtnProps = {},",
                "            downBtnProps = {},",
                "        } = this.props;",
                "",
                "        const prefixCls = `${prefix}number-picker`;",
                "",
                "        const cls = classNames({",
                "            [prefixCls]: true,",
                "            [`${prefixCls}-${this.props.type}`]: this.props.type,",
                "            [`${prefix}${size}`]: true,",
                "            [className]: className,",
                "        });",
                "",
                "        let upDisabled = false;",
                "        let downDisabled = false;",
                "        const value = this.state.value;",
                "        if (!isNaN(value)) {",
                "            const val = Number(value);",
                "            if (val >= max) {",
                "                upDisabled = true;",
                "            }",
                "            if (val <= min) {",
                "                downDisabled = true;",
                "            }",
                "        }",
                "",
                "        let innerAfter = null,",
                "            innerAfterClassName = null,",
                "            addonBefore = null,",
                "            addonAfter = null;",
                "        if (type === 'normal') {",
                "            innerAfter = [",
                "                <Button",
                "                    {...upBtnProps}",
                "                    onMouseDown={this.handleMouseDown}",
                "                    disabled={disabled}",
                "                    className={`${upBtnProps.className || ''} ${",
                "                        upDisabled ? 'disabled' : ''",
                "                    }`}",
                "                    onClick={this.up.bind(this, upDisabled)}",
                "                    key=\"0\"",
                "                >",
                "                    <Icon size=\"xxs\" type=\"arrow-up\" />",
                "                </Button>,",
                "                <Button",
                "                    {...downBtnProps}",
                "                    onMouseDown={this.handleMouseDown}",
                "                    disabled={disabled}",
                "                    className={`${downBtnProps.className || ''} ${",
                "                        downDisabled ? 'disabled' : ''",
                "                    }`}",
                "                    onClick={this.down.bind(this, downDisabled)}",
                "                    key=\"1\"",
                "                >",
                "                    <Icon size=\"xxs\" type=\"arrow-down\" />",
                "                </Button>,",
                "            ];",
                "            innerAfterClassName = `${prefixCls}-handler`;",
                "        } else {",
                "            addonBefore = (",
                "                <Button",
                "                    {...downBtnProps}",
                "                    size={size}",
                "                    disabled={disabled}",
                "                    className={`${downBtnProps.className || ''} ${",
                "                        downDisabled ? 'disabled' : ''",
                "                    }`}",
                "                    onClick={this.down.bind(this, downDisabled)}",
                "                >",
                "                    <Icon type=\"minus\" size=\"xs\" />",
                "                </Button>",
                "            );",
                "            addonAfter = (",
                "                <Button",
                "                    {...upBtnProps}",
                "                    size={size}",
                "                    disabled={disabled}"
            ]
        },
        "5": {
            "class_name": "NumberPicker (not found) 10-510",
            "file_path": "src/number-picker/number-picker.jsx",
            "class_details": [
                {
                    "name": "NumberPicker",
                    "start_line": 10,
                    "end_line": 510
                }
            ],
            "class_code": [
                "/** NumberPicker */",
                "class NumberPicker extends React.Component {",
                "    static propTypes = {",
                "        /**",
                "         * 样式前缀",
                "         */",
                "        prefix: PropTypes.string,",
                "        /**",
                "         * 设置类型",
                "         * @enumdesc 普通, 内联",
                "         */",
                "        type: PropTypes.oneOf(['normal', 'inline']),",
                "        /**",
                "         * 大小",
                "         */",
                "        size: PropTypes.oneOf(['large', 'medium']),",
                "        /**",
                "         * 当前值",
                "         */",
                "        value: PropTypes.number,",
                "        /**",
                "         * 默认值",
                "         */",
                "        defaultValue: PropTypes.number,",
                "        /**",
                "         * 是否禁用",
                "         */",
                "        disabled: PropTypes.bool,",
                "        /**",
                "         * 步长",
                "         */",
                "        step: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),",
                "        /**",
                "         * 保留小数点后位数",
                "         */",
                "        precision: PropTypes.number,",
                "        /**",
                "         * 用户是否可以输入",
                "         */",
                "        editable: PropTypes.bool,",
                "        /**",
                "         * 自动焦点",
                "         */",
                "        autoFocus: PropTypes.bool,",
                "        /**",
                "         * 数值被改变的事件",
                "         * @param {Number} value 数据",
                "         * @param {Event} e DOM事件对象",
                "         */",
                "        onChange: PropTypes.func,",
                "        /**",
                "         * 键盘按下",
                "         */",
                "        onKeyDown: PropTypes.func,",
                "        /**",
                "         * 焦点获得",
                "         */",
                "        onFocus: PropTypes.func,",
                "        /**",
                "         * 焦点失去",
                "         */",
                "        onBlur: PropTypes.func,",
                "        /**",
                "         * 数值订正后的回调",
                "         * @param {Object} obj {currentValue,oldValue:String}",
                "         */",
                "        onCorrect: PropTypes.func,",
                "        onDisabled: PropTypes.func, // 兼容0.x onDisabled",
                "        /**",
                "         * 最大值",
                "         */",
                "        max: PropTypes.number,",
                "        /**",
                "         * 最小值",
                "         */",
                "        min: PropTypes.number,",
                "        /**",
                "         * 自定义class",
                "         */",
                "        className: PropTypes.string,",
                "        /**",
                "         * 自定义内联样式",
                "         */",
                "        style: PropTypes.object,",
                "        state: PropTypes.oneOf(['error']),",
                "        /**",
                "         * 格式化当前值",
                "         * @param {Number} value",
                "         * @return {String|Number}",
                "         */",
                "        format: PropTypes.func,",
                "        /**",
                "         * 增加按钮的props",
                "         */",
                "        upBtnProps: PropTypes.object,",
                "        /**",
                "         * 减少按钮的props",
                "         */",
                "        downBtnProps: PropTypes.object,",
                "        rtl: PropTypes.bool,",
                "    };",
                "",
                "    static defaultProps = {",
                "        prefix: 'next-',",
                "        max: Infinity,",
                "        min: -Infinity,",
                "        type: 'normal',",
                "        size: 'medium',",
                "        step: 1,",
                "        style: {},",
                "        precision: 0,",
                "        editable: true,",
                "        onChange: func.noop,",
                "        onKeyDown: func.noop,",
                "        onBlur: func.noop,",
                "        onCorrect: func.noop,",
                "        onDisabled: func.noop,",
                "    };",
                "",
                "    constructor(props) {",
                "        super(props);",
                "",
                "        let value;",
                "        if ('value' in props) {",
                "            value = props.value;",
                "        } else {",
                "            value = props.defaultValue;",
                "        }",
                "",
                "        this.state = {",
                "            value: typeof value === 'undefined' ? '' : value,",
                "            hasFocused: false,",
                "        };",
                "    }",
                "",
                "    componentWillReceiveProps(nextProps) {",
                "        if ('value' in nextProps) {",
                "            const value = nextProps.value;",
                "            this.setState({",
                "                value: value === undefined || value === null ? '' : value,",
                "            });",
                "        }",
                "    }",
                "",
                "    onChange(value, e) {",
                "        if (this.props.editable === true) {",
                "            value = value.trim();",
                "            // Compatible Chinese Input Method",
                "            value = value.replace('。', '.');",
                "            // ignore space",
                "            if (this.state.value === value) {",
                "                return;",
                "            }",
                "",
                "            // in case of autoCorrect ('0.'=>0, '0.0'=>0) , we have these steps",
                "            if (value) {",
                "                // ignore when input start form '-'",
                "                if (value === '-' || this.state.value === '-') {",
                "                    this.setState({",
                "                        value,",
                "                    });",
                "                    return;",
                "                }",
                "                // ignore when next value = prev value.",
                "                // ps: Number('0.')=0 ; Number('0.0')=0;",
                "                // but take care of Number('')=0;",
                "                if (Number(this.state.value) === Number(value)) {",
                "                    this.setState({",
                "                        value,",
                "                    });",
                "                    return;",
                "                }",
                "                // ignore when value < min (because number is inputted one by one)",
                "                if (!isNaN(value) && Number(value) < this.props.min) {",
                "                    this.setState({",
                "                        value,",
                "                    });",
                "                    return;",
                "                }",
                "            }",
                "",
                "            this.setInputValue(value, e);",
                "        }",
                "    }",
                "",
                "    /**",
                "     * @param {Float} currentValue correct value",
                "     * @param {String} oldValue input value",
                "     */",
                "    onCorrect(currentValue, oldValue) {",
                "        this.props.onCorrect({",
                "            currentValue,",
                "            oldValue,",
                "        });",
                "    }",
                "",
                "    onKeyDown(e, ...args) {",
                "        if (e.keyCode === 38) {",
                "            this.up(e);",
                "        } else if (e.keyCode === 40) {",
                "            this.down(e);",
                "        }",
                "        this.props.onKeyDown(e, ...args);",
                "    }",
                "",
                "    onFocus(e, ...args) {",
                "        const { onFocus } = this.props;",
                "        this.setFocus(true);",
                "        onFocus && onFocus(e, ...args);",
                "    }",
                "",
                "    onBlur(e, ...args) {",
                "        const value = this.getCurrentValidValue(e.target.value.trim());",
                "        if (this.state.value !== value) {",
                "            this.setValue(value, e);",
                "        }",
                "        this.setFocus(false);",
                "        const { onBlur } = this.props;",
                "        onBlur && onBlur(e, ...args);",
                "    }",
                "",
                "    getCurrentValidValue(value) {",
                "        let val = value;",
                "        const props = this.props;",
                "        if (val === '') {",
                "            val = '';",
                "        } else if (!isNaN(val)) {",
                "            val = Number(val);",
                "            if (val < props.min) {",
                "                val = props.min;",
                "            }",
                "            if (val > props.max) {",
                "                val = props.max;",
                "            }",
                "",
                "            // precision=2  and input from 1.99 to 1.999, should stay with 1.99 not 2",
                "            const strValue = `${val}`;",
                "            const pointPos = strValue.indexOf('.');",
                "            const cutPos = pointPos + 1 + this.getPrecision();",
                "            if (pointPos !== -1 && strValue.length > cutPos) {",
                "                val = Number(strValue.substr(0, cutPos));",
                "            }",
                "        } else {",
                "            val = this.state.value;",
                "        }",
                "",
                "        if (`${val}` !== `${value}`) {",
                "            this.onCorrect(val, value);",
                "        }",
                "",
                "        return val;",
                "    }",
                "",
                "    setValue(v, e, triggerType) {",
                "        if (!('value' in this.props)) {",
                "            this.setState({",
                "                value: v,",
                "            });",
                "        }",
                "",
                "        this.props.onChange(isNaN(v) || v === '' ? undefined : v, {",
                "            ...e,",
                "            triggerType,",
                "        });",
                "    }",
                "",
                "    setInputValue(v, e) {",
                "        const value = this.getCurrentValidValue(v);",
                "        if (this.state.value !== value) {",
                "            this.setValue(value, e);",
                "        }",
                "    }",
                "",
                "    setFocus(status) {",
                "        const { format } = this.props;",
                "        // Only trigger `setState` if `format` is settled to avoid unnecessary rendering",
                "        if (typeof format === 'function') {",
                "            this.setState({",
                "                hasFocused: status,",
                "            });",
                "        }",
                "    }",
                "",
                "    getPrecision() {",
                "        const props = this.props;",
                "        const stepString = props.step.toString();",
                "        if (stepString.indexOf('e-') >= 0) {",
                "            return parseInt(stepString.slice(stepString.indexOf('e-')), 10);",
                "        }",
                "        let precision = 0;",
                "        if (stepString.indexOf('.') >= 0) {",
                "            precision = stepString.length - stepString.indexOf('.') - 1;",
                "        }",
                "",
                "        return Math.max(precision, this.props.precision);",
                "    }",
                "",
                "    getPrecisionFactor() {",
                "        const precision = this.getPrecision();",
                "        return Math.pow(10, precision);",
                "    }",
                "",
                "    upStep(val) {",
                "        const { step, min } = this.props;",
                "        const precisionFactor = this.getPrecisionFactor();",
                "        let result;",
                "        if (typeof val === 'number') {",
                "            result =",
                "                (precisionFactor * val + precisionFactor * step) /",
                "                precisionFactor;",
                "",
                "            result = this.hackChrome(result);",
                "        } else {",
                "            result = min === -Infinity ? step : min;",
                "        }",
                "        return result;",
                "    }",
                "",
                "    downStep(val) {",
                "        const { step, min } = this.props;",
                "        const precisionFactor = this.getPrecisionFactor();",
                "        let result;",
                "        if (typeof val === 'number') {",
                "            result =",
                "                (precisionFactor * val - precisionFactor * step) /",
                "                precisionFactor;",
                "",
                "            result = this.hackChrome(result);",
                "        } else {",
                "            result = min === -Infinity ? -step : min;",
                "        }",
                "        return result;",
                "    }",
                "",
                "    /**",
                "     * fix bug in chrome browser",
                "     * 0.28 + 0.01 = 0.29000000000000004",
                "     * 0.29 - 0.01 = 0.27999999999999997",
                "     * @param {Number} value value",
                "     */",
                "    hackChrome(value) {",
                "        const precision = this.getPrecision();",
                "        if (precision > 0) {",
                "            return Number(Number(value).toFixed(precision));",
                "        }",
                "        return value;",
                "    }",
                "",
                "    step(type, disabled, e) {",
                "        if (e) {",
                "            e.preventDefault();",
                "        }",
                "",
                "        const { onDisabled, min, max } = this.props;",
                "        if (disabled) {",
                "            return onDisabled(e);",
                "        }",
                "",
                "        const value = this.state.value;",
                "        if (isNaN(value)) {",
                "            return;",
                "        }",
                "",
                "        let val = this[`${type}Step`](value);",
                "        if (val > max) {",
                "            val = max;",
                "        }",
                "        if (val < min) {",
                "            val = min;",
                "        }",
                "        this.setValue(val, e, type);",
                "    }",
                "",
                "    down(disabled, e) {",
                "        this.step('down', disabled, e);",
                "    }",
                "",
                "    up(disabled, e) {",
                "        this.step('up', disabled, e);",
                "    }",
                "",
                "    renderValue() {",
                "        const { value, hasFocused } = this.state;",
                "        const { format } = this.props;",
                "        return typeof format === 'function' && !hasFocused",
                "            ? format(value)",
                "            : value;",
                "    }",
                "",
                "    focus() {",
                "        this.inputRef.getInstance().focus();",
                "    }",
                "",
                "    saveInputRef(ref) {",
                "        this.inputRef = ref;",
                "    }",
                "",
                "    handleMouseDown(e) {",
                "        e.preventDefault();",
                "    }",
                "",
                "    render() {",
                "        const {",
                "            type,",
                "            prefix,",
                "            rtl,",
                "            disabled,",
                "            style,",
                "            className,",
                "            size,",
                "            max,",
                "            min,",
                "            autoFocus,",
                "            editable,",
                "            state,",
                "            upBtnProps = {},",
                "            downBtnProps = {},",
                "        } = this.props;",
                "",
                "        const prefixCls = `${prefix}number-picker`;",
                "",
                "        const cls = classNames({",
                "            [prefixCls]: true,",
                "            [`${prefixCls}-${this.props.type}`]: this.props.type,",
                "            [`${prefix}${size}`]: true,",
                "            [className]: className,",
                "        });",
                "",
                "        let upDisabled = false;",
                "        let downDisabled = false;",
                "        const value = this.state.value;",
                "        if (!isNaN(value)) {",
                "            const val = Number(value);",
                "            if (val >= max) {",
                "                upDisabled = true;",
                "            }",
                "            if (val <= min) {",
                "                downDisabled = true;",
                "            }",
                "        }",
                "",
                "        let innerAfter = null,",
                "            innerAfterClassName = null,",
                "            addonBefore = null,",
                "            addonAfter = null;",
                "        if (type === 'normal') {",
                "            innerAfter = [",
                "                <Button",
                "                    {...upBtnProps}",
                "                    onMouseDown={this.handleMouseDown}",
                "                    disabled={disabled}",
                "                    className={`${upBtnProps.className || ''} ${",
                "                        upDisabled ? 'disabled' : ''",
                "                    }`}",
                "                    onClick={this.up.bind(this, upDisabled)}",
                "                    key=\"0\"",
                "                >",
                "                    <Icon size=\"xxs\" type=\"arrow-up\" />",
                "                </Button>,",
                "                <Button",
                "                    {...downBtnProps}",
                "                    onMouseDown={this.handleMouseDown}",
                "                    disabled={disabled}",
                "                    className={`${downBtnProps.className || ''} ${",
                "                        downDisabled ? 'disabled' : ''",
                "                    }`}",
                "                    onClick={this.down.bind(this, downDisabled)}",
                "                    key=\"1\"",
                "                >",
                "                    <Icon size=\"xxs\" type=\"arrow-down\" />",
                "                </Button>,",
                "            ];",
                "            innerAfterClassName = `${prefixCls}-handler`;",
                "        } else {",
                "            addonBefore = (",
                "                <Button",
                "                    {...downBtnProps}",
                "                    size={size}",
                "                    disabled={disabled}",
                "                    className={`${downBtnProps.className || ''} ${",
                "                        downDisabled ? 'disabled' : ''",
                "                    }`}",
                "                    onClick={this.down.bind(this, downDisabled)}",
                "                >",
                "                    <Icon type=\"minus\" size=\"xs\" />",
                "                </Button>",
                "            );",
                "            addonAfter = (",
                "                <Button",
                "                    {...upBtnProps}",
                "                    size={size}",
                "                    disabled={disabled}",
                "                    className={`${upBtnProps.className || ''} ${",
                "                        upDisabled ? 'disabled' : ''",
                "                    }`}",
                "                    onClick={this.up.bind(this, upDisabled)}",
                "                >",
                "                    <Icon type=\"add\" size=\"xs\" />",
                "                </Button>",
                "            );",
                "        }"
            ]
        }
    },
    "bug_functions": {}
}