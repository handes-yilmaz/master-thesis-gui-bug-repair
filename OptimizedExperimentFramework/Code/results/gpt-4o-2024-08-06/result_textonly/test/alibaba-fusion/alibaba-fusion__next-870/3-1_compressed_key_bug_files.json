{
    "1": {
        "bug_file": "src/overlay/overlay.jsx",
        "compressed": "YES",
        "line_numbers": 790,
        "compressed_line_numbers": 159,
        "compressed_bug_file_content": "import React, { Component, Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport { dom, events, func, support, focus, KEYCODE, guid } from '../util';\nimport overlayManager from './manager';\nimport Gateway from './gateway';\nimport Position from './position';\nimport findNode from './utils/find-node';\n\n\n        // ignore error for firefox\n\n\n/**\n * Overlay\n * */\nexport default class Overlay extends Component {\n\n\n        /**\n         * 弹层内容\n         */\n\n        /**\n         * 是否显示弹层\n         */\n\n        /**\n         * 弹层请求关闭时触发事件的回调函数\n         * @param {String} type 弹层关闭的来源\n         * @param {Object} e DOM 事件\n         */\n\n        /**\n         * 弹层定位的参照元素\n         */\n\n        /**\n         * 弹层相对于参照元素的定位, 详见开发指南的[定位部分](#定位)\n         */\n\n        /**\n         * 弹层相对于trigger的定位的微调, 接收数组[hoz, ver], 表示弹层在 left / top 上的增量\n         * e.g. [100, 100] 表示往右(RTL 模式下是往左) 、下分布偏移100px\n         */\n\n        /**\n         * 渲染组件的容器，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点\n         */\n\n        /**\n         * 是否显示遮罩\n         */\n\n        /**\n         * 是否支持 esc 按键关闭弹层\n         */\n\n        /**\n         * 点击弹层外的区域是否关闭弹层，不显示遮罩时生效\n         */\n\n        /**\n         * 点击遮罩区域是否关闭弹层，显示遮罩时生效\n         */\n\n        /**\n         * 弹层打开前触发事件的回调函数\n         */\n\n        /**\n         * 弹层打开时触发事件的回调函数\n         */\n\n        /**\n         * 弹层打开后触发事件的回调函数, 如果有动画，则在动画结束后触发\n         */\n\n        /**\n         * 弹层关闭前触发事件的回调函数\n         */\n\n        /**\n         * 弹层关闭时触发事件的回调函数\n         */\n\n        /**\n         * 弹层关闭后触发事件的回调函数, 如果有动画，则在动画结束后触发\n         */\n\n        /**\n         * 弹层定位完成前触发的事件\n         */\n\n        /**\n         * 弹层定位完成时触发的事件\n         * @param {Object} config 定位的参数\n         * @param {Array} config.align 对齐方式，如 ['cc', 'cc']（如果开启 needAdjust，可能和预先设置的 align 不同）\n         * @param {Number} config.top 距离视口顶部距离\n         * @param {Number} config.left 距离视口左侧距离\n         * @param {Object} node 定位参照的容器节点\n         */\n\n        /**\n         * 是否在每次弹层重新渲染后强制更新定位信息，一般用于弹层内容区域大小发生变化时，仍需保持原来的定位方式\n         */\n\n        /**\n         * 弹层打开时是否让其中的元素自动获取焦点\n         */\n\n        /**\n         * 当弹层由于页面滚动等情况不在可视区域时，是否自动调整定位以出现在可视区域\n         */\n\n        /**\n         * 是否禁用页面滚动\n         */\n\n        /**\n         * 隐藏时是否保留子节点\n         */\n\n        /**\n         * 安全节点，当点击 document 的时候，如果包含该节点则不会关闭弹层，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点，或者以上值组成的数组\n         */\n\n        /**\n         * 弹层的根节点的样式类\n         */\n\n        /**\n         * 弹层的根节点的内联样式\n         */\n\n        /**\n         * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画。 请参考 Animate 组件的文档获取可用的动画名\n         * @default { in: 'expandInDown', out: 'expandOutUp' }\n         */\n\n\n                // NOTE: setState callback (second argument) now fires immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.\n\n\n            // 这个时候很可能上一个弹层的关闭事件还未触发，导致焦点已经回到触发的元素\n            // 这里延时处理一下，延时的时间为 document.click 捕获触发的延时时间\n\n\n                // HACK: 如果触发点击的节点是弹层内部的节点，并且在被点击后立即销毁，那么此时无法使用 node.contains(e.target)\n                // 来判断此时点击的节点是否是弹层内部的节点，额外判断\n\n\n    // 兼容过去的用法: this.popupRef.getInstance().overlay.getInstance().getContentNode()\n\n\n            // if chlild is a functional component wrap in a component to allow a ref to be set\n\n\n"
    },
    "2": {
        "bug_file": "src/overlay/popup.jsx",
        "compressed": "NO",
        "line_numbers": 381,
        "compressed_line_numbers": 381,
        "compressed_bug_file_content": "import React, { Component, Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { func, KEYCODE } from '../util';\nimport Overlay from './overlay';\n\nconst { noop, makeChain, bindCtx } = func;\n\n/**\n * Overlay.Popup\n * @description 继承 Overlay 的 API，除非特别说明\n * */\nexport default class Popup extends Component {\n    static propTypes = {\n        /**\n         * 弹层内容\n         */\n        children: PropTypes.node,\n        /**\n         * 触发弹层显示或隐藏的元素\n         */\n        trigger: PropTypes.element,\n        /**\n         * 触发弹层显示或隐藏的操作类型，可以是 'click'，'hover'，'focus'，或者它们组成的数组，如 ['hover', 'focus']\n         */\n        triggerType: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n        /**\n         * 当 triggerType 为 click 时才生效，可自定义触发弹层显示的键盘码\n         */\n\n        triggerClickKeycode: PropTypes.oneOfType([\n            PropTypes.number,\n            PropTypes.array,\n        ]),\n        /**\n         * 弹层当前是否显示\n         */\n        visible: PropTypes.bool,\n        /**\n         * 弹层默认是否显示\n         */\n        defaultVisible: PropTypes.bool,\n        /**\n         * 弹层显示或隐藏时触发的回调函数\n         * @param {Boolean} visible 弹层是否显示\n         * @param {String} type 触发弹层显示或隐藏的来源 fromTrigger 表示由trigger的点击触发； docClick 表示由document的点击触发\n         * @param {Object} e DOM事件\n         */\n        onVisibleChange: PropTypes.func,\n        /**\n         * 设置此属性，弹层无法显示或隐藏\n         */\n        disabled: PropTypes.bool,\n        /**\n         * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效\n         */\n        delay: PropTypes.number,\n        /**\n         * trigger 是否可以关闭弹层\n         */\n        canCloseByTrigger: PropTypes.bool,\n        /**\n         * 弹层定位的参照元素\n         * @default target 属性，即触发元素\n         */\n        target: PropTypes.any,\n        safeNode: PropTypes.any,\n        /**\n         * 是否跟随trigger滚动\n         */\n        followTrigger: PropTypes.bool,\n        container: PropTypes.any,\n        hasMask: PropTypes.bool,\n        wrapperStyle: PropTypes.object,\n        rtl: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        triggerType: 'hover',\n        triggerClickKeycode: [KEYCODE.SPACE, KEYCODE.ENTER],\n        defaultVisible: false,\n        onVisibleChange: noop,\n        disabled: false,\n        delay: 200,\n        canCloseByTrigger: true,\n        followTrigger: false,\n        container: () => document.body,\n        rtl: false,\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            visible:\n                typeof props.visible === 'undefined'\n                    ? props.defaultVisible\n                    : props.visible,\n        };\n\n        bindCtx(this, [\n            'handleTriggerClick',\n            'handleTriggerKeyDown',\n            'handleTriggerMouseEnter',\n            'handleTriggerMouseLeave',\n            'handleTriggerFocus',\n            'handleTriggerBlur',\n            'handleContentMouseEnter',\n            'handleContentMouseLeave',\n            'handleContentMouseDown',\n            'handleRequestClose',\n            'handleMaskMouseEnter',\n            'handleMaskMouseLeave',\n        ]);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if ('visible' in nextProps) {\n            this.setState({\n                visible: nextProps.visible,\n            });\n        }\n    }\n\n    componentWillUnmount() {\n        ['_timer', '_hideTimer', '_showTimer'].forEach(time => {\n            this[time] && clearTimeout(this[time]);\n        });\n    }\n\n    handleVisibleChange(visible, type, e) {\n        if (!('visible' in this.props)) {\n            this.setState({\n                visible,\n            });\n        }\n\n        this.props.onVisibleChange(visible, type, e);\n    }\n\n    handleTriggerClick(e) {\n        if (this.state.visible && !this.props.canCloseByTrigger) {\n            return;\n        }\n\n        this.handleVisibleChange(!this.state.visible, 'fromTrigger', e);\n    }\n\n    handleTriggerKeyDown(e) {\n        const { triggerClickKeycode } = this.props;\n        const keycodes = Array.isArray(triggerClickKeycode)\n            ? triggerClickKeycode\n            : [triggerClickKeycode];\n        if (keycodes.includes(e.keyCode)) {\n            e.preventDefault();\n            this.handleTriggerClick(e);\n        }\n    }\n\n    handleTriggerMouseEnter(e) {\n        this._mouseNotFirstOnMask = false;\n\n        if (this._hideTimer) {\n            clearTimeout(this._hideTimer);\n            this._hideTimer = null;\n        }\n        if (this._showTimer) {\n            clearTimeout(this._showTimer);\n            this._showTimer = null;\n        }\n        if (!this.state.visible) {\n            this._showTimer = setTimeout(() => {\n                this.handleVisibleChange(true, 'fromTrigger', e);\n            }, this.props.delay);\n        }\n    }\n\n    handleTriggerMouseLeave(e, type) {\n        if (this._showTimer) {\n            clearTimeout(this._showTimer);\n            this._showTimer = null;\n        }\n        if (this.state.visible) {\n            this._hideTimer = setTimeout(() => {\n                this.handleVisibleChange(false, type || 'fromTrigger', e);\n            }, this.props.delay);\n        }\n    }\n\n    handleTriggerFocus(e) {\n        this.handleVisibleChange(true, 'fromTrigger', e);\n    }\n\n    handleTriggerBlur(e) {\n        if (!this._isForwardContent) {\n            this.handleVisibleChange(false, 'fromTrigger', e);\n        }\n        this._isForwardContent = false;\n    }\n\n    handleContentMouseDown() {\n        this._isForwardContent = true;\n    }\n\n    handleContentMouseEnter() {\n        clearTimeout(this._hideTimer);\n    }\n\n    handleContentMouseLeave(e) {\n        this.handleTriggerMouseLeave(e, 'fromContent');\n    }\n\n    handleMaskMouseEnter() {\n        if (!this._mouseNotFirstOnMask) {\n            clearTimeout(this._hideTimer);\n            this._hideTimer = null;\n            this._mouseNotFirstOnMask = false;\n        }\n    }\n\n    handleMaskMouseLeave() {\n        this._mouseNotFirstOnMask = true;\n    }\n\n    handleRequestClose(type, e) {\n        this.handleVisibleChange(false, type, e);\n    }\n\n    renderTrigger() {\n        const { trigger, disabled } = this.props;\n        const props = {\n            key: 'trigger',\n            'aria-haspopup': true,\n            'aria-expanded': this.state.visible,\n        };\n\n        if (!this.state.visible) {\n            props['aria-describedby'] = undefined;\n        }\n\n        if (!disabled) {\n            const { triggerType } = this.props;\n            const triggerTypes = Array.isArray(triggerType)\n                ? triggerType\n                : [triggerType];\n            const {\n                onClick,\n                onKeyDown,\n                onMouseEnter,\n                onMouseLeave,\n                onFocus,\n                onBlur,\n            } = trigger.props;\n            triggerTypes.forEach(triggerType => {\n                switch (triggerType) {\n                    case 'click':\n                        props.onClick = makeChain(\n                            this.handleTriggerClick,\n                            onClick\n                        );\n                        props.onKeyDown = makeChain(\n                            this.handleTriggerKeyDown,\n                            onKeyDown\n                        );\n                        break;\n                    case 'hover':\n                        props.onMouseEnter = makeChain(\n                            this.handleTriggerMouseEnter,\n                            onMouseEnter\n                        );\n                        props.onMouseLeave = makeChain(\n                            this.handleTriggerMouseLeave,\n                            onMouseLeave\n                        );\n                        break;\n                    case 'focus':\n                        props.onFocus = makeChain(\n                            this.handleTriggerFocus,\n                            onFocus\n                        );\n                        props.onBlur = makeChain(\n                            this.handleTriggerBlur,\n                            onBlur\n                        );\n                        break;\n                    default:\n                        break;\n                }\n            });\n        }\n\n        return React.cloneElement(trigger, props);\n    }\n\n    renderContent() {\n        const { children, triggerType } = this.props;\n        const triggerTypes = Array.isArray(triggerType)\n            ? triggerType\n            : [triggerType];\n        const content = Children.only(children);\n        const { onMouseDown, onMouseEnter, onMouseLeave } = content.props;\n        const props = {\n            key: 'portal',\n        };\n\n        triggerTypes.forEach(triggerType => {\n            switch (triggerType) {\n                case 'focus':\n                    props.onMouseDown = makeChain(\n                        this.handleContentMouseDown,\n                        onMouseDown\n                    );\n                    break;\n                case 'hover':\n                    props.onMouseEnter = makeChain(\n                        this.handleContentMouseEnter,\n                        onMouseEnter\n                    );\n                    props.onMouseLeave = makeChain(\n                        this.handleContentMouseLeave,\n                        onMouseLeave\n                    );\n                    break;\n                default:\n                    break;\n            }\n        });\n\n        return React.cloneElement(content, props);\n    }\n\n    renderPortal() {\n        const {\n            target,\n            safeNode,\n            followTrigger,\n            triggerType,\n            hasMask,\n            wrapperStyle,\n            ...others\n        } = this.props;\n        let { container } = this.props;\n        const findTriggerNode = () => findDOMNode(this) || {};\n        const safeNodes = Array.isArray(safeNode) ? [...safeNode] : [safeNode];\n        safeNodes.unshift(findTriggerNode);\n\n        const newWrapperStyle = wrapperStyle || {};\n\n        if (followTrigger) {\n            container = trigger => (trigger && trigger.parentNode) || trigger;\n            newWrapperStyle.position = 'relative';\n        }\n\n        if (triggerType === 'hover' && hasMask) {\n            others.onMaskMouseEnter = this.handleMaskMouseEnter;\n            others.onMaskMouseLeave = this.handleMaskMouseLeave;\n        }\n\n        return (\n            <Overlay\n                {...others}\n                key=\"overlay\"\n                ref={overlay => (this.overlay = overlay)}\n                visible={this.state.visible}\n                target={target || findTriggerNode}\n                container={container}\n                safeNode={safeNodes}\n                wrapperStyle={newWrapperStyle}\n                triggerType={triggerType}\n                hasMask={hasMask}\n                onRequestClose={this.handleRequestClose}\n            >\n                {this.renderContent()}\n            </Overlay>\n        );\n    }\n\n    render() {\n        return [this.renderTrigger(), this.renderPortal()];\n    }\n}"
    },
    "3": {
        "bug_file": "src/overlay/position.jsx",
        "compressed": "NO",
        "line_numbers": 137,
        "compressed_line_numbers": 137,
        "compressed_bug_file_content": "import { Component, Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { func, dom, events } from '../util';\nimport position from './utils/position';\nimport findNode from './utils/find-node';\n\nconst { noop, bindCtx } = func;\nconst { getStyle } = dom;\nconst place = position.place;\n\nexport default class Position extends Component {\n    static VIEWPORT = position.VIEWPORT;\n\n    static propTypes = {\n        children: PropTypes.node,\n        target: PropTypes.any,\n        align: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n        offset: PropTypes.array,\n        beforePosition: PropTypes.func,\n        onPosition: PropTypes.func,\n        needAdjust: PropTypes.bool,\n        needListenResize: PropTypes.bool,\n        shouldUpdatePosition: PropTypes.bool,\n        rtl: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        align: 'tl bl',\n        offset: [0, 0],\n        beforePosition: noop,\n        onPosition: noop,\n        needAdjust: true,\n        needListenResize: true,\n        shouldUpdatePosition: false,\n        rtl: false,\n    };\n\n    constructor(props) {\n        super(props);\n\n        bindCtx(this, ['handleResize']);\n    }\n\n    componentDidMount() {\n        this.setPosition();\n\n        if (this.props.needListenResize) {\n            events.on(window, 'resize', this.handleResize);\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if (\n            ('align' in nextProps && nextProps.align !== this.props.align) ||\n            nextProps.shouldUpdatePosition\n        ) {\n            this.shouldUpdatePosition = true;\n        }\n    }\n\n    componentDidUpdate() {\n        if (this.shouldUpdatePosition) {\n            this.setPosition();\n            this.shouldUpdatePosition = false;\n        }\n    }\n\n    componentWillUnmount() {\n        if (this.props.needListenResize) {\n            events.off(window, 'resize', this.handleResize);\n        }\n\n        clearTimeout(this.resizeTimeout);\n    }\n\n    setPosition() {\n        const {\n            align,\n            offset,\n            beforePosition,\n            onPosition,\n            needAdjust,\n            rtl,\n        } = this.props;\n\n        beforePosition();\n\n        const contentNode = this.getContentNode();\n        const targetNode = this.getTargetNode();\n        if (contentNode && targetNode) {\n            const resultAlign = place({\n                pinElement: contentNode,\n                baseElement: targetNode,\n                align,\n                offset,\n                needAdjust,\n                isRtl: rtl,\n            });\n            const top = getStyle(contentNode, 'top');\n            const left = getStyle(contentNode, 'left');\n\n            onPosition(\n                {\n                    align: resultAlign.split(' '),\n                    top,\n                    left,\n                },\n                contentNode\n            );\n        }\n    }\n\n    getContentNode() {\n        return findDOMNode(this);\n    }\n\n    getTargetNode() {\n        const { target } = this.props;\n\n        return target === position.VIEWPORT\n            ? position.VIEWPORT\n            : findNode(target, this.props);\n    }\n\n    handleResize() {\n        clearTimeout(this.resizeTimeout);\n\n        this.resizeTimeout = setTimeout(() => {\n            this.setPosition();\n        }, 200);\n    }\n\n    render() {\n        return Children.only(this.props.children);\n    }\n}"
    },
    "4": {
        "bug_file": "src/number-picker/number-picker.jsx",
        "compressed": "YES",
        "line_numbers": 547,
        "compressed_line_numbers": 148,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Icon from '../icon';\nimport Button from '../button';\nimport Input from '../input';\nimport ConfigProvider from '../config-provider';\nimport { func, obj } from '../util';\n\n/** NumberPicker */\n\n\n        /**\n         * 样式前缀\n         */\n\n        /**\n         * 设置类型\n         * @enumdesc 普通, 内联\n         */\n\n        /**\n         * 大小\n         */\n\n        /**\n         * 当前值\n         */\n\n        /**\n         * 默认值\n         */\n\n        /**\n         * 是否禁用\n         */\n\n        /**\n         * 步长\n         */\n\n        /**\n         * 保留小数点后位数\n         */\n\n        /**\n         * 用户是否可以输入\n         */\n\n        /**\n         * 自动焦点\n         */\n\n        /**\n         * 数值被改变的事件\n         * @param {Number} value 数据\n         * @param {Event} e DOM事件对象\n         */\n\n        /**\n         * 键盘按下\n         */\n\n        /**\n         * 焦点获得\n         */\n\n        /**\n         * 焦点失去\n         */\n\n        /**\n         * 数值订正后的回调\n         * @param {Object} obj {currentValue,oldValue:String}\n         */\n\n\n        /**\n         * 最大值\n         */\n\n        /**\n         * 最小值\n         */\n\n        /**\n         * 自定义class\n         */\n\n        /**\n         * 自定义内联样式\n         */\n\n\n        /**\n         * 格式化当前值\n         * @param {Number} value\n         * @return {String|Number}\n         */\n\n        /**\n         * 增加按钮的props\n         */\n\n        /**\n         * 减少按钮的props\n         */\n\n\n            // Compatible Chinese Input Method\n\n            // ignore space\n\n\n            // in case of autoCorrect ('0.'=>0, '0.0'=>0) , we have these steps\n\n                // ignore when input start form '-'\n\n\n                // ignore when next value = prev value.\n                // ps: Number('0.')=0 ; Number('0.0')=0;\n                // but take care of Number('')=0;\n\n\n                // ignore when value < min (because number is inputted one by one)\n\n\n    /**\n     * @param {Float} currentValue correct value\n     * @param {String} oldValue input value\n     */\n\n\n            // precision=2  and input from 1.99 to 1.999, should stay with 1.99 not 2\n\n\n        // Only trigger `setState` if `format` is settled to avoid unnecessary rendering\n\n\n    /**\n     * fix bug in chrome browser\n     * 0.28 + 0.01 = 0.29000000000000004\n     * 0.29 - 0.01 = 0.27999999999999997\n     * @param {Number} value value\n     */\n\n\nexport default ConfigProvider.config(NumberPicker);\n"
    }
}