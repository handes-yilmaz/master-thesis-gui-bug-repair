{
    "1": {
        "bug_file": "src/overlay/overlay.jsx",
        "compressed": "YES",
        "line_numbers": 790,
        "compressed_line_numbers": 159,
        "compressed_bug_file_content": "import React, { Component, Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport { dom, events, func, support, focus, KEYCODE, guid } from '../util';\nimport overlayManager from './manager';\nimport Gateway from './gateway';\nimport Position from './position';\nimport findNode from './utils/find-node';\n\n\n        // ignore error for firefox\n\n\n/**\n * Overlay\n * */\nexport default class Overlay extends Component {\n\n\n        /**\n         * 弹层内容\n         */\n\n        /**\n         * 是否显示弹层\n         */\n\n        /**\n         * 弹层请求关闭时触发事件的回调函数\n         * @param {String} type 弹层关闭的来源\n         * @param {Object} e DOM 事件\n         */\n\n        /**\n         * 弹层定位的参照元素\n         */\n\n        /**\n         * 弹层相对于参照元素的定位, 详见开发指南的[定位部分](#定位)\n         */\n\n        /**\n         * 弹层相对于trigger的定位的微调, 接收数组[hoz, ver], 表示弹层在 left / top 上的增量\n         * e.g. [100, 100] 表示往右(RTL 模式下是往左) 、下分布偏移100px\n         */\n\n        /**\n         * 渲染组件的容器，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点\n         */\n\n        /**\n         * 是否显示遮罩\n         */\n\n        /**\n         * 是否支持 esc 按键关闭弹层\n         */\n\n        /**\n         * 点击弹层外的区域是否关闭弹层，不显示遮罩时生效\n         */\n\n        /**\n         * 点击遮罩区域是否关闭弹层，显示遮罩时生效\n         */\n\n        /**\n         * 弹层打开前触发事件的回调函数\n         */\n\n        /**\n         * 弹层打开时触发事件的回调函数\n         */\n\n        /**\n         * 弹层打开后触发事件的回调函数, 如果有动画，则在动画结束后触发\n         */\n\n        /**\n         * 弹层关闭前触发事件的回调函数\n         */\n\n        /**\n         * 弹层关闭时触发事件的回调函数\n         */\n\n        /**\n         * 弹层关闭后触发事件的回调函数, 如果有动画，则在动画结束后触发\n         */\n\n        /**\n         * 弹层定位完成前触发的事件\n         */\n\n        /**\n         * 弹层定位完成时触发的事件\n         * @param {Object} config 定位的参数\n         * @param {Array} config.align 对齐方式，如 ['cc', 'cc']（如果开启 needAdjust，可能和预先设置的 align 不同）\n         * @param {Number} config.top 距离视口顶部距离\n         * @param {Number} config.left 距离视口左侧距离\n         * @param {Object} node 定位参照的容器节点\n         */\n\n        /**\n         * 是否在每次弹层重新渲染后强制更新定位信息，一般用于弹层内容区域大小发生变化时，仍需保持原来的定位方式\n         */\n\n        /**\n         * 弹层打开时是否让其中的元素自动获取焦点\n         */\n\n        /**\n         * 当弹层由于页面滚动等情况不在可视区域时，是否自动调整定位以出现在可视区域\n         */\n\n        /**\n         * 是否禁用页面滚动\n         */\n\n        /**\n         * 隐藏时是否保留子节点\n         */\n\n        /**\n         * 安全节点，当点击 document 的时候，如果包含该节点则不会关闭弹层，如果是函数需要返回 ref，如果是字符串则是该 DOM 的 id，也可以直接传入 DOM 节点，或者以上值组成的数组\n         */\n\n        /**\n         * 弹层的根节点的样式类\n         */\n\n        /**\n         * 弹层的根节点的内联样式\n         */\n\n        /**\n         * 配置动画的播放方式，支持 { in: 'enter-class', out: 'leave-class' } 的对象参数，如果设置为 false，则不播放动画。 请参考 Animate 组件的文档获取可用的动画名\n         * @default { in: 'expandInDown', out: 'expandOutUp' }\n         */\n\n\n                // NOTE: setState callback (second argument) now fires immediately after componentDidMount / componentDidUpdate instead of after all components have rendered.\n\n\n            // 这个时候很可能上一个弹层的关闭事件还未触发，导致焦点已经回到触发的元素\n            // 这里延时处理一下，延时的时间为 document.click 捕获触发的延时时间\n\n\n                // HACK: 如果触发点击的节点是弹层内部的节点，并且在被点击后立即销毁，那么此时无法使用 node.contains(e.target)\n                // 来判断此时点击的节点是否是弹层内部的节点，额外判断\n\n\n    // 兼容过去的用法: this.popupRef.getInstance().overlay.getInstance().getContentNode()\n\n\n            // if chlild is a functional component wrap in a component to allow a ref to be set\n\n\n"
    },
    "2": {
        "bug_file": "src/overlay/popup.jsx",
        "compressed": "NO",
        "line_numbers": 381,
        "compressed_line_numbers": 381,
        "compressed_bug_file_content": "import React, { Component, Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { func, KEYCODE } from '../util';\nimport Overlay from './overlay';\n\nconst { noop, makeChain, bindCtx } = func;\n\n/**\n * Overlay.Popup\n * @description 继承 Overlay 的 API，除非特别说明\n * */\nexport default class Popup extends Component {\n    static propTypes = {\n        /**\n         * 弹层内容\n         */\n        children: PropTypes.node,\n        /**\n         * 触发弹层显示或隐藏的元素\n         */\n        trigger: PropTypes.element,\n        /**\n         * 触发弹层显示或隐藏的操作类型，可以是 'click'，'hover'，'focus'，或者它们组成的数组，如 ['hover', 'focus']\n         */\n        triggerType: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n        /**\n         * 当 triggerType 为 click 时才生效，可自定义触发弹层显示的键盘码\n         */\n\n        triggerClickKeycode: PropTypes.oneOfType([\n            PropTypes.number,\n            PropTypes.array,\n        ]),\n        /**\n         * 弹层当前是否显示\n         */\n        visible: PropTypes.bool,\n        /**\n         * 弹层默认是否显示\n         */\n        defaultVisible: PropTypes.bool,\n        /**\n         * 弹层显示或隐藏时触发的回调函数\n         * @param {Boolean} visible 弹层是否显示\n         * @param {String} type 触发弹层显示或隐藏的来源 fromTrigger 表示由trigger的点击触发； docClick 表示由document的点击触发\n         * @param {Object} e DOM事件\n         */\n        onVisibleChange: PropTypes.func,\n        /**\n         * 设置此属性，弹层无法显示或隐藏\n         */\n        disabled: PropTypes.bool,\n        /**\n         * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效\n         */\n        delay: PropTypes.number,\n        /**\n         * trigger 是否可以关闭弹层\n         */\n        canCloseByTrigger: PropTypes.bool,\n        /**\n         * 弹层定位的参照元素\n         * @default target 属性，即触发元素\n         */\n        target: PropTypes.any,\n        safeNode: PropTypes.any,\n        /**\n         * 是否跟随trigger滚动\n         */\n        followTrigger: PropTypes.bool,\n        container: PropTypes.any,\n        hasMask: PropTypes.bool,\n        wrapperStyle: PropTypes.object,\n        rtl: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        triggerType: 'hover',\n        triggerClickKeycode: [KEYCODE.SPACE, KEYCODE.ENTER],\n        defaultVisible: false,\n        onVisibleChange: noop,\n        disabled: false,\n        delay: 200,\n        canCloseByTrigger: true,\n        followTrigger: false,\n        container: () => document.body,\n        rtl: false,\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            visible:\n                typeof props.visible === 'undefined'\n                    ? props.defaultVisible\n                    : props.visible,\n        };\n\n        bindCtx(this, [\n            'handleTriggerClick',\n            'handleTriggerKeyDown',\n            'handleTriggerMouseEnter',\n            'handleTriggerMouseLeave',\n            'handleTriggerFocus',\n            'handleTriggerBlur',\n            'handleContentMouseEnter',\n            'handleContentMouseLeave',\n            'handleContentMouseDown',\n            'handleRequestClose',\n            'handleMaskMouseEnter',\n            'handleMaskMouseLeave',\n        ]);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if ('visible' in nextProps) {\n            this.setState({\n                visible: nextProps.visible,\n            });\n        }\n    }\n\n    componentWillUnmount() {\n        ['_timer', '_hideTimer', '_showTimer'].forEach(time => {\n            this[time] && clearTimeout(this[time]);\n        });\n    }\n\n    handleVisibleChange(visible, type, e) {\n        if (!('visible' in this.props)) {\n            this.setState({\n                visible,\n            });\n        }\n\n        this.props.onVisibleChange(visible, type, e);\n    }\n\n    handleTriggerClick(e) {\n        if (this.state.visible && !this.props.canCloseByTrigger) {\n            return;\n        }\n\n        this.handleVisibleChange(!this.state.visible, 'fromTrigger', e);\n    }\n\n    handleTriggerKeyDown(e) {\n        const { triggerClickKeycode } = this.props;\n        const keycodes = Array.isArray(triggerClickKeycode)\n            ? triggerClickKeycode\n            : [triggerClickKeycode];\n        if (keycodes.includes(e.keyCode)) {\n            e.preventDefault();\n            this.handleTriggerClick(e);\n        }\n    }\n\n    handleTriggerMouseEnter(e) {\n        this._mouseNotFirstOnMask = false;\n\n        if (this._hideTimer) {\n            clearTimeout(this._hideTimer);\n            this._hideTimer = null;\n        }\n        if (this._showTimer) {\n            clearTimeout(this._showTimer);\n            this._showTimer = null;\n        }\n        if (!this.state.visible) {\n            this._showTimer = setTimeout(() => {\n                this.handleVisibleChange(true, 'fromTrigger', e);\n            }, this.props.delay);\n        }\n    }\n\n    handleTriggerMouseLeave(e, type) {\n        if (this._showTimer) {\n            clearTimeout(this._showTimer);\n            this._showTimer = null;\n        }\n        if (this.state.visible) {\n            this._hideTimer = setTimeout(() => {\n                this.handleVisibleChange(false, type || 'fromTrigger', e);\n            }, this.props.delay);\n        }\n    }\n\n    handleTriggerFocus(e) {\n        this.handleVisibleChange(true, 'fromTrigger', e);\n    }\n\n    handleTriggerBlur(e) {\n        if (!this._isForwardContent) {\n            this.handleVisibleChange(false, 'fromTrigger', e);\n        }\n        this._isForwardContent = false;\n    }\n\n    handleContentMouseDown() {\n        this._isForwardContent = true;\n    }\n\n    handleContentMouseEnter() {\n        clearTimeout(this._hideTimer);\n    }\n\n    handleContentMouseLeave(e) {\n        this.handleTriggerMouseLeave(e, 'fromContent');\n    }\n\n    handleMaskMouseEnter() {\n        if (!this._mouseNotFirstOnMask) {\n            clearTimeout(this._hideTimer);\n            this._hideTimer = null;\n            this._mouseNotFirstOnMask = false;\n        }\n    }\n\n    handleMaskMouseLeave() {\n        this._mouseNotFirstOnMask = true;\n    }\n\n    handleRequestClose(type, e) {\n        this.handleVisibleChange(false, type, e);\n    }\n\n    renderTrigger() {\n        const { trigger, disabled } = this.props;\n        const props = {\n            key: 'trigger',\n            'aria-haspopup': true,\n            'aria-expanded': this.state.visible,\n        };\n\n        if (!this.state.visible) {\n            props['aria-describedby'] = undefined;\n        }\n\n        if (!disabled) {\n            const { triggerType } = this.props;\n            const triggerTypes = Array.isArray(triggerType)\n                ? triggerType\n                : [triggerType];\n            const {\n                onClick,\n                onKeyDown,\n                onMouseEnter,\n                onMouseLeave,\n                onFocus,\n                onBlur,\n            } = trigger.props;\n            triggerTypes.forEach(triggerType => {\n                switch (triggerType) {\n                    case 'click':\n                        props.onClick = makeChain(\n                            this.handleTriggerClick,\n                            onClick\n                        );\n                        props.onKeyDown = makeChain(\n                            this.handleTriggerKeyDown,\n                            onKeyDown\n                        );\n                        break;\n                    case 'hover':\n                        props.onMouseEnter = makeChain(\n                            this.handleTriggerMouseEnter,\n                            onMouseEnter\n                        );\n                        props.onMouseLeave = makeChain(\n                            this.handleTriggerMouseLeave,\n                            onMouseLeave\n                        );\n                        break;\n                    case 'focus':\n                        props.onFocus = makeChain(\n                            this.handleTriggerFocus,\n                            onFocus\n                        );\n                        props.onBlur = makeChain(\n                            this.handleTriggerBlur,\n                            onBlur\n                        );\n                        break;\n                    default:\n                        break;\n                }\n            });\n        }\n\n        return React.cloneElement(trigger, props);\n    }\n\n    renderContent() {\n        const { children, triggerType } = this.props;\n        const triggerTypes = Array.isArray(triggerType)\n            ? triggerType\n            : [triggerType];\n        const content = Children.only(children);\n        const { onMouseDown, onMouseEnter, onMouseLeave } = content.props;\n        const props = {\n            key: 'portal',\n        };\n\n        triggerTypes.forEach(triggerType => {\n            switch (triggerType) {\n                case 'focus':\n                    props.onMouseDown = makeChain(\n                        this.handleContentMouseDown,\n                        onMouseDown\n                    );\n                    break;\n                case 'hover':\n                    props.onMouseEnter = makeChain(\n                        this.handleContentMouseEnter,\n                        onMouseEnter\n                    );\n                    props.onMouseLeave = makeChain(\n                        this.handleContentMouseLeave,\n                        onMouseLeave\n                    );\n                    break;\n                default:\n                    break;\n            }\n        });\n\n        return React.cloneElement(content, props);\n    }\n\n    renderPortal() {\n        const {\n            target,\n            safeNode,\n            followTrigger,\n            triggerType,\n            hasMask,\n            wrapperStyle,\n            ...others\n        } = this.props;\n        let { container } = this.props;\n        const findTriggerNode = () => findDOMNode(this) || {};\n        const safeNodes = Array.isArray(safeNode) ? [...safeNode] : [safeNode];\n        safeNodes.unshift(findTriggerNode);\n\n        const newWrapperStyle = wrapperStyle || {};\n\n        if (followTrigger) {\n            container = trigger => (trigger && trigger.parentNode) || trigger;\n            newWrapperStyle.position = 'relative';\n        }\n\n        if (triggerType === 'hover' && hasMask) {\n            others.onMaskMouseEnter = this.handleMaskMouseEnter;\n            others.onMaskMouseLeave = this.handleMaskMouseLeave;\n        }\n\n        return (\n            <Overlay\n                {...others}\n                key=\"overlay\"\n                ref={overlay => (this.overlay = overlay)}\n                visible={this.state.visible}\n                target={target || findTriggerNode}\n                container={container}\n                safeNode={safeNodes}\n                wrapperStyle={newWrapperStyle}\n                triggerType={triggerType}\n                hasMask={hasMask}\n                onRequestClose={this.handleRequestClose}\n            >\n                {this.renderContent()}\n            </Overlay>\n        );\n    }\n\n    render() {\n        return [this.renderTrigger(), this.renderPortal()];\n    }\n}"
    },
    "3": {
        "bug_file": "src/overlay/position.jsx",
        "compressed": "NO",
        "line_numbers": 137,
        "compressed_line_numbers": 137,
        "compressed_bug_file_content": "import { Component, Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { func, dom, events } from '../util';\nimport position from './utils/position';\nimport findNode from './utils/find-node';\n\nconst { noop, bindCtx } = func;\nconst { getStyle } = dom;\nconst place = position.place;\n\nexport default class Position extends Component {\n    static VIEWPORT = position.VIEWPORT;\n\n    static propTypes = {\n        children: PropTypes.node,\n        target: PropTypes.any,\n        align: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n        offset: PropTypes.array,\n        beforePosition: PropTypes.func,\n        onPosition: PropTypes.func,\n        needAdjust: PropTypes.bool,\n        needListenResize: PropTypes.bool,\n        shouldUpdatePosition: PropTypes.bool,\n        rtl: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        align: 'tl bl',\n        offset: [0, 0],\n        beforePosition: noop,\n        onPosition: noop,\n        needAdjust: true,\n        needListenResize: true,\n        shouldUpdatePosition: false,\n        rtl: false,\n    };\n\n    constructor(props) {\n        super(props);\n\n        bindCtx(this, ['handleResize']);\n    }\n\n    componentDidMount() {\n        this.setPosition();\n\n        if (this.props.needListenResize) {\n            events.on(window, 'resize', this.handleResize);\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if (\n            ('align' in nextProps && nextProps.align !== this.props.align) ||\n            nextProps.shouldUpdatePosition\n        ) {\n            this.shouldUpdatePosition = true;\n        }\n    }\n\n    componentDidUpdate() {\n        if (this.shouldUpdatePosition) {\n            this.setPosition();\n            this.shouldUpdatePosition = false;\n        }\n    }\n\n    componentWillUnmount() {\n        if (this.props.needListenResize) {\n            events.off(window, 'resize', this.handleResize);\n        }\n\n        clearTimeout(this.resizeTimeout);\n    }\n\n    setPosition() {\n        const {\n            align,\n            offset,\n            beforePosition,\n            onPosition,\n            needAdjust,\n            rtl,\n        } = this.props;\n\n        beforePosition();\n\n        const contentNode = this.getContentNode();\n        const targetNode = this.getTargetNode();\n        if (contentNode && targetNode) {\n            const resultAlign = place({\n                pinElement: contentNode,\n                baseElement: targetNode,\n                align,\n                offset,\n                needAdjust,\n                isRtl: rtl,\n            });\n            const top = getStyle(contentNode, 'top');\n            const left = getStyle(contentNode, 'left');\n\n            onPosition(\n                {\n                    align: resultAlign.split(' '),\n                    top,\n                    left,\n                },\n                contentNode\n            );\n        }\n    }\n\n    getContentNode() {\n        return findDOMNode(this);\n    }\n\n    getTargetNode() {\n        const { target } = this.props;\n\n        return target === position.VIEWPORT\n            ? position.VIEWPORT\n            : findNode(target, this.props);\n    }\n\n    handleResize() {\n        clearTimeout(this.resizeTimeout);\n\n        this.resizeTimeout = setTimeout(() => {\n            this.setPosition();\n        }, 200);\n    }\n\n    render() {\n        return Children.only(this.props.children);\n    }\n}"
    },
    "4": {
        "bug_file": "src/overlay/utils/position.js",
        "compressed": "NO",
        "line_numbers": 388,
        "compressed_line_numbers": 388,
        "compressed_bug_file_content": "import { dom } from '../../util';\n\nconst VIEWPORT = 'viewport';\n\n// IE8 not support pageXOffset\nconst getPageX = () =>\n    window.pageXOffset || document.documentElement.scrollLeft;\nconst getPageY = () => window.pageYOffset || document.documentElement.scrollTop;\n\n/**\n * @private get element rect\n * @param       {Element} elem\n * @return      {Object}\n */\nfunction _getElementRect(elem) {\n    let offsetTop = 0,\n        offsetLeft = 0,\n        scrollTop = 0,\n        scrollLeft = 0;\n\n    const offsetHeight = elem.offsetHeight;\n    const offsetWidth = elem.offsetWidth;\n\n    do {\n        if (!isNaN(elem.offsetTop)) {\n            offsetTop += elem.offsetTop;\n        }\n        if (!isNaN(elem.offsetLeft)) {\n            offsetLeft += elem.offsetLeft;\n        }\n        if (!isNaN(elem.scrollTop)) {\n            scrollTop += elem.scrollTop;\n        }\n        if (!isNaN(elem.scrollLeft)) {\n            scrollLeft += elem.scrollLeft;\n        }\n    } while ((elem = elem.offsetParent) !== null);\n\n    return {\n        top:\n            offsetTop -\n            scrollTop -\n            (document.documentElement.scrollTop || document.body.scrollTop),\n        left:\n            offsetLeft -\n            scrollLeft -\n            (document.documentElement.scrollLeft || document.body.scrollLeft),\n        height: offsetHeight,\n        width: offsetWidth,\n    };\n}\n\n/**\n * @private get viewport size\n * @return {Object}\n */\nfunction _getViewportSize() {\n    return {\n        width: document.documentElement.clientWidth,\n        height: document.documentElement.clientHeight,\n    };\n}\nexport default class Position {\n    static VIEWPORT = VIEWPORT;\n\n    /**\n     * @public static place method\n     * @param  {Object}       props\n     *     @param  {DOM}      props.pinElement\n     *     @param  {DOM}      props.baseElement\n     *     @param  {String}   props.align\n     *     @param  {Number}   props.offset\n     *     @param  {Boolean}  props.needAdjust\n     *     @param  {Boolean}  props.isRtl\n     * @return {Position}\n     */\n    static place = props => new Position(props).setPosition();\n\n    constructor(props) {\n        this.pinElement = props.pinElement;\n        this.baseElement = props.baseElement;\n        this.align = props.align || 'tl tl';\n        this.offset = props.offset || [0, 0];\n        this.needAdjust = props.needAdjust || false;\n        this.isRtl = props.isRtl || false;\n    }\n\n    setPosition() {\n        const pinElement = this.pinElement;\n        const baseElement = this.baseElement;\n        const expectedAlign = this._getExpectedAlign();\n        let isPinFixed, isBaseFixed, firstPositionResult;\n        if (pinElement === VIEWPORT) {\n            return;\n        }\n        if (dom.getStyle(pinElement, 'position') !== 'fixed') {\n            dom.setStyle(pinElement, 'position', 'absolute');\n            isPinFixed = false;\n        } else {\n            isPinFixed = true;\n        }\n        if (\n            baseElement === VIEWPORT ||\n            dom.getStyle(baseElement, 'position') !== 'fixed'\n        ) {\n            isBaseFixed = false;\n        } else {\n            isBaseFixed = true;\n        }\n        // 根据期望的定位\n        for (let i = 0; i < expectedAlign.length; i++) {\n            const align = expectedAlign[i];\n            const pinElementPoints = this._normalizePosition(\n                pinElement,\n                align.split(' ')[0],\n                isPinFixed\n            );\n            const baseElementPoints = this._normalizePosition(\n                baseElement,\n                align.split(' ')[1],\n                isPinFixed\n            );\n            const pinElementParentOffset = this._getParentOffset(pinElement);\n            const baseElementOffset =\n                isPinFixed && isBaseFixed\n                    ? this._getLeftTop(baseElement)\n                    : baseElementPoints.offset();\n            const top =\n                baseElementOffset.top +\n                baseElementPoints.y -\n                pinElementParentOffset.top -\n                pinElementPoints.y;\n            const left =\n                baseElementOffset.left +\n                baseElementPoints.x -\n                pinElementParentOffset.left -\n                pinElementPoints.x;\n            this._setPinElementPostion(pinElement, { left, top }, this.offset);\n\n            if (!firstPositionResult) {\n                firstPositionResult = { left, top };\n            }\n            if (this._isInViewport(pinElement)) {\n                return align;\n            }\n        }\n\n        // This will only execute if `pinElement` could not be placed entirely in the Viewport\n        const inViewportLeft = this._makeElementInViewport(\n            pinElement,\n            firstPositionResult.left,\n            'Left',\n            isPinFixed\n        );\n        const inViewportTop = this._makeElementInViewport(\n            pinElement,\n            firstPositionResult.top,\n            'Top',\n            isPinFixed\n        );\n        this._setPinElementPostion(\n            pinElement,\n            { left: inViewportLeft, top: inViewportTop },\n            this.offset\n        );\n        return expectedAlign[0];\n    }\n\n    _getParentOffset(element) {\n        const parent = element.offsetParent || document.documentElement;\n        let offset;\n        if (\n            parent === document.body &&\n            dom.getStyle(parent, 'position') === 'static'\n        ) {\n            offset = {\n                top: 0,\n                left: 0,\n            };\n        } else {\n            offset = this._getElementOffset(parent);\n        }\n\n        offset.top += parseFloat(dom.getStyle(parent, 'border-top-width'), 10);\n        offset.left += parseFloat(\n            dom.getStyle(parent, 'border-left-width'),\n            10\n        );\n        offset.offsetParent = parent;\n        return offset;\n    }\n\n    _makeElementInViewport(pinElement, number, type, isPinFixed) {\n        let result = number;\n        const docElement = document.documentElement;\n        const offsetParent =\n            pinElement.offsetParent || document.documentElement;\n\n        if (result < 0) {\n            if (isPinFixed) {\n                result = 0;\n            } else if (\n                offsetParent === document.body &&\n                dom.getStyle(offsetParent, 'position') === 'static'\n            ) {\n                // Only when div's offsetParent is document.body, we set new position result.\n                result = Math.max(\n                    docElement[`scroll${type}`],\n                    document.body[`scroll${type}`]\n                );\n            }\n        }\n\n        return result;\n    }\n\n    _normalizePosition(element, align, isPinFixed) {\n        const points = this._normalizeElement(element, isPinFixed);\n        this._normalizeXY(points, align);\n\n        return points;\n    }\n\n    _normalizeXY(points, align) {\n        const x = align.split('')[1];\n        const y = align.split('')[0];\n\n        points.x = this._xyConverter(x, points, 'width');\n        points.y = this._xyConverter(y, points, 'height');\n\n        return points;\n    }\n\n    _xyConverter(align, points, type) {\n        const res = align\n            .replace(/t|l/gi, '0%')\n            .replace(/c/gi, '50%')\n            .replace(/b|r/gi, '100%')\n            .replace(/(\\d+)%/gi, function(m, d) {\n                return points.size()[type] * (d / 100);\n            });\n\n        return parseFloat(res, 10) || 0;\n    }\n\n    _getLeftTop(element) {\n        return {\n            left: parseFloat(dom.getStyle(element, 'left')) || 0,\n            top: parseFloat(dom.getStyle(element, 'top')) || 0,\n        };\n    }\n\n    _normalizeElement(element, isPinFixed) {\n        const result = {\n                element: element,\n                x: 0,\n                y: 0,\n            },\n            isViewport = element === VIEWPORT,\n            docElement = document.documentElement;\n\n        result.offset = () => {\n            if (isPinFixed) {\n                return {\n                    left: 0,\n                    top: 0,\n                };\n            } else if (isViewport) {\n                return {\n                    left: getPageX(),\n                    top: getPageY(),\n                };\n            } else {\n                return this._getElementOffset(element);\n            }\n        };\n\n        result.size = () => {\n            if (isViewport) {\n                return {\n                    width: docElement.clientWidth,\n                    height: docElement.clientHeight,\n                };\n            } else {\n                return {\n                    width: element.offsetWidth,\n                    height: element.offsetHeight,\n                };\n            }\n        };\n\n        return result;\n    }\n\n    _getElementOffset(element) {\n        const rect = element.getBoundingClientRect();\n        const docElement = document.documentElement;\n        const body = document.body;\n        const docClientLeft = docElement.clientLeft || body.clientLeft || 0;\n        const docClientTop = docElement.clientTop || body.clientTop || 0;\n\n        return {\n            left: rect.left + (getPageX() - docClientLeft),\n            top: rect.top + (getPageY() - docClientTop),\n        };\n    }\n\n    // According to the location of the overflow to calculate the desired positioning\n    _getExpectedAlign() {\n        const align = this.isRtl\n            ? this._replaceAlignDir(this.align, /l|r/g, { l: 'r', r: 'l' })\n            : this.align;\n        const expectedAlign = [align];\n        if (this.needAdjust) {\n            if (/t|b/g.test(align)) {\n                expectedAlign.push(\n                    this._replaceAlignDir(align, /t|b/g, { t: 'b', b: 't' })\n                );\n            }\n            if (/l|r/g.test(align)) {\n                expectedAlign.push(\n                    this._replaceAlignDir(align, /l|r/g, { l: 'r', r: 'l' })\n                );\n            }\n            if (/c/g.test(align)) {\n                expectedAlign.push(\n                    this._replaceAlignDir(align, /c(?= |$)/g, { c: 'l' })\n                );\n                expectedAlign.push(\n                    this._replaceAlignDir(align, /c(?= |$)/g, { c: 'r' })\n                );\n            }\n            expectedAlign.push(\n                this._replaceAlignDir(align, /l|r|t|b/g, {\n                    l: 'r',\n                    r: 'l',\n                    t: 'b',\n                    b: 't',\n                })\n            );\n        }\n        return expectedAlign;\n    }\n\n    // Transform align order.\n    _replaceAlignDir(align, regExp, map) {\n        return align.replace(regExp, res => {\n            return map[res];\n        });\n    }\n\n    // Detecting element is in the window， we want to adjust position later.\n    _isInViewport(element) {\n        const viewportSize = _getViewportSize();\n        // Avoid animate problem that use offsetWidth instead of getBoundingClientRect.\n        const elementRect = _getElementRect(element);\n        return (\n            elementRect.left >= 0 &&\n            elementRect.left + element.offsetWidth <= viewportSize.width &&\n            elementRect.top >= 0 &&\n            elementRect.top + element.offsetHeight <= viewportSize.height\n        );\n    }\n    // 在这里做RTL判断 top-left 定位转化为等效的 top-right定位\n    _setPinElementPostion(pinElement, postion, offset = [0, 0]) {\n        const { top, left } = postion;\n        if (!this.isRtl) {\n            dom.setStyle(pinElement, {\n                left: `${left + offset[0]}px`,\n                top: `${top + offset[1]}px`,\n            });\n            return;\n        }\n\n        // transfer {left,top} equaly to {right,top}\n        const pinElementParentOffset = this._getParentOffset(pinElement);\n        const { width: offsetParentWidth } = _getElementRect(\n            pinElementParentOffset.offsetParent\n        );\n        const { width } = _getElementRect(pinElement);\n        const right = offsetParentWidth - (left + width);\n        dom.setStyle(pinElement, {\n            left: 'auto',\n            right: `${right + offset[0]}px`,\n            top: `${top + offset[1]}px`,\n        });\n    }\n}"
    },
    "5": {
        "bug_file": "src/number-picker/number-picker.jsx",
        "compressed": "YES",
        "line_numbers": 547,
        "compressed_line_numbers": 148,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Icon from '../icon';\nimport Button from '../button';\nimport Input from '../input';\nimport ConfigProvider from '../config-provider';\nimport { func, obj } from '../util';\n\n/** NumberPicker */\n\n\n        /**\n         * 样式前缀\n         */\n\n        /**\n         * 设置类型\n         * @enumdesc 普通, 内联\n         */\n\n        /**\n         * 大小\n         */\n\n        /**\n         * 当前值\n         */\n\n        /**\n         * 默认值\n         */\n\n        /**\n         * 是否禁用\n         */\n\n        /**\n         * 步长\n         */\n\n        /**\n         * 保留小数点后位数\n         */\n\n        /**\n         * 用户是否可以输入\n         */\n\n        /**\n         * 自动焦点\n         */\n\n        /**\n         * 数值被改变的事件\n         * @param {Number} value 数据\n         * @param {Event} e DOM事件对象\n         */\n\n        /**\n         * 键盘按下\n         */\n\n        /**\n         * 焦点获得\n         */\n\n        /**\n         * 焦点失去\n         */\n\n        /**\n         * 数值订正后的回调\n         * @param {Object} obj {currentValue,oldValue:String}\n         */\n\n\n        /**\n         * 最大值\n         */\n\n        /**\n         * 最小值\n         */\n\n        /**\n         * 自定义class\n         */\n\n        /**\n         * 自定义内联样式\n         */\n\n\n        /**\n         * 格式化当前值\n         * @param {Number} value\n         * @return {String|Number}\n         */\n\n        /**\n         * 增加按钮的props\n         */\n\n        /**\n         * 减少按钮的props\n         */\n\n\n            // Compatible Chinese Input Method\n\n            // ignore space\n\n\n            // in case of autoCorrect ('0.'=>0, '0.0'=>0) , we have these steps\n\n                // ignore when input start form '-'\n\n\n                // ignore when next value = prev value.\n                // ps: Number('0.')=0 ; Number('0.0')=0;\n                // but take care of Number('')=0;\n\n\n                // ignore when value < min (because number is inputted one by one)\n\n\n    /**\n     * @param {Float} currentValue correct value\n     * @param {String} oldValue input value\n     */\n\n\n            // precision=2  and input from 1.99 to 1.999, should stay with 1.99 not 2\n\n\n        // Only trigger `setState` if `format` is settled to avoid unnecessary rendering\n\n\n    /**\n     * fix bug in chrome browser\n     * 0.28 + 0.01 = 0.29000000000000004\n     * 0.29 - 0.01 = 0.27999999999999997\n     * @param {Number} value value\n     */\n\n\nexport default ConfigProvider.config(NumberPicker);\n"
    },
    "6": {
        "bug_file": "src/number-picker/style.js",
        "compressed": "NO",
        "line_numbers": 4,
        "compressed_line_numbers": 4,
        "compressed_bug_file_content": "import '../input/style.js';\nimport '../icon/style.js';\nimport '../button/style.js';\nimport './main.scss';"
    }
}