{
    "src/tree-select/tree-select.jsx": [
        "...",
        " * TreeSelect",
        " */",
        "export default class TreeSelect extends Component {",
        "    static propTypes = {",
        "        prefix: PropTypes.string,",
        "        pure: PropTypes.bool,",
        "        className: PropTypes.string,",
        "        /**",
        "         * 树节点",
        "         */",
        "        children: PropTypes.node,",
        "        /**",
        "         * 选择框大小",
        "         */",
        "        size: PropTypes.oneOf(['small', 'medium', 'large']),",
        "        /**",
        "         * 选择框占位符",
        "         */",
        "        placeholder: PropTypes.string,",
        "        /**",
        "         * 是否禁用",
        "         */",
        "        disabled: PropTypes.bool,",
        "        /**",
        "         * 是否有下拉箭头",
        "         */",
        "        hasArrow: PropTypes.bool,",
        "        /**",
        "         * 是否有边框",
        "         */",
        "        hasBorder: PropTypes.bool,",
        "        /**",
        "         * 是否有清空按钮",
        "         */",
        "        hasClear: PropTypes.bool,",
        "        /**",
        "         * 自定义内联 label",
        "         */",
        "        label: PropTypes.node,",
        "        /**",
        "         * 是否只读，只读模式下可以展开弹层但不能选择",
        "         */",
        "        readOnly: PropTypes.bool,",
        "        /**",
        "         * 下拉框是否与选择器对齐",
        "         */",
        "        autoWidth: PropTypes.bool,",
        "        /**",
        "         * 数据源，该属性优先级高于 children",
        "         */",
        "        dataSource: PropTypes.arrayOf(PropTypes.object),",
        "        /**",
        "         * （受控）当前值",
        "         */",
        "        value: PropTypes.oneOfType([",
        "            PropTypes.string,",
        "            PropTypes.arrayOf(PropTypes.string),",
        "        ]),",
        "        /**",
        "         * （非受控）默认值",
        "         */",
        "        defaultValue: PropTypes.oneOfType([",
        "            PropTypes.string,",
        "            PropTypes.arrayOf(PropTypes.string),",
        "        ]),",
        "        /**",
        "         * 选中值改变时触发的回调函数",
        "         * @param {String|Array} value 选中的值，单选时返回单个值，多选时返回数组",
        "         * @param {Object|Array} data 选中的数据，包括 value, label, pos, key属性，单选时返回单个值，多选时返回数组，父子节点选中关联时，同时选中，只返回父节点",
        "         */",
        "        onChange: PropTypes.func,",
        "        /**",
        "         * 是否显示搜索框",
        "         */",
        "        showSearch: PropTypes.bool,",
        "        /**",
        "         * 在搜索框中输入时触发的回调函数",
        "         * @param {String} keyword 输入的关键字",
        "         */",
        "        onSearch: PropTypes.func,",
        "        onSearchClear: PropTypes.func,",
        "        /**",
        "         * 无数据时显示内容",
        "         */",
        "        notFoundContent: PropTypes.node,",
        "        /**",
        "         * 是否支持多选",
        "         */",
        "        multiple: PropTypes.bool,",
        "        /**",
        "         * 下拉框中的树是否支持勾选节点的复选框",
        "         */",
        "        treeCheckable: PropTypes.bool,",
        "        /**",
        "         * 下拉框中的树勾选节点复选框是否完全受控（父子节点选中状态不再关联）",
        "         */",
        "        treeCheckStrictly: PropTypes.bool,",
        "        /**",
        "         * 定义选中时回填的方式",
        "         * @enumdesc 返回所有选中的节点, 父子节点都选中时只返回父节点, 父子节点都选中时只返回子节点",
        "         */",
        "        treeCheckedStrategy: PropTypes.oneOf(['all', 'parent', 'child']),",
        "        /**",
        "         * 下拉框中的树是否默认展开所有节点",
        "         */",
        "        treeDefaultExpandAll: PropTypes.bool,",
        "        /**",
        "         * 下拉框中的树默认展开节点key的数组",
        "         */",
        "        treeDefaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 下拉框中的树异步加载数据的函数，使用请参考[Tree的异步加载数据Demo](https://fusion.design/component/tree)",
        "         * @param {ReactElement} node 被点击展开的节点",
        "         */",
        "        treeLoadData: PropTypes.func,",
        "        /**",
        "         * 透传到 Tree 的属性对象",
        "         */",
        "        treeProps: PropTypes.object,",
        "        /**",
        "         * 初始下拉框是否显示",
        "         */",
        "        defaultVisible: PropTypes.bool,",
        "        /**",
        "         * 当前下拉框是否显示",
        "         */",
        "        visible: PropTypes.bool,",
        "        /**",
        "         * 下拉框显示或关闭时触发事件的回调函数",
        "         * @param {Boolean} visible 是否显示",
        "         * @param {String} type 触发显示关闭的操作类型",
        "         */",
        "        onVisibleChange: PropTypes.func,",
        "        /**",
        "         * 下拉框自定义样式对象",
        "         */",
        "        popupStyle: PropTypes.object,",
        "        /**",
        "         * 下拉框样式自定义类名",
        "         */",
        "        popupClassName: PropTypes.string,",
        "        /**",
        "         * 下拉框挂载的容器节点",
        "         */",
        "        popupContainer: PropTypes.any,",
        "        /**",
        "         * 透传到 Popup 的属性对象",
        "         */",
        "        popupProps: PropTypes.object,",
        "        /**",
        "         * 是否跟随滚动",
        "         */",
        "        followTrigger: PropTypes.bool,",
        "        /**",
        "         * 是否为预览态",
        "         */",
        "        isPreview: PropTypes.bool,",
        "        /**",
        "         * 预览态模式下渲染的内容",
        "         * @param {Array<data>} value 选择值 { label: , value:}",
        "         */",
        "        renderPreview: PropTypes.func,",
        "    };",
        "",
        "    static defaultProps = {",
        "        prefix: 'next-',",
        "        pure: false,",
        "        size: 'medium',",
        "        disabled: false,",
        "        hasArrow: true,",
        "        hasBorder: true,",
        "        hasClear: false,",
        "        autoWidth: true,",
        "        defaultValue: null,",
        "        onChange: noop,",
        "        showSearch: false,",
        "        onSearch: noop,",
        "        onSearchClear: noop,",
        "        notFoundContent: 'Not Found',",
        "        multiple: false,",
        "        treeCheckable: false,",
        "        treeCheckStrictly: false,",
        "        treeCheckedStrategy: 'parent',",
        "        treeDefaultExpandAll: false,",
        "        treeDefaultExpandedKeys: [],",
        "        treeProps: {},",
        "        defaultVisible: false,",
        "        onVisibleChange: noop,",
        "    };",
        "",
        "    constructor(props, context) {",
        "        super(props, context);",
        "",
        "        const { defaultVisible, visible, defaultValue, value } = props;",
        "        this.state = {",
        "            visible: typeof visible === 'undefined' ? defaultVisible : visible,",
        "            value: normalizeToArray(",
        "                typeof value === 'undefined' ? defaultValue : value",
        "            ),",
        "            searchedValue: '',",
        "            expandedKeys: [],",
        "            autoExpandParent: false,",
        "        };",
        "",
        "        bindCtx(this, [",
        "            'handleSelect',",
        "            'handleCheck',",
        "            'handleSearch',",
        "            'handleSearchClear',",
        "            'handleVisibleChange',",
        "            'handleChange',",
        "            'handleRemove',",
        "            'handleExpand',",
        "            'handleKeyDown',",
        "            'saveTreeRef',",
        "            'saveSelectRef',",
        "        ]);",
        "",
        "        this.updateCache(props);",
        "    }",
        "",
        "    componentWillReceiveProps(nextProps) {",
        "        this.updateCache(nextProps);",
        "",
        "        const st = {};",
        "        if ('value' in nextProps) {",
        "            st.value = normalizeToArray(nextProps.value);",
        "        }",
        "        if ('visible' in nextProps) {",
        "            st.visible = nextProps.visible;",
        "        }",
        "",
        "        if (Object.keys(st).length) {",
        "            this.setState(st);",
        "        }",
        "    }",
        "",
        "    updateCache(props) {",
        "        this._k2n = {};",
        "        this._p2n = {};",
        "        this._v2n = {};",
        "",
        "        if ('dataSource' in props) {",
        "            const loop = (data, prefix = '0') =>",
        "                data.map((item, index) => {",
        "                    const { value, children } = item;",
        "                    const pos = `${prefix}-${index}`;",
        "                    const key = item.key || pos;",
        "                    const newItem = { ...item, key, pos };",
        "                    if (children && children.length) {",
        "                        newItem.children = loop(children, pos);",
        "                    }",
        "",
        "                    this._k2n[key] = this._p2n[pos] = this._v2n[",
        "                        value",
        "                    ] = newItem;",
        "                    return newItem;",
        "                });",
        "            loop(props.dataSource);",
        "        } else if ('children' in props) {",
        "            const loop = (children, prefix = '0') =>",
        "                Children.map(children, (node, index) => {",
        "                    if (!React.isValidElement(node)) {",
        "                        return;",
        "                    }",
        "",
        "                    const { value, children } = node.props;",
        "                    const pos = `${prefix}-${index}`;",
        "                    const key = node.key || pos;",
        "                    const newItem = { ...node.props, key, pos };",
        "                    if (children && Children.count(children)) {",
        "                        newItem.children = loop(children, pos);",
        "                    }",
        "",
        "                    this._k2n[key] = this._p2n[pos] = this._v2n[",
        "                        value",
        "                    ] = newItem;",
        "                    return newItem;",
        "                });",
        "            loop(props.children);",
        "        }",
        "    }",
        "",
        "    getKeysByValue(value) {",
        "        return value.reduce((ret, v) => {",
        "            const k = this._v2n[v] && this._v2n[v].key;",
        "            if (k) {",
        "                ret.push(k);",
        "            }",
        "",
        "            return ret;",
        "        }, []);",
        "    }",
        "",
        "    getValueByKeys(keys) {",
        "        return keys.map(k => this._k2n[k].value);",
        "    }",
        "",
        "    getValueForSelect(value) {",
        "        const { treeCheckedStrategy } = this.props;",
        "",
        "        let keys = this.getKeysByValue(value);",
        "        keys = getAllCheckedKeys(keys, this._k2n, this._p2n);",
        "",
        "        switch (treeCheckedStrategy) {",
        "            case 'parent':",
        "                keys = filterChildKey(keys, this._k2n, this._p2n);",
        "                break;",
        "            case 'child':",
        "                keys = filterParentKey(keys, this._k2n, this._p2n);",
        "                break;",
        "            default:",
        "                break;",
        "        }",
        "",
        "        return this.getValueByKeys(keys);",
        "    }",
        "",
        "    getData(value, forSelect) {",
        "        return value.reduce((ret, v) => {",
        "            const k = this._v2n[v] && this._v2n[v].key;",
        "            if (k) {",
        "                const { label, pos, disabled, checkboxDisabled } = this._k2n[k];",
        "                const d = {",
        "                    value: v,",
        "                    label,",
        "                    pos,",
        "                };",
        "                if (forSelect) {",
        "                    d.disabled = disabled || checkboxDisabled;",
        "                } else {",
        "                    d.key = k;",
        "                }",
        "                ret.push(d);",
        "            }",
        "",
        "            return ret;",
        "        }, []);",
        "    }",
        "",
        "    saveTreeRef(ref) {",
        "        this.tree = ref;",
        "    }",
        "",
        "    saveSelectRef(ref) {",
        "        this.select = ref;",
        "    }",
        "",
        "    handleVisibleChange(visible, type) {",
        "        if (!('visible' in this.props)) {",
        "            this.setState({",
        "                visible,",
        "            });",
        "        }",
        "",
        "        if (['fromTree', 'keyboard'].indexOf(type) !== -1 && !visible) {",
        "            this.select.focusInput();",
        "        }",
        "",
        "        this.props.onVisibleChange(visible, type);",
        "    }",
        "",
        "    handleSelect(selectedKeys, extra) {",
        "        const { multiple, onChange } = this.props;",
        "        const { selected } = extra;",
        "",
        "        if (multiple || selected) {",
        "            const value = this.getValueByKeys(selectedKeys);",
        "            if (!('value' in this.props)) {",
        "                this.setState({",
        "                    value,",
        "                });",
        "            }",
        "            if (!multiple) {",
        "                this.handleVisibleChange(false, 'fromTree');",
        "            }",
        "",
        "            const data = this.getData(value);",
        "            multiple ? onChange(value, data) : onChange(value[0], data[0]);",
        "        } else {",
        "            this.handleVisibleChange(false, 'fromTree');",
        "        }",
        "    }",
        "",
        "    handleCheck(checkedKeys) {",
        "        const { onChange } = this.props;",
        "",
        "        const value = this.getValueByKeys(checkedKeys);",
        "        if (!('value' in this.props)) {",
        "            this.setState({",
        "                value,",
        "            });",
        "        }",
        "",
        "        onChange(value, this.getData(value));",
        "    }",
        "",
        "    handleRemove(removedItem) {",
        "        const { value: removedValue } = removedItem;",
        "        const {",
        "            treeCheckable,",
        "            treeCheckStrictly,",
        "            treeCheckedStrategy,",
        "            onChange,",
        "        } = this.props;",
        "",
        "        let value;",
        "        if (",
        "            treeCheckable &&",
        "            !treeCheckStrictly &&",
        "            ['parent', 'all'].indexOf(treeCheckedStrategy) !== -1",
        "        ) {",
        "            const removedPos = this._v2n[removedValue].pos;",
        "            value = this.state.value.filter(v => {",
        "                const p = this._v2n[v].pos;",
        "                return !isDescendantOrSelf(removedPos, p);",
        "            });",
        "",
        "            const nums = removedPos.split('-');",
        "            for (let i = nums.length; i > 2; i--) {",
        "                const parentPos = nums.slice(0, i - 1).join('-');",
        "                const parentValue = this._p2n[parentPos].value;",
        "                const parentIndex = value.indexOf(parentValue);",
        "                if (parentIndex > -1) {",
        "                    value.splice(parentIndex, 1);",
        "                } else {",
        "                    break;",
        "                }",
        "            }",
        "        } else {",
        "            value = this.state.value.filter(v => v !== removedValue);",
        "        }",
        "",
        "        if (!('value' in this.props)) {",
        "            this.setState({",
        "                value,",
        "            });",
        "        }",
        "",
        "        const data = this.getData(value);",
        "        onChange(value, data);",
        "    }",
        "",
        "    handleSearch(searchedValue) {",
        "        const searchedKeys = [];",
        "        const retainedKeys = [];",
        "        Object.keys(this._k2n).forEach(k => {",
        "            const { label, pos } = this._k2n[k];",
        "            if (this.isSearched(label, searchedValue)) {",
        "                searchedKeys.push(k);",
        "                const posArr = pos.split('-');",
        "                posArr.forEach((n, i) => {",
        "                    if (i > 0) {",
        "                        const p = posArr.slice(0, i + 1).join('-');",
        "                        const kk = this._p2n[p].key;",
        "                        if (retainedKeys.indexOf(kk) === -1) {",
        "                            retainedKeys.push(kk);",
        "                        }",
        "                    }",
        "                });",
        "            }",
        "        });",
        "",
        "        this.setState({",
        "            searchedValue,",
        "            expandedKeys: searchedKeys,",
        "            autoExpandParent: true,",
        "        });",
        "        this.searchedKeys = searchedKeys;",
        "        this.retainedKeys = retainedKeys;",
        "",
        "        this.props.onSearch(searchedValue);",
        "    }",
        "",
        "    handleSearchClear(triggerType) {",
        "        this.setState({",
        "            searchedValue: '',",
        "            expandedKeys: [],",
        "        });",
        "        this.props.onSearchClear(triggerType);",
        "    }",
        "",
        "    handleExpand(expandedKeys) {",
        "        this.setState({",
        "            expandedKeys,",
        "            autoExpandParent: false,",
        "        });",
        "    }",
        "",
        "    handleKeyDown(e) {",
        "        const { onKeyDown } = this.props;",
        "        const { visible } = this.state;",
        "",
        "        if (onKeyDown) {",
        "            onKeyDown(e);",
        "        }",
        "",
        "        if (!visible) {",
        "            return;",
        "        }",
        "",
        "..."
    ],
    "src/tree/view/tree.jsx": [
        "...",
        "import TreeNode from './tree-node';",
        "import {",
        "    normalizeToArray,",
        "    isDescendantOrSelf,",
        "    isSiblingOrSelf,",
        "    filterChildKey,",
        "    filterParentKey,",
        "    getAllCheckedKeys,",
        "    forEachEnableNode,",
        "    isNodeChecked,",
        "} from './util';",
        "",
        "const { bindCtx, noop } = func;",
        "const { getOffset } = dom;",
        "const { pickOthers, isPlainObject } = obj;",
        "",
        "/**",
        " * Tree",
        " */",
        "export default class Tree extends Component {",
        "    static propTypes = {",
        "        prefix: PropTypes.string,",
        "        rtl: PropTypes.bool,",
        "        pure: PropTypes.bool,",
        "        className: PropTypes.string,",
        "        /**",
        "         * 树节点",
        "         */",
        "        children: PropTypes.node,",
        "        /**",
        "         * 数据源，该属性优先级高于 children",
        "         */",
        "        dataSource: PropTypes.array,",
        "        /**",
        "         * 是否显示树的线",
        "         */",
        "        showLine: PropTypes.bool,",
        "        /**",
        "         * 是否支持选中节点",
        "         */",
        "        selectable: PropTypes.bool,",
        "        /**",
        "         * （用于受控）当前选中节点 key 的数组",
        "         */",
        "        selectedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * （用于非受控）默认选中节点 key 的数组",
        "         */",
        "        defaultSelectedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 选中或取消选中节点时触发的回调函数",
        "         * @param {Array} selectedKeys 选中节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Array} extra.selectedNodes 选中节点的数组",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.selected 当前操作是否是选中",
        "         */",
        "        onSelect: PropTypes.func,",
        "        /**",
        "         * 是否支持多选",
        "         */",
        "        multiple: PropTypes.bool,",
        "        /**",
        "         * 是否支持勾选节点的复选框",
        "         */",
        "        checkable: PropTypes.bool,",
        "        /**",
        "         * （用于受控）当前勾选复选框节点 key 的数组或 `{checked: Array, indeterminate: Array}` 的对象",
        "         */",
        "        checkedKeys: PropTypes.oneOfType([",
        "            PropTypes.arrayOf(PropTypes.string),",
        "            PropTypes.object,",
        "        ]),",
        "        /**",
        "         * （用于非受控）默认勾选复选框节点 key 的数组",
        "         */",
        "        defaultCheckedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 勾选节点复选框是否完全受控（父子节点选中状态不再关联）",
        "         */",
        "        checkStrictly: PropTypes.bool,",
        "        /**",
        "         * 定义选中时回填的方式",
        "         * @enumdesc 返回所有选中的节点, 父子节点都选中时只返回父节点, 父子节点都选中时只返回子节点",
        "         */",
        "        checkedStrategy: PropTypes.oneOf(['all', 'parent', 'child']),",
        "        /**",
        "         * 勾选或取消勾选复选框时触发的回调函数",
        "         * @param {Array} checkedKeys 勾选复选框节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Array} extra.checkedNodes 勾选复选框节点的数组",
        "         * @param {Array} extra.checkedNodesPositions 包含有勾选复选框节点和其位置的对象的数组",
        "         * @param {Array} extra.indeterminateKeys 半选复选框节点 key 的数组",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.checked 当前操作是否是勾选",
        "         */",
        "        onCheck: PropTypes.func,",
        "        /**",
        "         * （用于受控）当前展开的节点 key 的数组",
        "         */",
        "        expandedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * （用于非受控）默认展开的节点 key 的数组",
        "         */",
        "        defaultExpandedKeys: PropTypes.arrayOf(PropTypes.string),",
        "        /**",
        "         * 是否默认展开所有节点",
        "         */",
        "        defaultExpandAll: PropTypes.bool,",
        "        /**",
        "         * 是否自动展开父节点，建议受控时设置为false",
        "         */",
        "        autoExpandParent: PropTypes.bool,",
        "        /**",
        "         * 展开或收起节点时触发的回调函数",
        "         * @param {Array} expandedKeys 展开的节点key的数组",
        "         * @param {Object} extra 额外参数",
        "         * @param {Object} extra.node 当前操作的节点",
        "         * @param {Boolean} extra.expanded 当前操作是否是展开",
        "         */",
        "        onExpand: PropTypes.func,",
        "        /**",
        "         * 是否支持编辑节点内容",
        "         */",
        "        editable: PropTypes.bool,",
        "        /**",
        "         * 编辑节点内容完成时触发的回调函数",
        "         * @param {String} key 编辑节点的 key",
        "         * @param {String} label 编辑节点完成时节点的文本",
        "         * @param {Object} node 当前编辑的节点",
        "         */",
        "        onEditFinish: PropTypes.func,",
        "        /**",
        "         * 是否支持拖拽节点",
        "         */",
        "        draggable: PropTypes.bool,",
        "        /**",
        "         * 开始拖拽节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 拖拽的节点",
        "         */",
        "        onDragStart: PropTypes.func,",
        "        /**",
        "         * 拖拽节点进入目标节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Array} info.expandedKeys 当前展开的节点key的数组",
        "         */",
        "        onDragEnter: PropTypes.func,",
        "        /**",
        "         * 拖拽节点在目标节点上移动的时候触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragOver: PropTypes.func,",
        "        /**",
        "         * 拖拽节点离开目标节点时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragLeave: PropTypes.func,",
        "        /**",
        "         * 拖拽节点拖拽结束时触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         */",
        "        onDragEnd: PropTypes.func,",
        "        /**",
        "         * 拖拽节点放入目标节点内或前后触发的回调函数",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Object} info.dragNode 拖拽的节点",
        "         * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点 key 的数组",
        "         * @param {Number} info.dropPosition 放置位置，-1代表当前节点前，0代表当前节点里，1代表当前节点后",
        "         */",
        "        onDrop: PropTypes.func,",
        "        /**",
        "         * 节点是否可被作为拖拽的目标节点",
        "         * @param {Object} info 拖拽信息",
        "         * @param {Object} info.node 目标节点",
        "         * @param {Object} info.dragNode 拖拽的节点",
        "         * @param {Array} info.dragNodesKeys 拖拽的节点和其子节点 key 的数组",
        "         * @param {Number} info.dropPosition 放置位置，-1代表当前节点前，0代表当前节点里，1代表当前节点后",
        "         * @return {Boolean} 是否可以被当作目标节点",
        "         */",
        "        canDrop: PropTypes.func,",
        "        /**",
        "         * 异步加载数据的函数",
        "         * @param {Object} node 被点击展开的节点",
        "         */",
        "        loadData: PropTypes.func,",
        "        /**",
        "         * 按需筛选高亮节点",
        "         * @param {Object} node 待筛选的节点",
        "         * @return {Boolean} 是否被筛选中",
        "         */",
        "        filterTreeNode: PropTypes.func,",
        "        /**",
        "         * 右键点击节点时触发的回调函数",
        "         * @param {Object} info 信息对象",
        "         * @param {Object} info.event 事件对象",
        "         * @param {Object} info.node 点击的节点",
        "         */",
        "        onRightClick: PropTypes.func,",
        "        /**",
        "         * 设置节点是否占满剩余空间，一般用于统一在各节点右侧添加元素(借助 flex 实现，暂时只支持 ie10+)",
        "         */",
        "        isLabelBlock: PropTypes.bool,",
        "        /**",
        "         * 设置节点是否占满一行",
        "         */",
        "        isNodeBlock: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),",
        "        /**",
        "         * 是否开启展开收起动画",
        "         */",
        "        animation: PropTypes.bool,",
        "        /**",
        "         * 当前获得焦点的子菜单或菜单项 key 值",
        "         */",
        "        focusedKey: PropTypes.string,",
        "        /**",
        "         * 渲染子节点",
        "         * @param {Array<ReactNode>} nodes 所有的子节点",
        "         * @return {ReactNode} 返回节点",
        "         */",
        "        renderChildNodes: PropTypes.func,",
        "        focusable: PropTypes.bool,",
        "        autoFocus: PropTypes.bool,",
        "        onItemFocus: PropTypes.func,",
        "        onBlur: PropTypes.func,",
        "        onItemKeyDown: PropTypes.func,",
        "    };",
        "",
        "    static defaultProps = {",
        "        prefix: 'next-',",
        "        rtl: false,",
        "        pure: false,",
        "        showLine: false,",
        "        selectable: true,",
        "        editable: false,",
        "        multiple: false,",
        "        checkable: false,",
        "        checkStrictly: false,",
        "        checkedStrategy: 'all',",
        "        draggable: false,",
        "        autoExpandParent: true,",
        "        defaultExpandAll: false,",
        "        defaultExpandedKeys: [],",
        "        defaultCheckedKeys: [],",
        "        defaultSelectedKeys: [],",
        "        onExpand: noop,",
        "        onCheck: noop,",
        "        onSelect: noop,",
        "        onDragStart: noop,",
        "        onDragEnter: noop,",
        "        onDragOver: noop,",
        "        onDragLeave: noop,",
        "        onDragEnd: noop,",
        "        onDrop: noop,",
        "        canDrop: () => true,",
        "        onEditFinish: noop,",
        "        onRightClick: noop,",
        "        isLabelBlock: false,",
        "        isNodeBlock: false,",
        "        animation: true,",
        "        focusable: true,",
        "        autoFocus: false,",
        "        onItemFocus: noop,",
        "        onItemKeyDown: noop,",
        "    };",
        "",
        "    constructor(props) {",
        "        super(props);",
        "",
        "        this.updateCache(props);",
        "",
        "        const { focusable, autoFocus, focusedKey } = this.props;",
        "",
        "        if (focusable) {",
        "            this.tabbableKey = this.getFirstAvaliablelChildKey('0');",
        "        }",
        "",
        "        this.indeterminateKeys = [];",
        "        this.state = {",
        "            expandedKeys: this.getExpandedKeys(props),",
        "            selectedKeys: this.getSelectedKeys(props),",
        "            checkedKeys: this.getCheckedKeys(props),",
        "            focusedKey:",
        "                'focusedKey' in this.props",
        "                    ? focusedKey",
        "                    : focusable && autoFocus",
        "                    ? this.tabbableKey",
        "                    : null,",
        "        };",
        "",
        "        bindCtx(this, [",
        "            'handleExpand',",
        "            'handleSelect',",
        "            'handleCheck',",
        "            'handleBlur',",
        "        ]);",
        "    }",
        "",
        "    componentWillReceiveProps(nextProps) {",
        "        this.updateCache(nextProps);",
        "",
        "        const st = {};",
        "",
        "        if ('expandedKeys' in nextProps) {",
        "            st.expandedKeys = this.getExpandedKeys(nextProps, true);",
        "        }",
        "        if ('selectedKeys' in nextProps) {",
        "            st.selectedKeys = this.getSelectedKeys(nextProps, true);",
        "        }",
        "        if ('checkedKeys' in nextProps) {",
        "            st.checkedKeys = this.getCheckedKeys(nextProps, true);",
        "        }",
        "",
        "        this.indeterminateKeys = this.getIndeterminateKeys(",
        "            st.checkedKeys || this.state.checkedKeys || []",
        "        );",
        "",
        "        if (Object.keys(st).length) {",
        "            this.setState(st);",
        "        }",
        "    }",
        "",
        "    updateCache(props) {",
        "        this._k2n = {};",
        "        this._p2n = {};",
        "",
        "        if ('dataSource' in props) {",
        "            const loop = (data, prefix = '0') =>",
        "                data.forEach((item, index) => {",
        "                    const pos = `${prefix}-${index}`;",
        "                    let { key } = item;",
        "                    key = key || pos;",
        "                    const newItem = { ...item, key, pos };",
        "                    const { children } = item;",
        "                    if (children && children.length) {",
        "                        loop(children, pos);",
        "                    }",
        "                    this._k2n[key] = this._p2n[pos] = newItem;",
        "                });",
        "            loop(props.dataSource);",
        "        } else if ('children' in props) {",
        "            const loop = (children, prefix = '0') =>",
        "                Children.map(children, (node, index) => {",
        "                    if (!React.isValidElement(node)) {",
        "                        return;",
        "                    }",
        "",
        "                    const pos = `${prefix}-${index}`;",
        "                    let { key } = node;",
        "                    key = key || pos;",
        "                    const newItem = { ...node.props, key, pos };",
        "",
        "                    const { children } = node.props;",
        "                    if (children && Children.count(children)) {",
        "                        newItem.children = loop(children, pos);",
        "                    }",
        "                    this._k2n[key] = this._p2n[pos] = newItem;",
        "                    return newItem;",
        "                });",
        "            loop(props.children);",
        "        }",
        "    }",
        "",
        "    setFocusKey() {",
        "        const { selectedKeys = [] } = this.state;",
        "        this.setState({",
        "            focusedKey:",
        "                selectedKeys.length > 0",
        "                    ? selectedKeys[0]",
        "                    : this.getFirstAvaliablelChildKey('0'),",
        "        });",
        "    }",
        "",
        "    getExpandedKeys(props, willReceiveProps) {",
        "        let expandedKeys;",
        "",
        "        if (!willReceiveProps && props.defaultExpandAll) {",
        "            expandedKeys = Object.keys(this._k2n).filter(key => {",
        "                const children = this._k2n[key].children;",
        "                return children && children.length;",
        "            });",
        "        } else {",
        "            expandedKeys =",
        "                'expandedKeys' in props",
        "                    ? props.expandedKeys",
        "                    : willReceiveProps",
        "                    ? []",
        "                    : props.defaultExpandedKeys;",
        "            expandedKeys = normalizeToArray(expandedKeys);",
        "",
        "            if (props.autoExpandParent) {",
        "                const newExpandedKeys = [];",
        "",
        "                const expandedPoss = expandedKeys.reduce((ret, key) => {",
        "                    const pos = this._k2n[key] && this._k2n[key].pos;",
        "                    if (pos) {",
        "                        ret.push(pos);",
        "                        newExpandedKeys.push(key);",
        "                    }",
        "                    return ret;",
        "                }, []);",
        "",
        "                expandedPoss.forEach(pos => {",
        "                    const nums = pos.split('-');",
        "                    if (nums.length === 2) {",
        "                        return;",
        "                    }",
        "                    for (let i = 1; i <= nums.length - 2; i++) {",
        "                        const ancestorPos = nums.slice(0, i + 1).join('-');",
        "                        const ancestorKey = this._p2n[ancestorPos].key;",
        "                        if (newExpandedKeys.indexOf(ancestorKey) === -1) {",
        "                            newExpandedKeys.push(ancestorKey);",
        "                        }",
        "                    }",
        "                });",
        "",
        "                return newExpandedKeys;",
        "            }",
        "        }",
        "",
        "        return expandedKeys;",
        "    }",
        "",
        "    getAvailableKey(pos, prev) {",
        "        const ps = Object.keys(this._p2n).filter(p =>",
        "            this.isAvailablePos(pos, p)",
        "        );",
        "        if (ps.length > 1) {",
        "            const index = ps.indexOf(pos);",
        "            let targetIndex;",
        "            if (prev) {",
        "                targetIndex = index === 0 ? ps.length - 1 : index - 1;",
        "            } else {",
        "                targetIndex = index === ps.length - 1 ? 0 : index + 1;",
        "            }",
        "",
        "            return this._p2n[ps[targetIndex]].key;",
        "        }",
        "",
        "        return null;",
        "    }",
        "",
        "    getFirstAvaliablelChildKey(parentPos) {",
        "        const pos = Object.keys(this._p2n).find(p =>",
        "            this.isAvailablePos(`${parentPos}-0`, p)",
        "        );",
        "        return pos ? this._p2n[pos].key : null;",
        "    }",
        "",
        "    isAvailablePos(refPos, targetPos) {",
        "        const { disabled } = this._p2n[targetPos];",
        "",
        "        return this.isSibling(refPos, targetPos) && !disabled;",
        "    }",
        "",
        "    isSibling(currentPos, targetPos) {",
        "        const currentNums = currentPos.split('-').slice(0, -1);",
        "        const targetNums = targetPos.split('-').slice(0, -1);",
        "",
        "        return (",
        "            currentNums.length === targetNums.length &&",
        "            currentNums.every((num, index) => {",
        "                return num === targetNums[index];",
        "            })",
        "        );",
        "    }",
        "",
        "    getParentKey(pos) {",
        "        return this._p2n[pos.slice(0, pos.length - 2)].key;",
        "    }",
        "",
        "    getSelectedKeys(props, willReceiveProps) {",
        "        let selectedKeys =",
        "            'selectedKeys' in props",
        "                ? props.selectedKeys",
        "                : willReceiveProps",
        "                ? []",
        "                : props.defaultSelectedKeys;",
        "        selectedKeys = normalizeToArray(selectedKeys);",
        "",
        "        const newSelectKeys = selectedKeys.filter(key => {",
        "            return this._k2n[key];",
        "        });",
        "        return newSelectKeys;",
        "    }",
        "",
        "    /* istanbul ignore next */",
        "    getCheckedKeys(props, willReceiveProps) {",
        "        let checkedKeys = props.defaultCheckedKeys;",
        "",
        "..."
    ]
}