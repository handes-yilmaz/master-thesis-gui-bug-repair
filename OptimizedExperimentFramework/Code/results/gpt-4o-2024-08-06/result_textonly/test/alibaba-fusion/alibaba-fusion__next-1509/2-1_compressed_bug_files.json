{
    "1": {
        "bug_file": "src/dialog/dialog.jsx",
        "compressed": "NO",
        "line_numbers": 408,
        "compressed_line_numbers": 408,
        "compressed_bug_file_content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Overlay from '../overlay';\nimport zhCN from '../locale/zh-cn';\nimport { focus, obj, func, events, dom } from '../util';\nimport Inner from './inner';\n\nconst noop = () => {};\nconst { limitTabRange } = focus;\nconst { bindCtx } = func;\nconst { pickOthers } = obj;\nconst { getStyle, setStyle } = dom;\n\n/**\n * Dialog\n */\nexport default class Dialog extends Component {\n    static propTypes = {\n        prefix: PropTypes.string,\n        pure: PropTypes.bool,\n        rtl: PropTypes.bool,\n        className: PropTypes.string,\n        /**\n         * 是否显示\n         */\n        visible: PropTypes.bool,\n        /**\n         * 标题\n         */\n        title: PropTypes.node,\n        /**\n         * 内容\n         */\n        children: PropTypes.node,\n        /**\n         * 底部内容，设置为 false，则不进行显示\n         * @default [<Button type=\"primary\">确定</Button>, <Button>取消</Button>]\n         */\n        footer: PropTypes.oneOfType([PropTypes.bool, PropTypes.node]),\n        /**\n         * 底部按钮的对齐方式\n         */\n        footerAlign: PropTypes.oneOf(['left', 'center', 'right']),\n        /**\n         * 指定确定按钮和取消按钮是否存在以及如何排列,<br><br>**可选值**：\n         * ['ok', 'cancel']（确认取消按钮同时存在，确认按钮在左）\n         * ['cancel', 'ok']（确认取消按钮同时存在，确认按钮在右）\n         * ['ok']（只存在确认按钮）\n         * ['cancel']（只存在取消按钮）\n         */\n        footerActions: PropTypes.array,\n        /**\n         * 在点击确定按钮时触发的回调函数\n         * @param {Object} event 点击事件对象\n         */\n        onOk: PropTypes.func,\n        /**\n         * 在点击取消按钮时触发的回调函数\n         * @param {Object} event 点击事件对象\n         */\n        onCancel: PropTypes.func,\n        /**\n         * 应用于确定按钮的属性对象\n         */\n        okProps: PropTypes.object,\n        /**\n         * 应用于取消按钮的属性对象\n         */\n        cancelProps: PropTypes.object,\n        /**\n         * 控制对话框关闭的方式，值可以为字符串或者布尔值，其中字符串是由以下值组成：\n         * **close** 表示点击关闭按钮可以关闭对话框\n         * **mask** 表示点击遮罩区域可以关闭对话框\n         * **esc** 表示按下 esc 键可以关闭对话框\n         * 如 'close' 或 'close,esc,mask'\n         * 如果设置为 true，则以上关闭方式全部生效\n         * 如果设置为 false，则以上关闭方式全部失效\n         */\n        closeable: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n        /**\n         * 对话框关闭时触发的回调函数\n         * @param {String} trigger 关闭触发行为的描述字符串\n         * @param {Object} event 关闭时事件对象\n         */\n        onClose: PropTypes.func,\n        /**\n         * 对话框关闭后触发的回调函数, 如果有动画，则在动画结束后触发\n         */\n        afterClose: PropTypes.func,\n        /**\n         * 是否显示遮罩\n         */\n        hasMask: PropTypes.bool,\n        /**\n         * 显示隐藏时动画的播放方式\n         * @property {String} in 进场动画\n         * @property {String} out 出场动画\n         */\n        animation: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),\n        /**\n         * 对话框弹出时是否自动获得焦点\n         */\n        autoFocus: PropTypes.bool,\n        /**\n         * 对话框对齐方式, 具体见Overlay文档\n         */\n        align: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n        /**\n         * 当对话框高度超过浏览器视口高度时，是否显示所有内容而不是出现滚动条以保证对话框完整显示在浏览器视口内，该属性仅在对话框垂直水平居中时生效，即 align 被设置为 'cc cc' 时\n         */\n        isFullScreen: PropTypes.bool,\n        /**\n         * 是否在对话框重新渲染时及时更新对话框位置，一般用于对话框高度变化后依然能保证原来的对齐方式\n         */\n        shouldUpdatePosition: PropTypes.bool,\n        /**\n         * 对话框距离浏览器顶部和底部的最小间距，align 被设置为 'cc cc' 并且 isFullScreen 被设置为 true 时不生效\n         */\n        minMargin: PropTypes.number,\n        /**\n         * 透传到弹层组件的属性对象\n         */\n        overlayProps: PropTypes.object,\n        /**\n         * 自定义国际化文案对象\n         * @property {String} ok 确认按钮文案\n         * @property {String} cancel 取消按钮文案\n         */\n        locale: PropTypes.object,\n        /**\n         * 对话框的高度样式属性\n         */\n        height: PropTypes.string,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        pure: false,\n        visible: false,\n        footerAlign: 'right',\n        footerActions: ['ok', 'cancel'],\n        onOk: noop,\n        onCancel: noop,\n        okProps: {},\n        cancelProps: {},\n        closeable: 'esc,close',\n        onClose: noop,\n        afterClose: noop,\n        hasMask: true,\n        animation: {\n            in: 'fadeInDown',\n            out: 'fadeOutUp',\n        },\n        autoFocus: false,\n        align: 'cc cc',\n        isFullScreen: false,\n        shouldUpdatePosition: false,\n        minMargin: 40,\n        overlayProps: {},\n        locale: zhCN.Dialog,\n    };\n\n    constructor(props, context) {\n        super(props, context);\n        bindCtx(this, [\n            'onKeyDown',\n            'beforePosition',\n            'adjustPosition',\n            'getOverlayRef',\n        ]);\n    }\n\n    componentDidMount() {\n        events.on(document, 'keydown', this.onKeyDown);\n        if (!this.useCSSToPosition()) {\n            this.adjustPosition();\n        }\n    }\n\n    componentWillUnmount() {\n        events.off(document, 'keydown', this.onKeyDown);\n    }\n\n    useCSSToPosition() {\n        const { align, isFullScreen } = this.props;\n        return align === 'cc cc' && isFullScreen;\n    }\n\n    onKeyDown(e) {\n        const node = this.getInnerNode();\n        if (node) {\n            limitTabRange(node, e);\n        }\n    }\n\n    beforePosition() {\n        if (this.props.visible && this.overlay) {\n            const inner = this.getInner();\n            if (inner) {\n                const node = this.getInnerNode();\n                if (this._lastDialogHeight !== getStyle(node, 'height')) {\n                    this.revertSize(inner.bodyNode);\n                }\n            }\n        }\n    }\n\n    adjustPosition() {\n        if (this.props.visible && this.overlay) {\n            const inner = this.getInner();\n            if (inner) {\n                const node = this.getInnerNode();\n\n                let top = getStyle(node, 'top');\n                const minMargin = this.props.minMargin;\n                if (top < minMargin) {\n                    top = minMargin;\n                    setStyle(node, 'top', `${minMargin}px`);\n                }\n\n                const height = getStyle(node, 'height');\n                const viewportHeight =\n                    window.innerHeight || document.documentElement.clientHeight;\n                if (viewportHeight < height + top * 2) {\n                    const expectHeight = viewportHeight - top * 2;\n                    this.adjustSize(inner, node, expectHeight);\n                } else {\n                    this.revertSize(inner.bodyNode);\n                }\n\n                this._lastDialogHeight = height;\n            }\n        }\n    }\n\n    adjustSize(inner, node, expectHeight) {\n        const { headerNode, bodyNode, footerNode } = inner;\n\n        const headerHeight = headerNode ? getStyle(headerNode, 'height') : 0;\n        const footerHeight = footerNode ? getStyle(footerNode, 'height') : 0;\n        const padding =\n            getStyle(node, 'padding-top') + getStyle(node, 'padding-bottom');\n        let maxBodyHeight =\n            expectHeight - headerHeight - footerHeight - padding;\n        if (maxBodyHeight < 0) {\n            maxBodyHeight = 1;\n        }\n\n        if (bodyNode) {\n            this.dialogBodyStyleMaxHeight = bodyNode.style.maxHeight;\n            this.dialogBodyStyleOverflowY = bodyNode.style.overflowY;\n\n            setStyle(bodyNode, {\n                'max-height': `${maxBodyHeight}px`,\n                'overflow-y': 'auto',\n            });\n        }\n    }\n\n    revertSize(bodyNode) {\n        setStyle(bodyNode, {\n            'max-height': this.dialogBodyStyleMaxHeight,\n            'overflow-y': this.dialogBodyStyleOverflowY,\n        });\n    }\n\n    mapcloseableToConfig(closeable) {\n        return ['esc', 'close', 'mask'].reduce((ret, option) => {\n            const key = option.charAt(0).toUpperCase() + option.substr(1);\n            const value =\n                typeof closeable === 'boolean'\n                    ? closeable\n                    : closeable.split(',').indexOf(option) > -1;\n\n            if (option === 'esc' || option === 'mask') {\n                ret[`canCloseBy${key}`] = value;\n            } else {\n                ret[`canCloseBy${key}Click`] = value;\n            }\n\n            return ret;\n        }, {});\n    }\n\n    getOverlayRef(ref) {\n        this.overlay = ref;\n    }\n\n    getInner() {\n        return this.overlay.getInstance().getContent();\n    }\n\n    getInnerNode() {\n        return this.overlay.getInstance().getContentNode();\n    }\n\n    renderInner(closeable) {\n        const {\n            prefix,\n            className,\n            title,\n            children,\n            footer,\n            footerAlign,\n            footerActions,\n            onOk,\n            onCancel,\n            okProps,\n            cancelProps,\n            onClose,\n            locale,\n            visible,\n            rtl,\n            height,\n        } = this.props;\n        const others = pickOthers(Object.keys(Dialog.propTypes), this.props);\n\n        return (\n            <Inner\n                prefix={prefix}\n                className={className}\n                title={title}\n                footer={footer}\n                footerAlign={footerAlign}\n                footerActions={footerActions}\n                onOk={visible ? onOk : noop}\n                onCancel={visible ? onCancel : noop}\n                okProps={okProps}\n                cancelProps={cancelProps}\n                locale={locale}\n                closeable={closeable}\n                rtl={rtl}\n                onClose={onClose.bind(this, 'closeClick')}\n                height={height}\n                {...others}\n            >\n                {children}\n            </Inner>\n        );\n    }\n\n    render() {\n        const {\n            prefix,\n            visible,\n            hasMask,\n            animation,\n            autoFocus,\n            closeable,\n            onClose,\n            afterClose,\n            shouldUpdatePosition,\n            align,\n            overlayProps,\n            rtl,\n        } = this.props;\n\n        const useCSS = this.useCSSToPosition();\n        const {\n            canCloseByCloseClick,\n            ...closeConfig\n        } = this.mapcloseableToConfig(closeable);\n        const newOverlayProps = {\n            disableScroll: true,\n            ...overlayProps,\n            prefix,\n            visible,\n            animation,\n            hasMask,\n            autoFocus,\n            afterClose,\n            ...closeConfig,\n            canCloseByOutSideClick: false,\n            align: useCSS ? false : align,\n            onRequestClose: onClose,\n            needAdjust: false,\n            ref: this.getOverlayRef,\n            rtl,\n            maskClass: useCSS ? `${prefix}dialog-container` : '',\n            isChildrenInMask: useCSS && hasMask,\n        };\n        if (!useCSS) {\n            newOverlayProps.beforePosition = this.beforePosition;\n            newOverlayProps.onPosition = this.adjustPosition;\n            newOverlayProps.shouldUpdatePosition = shouldUpdatePosition;\n        }\n\n        const inner = this.renderInner(canCloseByCloseClick);\n\n        // useCSS && hasMask : isFullScreen 并且 有mask的模式下，为了解决 next-overlay-backdrop 覆盖mask，使得点击mask关闭页面的功能不生效的问题，需要开启 Overlay 的 isChildrenInMask 功能，并且把 next-dialog-container 放到 next-overlay-backdrop上\n        // useCSS && !hasMask : isFullScreen 并且 没有mask的情况下，需要关闭 isChildrenInMask 功能，以防止children不渲染\n        // 其他模式下维持 mask 与 children 同级的关系\n        return (\n            <Overlay {...newOverlayProps}>\n                {useCSS && !hasMask ? (\n                    <div\n                        className={`${prefix}dialog-container`}\n                        dir={rtl ? 'rtl' : undefined}\n                    >\n                        {inner}\n                    </div>\n                ) : (\n                    inner\n                )}\n            </Overlay>\n        );\n    }\n}"
    },
    "2": {
        "bug_file": "src/dialog/index.jsx",
        "compressed": "NO",
        "line_numbers": 71,
        "compressed_line_numbers": 71,
        "compressed_bug_file_content": "import ConfigProvider from '../config-provider';\nimport { log } from '../util';\nimport Dialog from './dialog';\nimport Inner from './inner';\nimport { show, alert, confirm } from './show';\n\nDialog.Inner = Inner;\nDialog.show = config => {\n    const { warning } = ConfigProvider.getContextProps(config, 'Dialog');\n    if (warning !== false) {\n        config = processProps(config, log.deprecated);\n    }\n    return show(config);\n};\nDialog.alert = config => {\n    const { warning } = ConfigProvider.getContextProps(config, 'Dialog');\n    if (warning !== false) {\n        config = processProps(config, log.deprecated);\n    }\n    return alert(config);\n};\nDialog.confirm = config => {\n    const { warning } = ConfigProvider.getContextProps(config, 'Dialog');\n    if (warning !== false) {\n        config = processProps(config, log.deprecated);\n    }\n    return confirm(config);\n};\n\n/* istanbul ignore next */\nfunction processProps(props, deprecated) {\n    if ('closable' in props) {\n        deprecated('closable', 'closeable', 'Dialog');\n        const { closable, ...others } = props;\n        props = { closeable: closable, ...others };\n    }\n\n    const overlayPropNames = [\n        'target',\n        'offset',\n        'beforeOpen',\n        'onOpen',\n        'afterOpen',\n        'beforePosition',\n        'onPosition',\n        'cache',\n        'safeNode',\n        'wrapperClassName',\n        'container',\n    ];\n    overlayPropNames.forEach(name => {\n        if (name in props) {\n            deprecated(name, `overlayProps.${name}`, 'Dialog');\n            const { overlayProps, ...others } = props;\n            const newOverlayProps = {\n                [name]: props[name],\n                ...(overlayProps || {}),\n            };\n            delete others[name];\n            props = { overlayProps: newOverlayProps, ...others };\n        }\n    });\n\n    return props;\n}\n\nexport default ConfigProvider.config(Dialog, {\n    transform: (props, deprecated) => {\n        return processProps(props, deprecated);\n    },\n});"
    },
    "3": {
        "bug_file": "src/config-provider/config.jsx",
        "compressed": "NO",
        "line_numbers": 260,
        "compressed_line_numbers": 260,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { obj, log } from '../util';\nimport getContextProps from './get-context-props';\nimport ErrorBoundary from './error-boundary';\n\nconst { shallowEqual } = obj;\n\nfunction getDisplayName(Component) {\n    return Component.displayName || Component.name || 'Component';\n}\n\nlet globalLocales;\nlet currentGlobalLanguage = 'zh-cn';\nlet currentGlobalLocale = {};\nlet currentGlobalRtl;\n\nexport function initLocales(locales) {\n    globalLocales = locales;\n\n    if (locales) {\n        currentGlobalLocale = locales[currentGlobalLanguage];\n\n        if (typeof currentGlobalRtl !== 'boolean') {\n            currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n        }\n    }\n}\n\nexport function setLanguage(language) {\n    if (globalLocales) {\n        currentGlobalLanguage = language;\n        currentGlobalLocale = globalLocales[language];\n\n        if (typeof currentGlobalRtl !== 'boolean') {\n            currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n        }\n    }\n}\n\nexport function setLocale(locale) {\n    currentGlobalLocale = {\n        ...(globalLocales ? globalLocales[currentGlobalLanguage] : {}),\n        ...locale,\n    };\n\n    if (typeof currentGlobalRtl !== 'boolean') {\n        currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n    }\n}\n\nexport function setDirection(dir) {\n    currentGlobalRtl = dir === 'rtl';\n}\n\nexport function getLocale() {\n    return currentGlobalLocale;\n}\n\nexport function getLanguage() {\n    return currentGlobalLanguage;\n}\n\nexport function getDirection() {\n    return currentGlobalRtl;\n}\n\nexport function config(Component, options = {}) {\n    // 非 forwardRef 创建的 class component\n    if (\n        obj.isClassComponent(Component) &&\n        Component.prototype.shouldComponentUpdate === undefined\n    ) {\n        // class component: 通过定义 shouldComponentUpdate 改写成 pure component, 有refs\n        Component.prototype.shouldComponentUpdate = function shouldComponentUpdate(\n            nextProps,\n            nextState\n        ) {\n            if (this.props.pure) {\n                return (\n                    !shallowEqual(this.props, nextProps) ||\n                    !shallowEqual(this.state, nextState)\n                );\n            }\n\n            return true;\n        };\n    }\n\n    class ConfigedComponent extends React.Component {\n        static propTypes = {\n            ...(Component.propTypes || {}),\n            prefix: PropTypes.string,\n            locale: PropTypes.object,\n            pure: PropTypes.bool,\n            rtl: PropTypes.bool,\n            device: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n            popupContainer: PropTypes.oneOfType([\n                PropTypes.string,\n                PropTypes.func,\n            ]),\n            errorBoundary: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.object,\n            ]),\n        };\n        static contextTypes = {\n            ...(Component.contextTypes || {}),\n            nextPrefix: PropTypes.string,\n            nextLocale: PropTypes.object,\n            nextPure: PropTypes.bool,\n            nextRtl: PropTypes.bool,\n            nextWarning: PropTypes.bool,\n            nextDevice: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n            nextPopupContainer: PropTypes.oneOfType([\n                PropTypes.string,\n                PropTypes.func,\n            ]),\n            nextErrorBoundary: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.object,\n            ]),\n        };\n\n        constructor(props, context) {\n            super(props, context);\n\n            this._getInstance = this._getInstance.bind(this);\n            this._deprecated = this._deprecated.bind(this);\n        }\n\n        _getInstance(ref) {\n            this._instance = ref;\n\n            if (this._instance && options.exportNames) {\n                options.exportNames.forEach(name => {\n                    const field = this._instance[name];\n                    if (typeof field === 'function') {\n                        this[name] = field.bind(this._instance);\n                    } else {\n                        this[name] = field;\n                    }\n                });\n            }\n        }\n\n        _deprecated(...args) {\n            if (this.context.nextWarning !== false) {\n                log.deprecated(...args);\n            }\n        }\n\n        getInstance() {\n            return this._instance;\n        }\n\n        render() {\n            const {\n                prefix,\n                locale,\n                pure,\n                rtl,\n                device,\n                popupContainer,\n                errorBoundary,\n                ...others\n            } = this.props;\n            const {\n                nextPrefix,\n                nextLocale = {},\n                nextPure,\n                nextRtl,\n                nextDevice,\n                nextPopupContainer,\n                nextErrorBoundary,\n            } = this.context;\n\n            const displayName =\n                options.componentName || getDisplayName(Component);\n            const contextProps = getContextProps(\n                {\n                    prefix,\n                    locale,\n                    pure,\n                    device,\n                    popupContainer,\n                    rtl,\n                    errorBoundary,\n                },\n                {\n                    nextPrefix,\n                    nextLocale: { ...currentGlobalLocale, ...nextLocale },\n                    nextPure,\n                    nextDevice,\n                    nextPopupContainer,\n                    nextRtl:\n                        typeof nextRtl === 'boolean'\n                            ? nextRtl\n                            : currentGlobalRtl === true\n                            ? true\n                            : undefined,\n                    nextErrorBoundary,\n                },\n                displayName\n            );\n\n            // errorBoundary is only for <ErrorBoundary>\n            const newContextProps = [\n                'prefix',\n                'locale',\n                'pure',\n                'rtl',\n                'device',\n                'popupContainer',\n            ].reduce((ret, name) => {\n                if (typeof contextProps[name] !== 'undefined') {\n                    ret[name] = contextProps[name];\n                }\n                return ret;\n            }, {});\n\n            if ('pure' in newContextProps && newContextProps.pure) {\n                log.warning(\n                    'pure of ConfigProvider is deprecated, use Function Component or React.PureComponent'\n                );\n            }\n\n            const newOthers = options.transform\n                ? options.transform(others, this._deprecated)\n                : others;\n\n            const content = (\n                <Component\n                    {...newOthers}\n                    {...newContextProps}\n                    ref={\n                        obj.isClassComponent(Component)\n                            ? this._getInstance\n                            : null\n                    }\n                />\n            );\n\n            const { open, ...othersBoundary } = contextProps.errorBoundary;\n\n            return open ? (\n                <ErrorBoundary {...othersBoundary}>{content}</ErrorBoundary>\n            ) : (\n                content\n            );\n        }\n    }\n\n    ConfigedComponent.displayName = `Config(${getDisplayName(Component)})`;\n\n    hoistNonReactStatic(ConfigedComponent, Component);\n\n    return ConfigedComponent;\n}"
    },
    "4": {
        "bug_file": "src/config-provider/index.jsx",
        "compressed": "NO",
        "line_numbers": 233,
        "compressed_line_numbers": 233,
        "compressed_bug_file_content": "import { Component, Children } from 'react';\nimport PropTypes from 'prop-types';\nimport { polyfill } from 'react-lifecycles-compat';\nimport getContextProps from './get-context-props';\nimport {\n    config,\n    initLocales,\n    setLanguage,\n    setLocale,\n    setDirection,\n    getLocale,\n    getLanguage,\n    getDirection,\n} from './config';\nimport Consumer from './consumer';\nimport ErrorBoundary from './error-boundary';\nimport Cache from './cache';\n\nconst childContextCache = new Cache();\n\nconst setMomentLocale = locale => {\n    let moment;\n    try {\n        moment = require('moment');\n    } catch (e) {\n        // ignore\n    }\n\n    if (moment && locale) {\n        moment.locale(locale.momentLocale);\n    }\n};\n/**\n * ConfigProvider\n * @propsExtends false\n */\nclass ConfigProvider extends Component {\n    static propTypes = {\n        /**\n         * 样式类名的品牌前缀\n         */\n        prefix: PropTypes.string,\n        /**\n         * 国际化文案对象，属性为组件的 displayName\n         */\n        locale: PropTypes.object,\n        /**\n         * 是否开启错误捕捉 errorBoundary\n         * 如需自定义参数，请传入对象 对象接受参数列表如下：\n         *\n         * fallbackUI `Function(error?: {}, errorInfo?: {}) => Element` 捕获错误后的展示\n         * afterCatch `Function(error?: {}, errorInfo?: {})` 捕获错误后的行为, 比如埋点上传\n         */\n        errorBoundary: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),\n        /**\n         * 是否开启 Pure Render 模式，会提高性能，但是也会带来副作用\n         */\n        pure: PropTypes.bool,\n        /**\n         * 是否在开发模式下显示组件属性被废弃的 warning 提示\n         */\n        warning: PropTypes.bool,\n        /**\n         * 是否开启 rtl 模式\n         */\n        rtl: PropTypes.bool,\n        /**\n         * 设备类型，针对不同的设备类型组件做出对应的响应式变化\n         */\n        device: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n        /**\n         * 组件树\n         */\n        children: PropTypes.any,\n        /**\n         * 指定浮层渲染的父节点, 可以为节点id的字符串，也可以返回节点的函数\n         */\n        popupContainer: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n    };\n\n    static defaultProps = {\n        warning: true,\n        errorBoundary: false,\n    };\n\n    static childContextTypes = {\n        nextPrefix: PropTypes.string,\n        nextLocale: PropTypes.object,\n        nextPure: PropTypes.bool,\n        nextRtl: PropTypes.bool,\n        nextWarning: PropTypes.bool,\n        nextDevice: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n        nextPopupContainer: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.func,\n        ]),\n        nextErrorBoundary: PropTypes.oneOfType([\n            PropTypes.bool,\n            PropTypes.object,\n        ]),\n    };\n\n    /**\n     * 传入组件，生成受 ConfigProvider 控制的 HOC 组件\n     * @param {Component} Component 组件类\n     * @param {Object} options 可选项\n     * @returns {Component} HOC\n     */\n    static config = (Component, options) => {\n        return config(Component, options);\n    };\n\n    /**\n     * 传入组件的 props 和 displayName，得到和 childContext 计算过的包含有 preifx/locale/pure 的对象，一般用于通过静态方法生成脱离组件树的组件\n     * @param {Object} props 组件的 props\n     * @param {String} displayName 组件的 displayName\n     * @returns {Object} 新的 context props\n     */\n    static getContextProps = (props, displayName) => {\n        return getContextProps(\n            props,\n            childContextCache.root() || {},\n            displayName\n        );\n    };\n\n    static initLocales = initLocales;\n    static setLanguage = setLanguage;\n    static setLocale = setLocale;\n    static setDirection = setDirection;\n    static getLanguage = getLanguage;\n    static getLocale = getLocale;\n    static getDirection = getDirection;\n    static Consumer = Consumer;\n    static ErrorBoundary = ErrorBoundary;\n\n    static getContext = () => {\n        const {\n            nextPrefix,\n            nextLocale,\n            nextPure,\n            nextRtl,\n            nextWarning,\n            nextDevice,\n            nextPopupContainer,\n            nextErrorBoundary,\n        } = childContextCache.root() || {};\n\n        return {\n            prefix: nextPrefix,\n            locale: nextLocale,\n            pure: nextPure,\n            rtl: nextRtl,\n            warning: nextWarning,\n            device: nextDevice,\n            popupContainer: nextPopupContainer,\n            errorBoundary: nextErrorBoundary,\n        };\n    };\n\n    constructor(...args) {\n        super(...args);\n        childContextCache.add(\n            this,\n            Object.assign(\n                {},\n                childContextCache.get(this, {}),\n                this.getChildContext()\n            )\n        );\n\n        this.state = {\n            locale: this.props.locale,\n        };\n    }\n\n    getChildContext() {\n        const {\n            prefix,\n            locale,\n            pure,\n            warning,\n            rtl,\n            device,\n            popupContainer,\n            errorBoundary,\n        } = this.props;\n\n        return {\n            nextPrefix: prefix,\n            nextLocale: locale,\n            nextPure: pure,\n            nextRtl: rtl,\n            nextWarning: warning,\n            nextDevice: device,\n            nextPopupContainer: popupContainer,\n            nextErrorBoundary: errorBoundary,\n        };\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n        if (nextProps.locale !== prevState.locale) {\n            setMomentLocale(nextProps.locale);\n\n            return {\n                locale: nextProps.locale,\n            };\n        }\n\n        return null;\n    }\n\n    componentDidUpdate() {\n        childContextCache.add(\n            this,\n            Object.assign(\n                {},\n                childContextCache.get(this, {}),\n                this.getChildContext()\n            )\n        );\n    }\n\n    componentWillUnmount() {\n        childContextCache.remove(this);\n    }\n\n    render() {\n        return Children.only(this.props.children);\n    }\n}\n\nexport default polyfill(ConfigProvider);"
    },
    "5": {
        "bug_file": "src/overlay/popup.jsx",
        "compressed": "NO",
        "line_numbers": 383,
        "compressed_line_numbers": 383,
        "compressed_bug_file_content": "import React, { Component, Children } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport { func, KEYCODE } from '../util';\nimport Overlay from './overlay';\n\nconst { noop, makeChain, bindCtx } = func;\n\n/**\n * Overlay.Popup\n * @description 继承 Overlay 的 API，除非特别说明\n * */\nexport default class Popup extends Component {\n    static propTypes = {\n        /**\n         * 弹层内容\n         */\n        children: PropTypes.node,\n        /**\n         * 触发弹层显示或隐藏的元素\n         */\n        trigger: PropTypes.element,\n        /**\n         * 触发弹层显示或隐藏的操作类型，可以是 'click'，'hover'，'focus'，或者它们组成的数组，如 ['hover', 'focus']\n         */\n        triggerType: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n        /**\n         * 当 triggerType 为 click 时才生效，可自定义触发弹层显示的键盘码\n         */\n\n        triggerClickKeycode: PropTypes.oneOfType([\n            PropTypes.number,\n            PropTypes.array,\n        ]),\n        /**\n         * 弹层当前是否显示\n         */\n        visible: PropTypes.bool,\n        /**\n         * 弹层默认是否显示\n         */\n        defaultVisible: PropTypes.bool,\n        /**\n         * 弹层显示或隐藏时触发的回调函数\n         * @param {Boolean} visible 弹层是否显示\n         * @param {String} type 触发弹层显示或隐藏的来源 fromTrigger 表示由trigger的点击触发； docClick 表示由document的点击触发\n         * @param {Object} e DOM事件\n         */\n        onVisibleChange: PropTypes.func,\n        /**\n         * 设置此属性，弹层无法显示或隐藏\n         */\n        disabled: PropTypes.bool,\n        autoFit: PropTypes.bool,\n        /**\n         * 弹层显示或隐藏的延时时间（以毫秒为单位），在 triggerType 被设置为 hover 时生效\n         */\n        delay: PropTypes.number,\n        /**\n         * trigger 是否可以关闭弹层\n         */\n        canCloseByTrigger: PropTypes.bool,\n        /**\n         * 弹层定位的参照元素\n         * @default target 属性，即触发元素\n         */\n        target: PropTypes.any,\n        safeNode: PropTypes.any,\n        /**\n         * 是否跟随trigger滚动\n         */\n        followTrigger: PropTypes.bool,\n        container: PropTypes.any,\n        hasMask: PropTypes.bool,\n        wrapperStyle: PropTypes.object,\n        rtl: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        triggerType: 'hover',\n        triggerClickKeycode: [KEYCODE.SPACE, KEYCODE.ENTER],\n        defaultVisible: false,\n        onVisibleChange: noop,\n        disabled: false,\n        autoFit: false,\n        delay: 200,\n        canCloseByTrigger: true,\n        followTrigger: false,\n        container: () => document.body,\n        rtl: false,\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            visible:\n                typeof props.visible === 'undefined'\n                    ? props.defaultVisible\n                    : props.visible,\n        };\n\n        bindCtx(this, [\n            'handleTriggerClick',\n            'handleTriggerKeyDown',\n            'handleTriggerMouseEnter',\n            'handleTriggerMouseLeave',\n            'handleTriggerFocus',\n            'handleTriggerBlur',\n            'handleContentMouseEnter',\n            'handleContentMouseLeave',\n            'handleContentMouseDown',\n            'handleRequestClose',\n            'handleMaskMouseEnter',\n            'handleMaskMouseLeave',\n        ]);\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if ('visible' in nextProps) {\n            this.setState({\n                visible: nextProps.visible,\n            });\n        }\n    }\n\n    componentWillUnmount() {\n        ['_timer', '_hideTimer', '_showTimer'].forEach(time => {\n            this[time] && clearTimeout(this[time]);\n        });\n    }\n\n    handleVisibleChange(visible, type, e) {\n        if (!('visible' in this.props)) {\n            this.setState({\n                visible,\n            });\n        }\n\n        this.props.onVisibleChange(visible, type, e);\n    }\n\n    handleTriggerClick(e) {\n        if (this.state.visible && !this.props.canCloseByTrigger) {\n            return;\n        }\n\n        this.handleVisibleChange(!this.state.visible, 'fromTrigger', e);\n    }\n\n    handleTriggerKeyDown(e) {\n        const { triggerClickKeycode } = this.props;\n        const keycodes = Array.isArray(triggerClickKeycode)\n            ? triggerClickKeycode\n            : [triggerClickKeycode];\n        if (keycodes.includes(e.keyCode)) {\n            e.preventDefault();\n            this.handleTriggerClick(e);\n        }\n    }\n\n    handleTriggerMouseEnter(e) {\n        this._mouseNotFirstOnMask = false;\n\n        if (this._hideTimer) {\n            clearTimeout(this._hideTimer);\n            this._hideTimer = null;\n        }\n        if (this._showTimer) {\n            clearTimeout(this._showTimer);\n            this._showTimer = null;\n        }\n        if (!this.state.visible) {\n            this._showTimer = setTimeout(() => {\n                this.handleVisibleChange(true, 'fromTrigger', e);\n            }, this.props.delay);\n        }\n    }\n\n    handleTriggerMouseLeave(e, type) {\n        if (this._showTimer) {\n            clearTimeout(this._showTimer);\n            this._showTimer = null;\n        }\n        if (this.state.visible) {\n            this._hideTimer = setTimeout(() => {\n                this.handleVisibleChange(false, type || 'fromTrigger', e);\n            }, this.props.delay);\n        }\n    }\n\n    handleTriggerFocus(e) {\n        this.handleVisibleChange(true, 'fromTrigger', e);\n    }\n\n    handleTriggerBlur(e) {\n        if (!this._isForwardContent) {\n            this.handleVisibleChange(false, 'fromTrigger', e);\n        }\n        this._isForwardContent = false;\n    }\n\n    handleContentMouseDown() {\n        this._isForwardContent = true;\n    }\n\n    handleContentMouseEnter() {\n        clearTimeout(this._hideTimer);\n    }\n\n    handleContentMouseLeave(e) {\n        this.handleTriggerMouseLeave(e, 'fromContent');\n    }\n\n    handleMaskMouseEnter() {\n        if (!this._mouseNotFirstOnMask) {\n            clearTimeout(this._hideTimer);\n            this._hideTimer = null;\n            this._mouseNotFirstOnMask = false;\n        }\n    }\n\n    handleMaskMouseLeave() {\n        this._mouseNotFirstOnMask = true;\n    }\n\n    handleRequestClose(type, e) {\n        this.handleVisibleChange(false, type, e);\n    }\n\n    renderTrigger() {\n        const { trigger, disabled } = this.props;\n        const props = {\n            key: 'trigger',\n            'aria-haspopup': true,\n            'aria-expanded': this.state.visible,\n        };\n\n        if (!this.state.visible) {\n            props['aria-describedby'] = undefined;\n        }\n\n        if (!disabled) {\n            const { triggerType } = this.props;\n            const triggerTypes = Array.isArray(triggerType)\n                ? triggerType\n                : [triggerType];\n            const {\n                onClick,\n                onKeyDown,\n                onMouseEnter,\n                onMouseLeave,\n                onFocus,\n                onBlur,\n            } = (trigger && trigger.props) || {};\n            triggerTypes.forEach(triggerType => {\n                switch (triggerType) {\n                    case 'click':\n                        props.onClick = makeChain(\n                            this.handleTriggerClick,\n                            onClick\n                        );\n                        props.onKeyDown = makeChain(\n                            this.handleTriggerKeyDown,\n                            onKeyDown\n                        );\n                        break;\n                    case 'hover':\n                        props.onMouseEnter = makeChain(\n                            this.handleTriggerMouseEnter,\n                            onMouseEnter\n                        );\n                        props.onMouseLeave = makeChain(\n                            this.handleTriggerMouseLeave,\n                            onMouseLeave\n                        );\n                        break;\n                    case 'focus':\n                        props.onFocus = makeChain(\n                            this.handleTriggerFocus,\n                            onFocus\n                        );\n                        props.onBlur = makeChain(\n                            this.handleTriggerBlur,\n                            onBlur\n                        );\n                        break;\n                    default:\n                        break;\n                }\n            });\n        }\n\n        return trigger && React.cloneElement(trigger, props);\n    }\n\n    renderContent() {\n        const { children, triggerType } = this.props;\n        const triggerTypes = Array.isArray(triggerType)\n            ? triggerType\n            : [triggerType];\n        const content = Children.only(children);\n        const { onMouseDown, onMouseEnter, onMouseLeave } = content.props;\n        const props = {\n            key: 'portal',\n        };\n\n        triggerTypes.forEach(triggerType => {\n            switch (triggerType) {\n                case 'focus':\n                    props.onMouseDown = makeChain(\n                        this.handleContentMouseDown,\n                        onMouseDown\n                    );\n                    break;\n                case 'hover':\n                    props.onMouseEnter = makeChain(\n                        this.handleContentMouseEnter,\n                        onMouseEnter\n                    );\n                    props.onMouseLeave = makeChain(\n                        this.handleContentMouseLeave,\n                        onMouseLeave\n                    );\n                    break;\n                default:\n                    break;\n            }\n        });\n\n        return React.cloneElement(content, props);\n    }\n\n    renderPortal() {\n        const {\n            target,\n            safeNode,\n            followTrigger,\n            triggerType,\n            hasMask,\n            wrapperStyle,\n            ...others\n        } = this.props;\n        let { container } = this.props;\n        const findTriggerNode = () => findDOMNode(this) || {};\n        const safeNodes = Array.isArray(safeNode) ? [...safeNode] : [safeNode];\n        safeNodes.unshift(findTriggerNode);\n\n        const newWrapperStyle = wrapperStyle || {};\n\n        if (followTrigger) {\n            container = trigger => (trigger && trigger.parentNode) || trigger;\n            newWrapperStyle.position = 'relative';\n        }\n\n        if (triggerType === 'hover' && hasMask) {\n            others.onMaskMouseEnter = this.handleMaskMouseEnter;\n            others.onMaskMouseLeave = this.handleMaskMouseLeave;\n        }\n\n        return (\n            <Overlay\n                {...others}\n                key=\"overlay\"\n                ref={overlay => (this.overlay = overlay)}\n                visible={this.state.visible}\n                target={target || findTriggerNode}\n                container={container}\n                safeNode={safeNodes}\n                wrapperStyle={newWrapperStyle}\n                triggerType={triggerType}\n                hasMask={hasMask}\n                onRequestClose={this.handleRequestClose}\n            >\n                {this.renderContent()}\n            </Overlay>\n        );\n    }\n\n    render() {\n        return [this.renderTrigger(), this.renderPortal()];\n    }\n}"
    },
    "6": {
        "bug_file": "src/overlay/index.jsx",
        "compressed": "NO",
        "line_numbers": 15,
        "compressed_line_numbers": 15,
        "compressed_bug_file_content": "import ConfigProvider from '../config-provider';\nimport Overlay from './overlay';\nimport Gateway from './gateway';\nimport Position from './position';\nimport Popup from './popup';\n\nOverlay.Gateway = Gateway;\nOverlay.Position = Position;\nOverlay.Popup = ConfigProvider.config(Popup, {\n    exportNames: ['overlay'],\n});\n\nexport default ConfigProvider.config(Overlay, {\n    exportNames: ['getContent', 'getContentNode'],\n});"
    }
}