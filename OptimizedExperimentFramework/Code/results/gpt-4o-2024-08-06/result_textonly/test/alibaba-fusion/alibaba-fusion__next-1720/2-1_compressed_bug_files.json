{
    "1": {
        "bug_file": "src/search/Search.jsx",
        "compressed": "NO",
        "line_numbers": 383,
        "compressed_line_numbers": 383,
        "compressed_bug_file_content": "import React, { isValidElement } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\n\nimport Input from '../input';\nimport Select from '../select';\nimport Button from '../button';\nimport Icon from '../icon';\nimport { obj, func, KEYCODE } from '../util';\nimport zhCN from '../locale/zh-cn';\n\nconst Group = Input.Group;\nconst AutoComplete = Select.AutoComplete;\n\n/**\n * Search\n * @description 输入框部分继承 Select.AutoComplete 的能力，可以直接用AutoComplete 的 api\n */\nclass Search extends React.Component {\n    static propTypes = {\n        /**\n         * 样式前缀\n         */\n        prefix: PropTypes.string,\n        /**\n         * 形状\n         */\n        shape: PropTypes.oneOf(['normal', 'simple']),\n        /**\n         * 类型 shape=normal: primary/secondary; shape=simple: normal/dark;\n         */\n        type: PropTypes.oneOf(['primary', 'secondary', 'normal', 'dark']),\n        /**\n         * 大小\n         * @enumdesc '大', '小'\n         */\n        size: PropTypes.oneOf(['large', 'medium']),\n        /**\n         * 搜索框默认值\n         */\n        defaultValue: PropTypes.string,\n        /**\n         * 搜索框数值\n         */\n        value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        /**\n         * 输入关键字时的回掉\n         * @param {Object} value 输入值\n         */\n        onChange: PropTypes.func,\n        /**\n         * 点击搜索按钮触发的回调\n         * @param {String} value 输入值\n         * @param {String} filterValue 选项值\n         */\n        onSearch: PropTypes.func,\n        /**\n         * 选择器默认值\n         */\n        defaultFilterValue: PropTypes.string,\n        /**\n         * 选择器\n         */\n        filter: PropTypes.array,\n        /**\n         * 选择器值\n         */\n        filterValue: PropTypes.string,\n        /**\n         * 选择器发生变化时回调\n         * @param {Object} filter value\n         */\n        onFilterChange: PropTypes.func,\n        /**\n         * 搜索框下拉联想列表\n         */\n        dataSource: PropTypes.array,\n        /**\n         * 默认提示\n         */\n        placeholder: PropTypes.string,\n        /**\n         * button 的内容\n         */\n        searchText: PropTypes.node,\n        /**\n         * 自定义样式\n         */\n        style: PropTypes.object,\n        /**\n         * 样式名称\n         */\n        className: PropTypes.string,\n        /**\n         * 选择器的props\n         */\n        filterProps: PropTypes.object,\n        /**\n         * 按钮的额外属性\n         */\n        buttonProps: PropTypes.object,\n        /**\n         * 自定义渲染的的下拉框\n         */\n        popupContent: PropTypes.node,\n        /**\n         * 是否跟随滚动\n         */\n        followTrigger: PropTypes.bool,\n        /**\n         * 自定义渲染的的下拉框\n         */\n        visible: PropTypes.bool,\n        /**\n         * 是否显示清除按钮\n         */\n        hasClear: PropTypes.bool,\n        /**\n         * 是否显示搜索按钮\n         */\n        hasIcon: PropTypes.bool,\n        /**\n         * 是否禁用\n         */\n        disabled: PropTypes.bool,\n        locale: PropTypes.object,\n        rtl: PropTypes.bool,\n        /**\n         * 可配置的icons，包括 search 等\n         */\n        icons: PropTypes.object,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        shape: 'normal',\n        type: 'normal',\n        size: 'medium',\n        hasIcon: true,\n        filter: [],\n        locale: zhCN.Search,\n        buttonProps: {},\n        onChange: func.noop,\n        onSearch: func.noop,\n        onFilterChange: func.noop,\n        hasClear: false,\n        disabled: false,\n        icons: {},\n    };\n\n    constructor(props) {\n        super(props);\n\n        const value = 'value' in props ? props.value : props.defaultValue;\n        const filterValue =\n            'filterValue' in props\n                ? props.filterValue\n                : props.defaultFilterValue;\n\n        this.state = {\n            value: typeof value === 'undefined' ? '' : value,\n            filterValue,\n        };\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n        const nextState = {};\n        if ('value' in nextProps && nextProps.value !== prevState.value) {\n            const value = nextProps.value;\n            nextState.value =\n                value === undefined || value === null ? '' : nextProps.value;\n        }\n\n        if (\n            'filterValue' in nextProps &&\n            nextProps.filterValue !== prevState.filterValue\n        ) {\n            const filterValue = nextProps.filterValue;\n            nextState.filterValue =\n                filterValue === undefined ? '' : filterValue;\n        }\n\n        if (Object.keys(nextState).length > 0) {\n            return nextState;\n        }\n\n        return null;\n    }\n\n    onChange = (value, ...argv) => {\n        if (!('value' in this.props)) {\n            this.setState({ value });\n        }\n\n        this.props.onChange(value, ...argv);\n    };\n\n    onSearch = () => {\n        if (this.props.disabled) {\n            return;\n        }\n        this.props.onSearch(this.state.value, this.state.filterValue);\n    };\n\n    onFilterChange = filterValue => {\n        if (!('filterValue' in this.props)) {\n            this.setState({ filterValue });\n        }\n\n        this.props.onFilterChange(filterValue);\n    };\n\n    onKeyDown = e => {\n        if (this.props.disabled) {\n            return;\n        }\n        if (e.keyCode !== KEYCODE.ENTER) {\n            return;\n        }\n        this.onSearch();\n    };\n    render() {\n        const {\n            shape,\n            filter,\n            hasIcon,\n            disabled,\n            placeholder,\n            type,\n            className,\n            style,\n            size,\n            prefix,\n            searchText,\n            dataSource,\n            filterProps,\n            buttonProps,\n            popupContent,\n            followTrigger,\n            hasClear,\n            visible,\n            locale,\n            rtl,\n            icons,\n            ...others\n        } = this.props;\n\n        const cls = classNames({\n            [`${prefix}search`]: true,\n            [`${prefix}search-${shape}`]: true,\n            [`${prefix}${type}`]: type,\n            [`${prefix}${size}`]: size,\n            [className]: !!className,\n        });\n\n        let searchIcon = null,\n            filterSelect = null,\n            searchBtn = null,\n            iconsSearch = icons.search;\n\n        if (!isValidElement(icons.search) && icons.search) {\n            iconsSearch = <span>{icons.search}</span>;\n        }\n\n        if (shape === 'simple') {\n            const cls = classNames({\n                [`${prefix}search-icon`]: true,\n                [buttonProps.className]: !!buttonProps.className,\n                [`${prefix}search-symbol-icon`]: !iconsSearch,\n            });\n            hasIcon &&\n                (searchIcon = React.cloneElement(\n                    iconsSearch || <Icon type=\"search\" />,\n                    {\n                        role: 'button',\n                        'aria-disabled': disabled,\n                        'aria-label': locale.buttonText,\n                        ...buttonProps,\n                        className: cls,\n                        onClick: this.onSearch,\n                        onKeyDown: this.onKeyDown,\n                    }\n                ));\n        } else {\n            const cls = classNames({\n                [`${prefix}search-btn`]: true,\n                [buttonProps.className]: !!buttonProps.className,\n            });\n            searchBtn = (\n                <Button\n                    tabIndex=\"0\"\n                    aria-disabled={disabled}\n                    aria-label={locale.buttonText}\n                    className={cls}\n                    disabled={disabled}\n                    {...buttonProps}\n                    onClick={this.onSearch}\n                    onKeyDown={this.onKeyDown}\n                >\n                    {hasIcon\n                        ? iconsSearch || (\n                              <Icon\n                                  type=\"search\"\n                                  className={`${prefix}search-symbol-icon`}\n                              />\n                          )\n                        : null}\n                    {searchText ? (\n                        <span className={`${prefix}search-btn-text`}>\n                            {searchText}\n                        </span>\n                    ) : null}\n                </Button>\n            );\n        }\n\n        if (filter.length > 0) {\n            filterSelect = (\n                <Select\n                    {...filterProps}\n                    followTrigger={followTrigger}\n                    hasBorder={false}\n                    dataSource={filter}\n                    size={size}\n                    disabled={disabled}\n                    value={this.state.filterValue}\n                    onChange={this.onFilterChange}\n                />\n            );\n        }\n\n        const othersAttributes = obj.pickOthers(Search.propTypes, others);\n        if (visible !== undefined) {\n            // 受控属性 visible 不能直接写在组件上\n            othersAttributes.visible = Boolean(visible);\n        }\n        const dataAttr = obj.pickAttrsWith(others, 'data-');\n\n        const left = (\n            <Group\n                addonBefore={filterSelect}\n                className={`${prefix}search-left`}\n                addonBeforeClassName={`${prefix}search-left-addon`}\n            >\n                <AutoComplete\n                    aria-label={locale.buttonText}\n                    {...othersAttributes}\n                    followTrigger={followTrigger}\n                    role=\"searchbox\"\n                    hasClear={hasClear}\n                    className={`${prefix}search-input`}\n                    size={size}\n                    placeholder={placeholder}\n                    dataSource={dataSource}\n                    innerAfter={searchIcon}\n                    onPressEnter={this.onSearch}\n                    value={this.state.value}\n                    onChange={this.onChange}\n                    popupContent={popupContent}\n                    disabled={disabled}\n                />\n            </Group>\n        );\n\n        return (\n            <span\n                className={cls}\n                style={style}\n                {...dataAttr}\n                dir={rtl ? 'rtl' : undefined}\n            >\n                {searchBtn ? (\n                    <Group addonAfter={searchBtn}>{left}</Group>\n                ) : (\n                    left\n                )}\n            </span>\n        );\n    }\n}\n\nexport default polyfill(Search);"
    },
    "2": {
        "bug_file": "src/search/index.jsx",
        "compressed": "NO",
        "line_numbers": 25,
        "compressed_line_numbers": 25,
        "compressed_bug_file_content": "import ConfigProvider from '../config-provider';\nimport Search from './Search';\n\nexport default ConfigProvider.config(Search, {\n    transfrom: /* istanbul ignore next */ (props, deprecated) => {\n        const { onInputFocus, overlayVisible, combox, ...others } = this.props;\n\n        const newprops = others;\n\n        if (onInputFocus) {\n            deprecated('onInputFocus', 'onFocus', 'Search');\n            newprops.onFocus = onInputFocus;\n        }\n        if ('overlayVisible' in this.props) {\n            deprecated('overlayVisible', 'visible', 'Search');\n            newprops.visible = overlayVisible;\n        }\n        if (combox) {\n            deprecated('combox', 'popupContent', 'Search');\n            newprops.popupContent = combox;\n        }\n\n        return newprops;\n    },\n});"
    },
    "3": {
        "bug_file": "src/select/auto-complete.jsx",
        "compressed": "NO",
        "line_numbers": 411,
        "compressed_line_numbers": 411,
        "compressed_bug_file_content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\n\nimport { func, obj, KEYCODE } from '../util';\nimport Input from '../input';\nimport Base from './base';\n\nconst { bindCtx, noop } = func;\n\n/**\n * Select.AutoComplete\n */\nclass AutoComplete extends Base {\n    static propTypes = {\n        ...Base.propTypes,\n        /**\n         * 当前值，用于受控模式\n         */\n        value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        /**\n         * 初始化的默认值\n         */\n        defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        /**\n         * Select发生改变时触发的回调\n         * @param {*} value 选中的值\n         * @param {String} actionType 触发的方式, 'itemClick', 'enter', 'change'\n         * @param {*} item 选中的值的对象数据\n         */\n        onChange: PropTypes.func,\n        /**\n         * 传入的数据源，可以动态渲染子项\n         */\n        dataSource: PropTypes.arrayOf(\n            PropTypes.oneOfType([\n                PropTypes.shape({\n                    value: PropTypes.string,\n                    label: PropTypes.any,\n                    disabled: PropTypes.bool,\n                    children: PropTypes.array,\n                }),\n                PropTypes.string,\n            ])\n        ),\n        /**\n         * 填充到选择框里的值的 key\b\b，默认是 value\n         */\n        fillProps: PropTypes.string,\n        /**\n         * 渲染 MenuItem 内容的方法\n         * @param {Object} item 渲染节点的 item\n         * @return {ReactNode} item node\n         */\n        itemRender: PropTypes.func,\n        // input keydown\n        onKeyDown: PropTypes.func,\n        // 是否将当前高亮的选项作为 placeholder\n        highlightHolder: PropTypes.bool,\n        style: PropTypes.object,\n    };\n\n    static defaultProps = {\n        ...Base.defaultProps,\n        onKeyDown: noop,\n        fillProps: 'value',\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.isAutoComplete = true;\n        this.isInputing = false;\n\n        this.dataStore.setOptions({ key: this.state.value });\n        Object.assign(this.state, {\n            dataSource: this.setDataSource(props),\n        });\n\n        bindCtx(this, [\n            'handleTriggerKeyDown',\n            'handleMenuSelect',\n            'handleItemClick',\n        ]);\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n        const state = {};\n\n        if ('value' in nextProps && nextProps.value !== prevState.value) {\n            Object.assign(state, {\n                value: nextProps.value,\n            });\n        }\n\n        if ('visible' in nextProps && nextProps.visible !== prevState.visible) {\n            Object.assign(state, {\n                visible: nextProps.visible,\n            });\n        }\n\n        if (Object.keys(state).length) {\n            return state;\n        }\n\n        return null;\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        const props = this.props;\n\n        if ('value' in props) {\n            this.dataStore.setOptions({ key: props.value });\n        }\n\n        if (props.filter !== prevProps.filter) {\n            this.dataStore.setOptions({\n                filter: props.filter,\n            });\n        }\n        if (props.filterLocal !== prevProps.filterLocal) {\n            this.dataStore.setOptions({\n                filterLocal: props.filterLocal,\n            });\n        }\n\n        if (\n            prevProps.children !== props.children ||\n            prevProps.dataSource !== props.dataSource\n        ) {\n            /* eslint-disable react/no-did-update-set-state */\n            this.setState({\n                dataSource: this.setDataSource(props),\n            });\n\n            // remote dataSource and focused\n            // 因为autoComplete没有下拉数据不展示，搜索并且有数据了需要自动展示下拉\n            if (!props.filterLocal && this.isInputing) {\n                this.shouldControlPopup(props, 'update');\n            }\n            if (!props.filterLocal && !props.popupContent) {\n                this.setFirstHightLightKeyForMenu();\n            }\n        }\n    }\n\n    shouldControlPopup(props = this.props, type) {\n        const hasPopup =\n            props.popupContent || this.dataStore.getMenuDS().length;\n        if (hasPopup) {\n            this.setVisible(true, type);\n        } else {\n            this.setVisible(false, type);\n        }\n    }\n\n    handleMenuSelect(keys) {\n        const key = keys[0];\n\n        const mapDS = this.dataStore.getMapDS();\n\n        if (key in mapDS) {\n            const item = mapDS[key];\n            this.handleSelectEvent(key, item, 'itemClick');\n        }\n    }\n\n    handleItemClick() {\n        this.setVisible(false, 'itemClick');\n    }\n\n    handleSelectEvent(key, item, triggerType) {\n        const value = (item && item[this.props.fillProps]) || key;\n\n        if (triggerType === 'itemClick' || triggerType === 'enter') {\n            // 点击 item 的时候不会触发关闭，需要手动关闭，其它类型比如 keyDown 等都会有其它事件句柄处理\n            this.setVisible(false, triggerType);\n        }\n\n        this.handleChange(value, triggerType, item);\n    }\n\n    handleChange = (value, proxy, item) => {\n        const { disabled, readOnly, filterLocal } = this.props;\n\n        if (disabled || readOnly) {\n            return false;\n        }\n\n        const actionType = typeof proxy === 'string' ? proxy : 'change';\n\n        this.isInputing = actionType === 'change';\n\n        if (filterLocal) {\n            this.setState({\n                dataSource: this.dataStore.updateByKey(value),\n            });\n\n            this.shouldControlPopup(this.props, actionType);\n            this.setFirstHightLightKeyForMenu();\n        }\n\n        // 非受控模式清空内部数据\n        if (!('value' in this.props)) {\n            this.setState({\n                value: value,\n            });\n        }\n\n        this.props.onChange(value, actionType, item);\n\n        if (actionType === 'itemClick' || actionType === 'enter') {\n            // 点击 item 的时候不会触发关闭，需要手动关闭，其它类型比如 keyDown 等都会有其它事件句柄处理\n            this.setVisible(false, actionType);\n        }\n    };\n\n    handleVisibleChange(visible, type) {\n        if (\n            !('visible' in this.props) &&\n            visible &&\n            !this.props.popupContent &&\n            !this.dataStore.getMenuDS().length\n        ) {\n            return;\n        }\n\n        this.setVisible(visible, type);\n    }\n\n    beforeClose() {\n        this.isInputing = false;\n    }\n\n    /**\n     * Handle trigger keydown event\n     * @param {Event} e\n     */\n    handleTriggerKeyDown(e) {\n        const { popupContent, onToggleHighlightItem, onKeyDown } = this.props;\n        if (popupContent) {\n            e.stopPropagation(); //stopPropagation can make use onChange triggerd while typing space('') in Input\n            return onKeyDown(e);\n        }\n\n        switch (e.keyCode) {\n            case KEYCODE.UP:\n                e.preventDefault();\n                onToggleHighlightItem(this.toggleHighlightItem(-1, e), 'up');\n                break;\n            case KEYCODE.DOWN:\n                e.preventDefault();\n                onToggleHighlightItem(this.toggleHighlightItem(1, e), 'down');\n                break;\n            case KEYCODE.ENTER:\n                e.preventDefault();\n                this.chooseHighlightItem(e);\n                break;\n            case KEYCODE.SPACE:\n                // stopPropagation can make use onChange triggerd while typing space('') in Input\n                e.stopPropagation();\n                break;\n            case KEYCODE.ESC:\n                e.preventDefault();\n                this.state.visible && this.setVisible(false, 'esc');\n                break;\n            default:\n                break;\n        }\n\n        onKeyDown(e);\n    }\n\n    // 回车 选择高亮的 item\n    chooseHighlightItem() {\n        if (!this.state.visible) {\n            return false;\n        }\n\n        const { highlightKey } = this.state;\n        const highlightItem = this.dataStore.getEnableDS().find(item => {\n            return highlightKey === `${item.value}`;\n        });\n\n        if (highlightItem) {\n            this.handleSelectEvent(highlightKey, highlightItem, 'enter');\n        }\n    }\n\n    hasClear() {\n        const { hasClear, readOnly, disabled } = this.props;\n        const { value } = this.state;\n\n        return value && hasClear && !readOnly && !disabled;\n    }\n\n    /**\n     * 选择器\n     * @override\n     * @param {object} props\n     */\n    renderSelect(props = this.props) {\n        const {\n            placeholder,\n            size,\n            prefix,\n            className,\n            style,\n            label,\n            readOnly,\n            disabled,\n            highlightHolder,\n            locale,\n            hasClear,\n            state,\n            rtl,\n        } = props;\n        const others = obj.pickOthers(AutoComplete.propTypes, props);\n        const othersData = obj.pickAttrsWith(others, 'data-');\n\n        const value = this.state.value;\n        const visible = this.state.visible;\n\n        // // 下拉箭头\n        // const arrowNode = this.renderArrowNode(props, () => {\n        //     this.focusInput();\n        //     this.setVisible(!this.state.visible);\n        // });\n\n        // trigger className\n        const triggerClazz = classNames(\n            [\n                `${prefix}select`,\n                `${prefix}select-auto-complete`,\n                `${prefix}size-${size}`,\n                className,\n            ],\n            {\n                [`${prefix}active`]: visible,\n                [`${prefix}disabled`]: disabled,\n            }\n        );\n\n        // highlightKey into placeholder\n        // compatible with selectPlaceHolder. TODO: removed in 2.0 version\n        let _placeholder =\n            placeholder ||\n            locale.autoCompletePlaceholder ||\n            locale.autoCompletePlaceHolder;\n        if (highlightHolder && visible) {\n            _placeholder = this.state.highlightKey || _placeholder;\n        }\n\n        // Input props\n        const _inputProps = {\n            ...obj.pickOthers(othersData, others),\n            state: state,\n            ref: this.saveInputRef,\n            hasClear: hasClear,\n            value,\n            size,\n            disabled,\n            readOnly,\n            placeholder: _placeholder,\n            label,\n            // extra: arrowNode,\n            onChange: this.handleChange,\n            onKeyDown: this.handleTriggerKeyDown,\n        };\n\n        return (\n            <span\n                {...othersData}\n                className={triggerClazz}\n                style={style}\n                dir={rtl ? 'rtl' : undefined}\n                ref={this.saveSelectRef}\n                onClick={this.focusInput}\n            >\n                <Input\n                    role=\"combobox\"\n                    aria-autocomplete=\"list\"\n                    aria-disabled={disabled}\n                    aria-expanded={this.state.visible}\n                    {..._inputProps}\n                />\n                <span className={`${prefix}sr-only`} aria-live=\"polite\">\n                    {this.state.srReader}\n                </span>\n            </span>\n        );\n    }\n\n    render() {\n        if (this.hasClear()) {\n            // clear 按钮点击后，会在 dom 结构中被删除掉，需要将其额外设置为安全节点，防止触发弹层的显示或隐藏\n            const safeNode = this.props.popupProps.safeNode || [];\n            const safeNodes = Array.isArray(safeNode) ? safeNode : [safeNode];\n            safeNodes.push(() => this.clearNode);\n            this.props.popupProps.safeNode = safeNodes;\n        }\n\n        return super.render(\n            Object.assign({}, this.props, { canCloseByTrigger: false })\n        );\n    }\n}\n\nexport default polyfill(AutoComplete);"
    },
    "4": {
        "bug_file": "src/select/util.js",
        "compressed": "NO",
        "line_numbers": 363,
        "compressed_line_numbers": 363,
        "compressed_bug_file_content": "import { Children } from 'react';\n\n/**\n * util module\n */\n\n/**\n * 是否是单选模式\n * @param {string} mode\n * @return {boolean} is single mode\n */\nexport function isSingle(mode) {\n    return !mode || mode === 'single';\n}\n\n/**\n * 在 Select 中，认为 null 和 undefined 都是空值\n * @param {*} n any object\n * @return {boolean}\n */\nexport function isNull(n) {\n    return n === null || n === undefined;\n}\n\n/**\n * 将字符串中的正则表达式关键字符添加转义\n * @param {string} str\n * @return {string}\n */\nexport function escapeForReg(str) {\n    return str.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\n/**\n * filter by key\n * @param {string} key filter key\n * @param {object} item item object\n * @return {boolean} it's filtered\n */\nexport function filter(key, item) {\n    const _key = escapeForReg(`${key}`);\n    const regExp = new RegExp(`(${_key})`, 'ig');\n\n    return regExp.test(`${item.value}`) || regExp.test(`${item.label}`);\n}\n\n/**\n * loop map\n * @param {Array} dataSource\n * @param {function} callback\n * @return {Array}\n * ----\n * @callback ~loopCallback\n * @param {object} option\n */\nexport function loopMap(dataSource, callback) {\n    const result = [];\n    dataSource.forEach(option => {\n        if (option.children) {\n            const children = loopMap(option.children, callback);\n            children.length &&\n                result.push({\n                    ...option,\n                    children,\n                });\n        } else {\n            // eslint-disable-next-line callback-return\n            const tmp = callback(option);\n            tmp && result.push(tmp);\n        }\n    });\n\n    return result;\n}\n\n/**\n * Parse dataSource from MenuItem\n * @static\n * @param {Array<Element>} children\n * @param {number} [deep=0] recursion deep level\n */\nexport function parseDataSourceFromChildren(children, deep = 0) {\n    const source = [];\n\n    Children.forEach(children, (child, index) => {\n        if (!child) {\n            return;\n        }\n        const { type, props: childProps } = child;\n        const item2 = { deep };\n\n        let isOption = false;\n        let isOptionGroup = false;\n\n        if (\n            (typeof type === 'function' &&\n                type._typeMark === 'next_select_option') ||\n            type === 'option'\n        ) {\n            isOption = true;\n        }\n        if (\n            (typeof type === 'function' &&\n                type._typeMark === 'next_select_option_group') ||\n            type === 'optgroup'\n        ) {\n            isOptionGroup = true;\n        }\n\n        if (!isOption && !isOptionGroup) {\n            return;\n        }\n\n        if (isOption) {\n            // option\n            // If children is a string, it can be used as value\n            const isStrChild = typeof childProps.children === 'string';\n            // value > key > string children > index\n            item2.value =\n                'value' in childProps\n                    ? childProps.value\n                    : 'key' in childProps\n                    ? childProps.key\n                    : isStrChild\n                    ? childProps.children\n                    : `${index}`;\n\n            item2.label =\n                childProps.label || childProps.children || `${item2.value}`;\n            item2.title = childProps.title;\n            childProps.disabled === true && (item2.disabled = true);\n            // You can put your extra data here, and use it in `itemRender` or `labelRender`\n            Object.assign(item2, childProps['data-extra'] || {});\n        } else if (isOptionGroup && deep < 1) {\n            // option group\n            item2.label = childProps.label || 'Group';\n            // parse children nodes\n            item2.children = parseDataSourceFromChildren(\n                childProps.children,\n                deep + 1\n            );\n        }\n\n        source.push(item2);\n    });\n\n    return source;\n}\n\n/**\n * Normalize dataSource\n * @static\n * @param {Array} dataSource\n * @param {number} [deep=0] recursion deep level\n * ----\n * value priority: value > 'index'\n * label priority: label > 'value' > 'index'\n * disabled: disabled === true\n */\nexport function normalizeDataSource(dataSource, deep = 0) {\n    const source = [];\n\n    dataSource.forEach((item, index) => {\n        // enable array of basic type\n        if (/string|boolean|number/.test(typeof item)) {\n            item = { label: `${item}`, value: item };\n        }\n\n        // filter off addon item\n        if (item.__isAddon) {\n            return;\n        }\n\n        const item2 = { deep };\n        // deep < 1: only 2 level allowed\n        if (Array.isArray(item.children) && deep < 1) {\n            // handle group\n            item2.label = item.label || item.value || `Group ${index}`;\n            // parse children\n            item2.children = normalizeDataSource(item.children, deep + 1);\n        } else {\n            const { value, label, title, disabled, ...others } = item;\n            item2.value = !isNull(value) ? value : `${index}`;\n            item2.label = label || `${item2.value}`;\n            item2.title = title;\n            disabled === true && (item2.disabled = true);\n\n            Object.assign(item2, others);\n        }\n\n        source.push(item2);\n    });\n\n    return source;\n}\n\n/**\n * Get flatten dataSource\n * @static\n * @param  {Array} dataSource structured dataSource\n * @return {Array}\n */\nexport function flattingDataSource(dataSource) {\n    const source = [];\n\n    dataSource.forEach(item => {\n        if (Array.isArray(item.children)) {\n            source.push(...flattingDataSource(item.children));\n        } else {\n            source.push(item);\n        }\n    });\n\n    return source;\n}\n\nexport function filterDataSource(dataSource, key, filter, addonKey) {\n    if (!Array.isArray(dataSource)) {\n        return [];\n    }\n    if (typeof key === 'undefined' || key === null) {\n        return [].concat(dataSource);\n    }\n\n    let addKey = true;\n    const menuDataSource = loopMap(dataSource, option => {\n        if (key === `${option.value}`) {\n            addKey = false;\n        }\n        return filter(key, option) && !option.__isAddon && option;\n    });\n\n    // if key not in menuDataSource, add key to dataSource\n    if (addonKey && key && addKey) {\n        menuDataSource.unshift({\n            value: key,\n            label: key,\n            title: key,\n            __isAddon: true,\n        });\n    }\n\n    return menuDataSource;\n}\n\nfunction getKeyItemByValue(value, valueMap) {\n    let item;\n\n    if (typeof value === 'object' && value.hasOwnProperty('value')) {\n        item = value;\n    } else {\n        item = valueMap[`${value}`] || {\n            value,\n            label: value,\n        };\n    }\n\n    return item;\n}\n\n/**\n * compute valueDataSource by new value\n * @param {Array/String} value 数据\n * @param {Object} mapValueDS   上个value的缓存数据 value => {value,label} 的映射关系表\n * @param {*} mapMenuDS  通过 dataSource 建立 value => {value,label} 的映射关系表\n * @returns {Object} value: [value]; valueDS: [{value,label}]; mapValueDS: {value: {value,label}}\n */\nexport function getValueDataSource(value, mapValueDS, mapMenuDS) {\n    if (isNull(value)) {\n        return {};\n    }\n\n    const newValue = [];\n    const newValueDS = [];\n    const newMapValueDS = {};\n    const _newMapDS = Object.assign({}, mapValueDS, mapMenuDS);\n\n    if (Array.isArray(value)) {\n        value.forEach(v => {\n            const item = getKeyItemByValue(v, _newMapDS);\n\n            newValueDS.push(item);\n            newMapValueDS[`${item.value}`] = item;\n            newValue.push(item.value);\n        });\n\n        return {\n            value: newValue, // [value]\n            valueDS: newValueDS, // [{value,label}]\n            mapValueDS: newMapValueDS, // {value: {value,label}}\n        };\n    } else {\n        const item = getKeyItemByValue(value, _newMapDS);\n\n        return {\n            value: item.value,\n            valueDS: item,\n            mapValueDS: {\n                [`${item.value}`]: item,\n            },\n        };\n    }\n}\n\n/**\n * Get flatten dataSource\n * @static\n * @param  {any} value structured dataSource\n * @return {String}\n */\nexport function valueToSelectKey(value) {\n    let val;\n    if (typeof value === 'object' && value.hasOwnProperty('value')) {\n        val = value.value;\n    } else {\n        val = value;\n    }\n    return `${val}`;\n}\n\n/**\n * UP Down 改进双向链表方法\n */\n// function DoubleLinkList(element){\n//     this.prev = null;\n//     this.next = null;\n//     this.element = element;\n// }\n//\n// export function mapDoubleLinkList(dataSource){\n//\n//     const mapDS = {};\n//     let doubleLink = null;\n//\n//     let head = null;\n//     let tail = null;\n//\n//     function  append(element) {\n//         if (!doubleLink) {\n//             doubleLink = new DoubleLinkList(element);\n//             head = doubleLink;\n//             tail = doubleLink;\n//             return doubleLink;\n//         }\n//\n//         const node = new DoubleLinkList(element);\n//         tail.next = node;\n//         node.prev = tail;\n//         tail = node;\n//\n//         return tail;\n//     }\n//\n//     dataSource.forEach((item => {\n//         if (item.disabled) {\n//             return;\n//         }\n//         mapDS[`${item.value}`] = append(item);\n//     }));\n//\n//     return mapDS;\n// }\n//"
    },
    "5": {
        "bug_file": "src/search/style.js",
        "compressed": "NO",
        "line_numbers": 5,
        "compressed_line_numbers": 5,
        "compressed_bug_file_content": "import '../input/style.js';\nimport '../select/style.js';\nimport '../button/style.js';\nimport '../icon/style.js';\nimport './main.scss';"
    }
}