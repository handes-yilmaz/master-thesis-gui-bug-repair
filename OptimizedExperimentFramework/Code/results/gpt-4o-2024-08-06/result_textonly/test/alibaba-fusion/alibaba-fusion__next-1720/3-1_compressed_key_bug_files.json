{
    "1": {
        "bug_file": "src/search/Search.jsx",
        "compressed": "NO",
        "line_numbers": 383,
        "compressed_line_numbers": 383,
        "compressed_bug_file_content": "import React, { isValidElement } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\n\nimport Input from '../input';\nimport Select from '../select';\nimport Button from '../button';\nimport Icon from '../icon';\nimport { obj, func, KEYCODE } from '../util';\nimport zhCN from '../locale/zh-cn';\n\nconst Group = Input.Group;\nconst AutoComplete = Select.AutoComplete;\n\n/**\n * Search\n * @description 输入框部分继承 Select.AutoComplete 的能力，可以直接用AutoComplete 的 api\n */\nclass Search extends React.Component {\n    static propTypes = {\n        /**\n         * 样式前缀\n         */\n        prefix: PropTypes.string,\n        /**\n         * 形状\n         */\n        shape: PropTypes.oneOf(['normal', 'simple']),\n        /**\n         * 类型 shape=normal: primary/secondary; shape=simple: normal/dark;\n         */\n        type: PropTypes.oneOf(['primary', 'secondary', 'normal', 'dark']),\n        /**\n         * 大小\n         * @enumdesc '大', '小'\n         */\n        size: PropTypes.oneOf(['large', 'medium']),\n        /**\n         * 搜索框默认值\n         */\n        defaultValue: PropTypes.string,\n        /**\n         * 搜索框数值\n         */\n        value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        /**\n         * 输入关键字时的回掉\n         * @param {Object} value 输入值\n         */\n        onChange: PropTypes.func,\n        /**\n         * 点击搜索按钮触发的回调\n         * @param {String} value 输入值\n         * @param {String} filterValue 选项值\n         */\n        onSearch: PropTypes.func,\n        /**\n         * 选择器默认值\n         */\n        defaultFilterValue: PropTypes.string,\n        /**\n         * 选择器\n         */\n        filter: PropTypes.array,\n        /**\n         * 选择器值\n         */\n        filterValue: PropTypes.string,\n        /**\n         * 选择器发生变化时回调\n         * @param {Object} filter value\n         */\n        onFilterChange: PropTypes.func,\n        /**\n         * 搜索框下拉联想列表\n         */\n        dataSource: PropTypes.array,\n        /**\n         * 默认提示\n         */\n        placeholder: PropTypes.string,\n        /**\n         * button 的内容\n         */\n        searchText: PropTypes.node,\n        /**\n         * 自定义样式\n         */\n        style: PropTypes.object,\n        /**\n         * 样式名称\n         */\n        className: PropTypes.string,\n        /**\n         * 选择器的props\n         */\n        filterProps: PropTypes.object,\n        /**\n         * 按钮的额外属性\n         */\n        buttonProps: PropTypes.object,\n        /**\n         * 自定义渲染的的下拉框\n         */\n        popupContent: PropTypes.node,\n        /**\n         * 是否跟随滚动\n         */\n        followTrigger: PropTypes.bool,\n        /**\n         * 自定义渲染的的下拉框\n         */\n        visible: PropTypes.bool,\n        /**\n         * 是否显示清除按钮\n         */\n        hasClear: PropTypes.bool,\n        /**\n         * 是否显示搜索按钮\n         */\n        hasIcon: PropTypes.bool,\n        /**\n         * 是否禁用\n         */\n        disabled: PropTypes.bool,\n        locale: PropTypes.object,\n        rtl: PropTypes.bool,\n        /**\n         * 可配置的icons，包括 search 等\n         */\n        icons: PropTypes.object,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        shape: 'normal',\n        type: 'normal',\n        size: 'medium',\n        hasIcon: true,\n        filter: [],\n        locale: zhCN.Search,\n        buttonProps: {},\n        onChange: func.noop,\n        onSearch: func.noop,\n        onFilterChange: func.noop,\n        hasClear: false,\n        disabled: false,\n        icons: {},\n    };\n\n    constructor(props) {\n        super(props);\n\n        const value = 'value' in props ? props.value : props.defaultValue;\n        const filterValue =\n            'filterValue' in props\n                ? props.filterValue\n                : props.defaultFilterValue;\n\n        this.state = {\n            value: typeof value === 'undefined' ? '' : value,\n            filterValue,\n        };\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n        const nextState = {};\n        if ('value' in nextProps && nextProps.value !== prevState.value) {\n            const value = nextProps.value;\n            nextState.value =\n                value === undefined || value === null ? '' : nextProps.value;\n        }\n\n        if (\n            'filterValue' in nextProps &&\n            nextProps.filterValue !== prevState.filterValue\n        ) {\n            const filterValue = nextProps.filterValue;\n            nextState.filterValue =\n                filterValue === undefined ? '' : filterValue;\n        }\n\n        if (Object.keys(nextState).length > 0) {\n            return nextState;\n        }\n\n        return null;\n    }\n\n    onChange = (value, ...argv) => {\n        if (!('value' in this.props)) {\n            this.setState({ value });\n        }\n\n        this.props.onChange(value, ...argv);\n    };\n\n    onSearch = () => {\n        if (this.props.disabled) {\n            return;\n        }\n        this.props.onSearch(this.state.value, this.state.filterValue);\n    };\n\n    onFilterChange = filterValue => {\n        if (!('filterValue' in this.props)) {\n            this.setState({ filterValue });\n        }\n\n        this.props.onFilterChange(filterValue);\n    };\n\n    onKeyDown = e => {\n        if (this.props.disabled) {\n            return;\n        }\n        if (e.keyCode !== KEYCODE.ENTER) {\n            return;\n        }\n        this.onSearch();\n    };\n    render() {\n        const {\n            shape,\n            filter,\n            hasIcon,\n            disabled,\n            placeholder,\n            type,\n            className,\n            style,\n            size,\n            prefix,\n            searchText,\n            dataSource,\n            filterProps,\n            buttonProps,\n            popupContent,\n            followTrigger,\n            hasClear,\n            visible,\n            locale,\n            rtl,\n            icons,\n            ...others\n        } = this.props;\n\n        const cls = classNames({\n            [`${prefix}search`]: true,\n            [`${prefix}search-${shape}`]: true,\n            [`${prefix}${type}`]: type,\n            [`${prefix}${size}`]: size,\n            [className]: !!className,\n        });\n\n        let searchIcon = null,\n            filterSelect = null,\n            searchBtn = null,\n            iconsSearch = icons.search;\n\n        if (!isValidElement(icons.search) && icons.search) {\n            iconsSearch = <span>{icons.search}</span>;\n        }\n\n        if (shape === 'simple') {\n            const cls = classNames({\n                [`${prefix}search-icon`]: true,\n                [buttonProps.className]: !!buttonProps.className,\n                [`${prefix}search-symbol-icon`]: !iconsSearch,\n            });\n            hasIcon &&\n                (searchIcon = React.cloneElement(\n                    iconsSearch || <Icon type=\"search\" />,\n                    {\n                        role: 'button',\n                        'aria-disabled': disabled,\n                        'aria-label': locale.buttonText,\n                        ...buttonProps,\n                        className: cls,\n                        onClick: this.onSearch,\n                        onKeyDown: this.onKeyDown,\n                    }\n                ));\n        } else {\n            const cls = classNames({\n                [`${prefix}search-btn`]: true,\n                [buttonProps.className]: !!buttonProps.className,\n            });\n            searchBtn = (\n                <Button\n                    tabIndex=\"0\"\n                    aria-disabled={disabled}\n                    aria-label={locale.buttonText}\n                    className={cls}\n                    disabled={disabled}\n                    {...buttonProps}\n                    onClick={this.onSearch}\n                    onKeyDown={this.onKeyDown}\n                >\n                    {hasIcon\n                        ? iconsSearch || (\n                              <Icon\n                                  type=\"search\"\n                                  className={`${prefix}search-symbol-icon`}\n                              />\n                          )\n                        : null}\n                    {searchText ? (\n                        <span className={`${prefix}search-btn-text`}>\n                            {searchText}\n                        </span>\n                    ) : null}\n                </Button>\n            );\n        }\n\n        if (filter.length > 0) {\n            filterSelect = (\n                <Select\n                    {...filterProps}\n                    followTrigger={followTrigger}\n                    hasBorder={false}\n                    dataSource={filter}\n                    size={size}\n                    disabled={disabled}\n                    value={this.state.filterValue}\n                    onChange={this.onFilterChange}\n                />\n            );\n        }\n\n        const othersAttributes = obj.pickOthers(Search.propTypes, others);\n        if (visible !== undefined) {\n            // 受控属性 visible 不能直接写在组件上\n            othersAttributes.visible = Boolean(visible);\n        }\n        const dataAttr = obj.pickAttrsWith(others, 'data-');\n\n        const left = (\n            <Group\n                addonBefore={filterSelect}\n                className={`${prefix}search-left`}\n                addonBeforeClassName={`${prefix}search-left-addon`}\n            >\n                <AutoComplete\n                    aria-label={locale.buttonText}\n                    {...othersAttributes}\n                    followTrigger={followTrigger}\n                    role=\"searchbox\"\n                    hasClear={hasClear}\n                    className={`${prefix}search-input`}\n                    size={size}\n                    placeholder={placeholder}\n                    dataSource={dataSource}\n                    innerAfter={searchIcon}\n                    onPressEnter={this.onSearch}\n                    value={this.state.value}\n                    onChange={this.onChange}\n                    popupContent={popupContent}\n                    disabled={disabled}\n                />\n            </Group>\n        );\n\n        return (\n            <span\n                className={cls}\n                style={style}\n                {...dataAttr}\n                dir={rtl ? 'rtl' : undefined}\n            >\n                {searchBtn ? (\n                    <Group addonAfter={searchBtn}>{left}</Group>\n                ) : (\n                    left\n                )}\n            </span>\n        );\n    }\n}\n\nexport default polyfill(Search);"
    },
    "2": {
        "bug_file": "src/select/auto-complete.jsx",
        "compressed": "NO",
        "line_numbers": 411,
        "compressed_line_numbers": 411,
        "compressed_bug_file_content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\n\nimport { func, obj, KEYCODE } from '../util';\nimport Input from '../input';\nimport Base from './base';\n\nconst { bindCtx, noop } = func;\n\n/**\n * Select.AutoComplete\n */\nclass AutoComplete extends Base {\n    static propTypes = {\n        ...Base.propTypes,\n        /**\n         * 当前值，用于受控模式\n         */\n        value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        /**\n         * 初始化的默认值\n         */\n        defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        /**\n         * Select发生改变时触发的回调\n         * @param {*} value 选中的值\n         * @param {String} actionType 触发的方式, 'itemClick', 'enter', 'change'\n         * @param {*} item 选中的值的对象数据\n         */\n        onChange: PropTypes.func,\n        /**\n         * 传入的数据源，可以动态渲染子项\n         */\n        dataSource: PropTypes.arrayOf(\n            PropTypes.oneOfType([\n                PropTypes.shape({\n                    value: PropTypes.string,\n                    label: PropTypes.any,\n                    disabled: PropTypes.bool,\n                    children: PropTypes.array,\n                }),\n                PropTypes.string,\n            ])\n        ),\n        /**\n         * 填充到选择框里的值的 key\b\b，默认是 value\n         */\n        fillProps: PropTypes.string,\n        /**\n         * 渲染 MenuItem 内容的方法\n         * @param {Object} item 渲染节点的 item\n         * @return {ReactNode} item node\n         */\n        itemRender: PropTypes.func,\n        // input keydown\n        onKeyDown: PropTypes.func,\n        // 是否将当前高亮的选项作为 placeholder\n        highlightHolder: PropTypes.bool,\n        style: PropTypes.object,\n    };\n\n    static defaultProps = {\n        ...Base.defaultProps,\n        onKeyDown: noop,\n        fillProps: 'value',\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.isAutoComplete = true;\n        this.isInputing = false;\n\n        this.dataStore.setOptions({ key: this.state.value });\n        Object.assign(this.state, {\n            dataSource: this.setDataSource(props),\n        });\n\n        bindCtx(this, [\n            'handleTriggerKeyDown',\n            'handleMenuSelect',\n            'handleItemClick',\n        ]);\n    }\n\n    static getDerivedStateFromProps(nextProps, prevState) {\n        const state = {};\n\n        if ('value' in nextProps && nextProps.value !== prevState.value) {\n            Object.assign(state, {\n                value: nextProps.value,\n            });\n        }\n\n        if ('visible' in nextProps && nextProps.visible !== prevState.visible) {\n            Object.assign(state, {\n                visible: nextProps.visible,\n            });\n        }\n\n        if (Object.keys(state).length) {\n            return state;\n        }\n\n        return null;\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        const props = this.props;\n\n        if ('value' in props) {\n            this.dataStore.setOptions({ key: props.value });\n        }\n\n        if (props.filter !== prevProps.filter) {\n            this.dataStore.setOptions({\n                filter: props.filter,\n            });\n        }\n        if (props.filterLocal !== prevProps.filterLocal) {\n            this.dataStore.setOptions({\n                filterLocal: props.filterLocal,\n            });\n        }\n\n        if (\n            prevProps.children !== props.children ||\n            prevProps.dataSource !== props.dataSource\n        ) {\n            /* eslint-disable react/no-did-update-set-state */\n            this.setState({\n                dataSource: this.setDataSource(props),\n            });\n\n            // remote dataSource and focused\n            // 因为autoComplete没有下拉数据不展示，搜索并且有数据了需要自动展示下拉\n            if (!props.filterLocal && this.isInputing) {\n                this.shouldControlPopup(props, 'update');\n            }\n            if (!props.filterLocal && !props.popupContent) {\n                this.setFirstHightLightKeyForMenu();\n            }\n        }\n    }\n\n    shouldControlPopup(props = this.props, type) {\n        const hasPopup =\n            props.popupContent || this.dataStore.getMenuDS().length;\n        if (hasPopup) {\n            this.setVisible(true, type);\n        } else {\n            this.setVisible(false, type);\n        }\n    }\n\n    handleMenuSelect(keys) {\n        const key = keys[0];\n\n        const mapDS = this.dataStore.getMapDS();\n\n        if (key in mapDS) {\n            const item = mapDS[key];\n            this.handleSelectEvent(key, item, 'itemClick');\n        }\n    }\n\n    handleItemClick() {\n        this.setVisible(false, 'itemClick');\n    }\n\n    handleSelectEvent(key, item, triggerType) {\n        const value = (item && item[this.props.fillProps]) || key;\n\n        if (triggerType === 'itemClick' || triggerType === 'enter') {\n            // 点击 item 的时候不会触发关闭，需要手动关闭，其它类型比如 keyDown 等都会有其它事件句柄处理\n            this.setVisible(false, triggerType);\n        }\n\n        this.handleChange(value, triggerType, item);\n    }\n\n    handleChange = (value, proxy, item) => {\n        const { disabled, readOnly, filterLocal } = this.props;\n\n        if (disabled || readOnly) {\n            return false;\n        }\n\n        const actionType = typeof proxy === 'string' ? proxy : 'change';\n\n        this.isInputing = actionType === 'change';\n\n        if (filterLocal) {\n            this.setState({\n                dataSource: this.dataStore.updateByKey(value),\n            });\n\n            this.shouldControlPopup(this.props, actionType);\n            this.setFirstHightLightKeyForMenu();\n        }\n\n        // 非受控模式清空内部数据\n        if (!('value' in this.props)) {\n            this.setState({\n                value: value,\n            });\n        }\n\n        this.props.onChange(value, actionType, item);\n\n        if (actionType === 'itemClick' || actionType === 'enter') {\n            // 点击 item 的时候不会触发关闭，需要手动关闭，其它类型比如 keyDown 等都会有其它事件句柄处理\n            this.setVisible(false, actionType);\n        }\n    };\n\n    handleVisibleChange(visible, type) {\n        if (\n            !('visible' in this.props) &&\n            visible &&\n            !this.props.popupContent &&\n            !this.dataStore.getMenuDS().length\n        ) {\n            return;\n        }\n\n        this.setVisible(visible, type);\n    }\n\n    beforeClose() {\n        this.isInputing = false;\n    }\n\n    /**\n     * Handle trigger keydown event\n     * @param {Event} e\n     */\n    handleTriggerKeyDown(e) {\n        const { popupContent, onToggleHighlightItem, onKeyDown } = this.props;\n        if (popupContent) {\n            e.stopPropagation(); //stopPropagation can make use onChange triggerd while typing space('') in Input\n            return onKeyDown(e);\n        }\n\n        switch (e.keyCode) {\n            case KEYCODE.UP:\n                e.preventDefault();\n                onToggleHighlightItem(this.toggleHighlightItem(-1, e), 'up');\n                break;\n            case KEYCODE.DOWN:\n                e.preventDefault();\n                onToggleHighlightItem(this.toggleHighlightItem(1, e), 'down');\n                break;\n            case KEYCODE.ENTER:\n                e.preventDefault();\n                this.chooseHighlightItem(e);\n                break;\n            case KEYCODE.SPACE:\n                // stopPropagation can make use onChange triggerd while typing space('') in Input\n                e.stopPropagation();\n                break;\n            case KEYCODE.ESC:\n                e.preventDefault();\n                this.state.visible && this.setVisible(false, 'esc');\n                break;\n            default:\n                break;\n        }\n\n        onKeyDown(e);\n    }\n\n    // 回车 选择高亮的 item\n    chooseHighlightItem() {\n        if (!this.state.visible) {\n            return false;\n        }\n\n        const { highlightKey } = this.state;\n        const highlightItem = this.dataStore.getEnableDS().find(item => {\n            return highlightKey === `${item.value}`;\n        });\n\n        if (highlightItem) {\n            this.handleSelectEvent(highlightKey, highlightItem, 'enter');\n        }\n    }\n\n    hasClear() {\n        const { hasClear, readOnly, disabled } = this.props;\n        const { value } = this.state;\n\n        return value && hasClear && !readOnly && !disabled;\n    }\n\n    /**\n     * 选择器\n     * @override\n     * @param {object} props\n     */\n    renderSelect(props = this.props) {\n        const {\n            placeholder,\n            size,\n            prefix,\n            className,\n            style,\n            label,\n            readOnly,\n            disabled,\n            highlightHolder,\n            locale,\n            hasClear,\n            state,\n            rtl,\n        } = props;\n        const others = obj.pickOthers(AutoComplete.propTypes, props);\n        const othersData = obj.pickAttrsWith(others, 'data-');\n\n        const value = this.state.value;\n        const visible = this.state.visible;\n\n        // // 下拉箭头\n        // const arrowNode = this.renderArrowNode(props, () => {\n        //     this.focusInput();\n        //     this.setVisible(!this.state.visible);\n        // });\n\n        // trigger className\n        const triggerClazz = classNames(\n            [\n                `${prefix}select`,\n                `${prefix}select-auto-complete`,\n                `${prefix}size-${size}`,\n                className,\n            ],\n            {\n                [`${prefix}active`]: visible,\n                [`${prefix}disabled`]: disabled,\n            }\n        );\n\n        // highlightKey into placeholder\n        // compatible with selectPlaceHolder. TODO: removed in 2.0 version\n        let _placeholder =\n            placeholder ||\n            locale.autoCompletePlaceholder ||\n            locale.autoCompletePlaceHolder;\n        if (highlightHolder && visible) {\n            _placeholder = this.state.highlightKey || _placeholder;\n        }\n\n        // Input props\n        const _inputProps = {\n            ...obj.pickOthers(othersData, others),\n            state: state,\n            ref: this.saveInputRef,\n            hasClear: hasClear,\n            value,\n            size,\n            disabled,\n            readOnly,\n            placeholder: _placeholder,\n            label,\n            // extra: arrowNode,\n            onChange: this.handleChange,\n            onKeyDown: this.handleTriggerKeyDown,\n        };\n\n        return (\n            <span\n                {...othersData}\n                className={triggerClazz}\n                style={style}\n                dir={rtl ? 'rtl' : undefined}\n                ref={this.saveSelectRef}\n                onClick={this.focusInput}\n            >\n                <Input\n                    role=\"combobox\"\n                    aria-autocomplete=\"list\"\n                    aria-disabled={disabled}\n                    aria-expanded={this.state.visible}\n                    {..._inputProps}\n                />\n                <span className={`${prefix}sr-only`} aria-live=\"polite\">\n                    {this.state.srReader}\n                </span>\n            </span>\n        );\n    }\n\n    render() {\n        if (this.hasClear()) {\n            // clear 按钮点击后，会在 dom 结构中被删除掉，需要将其额外设置为安全节点，防止触发弹层的显示或隐藏\n            const safeNode = this.props.popupProps.safeNode || [];\n            const safeNodes = Array.isArray(safeNode) ? safeNode : [safeNode];\n            safeNodes.push(() => this.clearNode);\n            this.props.popupProps.safeNode = safeNodes;\n        }\n\n        return super.render(\n            Object.assign({}, this.props, { canCloseByTrigger: false })\n        );\n    }\n}\n\nexport default polyfill(AutoComplete);"
    }
}