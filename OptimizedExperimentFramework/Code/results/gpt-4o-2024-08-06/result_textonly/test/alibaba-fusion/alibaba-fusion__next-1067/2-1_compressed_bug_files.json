{
    "1": {
        "bug_file": "src/slider/index.jsx",
        "compressed": "NO",
        "line_numbers": 77,
        "compressed_line_numbers": 77,
        "compressed_bug_file_content": "import ConfigProvider from '../config-provider';\nimport Slider from './slider';\n\nexport default ConfigProvider.config(Slider, {\n    exportNames: ['resize'],\n    transform: /* istanbul ignore next */ (props, deprecated) => {\n        if ('fade' in props) {\n            deprecated('fade', 'animation', 'Slider');\n\n            const { fade, ...others } = props;\n            if (fade) {\n                props = { animation: 'fade', ...others };\n            } else {\n                props = others;\n            }\n        }\n        if ('arrowPos' in props) {\n            if (props.arrowPos === 'inline') {\n                deprecated('arrowPos=inline', 'arrowPosition=inner', 'Slider');\n\n                props.arrowPos = 'inner';\n            } else {\n                deprecated('arrowPos', 'arrowPosition', 'Slider');\n            }\n            const { arrowPos, ...others } = props;\n            props = { arrowPosition: arrowPos, ...others };\n        }\n        ['arrowDirection', 'dotsDirection', 'slideDirection'].forEach(\n            propName => {\n                if (props[propName] === 'horizontal') {\n                    deprecated(\n                        `${propName}=horizontal`,\n                        `${propName}=hoz`,\n                        'Slider'\n                    );\n\n                    props[propName] = 'hoz';\n                } else if (props[propName] === 'vertical') {\n                    deprecated(\n                        `${propName}=vertical`,\n                        `${propName}=ver`,\n                        'Slider'\n                    );\n\n                    props[propName] = 'ver';\n                }\n            }\n        );\n        if ('initialSlide' in props) {\n            deprecated('initialSlide', 'defaultActiveIndex', 'Slider');\n\n            const { initialSlide, ...others } = props;\n            props = { defaultActiveIndex: initialSlide, ...others };\n        }\n        if ('slickGoTo' in props) {\n            deprecated('slickGoTo', 'activeIndex', 'Slider');\n\n            const { slickGoTo, ...others } = props;\n            props = { activeIndex: slickGoTo, ...others };\n        }\n        if ('afterChange' in props) {\n            deprecated('afterChange', 'onChange', 'Slider');\n\n            const { afterChange, ...others } = props;\n            props = { onChange: afterChange, ...others };\n        }\n\n        if ('beforeChange' in props) {\n            deprecated('beforeChange', 'onBeforeChange', 'Slider');\n\n            const { beforeChange, ...others } = props;\n            props = { onBeforeChange: beforeChange, ...others };\n        }\n\n        return props;\n    },\n});"
    },
    "2": {
        "bug_file": "src/slider/slider.jsx",
        "compressed": "NO",
        "line_numbers": 266,
        "compressed_line_numbers": 266,
        "compressed_bug_file_content": "import React, { Component } from 'react';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport { obj } from '../util';\nimport InnerSlider from './slick/inner-slider';\nimport ConfigProvider from '../config-provider';\n\n/**\n * Slider\n */\nexport default class Slider extends Component {\n    static propTypes = {\n        prefix: PropTypes.string,\n        rtl: PropTypes.bool,\n        /**\n         * 自定义传入的样式\n         */\n        className: PropTypes.any,\n        /**\n         * 是否使用自适应高度\n         */\n        adaptiveHeight: PropTypes.bool,\n        /**\n         * 动效类型，默认是'slide'\n         */\n        animation: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n        /**\n         * 是否显示箭头\n         */\n        arrows: PropTypes.bool,\n        /**\n         * 导航箭头大小 可选值: 'medium', 'large'\n         */\n        arrowSize: PropTypes.oneOf(['medium', 'large']),\n        /**\n         * 导航箭头位置 可选值: 'inner', 'outer'\n         */\n        arrowPosition: PropTypes.oneOf(['inner', 'outer']),\n        /**\n         * 导航箭头的方向 可选值: 'hoz', 'ver'\n         */\n        arrowDirection: PropTypes.oneOf(['hoz', 'ver']),\n        /**\n         * 是否自动播放\n         */\n        autoplay: PropTypes.bool,\n        /**\n         * 自动播放的速度\n         */\n        autoplaySpeed: PropTypes.number,\n        /**\n         * 向后箭头\n         */\n        nextArrow: PropTypes.element,\n        /**\n         * 向前箭头\n         */\n        prevArrow: PropTypes.element,\n        /**\n         * 是否启用居中模式\n         */\n        centerMode: PropTypes.bool,\n        /**\n         * 是否显示导航锚点\n         */\n        dots: PropTypes.bool,\n        /**\n         * 导航锚点位置\n         */\n        dotsDirection: PropTypes.oneOf(['hoz', 'ver']),\n        dotsClass: PropTypes.string,\n        /**\n         * 自定义导航锚点\n         */\n        dotRender: PropTypes.func,\n        /**\n         * 是否可拖拽\n         */\n        draggable: PropTypes.bool,\n        /**\n         * 是否使用无穷循环模式\n         */\n        infinite: PropTypes.bool,\n        /**\n         * 初始被激活的轮播图\n         */\n        defaultActiveIndex: PropTypes.number,\n        /**\n         * 是否启用懒加载\n         */\n        lazyLoad: PropTypes.bool,\n        slide: PropTypes.string,\n        /**\n         * 轮播方向\n         */\n        slideDirection: PropTypes.oneOf(['hoz', 'ver']),\n        /**\n         * 同时展示的图片数量\n         */\n        slidesToShow: PropTypes.number,\n        /**\n         * 同时滑动的图片数量\n         */\n        slidesToScroll: PropTypes.number,\n        /**\n         * 轮播速度\n         */\n        speed: PropTypes.number,\n        /**\n         * 跳转到指定的轮播图（受控）\n         */\n        activeIndex: PropTypes.number,\n        /**\n         * 锚点导航触发方式\n         */\n        triggerType: PropTypes.oneOf(['click', 'hover']),\n        /**\n         * 轮播切换的回调函数\n         * @param {Number} index 幻灯片的索引\n         */\n        onChange: PropTypes.func,\n        onBeforeChange: PropTypes.func, // 兼容 0.x onBeforeChange\n        children: PropTypes.any,\n        /**\n         * 自定义传入的class\n         */\n        style: PropTypes.object,\n        /**\n         * Side padding when in center mode (px or %); 展示部分为center，pading会产生前后预览\n         */\n        centerPadding: PropTypes.string,\n        /**\n         * CSS3 Animation Easing,默认‘ease’\n         */\n        cssEase: PropTypes.string, // used\n        edgeFriction: PropTypes.number, // 非无限轮播滑动到边缘时的阻力\n        /**\n         * 多图轮播时，点击选中后自动居中\n         */\n        focusOnSelect: PropTypes.bool,\n        pauseOnHover: PropTypes.bool, // 鼠标经过时停止播放\n        swipe: PropTypes.bool,\n        swipeToSlide: PropTypes.bool,\n        touchMove: PropTypes.bool,\n        touchThreshold: PropTypes.number,\n        useCSS: PropTypes.bool,\n        variableWidth: PropTypes.bool, // used\n        waitForAnimate: PropTypes.bool,\n        edgeEvent: PropTypes.any,\n        swipeEvent: PropTypes.any,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        animation: 'slide',\n        arrowSize: 'medium',\n        arrowPosition: 'inner',\n        vertical: false,\n        verticalSwiping: false,\n        dots: true,\n        dotsDirection: 'hoz',\n        arrows: true,\n        arrowDirection: 'hoz',\n        infinite: true,\n        autoplay: false,\n        autoplaySpeed: 3000,\n        speed: 600,\n        adaptiveHeight: false,\n        centerMode: false,\n        centerPadding: '50px', // Side padding when in center mode (px or %); 展示部分为center，pading会产生前后预览\n        cssEase: 'ease',\n        draggable: true,\n        edgeFriction: 0.35,\n        focusOnSelect: false,\n        defaultActiveIndex: 0,\n        lazyLoad: false,\n        pauseOnHover: false,\n        rtl: false,\n        slide: 'div',\n        slideDirection: 'hoz',\n        slidesToShow: 1,\n        slidesToScroll: 1,\n        swipe: true,\n        swipeToSlide: false, // Allow users to drag or swipe directly to a slide irrespective of slidesToScroll\n        touchMove: true, // 移动端touch\n        touchThreshold: 5,\n        useCSS: true,\n        variableWidth: false,\n        waitForAnimate: true,\n        onChange: () => {},\n        onBeforeChange: () => {},\n        edgeEvent: null,\n        swipeEvent: null,\n        nextArrow: null, // nextArrow, prevArrow are react components\n        prevArrow: null,\n        style: null,\n        dotsRender: null,\n        triggerType: 'click',\n    };\n\n    resize = () => {\n        // export api\n        this.innerSlider.onWindowResized();\n    };\n\n    render() {\n        const {\n            prefix,\n            arrowPosition,\n            slideDirection,\n            style,\n            className,\n            children,\n        } = this.props;\n\n        const sliderProps = obj.pickOthers(\n            ['className', 'style', 'slideDirection'],\n            this.props\n        );\n        const slideCount = React.Children.count(children);\n\n        if (slideCount === 0) {\n            // 没有 item 时不显示 slider\n            return null;\n        } else if (slideCount === 1) {\n            // 单个 item 时不显示箭头和控制器\n            sliderProps.arrows = false;\n            sliderProps.autoplay = false;\n            sliderProps.draggable = false;\n        }\n\n        const clazz = classNames(\n            [\n                `${prefix}slick`,\n                `${prefix}slick-${arrowPosition}`,\n                `${prefix}slick-${slideDirection}`,\n            ],\n            className\n        );\n\n        if (slideDirection === 'ver') {\n            // 向下传递时使用 vertical 属性\n            sliderProps.vertical = true;\n            sliderProps.verticalSwiping = true;\n        }\n\n        return (\n            <ConfigProvider rtl={false}>\n                <div\n                    dir=\"ltr\"\n                    className={clazz}\n                    style={style}\n                    {...obj.pickOthers(\n                        { ...Slider.propTypes, ...InnerSlider.propTypes },\n                        sliderProps\n                    )}\n                >\n                    <InnerSlider\n                        ref={InnerSlider => (this.innerSlider = InnerSlider)}\n                        {...sliderProps}\n                    />\n                </div>\n            </ConfigProvider>\n        );\n    }\n}"
    },
    "3": {
        "bug_file": "src/slider/slick/arrow.jsx",
        "compressed": "NO",
        "line_numbers": 143,
        "compressed_line_numbers": 143,
        "compressed_bug_file_content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Icon from '../../icon';\nimport { obj, func } from '../../util';\n\n/**\n * slider arrow\n * 左右控制箭头\n */\n\nconst { noop } = func;\n\nexport default class Arrow extends Component {\n    static propTypes = {\n        prefix: PropTypes.string,\n        rtl: PropTypes.bool,\n        type: PropTypes.oneOf(['prev', 'next']).isRequired,\n        centerMode: PropTypes.bool,\n        currentSlide: PropTypes.number,\n        infinite: PropTypes.bool,\n        clickHandler: PropTypes.func,\n        slideCount: PropTypes.number,\n        slidesToShow: PropTypes.number,\n        arrow: PropTypes.element,\n        arrowSize: PropTypes.string,\n        arrowPosition: PropTypes.string,\n        arrowDirection: PropTypes.oneOf(['hoz', 'ver']),\n        onMouseEnter: PropTypes.func,\n        onMouseLeave: PropTypes.func,\n        children: PropTypes.node,\n    };\n\n    static defaultProps = {\n        onMouseEnter: noop,\n        onMouseLeave: noop,\n    };\n\n    static isDisabled(props) {\n        const {\n            infinite,\n            type,\n            centerMode,\n            currentSlide,\n            slideCount,\n            slidesToShow,\n        } = props;\n\n        if (infinite) {\n            return false;\n        }\n\n        // 下一个 index 大于总数？？\n        if (slideCount <= slidesToShow) {\n            return true;\n        }\n\n        // 向前箭头：当前是第 0 个\n        if (type === 'prev') {\n            return currentSlide <= 0;\n        }\n\n        if (centerMode && currentSlide >= slideCount - 1) {\n            // 向后箭头：居中模式，当前 index 大于最大 index\n            return true;\n        } else if (currentSlide >= slideCount - slidesToShow) {\n            // 向后箭头：普通模式，当前 index 大于 总数 - 下一个 index ？？？\n            return true;\n        }\n\n        return false;\n    }\n\n    static ARROW_ICON_TYPES = {\n        hoz: { prev: 'arrow-left', next: 'arrow-right' },\n        ver: { prev: 'arrow-up', next: 'arrow-down' },\n    };\n\n    handleClick(options, e) {\n        e && e.preventDefault();\n\n        // TODO hack\n        if (options.message === 'prev') {\n            options.message = 'previous';\n        }\n\n        this.props.clickHandler(options, e);\n    }\n\n    render() {\n        const {\n            prefix,\n            type,\n            arrowSize,\n            arrowPosition,\n            arrowDirection,\n            onMouseEnter,\n            onMouseLeave,\n            children,\n        } = this.props;\n\n        const others = obj.pickOthers(Arrow.propTypes, this.props);\n        const iconType = Arrow.ARROW_ICON_TYPES[arrowDirection][type];\n        const disabled = Arrow.isDisabled(this.props);\n\n        const arrowClazz = classNames(\n            [\n                `${prefix}slick-arrow`,\n                `${prefix}slick-${type}`,\n                arrowPosition,\n                arrowSize,\n                arrowDirection,\n            ],\n            { disabled }\n        );\n\n        const arrowProps = {\n            ...others,\n            key: type,\n            'data-role': 'none',\n            className: arrowClazz,\n            style: { display: 'block' },\n            onClick: disabled\n                ? null\n                : this.handleClick.bind(this, { message: type }),\n            onMouseEnter: disabled ? null : onMouseEnter,\n            onMouseLeave: disabled ? null : onMouseLeave,\n        };\n\n        if (children) {\n            return React.cloneElement(\n                React.Children.only(children),\n                arrowProps\n            );\n        } else {\n            return (\n                <button type=\"button\" role=\"button\" {...arrowProps}>\n                    <Icon type={iconType} />\n                </button>\n            );\n        }\n    }\n}"
    },
    "4": {
        "bug_file": "src/slider/slick/mixins/helpers.js",
        "compressed": "NO",
        "line_numbers": 472,
        "compressed_line_numbers": 472,
        "compressed_bug_file_content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { getTrackCSS, getTrackLeft, getTrackAnimateCSS } from './trackHelper';\n\nconst helpers = {\n    initialize(props) {\n        const slickList = ReactDOM.findDOMNode(this.list);\n        const slideCount = React.Children.count(props.children);\n        const listWidth = this.getWidth(slickList);\n        const trackWidth = this.getWidth(ReactDOM.findDOMNode(this.track));\n        let slideWidth;\n\n        if (!props.vertical) {\n            const centerPaddingAdj =\n                props.centerMode && parseInt(props.centerPadding) * 2;\n            slideWidth = (listWidth - centerPaddingAdj) / props.slidesToShow;\n        } else {\n            slideWidth = listWidth;\n        }\n\n        const slideHeight = this.getHeight(\n            slickList.querySelector('[data-index=\"0\"]')\n        );\n        const listHeight = slideHeight * props.slidesToShow;\n\n        const slidesToShow = props.slidesToShow || 1;\n        const currentSlide = props.rtl\n            ? slideCount - 1 - (slidesToShow - 1) - props.defaultActiveIndex\n            : props.defaultActiveIndex;\n\n        this.setState(\n            {\n                slideCount,\n                slideWidth,\n                listWidth,\n                trackWidth,\n                currentSlide,\n                slideHeight,\n                listHeight,\n            },\n            () => {\n                const targetLeft = getTrackLeft({\n                    slideIndex: this.state.currentSlide,\n                    trackRef: this.track,\n                    ...props,\n                    ...this.state,\n                });\n                // getCSS function needs previously set state\n                const trackStyle = getTrackCSS({\n                    left: targetLeft,\n                    ...props,\n                    ...this.state,\n                });\n\n                this.setState({ trackStyle: trackStyle });\n\n                this.autoPlay(); // once we're set up, trigger the initial autoplay.\n            }\n        );\n    },\n\n    update(props) {\n        this.initialize(props);\n    },\n\n    getWidth(elem) {\n        return elem.getBoundingClientRect().width || elem.offsetWidth;\n    },\n\n    getHeight(elem) {\n        return elem.getBoundingClientRect().height || elem.offsetHeight;\n    },\n\n    adaptHeight() {\n        if (this.props.adaptiveHeight) {\n            const selector = `[data-index=\"${this.state.currentSlide}\"]`;\n            if (this.list) {\n                const slickList = ReactDOM.findDOMNode(this.list);\n                const listHeight = slickList.querySelector(selector)\n                    .offsetHeight;\n                slickList.style.height = `${listHeight}px`;\n            }\n        }\n    },\n\n    canGoNext(opts) {\n        let canGo = true;\n        if (!opts.infinite) {\n            if (opts.centerMode) {\n                if (opts.currentSlide >= opts.slideCount - 1) {\n                    canGo = false;\n                }\n            } else if (\n                opts.slideCount <= opts.slidesToShow ||\n                opts.currentSlide >= opts.slideCount - opts.slidesToShow\n            ) {\n                // check if all slides are shown in slider\n                canGo = false;\n            }\n        }\n        return canGo;\n    },\n\n    slideHandler(index) {\n        const { rtl } = this.props;\n\n        // Functionality of animateSlide and postSlide is merged into this function\n        let targetSlide, currentSlide;\n        let callback;\n\n        if (this.props.waitForAnimate && this.state.animating) {\n            return;\n        }\n\n        if (this.props.animation === 'fade') {\n            currentSlide = this.state.currentSlide;\n\n            // don't change slide if it's not infinite and current slide is the first or last slide'\n            if (\n                this.props.infinite === false &&\n                (index < 0 || index >= this.state.slideCount)\n            ) {\n                return;\n            }\n\n            //  Shifting targetSlide back into the range\n            if (index < 0) {\n                targetSlide = index + this.state.slideCount;\n            } else if (index >= this.state.slideCount) {\n                targetSlide = index - this.state.slideCount;\n            } else {\n                targetSlide = index;\n            }\n\n            if (\n                this.props.lazyLoad &&\n                this.state.lazyLoadedList.indexOf(targetSlide) < 0\n            ) {\n                this.setState({\n                    lazyLoadedList: this.state.lazyLoadedList.concat(\n                        targetSlide\n                    ),\n                });\n            }\n\n            callback = () => {\n                this.setState({\n                    animating: false,\n                });\n                this.props.onChange(targetSlide);\n                delete this.animationEndCallback;\n            };\n\n            this.props.onBeforeChange(this.state.currentSlide, targetSlide);\n\n            this.setState(\n                {\n                    animating: true,\n                    currentSlide: targetSlide,\n                },\n                function() {\n                    this.animationEndCallback = setTimeout(\n                        callback,\n                        this.props.speed + 20\n                    );\n                }\n            );\n\n            this.autoPlay();\n            return;\n        }\n\n        targetSlide = index;\n\n        if (rtl) {\n            if (targetSlide < 0) {\n                if (this.props.infinite === false) {\n                    currentSlide = 0;\n                } else if (\n                    this.state.slideCount % this.props.slidesToScroll !==\n                    0\n                ) {\n                    if (targetSlide + this.props.slidesToScroll <= 0) {\n                        currentSlide = this.state.slideCount + targetSlide;\n                        targetSlide =\n                            this.state.slideCount - this.props.slidesToScroll;\n                    } else {\n                        currentSlide = targetSlide = 0;\n                    }\n                } else {\n                    // this.state.slideCount % this.props.slidesToScroll\n                    currentSlide = this.state.slideCount + targetSlide;\n                }\n            } else if (targetSlide >= this.state.slideCount) {\n                if (this.props.infinite === false) {\n                    currentSlide =\n                        this.state.slideCount - this.props.slidesToShow;\n                } else if (\n                    this.state.slideCount % this.props.slidesToScroll !==\n                    0\n                ) {\n                    currentSlide = 0;\n                } else {\n                    currentSlide = targetSlide - this.state.slideCount;\n                }\n            } else {\n                currentSlide = targetSlide;\n            }\n        } else if (targetSlide < 0) {\n            if (this.props.infinite === false) {\n                currentSlide = 0;\n            } else if (\n                this.state.slideCount % this.props.slidesToScroll !==\n                0\n            ) {\n                currentSlide =\n                    this.state.slideCount -\n                    (this.state.slideCount % this.props.slidesToScroll);\n            } else {\n                currentSlide = this.state.slideCount + targetSlide;\n            }\n        } else if (targetSlide >= this.state.slideCount) {\n            if (this.props.infinite === false) {\n                currentSlide = this.state.slideCount - this.props.slidesToShow;\n            } else if (\n                this.state.slideCount % this.props.slidesToScroll !==\n                0\n            ) {\n                currentSlide = 0;\n            } else {\n                currentSlide = targetSlide - this.state.slideCount;\n            }\n        } else {\n            currentSlide = targetSlide;\n        }\n\n        let targetLeft = getTrackLeft({\n            slideIndex: targetSlide,\n            trackRef: this.track,\n            ...this.props,\n            ...this.state,\n        });\n\n        const currentLeft = getTrackLeft({\n            slideIndex: currentSlide,\n            trackRef: this.track,\n            ...this.props,\n            ...this.state,\n        });\n\n        if (this.props.infinite === false) {\n            targetLeft = currentLeft;\n        }\n\n        if (this.props.lazyLoad) {\n            let loaded = true;\n            const slidesToLoad = [];\n            const slidesLen = this.state.slideCount;\n\n            const sliderIndex =\n                targetSlide < 0 ? slidesLen + targetSlide : currentSlide;\n\n            for (\n                let i = sliderIndex;\n                i < sliderIndex + this.props.slidesToShow;\n                i++\n            ) {\n                let k = i;\n                if (rtl) {\n                    k =\n                        i >= slidesLen\n                            ? slidesLen * 2 - i - 1\n                            : slidesLen - i - 1;\n                }\n\n                const pre = k - 1 < 0 ? slidesLen - 1 : k - 1;\n                const next = k + 1 >= slidesLen ? 0 : k + 1;\n\n                this.state.lazyLoadedList.indexOf(k) < 0 &&\n                    slidesToLoad.push(k);\n                this.state.lazyLoadedList.indexOf(pre) < 0 &&\n                    slidesToLoad.push(pre);\n                this.state.lazyLoadedList.indexOf(next) < 0 &&\n                    slidesToLoad.push(next);\n            }\n\n            slidesToLoad.forEach(i => {\n                if (this.state.lazyLoadedList.indexOf(i) < 0) {\n                    loaded = false;\n                }\n            });\n\n            if (!loaded) {\n                this.setState({\n                    lazyLoadedList: this.state.lazyLoadedList.concat(\n                        slidesToLoad\n                    ),\n                });\n            }\n        }\n\n        this.props.onBeforeChange(this.state.currentSlide, currentSlide);\n\n        // Slide Transition happens here.\n        // animated transition happens to target Slide and\n        // non - animated transition happens to current Slide\n        // If CSS transitions are false, directly go the current slide.\n        /* istanbul ignore if */\n        if (this.props.useCSS === false) {\n            this.setState(\n                {\n                    currentSlide: currentSlide,\n                    trackStyle: getTrackCSS({\n                        left: currentLeft,\n                        ...this.props,\n                        ...this.state,\n                    }),\n                },\n                () => {\n                    this.props.onChange(currentSlide);\n                }\n            );\n        } else {\n            const nextStateChanges = {\n                animating: false,\n                currentSlide: currentSlide,\n                trackStyle: getTrackCSS({\n                    left: currentLeft,\n                    ...this.props,\n                    ...this.state,\n                }),\n                swipeLeft: null,\n            };\n\n            callback = () => {\n                this.setState(nextStateChanges);\n                this.props.onChange(currentSlide);\n                delete this.animationEndCallback;\n            };\n\n            this.setState(\n                {\n                    animating: true,\n                    currentSlide: currentSlide,\n                    trackStyle: getTrackAnimateCSS({\n                        left: targetLeft,\n                        ...this.props,\n                        ...this.state,\n                    }),\n                },\n                function() {\n                    this.animationEndCallback = setTimeout(\n                        callback,\n                        this.props.speed + 20\n                    );\n                }\n            );\n        }\n\n        this.autoPlay();\n    },\n\n    // 鼠标悬浮在 arrow 上时作出动画反馈\n    arrowHoverHandler(msg) {\n        const offset = 30; // slide 的位置偏移量\n        const targetLeft = getTrackLeft({\n            slideIndex: this.state.currentSlide,\n            trackRef: this.track,\n            ...this.props,\n            ...this.state,\n        });\n\n        let left;\n        /* istanbul ignore next */\n        if (msg === 'next') {\n            left = targetLeft - offset;\n        } else if (msg === 'prev') {\n            left = targetLeft + offset;\n        } else {\n            left = targetLeft;\n        }\n\n        this.setState({\n            trackStyle: getTrackAnimateCSS({\n                left,\n                ...this.props,\n                ...this.state,\n            }),\n        });\n    },\n\n    swipeDirection(touchObject) {\n        /* istanbul ignore next */\n        let swipeAngle;\n        /* istanbul ignore next */\n        const xDist = touchObject.startX - touchObject.curX;\n        /* istanbul ignore next */\n        const yDist = touchObject.startY - touchObject.curY;\n        /* istanbul ignore next */\n        const r = Math.atan2(yDist, xDist);\n        /* istanbul ignore next */\n        swipeAngle = Math.round((r * 180) / Math.PI);\n        /* istanbul ignore next */\n        if (swipeAngle < 0) {\n            swipeAngle = 360 - Math.abs(swipeAngle);\n        }\n        /* istanbul ignore next */\n        if (\n            (swipeAngle <= 45 && swipeAngle >= 0) ||\n            (swipeAngle <= 360 && swipeAngle >= 315)\n        ) {\n            return this.props.rtl === false ? 'left' : 'right';\n        }\n        /* istanbul ignore next */\n        if (swipeAngle >= 135 && swipeAngle <= 225) {\n            return this.props.rtl === false ? 'right' : 'left';\n        }\n        /* istanbul ignore next */\n        if (this.props.verticalSwiping === true) {\n            if (swipeAngle >= 35 && swipeAngle <= 135) {\n                return 'down';\n            } else {\n                return 'up';\n            }\n        }\n\n        /* istanbul ignore next */\n        return 'vertical';\n    },\n\n    play() {\n        let nextIndex;\n        if (!this.hasMounted) {\n            /* istanbul ignore next */\n            return false;\n        }\n        if (this.props.rtl) {\n            nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n        } else if (this.canGoNext({ ...this.props, ...this.state })) {\n            nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n        } else {\n            return false;\n        }\n        this.slideHandler(nextIndex);\n    },\n\n    autoPlay() {\n        if (this.state.autoPlayTimer) {\n            clearTimeout(this.state.autoPlayTimer);\n        }\n        if (this.props.autoplay) {\n            this.setState({\n                autoPlayTimer: setTimeout(\n                    this.play.bind(this),\n                    this.props.autoplaySpeed\n                ),\n            });\n        }\n    },\n\n    pause() {\n        /* istanbul ignore next */\n        if (this.state.autoPlayTimer) {\n            clearTimeout(this.state.autoPlayTimer);\n            this.setState({\n                autoPlayTimer: null,\n            });\n        }\n    },\n};\n\nexport default helpers;"
    },
    "5": {
        "bug_file": "src/slider/slick/mixins/event-handlers.js",
        "compressed": "NO",
        "line_numbers": 348,
        "compressed_line_numbers": 348,
        "compressed_bug_file_content": "import { findDOMNode } from 'react-dom';\nimport { getTrackCSS, getTrackLeft, getTrackAnimateCSS } from './trackHelper';\n\n/* istanbul ignore next */\nconst EventHandlers = {\n    // Event handler for previous and next\n    changeSlide(options) {\n        let slideOffset, targetSlide;\n        const unevenOffset =\n            this.state.slideCount % this.props.slidesToScroll !== 0;\n        const indexOffset = unevenOffset\n            ? 0\n            : (this.state.slideCount - this.state.currentSlide) %\n              this.props.slidesToScroll;\n\n        if (options.message === 'previous') {\n            slideOffset =\n                indexOffset === 0\n                    ? this.props.slidesToScroll\n                    : this.props.slidesToShow - indexOffset;\n            targetSlide = this.state.currentSlide - slideOffset;\n        } else if (options.message === 'next') {\n            slideOffset =\n                indexOffset === 0 ? this.props.slidesToScroll : indexOffset;\n            targetSlide = this.state.currentSlide + slideOffset;\n        } else if (\n            options.message === 'dots' ||\n            options.message === 'children'\n        ) {\n            // Click on dots\n            targetSlide = options.index * options.slidesToScroll;\n            if (targetSlide === options.currentSlide) {\n                return;\n            }\n        } else if (options.message === 'index') {\n            targetSlide = options.index;\n            if (targetSlide === options.currentSlide) {\n                return;\n            }\n        }\n        this.slideHandler(targetSlide);\n    },\n\n    // Accessiblity handler for previous and next\n    keyHandler(e) {\n        //Dont slide if the cursor is inside the form fields and arrow keys are pressed\n        if (!e.target.tagName.match('TEXTAREA|INPUT|SELECT')) {\n            if (e.keyCode === 37 && this.props.accessibility === true) {\n                this.changeSlide({\n                    message: this.props.rtl === true ? 'next' : 'previous',\n                });\n            } else if (e.keyCode === 39 && this.props.accessibility === true) {\n                this.changeSlide({\n                    message: this.props.rtl === true ? 'previous' : 'next',\n                });\n            }\n        }\n    },\n\n    // Focus on selecting a slide (click handler on track)\n    selectHandler(options) {\n        this.changeSlide(options);\n    },\n\n    swipeStart(e) {\n        if (\n            this.props.swipe === false ||\n            ('ontouchend' in document && this.props.swipe === false)\n        ) {\n            return;\n        } else if (\n            this.props.draggable === false &&\n            e.type.indexOf('mouse') !== -1\n        ) {\n            return;\n        }\n        const posX = e.touches !== undefined ? e.touches[0].pageX : e.clientX;\n        const posY = e.touches !== undefined ? e.touches[0].pageY : e.clientY;\n        this.setState({\n            dragging: true,\n            touchObject: {\n                startX: posX,\n                startY: posY,\n                curX: posX,\n                curY: posY,\n            },\n        });\n    },\n\n    swipeMove(e) {\n        if (!this.state.dragging) {\n            return;\n        }\n        if (this.state.animating) {\n            return;\n        }\n        const touchObject = this.state.touchObject;\n\n        const curLeft = getTrackLeft({\n            slideIndex: this.state.currentSlide,\n            trackRef: this.refs.track,\n            ...this.props,\n            ...this.state,\n        });\n\n        touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n        touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n        touchObject.swipeLength = Math.round(\n            Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2))\n        );\n\n        let positionOffset =\n            (this.props.rtl === false ? 1 : -1) *\n            (touchObject.curX > touchObject.startX ? 1 : -1);\n\n        if (this.props.verticalSwiping === true) {\n            touchObject.swipeLength = Math.round(\n                Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2))\n            );\n            positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n        }\n\n        const currentSlide = this.state.currentSlide;\n        const dotCount = Math.ceil(\n            this.state.slideCount / this.props.slidesToScroll\n        );\n        const swipeDirection = this.swipeDirection(this.state.touchObject);\n        let touchSwipeLength = touchObject.swipeLength;\n\n        if (this.props.infinite === false) {\n            if (\n                (currentSlide === 0 && swipeDirection === 'right') ||\n                (currentSlide + 1 >= dotCount && swipeDirection === 'left')\n            ) {\n                touchSwipeLength =\n                    touchObject.swipeLength * this.props.edgeFriction;\n\n                if (this.state.edgeDragged === false && this.props.edgeEvent) {\n                    this.props.edgeEvent(swipeDirection);\n                    this.setState({ edgeDragged: true });\n                }\n            }\n        }\n\n        if (this.state.swiped === false && this.props.swipeEvent) {\n            this.props.swipeEvent(swipeDirection);\n            this.setState({ swiped: true });\n        }\n\n        const swipeLeft = curLeft + touchSwipeLength * positionOffset;\n        this.setState({\n            touchObject: touchObject,\n            swipeLeft: swipeLeft,\n            trackStyle: getTrackCSS({\n                left: swipeLeft,\n                ...this.props,\n                ...this.state,\n            }),\n        });\n\n        if (\n            Math.abs(touchObject.curX - touchObject.startX) <\n            Math.abs(touchObject.curY - touchObject.startY) * 0.8\n        ) {\n            return;\n        }\n        if (touchObject.swipeLength > 4) {\n            e.preventDefault();\n        }\n    },\n\n    getNavigableIndexes() {\n        let max;\n        let breakPoint = 0;\n        let counter = 0;\n        const indexes = [];\n\n        if (!this.props.infinite) {\n            max = this.state.slideCount;\n        } else {\n            breakPoint = this.props.slidesToShow * -1;\n            counter = this.props.slidesToShow * -1;\n            max = this.state.slideCount * 2;\n        }\n\n        while (breakPoint < max) {\n            indexes.push(breakPoint);\n            breakPoint = counter + this.props.slidesToScroll;\n\n            counter +=\n                this.props.slidesToScroll <= this.props.slidesToShow\n                    ? this.props.slidesToScroll\n                    : this.props.slidesToShow;\n        }\n\n        return indexes;\n    },\n\n    checkNavigable(index) {\n        const navigables = this.getNavigableIndexes();\n        let prevNavigable = 0;\n\n        if (index > navigables[navigables.length - 1]) {\n            index = navigables[navigables.length - 1];\n        } else {\n            for (const n in navigables) {\n                if (index < navigables[n]) {\n                    index = prevNavigable;\n                    break;\n                }\n\n                prevNavigable = navigables[n];\n            }\n        }\n\n        return index;\n    },\n\n    getSlideCount() {\n        const centerOffset = this.props.centerMode\n            ? this.state.slideWidth * Math.floor(this.props.slidesToShow / 2)\n            : 0;\n        if (this.props.swipeToSlide) {\n            let swipedSlide;\n            const slickList = findDOMNode(this.list);\n\n            const slides = slickList.querySelectorAll(\n                `${this.props.prefix}slick-slide`\n            );\n\n            Array.from(slides).every(slide => {\n                if (!this.props.vertical) {\n                    if (\n                        slide.offsetLeft -\n                            centerOffset +\n                            this.getWidth(slide) / 2 >\n                        this.state.swipeLeft * -1\n                    ) {\n                        swipedSlide = slide;\n                        return false;\n                    }\n                } else if (\n                    slide.offsetTop + this.getHeight(slide) / 2 >\n                    this.state.swipeLeft * -1\n                ) {\n                    swipedSlide = slide;\n                    return false;\n                }\n\n                return true;\n            });\n            const slidesTraversed =\n                Math.abs(swipedSlide.dataset.index - this.state.currentSlide) ||\n                1;\n            return slidesTraversed;\n        } else {\n            return this.props.slidesToScroll;\n        }\n    },\n\n    swipeEnd(e) {\n        if (!this.state.dragging) {\n            if (this.props.swipe) {\n                e.preventDefault();\n            }\n            return;\n        }\n        const touchObject = this.state.touchObject;\n        let minSwipe = this.state.listWidth / this.props.touchThreshold;\n        const swipeDirection = this.swipeDirection(touchObject);\n\n        if (this.props.verticalSwiping) {\n            minSwipe = this.state.listHeight / this.props.touchThreshold;\n        }\n\n        // reset the state of touch related state variables.\n        this.setState({\n            dragging: false,\n            edgeDragged: false,\n            swiped: false,\n            swipeLeft: null,\n            touchObject: {},\n        });\n\n        if (!touchObject.swipeLength) {\n            return;\n        }\n\n        if (touchObject.swipeLength > minSwipe) {\n            e.preventDefault();\n\n            let slideCount;\n            let newSlide;\n\n            switch (swipeDirection) {\n                case 'left':\n                case 'down':\n                    newSlide = this.state.currentSlide + this.getSlideCount();\n                    slideCount = this.props.swipeToSlide\n                        ? this.checkNavigable(newSlide)\n                        : newSlide;\n                    this.setState({ currentDirection: 0 });\n                    break;\n                case 'right':\n                case 'up':\n                    newSlide = this.state.currentSlide - this.getSlideCount();\n                    slideCount = this.props.swipeToSlide\n                        ? this.checkNavigable(newSlide)\n                        : newSlide;\n                    this.setState({ currentDirection: 1 });\n                    break;\n                default:\n                    slideCount = this.state.currentSlide;\n            }\n            this.slideHandler(slideCount);\n        } else {\n            // Adjust the track back to it's original position.\n            const currentLeft = getTrackLeft({\n                slideIndex: this.state.currentSlide,\n                trackRef: this.track,\n                ...this.props,\n                ...this.state,\n            });\n\n            this.setState({\n                trackStyle: getTrackAnimateCSS({\n                    left: currentLeft,\n                    ...this.props,\n                    ...this.state,\n                }),\n            });\n        }\n    },\n\n    onInnerSliderEnter() {\n        if (this.props.autoplay && this.props.pauseOnHover) {\n            this.pause();\n        }\n    },\n\n    onInnerSliderLeave() {\n        if (this.props.autoplay && this.props.pauseOnHover) {\n            this.autoPlay();\n        }\n    },\n};\n\nexport default EventHandlers;"
    },
    "6": {
        "bug_file": "src/slider/slick/inner-slider.jsx",
        "compressed": "NO",
        "line_numbers": 412,
        "compressed_line_numbers": 412,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport { events, func, obj } from '../../util';\nimport EventHandlersMixin from './mixins/event-handlers';\nimport HelpersMixin from './mixins/helpers';\nimport Arrow from './arrow';\nimport Track from './track';\nimport Dots from './dots';\n\n/**\n * Slider inner\n */\n\nconst { noop } = func;\n\nclass InnerSlider extends React.Component {\n    static propTypes = {\n        prefix: PropTypes.string,\n        animation: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n        arrows: PropTypes.bool,\n        arrowSize: PropTypes.oneOf(['medium', 'large']),\n        arrowPosition: PropTypes.oneOf(['inner', 'outer']),\n        arrowDirection: PropTypes.oneOf(['hoz', 'ver']),\n        centerPadding: PropTypes.any,\n        children: PropTypes.any,\n        centerMode: PropTypes.bool,\n        dots: PropTypes.bool,\n        dotsDirection: PropTypes.oneOf(['hoz', 'ver']),\n        dotsClass: PropTypes.string,\n        focusOnSelect: PropTypes.bool,\n        cssEase: PropTypes.string,\n        speed: PropTypes.number,\n        infinite: PropTypes.bool,\n        defaultActiveIndex: PropTypes.number,\n        rtl: PropTypes.bool,\n        slidesToShow: PropTypes.number,\n        lazyLoad: PropTypes.bool,\n        activeIndex: PropTypes.number,\n        slidesToScroll: PropTypes.number,\n        variableWidth: PropTypes.bool,\n        vertical: PropTypes.bool,\n        verticalSwiping: PropTypes.bool,\n        prevArrow: PropTypes.element,\n        nextArrow: PropTypes.element,\n        dotsRender: PropTypes.func,\n        triggerType: PropTypes.string,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        arrowDirection: 'hoz',\n        triggerType: 'click',\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            animating: false,\n            dragging: false,\n            autoPlayTimer: null,\n            currentDirection: 0,\n            currentLeft: null,\n            currentSlide:\n                'activeIndex' in props\n                    ? props.activeIndex\n                    : props.defaultActiveIndex,\n            direction: 1,\n            listWidth: null,\n            listHeight: null,\n            slideCount: null,\n            slideWidth: null,\n            slideHeight: null,\n            swipeLeft: null,\n            touchObject: {\n                startX: 0,\n                startY: 0,\n                curX: 0,\n                curY: 0,\n            },\n\n            lazyLoadedList: [],\n\n            // added for react\n            initialized: false,\n            edgeDragged: false,\n            swiped: false, // used by swipeEvent. differentites between touch and swipe.\n            trackStyle: {},\n            trackWidth: 0,\n        };\n\n        // this.filterProps = Object.assign({}, sliderPropTypes, InnerSlider.propTypes);\n\n        func.bindCtx(this, [\n            'onWindowResized',\n            'selectHandler',\n            'changeSlide',\n            'onInnerSliderEnter',\n            'onInnerSliderLeave',\n            'swipeStart',\n            'swipeMove',\n            'swipeEnd',\n        ]);\n    }\n\n    componentWillMount() {\n        this.hasMounted = true;\n\n        const { lazyLoad, children, slidesToShow } = this.props;\n        const { currentSlide } = this.state;\n        const lazyLoadedList = [];\n\n        if (lazyLoad) {\n            for (let i = 0, j = React.Children.count(children); i < j; i++) {\n                if (i >= currentSlide && i < currentSlide + slidesToShow) {\n                    lazyLoadedList.push(i);\n\n                    const pre = i - 1 < 0 ? j - 1 : i - 1;\n                    const next = i + 1 >= j ? 0 : i + 1;\n\n                    lazyLoadedList.push(pre);\n                    lazyLoadedList.push(next);\n                }\n            }\n\n            if (this.state.lazyLoadedList.length === 0) {\n                this.setState({\n                    lazyLoadedList,\n                });\n            }\n        }\n    }\n\n    componentDidMount() {\n        // TODO Hack for autoplay -- Inspect Later\n        this.initialize(this.props);\n        this.adaptHeight();\n\n        if (this.props.activeIndex) {\n            this.slickGoTo(this.props.activeIndex);\n        }\n\n        /* istanbul ignore if  */\n        if (window) {\n            // To support server-side rendering\n            events.on(window, 'resize', this.onWindowResized);\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if (this.props.defaultActiveIndex !== nextProps.defaultActiveIndex) {\n            this.setState({\n                currentSlide: nextProps.defaultActiveIndex,\n            });\n        }\n\n        if (this.props.activeIndex !== nextProps.activeIndex) {\n            this.slickGoTo(nextProps.activeIndex);\n        } else if (this.state.currentSlide >= nextProps.children.length) {\n            this.update(nextProps);\n            this.changeSlide({\n                message: 'index',\n                index: nextProps.children.length - nextProps.slidesToShow,\n                currentSlide: this.state.currentSlide,\n            });\n        } else {\n            const others = ['children'];\n            const update = !obj.shallowEqual(\n                obj.pickOthers(others, this.props),\n                obj.pickOthers(others, nextProps)\n            );\n            if (update) {\n                this.update(nextProps);\n            }\n        }\n    }\n\n    componentDidUpdate() {\n        this.adaptHeight();\n    }\n\n    componentWillUnmount() {\n        if (this.animationEndCallback) {\n            clearTimeout(this.animationEndCallback);\n        }\n\n        events.off(window, 'resize', this.onWindowResized);\n\n        if (this.state.autoPlayTimer) {\n            clearInterval(this.state.autoPlayTimer);\n        }\n    }\n\n    onWindowResized() {\n        this.update(this.props);\n        // animating state should be cleared while resizing, otherwise autoplay stops working\n        this.setState({ animating: false });\n        clearTimeout(this.animationEndCallback);\n        delete this.animationEndCallback;\n    }\n\n    slickGoTo(slide) {\n        typeof slide === 'number' &&\n            this.changeSlide({\n                message: 'index',\n                index: slide,\n                currentSlide: this.state.currentSlide,\n            });\n    }\n\n    onEnterArrow(msg) {\n        this.arrowHoverHandler(msg);\n    }\n\n    onLeaveArrow() {\n        this.arrowHoverHandler();\n    }\n\n    _instanceRefHandler(attr, ref) {\n        this[attr] = ref;\n    }\n\n    render() {\n        const {\n            prefix,\n            animation,\n            arrows,\n            arrowSize,\n            arrowPosition,\n            arrowDirection,\n            dots,\n            dotsClass,\n            cssEase,\n            speed,\n            infinite,\n            centerMode,\n            centerPadding,\n            lazyLoad,\n            dotsDirection,\n            rtl,\n            slidesToShow,\n            slidesToScroll,\n            variableWidth,\n            vertical,\n            verticalSwiping,\n            focusOnSelect,\n            children,\n            dotsRender,\n            triggerType,\n        } = this.props;\n\n        const {\n            currentSlide,\n            lazyLoadedList,\n            slideCount,\n            slideWidth,\n            slideHeight,\n            trackStyle,\n            listHeight,\n            dragging,\n        } = this.state;\n\n        // TODO 需要精简一下\n        const trackProps = {\n            prefix,\n            animation,\n            cssEase,\n            speed,\n            infinite,\n            centerMode,\n            focusOnSelect: focusOnSelect ? this.selectHandler : null,\n            currentSlide,\n            lazyLoad,\n            lazyLoadedList,\n            rtl,\n            slideWidth,\n            slideHeight,\n            slidesToShow,\n            slidesToScroll,\n            slideCount,\n            trackStyle,\n            variableWidth,\n            vertical,\n            verticalSwiping,\n            triggerType,\n            // clickHandler: this.changeSlide, unused\n        };\n\n        let dotsEle;\n\n        if (dots === true && slideCount > slidesToShow) {\n            const dotProps = {\n                prefix,\n                rtl,\n                dotsClass,\n                slideCount,\n                slidesToShow,\n                currentSlide,\n                slidesToScroll,\n                dotsDirection,\n                changeSlide: this.changeSlide,\n                dotsRender,\n                triggerType,\n            };\n\n            dotsEle = <Dots {...dotProps} />;\n        }\n\n        let prevArrow, nextArrow;\n\n        const arrowProps = {\n            prefix,\n            rtl,\n            arrowSize,\n            arrowPosition,\n            arrowDirection,\n            infinite,\n            centerMode,\n            currentSlide,\n            slideCount,\n            slidesToShow,\n            clickHandler: this.changeSlide,\n        };\n\n        if (arrows) {\n            prevArrow = (\n                <Arrow\n                    {...arrowProps}\n                    type=\"prev\"\n                    aria-label=\"Previous\"\n                    ref={this._instanceRefHandler.bind(this, 'pArrow')}\n                    onMouseEnter={\n                        animation ? this.onEnterArrow.bind(this, 'prev') : noop\n                    }\n                    onMouseLeave={\n                        animation ? this.onLeaveArrow.bind(this, 'prev') : noop\n                    }\n                >\n                    {this.props.prevArrow}\n                </Arrow>\n            );\n\n            nextArrow = (\n                <Arrow\n                    {...arrowProps}\n                    type=\"next\"\n                    aria-label=\"Next\"\n                    ref={this._instanceRefHandler.bind(this, 'nArrow')}\n                    onMouseEnter={\n                        animation ? this.onEnterArrow.bind(this, 'next') : noop\n                    }\n                    onMouseLeave={\n                        animation ? this.onLeaveArrow.bind(this, 'next') : noop\n                    }\n                >\n                    {this.props.nextArrow}\n                </Arrow>\n            );\n        }\n\n        const verticalHeightStyle = vertical\n            ? {\n                  height: listHeight,\n              }\n            : null;\n\n        let centerPaddingStyle;\n        if (centerMode) {\n            centerPaddingStyle = vertical\n                ? { padding: `${centerPadding} 0px` }\n                : { padding: `0px ${centerPadding}` };\n        }\n\n        return (\n            <div\n                className={`${prefix}slick-container ${prefix}slick-initialized`}\n                onMouseEnter={this.onInnerSliderEnter}\n                onMouseLeave={this.onInnerSliderLeave}\n            >\n                <div\n                    ref={this._instanceRefHandler.bind(this, 'list')}\n                    className={`${prefix}slick-list`}\n                    style={{ ...verticalHeightStyle, ...centerPaddingStyle }}\n                    onMouseDown={this.swipeStart}\n                    onMouseUp={this.swipeEnd}\n                    onTouchStart={this.swipeStart}\n                    onTouchEnd={this.swipeEnd}\n                    onMouseMove={dragging ? this.swipeMove : null}\n                    onMouseLeave={dragging ? this.swipeEnd : null}\n                    onTouchMove={dragging ? this.swipeMove : null}\n                    onTouchCancel={dragging ? this.swipeEnd : null}\n                >\n                    <Track\n                        ref={this._instanceRefHandler.bind(this, 'track')}\n                        {...trackProps}\n                    >\n                        {children}\n                    </Track>\n                </div>\n                {prevArrow}\n                {nextArrow}\n                {dotsEle}\n            </div>\n        );\n    }\n}\n\n// extend prototype\nObject.assign(InnerSlider.prototype, HelpersMixin);\nObject.assign(InnerSlider.prototype, EventHandlersMixin);\n\nexport default InnerSlider;"
    }
}