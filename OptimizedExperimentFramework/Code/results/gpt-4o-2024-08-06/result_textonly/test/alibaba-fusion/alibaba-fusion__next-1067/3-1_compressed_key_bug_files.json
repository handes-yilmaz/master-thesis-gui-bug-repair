{
    "1": {
        "bug_file": "src/slider/slick/arrow.jsx",
        "compressed": "NO",
        "line_numbers": 143,
        "compressed_line_numbers": 143,
        "compressed_bug_file_content": "import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Icon from '../../icon';\nimport { obj, func } from '../../util';\n\n/**\n * slider arrow\n * 左右控制箭头\n */\n\nconst { noop } = func;\n\nexport default class Arrow extends Component {\n    static propTypes = {\n        prefix: PropTypes.string,\n        rtl: PropTypes.bool,\n        type: PropTypes.oneOf(['prev', 'next']).isRequired,\n        centerMode: PropTypes.bool,\n        currentSlide: PropTypes.number,\n        infinite: PropTypes.bool,\n        clickHandler: PropTypes.func,\n        slideCount: PropTypes.number,\n        slidesToShow: PropTypes.number,\n        arrow: PropTypes.element,\n        arrowSize: PropTypes.string,\n        arrowPosition: PropTypes.string,\n        arrowDirection: PropTypes.oneOf(['hoz', 'ver']),\n        onMouseEnter: PropTypes.func,\n        onMouseLeave: PropTypes.func,\n        children: PropTypes.node,\n    };\n\n    static defaultProps = {\n        onMouseEnter: noop,\n        onMouseLeave: noop,\n    };\n\n    static isDisabled(props) {\n        const {\n            infinite,\n            type,\n            centerMode,\n            currentSlide,\n            slideCount,\n            slidesToShow,\n        } = props;\n\n        if (infinite) {\n            return false;\n        }\n\n        // 下一个 index 大于总数？？\n        if (slideCount <= slidesToShow) {\n            return true;\n        }\n\n        // 向前箭头：当前是第 0 个\n        if (type === 'prev') {\n            return currentSlide <= 0;\n        }\n\n        if (centerMode && currentSlide >= slideCount - 1) {\n            // 向后箭头：居中模式，当前 index 大于最大 index\n            return true;\n        } else if (currentSlide >= slideCount - slidesToShow) {\n            // 向后箭头：普通模式，当前 index 大于 总数 - 下一个 index ？？？\n            return true;\n        }\n\n        return false;\n    }\n\n    static ARROW_ICON_TYPES = {\n        hoz: { prev: 'arrow-left', next: 'arrow-right' },\n        ver: { prev: 'arrow-up', next: 'arrow-down' },\n    };\n\n    handleClick(options, e) {\n        e && e.preventDefault();\n\n        // TODO hack\n        if (options.message === 'prev') {\n            options.message = 'previous';\n        }\n\n        this.props.clickHandler(options, e);\n    }\n\n    render() {\n        const {\n            prefix,\n            type,\n            arrowSize,\n            arrowPosition,\n            arrowDirection,\n            onMouseEnter,\n            onMouseLeave,\n            children,\n        } = this.props;\n\n        const others = obj.pickOthers(Arrow.propTypes, this.props);\n        const iconType = Arrow.ARROW_ICON_TYPES[arrowDirection][type];\n        const disabled = Arrow.isDisabled(this.props);\n\n        const arrowClazz = classNames(\n            [\n                `${prefix}slick-arrow`,\n                `${prefix}slick-${type}`,\n                arrowPosition,\n                arrowSize,\n                arrowDirection,\n            ],\n            { disabled }\n        );\n\n        const arrowProps = {\n            ...others,\n            key: type,\n            'data-role': 'none',\n            className: arrowClazz,\n            style: { display: 'block' },\n            onClick: disabled\n                ? null\n                : this.handleClick.bind(this, { message: type }),\n            onMouseEnter: disabled ? null : onMouseEnter,\n            onMouseLeave: disabled ? null : onMouseLeave,\n        };\n\n        if (children) {\n            return React.cloneElement(\n                React.Children.only(children),\n                arrowProps\n            );\n        } else {\n            return (\n                <button type=\"button\" role=\"button\" {...arrowProps}>\n                    <Icon type={iconType} />\n                </button>\n            );\n        }\n    }\n}"
    },
    "2": {
        "bug_file": "src/slider/slick/mixins/helpers.js",
        "compressed": "NO",
        "line_numbers": 472,
        "compressed_line_numbers": 472,
        "compressed_bug_file_content": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { getTrackCSS, getTrackLeft, getTrackAnimateCSS } from './trackHelper';\n\nconst helpers = {\n    initialize(props) {\n        const slickList = ReactDOM.findDOMNode(this.list);\n        const slideCount = React.Children.count(props.children);\n        const listWidth = this.getWidth(slickList);\n        const trackWidth = this.getWidth(ReactDOM.findDOMNode(this.track));\n        let slideWidth;\n\n        if (!props.vertical) {\n            const centerPaddingAdj =\n                props.centerMode && parseInt(props.centerPadding) * 2;\n            slideWidth = (listWidth - centerPaddingAdj) / props.slidesToShow;\n        } else {\n            slideWidth = listWidth;\n        }\n\n        const slideHeight = this.getHeight(\n            slickList.querySelector('[data-index=\"0\"]')\n        );\n        const listHeight = slideHeight * props.slidesToShow;\n\n        const slidesToShow = props.slidesToShow || 1;\n        const currentSlide = props.rtl\n            ? slideCount - 1 - (slidesToShow - 1) - props.defaultActiveIndex\n            : props.defaultActiveIndex;\n\n        this.setState(\n            {\n                slideCount,\n                slideWidth,\n                listWidth,\n                trackWidth,\n                currentSlide,\n                slideHeight,\n                listHeight,\n            },\n            () => {\n                const targetLeft = getTrackLeft({\n                    slideIndex: this.state.currentSlide,\n                    trackRef: this.track,\n                    ...props,\n                    ...this.state,\n                });\n                // getCSS function needs previously set state\n                const trackStyle = getTrackCSS({\n                    left: targetLeft,\n                    ...props,\n                    ...this.state,\n                });\n\n                this.setState({ trackStyle: trackStyle });\n\n                this.autoPlay(); // once we're set up, trigger the initial autoplay.\n            }\n        );\n    },\n\n    update(props) {\n        this.initialize(props);\n    },\n\n    getWidth(elem) {\n        return elem.getBoundingClientRect().width || elem.offsetWidth;\n    },\n\n    getHeight(elem) {\n        return elem.getBoundingClientRect().height || elem.offsetHeight;\n    },\n\n    adaptHeight() {\n        if (this.props.adaptiveHeight) {\n            const selector = `[data-index=\"${this.state.currentSlide}\"]`;\n            if (this.list) {\n                const slickList = ReactDOM.findDOMNode(this.list);\n                const listHeight = slickList.querySelector(selector)\n                    .offsetHeight;\n                slickList.style.height = `${listHeight}px`;\n            }\n        }\n    },\n\n    canGoNext(opts) {\n        let canGo = true;\n        if (!opts.infinite) {\n            if (opts.centerMode) {\n                if (opts.currentSlide >= opts.slideCount - 1) {\n                    canGo = false;\n                }\n            } else if (\n                opts.slideCount <= opts.slidesToShow ||\n                opts.currentSlide >= opts.slideCount - opts.slidesToShow\n            ) {\n                // check if all slides are shown in slider\n                canGo = false;\n            }\n        }\n        return canGo;\n    },\n\n    slideHandler(index) {\n        const { rtl } = this.props;\n\n        // Functionality of animateSlide and postSlide is merged into this function\n        let targetSlide, currentSlide;\n        let callback;\n\n        if (this.props.waitForAnimate && this.state.animating) {\n            return;\n        }\n\n        if (this.props.animation === 'fade') {\n            currentSlide = this.state.currentSlide;\n\n            // don't change slide if it's not infinite and current slide is the first or last slide'\n            if (\n                this.props.infinite === false &&\n                (index < 0 || index >= this.state.slideCount)\n            ) {\n                return;\n            }\n\n            //  Shifting targetSlide back into the range\n            if (index < 0) {\n                targetSlide = index + this.state.slideCount;\n            } else if (index >= this.state.slideCount) {\n                targetSlide = index - this.state.slideCount;\n            } else {\n                targetSlide = index;\n            }\n\n            if (\n                this.props.lazyLoad &&\n                this.state.lazyLoadedList.indexOf(targetSlide) < 0\n            ) {\n                this.setState({\n                    lazyLoadedList: this.state.lazyLoadedList.concat(\n                        targetSlide\n                    ),\n                });\n            }\n\n            callback = () => {\n                this.setState({\n                    animating: false,\n                });\n                this.props.onChange(targetSlide);\n                delete this.animationEndCallback;\n            };\n\n            this.props.onBeforeChange(this.state.currentSlide, targetSlide);\n\n            this.setState(\n                {\n                    animating: true,\n                    currentSlide: targetSlide,\n                },\n                function() {\n                    this.animationEndCallback = setTimeout(\n                        callback,\n                        this.props.speed + 20\n                    );\n                }\n            );\n\n            this.autoPlay();\n            return;\n        }\n\n        targetSlide = index;\n\n        if (rtl) {\n            if (targetSlide < 0) {\n                if (this.props.infinite === false) {\n                    currentSlide = 0;\n                } else if (\n                    this.state.slideCount % this.props.slidesToScroll !==\n                    0\n                ) {\n                    if (targetSlide + this.props.slidesToScroll <= 0) {\n                        currentSlide = this.state.slideCount + targetSlide;\n                        targetSlide =\n                            this.state.slideCount - this.props.slidesToScroll;\n                    } else {\n                        currentSlide = targetSlide = 0;\n                    }\n                } else {\n                    // this.state.slideCount % this.props.slidesToScroll\n                    currentSlide = this.state.slideCount + targetSlide;\n                }\n            } else if (targetSlide >= this.state.slideCount) {\n                if (this.props.infinite === false) {\n                    currentSlide =\n                        this.state.slideCount - this.props.slidesToShow;\n                } else if (\n                    this.state.slideCount % this.props.slidesToScroll !==\n                    0\n                ) {\n                    currentSlide = 0;\n                } else {\n                    currentSlide = targetSlide - this.state.slideCount;\n                }\n            } else {\n                currentSlide = targetSlide;\n            }\n        } else if (targetSlide < 0) {\n            if (this.props.infinite === false) {\n                currentSlide = 0;\n            } else if (\n                this.state.slideCount % this.props.slidesToScroll !==\n                0\n            ) {\n                currentSlide =\n                    this.state.slideCount -\n                    (this.state.slideCount % this.props.slidesToScroll);\n            } else {\n                currentSlide = this.state.slideCount + targetSlide;\n            }\n        } else if (targetSlide >= this.state.slideCount) {\n            if (this.props.infinite === false) {\n                currentSlide = this.state.slideCount - this.props.slidesToShow;\n            } else if (\n                this.state.slideCount % this.props.slidesToScroll !==\n                0\n            ) {\n                currentSlide = 0;\n            } else {\n                currentSlide = targetSlide - this.state.slideCount;\n            }\n        } else {\n            currentSlide = targetSlide;\n        }\n\n        let targetLeft = getTrackLeft({\n            slideIndex: targetSlide,\n            trackRef: this.track,\n            ...this.props,\n            ...this.state,\n        });\n\n        const currentLeft = getTrackLeft({\n            slideIndex: currentSlide,\n            trackRef: this.track,\n            ...this.props,\n            ...this.state,\n        });\n\n        if (this.props.infinite === false) {\n            targetLeft = currentLeft;\n        }\n\n        if (this.props.lazyLoad) {\n            let loaded = true;\n            const slidesToLoad = [];\n            const slidesLen = this.state.slideCount;\n\n            const sliderIndex =\n                targetSlide < 0 ? slidesLen + targetSlide : currentSlide;\n\n            for (\n                let i = sliderIndex;\n                i < sliderIndex + this.props.slidesToShow;\n                i++\n            ) {\n                let k = i;\n                if (rtl) {\n                    k =\n                        i >= slidesLen\n                            ? slidesLen * 2 - i - 1\n                            : slidesLen - i - 1;\n                }\n\n                const pre = k - 1 < 0 ? slidesLen - 1 : k - 1;\n                const next = k + 1 >= slidesLen ? 0 : k + 1;\n\n                this.state.lazyLoadedList.indexOf(k) < 0 &&\n                    slidesToLoad.push(k);\n                this.state.lazyLoadedList.indexOf(pre) < 0 &&\n                    slidesToLoad.push(pre);\n                this.state.lazyLoadedList.indexOf(next) < 0 &&\n                    slidesToLoad.push(next);\n            }\n\n            slidesToLoad.forEach(i => {\n                if (this.state.lazyLoadedList.indexOf(i) < 0) {\n                    loaded = false;\n                }\n            });\n\n            if (!loaded) {\n                this.setState({\n                    lazyLoadedList: this.state.lazyLoadedList.concat(\n                        slidesToLoad\n                    ),\n                });\n            }\n        }\n\n        this.props.onBeforeChange(this.state.currentSlide, currentSlide);\n\n        // Slide Transition happens here.\n        // animated transition happens to target Slide and\n        // non - animated transition happens to current Slide\n        // If CSS transitions are false, directly go the current slide.\n        /* istanbul ignore if */\n        if (this.props.useCSS === false) {\n            this.setState(\n                {\n                    currentSlide: currentSlide,\n                    trackStyle: getTrackCSS({\n                        left: currentLeft,\n                        ...this.props,\n                        ...this.state,\n                    }),\n                },\n                () => {\n                    this.props.onChange(currentSlide);\n                }\n            );\n        } else {\n            const nextStateChanges = {\n                animating: false,\n                currentSlide: currentSlide,\n                trackStyle: getTrackCSS({\n                    left: currentLeft,\n                    ...this.props,\n                    ...this.state,\n                }),\n                swipeLeft: null,\n            };\n\n            callback = () => {\n                this.setState(nextStateChanges);\n                this.props.onChange(currentSlide);\n                delete this.animationEndCallback;\n            };\n\n            this.setState(\n                {\n                    animating: true,\n                    currentSlide: currentSlide,\n                    trackStyle: getTrackAnimateCSS({\n                        left: targetLeft,\n                        ...this.props,\n                        ...this.state,\n                    }),\n                },\n                function() {\n                    this.animationEndCallback = setTimeout(\n                        callback,\n                        this.props.speed + 20\n                    );\n                }\n            );\n        }\n\n        this.autoPlay();\n    },\n\n    // 鼠标悬浮在 arrow 上时作出动画反馈\n    arrowHoverHandler(msg) {\n        const offset = 30; // slide 的位置偏移量\n        const targetLeft = getTrackLeft({\n            slideIndex: this.state.currentSlide,\n            trackRef: this.track,\n            ...this.props,\n            ...this.state,\n        });\n\n        let left;\n        /* istanbul ignore next */\n        if (msg === 'next') {\n            left = targetLeft - offset;\n        } else if (msg === 'prev') {\n            left = targetLeft + offset;\n        } else {\n            left = targetLeft;\n        }\n\n        this.setState({\n            trackStyle: getTrackAnimateCSS({\n                left,\n                ...this.props,\n                ...this.state,\n            }),\n        });\n    },\n\n    swipeDirection(touchObject) {\n        /* istanbul ignore next */\n        let swipeAngle;\n        /* istanbul ignore next */\n        const xDist = touchObject.startX - touchObject.curX;\n        /* istanbul ignore next */\n        const yDist = touchObject.startY - touchObject.curY;\n        /* istanbul ignore next */\n        const r = Math.atan2(yDist, xDist);\n        /* istanbul ignore next */\n        swipeAngle = Math.round((r * 180) / Math.PI);\n        /* istanbul ignore next */\n        if (swipeAngle < 0) {\n            swipeAngle = 360 - Math.abs(swipeAngle);\n        }\n        /* istanbul ignore next */\n        if (\n            (swipeAngle <= 45 && swipeAngle >= 0) ||\n            (swipeAngle <= 360 && swipeAngle >= 315)\n        ) {\n            return this.props.rtl === false ? 'left' : 'right';\n        }\n        /* istanbul ignore next */\n        if (swipeAngle >= 135 && swipeAngle <= 225) {\n            return this.props.rtl === false ? 'right' : 'left';\n        }\n        /* istanbul ignore next */\n        if (this.props.verticalSwiping === true) {\n            if (swipeAngle >= 35 && swipeAngle <= 135) {\n                return 'down';\n            } else {\n                return 'up';\n            }\n        }\n\n        /* istanbul ignore next */\n        return 'vertical';\n    },\n\n    play() {\n        let nextIndex;\n        if (!this.hasMounted) {\n            /* istanbul ignore next */\n            return false;\n        }\n        if (this.props.rtl) {\n            nextIndex = this.state.currentSlide - this.props.slidesToScroll;\n        } else if (this.canGoNext({ ...this.props, ...this.state })) {\n            nextIndex = this.state.currentSlide + this.props.slidesToScroll;\n        } else {\n            return false;\n        }\n        this.slideHandler(nextIndex);\n    },\n\n    autoPlay() {\n        if (this.state.autoPlayTimer) {\n            clearTimeout(this.state.autoPlayTimer);\n        }\n        if (this.props.autoplay) {\n            this.setState({\n                autoPlayTimer: setTimeout(\n                    this.play.bind(this),\n                    this.props.autoplaySpeed\n                ),\n            });\n        }\n    },\n\n    pause() {\n        /* istanbul ignore next */\n        if (this.state.autoPlayTimer) {\n            clearTimeout(this.state.autoPlayTimer);\n            this.setState({\n                autoPlayTimer: null,\n            });\n        }\n    },\n};\n\nexport default helpers;"
    },
    "3": {
        "bug_file": "src/slider/slick/inner-slider.jsx",
        "compressed": "NO",
        "line_numbers": 412,
        "compressed_line_numbers": 412,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport { events, func, obj } from '../../util';\nimport EventHandlersMixin from './mixins/event-handlers';\nimport HelpersMixin from './mixins/helpers';\nimport Arrow from './arrow';\nimport Track from './track';\nimport Dots from './dots';\n\n/**\n * Slider inner\n */\n\nconst { noop } = func;\n\nclass InnerSlider extends React.Component {\n    static propTypes = {\n        prefix: PropTypes.string,\n        animation: PropTypes.oneOfType([PropTypes.string, PropTypes.bool]),\n        arrows: PropTypes.bool,\n        arrowSize: PropTypes.oneOf(['medium', 'large']),\n        arrowPosition: PropTypes.oneOf(['inner', 'outer']),\n        arrowDirection: PropTypes.oneOf(['hoz', 'ver']),\n        centerPadding: PropTypes.any,\n        children: PropTypes.any,\n        centerMode: PropTypes.bool,\n        dots: PropTypes.bool,\n        dotsDirection: PropTypes.oneOf(['hoz', 'ver']),\n        dotsClass: PropTypes.string,\n        focusOnSelect: PropTypes.bool,\n        cssEase: PropTypes.string,\n        speed: PropTypes.number,\n        infinite: PropTypes.bool,\n        defaultActiveIndex: PropTypes.number,\n        rtl: PropTypes.bool,\n        slidesToShow: PropTypes.number,\n        lazyLoad: PropTypes.bool,\n        activeIndex: PropTypes.number,\n        slidesToScroll: PropTypes.number,\n        variableWidth: PropTypes.bool,\n        vertical: PropTypes.bool,\n        verticalSwiping: PropTypes.bool,\n        prevArrow: PropTypes.element,\n        nextArrow: PropTypes.element,\n        dotsRender: PropTypes.func,\n        triggerType: PropTypes.string,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        arrowDirection: 'hoz',\n        triggerType: 'click',\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            animating: false,\n            dragging: false,\n            autoPlayTimer: null,\n            currentDirection: 0,\n            currentLeft: null,\n            currentSlide:\n                'activeIndex' in props\n                    ? props.activeIndex\n                    : props.defaultActiveIndex,\n            direction: 1,\n            listWidth: null,\n            listHeight: null,\n            slideCount: null,\n            slideWidth: null,\n            slideHeight: null,\n            swipeLeft: null,\n            touchObject: {\n                startX: 0,\n                startY: 0,\n                curX: 0,\n                curY: 0,\n            },\n\n            lazyLoadedList: [],\n\n            // added for react\n            initialized: false,\n            edgeDragged: false,\n            swiped: false, // used by swipeEvent. differentites between touch and swipe.\n            trackStyle: {},\n            trackWidth: 0,\n        };\n\n        // this.filterProps = Object.assign({}, sliderPropTypes, InnerSlider.propTypes);\n\n        func.bindCtx(this, [\n            'onWindowResized',\n            'selectHandler',\n            'changeSlide',\n            'onInnerSliderEnter',\n            'onInnerSliderLeave',\n            'swipeStart',\n            'swipeMove',\n            'swipeEnd',\n        ]);\n    }\n\n    componentWillMount() {\n        this.hasMounted = true;\n\n        const { lazyLoad, children, slidesToShow } = this.props;\n        const { currentSlide } = this.state;\n        const lazyLoadedList = [];\n\n        if (lazyLoad) {\n            for (let i = 0, j = React.Children.count(children); i < j; i++) {\n                if (i >= currentSlide && i < currentSlide + slidesToShow) {\n                    lazyLoadedList.push(i);\n\n                    const pre = i - 1 < 0 ? j - 1 : i - 1;\n                    const next = i + 1 >= j ? 0 : i + 1;\n\n                    lazyLoadedList.push(pre);\n                    lazyLoadedList.push(next);\n                }\n            }\n\n            if (this.state.lazyLoadedList.length === 0) {\n                this.setState({\n                    lazyLoadedList,\n                });\n            }\n        }\n    }\n\n    componentDidMount() {\n        // TODO Hack for autoplay -- Inspect Later\n        this.initialize(this.props);\n        this.adaptHeight();\n\n        if (this.props.activeIndex) {\n            this.slickGoTo(this.props.activeIndex);\n        }\n\n        /* istanbul ignore if  */\n        if (window) {\n            // To support server-side rendering\n            events.on(window, 'resize', this.onWindowResized);\n        }\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if (this.props.defaultActiveIndex !== nextProps.defaultActiveIndex) {\n            this.setState({\n                currentSlide: nextProps.defaultActiveIndex,\n            });\n        }\n\n        if (this.props.activeIndex !== nextProps.activeIndex) {\n            this.slickGoTo(nextProps.activeIndex);\n        } else if (this.state.currentSlide >= nextProps.children.length) {\n            this.update(nextProps);\n            this.changeSlide({\n                message: 'index',\n                index: nextProps.children.length - nextProps.slidesToShow,\n                currentSlide: this.state.currentSlide,\n            });\n        } else {\n            const others = ['children'];\n            const update = !obj.shallowEqual(\n                obj.pickOthers(others, this.props),\n                obj.pickOthers(others, nextProps)\n            );\n            if (update) {\n                this.update(nextProps);\n            }\n        }\n    }\n\n    componentDidUpdate() {\n        this.adaptHeight();\n    }\n\n    componentWillUnmount() {\n        if (this.animationEndCallback) {\n            clearTimeout(this.animationEndCallback);\n        }\n\n        events.off(window, 'resize', this.onWindowResized);\n\n        if (this.state.autoPlayTimer) {\n            clearInterval(this.state.autoPlayTimer);\n        }\n    }\n\n    onWindowResized() {\n        this.update(this.props);\n        // animating state should be cleared while resizing, otherwise autoplay stops working\n        this.setState({ animating: false });\n        clearTimeout(this.animationEndCallback);\n        delete this.animationEndCallback;\n    }\n\n    slickGoTo(slide) {\n        typeof slide === 'number' &&\n            this.changeSlide({\n                message: 'index',\n                index: slide,\n                currentSlide: this.state.currentSlide,\n            });\n    }\n\n    onEnterArrow(msg) {\n        this.arrowHoverHandler(msg);\n    }\n\n    onLeaveArrow() {\n        this.arrowHoverHandler();\n    }\n\n    _instanceRefHandler(attr, ref) {\n        this[attr] = ref;\n    }\n\n    render() {\n        const {\n            prefix,\n            animation,\n            arrows,\n            arrowSize,\n            arrowPosition,\n            arrowDirection,\n            dots,\n            dotsClass,\n            cssEase,\n            speed,\n            infinite,\n            centerMode,\n            centerPadding,\n            lazyLoad,\n            dotsDirection,\n            rtl,\n            slidesToShow,\n            slidesToScroll,\n            variableWidth,\n            vertical,\n            verticalSwiping,\n            focusOnSelect,\n            children,\n            dotsRender,\n            triggerType,\n        } = this.props;\n\n        const {\n            currentSlide,\n            lazyLoadedList,\n            slideCount,\n            slideWidth,\n            slideHeight,\n            trackStyle,\n            listHeight,\n            dragging,\n        } = this.state;\n\n        // TODO 需要精简一下\n        const trackProps = {\n            prefix,\n            animation,\n            cssEase,\n            speed,\n            infinite,\n            centerMode,\n            focusOnSelect: focusOnSelect ? this.selectHandler : null,\n            currentSlide,\n            lazyLoad,\n            lazyLoadedList,\n            rtl,\n            slideWidth,\n            slideHeight,\n            slidesToShow,\n            slidesToScroll,\n            slideCount,\n            trackStyle,\n            variableWidth,\n            vertical,\n            verticalSwiping,\n            triggerType,\n            // clickHandler: this.changeSlide, unused\n        };\n\n        let dotsEle;\n\n        if (dots === true && slideCount > slidesToShow) {\n            const dotProps = {\n                prefix,\n                rtl,\n                dotsClass,\n                slideCount,\n                slidesToShow,\n                currentSlide,\n                slidesToScroll,\n                dotsDirection,\n                changeSlide: this.changeSlide,\n                dotsRender,\n                triggerType,\n            };\n\n            dotsEle = <Dots {...dotProps} />;\n        }\n\n        let prevArrow, nextArrow;\n\n        const arrowProps = {\n            prefix,\n            rtl,\n            arrowSize,\n            arrowPosition,\n            arrowDirection,\n            infinite,\n            centerMode,\n            currentSlide,\n            slideCount,\n            slidesToShow,\n            clickHandler: this.changeSlide,\n        };\n\n        if (arrows) {\n            prevArrow = (\n                <Arrow\n                    {...arrowProps}\n                    type=\"prev\"\n                    aria-label=\"Previous\"\n                    ref={this._instanceRefHandler.bind(this, 'pArrow')}\n                    onMouseEnter={\n                        animation ? this.onEnterArrow.bind(this, 'prev') : noop\n                    }\n                    onMouseLeave={\n                        animation ? this.onLeaveArrow.bind(this, 'prev') : noop\n                    }\n                >\n                    {this.props.prevArrow}\n                </Arrow>\n            );\n\n            nextArrow = (\n                <Arrow\n                    {...arrowProps}\n                    type=\"next\"\n                    aria-label=\"Next\"\n                    ref={this._instanceRefHandler.bind(this, 'nArrow')}\n                    onMouseEnter={\n                        animation ? this.onEnterArrow.bind(this, 'next') : noop\n                    }\n                    onMouseLeave={\n                        animation ? this.onLeaveArrow.bind(this, 'next') : noop\n                    }\n                >\n                    {this.props.nextArrow}\n                </Arrow>\n            );\n        }\n\n        const verticalHeightStyle = vertical\n            ? {\n                  height: listHeight,\n              }\n            : null;\n\n        let centerPaddingStyle;\n        if (centerMode) {\n            centerPaddingStyle = vertical\n                ? { padding: `${centerPadding} 0px` }\n                : { padding: `0px ${centerPadding}` };\n        }\n\n        return (\n            <div\n                className={`${prefix}slick-container ${prefix}slick-initialized`}\n                onMouseEnter={this.onInnerSliderEnter}\n                onMouseLeave={this.onInnerSliderLeave}\n            >\n                <div\n                    ref={this._instanceRefHandler.bind(this, 'list')}\n                    className={`${prefix}slick-list`}\n                    style={{ ...verticalHeightStyle, ...centerPaddingStyle }}\n                    onMouseDown={this.swipeStart}\n                    onMouseUp={this.swipeEnd}\n                    onTouchStart={this.swipeStart}\n                    onTouchEnd={this.swipeEnd}\n                    onMouseMove={dragging ? this.swipeMove : null}\n                    onMouseLeave={dragging ? this.swipeEnd : null}\n                    onTouchMove={dragging ? this.swipeMove : null}\n                    onTouchCancel={dragging ? this.swipeEnd : null}\n                >\n                    <Track\n                        ref={this._instanceRefHandler.bind(this, 'track')}\n                        {...trackProps}\n                    >\n                        {children}\n                    </Track>\n                </div>\n                {prevArrow}\n                {nextArrow}\n                {dotsEle}\n            </div>\n        );\n    }\n}\n\n// extend prototype\nObject.assign(InnerSlider.prototype, HelpersMixin);\nObject.assign(InnerSlider.prototype, EventHandlersMixin);\n\nexport default InnerSlider;"
    }
}