{
    "1": {
        "bug_file": "src/number-picker/index.jsx",
        "compressed": "NO",
        "line_numbers": 446,
        "compressed_line_numbers": 446,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Icon from '../icon';\nimport Button from '../button';\nimport Input from '../input';\nimport ConfigProvider from '../config-provider';\nimport {func, obj} from '../util';\n\n/** NumberPicker */\nclass NumberPicker extends React.Component {\n\n    static propTypes = {\n        /**\n         * 样式前缀\n         */\n        prefix: PropTypes.string,\n        /**\n         * 设置类型\n         * @enumdesc 普通, 内联\n         */\n        type: PropTypes.oneOf(['normal', 'inline']),\n        /**\n         * 大小\n         */\n        size: PropTypes.oneOf(['large', 'medium']),\n        /**\n         * 当前值\n         */\n        value: PropTypes.number,\n        /**\n         * 默认值\n         */\n        defaultValue: PropTypes.number,\n        /**\n         * 是否禁用\n         */\n        disabled: PropTypes.bool,\n        /**\n         * 步长\n         */\n        step: PropTypes.oneOfType([\n            PropTypes.number,\n            PropTypes.string,\n        ]),\n        /**\n         * 保留小数点后位数\n         */\n        precision: PropTypes.number,\n        /**\n         * 用户是否可以输入\n         */\n        editable: PropTypes.bool,\n        /**\n         * 自动焦点\n         */\n        autoFocus: PropTypes.bool,\n        /**\n         * 数值被改变的事件\n         * @param {Number} value 数据\n         * @param {Event} e DOM事件对象\n         */\n        onChange: PropTypes.func,\n        /**\n         * 键盘按下\n         */\n        onKeyDown: PropTypes.func,\n        /**\n         * 焦点获得\n         */\n        onFocus: PropTypes.func,\n        /**\n         * 焦点失去\n         */\n        onBlur: PropTypes.func,\n        /**\n         * 数值订正后的回调\n         * @param {Object} obj {currentValue,oldValue:String}\n         */\n        onCorrect: PropTypes.func,\n        /**\n         * 最大值\n         */\n        max: PropTypes.number,\n        /**\n         * 最小值\n         */\n        min: PropTypes.number,\n        /**\n         * 自定义class\n         */\n        className: PropTypes.string,\n        /**\n         * 自定义内联样式\n         */\n        style: PropTypes.object,\n        state: PropTypes.oneOf(['error']),\n\n        /**\n         * 格式化当前值\n         * @param {Number} value\n         * @return {String|Number}\n         */\n        format: PropTypes.func,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        max: Infinity,\n        min: -Infinity,\n        type: 'normal',\n        size: 'medium',\n        step: 1,\n        style: {},\n        precision: 0,\n        editable: true,\n        onChange: func.noop,\n        onKeyDown: func.noop,\n        onBlur: func.noop,\n        onCorrect: func.noop,\n    };\n\n    constructor(props) {\n        super(props);\n\n        let value;\n        if ('value' in props) {\n            value = props.value;\n        } else {\n            value = props.defaultValue;\n        }\n\n        this.state = {\n            value: typeof value === 'undefined' ? '' : value,\n            hasFocused: false,\n        };\n    }\n\n    componentWillReceiveProps(nextProps) {\n        if ('value' in nextProps) {\n            this.setState({\n                value: nextProps.value === undefined ? '' : nextProps.value,\n            });\n        }\n    }\n\n    onChange(value, e) {\n        if (this.props.editable === true) {\n            value = value.trim();\n            // ignore space\n            if (this.state.value === value) {\n                return;\n            }\n\n            // in case of autoCorrect ('0.'=>0, '0.0'=>0) , we have these steps\n            if (value) {\n                // ignore when input start form '-'\n                if (value === '-' || this.state.value === '-') {\n                    this.setState({\n                        value\n                    });\n                    return;\n                }\n                // ignore when next value = prev value.\n                // ps: Number('0.')=0 ; Number('0.0')=0;\n                // but take care of Number('')=0;\n                if (Number(this.state.value) === Number(value)) {\n                    this.setState({\n                        value\n                    });\n                    return;\n                }\n                // ignore when value < min (because number is inputted one by one)\n                if (!isNaN(value) && Number(value) < this.props.min) {\n                    this.setState({\n                        value\n                    });\n                    return;\n                }\n            }\n\n            this.setInputValue(value, e);\n        }\n    }\n\n    /**\n     * @param {Float} currentValue correct value\n     * @param {String} oldValue input value\n     */\n    onCorrect(currentValue, oldValue) {\n        this.props.onCorrect({\n            currentValue,\n            oldValue\n        });\n    }\n\n    onKeyDown(e, ...args) {\n        if (e.keyCode === 38) {\n            this.up(e);\n        } else if (e.keyCode === 40) {\n            this.down(e);\n        }\n        this.props.onKeyDown(e, ...args);\n    }\n\n    onFocus(e, ...args) {\n        const { onFocus } = this.props;\n        this.setFocus(true);\n        onFocus && onFocus(e, ...args);\n    }\n\n    onBlur(e, ...args) {\n        const value = this.getCurrentValidValue(e.target.value.trim());\n        if (this.state.value !== value) {\n            this.setValue(value, e);\n        }\n        this.setFocus(false);\n        const { onBlur } = this.props;\n        onBlur && onBlur(e, ...args);\n    }\n\n    getCurrentValidValue(value) {\n        let val = value;\n        const props = this.props;\n        if (val === '') {\n            val = '';\n        } else if (!isNaN(val)) {\n            val = Number(val);\n            if (val < props.min) {\n                val = props.min;\n            }\n            if (val > props.max) {\n                val = props.max;\n            }\n\n            // precision=2  and input from 1.99 to 1.999, should stay with 1.99 not 2\n            const strValue = `${val}`;\n            const pointPos = strValue.indexOf('.');\n            const cutPos = pointPos + 1 + this.getPrecision();\n            if (pointPos !== -1 && strValue.length > cutPos) {\n                val = Number(strValue.substr(0, cutPos));\n            }\n\n        } else {\n            val = this.state.value;\n        }\n\n        if (`${val}` !== `${value}`) {\n            this.onCorrect(val, value);\n        }\n\n        return val;\n    }\n\n    setValue(v, e, triggerType) {\n        if (!('value' in this.props)) {\n            this.setState({\n                value: v,\n            });\n        }\n\n        this.props.onChange(isNaN(v) || v === '' ? undefined : v, {...e, triggerType});\n    }\n\n    setInputValue(v, e) {\n        const value = this.getCurrentValidValue(v);\n        if (this.state.value !== value) {\n            this.setValue(value, e);\n        }\n    }\n\n    setFocus(status) {\n        const { format } = this.props;\n        // Only trigger `setState` if `format` is settled to avoid unnecessary rendering\n        if (typeof format === 'function') {\n            this.setState({\n                hasFocused: status,\n            });\n        }\n    }\n\n    getPrecision() {\n        const props = this.props;\n        const stepString = props.step.toString();\n        if (stepString.indexOf('e-') >= 0) {\n            return parseInt(stepString.slice(stepString.indexOf('e-')), 10);\n        }\n        let precision = 0;\n        if (stepString.indexOf('.') >= 0) {\n            precision = stepString.length - stepString.indexOf('.') - 1;\n        }\n\n        return Math.max(precision, this.props.precision);\n    }\n\n    getPrecisionFactor() {\n        const precision = this.getPrecision();\n        return Math.pow(10, precision);\n    }\n\n    upStep(val) {\n        const {step, min} = this.props;\n        const precisionFactor = this.getPrecisionFactor();\n        let result;\n        if (typeof val === 'number') {\n            result = (precisionFactor * val + precisionFactor * step) / precisionFactor;\n        } else {\n            result = min === -Infinity ? step : min;\n        }\n        return result;\n    }\n\n    downStep(val) {\n        const {step, min} = this.props;\n        const precisionFactor = this.getPrecisionFactor();\n        let result;\n        if (typeof val === 'number') {\n            result = (precisionFactor * val - precisionFactor * step) / precisionFactor;\n\n            // in chrome browser: 0.3 - 0.2 = 0.09999999999, we should creact to 0.1\n            const precision = this.getPrecision();\n            if (precision > 0) {\n                result = Number(Number(result).toFixed(precision));\n            }\n        } else {\n            result = min === -Infinity ? -step : min;\n        }\n        return result;\n    }\n\n    step(type, e) {\n        if (e) {\n            e.preventDefault();\n        }\n        const {disabled, min, max} = this.props;\n        if (disabled) {\n            return;\n        }\n        const value = this.state.value;\n        if (isNaN(value)) {\n            return;\n        }\n        const val = this[`${type}Step`](value);\n        if (val > max || val < min) {\n            return;\n        }\n        this.setValue(val, e, type);\n    }\n\n    down(e) {\n        this.step('down', e);\n    }\n\n    up(e) {\n        this.step('up', e);\n    }\n\n    renderValue() {\n        const { value, hasFocused } = this.state;\n        const { format } = this.props;\n        return (typeof format === 'function' && !hasFocused) ? format(value) : value;\n    }\n\n    focus() {\n        this.inputRef.getInstance().focus();\n    }\n\n    saveInputRef(ref) {\n        this.inputRef = ref;\n    }\n\n    render() {\n        const {type, prefix, disabled, style, className, size, max, min, autoFocus, editable, state} = this.props;\n\n        const prefixCls = `${prefix}number-picker`;\n\n        const cls = classNames({\n            [prefixCls]: true,\n            [`${prefixCls}-${this.props.type}`]: this.props.type,\n            [`${prefix}${size}`]: true,\n            [className]: className,\n        });\n\n        let upDisabled = false;\n        let downDisabled = false;\n        const value = this.state.value;\n        if (!isNaN(value)) {\n            const val = Number(value);\n            if (val >= max) {\n                upDisabled = true;\n            }\n            if (val <= min) {\n                downDisabled = true;\n            }\n        }\n\n        let innerAfter = null, innerAfterClassName = null, addonBefore = null, addonAfter = null;\n        if (type === 'normal') {\n            innerAfter = ([\n                <Button disabled={disabled || upDisabled} onClick={this.up.bind(this)} key=\"0\">\n                    <Icon size=\"xxs\" type=\"arrow-up\"/>\n                </Button>,\n                <Button disabled={disabled || downDisabled} onClick={this.down.bind(this)} key=\"1\">\n                    <Icon size=\"xxs\" type=\"arrow-down\"/>\n                </Button>\n            ]);\n            innerAfterClassName = `${prefixCls}-handler`;\n        } else {\n            addonBefore = (\n                <Button size={size} disabled={disabled || downDisabled} onClick={this.down.bind(this)}>\n                    <Icon type=\"minus\" size=\"xs\"/>\n                </Button>\n            );\n            addonAfter = (\n                <Button size={size} disabled={disabled || upDisabled} onClick={this.up.bind(this)}>\n                    <Icon type=\"add\" size=\"xs\"/>\n                </Button>\n            );\n        }\n\n        const others = obj.pickOthers(NumberPicker.propTypes, this.props);\n        const dataAttrs = obj.pickAttrsWith(this.props, 'data-');\n        return (<span className={cls} style={style} {...dataAttrs}>\n            <Input\n                {...others}\n                state={state === 'error' ? 'error' : null}\n                onBlur={this.onBlur.bind(this)}\n                onFocus={this.onFocus.bind(this)}\n                onKeyDown={this.onKeyDown.bind(this)}\n                autoFocus={autoFocus}\n                readOnly={!editable}\n                value={this.renderValue()}\n                disabled={disabled}\n                size={size}\n                onChange={this.onChange.bind(this)}\n                ref={this.saveInputRef.bind(this)}\n                innerAfter={innerAfter}\n                innerAfterClassName={innerAfterClassName}\n                addonBefore={addonBefore}\n                addonAfter={addonAfter}\n            />\n        </span>);\n    }\n}\n\nexport default ConfigProvider.config(NumberPicker);"
    },
    "2": {
        "bug_file": "src/util/string.js",
        "compressed": "NO",
        "line_numbers": 20,
        "compressed_line_numbers": 20,
        "compressed_bug_file_content": "/**\n * 将字符串转化为驼峰式写法\n * @param  {String} str 例：-webkit-transition\n * @return {String}     例：WebkitTransition\n */\nexport function camelcase (str) {\n    if (!/-/.test(str)) {\n        return str || '';\n    }\n    return str.toLowerCase().replace(/-([a-z])/g, ($0, $1) => $1.toUpperCase());\n}\n\n/**\n * 将驼峰式字符串转化为连字符写法\n * @param  {String} str 例：WebkitTransition\n * @return {String}     例：-webkit-transition\n */\nexport function hyphenate (str) {\n    return str.replace(/([A-Z])/g, $0 => `-${$0.toLowerCase()}`);\n}"
    }
}