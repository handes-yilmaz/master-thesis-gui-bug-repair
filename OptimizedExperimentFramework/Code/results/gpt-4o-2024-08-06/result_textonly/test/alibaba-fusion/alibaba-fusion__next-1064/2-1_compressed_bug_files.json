{
    "1": {
        "bug_file": "src/field/index.js",
        "compressed": "YES",
        "line_numbers": 796,
        "compressed_line_numbers": 170,
        "compressed_bug_file_content": "import ReactDOM from 'react-dom';\nimport { log, func } from '../util';\nimport Validate from '../validate';\n\nimport {\n\n\n        // holds constructor values. Used for setting field defaults on init if no other value or initValue is passed.\n        // Also used caching values when using `parseName: true` before a field is initialized\n\n\n    /**\n     * Controlled Component\n     * @param {String} name\n     * @param {Object} fieldOption\n     * @returns {Object} {value, onChange}\n     */\n\n\n            // here use typeof, in case of defaultValue={0}\n\n\n        // Controlled Component, should alwasy equal props.value\n\n\n            // When rerendering set the values from props.value\n\n\n        // should get value from this.values\n        /**\n         * a new field (value not in field)\n         * step 1: get value from this.values\n         * step 2: from defaultValue\n         */\n\n\n        // Component props\n\n\n            // trigger map\n\n\n            // validate hook\n\n\n        // onChange hack\n\n\n    /**\n     * event on props\n     * props.onChange props.onBlur\n     */\n\n\n    /**\n     * update field.value and validate\n     */\n\n\n        // validate while onChange\n\n\n    /**\n     * ref must always be the same function, or if not it will be triggerd every time.\n     * @param {String} name name of component\n     * @param {String} action key to find ref\n     * @param {Function} fn saveRef\n     */\n\n\n    /**\n     * NOTE: saveRef is async function. it will be called after render\n     * @param {String} name name of component\n     * @param {Function} component ref\n     */\n\n\n            // component with same name (eg: type ? <A name=\"n\"/>:<B name=\"n\"/>)\n            // while type changed, B will render before A unmount. so we should cached value for B\n            // step: render -> B mount -> 1. _saveRef(A, null) -> 2. _saveRef(B, ref) -> render\n            // 1. _saveRef(A, null)\n\n\n            // after destroy, delete data\n\n\n        // 2. _saveRef(B, ref) (eg: same name but different compoent may be here)\n\n\n        // only one time here\n\n\n    /**\n     * validate one Component\n     * @param {String} name name of Component\n     * @param {Array} rule\n     * @param {String} trigger onChange/onBlur/onItemClick/...\n     */\n\n\n    /**\n     * 1. get values by names.\n     * 2. If no names passed, return shallow copy of `field.values`\n     * @param {Array} names\n     */\n\n\n            // NOTE: this is a shallow merge\n            // Ex. we have two values a.b.c=1 ; a.b.d=2, and use setValues({a:{b:{c:3}}}) , then because of shallow merge a.b.d will be lost, we will get only {a:{b:{c:3}}}\n\n\n                    // copy over values that are in this.values\n\n\n                    // if no value then copy values from fieldsMeta to keep initialized component data\n\n\n    /**\n     * Get errors using `getErrors` and format to match the structure of errors returned in field.validate\n     * @param {Array} fieldNames\n     * @return {Object || null} map of inputs and their errors\n     */\n\n\n    /**\n     * validate by trigger\n     * @param {Array} ns names\n     * @param {Function} cb callback after validate\n     */\n\n\n                // clear error\n\n\n                // update error in every Field\n\n\n            // update to success which has no error\n\n\n            // eslint-disable-next-line callback-return\n\n\n    // deprecated. TODO: remove in 2.0 version\n\n\n    /**\n     * splice in a Array\n     * @param {String} keyMatch like name.{index}\n     * @param {Number} startIndex index\n     */\n\n\n        // regex to match field names in the same target array\n\n\n            // is name in the target array?\n\n\n        // should be continuous array\n\n\n                // if parseName=true then parent is an Array object but does not know an element was removed\n                // this manually decrements the array length\n\n\n    //trigger rerender\n\n\nexport default Field;\n"
    },
    "2": {
        "bug_file": "src/field/utils.js",
        "compressed": "NO",
        "line_numbers": 186,
        "compressed_line_numbers": 186,
        "compressed_bug_file_content": "import { isValidElement, cloneElement } from 'react';\n\n/**\n * 从组件事件中获取数据\n * @param e Event或者value\n * @returns value\n */\nexport function getValueFromEvent(e) {\n    // support custom element\n    if (!e || !e.target) {\n        return e;\n    }\n    const { target } = e;\n\n    if (target.type === 'checkbox') {\n        return target.checked;\n    } else if (target.type === 'radio') {\n        //兼容原生radioGroup\n        if (target.value) {\n            return target.value;\n        } else {\n            return target.checked;\n        }\n    }\n    return target.value;\n}\n\nfunction cloneAndAddKey(element) {\n    if (element && isValidElement(element)) {\n        return cloneElement(element, { key: 'error' });\n    }\n    return element;\n}\n\nexport function getErrorStrs(errors) {\n    if (errors) {\n        return errors.map(function(e) {\n            const message = e.message || e;\n            return cloneAndAddKey(message);\n        });\n    }\n    return errors;\n}\n\nexport function getParams(ns, cb) {\n    let names = typeof ns === 'string' ? [ns] : ns;\n    let callback = cb;\n    if (cb === undefined && typeof names === 'function') {\n        callback = names;\n        names = undefined;\n    }\n    return {\n        names,\n        callback,\n    };\n}\n\nconst setInWithPath = (state, value, path, pathIndex) => {\n    if (pathIndex >= path.length) {\n        return value;\n    }\n\n    const first = path[pathIndex];\n    const next = setInWithPath(\n        state && state[first],\n        value,\n        path,\n        pathIndex + 1\n    );\n\n    if (!state) {\n        const initialized = isNaN(first) ? {} : [];\n        initialized[first] = next;\n        return initialized;\n    }\n\n    if (Array.isArray(state)) {\n        const copy = [].concat(state);\n        copy[first] = next;\n        return copy;\n    }\n\n    return Object.assign({}, state, {\n        [first]: next,\n    });\n};\n\nexport function setIn(state, name, value) {\n    return setInWithPath(\n        state,\n        value,\n        name\n            .replace(/\\[/, '.')\n            .replace(/\\]/, '')\n            .split('.'),\n        0\n    );\n}\n\nexport function getIn(state, name) {\n    if (!state) {\n        return state;\n    }\n\n    const path = name\n        .replace(/\\[/, '.')\n        .replace(/\\]/, '')\n        .split('.');\n    const length = path.length;\n    if (!length) {\n        return undefined;\n    }\n\n    let result = state;\n    for (let i = 0; i < length && !!result; ++i) {\n        result = result[path[i]];\n    }\n\n    return result;\n}\n\nexport function deleteIn(state, name) {\n    if (!state) {\n        return;\n    }\n\n    const path = name\n        .replace(/\\[/, '.')\n        .replace(/\\]/, '')\n        .split('.');\n    const length = path.length;\n    if (!length) {\n        return state;\n    }\n\n    let result = state;\n    for (let i = 0; i < length && !!result; ++i) {\n        if (i === length - 1) {\n            delete result[path[i]];\n        } else {\n            result = result[path[i]];\n        }\n    }\n\n    return state;\n}\n\nfunction validateMap(rulesMap, rule, defaultTrigger) {\n    const nrule = Object.assign({}, rule);\n\n    if (!nrule.trigger) {\n        nrule.trigger = [defaultTrigger];\n    }\n\n    if (typeof nrule.trigger === 'string') {\n        nrule.trigger = [nrule.trigger];\n    }\n\n    for (let i = 0; i < nrule.trigger.length; i++) {\n        const trigger = nrule.trigger[i];\n\n        if (trigger in rulesMap) {\n            rulesMap[trigger].push(nrule);\n        } else {\n            rulesMap[trigger] = [nrule];\n        }\n    }\n\n    delete nrule.trigger;\n}\n\n/**\n * 提取rule里面的trigger并且做映射\n * @param  {Array} rules   规则\n * @param  {String} defaultTrigger 默认触发\n * @return {Object} {onChange:rule1, onBlur: rule2}\n */\nexport function mapValidateRules(rules, defaultTrigger) {\n    const rulesMap = {};\n\n    rules.forEach(rule => {\n        validateMap(rulesMap, rule, defaultTrigger);\n    });\n\n    return rulesMap;\n}"
    },
    "3": {
        "bug_file": "src/form/index.jsx",
        "compressed": "NO",
        "line_numbers": 36,
        "compressed_line_numbers": 36,
        "compressed_bug_file_content": "import ConfigProvider from '../config-provider';\nimport Form from './form';\nimport Item from './item';\nimport Submit from './submit';\nimport Reset from './reset';\nimport Error from './error';\n\nForm.Item = ConfigProvider.config(Item, {\n    transform: /* istanbul ignore next */ (props, deprecated) => {\n        if ('validateStatus' in props) {\n            deprecated('validateStatus', 'validateState', 'Form.Item');\n\n            const { validateStatus, ...others } = props;\n            props = { validateState: validateStatus, ...others };\n        }\n\n        return props;\n    },\n});\nForm.Submit = Submit;\nForm.Reset = Reset;\nForm.Error = Error;\n\nexport default ConfigProvider.config(Form, {\n    transform: /* istanbul ignore next */ (props, deprecated) => {\n        if ('direction' in props) {\n            deprecated('direction', 'inline', 'Form');\n            const { direction, ...others } = props;\n            if (direction === 'hoz') {\n                props = { inline: true, ...others };\n            }\n        }\n\n        return props;\n    },\n});"
    },
    "4": {
        "bug_file": "src/form/item.jsx",
        "compressed": "NO",
        "line_numbers": 413,
        "compressed_line_numbers": 413,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport Grid from '../grid';\nimport { obj } from '../util';\nimport Error from './error';\nimport { getFieldInitCfg } from './enhance';\n\nconst { Row, Col } = Grid;\n\n/** Form.Item\n *  @description 手动传递了 wrapCol labelCol 会使用 Grid 辅助布局; labelAlign='top' 会强制禁用 Grid\n *  @order 1\n */\nexport default class Item extends React.Component {\n    static propTypes = {\n        /**\n         * 样式前缀\n         */\n        prefix: PropTypes.string,\n        rtl: PropTypes.bool,\n        /**\n         * label 标签的文本\n         */\n        label: PropTypes.node,\n        /**\n         * label 标签布局，通 `<Col>` 组件，设置 span offset 值，如 {span: 8, offset: 16}，该项仅在垂直表单有效\n         */\n        labelCol: PropTypes.object,\n        /**\n         * 需要为输入控件设置布局样式时，使用该属性，用法同 labelCol\n         */\n        wrapperCol: PropTypes.object,\n        /**\n         * 自定义提示信息，如不设置，则会根据校验规则自动生成.\n         */\n        help: PropTypes.node,\n        /**\n         * 额外的提示信息，和 help 类似，当需要错误信息和提示文案同时出现时，可以使用这个。 位于错误信息后面\n         */\n        extra: PropTypes.node,\n        /**\n         * 校验状态，如不设置，则会根据校验规则自动生成\n         * @enumdesc 失败, 成功, 校验中\n         */\n        validateState: PropTypes.oneOf(['error', 'success', 'loading']),\n        /**\n         * 配合 validateState 属性使用，是否展示 success/loading 的校验状态图标, 目前只有Input支持\n         */\n        hasFeedback: PropTypes.bool, //TODO: hasFeedback => validateStatus=[error,success,loading]\n        /**\n         * 自定义内联样式\n         */\n        style: PropTypes.object,\n        id: PropTypes.string,\n        /**\n         * node 或者 function(values)\n         */\n        children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),\n        /**\n         * 单个 Item 的 size 自定义，优先级高于 Form 的 size, 并且当组件与 Item 一起使用时，组件自身设置 size 属性无效。\n         */\n        size: PropTypes.oneOf(['large', 'small', 'medium']),\n        /**\n         * 标签的位置\n         * @enumdesc 上, 左, 内\n         */\n        labelAlign: PropTypes.oneOf(['top', 'left', 'inset']),\n        /**\n         * 标签的左右对齐方式\n         * @enumdesc 左, 右\n         */\n        labelTextAlign: PropTypes.oneOf(['left', 'right']),\n        /**\n         * 扩展class\n         */\n        className: PropTypes.string,\n        /**\n         * [表单校验] 不能为空\n         */\n        required: PropTypes.bool,\n        /**\n         * required 的星号是否显示\n         */\n        asterisk: PropTypes.bool,\n        /**\n         * required 自定义错误信息\n         */\n        requiredMessage: PropTypes.string,\n        /**\n         * required 自定义触发方式\n         */\n        requiredTrigger: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.array,\n        ]),\n        /**\n         * [表单校验] 最小值\n         */\n        min: PropTypes.number,\n        /**\n         * [表单校验] 最大值\n         */\n        max: PropTypes.number,\n        /**\n         * min/max 自定义错误信息\n         */\n        minmaxMessage: PropTypes.string,\n        /**\n         * min/max 自定义触发方式\n         */\n        minmaxTrigger: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n        /**\n         * [表单校验] 字符串最小长度 / 数组最小个数\n         */\n        minLength: PropTypes.number,\n        /**\n         * [表单校验] 字符串最大长度 / 数组最大个数\n         */\n        maxLength: PropTypes.number,\n        /**\n         * minLength/maxLength 自定义错误信息\n         */\n        minmaxLengthMessage: PropTypes.string,\n        /**\n         * minLength/maxLength 自定义触发方式\n         */\n        minmaxLengthTrigger: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.array,\n        ]),\n        /**\n         * [表单校验] 字符串精确长度 / 数组精确个数\n         */\n        length: PropTypes.number,\n        /**\n         * length 自定义错误信息\n         */\n        lengthMessage: PropTypes.string,\n        /**\n         * length 自定义触发方式\n         */\n        lengthTrigger: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n        /**\n         * 正则校验\n         */\n        pattern: PropTypes.any,\n        /**\n         * pattern 自定义错误信息\n         */\n        patternMessage: PropTypes.string,\n        /**\n         * pattern 自定义触发方式\n         */\n        patternTrigger: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.array,\n        ]),\n        /**\n         * [表单校验] 四种常用的 pattern\n         */\n        format: PropTypes.oneOf(['number', 'email', 'url', 'tel']),\n        /**\n         * format 自定义错误信息\n         */\n        formatMessage: PropTypes.string,\n        /**\n         * format 自定义触发方式\n         */\n        formatTrigger: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n        /**\n         * [表单校验] 自定义校验函数\n         */\n        validator: PropTypes.func,\n        /**\n         * validator 自定义触发方式\n         */\n        validatorTrigger: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.array,\n        ]),\n        /**\n         * 是否修改数据时自动触发校验\n         */\n        autoValidate: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        hasFeedback: false,\n    };\n\n    static contextTypes = {\n        _formField: PropTypes.object,\n        _formSize: PropTypes.oneOf(['large', 'small', 'medium']),\n    };\n\n    static _typeMark = 'form_item';\n\n    /**\n     * 从子元素里面提取表单组件\n     */\n    getNames() {\n        const children = React.Children.toArray(this.props.children);\n        return children\n            .filter(c => {\n                return c.props && ('name' in c.props || 'data-meta' in c.props);\n            })\n            .map(c => {\n                return c.props.name || c.props.id;\n            });\n    }\n\n    getHelper() {\n        const help = this.props.help;\n        const _formField = this.context._formField;\n\n        return (\n            <Error\n                name={help === undefined ? this.getNames() : undefined}\n                field={_formField}\n            >\n                {help}\n            </Error>\n        );\n    }\n\n    getState() {\n        const { validateState } = this.props;\n        if (validateState) {\n            return validateState;\n        }\n\n        if (this.context._formField) {\n            const { getState } = this.context._formField;\n            const names = this.getNames();\n            if (!names.length) {\n                return '';\n            }\n\n            // get first name\n            return getState(names[0]);\n        }\n\n        return undefined;\n    }\n\n    getSize() {\n        return this.props.size || this.context._formSize;\n    }\n\n    getItemLabel() {\n        const {\n            id,\n            required,\n            asterisk = required,\n            label,\n            labelCol,\n            wrapperCol,\n            prefix,\n            labelAlign,\n            labelTextAlign,\n        } = this.props;\n\n        if (!label) {\n            return null;\n        }\n\n        const ele = (\n            <label\n                htmlFor={id || this.getNames()[0]}\n                required={asterisk}\n                key=\"label\"\n            >\n                {label}\n            </label>\n        );\n\n        const cls = classNames({\n            [`${prefix}form-item-label`]: true,\n            [`${prefix}left`]: labelTextAlign === 'left',\n        });\n\n        if ((wrapperCol || labelCol) && labelAlign !== 'top') {\n            return (\n                <Col {...labelCol} className={cls}>\n                    {ele}\n                </Col>\n            );\n        }\n\n        return <div className={cls}>{ele}</div>;\n    }\n\n    getItemWrapper() {\n        const {\n            hasFeedback,\n            labelCol,\n            wrapperCol,\n            children,\n            extra,\n            labelAlign,\n            prefix,\n        } = this.props;\n\n        const state = this.getState();\n\n        const childrenProps = { size: this.getSize() };\n        if (state && (state === 'error' || hasFeedback)) {\n            childrenProps.state = state;\n        }\n\n        if (labelAlign === 'inset') {\n            childrenProps.label = this.getItemLabel();\n        }\n\n        let childrenNode = children;\n        if (typeof children === 'function' && this.context._formField) {\n            childrenNode = children(this.context._formField.getValues());\n        }\n\n        const ele = React.Children.map(childrenNode, child => {\n            if (\n                child &&\n                typeof child.type === 'function' &&\n                child.type._typeMark !== 'form_item' &&\n                child.type._typeMark !== 'form_error'\n            ) {\n                let extraProps = childrenProps;\n                if (\n                    this.context._formField &&\n                    'name' in child.props &&\n                    !('data-meta' in child.props)\n                ) {\n                    extraProps = this.context._formField.init(\n                        child.props.name,\n                        {\n                            ...getFieldInitCfg(\n                                this.props,\n                                child.type.displayName\n                            ),\n                            props: { ...child.props, ref: child.ref },\n                        },\n                        childrenProps\n                    );\n                } else {\n                    extraProps = Object.assign({}, child.props, extraProps);\n                }\n\n                return React.cloneElement(child, extraProps);\n            }\n\n            return child;\n        });\n\n        const help = this.getHelper();\n\n        if ((wrapperCol || labelCol) && labelAlign !== 'top') {\n            return (\n                <Col\n                    {...wrapperCol}\n                    className={`${prefix}form-item-control`}\n                    key=\"item\"\n                >\n                    {ele} {help} {extra}\n                </Col>\n            );\n        }\n\n        return (\n            <div className={`${prefix}form-item-control`}>\n                {ele} {help} {extra}\n            </div>\n        );\n    }\n\n    render() {\n        const {\n            className,\n            labelAlign,\n            style,\n            prefix,\n            wrapperCol,\n            labelCol,\n        } = this.props;\n        const state = this.getState();\n        const size = this.getSize();\n\n        const itemClassName = classNames({\n            [`${prefix}form-item`]: true,\n            [`${prefix}${labelAlign}`]: labelAlign,\n            [`has-${state}`]: !!state,\n            [`${prefix}${size}`]: !!size,\n            [`${className}`]: !!className,\n        });\n\n        // 垂直模式并且左对齐才用到\n        const Tag =\n            (wrapperCol || labelCol) && labelAlign !== 'top' ? Row : 'div';\n        const label = labelAlign === 'inset' ? null : this.getItemLabel();\n\n        return (\n            <Tag\n                {...obj.pickOthers(Item.propTypes, this.props)}\n                className={itemClassName}\n                style={style}\n            >\n                {label}\n                {this.getItemWrapper()}\n            </Tag>\n        );\n    }\n}"
    }
}