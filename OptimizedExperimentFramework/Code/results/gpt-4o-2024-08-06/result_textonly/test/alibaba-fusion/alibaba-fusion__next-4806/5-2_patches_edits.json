{
    "1/1": {
        "components/cascader-select/cascader-select.tsx": [
            {
                "SEARCH": [
                    "handleChange(value: string[], data: CascaderSelectDataItem[], extra: Extra) {",
                    "const { multiple, onChange } = this.props;",
                    "const { searchValue, value: stateValue } = this.state;",
                    "",
                    "const st = {} as CascaderSelectState;",
                    "",
                    "if (multiple && stateValue && Array.isArray(stateValue)) {",
                    "const noExistedValues = stateValue.filter(v => !this._v2n[v]);",
                    "",
                    "if (noExistedValues.length > 0) {",
                    "value = value.filter(v => {",
                    "return !(noExistedValues.indexOf(v) >= 0);",
                    "});",
                    "}",
                    "",
                    "value = [...noExistedValues, ...value];",
                    "// onChange 中的 data 参数也应该保留不存在的 value 的数据",
                    "// 在 dataSource 异步加载的情况下，会出现 value 重复的现象，需要去重",
                    "data = [",
                    "...noExistedValues.map(v => this._valueDataCache[v]).filter(v => v),",
                    "...data,",
                    "].filter((current, index, arr) => {",
                    "return index === arr.indexOf(current);",
                    "});",
                    "// 更新缓存",
                    "this.refreshValueDataCache(value);",
                    "}",
                    "",
                    "if (!('value' in this.props)) {",
                    "st.value = value;",
                    "}",
                    "if (!multiple && searchValue) {",
                    "st.searchValue = '';",
                    "}",
                    "if (Object.keys(st).length) {",
                    "this.setState(st);",
                    "}",
                    "",
                    "if (onChange) {",
                    "onChange(value, data, extra);",
                    "}",
                    "",
                    "if (searchValue && this.select) {",
                    "this.select.handleSearchClear();"
                ],
                "REPLACE": [
                    "    handleChange(value: string[], data: CascaderSelectDataItem[], extra: Extra) {",
                    "        const { multiple, onChange } = this.props;",
                    "        const { searchValue, value: stateValue } = this.state;",
                    "",
                    "        const st = {} as CascaderSelectState;",
                    "",
                    "        if (multiple && stateValue && Array.isArray(stateValue)) {",
                    "            const noExistedValues = stateValue.filter(v => !this._v2n[v]);",
                    "",
                    "            if (noExistedValues.length > 0) {",
                    "                value = value.filter(v => {",
                    "                    return !(noExistedValues.indexOf(v) >= 0);",
                    "                });",
                    "            }",
                    "",
                    "            value = [...noExistedValues, ...value];",
                    "            // onChange 中的 data 参数也应该保留不存在的 value 的数据",
                    "            // 在 dataSource 异步加载的情况下，会出现 value 重复的现象，需要去重",
                    "            data = [",
                    "                ...noExistedValues.map(v => this._valueDataCache[v]).filter(v => v),",
                    "                ...data,",
                    "            ].filter((current, index, arr) => {",
                    "                return index === arr.indexOf(current);",
                    "            });",
                    "            // 更新缓存",
                    "            this.refreshValueDataCache(value);",
                    "        }",
                    "",
                    "        if (!('value' in this.props)) {",
                    "            st.value = value;",
                    "        }",
                    "        if (!multiple && searchValue) {",
                    "            st.searchValue = '';",
                    "        }",
                    "        if (Object.keys(st).length) {",
                    "            this.setState(st);",
                    "        }",
                    "",
                    "        if (onChange) {",
                    "            onChange(value, data, extra);",
                    "        }",
                    "",
                    "        // Clear search value if all items are selected",
                    "        if (multiple && value.length === this.props.dataSource.length) {",
                    "            this.setState({ searchValue: '' });",
                    "        }",
                    "",
                    "        if (searchValue && this.select) {",
                    "            this.select.handleSearchClear();"
                ]
            }
        ]
    }
}