{
    "components/cascader-select/cascader-select.tsx": [
        "...",
        "    CascaderSelectDataItem,",
        "    CascaderSelectProps,",
        "    CascaderSelectState,",
        "    CascaderSelectVisibleChangeType,",
        "} from './types';",
        "import type { Popup } from '../overlay';",
        "",
        "const { bindCtx } = func;",
        "const { pickOthers } = obj;",
        "const { getStyle } = dom;",
        "",
        "type normalizeValueResult<T> = T extends NonNullable<T>",
        "    ? T extends unknown[]",
        "        ? NonNullable<T>",
        "        : [NonNullable<T>]",
        "    : [];",
        "",
        "const normalizeValue = <T,>(value: T): normalizeValueResult<T> => {",
        "    if (value) {",
        "        if (Array.isArray(value)) {",
        "            return value as normalizeValueResult<T>;",
        "        }",
        "",
        "        return [value] as normalizeValueResult<T>;",
        "    }",
        "",
        "    return [] as normalizeValueResult<T>;",
        "};",
        "",
        "export type CascaderSelectPropsWithDefault = ClassPropsWithDefault<",
        "    CascaderSelectProps,",
        "    typeof CascaderSelect.defaultProps",
        ">;",
        "",
        "/**",
        " * CascaderSelect",
        " */",
        "class CascaderSelect extends Component<CascaderSelectProps, CascaderSelectState> {",
        "    static displayName = 'CascaderSelect';",
        "    static propTypes = {",
        "        prefix: PropTypes.string,",
        "        pure: PropTypes.bool,",
        "        className: PropTypes.string,",
        "        size: PropTypes.oneOf(['small', 'medium', 'large']),",
        "        placeholder: PropTypes.string,",
        "        disabled: PropTypes.bool,",
        "        hasArrow: PropTypes.bool,",
        "        hasBorder: PropTypes.bool,",
        "        hasClear: PropTypes.bool,",
        "        label: PropTypes.node,",
        "        readOnly: PropTypes.bool,",
        "        dataSource: PropTypes.arrayOf(PropTypes.object),",
        "        defaultValue: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),",
        "        value: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),",
        "        onChange: PropTypes.func,",
        "        defaultExpandedValue: PropTypes.arrayOf(PropTypes.string),",
        "        expandedValue: PropTypes.arrayOf(PropTypes.string),",
        "        expandTriggerType: PropTypes.oneOf(['click', 'hover']),",
        "        onExpand: PropTypes.func,",
        "        useVirtual: PropTypes.bool,",
        "        multiple: PropTypes.bool,",
        "        changeOnSelect: PropTypes.bool,",
        "        canOnlyCheckLeaf: PropTypes.bool,",
        "        checkStrictly: PropTypes.bool,",
        "        listStyle: PropTypes.object,",
        "        listClassName: PropTypes.string,",
        "        displayRender: PropTypes.func,",
        "        itemRender: PropTypes.func,",
        "        showSearch: PropTypes.bool,",
        "        filter: PropTypes.func,",
        "        onSearch: PropTypes.func,",
        "        resultRender: PropTypes.func,",
        "        resultAutoWidth: PropTypes.bool,",
        "        notFoundContent: PropTypes.node,",
        "        locale: PropTypes.object,",
        "        loadData: PropTypes.func,",
        "        header: PropTypes.node,",
        "        footer: PropTypes.node,",
        "        defaultVisible: PropTypes.bool,",
        "        visible: PropTypes.bool,",
        "        onVisibleChange: PropTypes.func,",
        "        popupStyle: PropTypes.object,",
        "        popupClassName: PropTypes.string,",
        "        popupContainer: PropTypes.any,",
        "        popupProps: PropTypes.object,",
        "        followTrigger: PropTypes.bool,",
        "        isPreview: PropTypes.bool,",
        "        renderPreview: PropTypes.func,",
        "        immutable: PropTypes.bool,",
        "    };",
        "",
        "    static defaultProps = {",
        "        prefix: 'next-',",
        "        pure: false,",
        "        size: 'medium',",
        "        disabled: false,",
        "        hasArrow: true,",
        "        hasBorder: true,",
        "        hasClear: false,",
        "        dataSource: [],",
        "        defaultValue: null,",
        "        expandTriggerType: 'click',",
        "        onExpand: () => {},",
        "        useVirtual: false,",
        "        multiple: false,",
        "        changeOnSelect: false,",
        "        canOnlyCheckLeaf: false,",
        "        checkStrictly: false,",
        "        showSearch: false,",
        "        filter: (searchValue: string, path: Array<{ label: string; value: string }>) => {",
        "            return path.some(",
        "                item =>",
        "                    String(item.label).toLowerCase().indexOf(String(searchValue).toLowerCase()) > -1",
        "            );",
        "        },",
        "        resultRender: (searchValue: string, path: Array<{ label: string; value: string }>) => {",
        "            const parts: ReactNode[] = [];",
        "            path.forEach((item, i) => {",
        "                const reExp = searchValue.replace(/[-.+*?^$()[\\]{}|\\\\]/g, v => `\\\\${v}`);",
        "",
        "                const re = new RegExp(reExp, 'gi');",
        "                const others = item.label.split(re);",
        "                const matches = item.label.match(re);",
        "",
        "                others.forEach((other, j) => {",
        "                    if (other) {",
        "                        parts.push(other);",
        "                    }",
        "                    if (j < others.length - 1) {",
        "                        parts.push(<em key={`${i}-${j}`}>{matches![j]}</em>);",
        "                    }",
        "                });",
        "                if (i < path.length - 1) {",
        "                    parts.push(' / ');",
        "                }",
        "            });",
        "            return <span>{parts}</span>;",
        "        },",
        "        resultAutoWidth: true,",
        "        defaultVisible: false,",
        "        onVisibleChange: () => {},",
        "        popupProps: {},",
        "        immutable: false,",
        "        locale: zhCN.Select,",
        "    };",
        "",
        "    readonly props: CascaderSelectPropsWithDefault;",
        "    _valueDataCache: Record<string, CascaderSelectDataItem>;",
        "    _v2n: Record<string, CascaderSelectDataItem>;",
        "    _p2n: Record<string, CascaderSelectDataItem>;",
        "    select: InstanceType<typeof Select>;",
        "    cascader: InstanceType<typeof Cascader>;",
        "    popup: InstanceType<typeof Popup>;",
        "    cascaderHeight: string | number;",
        "",
        "    constructor(props: CascaderSelectProps) {",
        "        super(props);",
        "",
        "        this.state = {",
        "            value: normalizeValue('value' in props ? props.value : props.defaultValue),",
        "            searchValue: '',",
        "            visible: typeof props.visible === 'undefined' ? props.defaultVisible! : props.visible,",
        "        };",
        "",
        "        // 缓存选中值数据",
        "        this._valueDataCache = {};",
        "",
        "        bindCtx(this, [",
        "            'handleVisibleChange',",
        "            'handleAfterOpen',",
        "            'handleSelect',",
        "            'handleChange',",
        "            'handleClear',",
        "            'handleRemove',",
        "            'handleSearch',",
        "            'getPopup',",
        "            'saveSelectRef',",
        "            'saveCascaderRef',",
        "            'handleKeyDown',",
        "        ]);",
        "    }",
        "",
        "    static getDerivedStateFromProps(props: CascaderSelectPropsWithDefault) {",
        "        const st: Partial<CascaderSelectState> = {};",
        "",
        "        if ('value' in props) {",
        "            st.value = normalizeValue(props.value);",
        "        }",
        "        if ('visible' in props) {",
        "            st.visible = props.visible;",
        "        }",
        "",
        "        return st;",
        "    }",
        "",
        "    /**",
        "     * 使组件获得焦点",
        "     * @public",
        "     */",
        "    focus() {",
        "        this.select && this.select.focusInput();",
        "    }",
        "",
        "    updateCache(dataSource: CascaderDataItem[]) {",
        "        this._v2n = {};",
        "        this._p2n = {};",
        "        const loop = (data: CascaderDataItem[], prefix = '0') =>",
        "            data.forEach((item, index) => {",
        "                const { value, children } = item;",
        "                const pos = `${prefix}-${index}`;",
        "                this._v2n[value] = this._p2n[pos] = { ...item, pos };",
        "",
        "                if (children && children.length) {",
        "                    loop(children, pos);",
        "                }",
        "            });",
        "",
        "        loop(dataSource);",
        "    }",
        "",
        "    flatValue(value: string[]) {",
        "        const getDepth = (v: string) => {",
        "            const pos = this.getPos(v);",
        "            if (!pos) {",
        "                return 0;",
        "            }",
        "            return pos.split('-').length;",
        "        };",
        "        const newValue = value.slice(0).sort((prev, next) => {",
        "            return getDepth(prev) - getDepth(next);",
        "        });",
        "",
        "        for (let i = 0; i < newValue.length; i++) {",
        "            for (let j = 0; j < newValue.length; j++) {",
        "                if (",
        "                    i !== j &&",
        "                    this.isDescendantOrSelf(this.getPos(newValue[i]), this.getPos(newValue[j]))",
        "                ) {",
        "                    newValue.splice(j, 1);",
        "                    j--;",
        "                }",
        "            }",
        "        }",
        "",
        "        return newValue;",
        "    }",
        "",
        "    isDescendantOrSelf(",
        "        currentPos: string | undefined | null,",
        "        targetPos: string | undefined | null",
        "    ) {",
        "        if (!currentPos || !targetPos) {",
        "            return false;",
        "        }",
        "",
        "        const currentNums = currentPos.split('-');",
        "        const targetNums = targetPos.split('-');",
        "",
        "        return (",
        "            currentNums.length <= targetNums.length &&",
        "            currentNums.every((num, index) => {",
        "                return num === targetNums[index];",
        "            })",
        "        );",
        "    }",
        "",
        "    getValue(pos: string) {",
        "        return this._p2n[pos] ? this._p2n[pos].value : null;",
        "    }",
        "",
        "    getPos(value: string) {",
        "        return this._v2n[value] ? this._v2n[value].pos : null;",
        "    }",
        "",
        "    getData(value: string[]) {",
        "        return value.map(v => this._v2n[v] || this._valueDataCache[v]);",
        "    }",
        "",
        "    getLabelPath(data: CascaderSelectDataItem) {",
        "        const nums = data.pos.split('-');",
        "        return nums.slice(1).reduce(",
        "            (ret, num, index) => {",
        "                const p = nums.slice(0, index + 2).join('-');",
        "                ret.push(this._p2n[p].label);",
        "                return ret;",
        "            },",
        "            [] as CascaderSelectDataItem['label'][]",
        "        );",
        "    }",
        "",
        "    getSingleData(value: string | string[]) {",
        "        if (!value.length) {",
        "            return null;",
        "        }",
        "",
        "        if (Array.isArray(value)) value = value[0];",
        "",
        "        let data = this._v2n[value];",
        "",
        "        if (data) {",
        "            const labelPath = this.getLabelPath(data);",
        "            const displayRender = this.props.displayRender || (labels => labels.join(' / '));",
        "",
        "            data = {",
        "                ...data,",
        "                label: displayRender(labelPath, data),",
        "            };",
        "",
        "            this._valueDataCache[value] = data;",
        "            this.refreshValueDataCache(value);",
        "        } else {",
        "            data = this._valueDataCache[value];",
        "        }",
        "",
        "        return (",
        "            data || {",
        "                value,",
        "            }",
        "        );",
        "    }",
        "",
        "    getMultipleData(value: string[]) {",
        "        if (!value.length) {",
        "            return null;",
        "        }",
        "",
        "        const { checkStrictly, canOnlyCheckLeaf, displayRender } = this.props;",
        "        const flatValue = checkStrictly || canOnlyCheckLeaf ? value : this.flatValue(value);",
        "        let data = flatValue.map(v => {",
        "            let item = this._v2n[v];",
        "",
        "            if (item) {",
        "                this._valueDataCache[v] = item;",
        "            } else {",
        "                item = this._valueDataCache[v];",
        "            }",
        "",
        "            return item || { value: v };",
        "        });",
        "",
        "        if (displayRender) {",
        "            data = data.map(item => {",
        "                if (!item.pos || !(item.value in this._v2n)) {",
        "                    return item;",
        "                }",
        "",
        "                const labelPath = this.getLabelPath(item);",
        "                const newItem = {",
        "                    ...item,",
        "                    label: displayRender(labelPath, item),",
        "                };",
        "",
        "                this._valueDataCache[item.value] = newItem;",
        "",
        "                return newItem;",
        "            });",
        "        }",
        "",
        "        return data;",
        "    }",
        "",
        "    getIndeterminate(value: string[]) {",
        "        const indeterminate: Array<string> = [];",
        "",
        "        const positions: string[] = value.map(this.getPos.bind(this));",
        "        positions.forEach(pos => {",
        "            if (!pos) {",
        "                return false;",
        "            }",
        "            const nums = pos.split('-');",
        "            for (let i = nums.length; i > 2; i--) {",
        "                const parentPos = nums.slice(0, i - 1).join('-');",
        "                const parentValue = this.getValue(parentPos) as string;",
        "                if (indeterminate.indexOf(parentValue) === -1) {",
        "                    indeterminate.push(parentValue);",
        "                }",
        "            }",
        "        });",
        "",
        "        return indeterminate;",
        "    }",
        "",
        "    saveSelectRef(ref: InstanceType<typeof Select>) {",
        "        this.select = ref;",
        "    }",
        "",
        "    saveCascaderRef(ref: InstanceType<typeof Cascader>) {",
        "        this.cascader = ref;",
        "    }",
        "",
        "    completeValue(value: string[]) {",
        "        const newValue = [];",
        "",
        "        const flatValue = this.flatValue(value).reverse();",
        "        const ps = Object.keys(this._p2n);",
        "        for (let i = 0; i < ps.length; i++) {",
        "            for (let j = 0; j < flatValue.length; j++) {",
        "                const v = flatValue[j];",
        "                if (this.isDescendantOrSelf(this.getPos(v), ps[i])) {",
        "                    newValue.push(this.getValue(ps[i]) as string);",
        "                    ps.splice(i, 1);",
        "                    i--;",
        "                    break;",
        "                }",
        "            }",
        "        }",
        "",
        "        return newValue;",
        "    }",
        "",
        "    isLeaf(data: CascaderSelectDataItem) {",
        "        return !(",
        "            (data.children && data.children.length) ||",
        "            (!!this.props.loadData && !data.isLeaf)",
        "        );",
        "    }",
        "",
        "    handleVisibleChange(visible: boolean, type?: CascaderSelectVisibleChangeType) {",
        "        const { searchValue } = this.state;",
        "        if (!('visible' in this.props)) {",
        "            this.setState({",
        "                visible,",
        "            });",
        "        }",
        "",
        "        if (!visible && searchValue) {",
        "            this.setState({",
        "                searchValue: '',",
        "            });",
        "        }",
        "",
        "        if (['fromCascader', 'keyboard'].indexOf(type!) !== -1 && !visible) {",
        "            // 这里需要延迟下，showSearch 的情况下通过手动设置 menuProps={{focusable: true}} 回车 focus 会有延迟",
        "            setTimeout(() => this.select.focusInput(), 0);",
        "        }",
        "",
        "        this.props.onVisibleChange(visible, type);",
        "    }",
        "",
        "    handleKeyDown(e: KeyboardEvent<HTMLElement>) {",
        "        const { onKeyDown } = this.props;",
        "        const { visible } = this.state;",
        "",
        "        if (onKeyDown) {",
        "            onKeyDown(e);",
        "        }",
        "",
        "        if (!visible) {",
        "            switch (e.keyCode) {",
        "                case KEYCODE.UP:",
        "                case KEYCODE.DOWN: {",
        "                    e.preventDefault();",
        "                    this.handleVisibleChange(true, 'keyboard');",
        "                    break;",
        "                }",
        "                // no default",
        "            }",
        "            return;",
        "        }",
        "",
        "        switch (e.keyCode) {",
        "            case KEYCODE.UP:",
        "            case KEYCODE.DOWN:",
        "                this.cascader.setFocusValue();",
        "                e.preventDefault();",
        "                break;",
        "            default:",
        "                break;",
        "        }",
        "    }",
        "",
        "    getPopup(ref: InstanceType<typeof Popup>) {",
        "        this.popup = ref;",
        "        if (typeof this.props.popupProps.ref === 'function') {",
        "            this.props.popupProps.ref(ref);",
        "        }",
        "    }",
        "",
        "    handleAfterOpen() {",
        "        if (!this.popup) {",
        "            return;",
        "        }",
        "",
        "        const { prefix, popupProps } = this.props;",
        "        const { v2 = false } = popupProps;",
        "        if (!v2) {",
        "            // @ts-expect-error 待 overlay 技术升级完成",
        "            const dropDownNode = this.popup.getInstance().overlay.getInstance().getContentNode();",
        "            const cascaderNode = dropDownNode.querySelector(`.${prefix}cascader`) as HTMLElement;",
        "            if (cascaderNode) {",
        "                this.cascaderHeight = getStyle(cascaderNode, 'height');",
        "            }",
        "        }",
        "",
        "        if (typeof popupProps.afterOpen === 'function') {",
        "            popupProps.afterOpen();",
        "        }",
        "    }",
        "",
        "    handleSelect(value: unknown, data: CascaderSelectDataItem) {",
        "        const { multiple, changeOnSelect } = this.props;",
        "        const { visible, searchValue } = this.state;",
        "",
        "        if (!multiple && (!changeOnSelect || this.isLeaf(data) || !!searchValue)) {",
        "            this.handleVisibleChange(!visible, 'fromCascader');",
        "        }",
        "    }",
        "",
        "    /**",
        "     * 刷新值数据缓存，删除无效值",
        "     * @param curValue - 当前值",
        "     */",
        "    refreshValueDataCache = (curValue: string | string[]) => {",
        "        if (curValue) {",
        "            const valueArr = Array.isArray(curValue) ? curValue : [curValue];",
        "",
        "            valueArr.length &&",
        "                Object.keys(this._valueDataCache).forEach(v => {",
        "                    if (!valueArr.includes(v)) {",
        "                        delete this._valueDataCache[v];",
        "                    }",
        "                });",
        "        } else {",
        "            this._valueDataCache = {};",
        "        }",
        "    };",
        "",
        "    handleChange(value: string[], data: CascaderSelectDataItem[], extra: Extra) {",
        "        const { multiple, onChange } = this.props;",
        "        const { searchValue, value: stateValue } = this.state;",
        "",
        "        const st = {} as CascaderSelectState;",
        "",
        "        if (multiple && stateValue && Array.isArray(stateValue)) {",
        "            const noExistedValues = stateValue.filter(v => !this._v2n[v]);",
        "",
        "            if (noExistedValues.length > 0) {",
        "                value = value.filter(v => {",
        "                    return !(noExistedValues.indexOf(v) >= 0);",
        "                });",
        "            }",
        "",
        "            value = [...noExistedValues, ...value];",
        "            // onChange 中的 data 参数也应该保留不存在的 value 的数据",
        "            // 在 dataSource 异步加载的情况下，会出现 value 重复的现象，需要去重",
        "            data = [",
        "                ...noExistedValues.map(v => this._valueDataCache[v]).filter(v => v),",
        "                ...data,",
        "            ].filter((current, index, arr) => {",
        "                return index === arr.indexOf(current);",
        "            });",
        "            // 更新缓存",
        "            this.refreshValueDataCache(value);",
        "        }",
        "",
        "        if (!('value' in this.props)) {",
        "            st.value = value;",
        "        }",
        "        if (!multiple && searchValue) {",
        "            st.searchValue = '';",
        "        }",
        "        if (Object.keys(st).length) {",
        "            this.setState(st);",
        "        }",
        "",
        "        if (onChange) {",
        "            onChange(value, data, extra);",
        "        }",
        "",
        "        if (searchValue && this.select) {",
        "            this.select.handleSearchClear();",
        "..."
    ],
    "components/cascader-select/types.ts": [
        "import type React from 'react';",
        "import type { CascaderProps, CascaderDataItem, Extra } from '../cascader';",
        "import type { CommonProps } from '../util';",
        "import type { Popup } from '../overlay';",
        "import type { SelectProps, VisibleChangeType } from '../select';",
        "",
        "interface HTMLAttributesWeak",
        "    extends Omit<",
        "        React.HTMLAttributes<HTMLElement>,",
        "        'defaultValue' | 'onChange' | 'onSelect' | 'onFocus' | 'onBlur'",
        "    > {}",
        "",
        "export interface CascaderSelectDataItem extends CascaderDataItem {",
        "    pos: string;",
        "}",
        "",
        "export type CascaderSelectVisibleChangeType = VisibleChangeType | 'keyboard' | 'fromCascader';",
        "",
        "export interface DeprecatedProps {",
        "    /**",
        "     * @deprecated use `popupContainer` instead",
        "     */",
        "    container?: CascaderSelectProps['popupContainer'];",
        "    /**",
        "     * @deprecated use `hasBorder` instead",
        "     */",
        "    shape?: string;",
        "    /**",
        "     * @deprecated use `expandTriggerType` instead",
        "     */",
        "    expandTrigger?: CascaderSelectProps['expandTriggerType'];",
        "}",
        "",
        "type PickCascaderKeys =",
        "    | 'dataSource'",
        "    | 'useVirtual'",
        "    | 'multiple'",
        "    | 'canOnlyCheckLeaf'",
        "    | 'checkStrictly'",
        "    | 'resultRender'",
        "    | 'expandedValue'",
        "    | 'defaultExpandedValue'",
        "    | 'expandTriggerType'",
        "    | 'onExpand'",
        "    | 'listStyle'",
        "    | 'listClassName'",
        "    | 'loadData'",
        "    | 'itemRender'",
        "    | 'immutable';",
        "",
        "/**",
        " * @api CascaderSelect",
        " * @remarks",
        " * 继承 Cascader, Select 的部分属性，支持透传给 Cascader 的属性有 dataSource, useVirtual, multiple, canOnlyCheckLeaf,",
        " * checkStrictly, resultRender, expandedValue, defaultExpandedValue, expandTriggerType, onExpand, listStyle,",
        " * listClassName, loadData, itemRender, immutable。支持透传给 Select 的包括除上面传给 Cascader 和下方单独列出的属性以外的其他全部属性。",
        " * -",
        " * inherits partial props from Cascader, support passing props to Cascader: dataSource, useVirtual, multiple, canOnlyCheckLeaf,",
        " * checkStrictly, resultRender, expandedValue, defaultExpandedValue, expandTriggerType, onExpand, listStyle, listClassName, loadData, i",
        " * temRender, immutable. Support passing props to Select: other Select props except those listed above and those listed below.",
        " */",
        "export interface CascaderSelectProps",
        "    extends Pick<CascaderProps, PickCascaderKeys>,",
        "        Omit<",
        "            SelectProps,",
        "            PickCascaderKeys | 'locale' | 'onChange' | 'renderPreview' | 'menuProps' | 'filter'",
        "        >,",
        "        HTMLAttributesWeak,",
        "        CommonProps,",
        "        DeprecatedProps {",
        "    /**",
        "     * 选择框大小",
        "     * @en size",
        "     * @defaultValue 'medium'",
        "     */",
        "    size?: 'small' | 'medium' | 'large';",
        "    /**",
        "     * @deprecated use Form.Item name instead",
        "     * @skip",
        "     */",
        "    name?: string;",
        "    /**",
        "     * 是否禁用",
        "     * @en disabled",
        "     * @defaultValue false",
        "     */",
        "    disabled?: boolean;",
        "",
        "    /**",
        "     * 是否有下拉箭头",
        "     * @en hasArrow",
        "     * @defaultValue true",
        "     */",
        "    hasArrow?: boolean;",
        "",
        "    /**",
        "     * 是否有边框",
        "     * @en hasBorder",
        "     * @defaultValue true",
        "     */",
        "    hasBorder?: boolean;",
        "",
        "    /**",
        "     * 是否有清除按钮",
        "     * @en hasClear",
        "     * @defaultValue false",
        "     */",
        "    hasClear?: boolean;",
        "",
        "    /**",
        "     * 是否只读，只读模式下可以展开弹层但不能选",
        "     * @en readOnly, popup layer can be expanded but cannot be selected in read-only mode",
        "     */",
        "    readOnly?: boolean;",
        "",
        "    /**",
        "     *（非受控）默认值",
        "     * @en default value(not controlled)",
        "     */",
        "    defaultValue?: string | Array<string>;",
        "",
        "    /**",
        "     *（受控）当前值",
        "     * @en current value(controlled)",
        "     */",
        "    value?: string | Array<string>;",
        "",
        "    /**",
        "     * 选中值改变时触发的回调函数",
        "     * @en callback when selected value changes",
        "     */",
        "    onChange?: (",
        "        value: string | Array<string> | null,",
        "        data: CascaderDataItem | Array<CascaderDataItem> | null,",
        "        extra?: Extra",
        "    ) => void;",
        "",
        "    /**",
        "     * 是否选中即发生改变，该属性仅在单选模式下有效",
        "     * @en whether to call onChange as soon as selected, this property only works in single selection mode",
        "     * @defaultValue false",
        "     */",
        "    changeOnSelect?: boolean;",
        "",
        "    /**",
        "     * 选择框单选时展示结果的自定义渲染函数",
        "     * @en custom render function of selected result",
        "     */",
        "    displayRender?: (",
        "        label: Array<React.ReactNode>,",
        "        data: CascaderSelectDataItem",
        "    ) => React.ReactNode;",
        "",
        "    /**",
        "     * 是否显示搜索框",
        "     * @en show search box",
        "     * @defaultValue false",
        "     */",
        "    showSearch?: boolean;",
        "",
        "    /**",
        "     * 自定义搜索函数",
        "     * @en custom search function",
        "     */",
        "    filter?: (searchValue: string, path: CascaderSelectDataItem[]) => boolean;",
        "",
        "    /**",
        "     * 当搜索框值变化时回调",
        "     * @en callback when search value changes",
        "     * @version 1.23",
        "     */",
        "    onSearch?: (value: string) => void;",
        "",
        "    /**",
        "     * 搜索结果列表是否和选择框等宽",
        "     * @en whether the search result list is the same width as the selection box",
        "     * @defaultValue true",
        "     */",
        "    resultAutoWidth?: boolean;",
        "",
        "    /**",
        "     * 无数据时显示内容",
        "     * @en content when no data",
        "     */",
        "    notFoundContent?: React.ReactNode;",
        "",
        "    /**",
        "     * 自定义下拉框头部",
        "     * @en custom dropdown header",
        "     */",
        "    header?: React.ReactNode;",
        "",
        "    /**",
        "     * 自定义下拉框底部",
        "     * @en custom dropdown footer",
        "     */",
        "    footer?: React.ReactNode;",
        "",
        "    /**",
        "     * 初始下拉框是否显示",
        "     * @en visible by default",
        "     * @defaultValue false",
        "     */",
        "    defaultVisible?: boolean;",
        "",
        "    /**",
        "     * 当前下拉框是否显示",
        "     * @en current visible",
        "     */",
        "    visible?: boolean;",
        "",
        "    /**",
        "     * 下拉框显示或关闭时触发事件的回调函数",
        "     */",
        "    onVisibleChange?: (visible: boolean, type?: CascaderSelectVisibleChangeType) => void;",
        "",
        "    /**",
        "     * 透传到 Popup 的属性对象",
        "     * @en props object passed to Popup",
        "     */",
        "    popupProps?: React.ComponentPropsWithRef<typeof Popup>;",
        "",
        "    /**",
        "     * 是否为预览态",
        "     * @en whether it is in preview mode",
        "     * @defaultValue false",
        "     */",
        "    isPreview?: boolean;",
        "",
        "    /**",
        "     * 自定义预览态",
        "     * @en custom preview",
        "     */",
        "    renderPreview?: (",
        "        value: CascaderSelectDataItem | CascaderSelectDataItem[],",
        "        props: CascaderSelectProps",
        "    ) => React.ReactNode;",
        "    /**",
        "     * 是否支持树形勾选",
        "     * @en whether to support tree check",
        "     * @skip",
        "     */",
        "    treeCheckable?: boolean;",
        "    /**",
        "     * 透传到 Cascader 的属性对象",
        "     * @en props object passed to Cascader",
        "     */",
        "    menuProps?: Omit<CascaderProps, 'onSelect' | 'onChange'>;",
        "}",
        "",
        "export interface CascaderSelectState {",
        "    value: string[];",
        "    searchValue: string;",
        "    visible: boolean;",
        "}"
    ]
}