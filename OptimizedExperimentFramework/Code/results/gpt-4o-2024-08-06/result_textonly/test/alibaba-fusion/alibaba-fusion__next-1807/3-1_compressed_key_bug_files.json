{
    "1": {
        "bug_file": "src/menu/view/item.jsx",
        "compressed": "NO",
        "line_numbers": 229,
        "compressed_line_numbers": 229,
        "compressed_bug_file_content": "import React, { Component, Children, isValidElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { func, obj, KEYCODE } from '../../util';\n\nconst { bindCtx } = func;\nconst { pickOthers } = obj;\n\nexport default class Item extends Component {\n    static propTypes = {\n        _key: PropTypes.string,\n        level: PropTypes.number,\n        inlineLevel: PropTypes.number,\n        groupIndent: PropTypes.number,\n        root: PropTypes.object,\n        menu: PropTypes.any,\n        parent: PropTypes.object,\n        parentMode: PropTypes.oneOf(['inline', 'popup']),\n        type: PropTypes.oneOf(['submenu', 'item']),\n        component: PropTypes.string,\n        disabled: PropTypes.bool,\n        className: PropTypes.string,\n        onClick: PropTypes.func,\n        onKeyDown: PropTypes.func,\n        needIndent: PropTypes.bool,\n        replaceClassName: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        component: 'li',\n        groupIndent: 0,\n        replaceClassName: false,\n        needIndent: true,\n    };\n\n    constructor(props) {\n        super(props);\n\n        bindCtx(this, ['handleClick', 'handleKeyDown']);\n    }\n\n    componentDidMount() {\n        this.itemNode = findDOMNode(this);\n\n        const { parentMode, root, menu } = this.props;\n        if (menu) {\n            this.menuNode = findDOMNode(menu);\n        } else if (parentMode === 'popup') {\n            this.menuNode = this.itemNode.parentNode;\n        } else {\n            this.menuNode = findDOMNode(root);\n            const { prefix, header, footer } = root.props;\n            if (header || footer) {\n                this.menuNode = this.menuNode.querySelector(\n                    `.${prefix}menu-content`\n                );\n            }\n        }\n\n        this.setFocus();\n    }\n\n    componentDidUpdate() {\n        this.setFocus();\n    }\n\n    focusable() {\n        const { root, type, disabled } = this.props;\n        const { focusable } = root.props;\n        return focusable && (type === 'submenu' || !disabled);\n    }\n\n    getFocused() {\n        const { _key, root } = this.props;\n        const { focusedKey } = root.state;\n        return focusedKey === _key;\n    }\n\n    setFocus() {\n        const focused = this.getFocused();\n        if (focused) {\n            if (this.focusable()) {\n                this.itemNode.focus({ preventScroll: true });\n            }\n            if (\n                this.menuNode &&\n                this.menuNode.scrollHeight > this.menuNode.clientHeight\n            ) {\n                const scrollBottom =\n                    this.menuNode.clientHeight + this.menuNode.scrollTop;\n                const itemBottom =\n                    this.itemNode.offsetTop + this.itemNode.offsetHeight;\n                if (itemBottom > scrollBottom) {\n                    this.menuNode.scrollTop =\n                        itemBottom - this.menuNode.clientHeight;\n                } else if (this.itemNode.offsetTop < this.menuNode.scrollTop) {\n                    this.menuNode.scrollTop = this.itemNode.offsetTop;\n                }\n            }\n        }\n    }\n\n    handleClick(e) {\n        e.stopPropagation();\n\n        const { _key, root, disabled } = this.props;\n\n        if (!disabled) {\n            root.handleItemClick(_key, this, e);\n\n            this.props.onClick && this.props.onClick(e);\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    handleKeyDown(e) {\n        const { _key, root, type } = this.props;\n\n        if (this.focusable()) {\n            root.handleItemKeyDown(_key, type, this, e);\n\n            switch (e.keyCode) {\n                case KEYCODE.ENTER: {\n                    if (!(type === 'submenu')) {\n                        this.handleClick(e);\n                    }\n                    break;\n                }\n            }\n        }\n\n        this.props.onKeyDown && this.props.onKeyDown(e);\n    }\n\n    getTitle(children) {\n        let labelString = '';\n\n        const loop = children => {\n            Children.forEach(children, child => {\n                if (isValidElement(child) && child.props.children) {\n                    loop(child.props.children);\n                } else if (typeof child === 'string') {\n                    labelString += child;\n                }\n            });\n        };\n\n        loop(children);\n\n        return labelString;\n    }\n\n    render() {\n        const {\n            inlineLevel,\n            root,\n            replaceClassName,\n            groupIndent,\n            component,\n            disabled,\n            className,\n            children,\n            needIndent,\n            parentMode,\n            _key,\n        } = this.props;\n        const others = pickOthers(Object.keys(Item.propTypes), this.props);\n\n        const {\n            prefix,\n            focusable,\n            inlineIndent,\n            itemClassName,\n            rtl,\n        } = root.props;\n        const focused = this.getFocused();\n\n        const newClassName = replaceClassName\n            ? className\n            : cx({\n                  [`${prefix}menu-item`]: true,\n                  [`${prefix}disabled`]: disabled,\n                  [`${prefix}focused`]: !focusable && focused,\n                  [itemClassName]: !!itemClassName,\n                  [className]: !!className,\n              });\n        if (disabled) {\n            others['aria-disabled'] = true;\n            others['aria-hidden'] = true;\n        }\n\n        others.tabIndex = root.state.tabbableKey === _key ? '0' : '-1';\n\n        if (\n            parentMode === 'inline' &&\n            inlineLevel > 1 &&\n            inlineIndent > 0 &&\n            needIndent\n        ) {\n            const paddingProp = rtl ? 'paddingRight' : 'paddingLeft';\n            others.style = {\n                ...(others.style || {}),\n                [paddingProp]: `${inlineLevel * inlineIndent -\n                    (groupIndent || 0) * 0.4 * inlineIndent}px`,\n            };\n        }\n        const TagName = component;\n\n        let role = 'menuitem';\n        if ('selectMode' in root.props) {\n            role = 'option';\n        }\n\n        return (\n            <TagName\n                role={role}\n                title={this.getTitle(children)}\n                {...others}\n                className={newClassName}\n                onClick={this.handleClick}\n                onKeyDown={this.handleKeyDown}\n            >\n                <div className={`${prefix}menu-item-inner`}>{children}</div>\n            </TagName>\n        );\n    }\n}"
    },
    "2": {
        "bug_file": "src/config-provider/config.jsx",
        "compressed": "NO",
        "line_numbers": 254,
        "compressed_line_numbers": 254,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { obj, log } from '../util';\nimport getContextProps from './get-context-props';\nimport ErrorBoundary from './error-boundary';\n\nconst { shallowEqual } = obj;\n\nfunction getDisplayName(Component) {\n    return Component.displayName || Component.name || 'Component';\n}\n\nlet globalLocales;\nlet currentGlobalLanguage = 'zh-cn';\nlet currentGlobalLocale = {};\nlet currentGlobalRtl;\n\nexport function initLocales(locales) {\n    globalLocales = locales;\n\n    if (locales) {\n        currentGlobalLocale = locales[currentGlobalLanguage];\n\n        if (typeof currentGlobalRtl !== 'boolean') {\n            currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n        }\n    }\n}\n\nexport function setLanguage(language) {\n    if (globalLocales) {\n        currentGlobalLanguage = language;\n        currentGlobalLocale = globalLocales[language];\n\n        if (typeof currentGlobalRtl !== 'boolean') {\n            currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n        }\n    }\n}\n\nexport function setLocale(locale) {\n    currentGlobalLocale = {\n        ...(globalLocales ? globalLocales[currentGlobalLanguage] : {}),\n        ...locale,\n    };\n\n    if (typeof currentGlobalRtl !== 'boolean') {\n        currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n    }\n}\n\nexport function setDirection(dir) {\n    currentGlobalRtl = dir === 'rtl';\n}\n\nexport function getLocale() {\n    return currentGlobalLocale;\n}\n\nexport function getLanguage() {\n    return currentGlobalLanguage;\n}\n\nexport function getDirection() {\n    return currentGlobalRtl;\n}\n\nexport function config(Component, options = {}) {\n    // 非 forwardRef 创建的 class component\n    if (\n        obj.isClassComponent(Component) &&\n        Component.prototype.shouldComponentUpdate === undefined\n    ) {\n        // class component: 通过定义 shouldComponentUpdate 改写成 pure component, 有refs\n        Component.prototype.shouldComponentUpdate = function shouldComponentUpdate(\n            nextProps,\n            nextState\n        ) {\n            if (this.props.pure) {\n                return (\n                    !shallowEqual(this.props, nextProps) ||\n                    !shallowEqual(this.state, nextState)\n                );\n            }\n\n            return true;\n        };\n    }\n\n    class ConfigedComponent extends React.Component {\n        static propTypes = {\n            ...(Component.propTypes || {}),\n            prefix: PropTypes.string,\n            locale: PropTypes.object,\n            pure: PropTypes.bool,\n            rtl: PropTypes.bool,\n            device: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n            popupContainer: PropTypes.any,\n            errorBoundary: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.object,\n            ]),\n        };\n        static contextTypes = {\n            ...(Component.contextTypes || {}),\n            nextPrefix: PropTypes.string,\n            nextLocale: PropTypes.object,\n            nextPure: PropTypes.bool,\n            nextRtl: PropTypes.bool,\n            nextWarning: PropTypes.bool,\n            nextDevice: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n            nextPopupContainer: PropTypes.any,\n            nextErrorBoundary: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.object,\n            ]),\n        };\n\n        constructor(props, context) {\n            super(props, context);\n\n            this._getInstance = this._getInstance.bind(this);\n            this._deprecated = this._deprecated.bind(this);\n        }\n\n        _getInstance(ref) {\n            this._instance = ref;\n\n            if (this._instance && options.exportNames) {\n                options.exportNames.forEach(name => {\n                    const field = this._instance[name];\n                    if (typeof field === 'function') {\n                        this[name] = field.bind(this._instance);\n                    } else {\n                        this[name] = field;\n                    }\n                });\n            }\n        }\n\n        _deprecated(...args) {\n            if (this.context.nextWarning !== false) {\n                log.deprecated(...args);\n            }\n        }\n\n        getInstance() {\n            return this._instance;\n        }\n\n        render() {\n            const {\n                prefix,\n                locale,\n                pure,\n                rtl,\n                device,\n                popupContainer,\n                errorBoundary,\n                ...others\n            } = this.props;\n            const {\n                nextPrefix,\n                nextLocale = {},\n                nextPure,\n                nextRtl,\n                nextDevice,\n                nextPopupContainer,\n                nextErrorBoundary,\n            } = this.context;\n\n            const displayName =\n                options.componentName || getDisplayName(Component);\n            const contextProps = getContextProps(\n                {\n                    prefix,\n                    locale,\n                    pure,\n                    device,\n                    popupContainer,\n                    rtl,\n                    errorBoundary,\n                },\n                {\n                    nextPrefix,\n                    nextLocale: { ...currentGlobalLocale, ...nextLocale },\n                    nextPure,\n                    nextDevice,\n                    nextPopupContainer,\n                    nextRtl:\n                        typeof nextRtl === 'boolean'\n                            ? nextRtl\n                            : currentGlobalRtl === true\n                            ? true\n                            : undefined,\n                    nextErrorBoundary,\n                },\n                displayName\n            );\n\n            // errorBoundary is only for <ErrorBoundary>\n            const newContextProps = [\n                'prefix',\n                'locale',\n                'pure',\n                'rtl',\n                'device',\n                'popupContainer',\n            ].reduce((ret, name) => {\n                if (typeof contextProps[name] !== 'undefined') {\n                    ret[name] = contextProps[name];\n                }\n                return ret;\n            }, {});\n\n            if ('pure' in newContextProps && newContextProps.pure) {\n                log.warning(\n                    'pure of ConfigProvider is deprecated, use Function Component or React.PureComponent'\n                );\n            }\n\n            const newOthers = options.transform\n                ? options.transform(others, this._deprecated)\n                : others;\n\n            const content = (\n                <Component\n                    {...newOthers}\n                    {...newContextProps}\n                    ref={\n                        obj.isClassComponent(Component)\n                            ? this._getInstance\n                            : null\n                    }\n                />\n            );\n\n            const { open, ...othersBoundary } = contextProps.errorBoundary;\n\n            return open ? (\n                <ErrorBoundary {...othersBoundary}>{content}</ErrorBoundary>\n            ) : (\n                content\n            );\n        }\n    }\n\n    ConfigedComponent.displayName = `Config(${getDisplayName(Component)})`;\n\n    hoistNonReactStatic(ConfigedComponent, Component);\n\n    return ConfigedComponent;\n}"
    }
}