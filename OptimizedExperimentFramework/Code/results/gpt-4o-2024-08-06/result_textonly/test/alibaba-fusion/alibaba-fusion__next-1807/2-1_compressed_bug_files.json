{
    "1": {
        "bug_file": "src/config-provider/config.jsx",
        "compressed": "NO",
        "line_numbers": 254,
        "compressed_line_numbers": 254,
        "compressed_bug_file_content": "import React from 'react';\nimport PropTypes from 'prop-types';\nimport hoistNonReactStatic from 'hoist-non-react-statics';\nimport { obj, log } from '../util';\nimport getContextProps from './get-context-props';\nimport ErrorBoundary from './error-boundary';\n\nconst { shallowEqual } = obj;\n\nfunction getDisplayName(Component) {\n    return Component.displayName || Component.name || 'Component';\n}\n\nlet globalLocales;\nlet currentGlobalLanguage = 'zh-cn';\nlet currentGlobalLocale = {};\nlet currentGlobalRtl;\n\nexport function initLocales(locales) {\n    globalLocales = locales;\n\n    if (locales) {\n        currentGlobalLocale = locales[currentGlobalLanguage];\n\n        if (typeof currentGlobalRtl !== 'boolean') {\n            currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n        }\n    }\n}\n\nexport function setLanguage(language) {\n    if (globalLocales) {\n        currentGlobalLanguage = language;\n        currentGlobalLocale = globalLocales[language];\n\n        if (typeof currentGlobalRtl !== 'boolean') {\n            currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n        }\n    }\n}\n\nexport function setLocale(locale) {\n    currentGlobalLocale = {\n        ...(globalLocales ? globalLocales[currentGlobalLanguage] : {}),\n        ...locale,\n    };\n\n    if (typeof currentGlobalRtl !== 'boolean') {\n        currentGlobalRtl = currentGlobalLocale && currentGlobalLocale.rtl;\n    }\n}\n\nexport function setDirection(dir) {\n    currentGlobalRtl = dir === 'rtl';\n}\n\nexport function getLocale() {\n    return currentGlobalLocale;\n}\n\nexport function getLanguage() {\n    return currentGlobalLanguage;\n}\n\nexport function getDirection() {\n    return currentGlobalRtl;\n}\n\nexport function config(Component, options = {}) {\n    // 非 forwardRef 创建的 class component\n    if (\n        obj.isClassComponent(Component) &&\n        Component.prototype.shouldComponentUpdate === undefined\n    ) {\n        // class component: 通过定义 shouldComponentUpdate 改写成 pure component, 有refs\n        Component.prototype.shouldComponentUpdate = function shouldComponentUpdate(\n            nextProps,\n            nextState\n        ) {\n            if (this.props.pure) {\n                return (\n                    !shallowEqual(this.props, nextProps) ||\n                    !shallowEqual(this.state, nextState)\n                );\n            }\n\n            return true;\n        };\n    }\n\n    class ConfigedComponent extends React.Component {\n        static propTypes = {\n            ...(Component.propTypes || {}),\n            prefix: PropTypes.string,\n            locale: PropTypes.object,\n            pure: PropTypes.bool,\n            rtl: PropTypes.bool,\n            device: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n            popupContainer: PropTypes.any,\n            errorBoundary: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.object,\n            ]),\n        };\n        static contextTypes = {\n            ...(Component.contextTypes || {}),\n            nextPrefix: PropTypes.string,\n            nextLocale: PropTypes.object,\n            nextPure: PropTypes.bool,\n            nextRtl: PropTypes.bool,\n            nextWarning: PropTypes.bool,\n            nextDevice: PropTypes.oneOf(['tablet', 'desktop', 'phone']),\n            nextPopupContainer: PropTypes.any,\n            nextErrorBoundary: PropTypes.oneOfType([\n                PropTypes.bool,\n                PropTypes.object,\n            ]),\n        };\n\n        constructor(props, context) {\n            super(props, context);\n\n            this._getInstance = this._getInstance.bind(this);\n            this._deprecated = this._deprecated.bind(this);\n        }\n\n        _getInstance(ref) {\n            this._instance = ref;\n\n            if (this._instance && options.exportNames) {\n                options.exportNames.forEach(name => {\n                    const field = this._instance[name];\n                    if (typeof field === 'function') {\n                        this[name] = field.bind(this._instance);\n                    } else {\n                        this[name] = field;\n                    }\n                });\n            }\n        }\n\n        _deprecated(...args) {\n            if (this.context.nextWarning !== false) {\n                log.deprecated(...args);\n            }\n        }\n\n        getInstance() {\n            return this._instance;\n        }\n\n        render() {\n            const {\n                prefix,\n                locale,\n                pure,\n                rtl,\n                device,\n                popupContainer,\n                errorBoundary,\n                ...others\n            } = this.props;\n            const {\n                nextPrefix,\n                nextLocale = {},\n                nextPure,\n                nextRtl,\n                nextDevice,\n                nextPopupContainer,\n                nextErrorBoundary,\n            } = this.context;\n\n            const displayName =\n                options.componentName || getDisplayName(Component);\n            const contextProps = getContextProps(\n                {\n                    prefix,\n                    locale,\n                    pure,\n                    device,\n                    popupContainer,\n                    rtl,\n                    errorBoundary,\n                },\n                {\n                    nextPrefix,\n                    nextLocale: { ...currentGlobalLocale, ...nextLocale },\n                    nextPure,\n                    nextDevice,\n                    nextPopupContainer,\n                    nextRtl:\n                        typeof nextRtl === 'boolean'\n                            ? nextRtl\n                            : currentGlobalRtl === true\n                            ? true\n                            : undefined,\n                    nextErrorBoundary,\n                },\n                displayName\n            );\n\n            // errorBoundary is only for <ErrorBoundary>\n            const newContextProps = [\n                'prefix',\n                'locale',\n                'pure',\n                'rtl',\n                'device',\n                'popupContainer',\n            ].reduce((ret, name) => {\n                if (typeof contextProps[name] !== 'undefined') {\n                    ret[name] = contextProps[name];\n                }\n                return ret;\n            }, {});\n\n            if ('pure' in newContextProps && newContextProps.pure) {\n                log.warning(\n                    'pure of ConfigProvider is deprecated, use Function Component or React.PureComponent'\n                );\n            }\n\n            const newOthers = options.transform\n                ? options.transform(others, this._deprecated)\n                : others;\n\n            const content = (\n                <Component\n                    {...newOthers}\n                    {...newContextProps}\n                    ref={\n                        obj.isClassComponent(Component)\n                            ? this._getInstance\n                            : null\n                    }\n                />\n            );\n\n            const { open, ...othersBoundary } = contextProps.errorBoundary;\n\n            return open ? (\n                <ErrorBoundary {...othersBoundary}>{content}</ErrorBoundary>\n            ) : (\n                content\n            );\n        }\n    }\n\n    ConfigedComponent.displayName = `Config(${getDisplayName(Component)})`;\n\n    hoistNonReactStatic(ConfigedComponent, Component);\n\n    return ConfigedComponent;\n}"
    },
    "2": {
        "bug_file": "src/menu/view/item.jsx",
        "compressed": "NO",
        "line_numbers": 229,
        "compressed_line_numbers": 229,
        "compressed_bug_file_content": "import React, { Component, Children, isValidElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { func, obj, KEYCODE } from '../../util';\n\nconst { bindCtx } = func;\nconst { pickOthers } = obj;\n\nexport default class Item extends Component {\n    static propTypes = {\n        _key: PropTypes.string,\n        level: PropTypes.number,\n        inlineLevel: PropTypes.number,\n        groupIndent: PropTypes.number,\n        root: PropTypes.object,\n        menu: PropTypes.any,\n        parent: PropTypes.object,\n        parentMode: PropTypes.oneOf(['inline', 'popup']),\n        type: PropTypes.oneOf(['submenu', 'item']),\n        component: PropTypes.string,\n        disabled: PropTypes.bool,\n        className: PropTypes.string,\n        onClick: PropTypes.func,\n        onKeyDown: PropTypes.func,\n        needIndent: PropTypes.bool,\n        replaceClassName: PropTypes.bool,\n    };\n\n    static defaultProps = {\n        component: 'li',\n        groupIndent: 0,\n        replaceClassName: false,\n        needIndent: true,\n    };\n\n    constructor(props) {\n        super(props);\n\n        bindCtx(this, ['handleClick', 'handleKeyDown']);\n    }\n\n    componentDidMount() {\n        this.itemNode = findDOMNode(this);\n\n        const { parentMode, root, menu } = this.props;\n        if (menu) {\n            this.menuNode = findDOMNode(menu);\n        } else if (parentMode === 'popup') {\n            this.menuNode = this.itemNode.parentNode;\n        } else {\n            this.menuNode = findDOMNode(root);\n            const { prefix, header, footer } = root.props;\n            if (header || footer) {\n                this.menuNode = this.menuNode.querySelector(\n                    `.${prefix}menu-content`\n                );\n            }\n        }\n\n        this.setFocus();\n    }\n\n    componentDidUpdate() {\n        this.setFocus();\n    }\n\n    focusable() {\n        const { root, type, disabled } = this.props;\n        const { focusable } = root.props;\n        return focusable && (type === 'submenu' || !disabled);\n    }\n\n    getFocused() {\n        const { _key, root } = this.props;\n        const { focusedKey } = root.state;\n        return focusedKey === _key;\n    }\n\n    setFocus() {\n        const focused = this.getFocused();\n        if (focused) {\n            if (this.focusable()) {\n                this.itemNode.focus({ preventScroll: true });\n            }\n            if (\n                this.menuNode &&\n                this.menuNode.scrollHeight > this.menuNode.clientHeight\n            ) {\n                const scrollBottom =\n                    this.menuNode.clientHeight + this.menuNode.scrollTop;\n                const itemBottom =\n                    this.itemNode.offsetTop + this.itemNode.offsetHeight;\n                if (itemBottom > scrollBottom) {\n                    this.menuNode.scrollTop =\n                        itemBottom - this.menuNode.clientHeight;\n                } else if (this.itemNode.offsetTop < this.menuNode.scrollTop) {\n                    this.menuNode.scrollTop = this.itemNode.offsetTop;\n                }\n            }\n        }\n    }\n\n    handleClick(e) {\n        e.stopPropagation();\n\n        const { _key, root, disabled } = this.props;\n\n        if (!disabled) {\n            root.handleItemClick(_key, this, e);\n\n            this.props.onClick && this.props.onClick(e);\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    handleKeyDown(e) {\n        const { _key, root, type } = this.props;\n\n        if (this.focusable()) {\n            root.handleItemKeyDown(_key, type, this, e);\n\n            switch (e.keyCode) {\n                case KEYCODE.ENTER: {\n                    if (!(type === 'submenu')) {\n                        this.handleClick(e);\n                    }\n                    break;\n                }\n            }\n        }\n\n        this.props.onKeyDown && this.props.onKeyDown(e);\n    }\n\n    getTitle(children) {\n        let labelString = '';\n\n        const loop = children => {\n            Children.forEach(children, child => {\n                if (isValidElement(child) && child.props.children) {\n                    loop(child.props.children);\n                } else if (typeof child === 'string') {\n                    labelString += child;\n                }\n            });\n        };\n\n        loop(children);\n\n        return labelString;\n    }\n\n    render() {\n        const {\n            inlineLevel,\n            root,\n            replaceClassName,\n            groupIndent,\n            component,\n            disabled,\n            className,\n            children,\n            needIndent,\n            parentMode,\n            _key,\n        } = this.props;\n        const others = pickOthers(Object.keys(Item.propTypes), this.props);\n\n        const {\n            prefix,\n            focusable,\n            inlineIndent,\n            itemClassName,\n            rtl,\n        } = root.props;\n        const focused = this.getFocused();\n\n        const newClassName = replaceClassName\n            ? className\n            : cx({\n                  [`${prefix}menu-item`]: true,\n                  [`${prefix}disabled`]: disabled,\n                  [`${prefix}focused`]: !focusable && focused,\n                  [itemClassName]: !!itemClassName,\n                  [className]: !!className,\n              });\n        if (disabled) {\n            others['aria-disabled'] = true;\n            others['aria-hidden'] = true;\n        }\n\n        others.tabIndex = root.state.tabbableKey === _key ? '0' : '-1';\n\n        if (\n            parentMode === 'inline' &&\n            inlineLevel > 1 &&\n            inlineIndent > 0 &&\n            needIndent\n        ) {\n            const paddingProp = rtl ? 'paddingRight' : 'paddingLeft';\n            others.style = {\n                ...(others.style || {}),\n                [paddingProp]: `${inlineLevel * inlineIndent -\n                    (groupIndent || 0) * 0.4 * inlineIndent}px`,\n            };\n        }\n        const TagName = component;\n\n        let role = 'menuitem';\n        if ('selectMode' in root.props) {\n            role = 'option';\n        }\n\n        return (\n            <TagName\n                role={role}\n                title={this.getTitle(children)}\n                {...others}\n                className={newClassName}\n                onClick={this.handleClick}\n                onKeyDown={this.handleKeyDown}\n            >\n                <div className={`${prefix}menu-item-inner`}>{children}</div>\n            </TagName>\n        );\n    }\n}"
    },
    "3": {
        "bug_file": "src/menu/view/create.jsx",
        "compressed": "NO",
        "line_numbers": 193,
        "compressed_line_numbers": 193,
        "compressed_bug_file_content": "import React, { Component } from 'react';\nimport { render, unmountComponentAtNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport Overlay from '../../overlay';\nimport { func } from '../../util';\nimport ConfigProvider from '../../config-provider';\nimport menu from './menu';\n\nconst { bindCtx } = func;\nconst { getContextProps } = ConfigProvider;\nconst Menu = ConfigProvider.config(menu);\n\nlet menuInstance;\n\nclass ContextMenu extends Component {\n    static propTypes = {\n        className: PropTypes.string,\n        popupClassName: PropTypes.string,\n        target: PropTypes.any,\n        align: PropTypes.string,\n        offset: PropTypes.array,\n        overlayProps: PropTypes.object,\n        afterClose: PropTypes.func,\n        mode: PropTypes.oneOf(['inline', 'popup']),\n        onOpen: PropTypes.func,\n        onItemClick: PropTypes.func,\n    };\n\n    static defaultProps = {\n        prefix: 'next-',\n        align: 'tl tl',\n        mode: 'popup',\n    };\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            visible: true,\n        };\n\n        bindCtx(this, [\n            'handleOverlayClose',\n            'handleOverlayOpen',\n            'handleItemClick',\n            'getOverlay',\n        ]);\n    }\n\n    getOverlay(ref) {\n        this.overlay = ref;\n    }\n\n    close() {\n        this.setState({\n            visible: false,\n        });\n        menuInstance = null;\n    }\n\n    handleOverlayClose(triggerType, e, ...others) {\n        const clickedPopupMenu =\n            triggerType === 'docClick' &&\n            this.popupNodes.some(node => node.contains(e.target));\n        if (!clickedPopupMenu) {\n            this.close();\n            const { overlayProps } = this.props;\n            if (overlayProps && overlayProps.onRequestClose) {\n                overlayProps.onRequestClose(triggerType, e, ...others);\n            }\n        }\n    }\n\n    handleOverlayOpen() {\n        this.popupNodes = this.overlay\n            .getInstance()\n            .getContent()\n            .getInstance().popupNodes;\n        const { overlayProps } = this.props;\n        if (overlayProps && overlayProps.onOpen) {\n            overlayProps.onOpen();\n        }\n    }\n\n    handleItemClick(...args) {\n        this.close();\n\n        this.props.onItemClick && this.props.onItemClick(...args);\n    }\n\n    render() {\n        const {\n            className,\n            popupClassName,\n            target,\n            align,\n            offset,\n            afterClose,\n            overlayProps = {},\n            ...others\n        } = this.props;\n        const contextProps = getContextProps(this.props);\n        const { prefix } = contextProps;\n        const { visible } = this.state;\n\n        const newOverlayProps = {\n            ...contextProps,\n            ...overlayProps,\n            target,\n            align,\n            offset,\n            afterClose,\n            visible,\n            onRequestClose: this.handleOverlayClose,\n            onOpen: this.handleOverlayOpen,\n            ref: this.getOverlay,\n        };\n        const menuProps = {\n            ...contextProps,\n            triggerType: 'hover',\n            ...others,\n            className: cx({\n                [`${prefix}context`]: true,\n                [className]: !!className,\n            }),\n            popupClassName: cx({\n                [`${prefix}context`]: true,\n                [popupClassName]: !!popupClassName,\n            }),\n            onItemClick: this.handleItemClick,\n        };\n\n        newOverlayProps.rtl = false;\n\n        return (\n            <Overlay {...newOverlayProps}>\n                <Menu {...menuProps} />\n            </Overlay>\n        );\n    }\n}\n\n/**\n * 创建上下文菜单\n * @exportName create\n * @param {Object} props 属性对象\n */\nexport default function create(props) {\n    if (menuInstance) {\n        menuInstance.destroy();\n    }\n\n    /* eslint-disable no-unused-vars */\n    const { afterClose, ...others } = props;\n    /* eslint-enable no-unused-vars */\n\n    const div = document.createElement('div');\n    document.body.appendChild(div);\n\n    const closeChain = () => {\n        unmountComponentAtNode(div);\n        document.body.removeChild(div);\n\n        afterClose && afterClose();\n    };\n\n    const newContext = ConfigProvider.getContext();\n\n    let menu;\n    render(\n        <ConfigProvider {...newContext}>\n            <ContextMenu\n                ref={ref => {\n                    menu = ref;\n                }}\n                afterClose={closeChain}\n                {...others}\n            />\n        </ConfigProvider>,\n        div\n    );\n\n    menuInstance = {\n        destroy: () => {\n            if (menu) {\n                menu.close();\n            }\n        },\n    };\n\n    return menuInstance;\n}"
    },
    "4": {
        "bug_file": "src/balloon/util.js",
        "compressed": "NO",
        "line_numbers": 26,
        "compressed_line_numbers": 26,
        "compressed_bug_file_content": "import React from 'react';\n\nexport function getDisabledCompatibleTrigger(element) {\n    if (\n        element.type.displayName === 'Config(Button)' &&\n        element.props.disabled\n    ) {\n        const displayStyle =\n            element.props.style && element.props.style.display\n                ? element.props.style.display\n                : 'inline-block';\n        const child = React.cloneElement(element, {\n            style: {\n                ...element.props.style,\n                pointerEvents: 'none',\n            },\n        });\n        return (\n            // eslint-disable-next-line\n            <span style={{ display: displayStyle, cursor: 'not-allowed' }}>\n                {child}\n            </span>\n        );\n    }\n    return element;\n}"
    },
    "5": {
        "bug_file": "src/menu/view/menu.jsx",
        "compressed": "YES",
        "line_numbers": 1075,
        "compressed_line_numbers": 191,
        "compressed_bug_file_content": "import React, { Component, Children, cloneElement } from 'react';\nimport { findDOMNode } from 'react-dom';\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\nimport { polyfill } from 'react-lifecycles-compat';\nimport SubMenu from './sub-menu';\nimport ConfigProvider from '../../config-provider';\nimport { func, obj, dom, events, KEYCODE } from '../../util';\nimport {\n\n\n    // keep placehold to get width\n\n\n        // indicators which not in use, just display: none\n\n\n                    // `React.forwardRef(render)` returns a forwarding\n                    // object that includes `render` method, and the specific\n                    // `child.type` will be an object instead of a class or\n                    // function.\n\n\n                    // filter out duplicate keys\n\n\n                // paddingLeft(or paddingRight in rtl) only make sense in inline mode\n                // parent know children's inlineLevel\n                // if parent's mode is popup, then children's inlineLevel must be 1;\n                // else inlineLevel should add 1\n\n\n/**\n * Menu\n */\n\n\n        /**\n         * 菜单项和子菜单\n         */\n\n        /**\n         * 点击菜单项触发的回调函数\n         * @param {String} key 点击的菜单项的 key 值\n         * @param {Object} item 点击的菜单项对象\n         * @param {Object} event 点击的事件对象\n         */\n\n        /**\n         * 当前打开的子菜单的 key 值\n         */\n\n        /**\n         * 初始打开的子菜单的 key 值\n         */\n\n\n        /**\n         * 初始展开所有的子菜单，只在 mode 设置为 'inline' 以及 openMode 设置为 'multiple' 下生效，优先级高于 defaultOpenKeys\n         */\n\n        /**\n         * 打开或关闭子菜单触发的回调函数\n         * @param {Array} key 打开的所有子菜单的 key 值\n         * @param {Object} extra 额外参数\n         * @param {String} extra.key 当前操作子菜单的 key 值\n         * @param {Boolean} extra.open 是否是打开\n         */\n\n        /**\n         * 子菜单打开的模式\n         */\n\n        /**\n         * 子菜单打开的触发行为\n         */\n\n        /**\n         * 展开内连子菜单的模式，同时可以展开一个子菜单还是多个子菜单，该属性仅在 mode 为 inline 时生效\n         */\n\n        /**\n         * 内连子菜单缩进距离\n         */\n\n\n        /**\n         * 是否自动让弹层的宽度和菜单项保持一致，如果弹层的宽度比菜单项小则和菜单项保持一致，如果宽度大于菜单项则不做处理\n         */\n\n        /**\n         * 弹层的对齐方式\n         */\n\n        /**\n         * 弹层自定义 props\n         */\n\n        /**\n         * 弹出子菜单自定义 className\n         */\n\n        /**\n         * 弹出子菜单自定义 style\n         */\n\n        /**\n         * 当前选中菜单项的 key 值\n         */\n\n        /**\n         * 初始选中菜单项的 key 值\n         */\n\n\n        /**\n         * 选中或取消选中菜单项触发的回调函数\n         * @param {Array} selectedKeys 选中的所有菜单项的值\n         * @param {Object} item 选中或取消选中的菜单项\n         * @param {Object} extra 额外参数\n         * @param {Boolean} extra.select 是否是选中\n         * @param {Array} extra.key 菜单项的 key\n         * @param {Object} extra.label 菜单项的文本\n         * @param {Array} extra.keyPath 菜单项 key 的路径\n         */\n\n        /**\n         * 选中模式，单选还是多选，默认无值，不可选\n         */\n\n        /**\n         * 是否只能选择第一层菜单项（不能选择子菜单中的菜单项）\n         */\n\n        /**\n         * 是否显示选中图标，如果设置为 false 需配合配置平台设置选中时的背景色以示区分\n         */\n\n\n        /**\n         * 是否将选中图标居右，仅当 hasSelectedIcon 为true 时生效。\n         * 注意：SubMenu 上的选中图标一直居左，不受此API控制\n         */\n\n        /**\n         * 菜单第一层展示方向\n         */\n\n        /**\n         * 横向菜单条 item 和 footer 的对齐方向，在 direction 设置为 'hoz' 并且 header 存在时生效\n         */\n\n        /**\n         * 横向菜单模式下，是否维持在一行，即超出一行折叠成 SubMenu 显示， 仅在 direction='hoz' mode='popup' 时生效\n         */\n\n\n        /**\n         * 自定义菜单头部\n         */\n\n        /**\n         * 自定义菜单尾部\n         */\n\n        /**\n         * 是否自动获得焦点\n         */\n\n        /**\n         * 当前获得焦点的子菜单或菜单项 key 值\n         */\n\n\n        /**\n         * 是否开启嵌入式模式，一般用于Layout的布局中，开启后没有默认背景、外层border、box-shadow，可以配合`<Menu style={{lineHeight: '100px'}}>` 自定义高度\n         */\n\n\n        /**\n         * 可配置的icons，包括 select 等\n         */\n\n\n        // keep placehold to get width\n\n\n            // indicators which not in use, just display: none\n\n\nexport default polyfill(Menu);\n"
    }
}