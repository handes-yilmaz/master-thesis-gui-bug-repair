{
    "src/languages/javascript.js": [
        "/* eslint-disable no-unreachable */",
        "/*",
        "Language: JavaScript",
        "Description: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.",
        "Category: common, scripting",
        "Website: https://developer.mozilla.org/en-US/docs/Web/JavaScript",
        "*/",
        "",
        "import * as ECMAScript from './lib/ecmascript.js';",
        "import * as regex from '../lib/regex.js';",
        "",
        "/** @type LanguageFn */",
        "export default function(hljs) {",
        "  /**",
        "   * Takes a string like \"<Booger\" and checks to see",
        "   * if we can find a matching \"</Booger\" later in the",
        "   * content.",
        "   * @param {RegExpMatchArray} match",
        "   * @param {{after:number}} param1",
        "   */",
        "  const hasClosingTag = (match, { after }) => {",
        "    const tag = match[0].replace(\"<\", \"</\");",
        "    const pos = match.input.indexOf(tag, after);",
        "    return pos !== -1;",
        "  };",
        "",
        "  const IDENT_RE = ECMAScript.IDENT_RE;",
        "  const FRAGMENT = {",
        "    begin: '<>',",
        "    end: '</>'",
        "  };",
        "  const XML_TAG = {",
        "    begin: /<[A-Za-z0-9\\\\._:-]+/,",
        "    end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,",
        "    /**",
        "     * @param {RegExpMatchArray} match",
        "     * @param {CallbackResponse} response",
        "     */",
        "    isTrulyOpeningTag: (match, response) => {",
        "      const afterMatchIndex = match[0].length + match.index;",
        "      const nextChar = match.input[afterMatchIndex];",
        "      // nested type?",
        "      // HTML should not include another raw `<` inside a tag",
        "      // But a type might: `<Array<Array<number>>`, etc.",
        "      if (nextChar === \"<\") {",
        "        response.ignoreMatch();",
        "        return;",
        "      }",
        "      // <something>",
        "      // This is now either a tag or a type.",
        "      if (nextChar === \">\") {",
        "        // if we cannot find a matching closing tag, then we",
        "        // will ignore it",
        "        if (!hasClosingTag(match, { after: afterMatchIndex })) {",
        "          response.ignoreMatch();",
        "        }",
        "      }",
        "    }",
        "  };",
        "  const KEYWORDS = {",
        "    $pattern: ECMAScript.IDENT_RE,",
        "    keyword: ECMAScript.KEYWORDS.join(\" \"),",
        "    literal: ECMAScript.LITERALS.join(\" \"),",
        "    built_in: ECMAScript.BUILT_INS.join(\" \")",
        "  };",
        "  const nonDecimalLiterals = (prefixLetters, validChars) =>",
        "    `\\\\b0[${prefixLetters}][${validChars}]([${validChars}_]*[${validChars}])?n?`;",
        "  const noLeadingZeroDecimalDigits = /[1-9]([0-9_]*\\d)?/;",
        "  const decimalDigits = /\\d([0-9_]*\\d)?/;",
        "  const exponentPart = regex.concat(/[eE][+-]?/, decimalDigits);",
        "  const NUMBER = {",
        "    className: 'number',",
        "    variants: [",
        "      { begin: nonDecimalLiterals('bB', '01') }, // Binary literals",
        "      { begin: nonDecimalLiterals('oO', '0-7') }, // Octal literals",
        "      { begin: nonDecimalLiterals('xX', '0-9a-fA-F') }, // Hexadecimal literals",
        "      { begin: regex.concat(/\\b/, noLeadingZeroDecimalDigits, 'n') }, // Non-zero BigInt literals",
        "      { begin: regex.concat(/(\\b0)?\\./, decimalDigits, regex.optional(exponentPart)) }, // Decimal literals between 0 and 1",
        "      { begin: regex.concat(",
        "        /\\b/,",
        "        noLeadingZeroDecimalDigits,",
        "        regex.optional(regex.concat(/\\./, regex.optional(decimalDigits))), // fractional part",
        "        regex.optional(exponentPart)",
        "        ) }, // Decimal literals >= 1",
        "      { begin: /\\b0[\\.n]?/ }, // Zero literals (`0`, `0.`, `0n`)",
        "    ],",
        "    relevance: 0",
        "  };",
        "  const SUBST = {",
        "    className: 'subst',",
        "    begin: '\\\\$\\\\{',",
        "    end: '\\\\}',",
        "    keywords: KEYWORDS,",
        "    contains: [] // defined later",
        "  };",
        "  const HTML_TEMPLATE = {",
        "    begin: 'html`',",
        "    end: '',",
        "    starts: {",
        "      end: '`',",
        "      returnEnd: false,",
        "      contains: [",
        "        hljs.BACKSLASH_ESCAPE,",
        "        SUBST",
        "      ],",
        "      subLanguage: 'xml'",
        "    }",
        "  };",
        "  const CSS_TEMPLATE = {",
        "    begin: 'css`',",
        "    end: '',",
        "    starts: {",
        "      end: '`',",
        "      returnEnd: false,",
        "      contains: [",
        "        hljs.BACKSLASH_ESCAPE,",
        "        SUBST",
        "      ],",
        "      subLanguage: 'css'",
        "    }",
        "  };",
        "  const TEMPLATE_STRING = {",
        "    className: 'string',",
        "    begin: '`',",
        "    end: '`',",
        "    contains: [",
        "      hljs.BACKSLASH_ESCAPE,",
        "      SUBST",
        "    ]",
        "  };",
        "  const JSDOC_COMMENT = hljs.COMMENT(",
        "    '/\\\\*\\\\*',",
        "    '\\\\*/',",
        "    {",
        "      relevance: 0,",
        "      contains: [",
        "        {",
        "          className: 'doctag',",
        "          begin: '@[A-Za-z]+',",
        "          contains: [",
        "            {",
        "              className: 'type',",
        "              begin: '\\\\{',",
        "              end: '\\\\}',",
        "              relevance: 0",
        "            },",
        "            {",
        "              className: 'variable',",
        "              begin: IDENT_RE + '(?=\\\\s*(-)|$)',",
        "              endsParent: true,",
        "              relevance: 0",
        "            },",
        "            // eat spaces (not newlines) so we can find",
        "            // types or variables",
        "            {",
        "              begin: /(?=[^\\n])\\s/,",
        "              relevance: 0",
        "            }",
        "          ]",
        "        }",
        "      ]",
        "    }",
        "  );",
        "  const COMMENT = {",
        "    className: \"comment\",",
        "    variants: [",
        "      JSDOC_COMMENT,",
        "      hljs.C_BLOCK_COMMENT_MODE,",
        "      hljs.C_LINE_COMMENT_MODE",
        "    ]",
        "  };",
        "  SUBST.contains = [",
        "    hljs.APOS_STRING_MODE,",
        "    hljs.QUOTE_STRING_MODE,",
        "    HTML_TEMPLATE,",
        "    CSS_TEMPLATE,",
        "    TEMPLATE_STRING,",
        "    NUMBER,",
        "    hljs.REGEXP_MODE",
        "  ];",
        "  const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);",
        "  const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([",
        "    // eat recursive parens in sub expressions",
        "    {",
        "      begin: /\\(/,",
        "      end: /\\)/,",
        "      keywords: KEYWORDS,",
        "      contains: [\"self\"].concat(SUBST_AND_COMMENTS)",
        "    }",
        "  ]);",
        "  const PARAMS = {",
        "    className: 'params',",
        "    begin: /\\(/,",
        "    end: /\\)/,",
        "    excludeBegin: true,",
        "    excludeEnd: true,",
        "    keywords: KEYWORDS,",
        "    contains: PARAMS_CONTAINS",
        "  };",
        "",
        "  return {",
        "    name: 'Javascript',",
        "    aliases: ['js', 'jsx', 'mjs', 'cjs'],",
        "    keywords: KEYWORDS,",
        "    // this will be extended by TypeScript",
        "    exports: { PARAMS_CONTAINS },",
        "    illegal: /#(?![$_A-z])/,",
        "    contains: [",
        "      hljs.SHEBANG({",
        "        label: \"shebang\",",
        "        binary: \"node\",",
        "        relevance: 5",
        "      }),",
        "      {",
        "        label: \"use_strict\",",
        "        className: 'meta',",
        "        relevance: 10,",
        "        begin: /^\\s*['\"]use (strict|asm)['\"]/",
        "      },",
        "      hljs.APOS_STRING_MODE,",
        "      hljs.QUOTE_STRING_MODE,",
        "      HTML_TEMPLATE,",
        "      CSS_TEMPLATE,",
        "      TEMPLATE_STRING,",
        "      COMMENT,",
        "      NUMBER,",
        "      { // object attr container",
        "        begin: regex.concat(/[{,\\n]\\s*/,",
        "          // we need to look ahead to make sure that we actually have an",
        "          // attribute coming up so we don't steal a comma from a potential",
        "          // \"value\" container",
        "          //",
        "          // NOTE: this might not work how you think.  We don't actually always",
        "          // enter this mode and stay.  Instead it might merely match `,",
        "          // <comments up next>` and then immediately end after the , because it",
        "          // fails to find any actual attrs. But this still does the job because",
        "          // it prevents the value contain rule from grabbing this instead and",
        "          // prevening this rule from firing when we actually DO have keys.",
        "          regex.lookahead(regex.concat(",
        "            // we also need to allow for multiple possible comments inbetween",
        "            // the first key:value pairing",
        "            /(((\\/\\/.*$)|(\\/\\*(.|\\n)*\\*\\/))\\s*)*/,",
        "            IDENT_RE + '\\\\s*:'))),",
        "        relevance: 0,",
        "        contains: [",
        "          {",
        "            className: 'attr',",
        "            begin: IDENT_RE + regex.lookahead('\\\\s*:'),",
        "            relevance: 0",
        "          }",
        "        ]",
        "      },",
        "      { // \"value\" container",
        "        begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',",
        "        keywords: 'return throw case',",
        "        contains: [",
        "          COMMENT,",
        "          hljs.REGEXP_MODE,",
        "          {",
        "            className: 'function',",
        "            // we have to count the parens to make sure we actually have the",
        "            // correct bounding ( ) before the =>.  There could be any number of",
        "            // sub-expressions inside also surrounded by parens.",
        "            begin: '(\\\\([^(]*' +",
        "              '(\\\\([^(]*' +",
        "                '(\\\\([^(]*' +",
        "                '\\\\))?' +",
        "              '\\\\))?' +",
        "            '\\\\)|' + hljs.UNDERSCORE_IDENT_RE + ')\\\\s*=>',",
        "            returnBegin: true,",
        "            end: '\\\\s*=>',",
        "            contains: [",
        "              {",
        "                className: 'params',",
        "                variants: [",
        "                  {",
        "                    begin: hljs.UNDERSCORE_IDENT_RE",
        "                  },",
        "                  {",
        "                    className: null,",
        "                    begin: /\\(\\s*\\)/,",
        "                    skip: true",
        "                  },",
        "                  {",
        "                    begin: /\\(/,",
        "                    end: /\\)/,",
        "                    excludeBegin: true,",
        "                    excludeEnd: true,",
        "                    keywords: KEYWORDS,",
        "                    contains: PARAMS_CONTAINS",
        "                  }",
        "                ]",
        "              }",
        "            ]",
        "          },",
        "          { // could be a comma delimited list of params to a function call",
        "            begin: /,/, relevance: 0",
        "          },",
        "          {",
        "            className: '',",
        "            begin: /\\s/,",
        "            end: /\\s*/,",
        "            skip: true",
        "          },",
        "          { // JSX",
        "            variants: [",
        "              { begin: FRAGMENT.begin, end: FRAGMENT.end },",
        "              {",
        "                begin: XML_TAG.begin,",
        "                // we carefully check the opening tag to see if it truly",
        "                // is a tag and not a false positive",
        "                'on:begin': XML_TAG.isTrulyOpeningTag,",
        "                end: XML_TAG.end",
        "              }",
        "            ],",
        "            subLanguage: 'xml',",
        "            contains: [",
        "              {",
        "                begin: XML_TAG.begin,",
        "                end: XML_TAG.end,",
        "                skip: true,",
        "                contains: ['self']",
        "              }",
        "            ]",
        "          }",
        "        ],",
        "        relevance: 0",
        "      },",
        "      {",
        "        className: 'function',",
        "        beginKeywords: 'function',",
        "        end: /[{;]/,",
        "        excludeEnd: true,",
        "        keywords: KEYWORDS,",
        "        contains: [",
        "          'self',",
        "          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE }),",
        "          PARAMS",
        "        ],",
        "        illegal: /%/",
        "      },",
        "      // hack: prevents detection of keywords in some circumstances",
        "      // .keyword()",
        "      // $keyword = x",
        "      {",
        "        variants: [",
        "          { begin: '\\\\.' + IDENT_RE },",
        "          { begin: '\\\\$' + IDENT_RE }",
        "        ],",
        "        relevance: 0",
        "      },",
        "      { // ES6 class",
        "        className: 'class',",
        "        beginKeywords: 'class',",
        "        end: /[{;=]/,",
        "        excludeEnd: true,",
        "        illegal: /[:\"\\[\\]]/,",
        "        contains: [",
        "          { beginKeywords: 'extends' },",
        "          hljs.UNDERSCORE_TITLE_MODE",
        "        ]",
        "      },",
        "      {",
        "        beginKeywords: 'constructor',",
        "        end: /[\\{;]/,",
        "        excludeEnd: true,",
        "        contains: [",
        "          'self',",
        "          PARAMS",
        "        ]",
        "      },",
        "      {",
        "        begin: '(get|set)\\\\s+(?=' + IDENT_RE + '\\\\()',",
        "        end: /{/,",
        "        keywords: \"get set\",",
        "        contains: [",
        "          hljs.inherit(hljs.TITLE_MODE, { begin: IDENT_RE }),",
        "          { begin: /\\(\\)/ }, // eat to avoid empty params",
        "          PARAMS",
        "        ]",
        "      },",
        "      {",
        "        begin: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`",
        "      }",
        "    ]",
        "  };",
        "}"
    ],
    "src/lib/html_renderer.js": [
        "import { escapeHTML } from './utils.js';",
        "",
        "/**",
        " * @typedef {object} Renderer",
        " * @property {(text: string) => void} addText",
        " * @property {(node: Node) => void} openNode",
        " * @property {(node: Node) => void} closeNode",
        " * @property {() => string} value",
        " */",
        "",
        "/** @typedef {{kind?: string, sublanguage?: boolean}} Node */",
        "/** @typedef {{walk: (r: Renderer) => void}} Tree */",
        "/** */",
        "",
        "const SPAN_CLOSE = '</span>';",
        "",
        "/**",
        " * Determines if a node needs to be wrapped in <span>",
        " *",
        " * @param {Node} node */",
        "const emitsWrappingTags = (node) => {",
        "  return !!node.kind;",
        "};",
        "",
        "/** @type {Renderer} */",
        "export default class HTMLRenderer {",
        "  /**",
        "   * Creates a new HTMLRenderer",
        "   *",
        "   * @param {Tree} parseTree - the parse tree (must support `walk` API)",
        "   * @param {{classPrefix: string}} options",
        "   */",
        "  constructor(parseTree, options) {",
        "    this.buffer = \"\";",
        "    this.classPrefix = options.classPrefix;",
        "    parseTree.walk(this);",
        "  }",
        "",
        "  /**",
        "   * Adds texts to the output stream",
        "   *",
        "   * @param {string} text */",
        "  addText(text) {",
        "    this.buffer += escapeHTML(text);",
        "  }",
        "",
        "  /**",
        "   * Adds a node open to the output stream (if needed)",
        "   *",
        "   * @param {Node} node */",
        "  openNode(node) {",
        "    if (!emitsWrappingTags(node)) return;",
        "",
        "    let className = node.kind;",
        "    if (!node.sublanguage) {",
        "      className = `${this.classPrefix}${className}`;",
        "    }",
        "    this.span(className);",
        "  }",
        "",
        "  /**",
        "   * Adds a node close to the output stream (if needed)",
        "   *",
        "   * @param {Node} node */",
        "  closeNode(node) {",
        "    if (!emitsWrappingTags(node)) return;",
        "",
        "    this.buffer += SPAN_CLOSE;",
        "  }",
        "",
        "  /**",
        "   * returns the accumulated buffer",
        "  */",
        "  value() {",
        "    return this.buffer;",
        "  }",
        "",
        "  // helpers",
        "",
        "  /**",
        "   * Builds a span element",
        "   *",
        "   * @param {string} className */",
        "  span(className) {",
        "    this.buffer += `<span class=\"${className}\">`;",
        "  }",
        "}"
    ],
    "src/highlight.js": [
        "...",
        "   * Core highlighting function.",
        "   *",
        "   * @param {string} languageName - the language to use for highlighting",
        "   * @param {string} code - the code to highlight",
        "   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail",
        "   * @param {Mode} [continuation] - current continuation mode, if any",
        "   *",
        "   * @returns {HighlightResult} Result - an object that represents the result",
        "   * @property {string} language - the language name",
        "   * @property {number} relevance - the relevance score",
        "   * @property {string} value - the highlighted HTML code",
        "   * @property {string} code - the original raw code",
        "   * @property {Mode} top - top of the current mode stack",
        "   * @property {boolean} illegal - indicates whether any illegal matches were found",
        "  */",
        "  function highlight(languageName, code, ignoreIllegals, continuation) {",
        "    /** @type {{ code: string, language: string, result?: any }} */",
        "    var context = {",
        "      code,",
        "      language: languageName",
        "    };",
        "    // the plugin can change the desired language or the code to be highlighted",
        "    // just be changing the object it was passed",
        "    fire(\"before:highlight\", context);",
        "",
        "    // a before plugin can usurp the result completely by providing it's own",
        "    // in which case we don't even need to call highlight",
        "    var result = context.result ?",
        "      context.result :",
        "      _highlight(context.language, context.code, ignoreIllegals, continuation);",
        "",
        "    result.code = context.code;",
        "    // the plugin can change anything in result to suite it",
        "    fire(\"after:highlight\", result);",
        "",
        "    return result;",
        "  }",
        "",
        "  /**",
        "   * private highlight that's used internally and does not fire callbacks",
        "   *",
        "   * @param {string} languageName - the language to use for highlighting",
        "   * @param {string} code - the code to highlight",
        "   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail",
        "   * @param {Mode} [continuation] - current continuation mode, if any",
        "  */",
        "  function _highlight(languageName, code, ignoreIllegals, continuation) {",
        "    var codeToHighlight = code;",
        "",
        "    /**",
        "     * Return keyword data if a match is a keyword",
        "     * @param {CompiledMode} mode - current mode",
        "     * @param {RegExpMatchArray} match - regexp match data",
        "     * @returns {KeywordData | false}",
        "     */",
        "    function keywordData(mode, match) {",
        "      var matchText = language.case_insensitive ? match[0].toLowerCase() : match[0];",
        "      return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];",
        "    }",
        "",
        "    function processKeywords() {",
        "      if (!top.keywords) {",
        "        emitter.addText(modeBuffer);",
        "        return;",
        "      }",
        "",
        "      let lastIndex = 0;",
        "      top.keywordPatternRe.lastIndex = 0;",
        "      let match = top.keywordPatternRe.exec(modeBuffer);",
        "      let buf = \"\";",
        "",
        "      while (match) {",
        "        buf += modeBuffer.substring(lastIndex, match.index);",
        "        const data = keywordData(top, match);",
        "        if (data) {",
        "          const [kind, keywordRelevance] = data;",
        "          emitter.addText(buf);",
        "          buf = \"\";",
        "",
        "          relevance += keywordRelevance;",
        "          emitter.addKeyword(match[0], kind);",
        "        } else {",
        "          buf += match[0];",
        "        }",
        "        lastIndex = top.keywordPatternRe.lastIndex;",
        "        match = top.keywordPatternRe.exec(modeBuffer);",
        "      }",
        "      buf += modeBuffer.substr(lastIndex);",
        "      emitter.addText(buf);",
        "    }",
        "",
        "    function processSubLanguage() {",
        "      if (modeBuffer === \"\") return;",
        "      /** @type HighlightResult */",
        "      var result = null;",
        "",
        "      if (typeof top.subLanguage === 'string') {",
        "        if (!languages[top.subLanguage]) {",
        "          emitter.addText(modeBuffer);",
        "          return;",
        "        }",
        "        result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);",
        "        continuations[top.subLanguage] = result.top;",
        "      } else {",
        "        result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);",
        "      }",
        "",
        "      // Counting embedded language score towards the host language may be disabled",
        "      // with zeroing the containing mode relevance. Use case in point is Markdown that",
        "      // allows XML everywhere and makes every XML snippet to have a much larger Markdown",
        "      // score.",
        "      if (top.relevance > 0) {",
        "        relevance += result.relevance;",
        "      }",
        "      emitter.addSublanguage(result.emitter, result.language);",
        "    }",
        "",
        "    function processBuffer() {",
        "      if (top.subLanguage != null) {",
        "        processSubLanguage();",
        "      } else {",
        "        processKeywords();",
        "      }",
        "      modeBuffer = '';",
        "    }",
        "",
        "    /**",
        "     * @param {Mode} mode - new mode to start",
        "     */",
        "    function startNewMode(mode) {",
        "      if (mode.className) {",
        "        emitter.openNode(mode.className);",
        "      }",
        "      top = Object.create(mode, { parent: { value: top } });",
        "      return top;",
        "    }",
        "",
        "    /**",
        "     * @param {CompiledMode } mode - the mode to potentially end",
        "     * @param {RegExpMatchArray} match - the latest match",
        "     * @param {string} matchPlusRemainder - match plus remainder of content",
        "     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode",
        "     */",
        "    function endOfMode(mode, match, matchPlusRemainder) {",
        "      let matched = regex.startsWith(mode.endRe, matchPlusRemainder);",
        "",
        "      if (matched) {",
        "        if (mode[\"on:end\"]) {",
        "          const resp = new Response(mode);",
        "          mode[\"on:end\"](match, resp);",
        "          if (resp.ignore) matched = false;",
        "        }",
        "",
        "        if (matched) {",
        "          while (mode.endsParent && mode.parent) {",
        "            mode = mode.parent;",
        "          }",
        "          return mode;",
        "        }",
        "      }",
        "      // even if on:end fires an `ignore` it's still possible",
        "      // that we might trigger the end node because of a parent mode",
        "      if (mode.endsWithParent) {",
        "        return endOfMode(mode.parent, match, matchPlusRemainder);",
        "      }",
        "    }",
        "",
        "    /**",
        "     * Handle matching but then ignoring a sequence of text",
        "     *",
        "     * @param {string} lexeme - string containing full match text",
        "     */",
        "    function doIgnore(lexeme) {",
        "      if (top.matcher.regexIndex === 0) {",
        "        // no more regexs to potentially match here, so we move the cursor forward one",
        "        // space",
        "        modeBuffer += lexeme[0];",
        "        return 1;",
        "      } else {",
        "        // no need to move the cursor, we still have additional regexes to try and",
        "        // match at this very spot",
        "        resumeScanAtSamePosition = true;",
        "        return 0;",
        "      }",
        "    }",
        "",
        "    /**",
        "     * Handle the start of a new potential mode match",
        "     *",
        "     * @param {EnhancedMatch} match - the current match",
        "     * @returns {number} how far to advance the parse cursor",
        "     */",
        "    function doBeginMatch(match) {",
        "      var lexeme = match[0];",
        "      var newMode = match.rule;",
        "",
        "      const resp = new Response(newMode);",
        "      // first internal before callbacks, then the public ones",
        "      const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];",
        "      for (const cb of beforeCallbacks) {",
        "        if (!cb) continue;",
        "        cb(match, resp);",
        "        if (resp.ignore) return doIgnore(lexeme);",
        "      }",
        "",
        "      if (newMode && newMode.endSameAsBegin) {",
        "        newMode.endRe = regex.escape(lexeme);",
        "      }",
        "",
        "      if (newMode.skip) {",
        "        modeBuffer += lexeme;",
        "      } else {",
        "        if (newMode.excludeBegin) {",
        "          modeBuffer += lexeme;",
        "        }",
        "        processBuffer();",
        "        if (!newMode.returnBegin && !newMode.excludeBegin) {",
        "          modeBuffer = lexeme;",
        "        }",
        "      }",
        "      startNewMode(newMode);",
        "      // if (mode[\"after:begin\"]) {",
        "      //   let resp = new Response(mode);",
        "      //   mode[\"after:begin\"](match, resp);",
        "      // }",
        "      return newMode.returnBegin ? 0 : lexeme.length;",
        "    }",
        "",
        "    /**",
        "     * Handle the potential end of mode",
        "     *",
        "     * @param {RegExpMatchArray} match - the current match",
        "     */",
        "    function doEndMatch(match) {",
        "      var lexeme = match[0];",
        "      var matchPlusRemainder = codeToHighlight.substr(match.index);",
        "",
        "      var endMode = endOfMode(top, match, matchPlusRemainder);",
        "      if (!endMode) { return NO_MATCH; }",
        "",
        "      var origin = top;",
        "      if (origin.skip) {",
        "        modeBuffer += lexeme;",
        "      } else {",
        "        if (!(origin.returnEnd || origin.excludeEnd)) {",
        "          modeBuffer += lexeme;",
        "        }",
        "        processBuffer();",
        "        if (origin.excludeEnd) {",
        "          modeBuffer = lexeme;",
        "        }",
        "      }",
        "      do {",
        "        if (top.className) {",
        "          emitter.closeNode();",
        "        }",
        "        if (!top.skip && !top.subLanguage) {",
        "          relevance += top.relevance;",
        "        }",
        "        top = top.parent;",
        "      } while (top !== endMode.parent);",
        "      if (endMode.starts) {",
        "        if (endMode.endSameAsBegin) {",
        "          endMode.starts.endRe = endMode.endRe;",
        "        }",
        "        startNewMode(endMode.starts);",
        "      }",
        "      return origin.returnEnd ? 0 : lexeme.length;",
        "    }",
        "",
        "    function processContinuations() {",
        "      var list = [];",
        "      for (var current = top; current !== language; current = current.parent) {",
        "        if (current.className) {",
        "          list.unshift(current.className);",
        "        }",
        "      }",
        "      list.forEach(item => emitter.openNode(item));",
        "    }",
        "",
        "    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */",
        "    var lastMatch = {};",
        "",
        "    /**",
        "     *  Process an individual match",
        "     *",
        "     * @param {string} textBeforeMatch - text preceeding the match (since the last match)",
        "     * @param {EnhancedMatch} [match] - the match itself",
        "     */",
        "    function processLexeme(textBeforeMatch, match) {",
        "      var lexeme = match && match[0];",
        "",
        "      // add non-matched text to the current mode buffer",
        "      modeBuffer += textBeforeMatch;",
        "",
        "      if (lexeme == null) {",
        "        processBuffer();",
        "        return 0;",
        "      }",
        "",
        "      // we've found a 0 width match and we're stuck, so we need to advance",
        "      // this happens when we have badly behaved rules that have optional matchers to the degree that",
        "      // sometimes they can end up matching nothing at all",
        "      // Ref: https://github.com/highlightjs/highlight.js/issues/2140",
        "      if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {",
        "        // spit the \"skipped\" character that our regex choked on back into the output sequence",
        "        modeBuffer += codeToHighlight.slice(match.index, match.index + 1);",
        "        if (!SAFE_MODE) {",
        "          /** @type {AnnotatedError} */",
        "          const err = new Error('0 width match regex');",
        "          err.languageName = languageName;",
        "          err.badRule = lastMatch.rule;",
        "          throw err;",
        "        }",
        "        return 1;",
        "      }",
        "      lastMatch = match;",
        "",
        "      if (match.type === \"begin\") {",
        "        return doBeginMatch(match);",
        "      } else if (match.type === \"illegal\" && !ignoreIllegals) {",
        "        // illegal match, we do not continue processing",
        "        /** @type {AnnotatedError} */",
        "        const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.className || '<unnamed>') + '\"');",
        "        err.mode = top;",
        "        throw err;",
        "      } else if (match.type === \"end\") {",
        "        var processed = doEndMatch(match);",
        "        if (processed !== NO_MATCH) {",
        "          return processed;",
        "        }",
        "      }",
        "",
        "      // edge case for when illegal matches $ (end of line) which is technically",
        "      // a 0 width match but not a begin/end match so it's not caught by the",
        "      // first handler (when ignoreIllegals is true)",
        "      if (match.type === \"illegal\" && lexeme === \"\") {",
        "        // advance so we aren't stuck in an infinite loop",
        "        return 1;",
        "      }",
        "",
        "      // infinite loops are BAD, this is a last ditch catch all. if we have a",
        "      // decent number of iterations yet our index (cursor position in our",
        "      // parsing) still 3x behind our index then something is very wrong",
        "      // so we bail",
        "      if (iterations > 100000 && iterations > match.index * 3) {",
        "        const err = new Error('potential infinite loop, way more iterations than matches');",
        "        throw err;",
        "      }",
        "",
        "      /*",
        "      Why might be find ourselves here?  Only one occasion now.  An end match that was",
        "      triggered but could not be completed.  When might this happen?  When an `endSameasBegin`",
        "      rule sets the end rule to a specific match.  Since the overall mode termination rule that's",
        "      being used to scan the text isn't recompiled that means that any match that LOOKS like",
        "      the end (but is not, because it is not an exact match to the beginning) will",
        "      end up here.  A definite end match, but when `doEndMatch` tries to \"reapply\"",
        "      the end rule and fails to match, we wind up here, and just silently ignore the end.",
        "",
        "      This causes no real harm other than stopping a few times too many.",
        "      */",
        "",
        "      modeBuffer += lexeme;",
        "      return lexeme.length;",
        "    }",
        "",
        "    var language = getLanguage(languageName);",
        "    if (!language) {",
        "      console.error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));",
        "      throw new Error('Unknown language: \"' + languageName + '\"');",
        "    }",
        "",
        "    var md = compileLanguage(language);",
        "    var result = '';",
        "    /** @type {CompiledMode} */",
        "    var top = continuation || md;",
        "    /** @type Record<string,Mode> */",
        "    var continuations = {}; // keep continuations for sub-languages",
        "    var emitter = new options.__emitter(options);",
        "    processContinuations();",
        "    var modeBuffer = '';",
        "    var relevance = 0;",
        "    var index = 0;",
        "    var iterations = 0;",
        "    var resumeScanAtSamePosition = false;",
        "",
        "    try {",
        "      top.matcher.considerAll();",
        "",
        "      for (;;) {",
        "        iterations++;",
        "        if (resumeScanAtSamePosition) {",
        "          // only regexes not matched previously will now be",
        "          // considered for a potential match",
        "          resumeScanAtSamePosition = false;",
        "        } else {",
        "          top.matcher.considerAll();",
        "        }",
        "        top.matcher.lastIndex = index;",
        "",
        "        const match = top.matcher.exec(codeToHighlight);",
        "        // console.log(\"match\", match[0], match.rule && match.rule.begin)",
        "",
        "        if (!match) break;",
        "",
        "        const beforeMatch = codeToHighlight.substring(index, match.index);",
        "        const processedCount = processLexeme(beforeMatch, match);",
        "        index = match.index + processedCount;",
        "      }",
        "      processLexeme(codeToHighlight.substr(index));",
        "      emitter.closeAllNodes();",
        "      emitter.finalize();",
        "      result = emitter.toHTML();",
        "",
        "      return {",
        "        relevance: relevance,",
        "        value: result,",
        "        language: languageName,",
        "        illegal: false,",
        "        emitter: emitter,",
        "        top: top",
        "      };",
        "    } catch (err) {",
        "      if (err.message && err.message.includes('Illegal')) {",
        "        return {",
        "          illegal: true,",
        "          illegalBy: {",
        "            msg: err.message,",
        "            context: codeToHighlight.slice(index - 100, index + 100),",
        "            mode: err.mode",
        "          },",
        "          sofar: result,",
        "          relevance: 0,",
        "          value: escape(codeToHighlight),",
        "          emitter: emitter",
        "        };",
        "      } else if (SAFE_MODE) {",
        "        return {",
        "          illegal: false,",
        "          relevance: 0,",
        "          value: escape(codeToHighlight),",
        "          emitter: emitter,",
        "          language: languageName,",
        "          top: top,",
        "          errorRaised: err",
        "        };",
        "      } else {",
        "        throw err;",
        "      }",
        "    }",
        "  }",
        "",
        "  /**",
        "   * returns a valid highlight result, without actually doing any actual work,",
        "   * auto highlight starts with this and it's possible for small snippets that",
        "   * auto-detection may not find a better match",
        "   * @param {string} code",
        "   * @returns {HighlightResult}",
        "   */",
        "  function justTextHighlightResult(code) {",
        "    const result = {",
        "      relevance: 0,",
        "      emitter: new options.__emitter(options),",
        "      value: escape(code),",
        "      illegal: false,",
        "      top: PLAINTEXT_LANGUAGE",
        "    };",
        "    result.emitter.addText(code);",
        "    return result;",
        "  }",
        "",
        "  /**",
        "  Highlighting with language detection. Accepts a string with the code to",
        "  highlight. Returns an object with the following properties:",
        "",
        "  - language (detected language)",
        "  - relevance (int)",
        "  - value (an HTML string with highlighting markup)",
        "  - second_best (object with the same structure for second-best heuristically",
        "    detected language, may be absent)",
        "",
        "    @param {string} code",
        "    @param {Array<string>} [languageSubset]",
        "    @returns {AutoHighlightResult}",
        "  */",
        "  function highlightAuto(code, languageSubset) {",
        "    languageSubset = languageSubset || options.languages || Object.keys(languages);",
        "    var result = justTextHighlightResult(code);",
        "    var secondBest = result;",
        "    languageSubset.filter(getLanguage).filter(autoDetection).forEach(function(name) {",
        "      var current = _highlight(name, code, false);",
        "      current.language = name;",
        "      if (current.relevance > secondBest.relevance) {",
        "        secondBest = current;",
        "      }",
        "      if (current.relevance > result.relevance) {",
        "        secondBest = result;",
        "        result = current;",
        "      }",
        "    });",
        "    if (secondBest.language) {",
        "..."
    ]
}