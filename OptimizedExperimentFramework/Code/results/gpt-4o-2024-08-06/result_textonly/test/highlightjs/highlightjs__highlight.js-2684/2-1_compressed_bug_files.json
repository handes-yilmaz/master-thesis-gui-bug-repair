{
    "1": {
        "bug_file": "src/languages/bash.js",
        "compressed": "NO",
        "line_numbers": 126,
        "compressed_line_numbers": 126,
        "compressed_bug_file_content": "/*\nLanguage: Bash\nAuthor: vah <vahtenberg@gmail.com>\nContributrors: Benjamin Pannell <contact@sierrasoftworks.com>\nWebsite: https://www.gnu.org/software/bash/\nCategory: common\n*/\n\n/** @type LanguageFn */\nexport default function(hljs) {\n  const VAR = {};\n  const BRACED_VAR = {\n    begin: /\\$\\{/,\n    end:/\\}/,\n    contains: [\n      \"self\",\n      {\n        begin: /:-/,\n        contains: [ VAR ]\n      } // default values\n    ]\n  };\n  Object.assign(VAR,{\n    className: 'variable',\n    variants: [\n      {begin: /\\$[\\w\\d#@][\\w\\d_]*/},\n      BRACED_VAR\n    ]\n  });\n\n  const SUBST = {\n    className: 'subst',\n    begin: /\\$\\(/, end: /\\)/,\n    contains: [hljs.BACKSLASH_ESCAPE]\n  };\n  const QUOTE_STRING = {\n    className: 'string',\n    begin: /\"/, end: /\"/,\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      VAR,\n      SUBST\n    ]\n  };\n  SUBST.contains.push(QUOTE_STRING);\n  const ESCAPED_QUOTE = {\n    className: '',\n    begin: /\\\\\"/\n\n  };\n  const APOS_STRING = {\n    className: 'string',\n    begin: /'/, end: /'/\n  };\n  const ARITHMETIC = {\n    begin: /\\$\\(\\(/,\n    end: /\\)\\)/,\n    contains: [\n      { begin: /\\d+#[0-9a-f]+/, className: \"number\" },\n      hljs.NUMBER_MODE,\n      VAR\n    ]\n  };\n  const SH_LIKE_SHELLS = [\n    \"fish\",\n    \"bash\",\n    \"zsh\",\n    \"sh\",\n    \"csh\",\n    \"ksh\",\n    \"tcsh\",\n    \"dash\",\n    \"scsh\",\n  ];\n  const KNOWN_SHEBANG = hljs.SHEBANG({\n    binary: `(${SH_LIKE_SHELLS.join(\"|\")})`,\n    relevance: 10\n  });\n  const FUNCTION = {\n    className: 'function',\n    begin: /\\w[\\w\\d_]*\\s*\\(\\s*\\)\\s*\\{/,\n    returnBegin: true,\n    contains: [hljs.inherit(hljs.TITLE_MODE, {begin: /\\w[\\w\\d_]*/})],\n    relevance: 0\n  };\n\n  return {\n    name: 'Bash',\n    aliases: ['sh', 'zsh'],\n    keywords: {\n      $pattern: /\\b[a-z._-]+\\b/,\n      keyword:\n        'if then else elif fi for while in do done case esac function',\n      literal:\n        'true false',\n      built_in:\n        // Shell built-ins\n        // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n        'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' +\n        'trap umask unset ' +\n        // Bash built-ins\n        'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' +\n        'read readarray source type typeset ulimit unalias ' +\n        // Shell modifiers\n        'set shopt ' +\n        // Zsh built-ins\n        'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' +\n        'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' +\n        'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' +\n        'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' +\n        'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' +\n        'zpty zregexparse zsocket zstyle ztcp'\n    },\n    contains: [\n      KNOWN_SHEBANG, // to catch known shells and boost relevancy\n      hljs.SHEBANG(), // to catch unknown shells but still highlight the shebang\n      FUNCTION,\n      ARITHMETIC,\n      hljs.HASH_COMMENT_MODE,\n      QUOTE_STRING,\n      ESCAPED_QUOTE,\n      APOS_STRING,\n      VAR\n    ]\n  };\n}"
    },
    "2": {
        "bug_file": "src/languages/shell.js",
        "compressed": "NO",
        "line_numbers": 22,
        "compressed_line_numbers": 22,
        "compressed_bug_file_content": "/*\nLanguage: Shell Session\nRequires: bash.js\nAuthor: TSUYUSATO Kitsune <make.just.on@gmail.com>\nCategory: common\n*/\n\nexport default function(hljs) {\n  return {\n    name: 'Shell Session',\n    aliases: ['console'],\n    contains: [\n      {\n        className: 'meta',\n        begin: '^\\\\s{0,3}[/\\\\w\\\\d\\\\[\\\\]()@-]*[>%$#]',\n        starts: {\n          end: '$', subLanguage: 'bash'\n        }\n      }\n    ]\n  }\n}"
    },
    "3": {
        "bug_file": "src/lib/modes.js",
        "compressed": "NO",
        "line_numbers": 169,
        "compressed_line_numbers": 169,
        "compressed_bug_file_content": "import { inherit } from './utils.js';\nimport * as regex from './regex.js';\n\n// Common regexps\nexport const IDENT_RE = '[a-zA-Z]\\\\w*';\nexport const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\\\w*';\nexport const NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\nexport const C_NUMBER_RE = '(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\nexport const BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\nexport const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n\n/**\n* @param { Partial<Mode> & {binary?: string | RegExp} } opts\n*/\nexport const SHEBANG = (opts = {}) => {\n  const beginShebang = /^#![ ]*\\//;\n  if (opts.binary) {\n    opts.begin = regex.concat(\n      beginShebang,\n      /.*\\b/,\n      opts.binary,\n      /\\b.*/);\n  }\n  return inherit({\n    className: 'meta',\n    begin: beginShebang,\n    end: /$/,\n    relevance: 0,\n    /** @type {ModeCallback} */\n    \"on:begin\": (m, resp) => {\n      if (m.index !== 0) resp.ignoreMatch();\n    }\n  }, opts);\n};\n\n// Common modes\nexport const BACKSLASH_ESCAPE = {\n  begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n};\nexport const APOS_STRING_MODE = {\n  className: 'string',\n  begin: '\\'',\n  end: '\\'',\n  illegal: '\\\\n',\n  contains: [BACKSLASH_ESCAPE]\n};\nexport const QUOTE_STRING_MODE = {\n  className: 'string',\n  begin: '\"',\n  end: '\"',\n  illegal: '\\\\n',\n  contains: [BACKSLASH_ESCAPE]\n};\nexport const PHRASAL_WORDS_MODE = {\n  begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n};\n/**\n * Creates a comment mode\n *\n * @param {string | RegExp} begin\n * @param {string | RegExp} end\n * @param {Mode | {}} [modeOptions]\n * @returns {Partial<Mode>}\n */\nexport const COMMENT = function(begin, end, modeOptions = {}) {\n  var mode = inherit(\n    {\n      className: 'comment',\n      begin,\n      end,\n      contains: []\n    },\n    modeOptions\n  );\n  mode.contains.push(PHRASAL_WORDS_MODE);\n  mode.contains.push({\n    className: 'doctag',\n    begin: '(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):',\n    relevance: 0\n  });\n  return mode;\n};\nexport const C_LINE_COMMENT_MODE = COMMENT('//', '$');\nexport const C_BLOCK_COMMENT_MODE = COMMENT('/\\\\*', '\\\\*/');\nexport const HASH_COMMENT_MODE = COMMENT('#', '$');\nexport const NUMBER_MODE = {\n  className: 'number',\n  begin: NUMBER_RE,\n  relevance: 0\n};\nexport const C_NUMBER_MODE = {\n  className: 'number',\n  begin: C_NUMBER_RE,\n  relevance: 0\n};\nexport const BINARY_NUMBER_MODE = {\n  className: 'number',\n  begin: BINARY_NUMBER_RE,\n  relevance: 0\n};\nexport const CSS_NUMBER_MODE = {\n  className: 'number',\n  begin: NUMBER_RE + '(' +\n    '%|em|ex|ch|rem' +\n    '|vw|vh|vmin|vmax' +\n    '|cm|mm|in|pt|pc|px' +\n    '|deg|grad|rad|turn' +\n    '|s|ms' +\n    '|Hz|kHz' +\n    '|dpi|dpcm|dppx' +\n    ')?',\n  relevance: 0\n};\nexport const REGEXP_MODE = {\n  // this outer rule makes sure we actually have a WHOLE regex and not simply\n  // an expression such as:\n  //\n  //     3 / something\n  //\n  // (which will then blow up when regex's `illegal` sees the newline)\n  begin: /(?=\\/[^/\\n]*\\/)/,\n  contains: [{\n    className: 'regexp',\n    begin: /\\//,\n    end: /\\/[gimuy]*/,\n    illegal: /\\n/,\n    contains: [\n      BACKSLASH_ESCAPE,\n      {\n        begin: /\\[/,\n        end: /\\]/,\n        relevance: 0,\n        contains: [BACKSLASH_ESCAPE]\n      }\n    ]\n  }]\n};\nexport const TITLE_MODE = {\n  className: 'title',\n  begin: IDENT_RE,\n  relevance: 0\n};\nexport const UNDERSCORE_TITLE_MODE = {\n  className: 'title',\n  begin: UNDERSCORE_IDENT_RE,\n  relevance: 0\n};\nexport const METHOD_GUARD = {\n  // excludes method names from keyword processing\n  begin: '\\\\.\\\\s*' + UNDERSCORE_IDENT_RE,\n  relevance: 0\n};\n\n/**\n * Adds end same as begin mechanics to a mode\n *\n * Your mode must include at least a single () match group as that first match\n * group is what is used for comparison\n * @param {Partial<Mode>} mode\n */\nexport const END_SAME_AS_BEGIN = function(mode) {\n  return Object.assign(mode,\n    {\n      /** @type {ModeCallback} */\n      'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },\n      /** @type {ModeCallback} */\n      'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }\n    });\n};"
    },
    "4": {
        "bug_file": "src/highlight.js",
        "compressed": "YES",
        "line_numbers": 889,
        "compressed_line_numbers": 390,
        "compressed_bug_file_content": "/*\n\n\n*/\n\nimport deepFreeze from './vendor/deep_freeze.js';\nimport Response from './lib/response.js';\nimport TokenTreeEmitter from './lib/token_tree.js';\nimport * as regex from './lib/regex.js';\nimport * as utils from './lib/utils.js';\nimport * as MODES from './lib/modes.js';\nimport { compileLanguage } from './lib/mode_compiler.js';\nimport * as packageJSON from '../package.json';\nimport { VuePlugin } from \"./plugins/vue.js\";\n\n\n/**\n * @param {any} hljs - object that is extended (legacy)\n * @returns {HLJSApi}\n */\n\n  // Convenience variables for build-in objects\n  /** @type {unknown[]} */\n\n\n  // Global internal variables used within the highlight.js library.\n  /** @type {Record<string, Language>} */\n\n  /** @type {Record<string, string>} */\n\n  /** @type {HLJSPlugin[]} */\n\n\n  // safe/production mode - swallows more errors, tries to keep running\n  // even if a single syntax or parse hits a fatal error\n\n\n  /** @type {Language} */\n\n\n  // Global options used when within external APIs. This is modified when\n  // calling the `hljs.configure` function.\n  /** @type HLJSOptions */\n\n\n    // beta configuration options, subject to change, welcome to discuss\n    // https://github.com/highlightjs/highlight.js/issues/1086\n\n\n  /* Utility functions */\n\n  /**\n   * Tests a language name to see if highlighting should be skipped\n   * @param {string} languageName\n   */\n\n\n  /**\n   * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n   */\n\n\n    // language-* takes precedence over non-prefixed class names.\n\n\n  /**\n   * Core highlighting function.\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} code - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {Mode} [continuation] - current continuation mode, if any\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {Mode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found\n  */\n\n    /** @type {{ code: string, language: string, result?: any }} */\n\n\n    // the plugin can change the desired language or the code to be highlighted\n    // just be changing the object it was passed\n\n\n    // a before plugin can usurp the result completely by providing it's own\n    // in which case we don't even need to call highlight\n\n\n    // the plugin can change anything in result to suite it\n\n\n  /**\n   * private highlight that's used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} code - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {Mode} [continuation] - current continuation mode, if any\n  */\n\n\n    /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {RegExpMatchArray} match - regexp match data\n     * @returns {KeywordData | false}\n     */\n\n\n      /** @type HighlightResult */\n\n\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Use case in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n\n\n    /**\n     * @param {Mode} mode - new mode to start\n     */\n\n\n    /**\n     * @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n     */\n\n\n      // even if on:end fires an `ignore` it's still possible\n      // that we might trigger the end node because of a parent mode\n\n\n    /**\n     * Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text\n     */\n\n\n        // no more regexs to potentially match here, so we move the cursor forward one\n        // space\n\n\n        // no need to move the cursor, we still have additional regexes to try and\n        // match at this very spot\n\n\n    /**\n     * Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor\n     */\n\n\n      // first internal before callbacks, then the public ones\n\n\n      // if (mode[\"after:begin\"]) {\n      //   let resp = new Response(mode);\n      //   mode[\"after:begin\"](match, resp);\n      // }\n\n\n    /**\n     * Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match\n     */\n\n\n    /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */\n\n\n    /**\n     *  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceeding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself\n     */\n\n\n      // add non-matched text to the current mode buffer\n\n\n      // we've found a 0 width match and we're stuck, so we need to advance\n      // this happens when we have badly behaved rules that have optional matchers to the degree that\n      // sometimes they can end up matching nothing at all\n      // Ref: https://github.com/highlightjs/highlight.js/issues/2140\n\n        // spit the \"skipped\" character that our regex choked on back into the output sequence\n\n\n          /** @type {AnnotatedError} */\n\n\n        // illegal match, we do not continue processing\n        /** @type {AnnotatedError} */\n\n\n      // edge case for when illegal matches $ (end of line) which is technically\n      // a 0 width match but not a begin/end match so it's not caught by the\n      // first handler (when ignoreIllegals is true)\n\n        // advance so we aren't stuck in an infinite loop\n\n\n      // infinite loops are BAD, this is a last ditch catch all. if we have a\n      // decent number of iterations yet our index (cursor position in our\n      // parsing) still 3x behind our index then something is very wrong\n      // so we bail\n\n\n      /*\n\n\n      */\n\n\n    /** @type {CompiledMode} */\n\n    /** @type Record<string,Mode> */\n\n\n          // only regexes not matched previously will now be\n          // considered for a potential match\n\n\n        // console.log(\"match\", match[0], match.rule && match.rule.begin)\n\n\n  /**\n   * returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it's possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}\n   */\n\n\n  /**\n\n\n  */\n\n\n      // second_best (with underscore) is the expected API\n\n\n  /**\n\n\n  */\n\n\n  /**\n   * Builds new class name for block given the language name\n   *\n   * @param {string} prevClassName\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]\n   */\n\n\n  /**\n   * Applies highlighting to a DOM node containing code. Accepts a DOM node and\n   * two optional parameters for fixMarkup.\n   *\n   * @param {HighlightedHTMLElement} element - the HTML element to highlight\n  */\n\n    /** @type HTMLElement */\n\n\n      // TODO: remove with version 11.0\n\n\n        // TODO: remove with version 11.0\n\n\n  /**\n   * Updates highlight.js global options with the passed options\n   *\n   * @param {{}} userOptions\n   */\n\n\n  /**\n   * Highlights to all <pre><code> blocks on a page\n   *\n   * @type {Function & {called?: boolean}}\n   */\n\n\n  // Higlights all when DOMContentLoaded fires\n\n    // @ts-ignore\n\n\n  /**\n   * Register a language grammar module\n   *\n   * @param {string} languageName\n   * @param {LanguageFn} languageDefinition\n   */\n\n\n      // hard or soft error\n\n      // languages that have serious errors are replaced with essentially a\n      // \"plaintext\" stand-in so that the code blocks will still get normal\n      // css classes applied to them - and one bad language won't break the\n      // entire highlighter\n\n\n    // give it a temporary name if it doesn't have one in the meta-data\n\n\n  /**\n   * @returns {string[]} List of language internal names\n   */\n\n\n  /**\n\n\n  */\n\n\n  /**\n   * @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}\n   */\n\n\n  /**\n   *\n   * @param {string|string[]} aliasList - single alias or list of aliases\n   * @param {{languageName: string}} opts\n   */\n\n\n  /**\n   * Determines if a given language has auto-detection enabled\n   * @param {string} name - name of the language\n   */\n\n\n  /**\n   * @param {HLJSPlugin} plugin\n   */\n\n\n  /**\n   *\n   * @param {PluginEvent} event\n   * @param {any} args\n   */\n\n\n  /**\n\n\n  */\n\n\n  /* Interface definition */\n\n\n    // plugins for frameworks\n\n\n    // @ts-ignore\n\n      // @ts-ignore\n\n\n  // merge all the modes/regexs into our main object\n\n\n// export an \"instance\" of the highlighter\nexport default HLJS({});\n"
    }
}