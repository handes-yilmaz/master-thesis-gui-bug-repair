{
    "bug_classes": {
        "1": {
            "class_name": "LabelBehavior (not found) ",
            "file_path": "lib/features/modeling/behavior/LabelBehavior.js",
            "class_details": [
                {
                    "name": "LabelBehavior",
                    "start_line": 1,
                    "end_line": 402
                }
            ],
            "class_code": [
                "import {",
                "  assign",
                "} from 'min-dash';",
                "",
                "import inherits from 'inherits';",
                "",
                "import {",
                "  is,",
                "  getBusinessObject",
                "} from '../../../util/ModelUtil';",
                "",
                "import {",
                "  isLabelExternal,",
                "  getExternalLabelMid,",
                "  hasExternalLabel,",
                "  isLabel",
                "} from '../../../util/LabelUtil';",
                "",
                "import {",
                "  getLabel",
                "} from '../../label-editing/LabelUtil';",
                "",
                "import {",
                "  getLabelAdjustment",
                "} from './util/LabelLayoutUtil';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "",
                "import {",
                "  getNewAttachPoint",
                "} from 'diagram-js/lib/util/AttachUtil';",
                "",
                "import {",
                "  getMid,",
                "  roundPoint",
                "} from 'diagram-js/lib/layout/LayoutUtil';",
                "",
                "import {",
                "  delta",
                "} from 'diagram-js/lib/util/PositionUtil';",
                "",
                "import {",
                "  sortBy",
                "} from 'min-dash';",
                "",
                "import {",
                "  getDistancePointLine,",
                "  perpendicularFoot",
                "} from './util/GeometricUtil';",
                "",
                "var DEFAULT_LABEL_DIMENSIONS = {",
                "  width: 90,",
                "  height: 20",
                "};",
                "",
                "var NAME_PROPERTY = 'name';",
                "var TEXT_PROPERTY = 'text';",
                "",
                "/**",
                " * A component that makes sure that external labels are added",
                " * together with respective elements and properly updated (DI wise)",
                " * during move.",
                " *",
                " * @param {EventBus} eventBus",
                " * @param {Modeling} modeling",
                " * @param {BpmnFactory} bpmnFactory",
                " * @param {TextRenderer} textRenderer",
                " */",
                "export default function LabelBehavior(",
                "    eventBus, modeling, bpmnFactory,",
                "    textRenderer) {",
                "",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  // update label if name property was updated",
                "  this.postExecute('element.updateProperties', function(e) {",
                "    var context = e.context,",
                "        element = context.element,",
                "        properties = context.properties;",
                "",
                "    if (NAME_PROPERTY in properties) {",
                "      modeling.updateLabel(element, properties[NAME_PROPERTY]);",
                "    }",
                "",
                "    if (TEXT_PROPERTY in properties",
                "        && is(element, 'bpmn:TextAnnotation')) {",
                "",
                "      var newBounds = textRenderer.getTextAnnotationBounds(",
                "        {",
                "          x: element.x,",
                "          y: element.y,",
                "          width: element.width,",
                "          height: element.height",
                "        },",
                "        properties[TEXT_PROPERTY] || ''",
                "      );",
                "",
                "      modeling.updateLabel(element, properties.text, newBounds);",
                "    }",
                "  });",
                "",
                "  // create label shape after shape/connection was created",
                "  this.postExecute([ 'shape.create', 'connection.create' ], function(e) {",
                "    var context = e.context,",
                "        hints = context.hints || {};",
                "",
                "    if (hints.createElementsBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    var element = context.shape || context.connection,",
                "        businessObject = element.businessObject;",
                "",
                "    if (isLabel(element) || !isLabelExternal(element)) {",
                "      return;",
                "    }",
                "",
                "    // only create label if attribute available",
                "    if (!getLabel(element)) {",
                "      return;",
                "    }",
                "",
                "    var labelCenter = getExternalLabelMid(element);",
                "",
                "    // we don't care about x and y",
                "    var labelDimensions = textRenderer.getExternalLabelBounds(",
                "      DEFAULT_LABEL_DIMENSIONS,",
                "      getLabel(element)",
                "    );",
                "",
                "    modeling.createLabel(element, labelCenter, {",
                "      id: businessObject.id + '_label',",
                "      businessObject: businessObject,",
                "      width: labelDimensions.width,",
                "      height: labelDimensions.height",
                "    });",
                "  });",
                "",
                "  // update label after label shape was deleted",
                "  this.postExecute('shape.delete', function(event) {",
                "    var context = event.context,",
                "        labelTarget = context.labelTarget,",
                "        hints = context.hints || {};",
                "",
                "    // check if label",
                "    if (labelTarget && hints.unsetLabel !== false) {",
                "      modeling.updateLabel(labelTarget, null, null, { removeShape: false });",
                "    }",
                "  });",
                "",
                "  // update di information on label creation",
                "  this.postExecute([ 'label.create' ], function(event) {",
                "",
                "    var context = event.context,",
                "        element = context.shape,",
                "        businessObject,",
                "        di;",
                "",
                "    // we want to trigger on real labels only",
                "    if (!element.labelTarget) {",
                "      return;",
                "    }",
                "",
                "    // we want to trigger on BPMN elements only",
                "    if (!is(element.labelTarget || element, 'bpmn:BaseElement')) {",
                "      return;",
                "    }",
                "",
                "    businessObject = element.businessObject,",
                "    di = businessObject.di;",
                "",
                "",
                "    if (!di.label) {",
                "      di.label = bpmnFactory.create('bpmndi:BPMNLabel', {",
                "        bounds: bpmnFactory.create('dc:Bounds')",
                "      });",
                "    }",
                "",
                "    assign(di.label.bounds, {",
                "      x: element.x,",
                "      y: element.y,",
                "      width: element.width,",
                "      height: element.height",
                "    });",
                "  });",
                "",
                "  function getVisibleLabelAdjustment(event) {",
                "",
                "    var context = event.context,",
                "        connection = context.connection,",
                "        label = connection.label,",
                "        hints = assign({}, context.hints),",
                "        newWaypoints = context.newWaypoints || connection.waypoints,",
                "        oldWaypoints = context.oldWaypoints;",
                "",
                "",
                "    if (typeof hints.startChanged === 'undefined') {",
                "      hints.startChanged = !!hints.connectionStart;",
                "    }",
                "",
                "    if (typeof hints.endChanged === 'undefined') {",
                "      hints.endChanged = !!hints.connectionEnd;",
                "    }",
                "",
                "    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);",
                "  }",
                "",
                "  this.postExecute([",
                "    'connection.layout',",
                "    'connection.updateWaypoints'",
                "  ], function(event) {",
                "    var context = event.context,",
                "        hints = context.hints || {};",
                "",
                "    if (hints.labelBehavior === false) {",
                "      return;",
                "    }",
                "",
                "    var connection = context.connection,",
                "        label = connection.label,",
                "        labelAdjustment;",
                "",
                "    // handle missing label as well as the case",
                "    // that the label parent does not exist (yet),",
                "    // because it is being pasted / created via multi element create",
                "    //",
                "    // Cf. https://github.com/bpmn-io/bpmn-js/pull/1227",
                "    if (!label || !label.parent) {",
                "      return;",
                "    }",
                "",
                "    labelAdjustment = getVisibleLabelAdjustment(event);",
                "",
                "    modeling.moveShape(label, labelAdjustment);",
                "  });",
                "",
                "",
                "  // keep label position on shape replace",
                "  this.postExecute([ 'shape.replace' ], function(event) {",
                "    var context = event.context,",
                "        newShape = context.newShape,",
                "        oldShape = context.oldShape;",
                "",
                "    var businessObject = getBusinessObject(newShape);",
                "",
                "    if (businessObject",
                "      && isLabelExternal(businessObject)",
                "      && oldShape.label",
                "      && newShape.label) {",
                "      newShape.label.x = oldShape.label.x;",
                "      newShape.label.y = oldShape.label.y;",
                "    }",
                "  });",
                "",
                "",
                "  // move external label after resizing",
                "  this.postExecute('shape.resize', function(event) {",
                "",
                "    var context = event.context,",
                "        shape = context.shape,",
                "        newBounds = context.newBounds,",
                "        oldBounds = context.oldBounds;",
                "",
                "    if (hasExternalLabel(shape)) {",
                "",
                "      var label = shape.label,",
                "          labelMid = getMid(label),",
                "          edges = asEdges(oldBounds);",
                "",
                "      // get nearest border point to label as reference point",
                "      var referencePoint = getReferencePoint(labelMid, edges);",
                "",
                "      var delta = getReferencePointDelta(referencePoint, oldBounds, newBounds);",
                "",
                "      modeling.moveShape(label, delta);",
                "",
                "    }",
                "",
                "  });",
                "",
                "}",
                "",
                "inherits(LabelBehavior, CommandInterceptor);",
                "",
                "LabelBehavior.$inject = [",
                "  'eventBus',",
                "  'modeling',",
                "  'bpmnFactory',",
                "  'textRenderer'",
                "];",
                "",
                "// helpers //////////////////////",
                "",
                "/**",
                " * Calculates a reference point delta relative to a new position",
                " * of a certain element's bounds",
                " *",
                " * @param {Point} point",
                " * @param {Bounds} oldBounds",
                " * @param {Bounds} newBounds",
                " *",
                " * @return {Delta} delta",
                " */",
                "export function getReferencePointDelta(referencePoint, oldBounds, newBounds) {",
                "",
                "  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);",
                "",
                "  return roundPoint(delta(newReferencePoint, referencePoint));",
                "}",
                "",
                "/**",
                " * Generates the nearest point (reference point) for a given point",
                " * onto given set of lines",
                " *",
                " * @param {Array<Point, Point>} lines",
                " * @param {Point} point",
                " *",
                " * @param {Point}",
                " */",
                "export function getReferencePoint(point, lines) {",
                "",
                "  if (!lines.length) {",
                "    return;",
                "  }",
                "",
                "  var nearestLine = getNearestLine(point, lines);",
                "",
                "  return perpendicularFoot(point, nearestLine);",
                "}",
                "",
                "/**",
                " * Convert the given bounds to a lines array containing all edges",
                " *",
                " * @param {Bounds|Point} bounds",
                " *",
                " * @return Array<Point>",
                " */",
                "export function asEdges(bounds) {",
                "  return [",
                "    [ // top",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y",
                "      }",
                "    ],",
                "    [ // right",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ],",
                "    [ // bottom",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y + (bounds.height || 0)",
                "      },",
                "      {",
                "        x: bounds.x + (bounds.width || 0),",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ],",
                "    [ // left",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y",
                "      },",
                "      {",
                "        x: bounds.x,",
                "        y: bounds.y + (bounds.height || 0)",
                "      }",
                "    ]",
                "  ];",
                "}",
                "",
                "/**",
                " * Returns the nearest line for a given point by distance",
                " * @param {Point} point",
                " * @param Array<Point> lines",
                " *",
                " * @return Array<Point>",
                " */",
                "function getNearestLine(point, lines) {",
                "",
                "  var distances = lines.map(function(l) {",
                "    return {",
                "      line: l,",
                "      distance: getDistancePointLine(point, l)",
                "    };",
                "  });",
                "",
                "  var sorted = sortBy(distances, 'distance');",
                "",
                "  return sorted[0].line;",
                "}"
            ]
        },
        "2": {
            "class_name": "  (not found) ",
            "file_path": "lib/features/modeling/behavior/util/LabelLayoutUtil.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 222
                }
            ],
            "class_code": [
                "import {",
                "  getDistancePointPoint,",
                "  rotateVector,",
                "  getAngle",
                "} from './GeometricUtil';",
                "",
                "import {",
                "  getAttachment",
                "} from './LineAttachmentUtil';",
                "",
                "import {",
                "  roundPoint",
                "} from 'diagram-js/lib/layout/LayoutUtil';",
                "",
                "",
                "export function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {",
                "",
                "  var index = attachment.segmentIndex;",
                "",
                "  var offset = newWaypoints.length - oldWaypoints.length;",
                "",
                "  // segmentMove happened",
                "  if (hints.segmentMove) {",
                "",
                "    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,",
                "        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;",
                "",
                "    // if label was on moved segment return new segment index",
                "    if (index === oldSegmentStartIndex) {",
                "      return newSegmentStartIndex;",
                "    }",
                "",
                "    // label is after new segment index",
                "    if (index >= newSegmentStartIndex) {",
                "      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;",
                "    }",
                "",
                "    // if label is before new segment index",
                "    return index;",
                "  }",
                "",
                "  // bendpointMove happened",
                "  if (hints.bendpointMove) {",
                "",
                "    var insert = hints.bendpointMove.insert,",
                "        bendpointIndex = hints.bendpointMove.bendpointIndex,",
                "        newIndex;",
                "",
                "    // waypoints length didnt change",
                "    if (offset === 0) {",
                "      return index;",
                "    }",
                "",
                "    // label behind new/removed bendpoint",
                "    if (index >= bendpointIndex) {",
                "      newIndex = insert ? index + 1 : index - 1;",
                "    }",
                "",
                "    // label before new/removed bendpoint",
                "    if (index < bendpointIndex) {",
                "",
                "      newIndex = index;",
                "",
                "      // decide label should take right or left segment",
                "      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {",
                "",
                "        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);",
                "",
                "        if (rel < attachment.relativeLocation) {",
                "          newIndex++;",
                "        }",
                "      }",
                "    }",
                "",
                "    return newIndex;",
                "  }",
                "",
                "  // start/end changed",
                "  if (offset === 0) {",
                "    return index;",
                "  }",
                "",
                "  if (hints.connectionStart) {",
                "    return (index === 0) ? 0 : null;",
                "  }",
                "",
                "  if (hints.connectionEnd) {",
                "    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;",
                "  }",
                "",
                "  // if nothing fits, return null",
                "  return null;",
                "}",
                "",
                "",
                "/**",
                " * Calculate the required adjustment (move delta) for the given label",
                " * after the connection waypoints got updated.",
                " *",
                " * @param {djs.model.Label} label",
                " * @param {Array<Point>} newWaypoints",
                " * @param {Array<Point>} oldWaypoints",
                " * @param {Object} hints",
                " *",
                " * @return {Point} delta",
                " */",
                "export function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {",
                "",
                "  var x = 0,",
                "      y = 0;",
                "",
                "  var labelPosition = getLabelMid(label);",
                "",
                "  // get closest attachment",
                "  var attachment = getAttachment(labelPosition, oldWaypoints),",
                "      oldLabelLineIndex = attachment.segmentIndex,",
                "      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);",
                "",
                "  if (newLabelLineIndex === null) {",
                "    return { x: x, y: y };",
                "  }",
                "",
                "  // should never happen",
                "  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored",
                "  if (newLabelLineIndex < 0 ||",
                "      newLabelLineIndex > newWaypoints.length - 2) {",
                "    return { x: x, y: y };",
                "  }",
                "",
                "  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),",
                "      newLabelLine = getLine(newWaypoints, newLabelLineIndex),",
                "      oldFoot = attachment.position;",
                "",
                "  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),",
                "      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);",
                "",
                "  // special rule if label on bendpoint",
                "  if (attachment.type === 'bendpoint') {",
                "",
                "    var offset = newWaypoints.length - oldWaypoints.length,",
                "        oldBendpointIndex = attachment.bendpointIndex,",
                "        oldBendpoint = oldWaypoints[oldBendpointIndex];",
                "",
                "    // bendpoint position hasn't changed, return same position",
                "    if (newWaypoints.indexOf(oldBendpoint) !== -1) {",
                "      return { x: x, y: y };",
                "    }",
                "",
                "    // new bendpoint and old bendpoint have same index, then just return the offset",
                "    if (offset === 0) {",
                "      var newBendpoint = newWaypoints[oldBendpointIndex];",
                "",
                "      return {",
                "        x: newBendpoint.x - attachment.position.x,",
                "        y: newBendpoint.y - attachment.position.y",
                "      };",
                "    }",
                "",
                "    // if bendpoints get removed",
                "    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {",
                "      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);",
                "    }",
                "  }",
                "",
                "  var newFoot = {",
                "    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,",
                "    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y",
                "  };",
                "",
                "  // the rotated vector to label",
                "  var newLabelVector = rotateVector({",
                "    x: labelPosition.x - oldFoot.x,",
                "    y: labelPosition.y - oldFoot.y",
                "  }, angleDelta);",
                "",
                "  // the new relative position",
                "  x = newFoot.x + newLabelVector.x - labelPosition.x;",
                "  y = newFoot.y + newLabelVector.y - labelPosition.y;",
                "",
                "  return roundPoint({",
                "    x: x,",
                "    y: y",
                "  });",
                "}",
                "",
                "",
                "// HELPERS //////////////////////",
                "",
                "function relativePositionMidWaypoint(waypoints, idx) {",
                "",
                "  var distanceSegment1 = getDistancePointPoint(waypoints[idx-1], waypoints[idx]),",
                "      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx+1]);",
                "",
                "  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);",
                "",
                "  return relativePosition;",
                "}",
                "",
                "function getLabelMid(label) {",
                "  return {",
                "    x: label.x + label.width / 2,",
                "    y: label.y + label.height / 2",
                "  };",
                "}",
                "",
                "function getAngleDelta(l1, l2) {",
                "  var a1 = getAngle(l1),",
                "      a2 = getAngle(l2);",
                "  return a2 - a1;",
                "}",
                "",
                "function getLine(waypoints, idx) {",
                "  return [ waypoints[idx], waypoints[idx+1] ];",
                "}",
                "",
                "function getRelativeFootPosition(line, foot) {",
                "",
                "  var length = getDistancePointPoint(line[0], line[1]),",
                "      lengthToFoot = getDistancePointPoint(line[0], foot);",
                "",
                "  return length === 0 ? 0 : lengthToFoot / length;",
                "}"
            ]
        }
    },
    "bug_functions": {
        "3": {
            "function_name": "findNewLabelLineStartIndex (not found) ",
            "file_path": "lib/features/modeling/behavior/util/LabelLayoutUtil.js",
            "function_details": [
                {
                    "name": "findNewLabelLineStartIndex",
                    "start_line": 1,
                    "end_line": 222
                }
            ],
            "function_code": [
                "import {",
                "  getDistancePointPoint,",
                "  rotateVector,",
                "  getAngle",
                "} from './GeometricUtil';",
                "",
                "import {",
                "  getAttachment",
                "} from './LineAttachmentUtil';",
                "",
                "import {",
                "  roundPoint",
                "} from 'diagram-js/lib/layout/LayoutUtil';",
                "",
                "",
                "export function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {",
                "",
                "  var index = attachment.segmentIndex;",
                "",
                "  var offset = newWaypoints.length - oldWaypoints.length;",
                "",
                "  // segmentMove happened",
                "  if (hints.segmentMove) {",
                "",
                "    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,",
                "        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;",
                "",
                "    // if label was on moved segment return new segment index",
                "    if (index === oldSegmentStartIndex) {",
                "      return newSegmentStartIndex;",
                "    }",
                "",
                "    // label is after new segment index",
                "    if (index >= newSegmentStartIndex) {",
                "      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;",
                "    }",
                "",
                "    // if label is before new segment index",
                "    return index;",
                "  }",
                "",
                "  // bendpointMove happened",
                "  if (hints.bendpointMove) {",
                "",
                "    var insert = hints.bendpointMove.insert,",
                "        bendpointIndex = hints.bendpointMove.bendpointIndex,",
                "        newIndex;",
                "",
                "    // waypoints length didnt change",
                "    if (offset === 0) {",
                "      return index;",
                "    }",
                "",
                "    // label behind new/removed bendpoint",
                "    if (index >= bendpointIndex) {",
                "      newIndex = insert ? index + 1 : index - 1;",
                "    }",
                "",
                "    // label before new/removed bendpoint",
                "    if (index < bendpointIndex) {",
                "",
                "      newIndex = index;",
                "",
                "      // decide label should take right or left segment",
                "      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {",
                "",
                "        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);",
                "",
                "        if (rel < attachment.relativeLocation) {",
                "          newIndex++;",
                "        }",
                "      }",
                "    }",
                "",
                "    return newIndex;",
                "  }",
                "",
                "  // start/end changed",
                "  if (offset === 0) {",
                "    return index;",
                "  }",
                "",
                "  if (hints.connectionStart) {",
                "    return (index === 0) ? 0 : null;",
                "  }",
                "",
                "  if (hints.connectionEnd) {",
                "    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;",
                "  }",
                "",
                "  // if nothing fits, return null",
                "  return null;",
                "}",
                "",
                "",
                "/**",
                " * Calculate the required adjustment (move delta) for the given label",
                " * after the connection waypoints got updated.",
                " *",
                " * @param {djs.model.Label} label",
                " * @param {Array<Point>} newWaypoints",
                " * @param {Array<Point>} oldWaypoints",
                " * @param {Object} hints",
                " *",
                " * @return {Point} delta",
                " */",
                "export function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {",
                "",
                "  var x = 0,",
                "      y = 0;",
                "",
                "  var labelPosition = getLabelMid(label);",
                "",
                "  // get closest attachment",
                "  var attachment = getAttachment(labelPosition, oldWaypoints),",
                "      oldLabelLineIndex = attachment.segmentIndex,",
                "      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);",
                "",
                "  if (newLabelLineIndex === null) {",
                "    return { x: x, y: y };",
                "  }",
                "",
                "  // should never happen",
                "  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored",
                "  if (newLabelLineIndex < 0 ||",
                "      newLabelLineIndex > newWaypoints.length - 2) {",
                "    return { x: x, y: y };",
                "  }",
                "",
                "  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),",
                "      newLabelLine = getLine(newWaypoints, newLabelLineIndex),",
                "      oldFoot = attachment.position;",
                "",
                "  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),",
                "      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);",
                "",
                "  // special rule if label on bendpoint",
                "  if (attachment.type === 'bendpoint') {",
                "",
                "    var offset = newWaypoints.length - oldWaypoints.length,",
                "        oldBendpointIndex = attachment.bendpointIndex,",
                "        oldBendpoint = oldWaypoints[oldBendpointIndex];",
                "",
                "    // bendpoint position hasn't changed, return same position",
                "    if (newWaypoints.indexOf(oldBendpoint) !== -1) {",
                "      return { x: x, y: y };",
                "    }",
                "",
                "    // new bendpoint and old bendpoint have same index, then just return the offset",
                "    if (offset === 0) {",
                "      var newBendpoint = newWaypoints[oldBendpointIndex];",
                "",
                "      return {",
                "        x: newBendpoint.x - attachment.position.x,",
                "        y: newBendpoint.y - attachment.position.y",
                "      };",
                "    }",
                "",
                "    // if bendpoints get removed",
                "    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {",
                "      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);",
                "    }",
                "  }",
                "",
                "  var newFoot = {",
                "    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,",
                "    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y",
                "  };",
                "",
                "  // the rotated vector to label",
                "  var newLabelVector = rotateVector({",
                "    x: labelPosition.x - oldFoot.x,",
                "    y: labelPosition.y - oldFoot.y",
                "  }, angleDelta);",
                "",
                "  // the new relative position",
                "  x = newFoot.x + newLabelVector.x - labelPosition.x;",
                "  y = newFoot.y + newLabelVector.y - labelPosition.y;",
                "",
                "  return roundPoint({",
                "    x: x,",
                "    y: y",
                "  });",
                "}",
                "",
                "",
                "// HELPERS //////////////////////",
                "",
                "function relativePositionMidWaypoint(waypoints, idx) {",
                "",
                "  var distanceSegment1 = getDistancePointPoint(waypoints[idx-1], waypoints[idx]),",
                "      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx+1]);",
                "",
                "  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);",
                "",
                "  return relativePosition;",
                "}",
                "",
                "function getLabelMid(label) {",
                "  return {",
                "    x: label.x + label.width / 2,",
                "    y: label.y + label.height / 2",
                "  };",
                "}",
                "",
                "function getAngleDelta(l1, l2) {",
                "  var a1 = getAngle(l1),",
                "      a2 = getAngle(l2);",
                "  return a2 - a1;",
                "}",
                "",
                "function getLine(waypoints, idx) {",
                "  return [ waypoints[idx], waypoints[idx+1] ];",
                "}",
                "",
                "function getRelativeFootPosition(line, foot) {",
                "",
                "  var length = getDistancePointPoint(line[0], line[1]),",
                "      lengthToFoot = getDistancePointPoint(line[0], foot);",
                "",
                "  return length === 0 ? 0 : lengthToFoot / length;",
                "}"
            ]
        },
        "4": {
            "function_name": "getLabelAdjustment (not found) ",
            "file_path": "lib/features/modeling/behavior/util/LabelLayoutUtil.js",
            "function_details": [
                {
                    "name": "getLabelAdjustment",
                    "start_line": 1,
                    "end_line": 222
                }
            ],
            "function_code": [
                "import {",
                "  getDistancePointPoint,",
                "  rotateVector,",
                "  getAngle",
                "} from './GeometricUtil';",
                "",
                "import {",
                "  getAttachment",
                "} from './LineAttachmentUtil';",
                "",
                "import {",
                "  roundPoint",
                "} from 'diagram-js/lib/layout/LayoutUtil';",
                "",
                "",
                "export function findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {",
                "",
                "  var index = attachment.segmentIndex;",
                "",
                "  var offset = newWaypoints.length - oldWaypoints.length;",
                "",
                "  // segmentMove happened",
                "  if (hints.segmentMove) {",
                "",
                "    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex,",
                "        newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;",
                "",
                "    // if label was on moved segment return new segment index",
                "    if (index === oldSegmentStartIndex) {",
                "      return newSegmentStartIndex;",
                "    }",
                "",
                "    // label is after new segment index",
                "    if (index >= newSegmentStartIndex) {",
                "      return (index+offset < newSegmentStartIndex) ? newSegmentStartIndex : index+offset;",
                "    }",
                "",
                "    // if label is before new segment index",
                "    return index;",
                "  }",
                "",
                "  // bendpointMove happened",
                "  if (hints.bendpointMove) {",
                "",
                "    var insert = hints.bendpointMove.insert,",
                "        bendpointIndex = hints.bendpointMove.bendpointIndex,",
                "        newIndex;",
                "",
                "    // waypoints length didnt change",
                "    if (offset === 0) {",
                "      return index;",
                "    }",
                "",
                "    // label behind new/removed bendpoint",
                "    if (index >= bendpointIndex) {",
                "      newIndex = insert ? index + 1 : index - 1;",
                "    }",
                "",
                "    // label before new/removed bendpoint",
                "    if (index < bendpointIndex) {",
                "",
                "      newIndex = index;",
                "",
                "      // decide label should take right or left segment",
                "      if (insert && attachment.type !== 'bendpoint' && bendpointIndex-1 === index) {",
                "",
                "        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);",
                "",
                "        if (rel < attachment.relativeLocation) {",
                "          newIndex++;",
                "        }",
                "      }",
                "    }",
                "",
                "    return newIndex;",
                "  }",
                "",
                "  // start/end changed",
                "  if (offset === 0) {",
                "    return index;",
                "  }",
                "",
                "  if (hints.connectionStart) {",
                "    return (index === 0) ? 0 : null;",
                "  }",
                "",
                "  if (hints.connectionEnd) {",
                "    return (index === oldWaypoints.length - 2) ? newWaypoints.length - 2 : null;",
                "  }",
                "",
                "  // if nothing fits, return null",
                "  return null;",
                "}",
                "",
                "",
                "/**",
                " * Calculate the required adjustment (move delta) for the given label",
                " * after the connection waypoints got updated.",
                " *",
                " * @param {djs.model.Label} label",
                " * @param {Array<Point>} newWaypoints",
                " * @param {Array<Point>} oldWaypoints",
                " * @param {Object} hints",
                " *",
                " * @return {Point} delta",
                " */",
                "export function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {",
                "",
                "  var x = 0,",
                "      y = 0;",
                "",
                "  var labelPosition = getLabelMid(label);",
                "",
                "  // get closest attachment",
                "  var attachment = getAttachment(labelPosition, oldWaypoints),",
                "      oldLabelLineIndex = attachment.segmentIndex,",
                "      newLabelLineIndex = findNewLabelLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);",
                "",
                "  if (newLabelLineIndex === null) {",
                "    return { x: x, y: y };",
                "  }",
                "",
                "  // should never happen",
                "  // TODO(@janstuemmel): throw an error here when connectionSegmentMove is refactored",
                "  if (newLabelLineIndex < 0 ||",
                "      newLabelLineIndex > newWaypoints.length - 2) {",
                "    return { x: x, y: y };",
                "  }",
                "",
                "  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex),",
                "      newLabelLine = getLine(newWaypoints, newLabelLineIndex),",
                "      oldFoot = attachment.position;",
                "",
                "  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot),",
                "      angleDelta = getAngleDelta(oldLabelLine, newLabelLine);",
                "",
                "  // special rule if label on bendpoint",
                "  if (attachment.type === 'bendpoint') {",
                "",
                "    var offset = newWaypoints.length - oldWaypoints.length,",
                "        oldBendpointIndex = attachment.bendpointIndex,",
                "        oldBendpoint = oldWaypoints[oldBendpointIndex];",
                "",
                "    // bendpoint position hasn't changed, return same position",
                "    if (newWaypoints.indexOf(oldBendpoint) !== -1) {",
                "      return { x: x, y: y };",
                "    }",
                "",
                "    // new bendpoint and old bendpoint have same index, then just return the offset",
                "    if (offset === 0) {",
                "      var newBendpoint = newWaypoints[oldBendpointIndex];",
                "",
                "      return {",
                "        x: newBendpoint.x - attachment.position.x,",
                "        y: newBendpoint.y - attachment.position.y",
                "      };",
                "    }",
                "",
                "    // if bendpoints get removed",
                "    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {",
                "      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);",
                "    }",
                "  }",
                "",
                "  var newFoot = {",
                "    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,",
                "    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y",
                "  };",
                "",
                "  // the rotated vector to label",
                "  var newLabelVector = rotateVector({",
                "    x: labelPosition.x - oldFoot.x,",
                "    y: labelPosition.y - oldFoot.y",
                "  }, angleDelta);",
                "",
                "  // the new relative position",
                "  x = newFoot.x + newLabelVector.x - labelPosition.x;",
                "  y = newFoot.y + newLabelVector.y - labelPosition.y;",
                "",
                "  return roundPoint({",
                "    x: x,",
                "    y: y",
                "  });",
                "}",
                "",
                "",
                "// HELPERS //////////////////////",
                "",
                "function relativePositionMidWaypoint(waypoints, idx) {",
                "",
                "  var distanceSegment1 = getDistancePointPoint(waypoints[idx-1], waypoints[idx]),",
                "      distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx+1]);",
                "",
                "  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);",
                "",
                "  return relativePosition;",
                "}",
                "",
                "function getLabelMid(label) {",
                "  return {",
                "    x: label.x + label.width / 2,",
                "    y: label.y + label.height / 2",
                "  };",
                "}",
                "",
                "function getAngleDelta(l1, l2) {",
                "  var a1 = getAngle(l1),",
                "      a2 = getAngle(l2);",
                "  return a2 - a1;",
                "}",
                "",
                "function getLine(waypoints, idx) {",
                "  return [ waypoints[idx], waypoints[idx+1] ];",
                "}",
                "",
                "function getRelativeFootPosition(line, foot) {",
                "",
                "  var length = getDistancePointPoint(line[0], line[1]),",
                "      lengthToFoot = getDistancePointPoint(line[0], foot);",
                "",
                "  return length === 0 ? 0 : lengthToFoot / length;",
                "}"
            ]
        }
    }
}