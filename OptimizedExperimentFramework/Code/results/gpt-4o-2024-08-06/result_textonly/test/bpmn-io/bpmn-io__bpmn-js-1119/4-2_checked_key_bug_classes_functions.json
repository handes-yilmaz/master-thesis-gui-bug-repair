{
    "bug_classes": {
        "1": {
            "class_name": "ReplaceConnectionBehavior (not found) ",
            "file_path": "lib/features/modeling/behavior/ReplaceConnectionBehavior.js",
            "class_details": [
                {
                    "name": "ReplaceConnectionBehavior",
                    "start_line": 1,
                    "end_line": 190
                }
            ],
            "class_code": [
                "import {",
                "  forEach,",
                "  find,",
                "  matchPattern",
                "} from 'min-dash';",
                "",
                "import inherits from 'inherits';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "",
                "import { is } from '../../../util/ModelUtil';",
                "",
                "",
                "export default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {",
                "",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  var dragging = injector.get('dragging', false);",
                "",
                "  function fixConnection(connection) {",
                "",
                "    var source = connection.source,",
                "        target = connection.target,",
                "        parent = connection.parent;",
                "",
                "    // do not do anything if connection",
                "    // is already deleted (may happen due to other",
                "    // behaviors plugged-in before)",
                "    if (!parent) {",
                "      return;",
                "    }",
                "",
                "    var replacementType,",
                "        remove;",
                "",
                "    /**",
                "     * Check if incoming or outgoing connections",
                "     * can stay or could be substituted with an",
                "     * appropriate replacement.",
                "     *",
                "     * This holds true for SequenceFlow <> MessageFlow.",
                "     */",
                "",
                "    if (is(connection, 'bpmn:SequenceFlow')) {",
                "      if (!bpmnRules.canConnectSequenceFlow(source, target)) {",
                "        remove = true;",
                "      }",
                "",
                "      if (bpmnRules.canConnectMessageFlow(source, target)) {",
                "        replacementType = 'bpmn:MessageFlow';",
                "      }",
                "    }",
                "",
                "    // transform message flows into sequence flows, if possible",
                "",
                "    if (is(connection, 'bpmn:MessageFlow')) {",
                "",
                "      if (!bpmnRules.canConnectMessageFlow(source, target)) {",
                "        remove = true;",
                "      }",
                "",
                "      if (bpmnRules.canConnectSequenceFlow(source, target)) {",
                "        replacementType = 'bpmn:SequenceFlow';",
                "      }",
                "    }",
                "",
                "    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {",
                "      remove = true;",
                "    }",
                "",
                "",
                "    // remove invalid connection,",
                "    // unless it has been removed already",
                "    if (remove) {",
                "      modeling.removeConnection(connection);",
                "    }",
                "",
                "    // replace SequenceFlow <> MessageFlow",
                "",
                "    if (replacementType) {",
                "      modeling.connect(source, target, {",
                "        type: replacementType,",
                "        waypoints: connection.waypoints.slice()",
                "      });",
                "    }",
                "  }",
                "",
                "  function replaceReconnectedConnection(event) {",
                "",
                "    var context = event.context,",
                "        connection = context.connection,",
                "        allowed,",
                "        replacement;",
                "",
                "    if (context.newTarget) {",
                "      allowed = bpmnRules.canConnect(connection.source, context.newTarget);",
                "    } else {",
                "      allowed = bpmnRules.canConnect(context.newSource, connection.target);",
                "    }",
                "",
                "    if (!allowed || allowed.type === connection.type) {",
                "      return;",
                "    }",
                "",
                "    // temporarily connect old shapes with new connection",
                "    replacement = modeling.connect(connection.source, connection.target, {",
                "      type: allowed.type,",
                "      waypoints: connection.waypoints.slice()",
                "    });",
                "",
                "    // remove old connection",
                "    modeling.removeConnection(connection);",
                "",
                "    // replace connection in context to reconnect end/start",
                "    context.connection = replacement;",
                "",
                "    if (dragging) {",
                "      cleanDraggingSelection(connection, replacement);",
                "    }",
                "  }",
                "",
                "  // monkey-patch selection saved in dragging in order to not re-select non-existing connection",
                "  function cleanDraggingSelection(oldConnection, newConnection) {",
                "    var context = dragging.context(),",
                "        previousSelection = context && context.payload.previousSelection,",
                "        index;",
                "",
                "    // do nothing if not dragging or no selection was present",
                "    if (!previousSelection || !previousSelection.length) {",
                "      return;",
                "    }",
                "",
                "    index = previousSelection.indexOf(oldConnection);",
                "",
                "    if (index === -1) {",
                "      return;",
                "    }",
                "",
                "    previousSelection.splice(index, 1, newConnection);",
                "  }",
                "",
                "  // lifecycle hooks",
                "",
                "  this.postExecuted('elements.move', function(context) {",
                "",
                "    var closure = context.closure,",
                "        allConnections = closure.allConnections;",
                "",
                "    forEach(allConnections, fixConnection);",
                "  }, true);",
                "",
                "  this.preExecute([",
                "    'connection.reconnectStart',",
                "    'connection.reconnectEnd'",
                "  ], replaceReconnectedConnection);",
                "",
                "  this.postExecuted('element.updateProperties', function(event) {",
                "    var context = event.context,",
                "        properties = context.properties,",
                "        element = context.element,",
                "        businessObject = element.businessObject,",
                "        connection;",
                "",
                "    // remove condition expression when morphing to default flow",
                "    if (properties.default) {",
                "      connection = find(",
                "        element.outgoing,",
                "        matchPattern({ id: element.businessObject.default.id })",
                "      );",
                "",
                "      if (connection) {",
                "        modeling.updateProperties(connection, { conditionExpression: undefined });",
                "      }",
                "    }",
                "",
                "    // remove default property from source when morphing to conditional flow",
                "    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {",
                "      modeling.updateProperties(element.source, { default: undefined });",
                "    }",
                "  });",
                "}",
                "",
                "inherits(ReplaceConnectionBehavior, CommandInterceptor);",
                "",
                "ReplaceConnectionBehavior.$inject = [",
                "  'eventBus',",
                "  'modeling',",
                "  'bpmnRules',",
                "  'injector'",
                "];"
            ]
        },
        "2": {
            "class_name": "UpdateSemanticParentHandler (not found) ",
            "file_path": "lib/features/modeling/cmd/UpdateSemanticParentHandler.js",
            "class_details": [
                {
                    "name": "UpdateSemanticParentHandler",
                    "start_line": 1,
                    "end_line": 34
                }
            ],
            "class_code": [
                "export default function UpdateSemanticParentHandler(bpmnUpdater) {",
                "  this._bpmnUpdater = bpmnUpdater;",
                "}",
                "",
                "UpdateSemanticParentHandler.$inject = [ 'bpmnUpdater' ];",
                "",
                "",
                "UpdateSemanticParentHandler.prototype.execute = function(context) {",
                "  var dataStoreBo = context.dataStoreBo,",
                "      newSemanticParent = context.newSemanticParent,",
                "      newDiParent = context.newDiParent;",
                "",
                "  context.oldSemanticParent = dataStoreBo.$parent;",
                "  context.oldDiParent = dataStoreBo.di.$parent;",
                "",
                "  // update semantic parent",
                "  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);",
                "",
                "  // update DI parent",
                "  this._bpmnUpdater.updateDiParent(dataStoreBo.di, newDiParent);",
                "};",
                "",
                "UpdateSemanticParentHandler.prototype.revert = function(context) {",
                "  var dataStoreBo = context.dataStoreBo,",
                "      oldSemanticParent = context.oldSemanticParent,",
                "      oldDiParent = context.oldDiParent;",
                "",
                "  // update semantic parent",
                "  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);",
                "",
                "  // update DI parent",
                "  this._bpmnUpdater.updateDiParent(dataStoreBo.di, oldDiParent);",
                "};",
                ""
            ]
        }
    },
    "bug_functions": {
        "3": {
            "function_name": "fixConnection (not found) ",
            "file_path": "lib/features/modeling/behavior/ReplaceConnectionBehavior.js",
            "function_details": [
                {
                    "name": "fixConnection",
                    "start_line": 1,
                    "end_line": 190
                }
            ],
            "function_code": [
                "import {",
                "  forEach,",
                "  find,",
                "  matchPattern",
                "} from 'min-dash';",
                "",
                "import inherits from 'inherits';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "",
                "import { is } from '../../../util/ModelUtil';",
                "",
                "",
                "export default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {",
                "",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  var dragging = injector.get('dragging', false);",
                "",
                "  function fixConnection(connection) {",
                "",
                "    var source = connection.source,",
                "        target = connection.target,",
                "        parent = connection.parent;",
                "",
                "    // do not do anything if connection",
                "    // is already deleted (may happen due to other",
                "    // behaviors plugged-in before)",
                "    if (!parent) {",
                "      return;",
                "    }",
                "",
                "    var replacementType,",
                "        remove;",
                "",
                "    /**",
                "     * Check if incoming or outgoing connections",
                "     * can stay or could be substituted with an",
                "     * appropriate replacement.",
                "     *",
                "     * This holds true for SequenceFlow <> MessageFlow.",
                "     */",
                "",
                "    if (is(connection, 'bpmn:SequenceFlow')) {",
                "      if (!bpmnRules.canConnectSequenceFlow(source, target)) {",
                "        remove = true;",
                "      }",
                "",
                "      if (bpmnRules.canConnectMessageFlow(source, target)) {",
                "        replacementType = 'bpmn:MessageFlow';",
                "      }",
                "    }",
                "",
                "    // transform message flows into sequence flows, if possible",
                "",
                "    if (is(connection, 'bpmn:MessageFlow')) {",
                "",
                "      if (!bpmnRules.canConnectMessageFlow(source, target)) {",
                "        remove = true;",
                "      }",
                "",
                "      if (bpmnRules.canConnectSequenceFlow(source, target)) {",
                "        replacementType = 'bpmn:SequenceFlow';",
                "      }",
                "    }",
                "",
                "    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {",
                "      remove = true;",
                "    }",
                "",
                "",
                "    // remove invalid connection,",
                "    // unless it has been removed already",
                "    if (remove) {",
                "      modeling.removeConnection(connection);",
                "    }",
                "",
                "    // replace SequenceFlow <> MessageFlow",
                "",
                "    if (replacementType) {",
                "      modeling.connect(source, target, {",
                "        type: replacementType,",
                "        waypoints: connection.waypoints.slice()",
                "      });",
                "    }",
                "  }",
                "",
                "  function replaceReconnectedConnection(event) {",
                "",
                "    var context = event.context,",
                "        connection = context.connection,",
                "        allowed,",
                "        replacement;",
                "",
                "    if (context.newTarget) {",
                "      allowed = bpmnRules.canConnect(connection.source, context.newTarget);",
                "    } else {",
                "      allowed = bpmnRules.canConnect(context.newSource, connection.target);",
                "    }",
                "",
                "    if (!allowed || allowed.type === connection.type) {",
                "      return;",
                "    }",
                "",
                "    // temporarily connect old shapes with new connection",
                "    replacement = modeling.connect(connection.source, connection.target, {",
                "      type: allowed.type,",
                "      waypoints: connection.waypoints.slice()",
                "    });",
                "",
                "    // remove old connection",
                "    modeling.removeConnection(connection);",
                "",
                "    // replace connection in context to reconnect end/start",
                "    context.connection = replacement;",
                "",
                "    if (dragging) {",
                "      cleanDraggingSelection(connection, replacement);",
                "    }",
                "  }",
                "",
                "  // monkey-patch selection saved in dragging in order to not re-select non-existing connection",
                "  function cleanDraggingSelection(oldConnection, newConnection) {",
                "    var context = dragging.context(),",
                "        previousSelection = context && context.payload.previousSelection,",
                "        index;",
                "",
                "    // do nothing if not dragging or no selection was present",
                "    if (!previousSelection || !previousSelection.length) {",
                "      return;",
                "    }",
                "",
                "    index = previousSelection.indexOf(oldConnection);",
                "",
                "    if (index === -1) {",
                "      return;",
                "    }",
                "",
                "    previousSelection.splice(index, 1, newConnection);",
                "  }",
                "",
                "  // lifecycle hooks",
                "",
                "  this.postExecuted('elements.move', function(context) {",
                "",
                "    var closure = context.closure,",
                "        allConnections = closure.allConnections;",
                "",
                "    forEach(allConnections, fixConnection);",
                "  }, true);",
                "",
                "  this.preExecute([",
                "    'connection.reconnectStart',",
                "    'connection.reconnectEnd'",
                "  ], replaceReconnectedConnection);",
                "",
                "  this.postExecuted('element.updateProperties', function(event) {",
                "    var context = event.context,",
                "        properties = context.properties,",
                "        element = context.element,",
                "        businessObject = element.businessObject,",
                "        connection;",
                "",
                "    // remove condition expression when morphing to default flow",
                "    if (properties.default) {",
                "      connection = find(",
                "        element.outgoing,",
                "        matchPattern({ id: element.businessObject.default.id })",
                "      );",
                "",
                "      if (connection) {",
                "        modeling.updateProperties(connection, { conditionExpression: undefined });",
                "      }",
                "    }",
                "",
                "    // remove default property from source when morphing to conditional flow",
                "    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {",
                "      modeling.updateProperties(element.source, { default: undefined });",
                "    }",
                "  });",
                "}",
                "",
                "inherits(ReplaceConnectionBehavior, CommandInterceptor);",
                "",
                "ReplaceConnectionBehavior.$inject = [",
                "  'eventBus',",
                "  'modeling',",
                "  'bpmnRules',",
                "  'injector'",
                "];"
            ]
        },
        "4": {
            "function_name": "replaceReconnectedConnection (not found) ",
            "file_path": "lib/features/modeling/behavior/ReplaceConnectionBehavior.js",
            "function_details": [
                {
                    "name": "replaceReconnectedConnection",
                    "start_line": 1,
                    "end_line": 190
                }
            ],
            "function_code": [
                "import {",
                "  forEach,",
                "  find,",
                "  matchPattern",
                "} from 'min-dash';",
                "",
                "import inherits from 'inherits';",
                "",
                "import CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';",
                "",
                "import { is } from '../../../util/ModelUtil';",
                "",
                "",
                "export default function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {",
                "",
                "  CommandInterceptor.call(this, eventBus);",
                "",
                "  var dragging = injector.get('dragging', false);",
                "",
                "  function fixConnection(connection) {",
                "",
                "    var source = connection.source,",
                "        target = connection.target,",
                "        parent = connection.parent;",
                "",
                "    // do not do anything if connection",
                "    // is already deleted (may happen due to other",
                "    // behaviors plugged-in before)",
                "    if (!parent) {",
                "      return;",
                "    }",
                "",
                "    var replacementType,",
                "        remove;",
                "",
                "    /**",
                "     * Check if incoming or outgoing connections",
                "     * can stay or could be substituted with an",
                "     * appropriate replacement.",
                "     *",
                "     * This holds true for SequenceFlow <> MessageFlow.",
                "     */",
                "",
                "    if (is(connection, 'bpmn:SequenceFlow')) {",
                "      if (!bpmnRules.canConnectSequenceFlow(source, target)) {",
                "        remove = true;",
                "      }",
                "",
                "      if (bpmnRules.canConnectMessageFlow(source, target)) {",
                "        replacementType = 'bpmn:MessageFlow';",
                "      }",
                "    }",
                "",
                "    // transform message flows into sequence flows, if possible",
                "",
                "    if (is(connection, 'bpmn:MessageFlow')) {",
                "",
                "      if (!bpmnRules.canConnectMessageFlow(source, target)) {",
                "        remove = true;",
                "      }",
                "",
                "      if (bpmnRules.canConnectSequenceFlow(source, target)) {",
                "        replacementType = 'bpmn:SequenceFlow';",
                "      }",
                "    }",
                "",
                "    if (is(connection, 'bpmn:Association') && !bpmnRules.canConnectAssociation(source, target)) {",
                "      remove = true;",
                "    }",
                "",
                "",
                "    // remove invalid connection,",
                "    // unless it has been removed already",
                "    if (remove) {",
                "      modeling.removeConnection(connection);",
                "    }",
                "",
                "    // replace SequenceFlow <> MessageFlow",
                "",
                "    if (replacementType) {",
                "      modeling.connect(source, target, {",
                "        type: replacementType,",
                "        waypoints: connection.waypoints.slice()",
                "      });",
                "    }",
                "  }",
                "",
                "  function replaceReconnectedConnection(event) {",
                "",
                "    var context = event.context,",
                "        connection = context.connection,",
                "        allowed,",
                "        replacement;",
                "",
                "    if (context.newTarget) {",
                "      allowed = bpmnRules.canConnect(connection.source, context.newTarget);",
                "    } else {",
                "      allowed = bpmnRules.canConnect(context.newSource, connection.target);",
                "    }",
                "",
                "    if (!allowed || allowed.type === connection.type) {",
                "      return;",
                "    }",
                "",
                "    // temporarily connect old shapes with new connection",
                "    replacement = modeling.connect(connection.source, connection.target, {",
                "      type: allowed.type,",
                "      waypoints: connection.waypoints.slice()",
                "    });",
                "",
                "    // remove old connection",
                "    modeling.removeConnection(connection);",
                "",
                "    // replace connection in context to reconnect end/start",
                "    context.connection = replacement;",
                "",
                "    if (dragging) {",
                "      cleanDraggingSelection(connection, replacement);",
                "    }",
                "  }",
                "",
                "  // monkey-patch selection saved in dragging in order to not re-select non-existing connection",
                "  function cleanDraggingSelection(oldConnection, newConnection) {",
                "    var context = dragging.context(),",
                "        previousSelection = context && context.payload.previousSelection,",
                "        index;",
                "",
                "    // do nothing if not dragging or no selection was present",
                "    if (!previousSelection || !previousSelection.length) {",
                "      return;",
                "    }",
                "",
                "    index = previousSelection.indexOf(oldConnection);",
                "",
                "    if (index === -1) {",
                "      return;",
                "    }",
                "",
                "    previousSelection.splice(index, 1, newConnection);",
                "  }",
                "",
                "  // lifecycle hooks",
                "",
                "  this.postExecuted('elements.move', function(context) {",
                "",
                "    var closure = context.closure,",
                "        allConnections = closure.allConnections;",
                "",
                "    forEach(allConnections, fixConnection);",
                "  }, true);",
                "",
                "  this.preExecute([",
                "    'connection.reconnectStart',",
                "    'connection.reconnectEnd'",
                "  ], replaceReconnectedConnection);",
                "",
                "  this.postExecuted('element.updateProperties', function(event) {",
                "    var context = event.context,",
                "        properties = context.properties,",
                "        element = context.element,",
                "        businessObject = element.businessObject,",
                "        connection;",
                "",
                "    // remove condition expression when morphing to default flow",
                "    if (properties.default) {",
                "      connection = find(",
                "        element.outgoing,",
                "        matchPattern({ id: element.businessObject.default.id })",
                "      );",
                "",
                "      if (connection) {",
                "        modeling.updateProperties(connection, { conditionExpression: undefined });",
                "      }",
                "    }",
                "",
                "    // remove default property from source when morphing to conditional flow",
                "    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {",
                "      modeling.updateProperties(element.source, { default: undefined });",
                "    }",
                "  });",
                "}",
                "",
                "inherits(ReplaceConnectionBehavior, CommandInterceptor);",
                "",
                "ReplaceConnectionBehavior.$inject = [",
                "  'eventBus',",
                "  'modeling',",
                "  'bpmnRules',",
                "  'injector'",
                "];"
            ]
        }
    }
}