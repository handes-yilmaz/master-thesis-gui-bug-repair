{
    "1": {
        "bug_file": "lib/features/replace/ReplaceOptions.js",
        "compressed": "YES",
        "line_numbers": 820,
        "compressed_line_numbers": 67,
        "compressed_bug_file_content": "export var START_EVENT = [\n\n\nexport var START_EVENT_SUB_PROCESS = [\n\n\nexport var INTERMEDIATE_EVENT = [\n\n\nexport var END_EVENT = [\n\n\nexport var GATEWAY = [\n\n\n  // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194\n  // {\n  //   label: 'Event based instantiating Gateway',\n  //   actionName: 'replace-with-exclusive-event-based-gateway',\n  //   className: 'bpmn-icon-exclusive-event-based',\n  //   target: {\n  //     type: 'bpmn:EventBasedGateway'\n  //   },\n  //   options: {\n  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }\n  //   }\n  // },\n  // {\n  //   label: 'Parallel Event based instantiating Gateway',\n  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',\n  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',\n  //   target: {\n  //     type: 'bpmn:EventBasedGateway'\n  //   },\n  //   options: {\n  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }\n  //   }\n  // }\n\n\nexport var SUBPROCESS_EXPANDED = [\n\n\nexport var TRANSACTION = [\n\n\nexport var EVENT_SUB_PROCESS = [\n\n\nexport var TASK = [\n\n\nexport var BOUNDARY_EVENT = [\n\n\nexport var EVENT_SUB_PROCESS_START_EVENT = [\n\n\nexport var SEQUENCE_FLOW = [\n\n\nexport var PARTICIPANT = [\n\n\n    // TODO(@janstuemmel): maybe design new icon\n\n\n"
    },
    "2": {
        "bug_file": "lib/features/replace/BpmnReplace.js",
        "compressed": "NO",
        "line_numbers": 300,
        "compressed_line_numbers": 300,
        "compressed_bug_file_content": "import {\n  pick,\n  assign,\n  filter,\n  forEach,\n  isArray,\n  isUndefined,\n  has\n} from 'min-dash';\n\nimport {\n  is,\n  getBusinessObject\n} from '../../util/ModelUtil';\n\nimport {\n  isAny\n} from '../modeling/util/ModelingUtil';\n\nimport {\n  isExpanded,\n  isEventSubProcess\n} from '../../util/DiUtil';\n\nimport { getPropertyNames } from '../copy-paste/ModdleCopy';\n\nfunction copyProperties(source, target, properties) {\n  if (!isArray(properties)) {\n    properties = [ properties ];\n  }\n\n  forEach(properties, function(property) {\n    if (!isUndefined(source[property])) {\n      target[property] = source[property];\n    }\n  });\n}\n\nvar CUSTOM_PROPERTIES = [\n  'cancelActivity',\n  'instantiate',\n  'eventGatewayType',\n  'triggeredByEvent',\n  'isInterrupting'\n];\n\n\nfunction toggeling(element, target) {\n\n  var oldCollapsed = (\n    element && has(element, 'collapsed') ? element.collapsed : !isExpanded(element)\n  );\n\n  var targetCollapsed;\n\n  if (target && (has(target, 'collapsed') || has(target, 'isExpanded'))) {\n\n    // property is explicitly set so use it\n    targetCollapsed = (\n      has(target, 'collapsed') ? target.collapsed : !target.isExpanded\n    );\n  } else {\n\n    // keep old state\n    targetCollapsed = oldCollapsed;\n  }\n\n  if (oldCollapsed !== targetCollapsed) {\n    element.collapsed = oldCollapsed;\n    return true;\n  }\n\n  return false;\n}\n\n\n\n/**\n * This module takes care of replacing BPMN elements\n */\nexport default function BpmnReplace(\n    bpmnFactory,\n    elementFactory,\n    moddleCopy,\n    modeling,\n    replace,\n    selection\n) {\n\n  /**\n   * Prepares a new business object for the replacement element\n   * and triggers the replace operation.\n   *\n   * @param  {djs.model.Base} element\n   * @param  {Object} target\n   * @param  {Object} [hints]\n   *\n   * @return {djs.model.Base} the newly created element\n   */\n  function replaceElement(element, target, hints) {\n\n    hints = hints || {};\n\n    var type = target.type,\n        oldBusinessObject = element.businessObject;\n\n    if (isSubProcess(oldBusinessObject)) {\n      if (type === 'bpmn:SubProcess') {\n        if (toggeling(element, target)) {\n\n          // expanding or collapsing process\n          modeling.toggleCollapse(element);\n\n          return element;\n        }\n      }\n    }\n\n    var newBusinessObject = bpmnFactory.create(type);\n\n    var newElement = {\n      type: type,\n      businessObject: newBusinessObject\n    };\n\n    var elementProps = getPropertyNames(oldBusinessObject.$descriptor),\n        newElementProps = getPropertyNames(newBusinessObject.$descriptor, true),\n        copyProps = intersection(elementProps, newElementProps);\n\n    // initialize special properties defined in target definition\n    assign(newBusinessObject, pick(target, CUSTOM_PROPERTIES));\n\n    var properties = filter(copyProps, function(propertyName) {\n\n      // copying event definitions, unless we replace\n      if (propertyName === 'eventDefinitions') {\n        return hasEventDefinition(element, target.eventDefinitionType);\n      }\n\n      // retain loop characteristics if the target element\n      // is not an event sub process\n      if (propertyName === 'loopCharacteristics') {\n        return !isEventSubProcess(newBusinessObject);\n      }\n\n      // so the applied properties from 'target' don't get lost\n      if (has(newBusinessObject, propertyName)) {\n        return false;\n      }\n\n      if (propertyName === 'processRef' && target.isExpanded === false) {\n        return false;\n      }\n\n      if (propertyName === 'triggeredByEvent') {\n        return false;\n      }\n\n      return true;\n    });\n\n    newBusinessObject = moddleCopy.copyElement(\n      oldBusinessObject,\n      newBusinessObject,\n      properties\n    );\n\n    // initialize custom BPMN extensions\n    if (target.eventDefinitionType) {\n\n      // only initialize with new eventDefinition\n      // if we did not set an event definition yet,\n      // i.e. because we copied it\n      if (!hasEventDefinition(newBusinessObject, target.eventDefinitionType)) {\n        newElement.eventDefinitionType = target.eventDefinitionType;\n        newElement.eventDefinitionAttrs = target.eventDefinitionAttrs;\n      }\n    }\n\n    if (is(oldBusinessObject, 'bpmn:Activity')) {\n\n      if (isSubProcess(oldBusinessObject)) {\n\n        // no toggeling, so keep old state\n        newElement.isExpanded = isExpanded(oldBusinessObject);\n      }\n\n      // else if property is explicitly set, use it\n      else if (target && has(target, 'isExpanded')) {\n        newElement.isExpanded = target.isExpanded;\n      }\n\n      // TODO: need also to respect min/max Size\n      // copy size, from an expanded subprocess to an expanded alternative subprocess\n      // except bpmn:Task, because Task is always expanded\n      if ((isExpanded(oldBusinessObject) && !is(oldBusinessObject, 'bpmn:Task')) && newElement.isExpanded) {\n        newElement.width = element.width;\n        newElement.height = element.height;\n      }\n    }\n\n    // remove children if not expanding sub process\n    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {\n      hints.moveChildren = false;\n    }\n\n    // transform collapsed/expanded pools\n    if (is(oldBusinessObject, 'bpmn:Participant')) {\n\n      // create expanded pool\n      if (target.isExpanded === true) {\n        newBusinessObject.processRef = bpmnFactory.create('bpmn:Process');\n      } else {\n\n        // remove children when transforming to collapsed pool\n        hints.moveChildren = false;\n      }\n\n      // apply same width and default height\n      newElement.width = element.width;\n      newElement.height = elementFactory._getDefaultSize(newBusinessObject).height;\n    }\n\n    newBusinessObject.name = oldBusinessObject.name;\n\n    // retain default flow's reference between inclusive <-> exclusive gateways and activities\n    if (\n      isAny(oldBusinessObject, [\n        'bpmn:ExclusiveGateway',\n        'bpmn:InclusiveGateway',\n        'bpmn:Activity'\n      ]) &&\n      isAny(newBusinessObject, [\n        'bpmn:ExclusiveGateway',\n        'bpmn:InclusiveGateway',\n        'bpmn:Activity'\n      ])\n    ) {\n      newBusinessObject.default = oldBusinessObject.default;\n    }\n\n    if (\n      target.host &&\n      !is(oldBusinessObject, 'bpmn:BoundaryEvent') &&\n      is(newBusinessObject, 'bpmn:BoundaryEvent')\n    ) {\n      newElement.host = target.host;\n    }\n\n    newElement.di = {};\n\n    // fill and stroke will be set to DI\n    copyProperties(oldBusinessObject.di, newElement.di, [\n      'fill',\n      'stroke'\n    ]);\n\n    newElement = replace.replaceElement(element, newElement, hints);\n\n    if (hints.select !== false) {\n      selection.select(newElement);\n    }\n\n    return newElement;\n  }\n\n  this.replaceElement = replaceElement;\n}\n\nBpmnReplace.$inject = [\n  'bpmnFactory',\n  'elementFactory',\n  'moddleCopy',\n  'modeling',\n  'replace',\n  'selection'\n];\n\n\nfunction isSubProcess(bo) {\n  return is(bo, 'bpmn:SubProcess');\n}\n\nfunction hasEventDefinition(element, type) {\n\n  var bo = getBusinessObject(element);\n\n  return type && bo.get('eventDefinitions').some(function(definition) {\n    return is(definition, type);\n  });\n}\n\n/**\n * Compute intersection between two arrays.\n */\nfunction intersection(a1, a2) {\n  return a1.filter(function(el) {\n    return a2.indexOf(el) !== -1;\n  });\n}"
    },
    "3": {
        "bug_file": "lib/features/replace/index.js",
        "compressed": "NO",
        "line_numbers": 14,
        "compressed_line_numbers": 14,
        "compressed_bug_file_content": "import CopyPasteModule from '../copy-paste';\nimport ReplaceModule from 'diagram-js/lib/features/replace';\nimport SelectionModule from 'diagram-js/lib/features/selection';\n\nimport BpmnReplace from './BpmnReplace';\n\nexport default {\n  __depends__: [\n    CopyPasteModule,\n    ReplaceModule,\n    SelectionModule\n  ],\n  bpmnReplace: [ 'type', BpmnReplace ]\n};"
    },
    "4": {
        "bug_file": "lib/features/modeling/behavior/CreateDataObjectBehavior.js",
        "compressed": "NO",
        "line_numbers": 38,
        "compressed_line_numbers": 38,
        "compressed_bug_file_content": "import inherits from 'inherits';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport { is } from '../../../util/ModelUtil';\n\n\n/**\n * BPMN specific create data object behavior\n */\nexport default function CreateDataObjectBehavior(eventBus, bpmnFactory, moddle) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  this.preExecute('shape.create', function(event) {\n\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:DataObjectReference') && shape.type !== 'label') {\n\n      // create a DataObject every time a DataObjectReference is created\n      var dataObject = bpmnFactory.create('bpmn:DataObject');\n\n      // set the reference to the DataObject\n      shape.businessObject.dataObjectRef = dataObject;\n    }\n  });\n\n}\n\nCreateDataObjectBehavior.$inject = [\n  'eventBus',\n  'bpmnFactory',\n  'moddle'\n];\n\ninherits(CreateDataObjectBehavior, CommandInterceptor);"
    },
    "5": {
        "bug_file": "lib/features/modeling/behavior/DataStoreBehavior.js",
        "compressed": "NO",
        "line_numbers": 207,
        "compressed_line_numbers": 207,
        "compressed_bug_file_content": "import inherits from 'inherits';\n\nimport CommandInterceptor from 'diagram-js/lib/command/CommandInterceptor';\n\nimport { is } from '../../../util/ModelUtil';\n\nimport { isAny } from '../util/ModelingUtil';\n\nimport UpdateSemanticParentHandler from '../cmd/UpdateSemanticParentHandler';\n\n\n/**\n * BPMN specific data store behavior\n */\nexport default function DataStoreBehavior(\n    canvas, commandStack, elementRegistry,\n    eventBus) {\n\n  CommandInterceptor.call(this, eventBus);\n\n  commandStack.registerHandler('dataStore.updateContainment', UpdateSemanticParentHandler);\n\n  function getFirstParticipant() {\n    return elementRegistry.filter(function(element) {\n      return is(element, 'bpmn:Participant');\n    })[0];\n  }\n\n  function getDataStores(element) {\n    return element.children.filter(function(child) {\n      return is(child, 'bpmn:DataStoreReference') && !child.labelTarget;\n    });\n  }\n\n  function updateDataStoreParent(dataStore, newDataStoreParent) {\n    var dataStoreBo = dataStore.businessObject || dataStore;\n\n    newDataStoreParent = newDataStoreParent || getFirstParticipant();\n\n    if (newDataStoreParent) {\n      var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;\n\n      commandStack.execute('dataStore.updateContainment', {\n        dataStoreBo: dataStoreBo,\n        newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,\n        newDiParent: newDataStoreParentBo.di\n      });\n    }\n  }\n\n\n  // disable auto-resize for data stores\n  this.preExecute('shape.create', function(event) {\n\n    var context = event.context,\n        shape = context.shape;\n\n    if (is(shape, 'bpmn:DataStoreReference') &&\n        shape.type !== 'label') {\n\n      if (!context.hints) {\n        context.hints = {};\n      }\n\n      // prevent auto resizing\n      context.hints.autoResize = false;\n    }\n  });\n\n\n  // disable auto-resize for data stores\n  this.preExecute('elements.move', function(event) {\n    var context = event.context,\n        shapes = context.shapes;\n\n    var dataStoreReferences = shapes.filter(function(shape) {\n      return is(shape, 'bpmn:DataStoreReference');\n    });\n\n    if (dataStoreReferences.length) {\n      if (!context.hints) {\n        context.hints = {};\n      }\n\n      // prevent auto resizing for data store references\n      context.hints.autoResize = shapes.filter(function(shape) {\n        return !is(shape, 'bpmn:DataStoreReference');\n      });\n    }\n  });\n\n\n  // update parent on data store created\n  this.postExecute('shape.create', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        parent = shape.parent;\n\n\n    if (is(shape, 'bpmn:DataStoreReference') &&\n        shape.type !== 'label' &&\n        is(parent, 'bpmn:Collaboration')) {\n\n      updateDataStoreParent(shape);\n    }\n  });\n\n\n  // update parent on data store moved\n  this.postExecute('shape.move', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        oldParent = context.oldParent,\n        parent = shape.parent;\n\n    if (is(oldParent, 'bpmn:Collaboration')) {\n\n      // do nothing if not necessary\n      return;\n    }\n\n    if (is(shape, 'bpmn:DataStoreReference') &&\n        shape.type !== 'label' &&\n        is(parent, 'bpmn:Collaboration')) {\n\n      var participant = is(oldParent, 'bpmn:Participant') ?\n        oldParent :\n        getAncestor(oldParent, 'bpmn:Participant');\n\n      updateDataStoreParent(shape, participant);\n    }\n  });\n\n\n  // update data store parents on participant or subprocess deleted\n  this.postExecute('shape.delete', function(event) {\n    var context = event.context,\n        shape = context.shape,\n        rootElement = canvas.getRootElement();\n\n    if (isAny(shape, [ 'bpmn:Participant', 'bpmn:SubProcess' ])\n        && is(rootElement, 'bpmn:Collaboration')) {\n      getDataStores(rootElement)\n        .filter(function(dataStore) {\n          return isDescendant(dataStore, shape);\n        })\n        .forEach(function(dataStore) {\n          updateDataStoreParent(dataStore);\n        });\n    }\n  });\n\n  // update data store parents on collaboration -> process\n  this.postExecute('canvas.updateRoot', function(event) {\n    var context = event.context,\n        oldRoot = context.oldRoot,\n        newRoot = context.newRoot;\n\n    var dataStores = getDataStores(oldRoot);\n\n    dataStores.forEach(function(dataStore) {\n\n      if (is(newRoot, 'bpmn:Process')) {\n        updateDataStoreParent(dataStore, newRoot);\n      }\n\n    });\n  });\n}\n\nDataStoreBehavior.$inject = [\n  'canvas',\n  'commandStack',\n  'elementRegistry',\n  'eventBus',\n];\n\ninherits(DataStoreBehavior, CommandInterceptor);\n\n\n// helpers //////////\n\nfunction isDescendant(descendant, ancestor) {\n  var descendantBo = descendant.businessObject || descendant,\n      ancestorBo = ancestor.businessObject || ancestor;\n\n  while (descendantBo.$parent) {\n    if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {\n      return true;\n    }\n\n    descendantBo = descendantBo.$parent;\n  }\n\n  return false;\n}\n\nfunction getAncestor(element, type) {\n\n  while (element.parent) {\n    if (is(element.parent, type)) {\n      return element.parent;\n    }\n\n    element = element.parent;\n  }\n}"
    },
    "6": {
        "bug_file": "lib/features/popup-menu/ReplaceMenuProvider.js",
        "compressed": "YES",
        "line_numbers": 546,
        "compressed_line_numbers": 163,
        "compressed_bug_file_content": "import {\n\n\nimport {\n\n\nimport {\n\n\nimport {\n\n\nimport * as replaceOptions from '../replace/ReplaceOptions';\n\n\n/**\n * This module is an element agnostic replace menu provider for the popup menu.\n */\nexport default function ReplaceMenuProvider(\n\n\n/**\n * Register replace menu provider in the popup menu\n */\n\n\n/**\n * Get all entries from replaceOptions for the given element and apply filters\n * on them. Get for example only elements, which are different from the current one.\n *\n * @param {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu entry items\n */\n\n\n  // start events outside sub processes\n\n\n  // expanded/collapsed pools\n\n\n  // start events inside event sub processes\n\n\n      // filters elements which types and event definition are equal but have have different interrupting types\n\n\n  // start events inside sub processes\n\n\n  // end events\n\n\n      // hide cancel end events outside transactions\n\n\n  // boundary events\n\n\n  // intermediate events\n\n\n  // gateways\n\n\n  // transactions\n\n\n  // expanded event sub processes\n\n\n  // expanded sub processes\n\n\n  // collapsed ad hoc sub processes\n\n\n  // sequence flows\n\n\n  // flow nodes\n\n\n    // collapsed SubProcess can not be replaced with itself\n\n\n/**\n * Get a list of header items for the given element. This includes buttons\n * for multi instance markers and for the ad hoc marker.\n *\n * @param {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu entry items\n */\n\n\n/**\n * Creates an array of menu entry objects for a given element and filters the replaceOptions\n * according to a filter function.\n *\n * @param  {djs.model.Base} element\n * @param  {Object} replaceOptions\n *\n * @return {Array<Object>} a list of menu items\n */\n\n\n/**\n * Creates an array of menu entry objects for a given sequence flow.\n *\n * @param  {djs.model.Base} element\n * @param  {Object} replaceOptions\n\n * @return {Array<Object>} a list of menu items\n */\n\n\n      // default flows\n\n\n      // conditional flows\n\n\n/**\n * Creates and returns a single menu entry item.\n *\n * @param  {Object} definition a single replace options definition object\n * @param  {djs.model.Base} element\n * @param  {Function} [action] an action callback function which gets called when\n *                             the menu entry is being triggered.\n *\n * @return {Object} menu entry item\n */\n\n\n/**\n * Get a list of menu items containing buttons for multi instance markers\n *\n * @param  {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu items\n */\n\n\n/**\n * Get a list of menu items containing buttons for multi instance markers\n *\n * @param  {djs.model.Base} element\n *\n * @return {Array<Object>} a list of menu items\n */\n\n\n/**\n * Get the menu items containing a button for the ad hoc marker\n *\n * @param  {djs.model.Base} element\n *\n * @return {Object} a menu item\n */\n\n\n"
    }
}