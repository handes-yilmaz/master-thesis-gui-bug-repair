{
    "1": {
        "bug_file": "lib/cli-engine/cli-engine.js",
        "compressed": "YES",
        "line_numbers": 1045,
        "compressed_line_numbers": 470,
        "compressed_bug_file_content": "/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n/*\n * For some reason, ModuleResolver must be included via filepath instead of by\n * API exports in order to work properly. That's why this is separated out onto\n * its own require() statement.\n */\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {ReturnType<CascadingConfigArrayFactory[\"getConfigArrayForFile\"]>} ConfigArray */\n/** @typedef {ReturnType<ConfigArray[\"extractConfig\"]>} ExtractedConfig */\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this CLIEngine instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {string} [configFile] The configuration file to use.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {string[]} [envs] An array of environments to load.\n * @property {string[]|null} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {string[]} [globals] An array of global variables to declare.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {string|string[]} [ignorePattern] One or more glob patterns to ignore.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc\n * @property {string} [parser] The name of the parser to use.\n * @property {ParserOptions} [parserOptions] An object of parserOption settings to use.\n * @property {string[]} [plugins] An array of plugins to load.\n * @property {Record<string,RuleConf>} [rules] An object of rules to use.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [reportUnusedDisableDirectives] `true` adds reports for unused eslint-disable directives\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n/**\n * Linting results.\n * @typedef {Object} LintReport\n * @property {LintResult[]} results All of the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private data for CLIEngine.\n * @typedef {Object} CLIEngineInternalSlots\n * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cacheFilePath The path to the cache of lint results.\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.\n * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.\n * @property {FileEnumerator} fileEnumerator The file enumerator.\n * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\n * @property {LintResultCache|null} lintResultCache The cache of lint results.\n * @property {Linter} linter The linter instance which has loaded rules.\n * @property {CLIEngineOptions} options The normalized options of this instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */\n\n\n/**\n * Determines if each fix type in an array is supported by ESLint and throws\n * an error if not.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {void}\n * @throws {Error} If an invalid fix type is found.\n */\n\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\n\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {LintResult[]} results Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\n\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {ConfigArray} config.config The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.\n * @param {FileEnumerator} config.fileEnumerator The file enumerator to check if a path is a target or not.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\n\n\n    /*\n     * Verify.\n     * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n     * doesn't know CWD, so it gives `linter` an absolute path always.\n     */\n\n\n            /**\n             * Check if the linter should adopt a given code block or not.\n             * @param {string} blockFilename The virtual filename of a code block.\n             * @returns {boolean} `true` if the linter should adopt the code block.\n             */\n\n\n    // Tweak and return.\n\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir  Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\n\n\n/**\n * Get a rule.\n * @param {string} ruleId The rule ID to get.\n * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.\n * @returns {Rule|null} The rule or null.\n */\n\n\n/**\n * Collect used deprecated rules.\n * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\n */\n\n\n    // Flatten used configs.\n    /** @type {ExtractedConfig[]} */\n\n\n    // Traverse rule configs.\n\n\n            // Skip if it was processed.\n\n\n            // Skip if it's not used.\n\n\n            // Skip if it's not deprecated.\n\n\n            // This rule was used and deprecated.\n\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\n\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n\n\n        // is file so just use that file\n\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n\n\n/**\n * Convert a string array to a boolean map.\n * @param {string[]|null} keys The keys to assign true.\n * @param {boolean} defaultValue The default value for each property.\n * @param {string} displayName The property name which is used in error message.\n * @returns {Record<string,boolean>} The boolean map.\n */\n\n\n/**\n * Create a config data from CLI options.\n * @param {CLIEngineOptions} options The options\n * @returns {ConfigData|null} The created config data.\n */\n\n\n/**\n * Checks whether a directory exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @returns {boolean} `true` if a directory exists\n */\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\n    /**\n     * Creates a new instance of the core CLI engine.\n     * @param {CLIEngineOptions} providedOptions The options for this instance.\n     */\n\n\n        /** @type {ConfigArray[]} */\n\n\n        // Store private data.\n\n\n        // setup special filter for fixes\n\n\n            // throw an error if any invalid fix types are found\n\n\n            // convert to Set for faster lookup\n\n\n            // save original value of options.fix in case it's a function\n\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintReport} report The report object created by CLIEngine.\n     * @returns {void}\n     */\n\n\n    /**\n     * Add a plugin by passing its configuration\n     * @param {string} name Name of the plugin.\n     * @param {Plugin} pluginObject Plugin configuration object.\n     * @returns {void}\n     */\n\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {LintReport} The results for all files that were linted.\n     */\n\n\n        // Clear the last used config arrays.\n\n\n        // Delete cache file; should this do here?\n\n\n                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n\n\n        // Iterate source code files.\n\n\n            /*\n             * Store used configs for:\n             * - this method uses to collect used deprecated rules.\n             * - `getRules()` method uses to collect all loaded rules.\n             * - `--fix-type` option uses to get the loaded rule's meta data.\n             */\n\n\n            // Skip if there is cached result.\n\n\n            // Do lint.\n\n\n            /*\n             * Store the lint result in the LintResultCache.\n             * NOTE: The LintResultCache will remove the file source and any\n             * other properties that are difficult to serialize, and will\n             * hydrate those properties back in on future lint runs.\n             */\n\n\n        // Persist the cache to disk.\n\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} [filename] An optional string representing the texts filename.\n     * @param {boolean} [warnIgnored] Always warn when a file is ignored\n     * @returns {LintReport} The results for the linting.\n     */\n\n\n        // Clear the last used config arrays.\n\n\n            /*\n             * Store used configs for:\n             * - this method uses to collect used deprecated rules.\n             * - `getRules()` method uses to collect all loaded rules.\n             * - `--fix-type` option uses to get the loaded rule's meta data.\n             */\n\n\n            // Do lint.\n\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {ConfigData} A configuration object for the file.\n     */\n\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n\n\n    /**\n     * Returns the formatter representing the given format or null if the `format` is not a string.\n     * @param {string} [format] The name of the format to load or the path to a\n     *      custom formatter.\n     * @returns {(Function|null)} The formatter function or null if the `format` is not a string.\n     */\n\n\n        // default is stylish\n\n\n        // only strings are valid formatters\n\n\n            // replace \\ with / for Windows compatibility\n\n\n            // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n\n\n    /**\n     * Get the internal slots of a given CLIEngine instance for tests.\n     * @param {CLIEngine} instance The CLIEngine instance to get.\n     * @returns {CLIEngineInternalSlots} The internal slots.\n     */\n\n\n"
    },
    "2": {
        "bug_file": "lib/cli.js",
        "compressed": "NO",
        "line_numbers": 328,
        "compressed_line_numbers": 328,
        "compressed_bug_file_content": "/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    { promisify } = require(\"util\"),\n    { ESLint } = require(\"./eslint\"),\n    CLIOptions = require(\"./options\"),\n    log = require(\"./shared/logging\"),\n    RuntimeInfo = require(\"./shared/runtime-info\");\n\nconst debug = require(\"debug\")(\"eslint:cli\");\n\n//------------------------------------------------------------------------------\n// Types\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"./eslint/eslint\").ESLintOptions} ESLintOptions */\n/** @typedef {import(\"./eslint/eslint\").LintMessage} LintMessage */\n/** @typedef {import(\"./eslint/eslint\").LintResult} LintResult */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst mkdir = promisify(fs.mkdir);\nconst stat = promisify(fs.stat);\nconst writeFile = promisify(fs.writeFile);\n\n/**\n * Predicate function for whether or not to apply fixes in quiet mode.\n * If a message is a warning, do not apply a fix.\n * @param {LintMessage} message The lint result.\n * @returns {boolean} True if the lint message is an error (and thus should be\n * autofixed), false otherwise.\n */\nfunction quietFixPredicate(message) {\n    return message.severity === 2;\n}\n\n/**\n * Translates the CLI options into the options expected by the CLIEngine.\n * @param {Object} cliOptions The CLI options to translate.\n * @returns {ESLintOptions} The options object for the CLIEngine.\n * @private\n */\nfunction translateOptions({\n    cache,\n    cacheFile,\n    cacheLocation,\n    cacheStrategy,\n    config,\n    env,\n    errorOnUnmatchedPattern,\n    eslintrc,\n    ext,\n    fix,\n    fixDryRun,\n    fixType,\n    global,\n    ignore,\n    ignorePath,\n    ignorePattern,\n    inlineConfig,\n    parser,\n    parserOptions,\n    plugin,\n    quiet,\n    reportUnusedDisableDirectives,\n    resolvePluginsRelativeTo,\n    rule,\n    rulesdir\n}) {\n    return {\n        allowInlineConfig: inlineConfig,\n        cache,\n        cacheLocation: cacheLocation || cacheFile,\n        cacheStrategy,\n        errorOnUnmatchedPattern,\n        extensions: ext,\n        fix: (fix || fixDryRun) && (quiet ? quietFixPredicate : true),\n        fixTypes: fixType,\n        ignore,\n        ignorePath,\n        overrideConfig: {\n            env: env && env.reduce((obj, name) => {\n                obj[name] = true;\n                return obj;\n            }, {}),\n            globals: global && global.reduce((obj, name) => {\n                if (name.endsWith(\":true\")) {\n                    obj[name.slice(0, -5)] = \"writable\";\n                } else {\n                    obj[name] = \"readonly\";\n                }\n                return obj;\n            }, {}),\n            ignorePatterns: ignorePattern,\n            parser,\n            parserOptions,\n            plugins: plugin,\n            rules: rule\n        },\n        overrideConfigFile: config,\n        reportUnusedDisableDirectives: reportUnusedDisableDirectives ? \"error\" : void 0,\n        resolvePluginsRelativeTo,\n        rulePaths: rulesdir,\n        useEslintrc: eslintrc\n    };\n}\n\n/**\n * Count error messages.\n * @param {LintResult[]} results The lint results.\n * @returns {{errorCount:number;warningCount:number}} The number of error messages.\n */\nfunction countErrors(results) {\n    let errorCount = 0;\n    let warningCount = 0;\n\n    for (const result of results) {\n        errorCount += result.errorCount;\n        warningCount += result.warningCount;\n    }\n\n    return { errorCount, warningCount };\n}\n\n/**\n * Check if a given file path is a directory or not.\n * @param {string} filePath The path to a file to check.\n * @returns {Promise<boolean>} `true` if the given path is a directory.\n */\nasync function isDirectory(filePath) {\n    try {\n        return (await stat(filePath)).isDirectory();\n    } catch (error) {\n        if (error.code === \"ENOENT\" || error.code === \"ENOTDIR\") {\n            return false;\n        }\n        throw error;\n    }\n}\n\n/**\n * Outputs the results of the linting.\n * @param {ESLint} engine The ESLint instance to use.\n * @param {LintResult[]} results The results to print.\n * @param {string} format The name of the formatter to use or the path to the formatter.\n * @param {string} outputFile The path for the output file.\n * @returns {Promise<boolean>} True if the printing succeeds, false if not.\n * @private\n */\nasync function printResults(engine, results, format, outputFile) {\n    let formatter;\n\n    try {\n        formatter = await engine.loadFormatter(format);\n    } catch (e) {\n        log.error(e.message);\n        return false;\n    }\n\n    const output = formatter.format(results);\n\n    if (output) {\n        if (outputFile) {\n            const filePath = path.resolve(process.cwd(), outputFile);\n\n            if (await isDirectory(filePath)) {\n                log.error(\"Cannot write to output file path, it is a directory: %s\", outputFile);\n                return false;\n            }\n\n            try {\n                await mkdir(path.dirname(filePath), { recursive: true });\n                await writeFile(filePath, output);\n            } catch (ex) {\n                log.error(\"There was a problem writing the output file:\\n%s\", ex);\n                return false;\n            }\n        } else {\n            log.info(output);\n        }\n    }\n\n    return true;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as\n * for other Node.js programs to effectively run the CLI.\n */\nconst cli = {\n\n    /**\n     * Executes the CLI based on an array of arguments that is passed in.\n     * @param {string|Array|Object} args The arguments to process.\n     * @param {string} [text] The text to lint (used for TTY).\n     * @returns {Promise<number>} The exit code for the operation.\n     */\n    async execute(args, text) {\n        if (Array.isArray(args)) {\n            debug(\"CLI args: %o\", args.slice(2));\n        }\n        let options;\n\n        try {\n            options = CLIOptions.parse(args);\n        } catch (error) {\n            log.error(error.message);\n            return 2;\n        }\n\n        const files = options._;\n        const useStdin = typeof text === \"string\";\n\n        if (options.help) {\n            log.info(CLIOptions.generateHelp());\n            return 0;\n        }\n        if (options.version) {\n            log.info(RuntimeInfo.version());\n            return 0;\n        }\n        if (options.envInfo) {\n            try {\n                log.info(RuntimeInfo.environment());\n                return 0;\n            } catch (err) {\n                log.error(err.message);\n                return 2;\n            }\n        }\n\n        if (options.printConfig) {\n            if (files.length) {\n                log.error(\"The --print-config option must be used with exactly one file name.\");\n                return 2;\n            }\n            if (useStdin) {\n                log.error(\"The --print-config option is not available for piped-in code.\");\n                return 2;\n            }\n\n            const engine = new ESLint(translateOptions(options));\n            const fileConfig =\n                await engine.calculateConfigForFile(options.printConfig);\n\n            log.info(JSON.stringify(fileConfig, null, \"  \"));\n            return 0;\n        }\n\n        debug(`Running on ${useStdin ? \"text\" : \"files\"}`);\n\n        if (options.fix && options.fixDryRun) {\n            log.error(\"The --fix option and the --fix-dry-run option cannot be used together.\");\n            return 2;\n        }\n        if (useStdin && options.fix) {\n            log.error(\"The --fix option is not available for piped-in code; use --fix-dry-run instead.\");\n            return 2;\n        }\n        if (options.fixType && !options.fix && !options.fixDryRun) {\n            log.error(\"The --fix-type option requires either --fix or --fix-dry-run.\");\n            return 2;\n        }\n\n        const engine = new ESLint(translateOptions(options));\n        let results;\n\n        if (useStdin) {\n            results = await engine.lintText(text, {\n                filePath: options.stdinFilename,\n                warnIgnored: true\n            });\n        } else {\n            results = await engine.lintFiles(files);\n        }\n\n        if (options.fix) {\n            debug(\"Fix mode enabled - applying fixes\");\n            await ESLint.outputFixes(results);\n        }\n\n        if (options.quiet) {\n            debug(\"Quiet mode enabled - filtering out warnings\");\n            results = ESLint.getErrorResults(results);\n        }\n\n        if (await printResults(engine, results, options.format, options.outputFile)) {\n            const { errorCount, warningCount } = countErrors(results);\n            const tooManyWarnings =\n                options.maxWarnings >= 0 && warningCount > options.maxWarnings;\n\n            if (!errorCount && tooManyWarnings) {\n                log.error(\n                    \"ESLint found too many warnings (maximum: %s).\",\n                    options.maxWarnings\n                );\n            }\n\n            return (errorCount || tooManyWarnings) ? 1 : 0;\n        }\n\n        return 2;\n    }\n};\n\nmodule.exports = cli;"
    }
}