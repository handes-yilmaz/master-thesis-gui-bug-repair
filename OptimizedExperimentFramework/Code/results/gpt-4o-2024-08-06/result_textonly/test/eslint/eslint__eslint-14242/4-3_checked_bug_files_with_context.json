{
    "lib/cli-engine/cli-engine.js": [
        "...",
        " * @fileoverview Main CLI object.",
        " * @author Nicholas C. Zakas",
        " */",
        "",
        "\"use strict\";",
        "",
        "/*",
        " * The CLI object should *not* call process.exit() directly. It should only return",
        " * exit codes. This allows other programs to use the CLI object and still control",
        " * when the program exits.",
        " */",
        "",
        "//------------------------------------------------------------------------------",
        "// Requirements",
        "//------------------------------------------------------------------------------",
        "",
        "const fs = require(\"fs\");",
        "const path = require(\"path\");",
        "const defaultOptions = require(\"../../conf/default-cli-options\");",
        "const pkg = require(\"../../package.json\");",
        "",
        "",
        "const {",
        "    Legacy: {",
        "        ConfigOps,",
        "        naming,",
        "        CascadingConfigArrayFactory,",
        "        IgnorePattern,",
        "        getUsedExtractedConfigs",
        "    }",
        "} = require(\"@eslint/eslintrc\");",
        "",
        "/*",
        " * For some reason, ModuleResolver must be included via filepath instead of by",
        " * API exports in order to work properly. That's why this is separated out onto",
        " * its own require() statement.",
        " */",
        "const ModuleResolver = require(\"@eslint/eslintrc/lib/shared/relative-module-resolver\");",
        "const { FileEnumerator } = require(\"./file-enumerator\");",
        "",
        "const { Linter } = require(\"../linter\");",
        "const builtInRules = require(\"../rules\");",
        "const loadRules = require(\"./load-rules\");",
        "const hash = require(\"./hash\");",
        "const LintResultCache = require(\"./lint-result-cache\");",
        "",
        "const debug = require(\"debug\")(\"eslint:cli-engine\");",
        "const validFixTypes = new Set([\"problem\", \"suggestion\", \"layout\"]);",
        "",
        "//------------------------------------------------------------------------------",
        "// Typedefs",
        "//------------------------------------------------------------------------------",
        "",
        "// For VSCode IntelliSense",
        "/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */",
        "/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */",
        "/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */",
        "/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */",
        "/** @typedef {import(\"../shared/types\").Plugin} Plugin */",
        "/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */",
        "/** @typedef {import(\"../shared/types\").Rule} Rule */",
        "/** @typedef {ReturnType<CascadingConfigArrayFactory[\"getConfigArrayForFile\"]>} ConfigArray */",
        "/** @typedef {ReturnType<ConfigArray[\"extractConfig\"]>} ExtractedConfig */",
        "",
        "/**",
        " * The options to configure a CLI engine with.",
        " * @typedef {Object} CLIEngineOptions",
        " * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.",
        " * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this CLIEngine instance",
        " * @property {boolean} [cache] Enable result caching.",
        " * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.",
        " * @property {string} [configFile] The configuration file to use.",
        " * @property {string} [cwd] The value to use for the current working directory.",
        " * @property {string[]} [envs] An array of environments to load.",
        " * @property {string[]|null} [extensions] An array of file extensions to check.",
        " * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.",
        " * @property {string[]} [fixTypes] Array of rule types to apply fixes for.",
        " * @property {string[]} [globals] An array of global variables to declare.",
        " * @property {boolean} [ignore] False disables use of .eslintignore.",
        " * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.",
        " * @property {string|string[]} [ignorePattern] One or more glob patterns to ignore.",
        " * @property {boolean} [useEslintrc] False disables looking for .eslintrc",
        " * @property {string} [parser] The name of the parser to use.",
        " * @property {ParserOptions} [parserOptions] An object of parserOption settings to use.",
        " * @property {string[]} [plugins] An array of plugins to load.",
        " * @property {Record<string,RuleConf>} [rules] An object of rules to use.",
        " * @property {string[]} [rulePaths] An array of directories to load custom rules from.",
        " * @property {boolean} [reportUnusedDisableDirectives] `true` adds reports for unused eslint-disable directives",
        " * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.",
        " * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD",
        " */",
        "",
        "/**",
        " * A linting result.",
        " * @typedef {Object} LintResult",
        " * @property {string} filePath The path to the file that was linted.",
        " * @property {LintMessage[]} messages All of the messages for the result.",
        " * @property {number} errorCount Number of errors for the result.",
        " * @property {number} warningCount Number of warnings for the result.",
        " * @property {number} fixableErrorCount Number of fixable errors for the result.",
        " * @property {number} fixableWarningCount Number of fixable warnings for the result.",
        " * @property {string} [source] The source code of the file that was linted.",
        " * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.",
        " */",
        "",
        "/**",
        " * Linting results.",
        " * @typedef {Object} LintReport",
        " * @property {LintResult[]} results All of the result.",
        " * @property {number} errorCount Number of errors for the result.",
        " * @property {number} warningCount Number of warnings for the result.",
        " * @property {number} fixableErrorCount Number of fixable errors for the result.",
        " * @property {number} fixableWarningCount Number of fixable warnings for the result.",
        " * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.",
        " */",
        "",
        "/**",
        " * Private data for CLIEngine.",
        " * @typedef {Object} CLIEngineInternalSlots",
        " * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.",
        " * @property {string} cacheFilePath The path to the cache of lint results.",
        " * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.",
        " * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.",
        " * @property {FileEnumerator} fileEnumerator The file enumerator.",
        " * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.",
        " * @property {LintResultCache|null} lintResultCache The cache of lint results.",
        " * @property {Linter} linter The linter instance which has loaded rules.",
        " * @property {CLIEngineOptions} options The normalized options of this instance.",
        " */",
        "",
        "//------------------------------------------------------------------------------",
        "// Helpers",
        "//------------------------------------------------------------------------------",
        "",
        "/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */",
        "const internalSlotsMap = new WeakMap();",
        "",
        "/**",
        " * Determines if each fix type in an array is supported by ESLint and throws",
        " * an error if not.",
        " * @param {string[]} fixTypes An array of fix types to check.",
        " * @returns {void}",
        " * @throws {Error} If an invalid fix type is found.",
        " */",
        "function validateFixTypes(fixTypes) {",
        "    for (const fixType of fixTypes) {",
        "        if (!validFixTypes.has(fixType)) {",
        "            throw new Error(`Invalid fix type \"${fixType}\" found.`);",
        "        }",
        "    }",
        "}",
        "",
        "/**",
        " * It will calculate the error and warning count for collection of messages per file",
        " * @param {LintMessage[]} messages Collection of messages",
        " * @returns {Object} Contains the stats",
        " * @private",
        " */",
        "function calculateStatsPerFile(messages) {",
        "    return messages.reduce((stat, message) => {",
        "        if (message.fatal || message.severity === 2) {",
        "            stat.errorCount++;",
        "            if (message.fix) {",
        "                stat.fixableErrorCount++;",
        "            }",
        "        } else {",
        "            stat.warningCount++;",
        "            if (message.fix) {",
        "                stat.fixableWarningCount++;",
        "            }",
        "        }",
        "        return stat;",
        "    }, {",
        "        errorCount: 0,",
        "        warningCount: 0,",
        "        fixableErrorCount: 0,",
        "        fixableWarningCount: 0",
        "    });",
        "}",
        "",
        "/**",
        " * It will calculate the error and warning count for collection of results from all files",
        " * @param {LintResult[]} results Collection of messages from all the files",
        " * @returns {Object} Contains the stats",
        " * @private",
        " */",
        "function calculateStatsPerRun(results) {",
        "    return results.reduce((stat, result) => {",
        "        stat.errorCount += result.errorCount;",
        "        stat.warningCount += result.warningCount;",
        "        stat.fixableErrorCount += result.fixableErrorCount;",
        "        stat.fixableWarningCount += result.fixableWarningCount;",
        "        return stat;",
        "    }, {",
        "        errorCount: 0,",
        "        warningCount: 0,",
        "        fixableErrorCount: 0,",
        "        fixableWarningCount: 0",
        "    });",
        "}",
        "",
        "/**",
        " * Processes an source code using ESLint.",
        " * @param {Object} config The config object.",
        " * @param {string} config.text The source code to verify.",
        " * @param {string} config.cwd The path to the current working directory.",
        " * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.",
        " * @param {ConfigArray} config.config The config.",
        " * @param {boolean} config.fix If `true` then it does fix.",
        " * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.",
        " * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.",
        " * @param {FileEnumerator} config.fileEnumerator The file enumerator to check if a path is a target or not.",
        " * @param {Linter} config.linter The linter instance to verify.",
        " * @returns {LintResult} The result of linting.",
        " * @private",
        " */",
        "function verifyText({",
        "    text,",
        "    cwd,",
        "    filePath: providedFilePath,",
        "    config,",
        "    fix,",
        "    allowInlineConfig,",
        "    reportUnusedDisableDirectives,",
        "    fileEnumerator,",
        "    linter",
        "}) {",
        "    const filePath = providedFilePath || \"<text>\";",
        "",
        "    debug(`Lint ${filePath}`);",
        "",
        "    /*",
        "     * Verify.",
        "     * `config.extractConfig(filePath)` requires an absolute path, but `linter`",
        "     * doesn't know CWD, so it gives `linter` an absolute path always.",
        "     */",
        "    const filePathToVerify = filePath === \"<text>\" ? path.join(cwd, filePath) : filePath;",
        "    const { fixed, messages, output } = linter.verifyAndFix(",
        "        text,",
        "        config,",
        "        {",
        "            allowInlineConfig,",
        "            filename: filePathToVerify,",
        "            fix,",
        "            reportUnusedDisableDirectives,",
        "",
        "            /**",
        "             * Check if the linter should adopt a given code block or not.",
        "             * @param {string} blockFilename The virtual filename of a code block.",
        "             * @returns {boolean} `true` if the linter should adopt the code block.",
        "             */",
        "            filterCodeBlock(blockFilename) {",
        "                return fileEnumerator.isTargetPath(blockFilename);",
        "            }",
        "        }",
        "    );",
        "",
        "    // Tweak and return.",
        "    const result = {",
        "        filePath,",
        "        messages,",
        "        ...calculateStatsPerFile(messages)",
        "    };",
        "",
        "    if (fixed) {",
        "        result.output = output;",
        "    }",
        "    if (",
        "        result.errorCount + result.warningCount > 0 &&",
        "        typeof result.output === \"undefined\"",
        "    ) {",
        "        result.source = text;",
        "    }",
        "",
        "    return result;",
        "}",
        "",
        "/**",
        " * Returns result with warning by ignore settings",
        " * @param {string} filePath File path of checked code",
        " * @param {string} baseDir  Absolute path of base directory",
        " * @returns {LintResult} Result with single warning",
        " * @private",
        " */",
        "function createIgnoreResult(filePath, baseDir) {",
        "    let message;",
        "    const isHidden = filePath.split(path.sep)",
        "        .find(segment => /^\\./u.test(segment));",
        "    const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");",
        "",
        "    if (isHidden) {",
        "        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";",
        "    } else if (isInNodeModules) {",
        "        message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";",
        "    } else {",
        "        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";",
        "    }",
        "",
        "    return {",
        "        filePath: path.resolve(filePath),",
        "        messages: [",
        "            {",
        "                fatal: false,",
        "                severity: 1,",
        "                message",
        "            }",
        "        ],",
        "        errorCount: 0,",
        "        warningCount: 1,",
        "        fixableErrorCount: 0,",
        "        fixableWarningCount: 0",
        "    };",
        "}",
        "",
        "/**",
        " * Get a rule.",
        " * @param {string} ruleId The rule ID to get.",
        " * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.",
        " * @returns {Rule|null} The rule or null.",
        " */",
        "function getRule(ruleId, configArrays) {",
        "    for (const configArray of configArrays) {",
        "        const rule = configArray.pluginRules.get(ruleId);",
        "",
        "        if (rule) {",
        "            return rule;",
        "        }",
        "    }",
        "    return builtInRules.get(ruleId) || null;",
        "}",
        "",
        "/**",
        " * Collect used deprecated rules.",
        " * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.",
        " * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.",
        " */",
        "function *iterateRuleDeprecationWarnings(usedConfigArrays) {",
        "    const processedRuleIds = new Set();",
        "",
        "    // Flatten used configs.",
        "    /** @type {ExtractedConfig[]} */",
        "    const configs = [].concat(",
        "        ...usedConfigArrays.map(getUsedExtractedConfigs)",
        "    );",
        "",
        "    // Traverse rule configs.",
        "    for (const config of configs) {",
        "        for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {",
        "",
        "            // Skip if it was processed.",
        "            if (processedRuleIds.has(ruleId)) {",
        "                continue;",
        "            }",
        "            processedRuleIds.add(ruleId);",
        "",
        "            // Skip if it's not used.",
        "            if (!ConfigOps.getRuleSeverity(ruleConfig)) {",
        "                continue;",
        "            }",
        "            const rule = getRule(ruleId, usedConfigArrays);",
        "",
        "            // Skip if it's not deprecated.",
        "            if (!(rule && rule.meta && rule.meta.deprecated)) {",
        "                continue;",
        "            }",
        "",
        "            // This rule was used and deprecated.",
        "            yield {",
        "                ruleId,",
        "                replacedBy: rule.meta.replacedBy || []",
        "            };",
        "        }",
        "    }",
        "}",
        "",
        "/**",
        " * Checks if the given message is an error message.",
        " * @param {LintMessage} message The message to check.",
        " * @returns {boolean} Whether or not the message is an error message.",
        " * @private",
        " */",
        "function isErrorMessage(message) {",
        "    return message.severity === 2;",
        "}",
        "",
        "",
        "/**",
        " * return the cacheFile to be used by eslint, based on whether the provided parameter is",
        " * a directory or looks like a directory (ends in `path.sep`), in which case the file",
        " * name will be the `cacheFile/.cache_hashOfCWD`",
        " *",
        " * if cacheFile points to a file or looks like a file then in will just use that file",
        " * @param {string} cacheFile The name of file to be used to store the cache",
        " * @param {string} cwd Current working directory",
        " * @returns {string} the resolved path to the cache file",
        " */",
        "function getCacheFile(cacheFile, cwd) {",
        "",
        "    /*",
        "     * make sure the path separators are normalized for the environment/os",
        "     * keeping the trailing path separator if present",
        "     */",
        "    const normalizedCacheFile = path.normalize(cacheFile);",
        "",
        "    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);",
        "    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;",
        "",
        "    /**",
        "     * return the name for the cache file in case the provided parameter is a directory",
        "     * @returns {string} the resolved path to the cacheFile",
        "     */",
        "    function getCacheFileForDirectory() {",
        "        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);",
        "    }",
        "",
        "    let fileStats;",
        "",
        "    try {",
        "        fileStats = fs.lstatSync(resolvedCacheFile);",
        "    } catch {",
        "        fileStats = null;",
        "    }",
        "",
        "",
        "    /*",
        "     * in case the file exists we need to verify if the provided path",
        "     * is a directory or a file. If it is a directory we want to create a file",
        "     * inside that directory",
        "     */",
        "    if (fileStats) {",
        "",
        "        /*",
        "         * is a directory or is a file, but the original file the user provided",
        "         * looks like a directory but `path.resolve` removed the `last path.sep`",
        "         * so we need to still treat this like a directory",
        "         */",
        "        if (fileStats.isDirectory() || looksLikeADirectory) {",
        "            return getCacheFileForDirectory();",
        "        }",
        "",
        "        // is file so just use that file",
        "        return resolvedCacheFile;",
        "    }",
        "",
        "    /*",
        "     * here we known the file or directory doesn't exist,",
        "     * so we will try to infer if its a directory if it looks like a directory",
        "     * for the current operating system.",
        "     */",
        "",
        "    // if the last character passed is a path separator we assume is a directory",
        "    if (looksLikeADirectory) {",
        "        return getCacheFileForDirectory();",
        "    }",
        "",
        "    return resolvedCacheFile;",
        "}",
        "",
        "/**",
        " * Convert a string array to a boolean map.",
        " * @param {string[]|null} keys The keys to assign true.",
        " * @param {boolean} defaultValue The default value for each property.",
        " * @param {string} displayName The property name which is used in error message.",
        " * @returns {Record<string,boolean>} The boolean map.",
        " */",
        "function toBooleanMap(keys, defaultValue, displayName) {",
        "    if (keys && !Array.isArray(keys)) {",
        "        throw new Error(`${displayName} must be an array.`);",
        "    }",
        "    if (keys && keys.length > 0) {",
        "        return keys.reduce((map, def) => {",
        "            const [key, value] = def.split(\":\");",
        "",
        "            if (key !== \"__proto__\") {",
        "                map[key] = value === void 0",
        "                    ? defaultValue",
        "                    : value === \"true\";",
        "            }",
        "",
        "            return map;",
        "        }, {});",
        "    }",
        "    return void 0;",
        "}",
        "",
        "/**",
        " * Create a config data from CLI options.",
        " * @param {CLIEngineOptions} options The options",
        " * @returns {ConfigData|null} The created config data.",
        " */",
        "function createConfigDataFromOptions(options) {",
        "    const {",
        "        ignorePattern,",
        "        parser,",
        "        parserOptions,",
        "        plugins,",
        "        rules",
        "    } = options;",
        "    const env = toBooleanMap(options.envs, true, \"envs\");",
        "    const globals = toBooleanMap(options.globals, false, \"globals\");",
        "",
        "..."
    ],
    "lib/cli.js": [
        "/**",
        " * @fileoverview Main CLI object.",
        " * @author Nicholas C. Zakas",
        " */",
        "",
        "\"use strict\";",
        "",
        "/*",
        " * The CLI object should *not* call process.exit() directly. It should only return",
        " * exit codes. This allows other programs to use the CLI object and still control",
        " * when the program exits.",
        " */",
        "",
        "//------------------------------------------------------------------------------",
        "// Requirements",
        "//------------------------------------------------------------------------------",
        "",
        "const fs = require(\"fs\"),",
        "    path = require(\"path\"),",
        "    { promisify } = require(\"util\"),",
        "    { ESLint } = require(\"./eslint\"),",
        "    CLIOptions = require(\"./options\"),",
        "    log = require(\"./shared/logging\"),",
        "    RuntimeInfo = require(\"./shared/runtime-info\");",
        "",
        "const debug = require(\"debug\")(\"eslint:cli\");",
        "",
        "//------------------------------------------------------------------------------",
        "// Types",
        "//------------------------------------------------------------------------------",
        "",
        "/** @typedef {import(\"./eslint/eslint\").ESLintOptions} ESLintOptions */",
        "/** @typedef {import(\"./eslint/eslint\").LintMessage} LintMessage */",
        "/** @typedef {import(\"./eslint/eslint\").LintResult} LintResult */",
        "",
        "//------------------------------------------------------------------------------",
        "// Helpers",
        "//------------------------------------------------------------------------------",
        "",
        "const mkdir = promisify(fs.mkdir);",
        "const stat = promisify(fs.stat);",
        "const writeFile = promisify(fs.writeFile);",
        "",
        "/**",
        " * Predicate function for whether or not to apply fixes in quiet mode.",
        " * If a message is a warning, do not apply a fix.",
        " * @param {LintMessage} message The lint result.",
        " * @returns {boolean} True if the lint message is an error (and thus should be",
        " * autofixed), false otherwise.",
        " */",
        "function quietFixPredicate(message) {",
        "    return message.severity === 2;",
        "}",
        "",
        "/**",
        " * Translates the CLI options into the options expected by the CLIEngine.",
        " * @param {Object} cliOptions The CLI options to translate.",
        " * @returns {ESLintOptions} The options object for the CLIEngine.",
        " * @private",
        " */",
        "function translateOptions({",
        "    cache,",
        "    cacheFile,",
        "    cacheLocation,",
        "    cacheStrategy,",
        "    config,",
        "    env,",
        "    errorOnUnmatchedPattern,",
        "    eslintrc,",
        "    ext,",
        "    fix,",
        "    fixDryRun,",
        "    fixType,",
        "    global,",
        "    ignore,",
        "    ignorePath,",
        "    ignorePattern,",
        "    inlineConfig,",
        "    parser,",
        "    parserOptions,",
        "    plugin,",
        "    quiet,",
        "    reportUnusedDisableDirectives,",
        "    resolvePluginsRelativeTo,",
        "    rule,",
        "    rulesdir",
        "}) {",
        "    return {",
        "        allowInlineConfig: inlineConfig,",
        "        cache,",
        "        cacheLocation: cacheLocation || cacheFile,",
        "        cacheStrategy,",
        "        errorOnUnmatchedPattern,",
        "        extensions: ext,",
        "        fix: (fix || fixDryRun) && (quiet ? quietFixPredicate : true),",
        "        fixTypes: fixType,",
        "        ignore,",
        "        ignorePath,",
        "        overrideConfig: {",
        "            env: env && env.reduce((obj, name) => {",
        "                obj[name] = true;",
        "                return obj;",
        "            }, {}),",
        "            globals: global && global.reduce((obj, name) => {",
        "                if (name.endsWith(\":true\")) {",
        "                    obj[name.slice(0, -5)] = \"writable\";",
        "                } else {",
        "                    obj[name] = \"readonly\";",
        "                }",
        "                return obj;",
        "            }, {}),",
        "            ignorePatterns: ignorePattern,",
        "            parser,",
        "            parserOptions,",
        "            plugins: plugin,",
        "            rules: rule",
        "        },",
        "        overrideConfigFile: config,",
        "        reportUnusedDisableDirectives: reportUnusedDisableDirectives ? \"error\" : void 0,",
        "        resolvePluginsRelativeTo,",
        "        rulePaths: rulesdir,",
        "        useEslintrc: eslintrc",
        "    };",
        "}",
        "",
        "/**",
        " * Count error messages.",
        " * @param {LintResult[]} results The lint results.",
        " * @returns {{errorCount:number;warningCount:number}} The number of error messages.",
        " */",
        "function countErrors(results) {",
        "    let errorCount = 0;",
        "    let warningCount = 0;",
        "",
        "    for (const result of results) {",
        "        errorCount += result.errorCount;",
        "        warningCount += result.warningCount;",
        "    }",
        "",
        "    return { errorCount, warningCount };",
        "}",
        "",
        "/**",
        " * Check if a given file path is a directory or not.",
        " * @param {string} filePath The path to a file to check.",
        " * @returns {Promise<boolean>} `true` if the given path is a directory.",
        " */",
        "async function isDirectory(filePath) {",
        "    try {",
        "        return (await stat(filePath)).isDirectory();",
        "    } catch (error) {",
        "        if (error.code === \"ENOENT\" || error.code === \"ENOTDIR\") {",
        "            return false;",
        "        }",
        "        throw error;",
        "    }",
        "}",
        "",
        "/**",
        " * Outputs the results of the linting.",
        " * @param {ESLint} engine The ESLint instance to use.",
        " * @param {LintResult[]} results The results to print.",
        " * @param {string} format The name of the formatter to use or the path to the formatter.",
        " * @param {string} outputFile The path for the output file.",
        " * @returns {Promise<boolean>} True if the printing succeeds, false if not.",
        " * @private",
        " */",
        "async function printResults(engine, results, format, outputFile) {",
        "    let formatter;",
        "",
        "    try {",
        "        formatter = await engine.loadFormatter(format);",
        "    } catch (e) {",
        "        log.error(e.message);",
        "        return false;",
        "    }",
        "",
        "    const output = formatter.format(results);",
        "",
        "    if (output) {",
        "        if (outputFile) {",
        "            const filePath = path.resolve(process.cwd(), outputFile);",
        "",
        "            if (await isDirectory(filePath)) {",
        "                log.error(\"Cannot write to output file path, it is a directory: %s\", outputFile);",
        "                return false;",
        "            }",
        "",
        "            try {",
        "                await mkdir(path.dirname(filePath), { recursive: true });",
        "                await writeFile(filePath, output);",
        "            } catch (ex) {",
        "                log.error(\"There was a problem writing the output file:\\n%s\", ex);",
        "                return false;",
        "            }",
        "        } else {",
        "            log.info(output);",
        "        }",
        "    }",
        "",
        "    return true;",
        "}",
        "",
        "//------------------------------------------------------------------------------",
        "// Public Interface",
        "//------------------------------------------------------------------------------",
        "",
        "/**",
        " * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as",
        " * for other Node.js programs to effectively run the CLI.",
        " */",
        "const cli = {",
        "",
        "    /**",
        "     * Executes the CLI based on an array of arguments that is passed in.",
        "     * @param {string|Array|Object} args The arguments to process.",
        "     * @param {string} [text] The text to lint (used for TTY).",
        "     * @returns {Promise<number>} The exit code for the operation.",
        "     */",
        "    async execute(args, text) {",
        "        if (Array.isArray(args)) {",
        "            debug(\"CLI args: %o\", args.slice(2));",
        "        }",
        "        let options;",
        "",
        "        try {",
        "            options = CLIOptions.parse(args);",
        "        } catch (error) {",
        "            log.error(error.message);",
        "            return 2;",
        "        }",
        "",
        "        const files = options._;",
        "        const useStdin = typeof text === \"string\";",
        "",
        "        if (options.help) {",
        "            log.info(CLIOptions.generateHelp());",
        "            return 0;",
        "        }",
        "        if (options.version) {",
        "            log.info(RuntimeInfo.version());",
        "            return 0;",
        "        }",
        "        if (options.envInfo) {",
        "            try {",
        "                log.info(RuntimeInfo.environment());",
        "                return 0;",
        "            } catch (err) {",
        "                log.error(err.message);",
        "                return 2;",
        "            }",
        "        }",
        "",
        "        if (options.printConfig) {",
        "            if (files.length) {",
        "                log.error(\"The --print-config option must be used with exactly one file name.\");",
        "                return 2;",
        "            }",
        "            if (useStdin) {",
        "                log.error(\"The --print-config option is not available for piped-in code.\");",
        "                return 2;",
        "            }",
        "",
        "            const engine = new ESLint(translateOptions(options));",
        "            const fileConfig =",
        "                await engine.calculateConfigForFile(options.printConfig);",
        "",
        "            log.info(JSON.stringify(fileConfig, null, \"  \"));",
        "            return 0;",
        "        }",
        "",
        "        debug(`Running on ${useStdin ? \"text\" : \"files\"}`);",
        "",
        "        if (options.fix && options.fixDryRun) {",
        "            log.error(\"The --fix option and the --fix-dry-run option cannot be used together.\");",
        "            return 2;",
        "        }",
        "        if (useStdin && options.fix) {",
        "            log.error(\"The --fix option is not available for piped-in code; use --fix-dry-run instead.\");",
        "            return 2;",
        "        }",
        "        if (options.fixType && !options.fix && !options.fixDryRun) {",
        "            log.error(\"The --fix-type option requires either --fix or --fix-dry-run.\");",
        "            return 2;",
        "        }",
        "",
        "        const engine = new ESLint(translateOptions(options));",
        "        let results;",
        "",
        "        if (useStdin) {",
        "            results = await engine.lintText(text, {",
        "                filePath: options.stdinFilename,",
        "                warnIgnored: true",
        "            });",
        "        } else {",
        "            results = await engine.lintFiles(files);",
        "        }",
        "",
        "        if (options.fix) {",
        "            debug(\"Fix mode enabled - applying fixes\");",
        "            await ESLint.outputFixes(results);",
        "        }",
        "",
        "        if (options.quiet) {",
        "            debug(\"Quiet mode enabled - filtering out warnings\");",
        "            results = ESLint.getErrorResults(results);",
        "        }",
        "",
        "        if (await printResults(engine, results, options.format, options.outputFile)) {",
        "            const { errorCount, warningCount } = countErrors(results);",
        "            const tooManyWarnings =",
        "                options.maxWarnings >= 0 && warningCount > options.maxWarnings;",
        "",
        "            if (!errorCount && tooManyWarnings) {",
        "                log.error(",
        "                    \"ESLint found too many warnings (maximum: %s).\",",
        "                    options.maxWarnings",
        "                );",
        "            }",
        "",
        "            return (errorCount || tooManyWarnings) ? 1 : 0;",
        "        }",
        "",
        "        return 2;",
        "    }",
        "};",
        "",
        "module.exports = cli;"
    ]
}