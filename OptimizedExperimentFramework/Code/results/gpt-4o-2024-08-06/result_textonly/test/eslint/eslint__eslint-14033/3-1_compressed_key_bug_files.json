{
    "1": {
        "bug_file": "lib/rules/prefer-const.js",
        "compressed": "NO",
        "line_numbers": 476,
        "compressed_line_numbers": 476,
        "compressed_bug_file_content": "/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n * @param {ASTNode} identifier An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    let node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Checks if an property or element is from outer scope or function parameters\n * in destructing pattern.\n * @param {string} name A variable name to be checked.\n * @param {eslint-scope.Scope} initScope A scope to start find.\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\n */\nfunction isOuterVariableInDestructing(name, initScope) {\n\n    if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n        return true;\n    }\n\n    const variable = astUtils.getVariableByName(initScope, name);\n\n    if (variable !== null) {\n        return variable.defs.some(def => def.type === \"Parameter\");\n    }\n\n    return false;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Reference} reference A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    let node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Determines if a destructuring assignment node contains\n * any MemberExpression nodes. This is used to determine if a\n * variable that is only written once using destructuring can be\n * safely converted into a const declaration.\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\n * @returns {boolean} True if the destructuring pattern contains\n *      a MemberExpression, false if not.\n */\nfunction hasMemberExpressionAssignment(node) {\n    switch (node.type) {\n        case \"ObjectPattern\":\n            return node.properties.some(prop => {\n                if (prop) {\n\n                    /*\n                     * Spread elements have an argument property while\n                     * others have a value property. Because different\n                     * parsers use different node types for spread elements,\n                     * we just check if there is an argument property.\n                     */\n                    return hasMemberExpressionAssignment(prop.argument || prop.value);\n                }\n\n                return false;\n            });\n\n        case \"ArrayPattern\":\n            return node.elements.some(element => {\n                if (element) {\n                    return hasMemberExpressionAssignment(element);\n                }\n\n                return false;\n            });\n\n        case \"AssignmentPattern\":\n            return hasMemberExpressionAssignment(node.left);\n\n        case \"MemberExpression\":\n            return true;\n\n        // no default\n    }\n\n    return false;\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized nor assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *   e.g. `if (a) b = 1` / `return (b = 1)`\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\n *   `/*exported foo` directive comment makes such variables. This rule does not\n *   warn such variables because this rule cannot distinguish whether the\n *   exported variables are reassigned or not.\n * @param {eslint-scope.Variable} variable A variable to get.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    let writer = null;\n    let isReadBeforeInit = false;\n    const references = variable.references;\n\n    for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n\n        if (reference.isWrite()) {\n            const isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n\n            const destructuringHost = getDestructuringHost(reference);\n\n            if (destructuringHost !== null && destructuringHost.left !== void 0) {\n                const leftNode = destructuringHost.left;\n                let hasOuterVariables = false,\n                    hasNonIdentifiers = false;\n\n                if (leftNode.type === \"ObjectPattern\") {\n                    const properties = leftNode.properties;\n\n                    hasOuterVariables = properties\n                        .filter(prop => prop.value)\n                        .map(prop => prop.value.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n\n                } else if (leftNode.type === \"ArrayPattern\") {\n                    const elements = leftNode.elements;\n\n                    hasOuterVariables = elements\n                        .map(element => element && element.name)\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\n\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n                }\n\n                if (hasOuterVariables || hasNonIdentifiers) {\n                    return null;\n                }\n\n            }\n\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    /*\n     * If the assignment is from a different scope, ignore it.\n     * If the assignment cannot change to a declaration, ignore it.\n     */\n    const shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n\n    return writer.identifier;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    const identifierMap = new Map();\n\n    for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i];\n        const references = variable.references;\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        let prevId = null;\n\n        for (let j = 0; j < references.length; ++j) {\n            const reference = references[j];\n            const id = reference.identifier;\n\n            /*\n             * Avoid counting a reference twice or more for default values of\n             * destructuring.\n             */\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            const group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n/**\n * Finds the nearest parent of node with a given type.\n * @param {ASTNode} node The node to search from.\n * @param {string} type The type field of the parent node.\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\n */\nfunction findUp(node, type, shouldStop) {\n    if (!node || shouldStop(node)) {\n        return null;\n    }\n    if (node.type === type) {\n        return node;\n    }\n    return findUp(node.parent, type, shouldStop);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-const\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: { enum: [\"any\", \"all\"], default: \"any\" },\n                    ignoreReadBeforeAssign: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const sourceCode = context.getSourceCode();\n        const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        const variables = [];\n        let reportCount = 0;\n        let checkedId = null;\n        let checkedName = \"\";\n\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         * @param {(eslint-scope.Reference|null)[]} nodes\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            const nodesToReport = nodes.filter(Boolean);\n\n            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n                const isVarDecParentNull = varDeclParent === null;\n\n                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n                    const firstDeclaration = varDeclParent.declarations[0];\n\n                    if (firstDeclaration.init) {\n                        const firstDecParent = firstDeclaration.init.parent;\n\n                        /*\n                         * First we check the declaration type and then depending on\n                         * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\n                         * we compare the name and id from the first identifier, if the names are different\n                         * we assign the new name, id and reset the count of reportCount and nodeCount in\n                         * order to check each block for the number of reported errors and base our fix\n                         * based on comparing nodes.length and nodesToReport.length.\n                         */\n\n                        if (firstDecParent.type === \"VariableDeclarator\") {\n\n                            if (firstDecParent.id.name !== checkedName) {\n                                checkedName = firstDecParent.id.name;\n                                reportCount = 0;\n                            }\n\n                            if (firstDecParent.id.type === \"ObjectPattern\") {\n                                if (firstDecParent.init.name !== checkedName) {\n                                    checkedName = firstDecParent.init.name;\n                                    reportCount = 0;\n                                }\n                            }\n\n                            if (firstDecParent.id !== checkedId) {\n                                checkedId = firstDecParent.id;\n                                reportCount = 0;\n                            }\n                        }\n                    }\n                }\n\n                let shouldFix = varDeclParent &&\n\n                    // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" ||\n                        varDeclParent.declarations.every(declaration => declaration.init)) &&\n\n                    /*\n                     * If options.destructuring is \"all\", then this warning will not occur unless\n                     * every assignment in the destructuring should be const. In that case, it's safe\n                     * to apply the fix.\n                     */\n                    nodesToReport.length === nodes.length;\n\n                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n\n                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n\n                        /*\n                         * Add nodesToReport.length to a count, then comparing the count to the length\n                         * of the declarations in the current block.\n                         */\n\n                        reportCount += nodesToReport.length;\n\n                        shouldFix = shouldFix && (reportCount === varDeclParent.declarations.length);\n                    }\n                }\n\n                nodesToReport.forEach(node => {\n                    context.report({\n                        node,\n                        messageId: \"useConst\",\n                        data: node,\n                        fix: shouldFix\n                            ? fixer => fixer.replaceText(\n                                sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind),\n                                \"const\"\n                            )\n                            : null\n                    });\n                });\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n            },\n\n            VariableDeclaration(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    variables.push(...context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};"
    },
    "2": {
        "bug_file": "lib/rules/no-undef-init.js",
        "compressed": "NO",
        "line_numbers": 75,
        "compressed_line_numbers": 75,
        "compressed_bug_file_content": "/**\n * @fileoverview Rule to flag when initializing to undefined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"disallow initializing variables to `undefined`\",\n            category: \"Variables\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-undef-init\"\n        },\n\n        schema: [],\n        fixable: \"code\",\n\n        messages: {\n            unnecessaryUndefinedInit: \"It's not necessary to initialize '{{name}}' to undefined.\"\n        }\n    },\n\n    create(context) {\n\n        const sourceCode = context.getSourceCode();\n\n        return {\n\n            VariableDeclarator(node) {\n                const name = sourceCode.getText(node.id),\n                    init = node.init && node.init.name,\n                    scope = context.getScope(),\n                    undefinedVar = astUtils.getVariableByName(scope, \"undefined\"),\n                    shadowed = undefinedVar && undefinedVar.defs.length > 0,\n                    lastToken = sourceCode.getLastToken(node);\n\n                if (init === \"undefined\" && node.parent.kind !== \"const\" && !shadowed) {\n                    context.report({\n                        node,\n                        messageId: \"unnecessaryUndefinedInit\",\n                        data: { name },\n                        fix(fixer) {\n                            if (node.parent.kind === \"var\") {\n                                return null;\n                            }\n\n                            if (node.id.type === \"ArrayPattern\" || node.id.type === \"ObjectPattern\") {\n\n                                // Don't fix destructuring assignment to `undefined`.\n                                return null;\n                            }\n\n                            if (sourceCode.commentsExistBetween(node.id, lastToken)) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([node.id.range[1], node.range[1]]);\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};"
    },
    "3": {
        "bug_file": "lib/linter/source-code-fixer.js",
        "compressed": "NO",
        "line_numbers": 152,
        "compressed_line_numbers": 152,
        "compressed_bug_file_content": "/**\n * @fileoverview An object that caches and applies source code fixes.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst BOM = \"\\uFEFF\";\n\n/**\n * Compares items in a messages array by range.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByFixRange(a, b) {\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n\n/**\n * Compares items in a messages array by line and column.\n * @param {Message} a The first message.\n * @param {Message} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareMessagesByLocation(a, b) {\n    return a.line - b.line || a.column - b.column;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Utility for apply fixes to source code.\n * @constructor\n */\nfunction SourceCodeFixer() {\n    Object.freeze(this);\n}\n\n/**\n * Applies the fixes specified by the messages to the given text. Tries to be\n * smart about the fixes and won't apply fixes over the same area in the text.\n * @param {string} sourceText The text to apply the changes to.\n * @param {Message[]} messages The array of messages reported by ESLint.\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\n * @returns {Object} An object containing the fixed text and any unfixed messages.\n */\nSourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {\n    debug(\"Applying fixes\");\n\n    if (shouldFix === false) {\n        debug(\"shouldFix parameter was false, not attempting fixes\");\n        return {\n            fixed: false,\n            messages,\n            output: sourceText\n        };\n    }\n\n    // clone the array\n    const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n    let lastPos = Number.NEGATIVE_INFINITY,\n        output = bom;\n\n    /**\n     * Try to use the 'fix' from a problem.\n     * @param   {Message} problem The message object to apply fixes from\n     * @returns {boolean}         Whether fix was successfully applied\n     */\n    function attemptFix(problem) {\n        const fix = problem.fix;\n        const start = fix.range[0];\n        const end = fix.range[1];\n\n        // Remain it as a problem if it's overlapped or it's a negative range\n        if (lastPos >= start || start > end) {\n            remainingMessages.push(problem);\n            return false;\n        }\n\n        // Remove BOM.\n        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\n            output = \"\";\n        }\n\n        // Make output to this fix.\n        output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n        output += fix.text;\n        lastPos = end;\n        return true;\n    }\n\n    messages.forEach(problem => {\n        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n            fixes.push(problem);\n        } else {\n            remainingMessages.push(problem);\n        }\n    });\n\n    if (fixes.length) {\n        debug(\"Found fixes to apply\");\n        let fixesWereApplied = false;\n\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\n            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n                attemptFix(problem);\n\n                /*\n                 * The only time attemptFix will fail is if a previous fix was\n                 * applied which conflicts with it.  So we can mark this as true.\n                 */\n                fixesWereApplied = true;\n            } else {\n                remainingMessages.push(problem);\n            }\n        }\n        output += text.slice(Math.max(0, lastPos));\n\n        return {\n            fixed: fixesWereApplied,\n            messages: remainingMessages.sort(compareMessagesByLocation),\n            output\n        };\n    }\n\n    debug(\"No fixes to apply\");\n    return {\n        fixed: false,\n        messages,\n        output: bom + text\n    };\n\n};\n\nmodule.exports = SourceCodeFixer;"
    }
}