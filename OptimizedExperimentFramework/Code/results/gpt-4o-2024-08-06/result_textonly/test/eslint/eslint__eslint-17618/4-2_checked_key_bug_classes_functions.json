{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) 2-502",
            "file_path": "lib/linter/code-path-analysis/code-path-analyzer.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 2,
                    "end_line": 502
                }
            ],
            "class_code": [
                " * @fileoverview A class of the code path analyzer.",
                " * @author Toru Nagashima",
                " */",
                "",
                "\"use strict\";",
                "",
                "//------------------------------------------------------------------------------",
                "// Requirements",
                "//------------------------------------------------------------------------------",
                "",
                "const assert = require(\"assert\"),",
                "    { breakableTypePattern } = require(\"../../shared/ast-utils\"),",
                "    CodePath = require(\"./code-path\"),",
                "    CodePathSegment = require(\"./code-path-segment\"),",
                "    IdGenerator = require(\"./id-generator\"),",
                "    debug = require(\"./debug-helpers\");",
                "",
                "//------------------------------------------------------------------------------",
                "// Helpers",
                "//------------------------------------------------------------------------------",
                "",
                "/**",
                " * Checks whether or not a given node is a `case` node (not `default` node).",
                " * @param {ASTNode} node A `SwitchCase` node to check.",
                " * @returns {boolean} `true` if the node is a `case` node (not `default` node).",
                " */",
                "function isCaseNode(node) {",
                "    return Boolean(node.test);",
                "}",
                "",
                "/**",
                " * Checks if a given node appears as the value of a PropertyDefinition node.",
                " * @param {ASTNode} node THe node to check.",
                " * @returns {boolean} `true` if the node is a PropertyDefinition value,",
                " *      false if not.",
                " */",
                "function isPropertyDefinitionValue(node) {",
                "    const parent = node.parent;",
                "",
                "    return parent && parent.type === \"PropertyDefinition\" && parent.value === node;",
                "}",
                "",
                "/**",
                " * Checks whether the given logical operator is taken into account for the code",
                " * path analysis.",
                " * @param {string} operator The operator found in the LogicalExpression node",
                " * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"",
                " */",
                "function isHandledLogicalOperator(operator) {",
                "    return operator === \"&&\" || operator === \"||\" || operator === \"??\";",
                "}",
                "",
                "/**",
                " * Checks whether the given assignment operator is a logical assignment operator.",
                " * Logical assignments are taken into account for the code path analysis",
                " * because of their short-circuiting semantics.",
                " * @param {string} operator The operator found in the AssignmentExpression node",
                " * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"",
                " */",
                "function isLogicalAssignmentOperator(operator) {",
                "    return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";",
                "}",
                "",
                "/**",
                " * Gets the label if the parent node of a given node is a LabeledStatement.",
                " * @param {ASTNode} node A node to get.",
                " * @returns {string|null} The label or `null`.",
                " */",
                "function getLabel(node) {",
                "    if (node.parent.type === \"LabeledStatement\") {",
                "        return node.parent.label.name;",
                "    }",
                "    return null;",
                "}",
                "",
                "/**",
                " * Checks whether or not a given logical expression node goes different path",
                " * between the `true` case and the `false` case.",
                " * @param {ASTNode} node A node to check.",
                " * @returns {boolean} `true` if the node is a test of a choice statement.",
                " */",
                "function isForkingByTrueOrFalse(node) {",
                "    const parent = node.parent;",
                "",
                "    switch (parent.type) {",
                "        case \"ConditionalExpression\":",
                "        case \"IfStatement\":",
                "        case \"WhileStatement\":",
                "        case \"DoWhileStatement\":",
                "        case \"ForStatement\":",
                "            return parent.test === node;",
                "",
                "        case \"LogicalExpression\":",
                "            return isHandledLogicalOperator(parent.operator);",
                "",
                "        case \"AssignmentExpression\":",
                "            return isLogicalAssignmentOperator(parent.operator);",
                "",
                "        default:",
                "            return false;",
                "    }",
                "}",
                "",
                "/**",
                " * Gets the boolean value of a given literal node.",
                " *",
                " * This is used to detect infinity loops (e.g. `while (true) {}`).",
                " * Statements preceded by an infinity loop are unreachable if the loop didn't",
                " * have any `break` statement.",
                " * @param {ASTNode} node A node to get.",
                " * @returns {boolean|undefined} a boolean value if the node is a Literal node,",
                " *   otherwise `undefined`.",
                " */",
                "function getBooleanValueIfSimpleConstant(node) {",
                "    if (node.type === \"Literal\") {",
                "        return Boolean(node.value);",
                "    }",
                "    return void 0;",
                "}",
                "",
                "/**",
                " * Checks that a given identifier node is a reference or not.",
                " *",
                " * This is used to detect the first throwable node in a `try` block.",
                " * @param {ASTNode} node An Identifier node to check.",
                " * @returns {boolean} `true` if the node is a reference.",
                " */",
                "function isIdentifierReference(node) {",
                "    const parent = node.parent;",
                "",
                "    switch (parent.type) {",
                "        case \"LabeledStatement\":",
                "        case \"BreakStatement\":",
                "        case \"ContinueStatement\":",
                "        case \"ArrayPattern\":",
                "        case \"RestElement\":",
                "        case \"ImportSpecifier\":",
                "        case \"ImportDefaultSpecifier\":",
                "        case \"ImportNamespaceSpecifier\":",
                "        case \"CatchClause\":",
                "            return false;",
                "",
                "        case \"FunctionDeclaration\":",
                "        case \"FunctionExpression\":",
                "        case \"ArrowFunctionExpression\":",
                "        case \"ClassDeclaration\":",
                "        case \"ClassExpression\":",
                "        case \"VariableDeclarator\":",
                "            return parent.id !== node;",
                "",
                "        case \"Property\":",
                "        case \"PropertyDefinition\":",
                "        case \"MethodDefinition\":",
                "            return (",
                "                parent.key !== node ||",
                "                parent.computed ||",
                "                parent.shorthand",
                "            );",
                "",
                "        case \"AssignmentPattern\":",
                "            return parent.key !== node;",
                "",
                "        default:",
                "            return true;",
                "    }",
                "}",
                "",
                "/**",
                " * Updates the current segment with the head segment.",
                " * This is similar to local branches and tracking branches of git.",
                " *",
                " * To separate the current and the head is in order to not make useless segments.",
                " *",
                " * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"",
                " * events are fired.",
                " * @param {CodePathAnalyzer} analyzer The instance.",
                " * @param {ASTNode} node The current AST node.",
                " * @returns {void}",
                " */",
                "function forwardCurrentToHead(analyzer, node) {",
                "    const codePath = analyzer.codePath;",
                "    const state = CodePath.getState(codePath);",
                "    const currentSegments = state.currentSegments;",
                "    const headSegments = state.headSegments;",
                "    const end = Math.max(currentSegments.length, headSegments.length);",
                "    let i, currentSegment, headSegment;",
                "",
                "    // Fires leaving events.",
                "    for (i = 0; i < end; ++i) {",
                "        currentSegment = currentSegments[i];",
                "        headSegment = headSegments[i];",
                "",
                "        if (currentSegment !== headSegment && currentSegment) {",
                "",
                "            const eventName = currentSegment.reachable",
                "                ? \"onCodePathSegmentEnd\"",
                "                : \"onUnreachableCodePathSegmentEnd\";",
                "",
                "            debug.dump(`${eventName} ${currentSegment.id}`);",
                "",
                "            analyzer.emitter.emit(",
                "                eventName,",
                "                currentSegment,",
                "                node",
                "            );",
                "        }",
                "    }",
                "",
                "    // Update state.",
                "    state.currentSegments = headSegments;",
                "",
                "    // Fires entering events.",
                "    for (i = 0; i < end; ++i) {",
                "        currentSegment = currentSegments[i];",
                "        headSegment = headSegments[i];",
                "",
                "        if (currentSegment !== headSegment && headSegment) {",
                "",
                "            const eventName = headSegment.reachable",
                "                ? \"onCodePathSegmentStart\"",
                "                : \"onUnreachableCodePathSegmentStart\";",
                "",
                "            debug.dump(`${eventName} ${headSegment.id}`);",
                "",
                "            CodePathSegment.markUsed(headSegment);",
                "            analyzer.emitter.emit(",
                "                eventName,",
                "                headSegment,",
                "                node",
                "            );",
                "        }",
                "    }",
                "",
                "}",
                "",
                "/**",
                " * Updates the current segment with empty.",
                " * This is called at the last of functions or the program.",
                " * @param {CodePathAnalyzer} analyzer The instance.",
                " * @param {ASTNode} node The current AST node.",
                " * @returns {void}",
                " */",
                "function leaveFromCurrentSegment(analyzer, node) {",
                "    const state = CodePath.getState(analyzer.codePath);",
                "    const currentSegments = state.currentSegments;",
                "",
                "    for (let i = 0; i < currentSegments.length; ++i) {",
                "        const currentSegment = currentSegments[i];",
                "        const eventName = currentSegment.reachable",
                "            ? \"onCodePathSegmentEnd\"",
                "            : \"onUnreachableCodePathSegmentEnd\";",
                "",
                "        debug.dump(`${eventName} ${currentSegment.id}`);",
                "",
                "        analyzer.emitter.emit(",
                "            eventName,",
                "            currentSegment,",
                "            node",
                "        );",
                "    }",
                "",
                "    state.currentSegments = [];",
                "}",
                "",
                "/**",
                " * Updates the code path due to the position of a given node in the parent node",
                " * thereof.",
                " *",
                " * For example, if the node is `parent.consequent`, this creates a fork from the",
                " * current path.",
                " * @param {CodePathAnalyzer} analyzer The instance.",
                " * @param {ASTNode} node The current AST node.",
                " * @returns {void}",
                " */",
                "function preprocess(analyzer, node) {",
                "    const codePath = analyzer.codePath;",
                "    const state = CodePath.getState(codePath);",
                "    const parent = node.parent;",
                "",
                "    switch (parent.type) {",
                "",
                "        // The `arguments.length == 0` case is in `postprocess` function.",
                "        case \"CallExpression\":",
                "            if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {",
                "                state.makeOptionalRight();",
                "            }",
                "            break;",
                "        case \"MemberExpression\":",
                "            if (parent.optional === true && parent.property === node) {",
                "                state.makeOptionalRight();",
                "            }",
                "            break;",
                "",
                "        case \"LogicalExpression\":",
                "            if (",
                "                parent.right === node &&",
                "                isHandledLogicalOperator(parent.operator)",
                "            ) {",
                "                state.makeLogicalRight();",
                "            }",
                "            break;",
                "",
                "        case \"AssignmentExpression\":",
                "            if (",
                "                parent.right === node &&",
                "                isLogicalAssignmentOperator(parent.operator)",
                "            ) {",
                "                state.makeLogicalRight();",
                "            }",
                "            break;",
                "",
                "        case \"ConditionalExpression\":",
                "        case \"IfStatement\":",
                "",
                "            /*",
                "             * Fork if this node is at `consequent`/`alternate`.",
                "             * `popForkContext()` exists at `IfStatement:exit` and",
                "             * `ConditionalExpression:exit`.",
                "             */",
                "            if (parent.consequent === node) {",
                "                state.makeIfConsequent();",
                "            } else if (parent.alternate === node) {",
                "                state.makeIfAlternate();",
                "            }",
                "            break;",
                "",
                "        case \"SwitchCase\":",
                "            if (parent.consequent[0] === node) {",
                "                state.makeSwitchCaseBody(false, !parent.test);",
                "            }",
                "            break;",
                "",
                "        case \"TryStatement\":",
                "            if (parent.handler === node) {",
                "                state.makeCatchBlock();",
                "            } else if (parent.finalizer === node) {",
                "                state.makeFinallyBlock();",
                "            }",
                "            break;",
                "",
                "        case \"WhileStatement\":",
                "            if (parent.test === node) {",
                "                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));",
                "            } else {",
                "                assert(parent.body === node);",
                "                state.makeWhileBody();",
                "            }",
                "            break;",
                "",
                "        case \"DoWhileStatement\":",
                "            if (parent.body === node) {",
                "                state.makeDoWhileBody();",
                "            } else {",
                "                assert(parent.test === node);",
                "                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));",
                "            }",
                "            break;",
                "",
                "        case \"ForStatement\":",
                "            if (parent.test === node) {",
                "                state.makeForTest(getBooleanValueIfSimpleConstant(node));",
                "            } else if (parent.update === node) {",
                "                state.makeForUpdate();",
                "            } else if (parent.body === node) {",
                "                state.makeForBody();",
                "            }",
                "            break;",
                "",
                "        case \"ForInStatement\":",
                "        case \"ForOfStatement\":",
                "            if (parent.left === node) {",
                "                state.makeForInOfLeft();",
                "            } else if (parent.right === node) {",
                "                state.makeForInOfRight();",
                "            } else {",
                "                assert(parent.body === node);",
                "                state.makeForInOfBody();",
                "            }",
                "            break;",
                "",
                "        case \"AssignmentPattern\":",
                "",
                "            /*",
                "             * Fork if this node is at `right`.",
                "             * `left` is executed always, so it uses the current path.",
                "             * `popForkContext()` exists at `AssignmentPattern:exit`.",
                "             */",
                "            if (parent.right === node) {",
                "                state.pushForkContext();",
                "                state.forkBypassPath();",
                "                state.forkPath();",
                "            }",
                "            break;",
                "",
                "        default:",
                "            break;",
                "    }",
                "}",
                "",
                "/**",
                " * Updates the code path due to the type of a given node in entering.",
                " * @param {CodePathAnalyzer} analyzer The instance.",
                " * @param {ASTNode} node The current AST node.",
                " * @returns {void}",
                " */",
                "function processCodePathToEnter(analyzer, node) {",
                "    let codePath = analyzer.codePath;",
                "    let state = codePath && CodePath.getState(codePath);",
                "    const parent = node.parent;",
                "",
                "    /**",
                "     * Creates a new code path and trigger the onCodePathStart event",
                "     * based on the currently selected node.",
                "     * @param {string} origin The reason the code path was started.",
                "     * @returns {void}",
                "     */",
                "    function startCodePath(origin) {",
                "        if (codePath) {",
                "",
                "            // Emits onCodePathSegmentStart events if updated.",
                "            forwardCurrentToHead(analyzer, node);",
                "            debug.dumpState(node, state, false);",
                "        }",
                "",
                "        // Create the code path of this scope.",
                "        codePath = analyzer.codePath = new CodePath({",
                "            id: analyzer.idGenerator.next(),",
                "            origin,",
                "            upper: codePath,",
                "            onLooped: analyzer.onLooped",
                "        });",
                "        state = CodePath.getState(codePath);",
                "",
                "        // Emits onCodePathStart events.",
                "        debug.dump(`onCodePathStart ${codePath.id}`);",
                "        analyzer.emitter.emit(\"onCodePathStart\", codePath, node);",
                "    }",
                "",
                "    /*",
                "     * Special case: The right side of class field initializer is considered",
                "     * to be its own function, so we need to start a new code path in this",
                "     * case.",
                "     */",
                "    if (isPropertyDefinitionValue(node)) {",
                "        startCodePath(\"class-field-initializer\");",
                "",
                "        /*",
                "         * Intentional fall through because `node` needs to also be",
                "         * processed by the code below. For example, if we have:",
                "         *",
                "         * class Foo {",
                "         *     a = () => {}",
                "         * }",
                "         *",
                "         * In this case, we also need start a second code path.",
                "         */",
                "",
                "    }",
                "",
                "    switch (node.type) {",
                "        case \"Program\":",
                "            startCodePath(\"program\");",
                "            break;",
                "",
                "        case \"FunctionDeclaration\":",
                "        case \"FunctionExpression\":",
                "        case \"ArrowFunctionExpression\":",
                "            startCodePath(\"function\");",
                "            break;",
                "",
                "        case \"StaticBlock\":",
                "            startCodePath(\"class-static-block\");",
                "            break;",
                "",
                "        case \"ChainExpression\":",
                "            state.pushChainContext();",
                "            break;",
                "        case \"CallExpression\":",
                "            if (node.optional === true) {",
                "                state.makeOptionalNode();",
                "            }",
                "            break;",
                "        case \"MemberExpression\":",
                "            if (node.optional === true) {",
                "                state.makeOptionalNode();",
                "            }",
                "            break;",
                "",
                "        case \"LogicalExpression\":",
                "            if (isHandledLogicalOperator(node.operator)) {",
                "                state.pushChoiceContext(",
                "                    node.operator,",
                "                    isForkingByTrueOrFalse(node)",
                "                );",
                "            }",
                "            break;",
                "",
                "        case \"AssignmentExpression\":",
                "            if (isLogicalAssignmentOperator(node.operator)) {",
                "                state.pushChoiceContext(",
                "                    node.operator.slice(0, -1), // removes `=` from the end"
            ]
        },
        "2": {
            "class_name": "  (not found) 2-502",
            "file_path": "lib/linter/code-path-analysis/code-path-state.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 2,
                    "end_line": 502
                }
            ],
            "class_code": [
                " * @fileoverview A class to manage state of generating a code path.",
                " * @author Toru Nagashima",
                " */",
                "",
                "\"use strict\";",
                "",
                "//------------------------------------------------------------------------------",
                "// Requirements",
                "//------------------------------------------------------------------------------",
                "",
                "const CodePathSegment = require(\"./code-path-segment\"),",
                "    ForkContext = require(\"./fork-context\");",
                "",
                "//-----------------------------------------------------------------------------",
                "// Contexts",
                "//-----------------------------------------------------------------------------",
                "",
                "/**",
                " * Represents the context in which a `break` statement can be used.",
                " *",
                " * A `break` statement without a label is only valid in a few places in",
                " * JavaScript: any type of loop or a `switch` statement. Otherwise, `break`",
                " * without a label causes a syntax error. For these contexts, `breakable` is",
                " * set to `true` to indicate that a `break` without a label is valid.",
                " *",
                " * However, a `break` statement with a label is also valid inside of a labeled",
                " * statement. For example, this is valid:",
                " *",
                " *     a : {",
                " *         break a;",
                " *     }",
                " *",
                " * The `breakable` property is set false for labeled statements to indicate",
                " * that `break` without a label is invalid.",
                " */",
                "class BreakContext {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {BreakContext} upperContext The previous `BreakContext`.",
                "     * @param {boolean} breakable Indicates if we are inside a statement where",
                "     *      `break` without a label will exit the statement.",
                "     * @param {string|null} label The label for the statement.",
                "     * @param {ForkContext} forkContext The current fork context.",
                "     */",
                "    constructor(upperContext, breakable, label, forkContext) {",
                "",
                "        /**",
                "         * The previous `BreakContext`",
                "         * @type {BreakContext}",
                "         */",
                "        this.upper = upperContext;",
                "",
                "        /**",
                "         * Indicates if we are inside a statement where `break` without a label",
                "         * will exit the statement.",
                "         * @type {boolean}",
                "         */",
                "        this.breakable = breakable;",
                "",
                "        /**",
                "         * The label associated with the statement.",
                "         * @type {string|null}",
                "         */",
                "        this.label = label;",
                "",
                "        /**",
                "         * The fork context for the `break`.",
                "         * @type {ForkContext}",
                "         */",
                "        this.brokenForkContext = ForkContext.newEmpty(forkContext);",
                "    }",
                "}",
                "",
                "/**",
                " * Represents the context for `ChainExpression` nodes.",
                " */",
                "class ChainContext {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {ChainContext} upperContext The previous `ChainContext`.",
                "     */",
                "    constructor(upperContext) {",
                "",
                "        /**",
                "         * The previous `ChainContext`",
                "         * @type {ChainContext}",
                "         */",
                "        this.upper = upperContext;",
                "",
                "        /**",
                "         * The number of choice contexts inside of the `ChainContext`.",
                "         * @type {number}",
                "         */",
                "        this.choiceContextCount = 0;",
                "",
                "    }",
                "}",
                "",
                "/**",
                " * Represents a choice in the code path.",
                " *",
                " * Choices are created by logical operators such as `&&`, loops, conditionals,",
                " * and `if` statements. This is the point at which the code path has a choice of",
                " * which direction to go.",
                " *",
                " * The result of a choice might be in the left (test) expression of another choice,",
                " * and in that case, may create a new fork. For example, `a || b` is a choice",
                " * but does not create a new fork because the result of the expression is",
                " * not used as the test expression in another expression. In this case,",
                " * `isForkingAsResult` is false. In the expression `a || b || c`, the `a || b`",
                " * expression appears as the test expression for `|| c`, so the",
                " * result of `a || b` creates a fork because execution may or may not",
                " * continue to `|| c`. `isForkingAsResult` for `a || b` in this case is true",
                " * while `isForkingAsResult` for `|| c` is false. (`isForkingAsResult` is always",
                " * false for `if` statements, conditional expressions, and loops.)",
                " *",
                " * All of the choices except one (`??`) operate on a true/false fork, meaning if",
                " * true go one way and if false go the other (tracked by `trueForkContext` and",
                " * `falseForkContext`). The `??` operator doesn't operate on true/false because",
                " * the left expression is evaluated to be nullish or not, so only if nullish do",
                " * we fork to the right expression (tracked by `qqForkcontext`).",
                " */",
                "class ChoiceContext {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {ChoiceContext} upperContext The previous `ChoiceContext`.",
                "     * @param {string} kind The kind of choice. If it's a logical or assignment expression, this",
                "     *      is `\"&&\"` or `\"||\"` or `\"??\"`; if it's an `if` statement or",
                "     *      conditional expression, this is `\"test\"`; otherwise, this is `\"loop\"`.",
                "     * @param {boolean} isForkingAsResult Indicates if the result of the choice",
                "     *      creates a fork.",
                "     * @param {ForkContext} forkContext The containing `ForkContext`.",
                "     */",
                "    constructor(upperContext, kind, isForkingAsResult, forkContext) {",
                "",
                "        /**",
                "         * The previous `ChoiceContext`",
                "         * @type {ChoiceContext}",
                "         */",
                "        this.upper = upperContext;",
                "",
                "        /**",
                "         * The kind of choice. If it's a logical or assignment expression, this",
                "         * is `\"&&\"` or `\"||\"` or `\"??\"`; if it's an `if` statement or",
                "         * conditional expression, this is `\"test\"`; otherwise, this is `\"loop\"`.",
                "         * @type {string}",
                "         */",
                "        this.kind = kind;",
                "",
                "        /**",
                "         * Indicates if the result of the choice forks the code path.",
                "         * @type {boolean}",
                "         */",
                "        this.isForkingAsResult = isForkingAsResult;",
                "",
                "        /**",
                "         * The fork context for the `true` path of the choice.",
                "         * @type {ForkContext}",
                "         */",
                "        this.trueForkContext = ForkContext.newEmpty(forkContext);",
                "",
                "        /**",
                "         * The fork context for the `false` path of the choice.",
                "         * @type {ForkContext}",
                "         */",
                "        this.falseForkContext = ForkContext.newEmpty(forkContext);",
                "",
                "        /**",
                "         * The fork context for the right side of the `??` path of the choice.",
                "         * @type {ForkContext}",
                "         */",
                "        this.qqForkContext = ForkContext.newEmpty(forkContext);",
                "",
                "        /**",
                "         * Indicates if any of `trueForkContext`, `falseForkContext`, or",
                "         * `qqForkContext` have been updated with segments from a child context.",
                "         * @type {boolean}",
                "         */",
                "        this.processed = false;",
                "    }",
                "",
                "}",
                "",
                "/**",
                " * Base class for all loop contexts.",
                " */",
                "class LoopContextBase {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {LoopContext|null} upperContext The previous `LoopContext`.",
                "     * @param {string} type The AST node's `type` for the loop.",
                "     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.",
                "     * @param {BreakContext} breakContext The context for breaking the loop.",
                "     */",
                "    constructor(upperContext, type, label, breakContext) {",
                "",
                "        /**",
                "         * The previous `LoopContext`.",
                "         * @type {LoopContext}",
                "         */",
                "        this.upper = upperContext;",
                "",
                "        /**",
                "         * The AST node's `type` for the loop.",
                "         * @type {string}",
                "         */",
                "        this.type = type;",
                "",
                "        /**",
                "         * The label for the loop from an enclosing `LabeledStatement`.",
                "         * @type {string|null}",
                "         */",
                "        this.label = label;",
                "",
                "        /**",
                "         * The fork context for when `break` is encountered.",
                "         * @type {ForkContext}",
                "         */",
                "        this.brokenForkContext = breakContext.brokenForkContext;",
                "    }",
                "}",
                "",
                "/**",
                " * Represents the context for a `while` loop.",
                " */",
                "class WhileLoopContext extends LoopContextBase {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {LoopContext|null} upperContext The previous `LoopContext`.",
                "     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.",
                "     * @param {BreakContext} breakContext The context for breaking the loop.",
                "     */",
                "    constructor(upperContext, label, breakContext) {",
                "        super(upperContext, \"WhileStatement\", label, breakContext);",
                "",
                "        /**",
                "         * The hardcoded literal boolean test condition for",
                "         * the loop. Used to catch infinite or skipped loops.",
                "         * @type {boolean|undefined}",
                "         */",
                "        this.test = void 0;",
                "",
                "        /**",
                "         * The segments representing the test condition where `continue` will",
                "         * jump to. The test condition will typically have just one segment but",
                "         * it's possible for there to be more than one.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.continueDestSegments = null;",
                "    }",
                "}",
                "",
                "/**",
                " * Represents the context for a `do-while` loop.",
                " */",
                "class DoWhileLoopContext extends LoopContextBase {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {LoopContext|null} upperContext The previous `LoopContext`.",
                "     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.",
                "     * @param {BreakContext} breakContext The context for breaking the loop.",
                "     * @param {ForkContext} forkContext The enclosing fork context.",
                "     */",
                "    constructor(upperContext, label, breakContext, forkContext) {",
                "        super(upperContext, \"DoWhileStatement\", label, breakContext);",
                "",
                "        /**",
                "         * The hardcoded literal boolean test condition for",
                "         * the loop. Used to catch infinite or skipped loops.",
                "         * @type {boolean|undefined}",
                "         */",
                "        this.test = void 0;",
                "",
                "        /**",
                "         * The segments at the start of the loop body. This is the only loop",
                "         * where the test comes at the end, so the first iteration always",
                "         * happens and we need a reference to the first statements.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.entrySegments = null;",
                "",
                "        /**",
                "         * The fork context to follow when a `continue` is found.",
                "         * @type {ForkContext}",
                "         */",
                "        this.continueForkContext = ForkContext.newEmpty(forkContext);",
                "    }",
                "}",
                "",
                "/**",
                " * Represents the context for a `for` loop.",
                " */",
                "class ForLoopContext extends LoopContextBase {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {LoopContext|null} upperContext The previous `LoopContext`.",
                "     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.",
                "     * @param {BreakContext} breakContext The context for breaking the loop.",
                "     */",
                "    constructor(upperContext, label, breakContext) {",
                "        super(upperContext, \"ForStatement\", label, breakContext);",
                "",
                "        /**",
                "         * The hardcoded literal boolean test condition for",
                "         * the loop. Used to catch infinite or skipped loops.",
                "         * @type {boolean|undefined}",
                "         */",
                "        this.test = void 0;",
                "",
                "        /**",
                "         * The end of the init expression. This may change during the lifetime",
                "         * of the instance as we traverse the loop because some loops don't have",
                "         * an init expression.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.endOfInitSegments = null;",
                "",
                "        /**",
                "         * The start of the test expression. This may change during the lifetime",
                "         * of the instance as we traverse the loop because some loops don't have",
                "         * a test expression.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.testSegments = null;",
                "",
                "        /**",
                "         * The end of the test expression. This may change during the lifetime",
                "         * of the instance as we traverse the loop because some loops don't have",
                "         * a test expression.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.endOfTestSegments = null;",
                "",
                "        /**",
                "         * The start of the update expression. This may change during the lifetime",
                "         * of the instance as we traverse the loop because some loops don't have",
                "         * an update expression.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.updateSegments = null;",
                "",
                "        /**",
                "         * The end of the update expresion. This may change during the lifetime",
                "         * of the instance as we traverse the loop because some loops don't have",
                "         * an update expression.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.endOfUpdateSegments = null;",
                "",
                "        /**",
                "         * The segments representing the test condition where `continue` will",
                "         * jump to. The test condition will typically have just one segment but",
                "         * it's possible for there to be more than one. This may change during the",
                "         * lifetime of the instance as we traverse the loop because some loops",
                "         * don't have an update expression. When there is an update expression, this",
                "         * will end up pointing to that expression; otherwise it will end up pointing",
                "         * to the test expression.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.continueDestSegments = null;",
                "    }",
                "}",
                "",
                "/**",
                " * Represents the context for a `for-in` loop.",
                " *",
                " * Terminology:",
                " * - \"left\" means the part of the loop to the left of the `in` keyword. For",
                " *   example, in `for (var x in y)`, the left is `var x`.",
                " * - \"right\" means the part of the loop to the right of the `in` keyword. For",
                " *   example, in `for (var x in y)`, the right is `y`.",
                " */",
                "class ForInLoopContext extends LoopContextBase {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {LoopContext|null} upperContext The previous `LoopContext`.",
                "     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.",
                "     * @param {BreakContext} breakContext The context for breaking the loop.",
                "     */",
                "    constructor(upperContext, label, breakContext) {",
                "        super(upperContext, \"ForInStatement\", label, breakContext);",
                "",
                "        /**",
                "         * The segments that came immediately before the start of the loop.",
                "         * This allows you to traverse backwards out of the loop into the",
                "         * surrounding code. This is necessary to evaluate the right expression",
                "         * correctly, as it must be evaluated in the same way as the left",
                "         * expression, but the pointer to these segments would otherwise be",
                "         * lost if not stored on the instance. Once the right expression has",
                "         * been evaluated, this property is no longer used.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.prevSegments = null;",
                "",
                "        /**",
                "         * Segments representing the start of everything to the left of the",
                "         * `in` keyword. This can be used to move forward towards",
                "         * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are",
                "         * effectively the head and tail of a doubly-linked list.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.leftSegments = null;",
                "",
                "        /**",
                "         * Segments representing the end of everything to the left of the",
                "         * `in` keyword. This can be used to move backward towards `leftSegments`.",
                "         * `leftSegments` and `endOfLeftSegments` are effectively the head",
                "         * and tail of a doubly-linked list.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.endOfLeftSegments = null;",
                "",
                "        /**",
                "         * The segments representing the left expression where `continue` will",
                "         * jump to. In `for-in` loops, `continue` must always re-execute the",
                "         * left expression each time through the loop. This contains the same",
                "         * segments as `leftSegments`, but is duplicated here so each loop",
                "         * context has the same property pointing to where `continue` should",
                "         * end up.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.continueDestSegments = null;",
                "    }",
                "}",
                "",
                "/**",
                " * Represents the context for a `for-of` loop.",
                " */",
                "class ForOfLoopContext extends LoopContextBase {",
                "",
                "    /**",
                "     * Creates a new instance.",
                "     * @param {LoopContext|null} upperContext The previous `LoopContext`.",
                "     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.",
                "     * @param {BreakContext} breakContext The context for breaking the loop.",
                "     */",
                "    constructor(upperContext, label, breakContext) {",
                "        super(upperContext, \"ForOfStatement\", label, breakContext);",
                "",
                "        /**",
                "         * The segments that came immediately before the start of the loop.",
                "         * This allows you to traverse backwards out of the loop into the",
                "         * surrounding code. This is necessary to evaluate the right expression",
                "         * correctly, as it must be evaluated in the same way as the left",
                "         * expression, but the pointer to these segments would otherwise be",
                "         * lost if not stored on the instance. Once the right expression has",
                "         * been evaluated, this property is no longer used.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.prevSegments = null;",
                "",
                "        /**",
                "         * Segments representing the start of everything to the left of the",
                "         * `of` keyword. This can be used to move forward towards",
                "         * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are",
                "         * effectively the head and tail of a doubly-linked list.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.leftSegments = null;",
                "",
                "        /**",
                "         * Segments representing the end of everything to the left of the",
                "         * `of` keyword. This can be used to move backward towards `leftSegments`.",
                "         * `leftSegments` and `endOfLeftSegments` are effectively the head",
                "         * and tail of a doubly-linked list.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.endOfLeftSegments = null;",
                "",
                "        /**",
                "         * The segments representing the left expression where `continue` will",
                "         * jump to. In `for-in` loops, `continue` must always re-execute the",
                "         * left expression each time through the loop. This contains the same",
                "         * segments as `leftSegments`, but is duplicated here so each loop",
                "         * context has the same property pointing to where `continue` should",
                "         * end up.",
                "         * @type {Array<CodePathSegment>|null}",
                "         */",
                "        this.continueDestSegments = null;",
                "    }",
                "}",
                "",
                "/**",
                " * Represents the context for any loop.",
                " * @typedef {WhileLoopContext|DoWhileLoopContext|ForLoopContext|ForInLoopContext|ForOfLoopContext} LoopContext",
                " */",
                "",
                "/**",
                " * Represents the context for a `switch` statement.",
                " */",
                "class SwitchContext {",
                "",
                "    /**"
            ]
        }
    },
    "bug_functions": {}
}