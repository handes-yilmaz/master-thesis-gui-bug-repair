{
    "1": {
        "bug_file": "lib/linter/code-path-analysis/code-path-analyzer.js",
        "compressed": "YES",
        "line_numbers": 852,
        "compressed_line_numbers": 325,
        "compressed_bug_file_content": "/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n * @param {ASTNode} node A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\n\n\n/**\n * Checks if a given node appears as the value of a PropertyDefinition node.\n * @param {ASTNode} node THe node to check.\n * @returns {boolean} `true` if the node is a PropertyDefinition value,\n *      false if not.\n */\n\n\n/**\n * Checks whether the given logical operator is taken into account for the code\n * path analysis.\n * @param {string} operator The operator found in the LogicalExpression node\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\n */\n\n\n/**\n * Checks whether the given assignment operator is a logical assignment operator.\n * Logical assignments are taken into account for the code path analysis\n * because of their short-circuiting semantics.\n * @param {string} operator The operator found in the AssignmentExpression node\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\n */\n\n\n/**\n * Gets the label if the parent node of a given node is a LabeledStatement.\n * @param {ASTNode} node A node to get.\n * @returns {string|null} The label or `null`.\n */\n\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\n\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n * @param {ASTNode} node A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\n\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n * @param {ASTNode} node An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\n\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n    // Fires leaving events.\n\n\n    // Update state.\n\n\n    // Fires entering events.\n\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n        // The `arguments.length == 0` case is in `postprocess` function.\n\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n\n\n/**\n * Updates the code path due to the type of a given node in entering.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n    /**\n     * Creates a new code path and trigger the onCodePathStart event\n     * based on the currently selected node.\n     * @param {string} origin The reason the code path was started.\n     * @returns {void}\n     */\n\n\n            // Emits onCodePathSegmentStart events if updated.\n\n\n        // Create the code path of this scope.\n\n\n        // Emits onCodePathStart events.\n\n\n    /*\n     * Special case: The right side of class field initializer is considered\n     * to be its own function, so we need to start a new code path in this\n     * case.\n     */\n\n\n        /*\n         * Intentional fall through because `node` needs to also be\n         * processed by the code below. For example, if we have:\n         *\n         * class Foo {\n         *     a = () => {}\n         * }\n         *\n         * In this case, we also need start a second code path.\n         */\n\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n\n\n    // Emits onCodePathSegmentStart events if updated.\n\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n\n\n    // Emits onCodePathSegmentStart events if updated.\n\n\n/**\n * Updates the code path to finalize the current code path.\n * @param {CodePathAnalyzer} analyzer The instance.\n * @param {ASTNode} node The current AST node.\n * @returns {void}\n */\n\n\n    /**\n     * Ends the code path for the current node.\n     * @returns {void}\n     */\n\n\n        // Mark the current path as the final node.\n\n\n        // Emits onCodePathSegmentEnd event of the current segments.\n\n\n        // Emits onCodePathEnd event of this code path.\n\n\n        // The `arguments.length >= 1` case is in `preprocess` function.\n\n\n    /*\n     * Special case: The right side of class field initializer is considered\n     * to be its own function, so we need to end a code path in this\n     * case.\n     *\n     * We need to check after the other checks in order to close the\n     * code paths in the correct order for code like this:\n     *\n     *\n     * class Foo {\n     *     a = () => {}\n     * }\n     *\n     * In this case, The ArrowFunctionExpression code path is closed first\n     * and then we need to close the code path for the PropertyDefinition\n     * value.\n     */\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n */\n\n\n    /**\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\n     */\n\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     * @param {ASTNode} node A node which is entering.\n     * @returns {void}\n     */\n\n\n        // Updates the code path due to node's position in its parent node.\n\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n\n\n        // Emits node events.\n\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     * @param {ASTNode} node A node which is leaving.\n     * @returns {void}\n     */\n\n\n        /*\n         * Updates the code path.\n         * And emits onCodePathStart/onCodePathSegmentStart events.\n         */\n\n\n        // Emits node events.\n\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     * @param {CodePathSegment} fromSegment A segment of prev.\n     * @param {CodePathSegment} toSegment A segment of next.\n     * @returns {void}\n     */\n\n\n"
    },
    "2": {
        "bug_file": "lib/linter/code-path-analysis/code-path-segment.js",
        "compressed": "NO",
        "line_numbers": 263,
        "compressed_line_numbers": 263,
        "compressed_bug_file_content": "/**\n * @fileoverview The CodePathSegment class.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given segment is reachable.\n * @param {CodePathSegment} segment A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n *\n * Each segment is arranged in a series of linked lists (implemented by arrays)\n * that keep track of the previous and next segments in a code path. In this way,\n * you can navigate between all segments in any code path so long as you have a\n * reference to any segment in that code path.\n *\n * When first created, the segment is in a detached state, meaning that it knows the\n * segments that came before it but those segments don't know that this new segment\n * follows it. Only when `CodePathSegment#markUsed()` is called on a segment does it\n * officially become part of the code path by updating the previous segments to know\n * that this new segment follows.\n */\nclass CodePathSegment {\n\n    /**\n     * Creates a new instance.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     *   This array includes unreachable segments.\n     * @param {boolean} reachable A flag which shows this is reachable.\n     */\n    constructor(id, allPrevSegments, reachable) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * An array of the next reachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.nextSegments = [];\n\n        /**\n         * An array of the previous reachable segments.\n         * @type {CodePathSegment[]}\n         */\n        this.prevSegments = allPrevSegments.filter(isReachable);\n\n        /**\n         * An array of all next segments including reachable and unreachable.\n         * @type {CodePathSegment[]}\n         */\n        this.allNextSegments = [];\n\n        /**\n         * An array of all previous segments including reachable and unreachable.\n         * @type {CodePathSegment[]}\n         */\n        this.allPrevSegments = allPrevSegments;\n\n        /**\n         * A flag which shows this is reachable.\n         * @type {boolean}\n         */\n        this.reachable = reachable;\n\n        // Internal data.\n        Object.defineProperty(this, \"internal\", {\n            value: {\n\n                // determines if the segment has been attached to the code path\n                used: false,\n\n                // array of previous segments coming from the end of a loop\n                loopedPrevSegments: []\n            }\n        });\n\n        /* c8 ignore start */\n        if (debug.enabled) {\n            this.internal.nodes = [];\n        }/* c8 ignore stop */\n    }\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     * @param {CodePathSegment} segment A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment(segment) {\n        return this.internal.loopedPrevSegments.includes(segment);\n    }\n\n    /**\n     * Creates the root segment.\n     * @param {string} id An identifier.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newRoot(id) {\n        return new CodePathSegment(id, [], true);\n    }\n\n    /**\n     * Creates a new segment and appends it after the given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments\n     *      to append to.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newNext(id, allPrevSegments) {\n        return new CodePathSegment(\n            id,\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\n            allPrevSegments.some(isReachable)\n        );\n    }\n\n    /**\n     * Creates an unreachable segment and appends it after the given segments.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newUnreachable(id, allPrevSegments) {\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n\n        /*\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\n         * the return statement is not used but must not be removed.\n         */\n        CodePathSegment.markUsed(segment);\n\n        return segment;\n    }\n\n    /**\n     * Creates a segment that follows given segments.\n     * This factory method does not connect with `allPrevSegments`.\n     * But this inherits `reachable` flag.\n     * @param {string} id An identifier.\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\n     * @returns {CodePathSegment} The created segment.\n     */\n    static newDisconnected(id, allPrevSegments) {\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n    }\n\n    /**\n     * Marks a given segment as used.\n     *\n     * And this function registers the segment into the previous segments as a next.\n     * @param {CodePathSegment} segment A segment to mark.\n     * @returns {void}\n     */\n    static markUsed(segment) {\n        if (segment.internal.used) {\n            return;\n        }\n        segment.internal.used = true;\n\n        let i;\n\n        if (segment.reachable) {\n\n            /*\n             * If the segment is reachable, then it's officially part of the\n             * code path. This loops through all previous segments to update\n             * their list of next segments. Because the segment is reachable,\n             * it's added to both `nextSegments` and `allNextSegments`.\n             */\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                const prevSegment = segment.allPrevSegments[i];\n\n                prevSegment.allNextSegments.push(segment);\n                prevSegment.nextSegments.push(segment);\n            }\n        } else {\n\n            /*\n             * If the segment is not reachable, then it's not officially part of the\n             * code path. This loops through all previous segments to update\n             * their list of next segments. Because the segment is not reachable,\n             * it's added only to `allNextSegments`.\n             */\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\n                segment.allPrevSegments[i].allNextSegments.push(segment);\n            }\n        }\n    }\n\n    /**\n     * Marks a previous segment as looped.\n     * @param {CodePathSegment} segment A segment.\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\n     * @returns {void}\n     */\n    static markPrevSegmentAsLooped(segment, prevSegment) {\n        segment.internal.loopedPrevSegments.push(prevSegment);\n    }\n\n    /**\n     * Creates a new array based on an array of segments. If any segment in the\n     * array is unused, then it is replaced by all of its previous segments.\n     * All used segments are returned as-is without replacement.\n     * @param {CodePathSegment[]} segments The array of segments to flatten.\n     * @returns {CodePathSegment[]} The flattened array.\n     */\n    static flattenUnusedSegments(segments) {\n        const done = new Set();\n\n        for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            // Ignores duplicated.\n            if (done.has(segment)) {\n                continue;\n            }\n\n            // Use previous segments if unused.\n            if (!segment.internal.used) {\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n                    const prevSegment = segment.allPrevSegments[j];\n\n                    if (!done.has(prevSegment)) {\n                        done.add(prevSegment);\n                    }\n                }\n            } else {\n                done.add(segment);\n            }\n        }\n\n        return [...done];\n    }\n}\n\nmodule.exports = CodePathSegment;"
    },
    "3": {
        "bug_file": "lib/linter/code-path-analysis/code-path-state.js",
        "compressed": "YES",
        "line_numbers": 2303,
        "compressed_line_numbers": 1630,
        "compressed_bug_file_content": "/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//-----------------------------------------------------------------------------\n// Contexts\n//-----------------------------------------------------------------------------\n\n/**\n * Represents the context in which a `break` statement can be used.\n *\n * A `break` statement without a label is only valid in a few places in\n * JavaScript: any type of loop or a `switch` statement. Otherwise, `break`\n * without a label causes a syntax error. For these contexts, `breakable` is\n * set to `true` to indicate that a `break` without a label is valid.\n *\n * However, a `break` statement with a label is also valid inside of a labeled\n * statement. For example, this is valid:\n *\n *     a : {\n *         break a;\n *     }\n *\n * The `breakable` property is set false for labeled statements to indicate\n * that `break` without a label is invalid.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {BreakContext} upperContext The previous `BreakContext`.\n     * @param {boolean} breakable Indicates if we are inside a statement where\n     *      `break` without a label will exit the statement.\n     * @param {string|null} label The label for the statement.\n     * @param {ForkContext} forkContext The current fork context.\n     */\n\n\n        /**\n         * The previous `BreakContext`\n         * @type {BreakContext}\n         */\n\n\n        /**\n         * Indicates if we are inside a statement where `break` without a label\n         * will exit the statement.\n         * @type {boolean}\n         */\n\n\n        /**\n         * The label associated with the statement.\n         * @type {string|null}\n         */\n\n\n        /**\n         * The fork context for the `break`.\n         * @type {ForkContext}\n         */\n\n\n/**\n * Represents the context for `ChainExpression` nodes.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {ChainContext} upperContext The previous `ChainContext`.\n     */\n\n\n        /**\n         * The previous `ChainContext`\n         * @type {ChainContext}\n         */\n\n\n        /**\n         * The number of choice contexts inside of the `ChainContext`.\n         * @type {number}\n         */\n\n\n/**\n * Represents a choice in the code path.\n *\n * Choices are created by logical operators such as `&&`, loops, conditionals,\n * and `if` statements. This is the point at which the code path has a choice of\n * which direction to go.\n *\n * The result of a choice might be in the left (test) expression of another choice,\n * and in that case, may create a new fork. For example, `a || b` is a choice\n * but does not create a new fork because the result of the expression is\n * not used as the test expression in another expression. In this case,\n * `isForkingAsResult` is false. In the expression `a || b || c`, the `a || b`\n * expression appears as the test expression for `|| c`, so the\n * result of `a || b` creates a fork because execution may or may not\n * continue to `|| c`. `isForkingAsResult` for `a || b` in this case is true\n * while `isForkingAsResult` for `|| c` is false. (`isForkingAsResult` is always\n * false for `if` statements, conditional expressions, and loops.)\n *\n * All of the choices except one (`??`) operate on a true/false fork, meaning if\n * true go one way and if false go the other (tracked by `trueForkContext` and\n * `falseForkContext`). The `??` operator doesn't operate on true/false because\n * the left expression is evaluated to be nullish or not, so only if nullish do\n * we fork to the right expression (tracked by `qqForkcontext`).\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {ChoiceContext} upperContext The previous `ChoiceContext`.\n     * @param {string} kind The kind of choice. If it's a logical or assignment expression, this\n     *      is `\"&&\"` or `\"||\"` or `\"??\"`; if it's an `if` statement or\n     *      conditional expression, this is `\"test\"`; otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult Indicates if the result of the choice\n     *      creates a fork.\n     * @param {ForkContext} forkContext The containing `ForkContext`.\n     */\n\n\n        /**\n         * The previous `ChoiceContext`\n         * @type {ChoiceContext}\n         */\n\n\n        /**\n         * The kind of choice. If it's a logical or assignment expression, this\n         * is `\"&&\"` or `\"||\"` or `\"??\"`; if it's an `if` statement or\n         * conditional expression, this is `\"test\"`; otherwise, this is `\"loop\"`.\n         * @type {string}\n         */\n\n\n        /**\n         * Indicates if the result of the choice forks the code path.\n         * @type {boolean}\n         */\n\n\n        /**\n         * The fork context for the `true` path of the choice.\n         * @type {ForkContext}\n         */\n\n\n        /**\n         * The fork context for the `false` path of the choice.\n         * @type {ForkContext}\n         */\n\n\n        /**\n         * The fork context for the right side of the `??` path of the choice.\n         * @type {ForkContext}\n         */\n\n\n        /**\n         * Indicates if any of `trueForkContext`, `falseForkContext`, or\n         * `qqForkContext` have been updated with segments from a child context.\n         * @type {boolean}\n         */\n\n\n/**\n * Base class for all loop contexts.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string} type The AST node's `type` for the loop.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n\n\n        /**\n         * The previous `LoopContext`.\n         * @type {LoopContext}\n         */\n\n\n        /**\n         * The AST node's `type` for the loop.\n         * @type {string}\n         */\n\n\n        /**\n         * The label for the loop from an enclosing `LabeledStatement`.\n         * @type {string|null}\n         */\n\n\n        /**\n         * The fork context for when `break` is encountered.\n         * @type {ForkContext}\n         */\n\n\n/**\n * Represents the context for a `while` loop.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n\n\n        /**\n         * The hardcoded literal boolean test condition for\n         * the loop. Used to catch infinite or skipped loops.\n         * @type {boolean|undefined}\n         */\n\n\n        /**\n         * The segments representing the test condition where `continue` will\n         * jump to. The test condition will typically have just one segment but\n         * it's possible for there to be more than one.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n/**\n * Represents the context for a `do-while` loop.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     * @param {ForkContext} forkContext The enclosing fork context.\n     */\n\n\n        /**\n         * The hardcoded literal boolean test condition for\n         * the loop. Used to catch infinite or skipped loops.\n         * @type {boolean|undefined}\n         */\n\n\n        /**\n         * The segments at the start of the loop body. This is the only loop\n         * where the test comes at the end, so the first iteration always\n         * happens and we need a reference to the first statements.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The fork context to follow when a `continue` is found.\n         * @type {ForkContext}\n         */\n\n\n/**\n * Represents the context for a `for` loop.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n\n\n        /**\n         * The hardcoded literal boolean test condition for\n         * the loop. Used to catch infinite or skipped loops.\n         * @type {boolean|undefined}\n         */\n\n\n        /**\n         * The end of the init expression. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * an init expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The start of the test expression. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * a test expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The end of the test expression. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * a test expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The start of the update expression. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * an update expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The end of the update expresion. This may change during the lifetime\n         * of the instance as we traverse the loop because some loops don't have\n         * an update expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The segments representing the test condition where `continue` will\n         * jump to. The test condition will typically have just one segment but\n         * it's possible for there to be more than one. This may change during the\n         * lifetime of the instance as we traverse the loop because some loops\n         * don't have an update expression. When there is an update expression, this\n         * will end up pointing to that expression; otherwise it will end up pointing\n         * to the test expression.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n/**\n * Represents the context for a `for-in` loop.\n *\n * Terminology:\n * - \"left\" means the part of the loop to the left of the `in` keyword. For\n *   example, in `for (var x in y)`, the left is `var x`.\n * - \"right\" means the part of the loop to the right of the `in` keyword. For\n *   example, in `for (var x in y)`, the right is `y`.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n\n\n        /**\n         * The segments that came immediately before the start of the loop.\n         * This allows you to traverse backwards out of the loop into the\n         * surrounding code. This is necessary to evaluate the right expression\n         * correctly, as it must be evaluated in the same way as the left\n         * expression, but the pointer to these segments would otherwise be\n         * lost if not stored on the instance. Once the right expression has\n         * been evaluated, this property is no longer used.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * Segments representing the start of everything to the left of the\n         * `in` keyword. This can be used to move forward towards\n         * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are\n         * effectively the head and tail of a doubly-linked list.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * Segments representing the end of everything to the left of the\n         * `in` keyword. This can be used to move backward towards `leftSegments`.\n         * `leftSegments` and `endOfLeftSegments` are effectively the head\n         * and tail of a doubly-linked list.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The segments representing the left expression where `continue` will\n         * jump to. In `for-in` loops, `continue` must always re-execute the\n         * left expression each time through the loop. This contains the same\n         * segments as `leftSegments`, but is duplicated here so each loop\n         * context has the same property pointing to where `continue` should\n         * end up.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n/**\n * Represents the context for a `for-of` loop.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {LoopContext|null} upperContext The previous `LoopContext`.\n     * @param {string|null} label The label for the loop from an enclosing `LabeledStatement`.\n     * @param {BreakContext} breakContext The context for breaking the loop.\n     */\n\n\n        /**\n         * The segments that came immediately before the start of the loop.\n         * This allows you to traverse backwards out of the loop into the\n         * surrounding code. This is necessary to evaluate the right expression\n         * correctly, as it must be evaluated in the same way as the left\n         * expression, but the pointer to these segments would otherwise be\n         * lost if not stored on the instance. Once the right expression has\n         * been evaluated, this property is no longer used.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * Segments representing the start of everything to the left of the\n         * `of` keyword. This can be used to move forward towards\n         * `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are\n         * effectively the head and tail of a doubly-linked list.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * Segments representing the end of everything to the left of the\n         * `of` keyword. This can be used to move backward towards `leftSegments`.\n         * `leftSegments` and `endOfLeftSegments` are effectively the head\n         * and tail of a doubly-linked list.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The segments representing the left expression where `continue` will\n         * jump to. In `for-in` loops, `continue` must always re-execute the\n         * left expression each time through the loop. This contains the same\n         * segments as `leftSegments`, but is duplicated here so each loop\n         * context has the same property pointing to where `continue` should\n         * end up.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n/**\n * Represents the context for any loop.\n * @typedef {WhileLoopContext|DoWhileLoopContext|ForLoopContext|ForInLoopContext|ForOfLoopContext} LoopContext\n */\n\n/**\n * Represents the context for a `switch` statement.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {SwitchContext} upperContext The previous context.\n     * @param {boolean} hasCase Indicates if there is at least one `case` statement.\n     *      `default` doesn't count.\n     */\n\n\n        /**\n         * The previous context.\n         * @type {SwitchContext}\n         */\n\n\n        /**\n         * Indicates if there is at least one `case` statement. `default` doesn't count.\n         * @type {boolean}\n         */\n\n\n        /**\n         * The `default` keyword.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * The default case body starting segments.\n         * @type {Array<CodePathSegment>|null}\n         */\n\n\n        /**\n         * Indicates if a `default` case and is empty exists.\n         * @type {boolean}\n         */\n\n\n        /**\n         * Indicates that a `default` exists and is the last case.\n         * @type {boolean}\n         */\n\n\n        /**\n         * The number of fork contexts created. This is equivalent to the\n         * number of `case` statements plus a `default` statement (if present).\n         * @type {number}\n         */\n\n\n/**\n * Represents the context for a `try` statement.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {TryContext} upperContext The previous context.\n     * @param {boolean} hasFinalizer Indicates if the `try` statement has a\n     *      `finally` block.\n     * @param {ForkContext} forkContext The enclosing fork context.\n     */\n\n\n        /**\n         * The previous context.\n         * @type {TryContext}\n         */\n\n\n        /**\n         * Indicates if the `try` statement has a `finally` block.\n         * @type {boolean}\n         */\n\n\n        /**\n         * Tracks the traversal position inside of the `try` statement. This is\n         * used to help determine the context necessary to create paths because\n         * a `try` statement may or may not have `catch` or `finally` blocks,\n         * and code paths behave differently in those blocks.\n         * @type {\"try\"|\"catch\"|\"finally\"}\n         */\n\n\n        /**\n         * If the `try` statement has a `finally` block, this affects how a\n         * `return` statement behaves in the `try` block. Without `finally`,\n         * `return` behaves as usual and doesn't require a fork; with `finally`,\n         * `return` forks into the `finally` block, so we need a fork context\n         * to track it.\n         * @type {ForkContext|null}\n         */\n\n\n        /**\n         * When a `throw` occurs inside of a `try` block, the code path forks\n         * into the `catch` or `finally` blocks, and this fork context tracks\n         * that path.\n         * @type {ForkContext}\n         */\n\n\n        /**\n         * Indicates if the last segment in the `try` block is reachable.\n         * @type {boolean}\n         */\n\n\n        /**\n         * Indicates if the last segment in the `catch` block is reachable.\n         * @type {boolean}\n         */\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not include the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments Segments to add.\n * @returns {void}\n */\n\n\n/**\n * Gets a loop context for a `continue` statement based on a given label.\n * @param {CodePathState} state The state to search within.\n * @param {string|null} label The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\n\n\n    /* c8 ignore next */\n\n\n/**\n * Gets a context for a `break` statement.\n * @param {CodePathState} state The state to search within.\n * @param {string|null} label The label of a `break` statement.\n * @returns {BreakContext} A context for a `break` statement.\n */\n\n\n    /* c8 ignore next */\n\n\n/**\n * Gets a context for a `return` statement. There is just one special case:\n * if there is a `try` statement with a `finally` block, because that alters\n * how `return` behaves; otherwise, this just passes through the given state.\n * @param {CodePathState} state The state to search within\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\n\n\n/**\n * Gets a context for a `throw` statement. There is just one special case:\n * if there is a `try` statement with a `finally` block and we are inside of\n * a `catch` because that changes how `throw` behaves; otherwise, this just\n * passes through the given state.\n * @param {CodePathState} state The state to search within.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\n\n\n/**\n * Removes a given value from a given array.\n * @param {any[]} elements An array to remove the specific element.\n * @param {any} value The value to be removed.\n * @returns {void}\n */\n\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\n * @returns {void}\n */\n\n\n/**\n * Creates looping path between two arrays of segments, ensuring that there are\n * paths going between matching segments in the arrays.\n * @param {CodePathState} state The state to operate on.\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\n * @returns {void}\n */\n\n\n    /*\n     * This loop effectively updates a doubly-linked list between two collections\n     * of segments making sure that segments in the same array indices are\n     * combined to create a path.\n     */\n\n\n        // get the segments in matching array indices\n\n\n        /*\n         * If the destination segment is reachable, then create a path from the\n         * source segment to the destination segment.\n         */\n\n\n        /*\n         * If the source segment is reachable, then create a path from the\n         * destination segment back to the source segment.\n         */\n\n\n        /*\n         * Also update the arrays that don't care if the segments are reachable\n         * or not. This should always happen regardless of anything else.\n         */\n\n\n        /*\n         * If the destination segment has at least two previous segments in its\n         * path then that means there was one previous segment before this iteration\n         * of the loop was executed. So, we need to mark the source segment as\n         * looped.\n         */\n\n\n        // let the code path analyzer know that there's been a loop created\n\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n * @param {LoopContext} context A loop context to modify.\n * @param {ChoiceContext} choiceContext A choice context of this loop.\n * @param {CodePathSegment[]} head The current head paths.\n * @returns {void}\n */\n\n\n    /*\n     * If this choice context doesn't already contain paths from a\n     * child context, then add the current head to each potential path.\n     */\n\n\n    /*\n     * If the test condition isn't a hardcoded truthy value, then `break`\n     * must follow the same path as if the test condition is false. To represent\n     * that, we append the path for when the loop test is false (represented by\n     * `falseForkContext`) to the `brokenForkContext`.\n     */\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n */\n\n\n    /**\n     * Creates a new instance.\n     * @param {IdGenerator} idGenerator An id generator to generate id for code\n     *   path segments.\n     * @param {Function} onLooped A callback function to notify looping.\n     */\n\n\n        /**\n         * The ID generator to use when creating new segments.\n         * @type {IdGenerator}\n         */\n\n\n        /**\n         * A callback function to call when there is a loop.\n         * @type {Function}\n         */\n\n\n        /**\n         * The root fork context for this state.\n         * @type {ForkContext}\n         */\n\n\n        /**\n         * Context for logical expressions, conditional expressions, `if` statements,\n         * and loops.\n         * @type {ChoiceContext}\n         */\n\n\n        /**\n         * Context for `switch` statements.\n         * @type {SwitchContext}\n         */\n\n\n        /**\n         * Context for `try` statements.\n         * @type {TryContext}\n         */\n\n\n        /**\n         * Context for loop statements.\n         * @type {LoopContext}\n         */\n\n\n        /**\n         * Context for `break` statements.\n         * @type {BreakContext}\n         */\n\n\n        /**\n         * Context for `ChainExpression` nodes.\n         * @type {ChainContext}\n         */\n\n\n        /**\n         * An array that tracks the current segments in the state. The array\n         * starts empty and segments are added with each `onCodePathSegmentStart`\n         * event and removed with each `onCodePathSegmentEnd` event. Effectively,\n         * this is tracking the code path segment traversal as the state is\n         * modified.\n         * @type {Array<CodePathSegment>}\n         */\n\n\n        /**\n         * Tracks the starting segment for this path. This value never changes.\n         * @type {CodePathSegment}\n         */\n\n\n        /**\n         * The final segments of the code path which are either `return` or `throw`.\n         * This is a union of the segments in `returnedForkContext` and `thrownForkContext`.\n         * @type {Array<CodePathSegment>}\n         */\n\n\n        /**\n         * The final segments of the code path which are `return`. These\n         * segments are also contained in `finalSegments`.\n         * @type {Array<CodePathSegment>}\n         */\n\n\n        /**\n         * The final segments of the code path which are `throw`. These\n         * segments are also contained in `finalSegments`.\n         * @type {Array<CodePathSegment>}\n         */\n\n\n        /*\n         * We add an `add` method so that these look more like fork contexts and\n         * can be used interchangeably when a fork context is needed to add more\n         * segments to a path.\n         *\n         * Ultimately, we want anything added to `returned` or `thrown` to also\n         * be added to `final`. We only add reachable and used segments to these\n         * arrays.\n         */\n\n\n    /**\n     * A passthrough property exposing the current pointer as part of the API.\n     * @type {CodePathSegment[]}\n     */\n\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n\n\n    /**\n     * Creates and stacks new forking context.\n     * @param {boolean} forkLeavingPath A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     * @returns {void}\n     */\n\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     * @param {string} kind A kind string.\n     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult Indicates if the result of the choice\n     *      creates a fork.\n     * @returns {void}\n     */\n\n\n    /**\n     * Pops the last choice context and finalizes it.\n     * @throws {Error} (Unreachable.)\n     * @returns {ChoiceContext} The popped context.\n     */\n\n\n                /*\n                 * The `headSegments` are the path of the right-hand operand.\n                 * If we haven't previously added segments from child contexts,\n                 * then we add these segments to all possible forks.\n                 */\n\n\n                /*\n                 * If this context is the left (test) expression for another choice\n                 * context, such as `a || b` in the expression `a || b || c`,\n                 * then we take the segments for this context and move them up\n                 * to the parent context.\n                 */\n\n\n                    // Exit early so we don't collapse all paths into one.\n\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n\n\n                /*\n                 * Loops are addressed in `popLoopContext()` so just return\n                 * the context without modification.\n                 */\n\n\n            /* c8 ignore next */\n\n\n        /*\n         * Merge the true path with the false path to create a single path.\n         */\n\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     * @throws {Error} (Unreachable.)\n     * @returns {void}\n     */\n\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n\n\n    /**\n     * Makes a code path segment of the `if` block.\n     * @returns {void}\n     */\n\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n\n\n        // Creates new path from the `true` case.\n\n\n    /**\n     * Makes a code path segment of the `else` block.\n     * @returns {void}\n     */\n\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n\n\n        // Creates new path from the `false` case.\n\n\n    //--------------------------------------------------------------------------\n    // ChainExpression\n    //--------------------------------------------------------------------------\n\n    /**\n     * Pushes a new `ChainExpression` context to the stack. This method is\n     * called when entering a `ChainExpression` node. A chain context is used to\n     * count forking in the optional chain then merge them on the exiting from the\n     * `ChainExpression` node.\n     * @returns {void}\n     */\n\n\n    /**\n     * Pop a `ChainExpression` context from the stack. This method is called on\n     * exiting from each `ChainExpression` node. This merges all forks of the\n     * last optional chaining.\n     * @returns {void}\n     */\n\n\n        // pop all choice contexts of this.\n\n\n    /**\n     * Create a choice context for optional access.\n     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\n     * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\n     * @returns {void}\n     */\n\n\n    /**\n     * Create a fork.\n     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\n     * @returns {void}\n     */\n\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     * @param {boolean} hasCase `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label The label text.\n     * @returns {void}\n     */\n\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     * @returns {void}\n     */\n\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n\n\n        /*\n         * Any value that doesn't match a `case` test should flow to the default\n         * case. That happens normally when the default case is last in the `switch`,\n         * but if it's not, we need to rewire some of the paths to be correct.\n         */\n\n\n                /*\n                 * There is a non-empty default case, so remove the path from the `default`\n                 * label to its body for an accurate representation.\n                 */\n\n\n                /*\n                 * Connect the path from the last non-default case to the body of the\n                 * default case.\n                 */\n\n\n                /*\n                 * There is no default case, so we treat this as if the last case\n                 * had a `break` in it.\n                 */\n\n\n        // Traverse up to the original fork context for the `switch` statement\n\n\n        /*\n         * Creates a path from all `brokenForkContext` paths.\n         * This is a path after `switch` statement.\n         */\n\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     * @param {boolean} isCaseBodyEmpty `true` if the body is empty.\n     * @param {boolean} isDefaultCase `true` if the body is the default case.\n     * @returns {void}\n     */\n\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current `case` and the body of the previous case.\n         */\n\n\n        /*\n         * Add information about the default case.\n         *\n         * The purpose of this is to identify the starting segments for the\n         * default case to make sure there is a path there.\n         */\n\n\n            /*\n             * This is the default case in the `switch`.\n             *\n             * We first save the current pointer as `defaultSegments` to point\n             * to the `default` keyword.\n             */\n\n\n            /*\n             * If the body of the case is empty then we just set\n             * `foundEmptyDefault` to true; otherwise, we save a reference\n             * to the current pointer as `defaultBodySegments`.\n             */\n\n\n            /*\n             * This is not the default case in the `switch`.\n             *\n             * If it's not empty and there is already an empty default case found,\n             * that means the default case actually comes before this case,\n             * and that it will fall through to this case. So, we can now\n             * ignore the previous default case (reset `foundEmptyDefault` to false)\n             * and set `defaultBodySegments` to the current segments because this is\n             * effectively the new default case.\n             */\n\n\n        // keep track if the default case ends up last\n\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     * @param {boolean} hasFinalizer `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     * @returns {void}\n     */\n\n\n        /*\n         * If we're inside the `catch` block, that means there is no `finally`,\n         * so we can process the `try` and `catch` blocks the simple way and\n         * merge their two paths.\n         */\n\n\n        /*\n         * The following process is executed only when there is a `finally`\n         * block.\n         */\n\n\n        // no `return` or `throw` in `try` or `catch` so there's nothing left to do\n\n\n        /*\n         * The following process is executed only when there is a `finally`\n         * block and there was a `return` or `throw` in the `try` or `catch`\n         * blocks.\n         */\n\n        // Separate head to normal paths and leaving paths.\n\n\n        // Forwards the leaving path to upper contexts.\n\n\n        // Sets the normal path as the next.\n\n\n        /*\n         * If both paths of the `try` block and the `catch` block are\n         * unreachable, the next path becomes unreachable as well.\n         */\n\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     * @returns {void}\n     */\n\n\n        /*\n         * We are now in a catch block so we need to update the context\n         * with that information. This includes creating a new fork\n         * context in case we encounter any `throw` statements here.\n         */\n\n\n        // Merge the thrown paths from the `try` and `catch` blocks\n\n\n        // Fork to a bypass and the merged thrown path.\n\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     * @returns {void}\n     */\n\n\n        // Update state.\n\n\n            // Merges two paths from the `try` block and `catch` block.\n\n\n        /*\n         * If there was no `return` or `throw` in either the `try` or `catch`\n         * blocks, then there's no further code paths to create for `finally`.\n         */\n\n\n            // This path does not leave.\n\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this `finally` block.\n         */\n\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     * @returns {void}\n     */\n\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     * @param {string} type The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label A label of the node which was triggered.\n     * @throws {Error} (Unreachable - unknown type.)\n     * @returns {void}\n     */\n\n\n        // All loops need a path to account for `break` statements\n\n\n            /* c8 ignore next */\n\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     * @throws {Error} (Unreachable - unknown type.)\n     * @returns {void}\n     */\n\n\n        // Creates a looped path.\n\n\n                /*\n                 * Creates the path from the end of the loop body up to the\n                 * location where `continue` would jump to.\n                 */\n\n\n                /*\n                 * If this isn't a hardcoded `true` condition, then `break`\n                 * should continue down the path as if the condition evaluated\n                 * to false.\n                 */\n\n\n                /*\n                 * When the condition is true, the loop continues back to the top,\n                 * so create a path from each possible true condition back to the\n                 * top of the loop.\n                 */\n\n\n                /*\n                 * Creates the path from the end of the loop body up to the\n                 * left expression (left of `in` or `of`) of the loop.\n                 */\n\n\n            /* c8 ignore next */\n\n\n        /*\n         * If there wasn't a `break` statement in the loop, then we're at\n         * the end of the loop's path, so we make an unreachable segment\n         * to mark that.\n         *\n         * If there was a `break` statement, then we continue on into the\n         * `brokenForkContext`.\n         */\n\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n\n\n        // Update state.\n\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     * @returns {void}\n     */\n\n\n        /*\n         * If this isn't a hardcoded `true` condition, then `break`\n         * should continue down the path as if the condition evaluated\n         * to false.\n         */\n\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     * @returns {void}\n     */\n\n\n        // Update state.\n\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n\n\n        /*\n         * If there is a `continue` statement in the loop then `continueForkContext`\n         * won't be empty. We wire up the path from `continue` to the loop\n         * test condition and then continue the traversal in the root fork context.\n         */\n\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     * @param {boolean|undefined} test The test value (only when constant).\n     * @returns {void}\n     */\n\n\n        /*\n         * Update the state.\n         *\n         * The `continueDestSegments` are set to `testSegments` because we\n         * don't yet know if there is an update expression in this loop. So,\n         * from what we already know at this point, a `continue` statement\n         * will jump back to the test expression.\n         */\n\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     * @returns {void}\n     */\n\n\n        // Make the next paths of the test.\n\n\n        /*\n         * Update the state.\n         *\n         * The `continueDestSegments` are now set to `updateSegments` because we\n         * know there is an update expression in this loop. So, a `continue` statement\n         * in the loop will jump to the update expression first, and then to any\n         * test expression the loop might have.\n         */\n\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     * @returns {void}\n     */\n\n\n        /*\n         * Determine what to do based on which part of the `for` loop are present.\n         * 1. If there is an update expression, then `updateSegments` is not null and\n         *    we need to assign `endOfUpdateSegments`, and if there is a test\n         *    expression, we then need to create the looped path to get back to\n         *    the test condition.\n         * 2. If there is no update expression but there is a test expression,\n         *    then we only need to update the test segment information.\n         * 3. If there is no update expression and no test expression, then we\n         *    just save `endOfInitSegments`.\n         */\n\n\n            /*\n             * In a `for` loop that has both an update expression and a test\n             * condition, execution flows from the test expression into the\n             * loop body, to the update expression, and then back to the test\n             * expression to determine if the loop should continue.\n             *\n             * To account for that, we need to make a path from the end of the\n             * update expression to the start of the test expression. This is\n             * effectively what creates the loop in the code path.\n             */\n\n\n        /*\n         * If there is a test condition, then there `endOfTestSegments` is also\n         * the start of the loop body. If there isn't a test condition then\n         * `bodySegments` will be null and we need to look elsewhere to find\n         * the start of the body.\n         *\n         * The body starts at the end of the init expression and ends at the end\n         * of the update expression, so we use those locations to determine the\n         * body segments.\n         */\n\n\n        /*\n         * If there was no test condition and no update expression, then\n         * `continueDestSegments` will be null. In that case, a\n         * `continue` should skip directly to the body of the loop.\n         * Otherwise, we want to keep the current `continueDestSegments`.\n         */\n\n\n        // move pointer to the body\n\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n\n\n        // Update state.\n\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n\n\n        // Update state.\n\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     * @returns {void}\n     */\n\n\n        // Make a path: `right` -> `left`.\n\n\n        // Update state.\n\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context in which a `break` statement can be used. This occurs inside of a loop,\n     * labeled statement, or switch statement.\n     * @param {boolean} breakable Indicates if we are inside a statement where\n     *      `break` without a label will exit the statement.\n     * @param {string|null} label The label associated with the statement.\n     * @returns {BreakContext} The new context.\n     */\n\n\n    /**\n     * Removes the top item of the break context stack.\n     * @returns {Object} The removed context.\n     */\n\n\n        // Process this context here for other than switches and loops.\n\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string|null} label A label of the break statement.\n     * @returns {void}\n     */\n\n\n        /* c8 ignore next */\n\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @param {string|null} label A label of the continue statement.\n     * @returns {void}\n     */\n\n\n                // If the context is a for-in/of loop, this affects a break also.\n\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     * @returns {void}\n     */\n\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n\n\n"
    },
    "4": {
        "bug_file": "lib/linter/code-path-analysis/code-path.js",
        "compressed": "NO",
        "line_numbers": 342,
        "compressed_line_numbers": 342,
        "compressed_bug_file_content": "/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathState = require(\"./code-path-state\");\nconst IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n */\nclass CodePath {\n\n    /**\n     * Creates a new instance.\n     * @param {Object} options Options for the function (see below).\n     * @param {string} options.id An identifier.\n     * @param {string} options.origin The type of code path origin.\n     * @param {CodePath|null} options.upper The code path of the upper function scope.\n     * @param {Function} options.onLooped A callback function to notify looping.\n     */\n    constructor({ id, origin, upper, onLooped }) {\n\n        /**\n         * The identifier of this code path.\n         * Rules use it to store additional information of each rule.\n         * @type {string}\n         */\n        this.id = id;\n\n        /**\n         * The reason that this code path was started. May be \"program\",\n         * \"function\", \"class-field-initializer\", or \"class-static-block\".\n         * @type {string}\n         */\n        this.origin = origin;\n\n        /**\n         * The code path of the upper function scope.\n         * @type {CodePath|null}\n         */\n        this.upper = upper;\n\n        /**\n         * The code paths of nested function scopes.\n         * @type {CodePath[]}\n         */\n        this.childCodePaths = [];\n\n        // Initializes internal state.\n        Object.defineProperty(\n            this,\n            \"internal\",\n            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }\n        );\n\n        // Adds this into `childCodePaths` of `upper`.\n        if (upper) {\n            upper.childCodePaths.push(this);\n        }\n    }\n\n    /**\n     * Gets the state of a given code path.\n     * @param {CodePath} codePath A code path to get.\n     * @returns {CodePathState} The state of the code path.\n     */\n    static getState(codePath) {\n        return codePath.internal;\n    }\n\n    /**\n     * The initial code path segment. This is the segment that is at the head\n     * of the code path.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment}\n     */\n    get initialSegment() {\n        return this.internal.initialSegment;\n    }\n\n    /**\n     * Final code path segments. These are the terminal (tail) segments in the\n     * code path, which is the combination of `returnedSegments` and `thrownSegments`.\n     * All segments in this array are reachable.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     */\n    get finalSegments() {\n        return this.internal.finalSegments;\n    }\n\n    /**\n     * Final code path segments that represent normal completion of the code path.\n     * For functions, this means both explicit `return` statements and implicit returns,\n     * such as the last reachable segment in a function that does not have an\n     * explicit `return` as this implicitly returns `undefined`. For scripts,\n     * modules, class field initializers, and class static blocks, this means\n     * all lines of code have been executed.\n     * These segments are also present in `finalSegments`.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     */\n    get returnedSegments() {\n        return this.internal.returnedForkContext;\n    }\n\n    /**\n     * Final code path segments that represent `throw` statements.\n     * This is a passthrough to the underlying `CodePathState`.\n     * These segments are also present in `finalSegments`.\n     * @type {CodePathSegment[]}\n     */\n    get thrownSegments() {\n        return this.internal.thrownForkContext;\n    }\n\n    /**\n     * Tracks the traversal of the code path through each segment. This array\n     * starts empty and segments are added or removed as the code path is\n     * traversed. This array always ends up empty at the end of a code path\n     * traversal. The `CodePathState` uses this to track its progress through\n     * the code path.\n     * This is a passthrough to the underlying `CodePathState`.\n     * @type {CodePathSegment[]}\n     * @deprecated\n     */\n    get currentSegments() {\n        return this.internal.currentSegments;\n    }\n\n    /**\n     * Traverses all segments in this code path.\n     *\n     *     codePath.traverseSegments((segment, controller) => {\n     *         // do something.\n     *     });\n     *\n     * This method enumerates segments in order from the head.\n     *\n     * The `controller` argument has two methods:\n     *\n     * - `skip()` - skips the following segments in this branch\n     * - `break()` - skips all following segments in the traversal\n     *\n     * A note on the parameters: the `options` argument is optional. This means\n     * the first argument might be an options object or the callback function.\n     * @param {Object} [optionsOrCallback] Optional first and last segments to traverse.\n     * @param {CodePathSegment} [optionsOrCallback.first] The first segment to traverse.\n     * @param {CodePathSegment} [optionsOrCallback.last] The last segment to traverse.\n     * @param {Function} callback A callback function.\n     * @returns {void}\n     */\n    traverseSegments(optionsOrCallback, callback) {\n\n        // normalize the arguments into a callback and options\n        let resolvedOptions;\n        let resolvedCallback;\n\n        if (typeof optionsOrCallback === \"function\") {\n            resolvedCallback = optionsOrCallback;\n            resolvedOptions = {};\n        } else {\n            resolvedOptions = optionsOrCallback || {};\n            resolvedCallback = callback;\n        }\n\n        // determine where to start traversing from based on the options\n        const startSegment = resolvedOptions.first || this.internal.initialSegment;\n        const lastSegment = resolvedOptions.last;\n\n        // set up initial location information\n        let record = null;\n        let index = 0;\n        let end = 0;\n        let segment = null;\n\n        // segments that have already been visited during traversal\n        const visited = new Set();\n\n        // tracks the traversal steps\n        const stack = [[startSegment, 0]];\n\n        // tracks the last skipped segment during traversal\n        let skippedSegment = null;\n\n        // indicates if we exited early from the traversal\n        let broken = false;\n\n        /**\n         * Maintains traversal state.\n         */\n        const controller = {\n\n            /**\n             * Skip the following segments in this branch.\n             * @returns {void}\n             */\n            skip() {\n                if (stack.length <= 1) {\n                    broken = true;\n                } else {\n                    skippedSegment = stack[stack.length - 2][0];\n                }\n            },\n\n            /**\n             * Stop traversal completely - do not traverse to any\n             * other segments.\n             * @returns {void}\n             */\n            break() {\n                broken = true;\n            }\n        };\n\n        /**\n         * Checks if a given previous segment has been visited.\n         * @param {CodePathSegment} prevSegment A previous segment to check.\n         * @returns {boolean} `true` if the segment has been visited.\n         */\n        function isVisited(prevSegment) {\n            return (\n                visited.has(prevSegment) ||\n                segment.isLoopedPrevSegment(prevSegment)\n            );\n        }\n\n        // the traversal\n        while (stack.length > 0) {\n\n            /*\n             * This isn't a pure stack. We use the top record all the time\n             * but don't always pop it off. The record is popped only if\n             * one of the following is true:\n             *\n             * 1) We have already visited the segment.\n             * 2) We have not visited *all* of the previous segments.\n             * 3) We have traversed past the available next segments.\n             *\n             * Otherwise, we just read the value and sometimes modify the\n             * record as we traverse.\n             */\n            record = stack[stack.length - 1];\n            segment = record[0];\n            index = record[1];\n\n            if (index === 0) {\n\n                // Skip if this segment has been visited already.\n                if (visited.has(segment)) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Skip if all previous segments have not been visited.\n                if (segment !== startSegment &&\n                    segment.prevSegments.length > 0 &&\n                    !segment.prevSegments.every(isVisited)\n                ) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Reset the skipping flag if all branches have been skipped.\n                if (skippedSegment && segment.prevSegments.includes(skippedSegment)) {\n                    skippedSegment = null;\n                }\n                visited.add(segment);\n\n                /*\n                 * If the most recent segment hasn't been skipped, then we call\n                 * the callback, passing in the segment and the controller.\n                 */\n                if (!skippedSegment) {\n                    resolvedCallback.call(this, segment, controller);\n\n                    // exit if we're at the last segment\n                    if (segment === lastSegment) {\n                        controller.skip();\n                    }\n\n                    /*\n                     * If the previous statement was executed, or if the callback\n                     * called a method on the controller, we might need to exit the\n                     * loop, so check for that and break accordingly.\n                     */\n                    if (broken) {\n                        break;\n                    }\n                }\n            }\n\n            // Update the stack.\n            end = segment.nextSegments.length - 1;\n            if (index < end) {\n\n                /*\n                 * If we haven't yet visited all of the next segments, update\n                 * the current top record on the stack to the next index to visit\n                 * and then push a record for the current segment on top.\n                 *\n                 * Setting the current top record's index lets us know how many\n                 * times we've been here and ensures that the segment won't be\n                 * reprocessed (because we only process segments with an index\n                 * of 0).\n                 */\n                record[1] += 1;\n                stack.push([segment.nextSegments[index], 0]);\n            } else if (index === end) {\n\n                /*\n                 * If we are at the last next segment, then reset the top record\n                 * in the stack to next segment and set its index to 0 so it will\n                 * be processed next.\n                 */\n                record[0] = segment.nextSegments[index];\n                record[1] = 0;\n            } else {\n\n                /*\n                 * If index > end, that means we have no more segments that need\n                 * processing. So, we pop that record off of the stack in order to\n                 * continue traversing at the next level up.\n                 */\n                stack.pop();\n            }\n        }\n    }\n}\n\nmodule.exports = CodePath;"
    },
    "5": {
        "bug_file": "lib/linter/linter.js",
        "compressed": "YES",
        "line_numbers": 2134,
        "compressed_line_numbers": 813,
        "compressed_bug_file_content": "/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n * @author aladdin-add\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ConfigArray>} ConfigArray */\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ExtractedConfig>} ExtractedConfig */\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n/**\n * @template T\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\n */\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n/**\n * @typedef {Object} DisableDirective\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type Type of directive\n * @property {number} line The line number\n * @property {number} column The column number\n * @property {(string|null)} ruleId The rule ID\n * @property {string} justification The justification of directive\n */\n\n/**\n * The private data for `Linter` instance.\n * @typedef {Object} LinterInternalSlots\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\n * @property {SuppressedLintMessage[]} lastSuppressedMessages The `SuppressedLintMessage[]` instance that the last `verify()` call produced.\n * @property {Map<string, Parser>} parserMap The loaded parsers.\n * @property {Rules} ruleMap The loaded rules.\n */\n\n/**\n * @typedef {Object} VerifyOptions\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\n *      to change config once it is set. Defaults to true if not supplied.\n *      Useful if you want to validate JS without comments overriding rules.\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\n *      properties into the lint result.\n * @property {string} [filename] the filename of the source code.\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\n *      unused `eslint-disable` directives.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\n *      predicate function that selects adopt code blocks.\n * @property {Processor.postprocess} [postprocess] postprocessor for report\n *      messages. If provided, this should accept an array of the message lists\n *      for each code block returned from the preprocessor, apply a mapping to\n *      the messages as appropriate, and return a one-dimensional array of\n *      messages.\n * @property {Processor.preprocess} [preprocess] preprocessor for source text.\n *      If provided, this should accept a string of source text, and return an\n *      array of code blocks to lint.\n */\n\n/**\n * @typedef {Object} FixOptions\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\n *      whether fixes should be applied.\n */\n\n/**\n * @typedef {Object} InternalOptions\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines if a given object is Espree.\n * @param {Object} parser The parser to check.\n * @returns {boolean} True if the parser is Espree or false if not.\n */\n\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} configGlobals The globals declared in configuration\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\n * @returns {void}\n */\n\n\n    // Define configured global variables.\n\n\n        /*\n         * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\n         */\n\n\n    // mark all exported variables as such\n\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n\n\n/**\n * creates a missing-rule message.\n * @param {string} ruleId the ruleId to create\n * @returns {string} created error message\n * @private\n */\n\n\n/**\n * creates a linting problem\n * @param {Object} options to create linting error\n * @param {string} [options.ruleId] the ruleId to report\n * @param {Object} [options.loc] the loc to report\n * @param {string} [options.message] the error message to report\n * @param {string} [options.severity] the error message to report\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\n * @private\n */\n\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {Object} options to create disable directives\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\n * @param {token} options.commentToken The Comment token\n * @param {string} options.value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @param {string} options.justification The justification of the directive\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\n * @returns {Object} Directives and problems from the comment\n */\n\n\n        // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n\n\n/**\n * Extract the directive and the justification from a given directive comment and trim them.\n * @param {string} value The comment text to extract.\n * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.\n */\n\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: LintMessage[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\n\n\n                            // do not apply the config, if found invalid options.\n\n\n            // no default\n\n\n        exportedVariables,\n\n\n/**\n * Parses comments in file to extract disable directives.\n * @param {SourceCode} sourceCode The SourceCode object to get comments from.\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\n * @returns {{problems: LintMessage[], disableDirectives: DisableDirective[]}}\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\n */\n\n\n            // no default\n\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param {Parser} parser The parser which uses this options.\n * @param {number} ecmaVersion ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\n\n\n    /*\n     * Calculate ECMAScript edition number from official year version starting with\n     * ES2015, which corresponds with ES6 (or a difference of 2009).\n     */\n\n\n/**\n * Normalize ECMAScript version from the initial config into languageOptions (year)\n * format.\n * @param {any} [ecmaVersion] ECMAScript version from the initial config\n * @returns {number} normalized ECMAScript version\n */\n\n\n        // void 0 = no ecmaVersion specified so use the default\n\n\n    /*\n     * We default to the latest supported ecmaVersion for everything else.\n     * Remember, this is for languageOptions.ecmaVersion, which sets the version\n     * that is used for a number of processes inside of ESLint. It's normally\n     * safe to assume people want the latest unless otherwise specified.\n     */\n\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\n\n\n/**\n * Convert \"/path/to/<text>\" to \"<text>\".\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\n * was omitted because `configArray.extractConfig()` requires an absolute path.\n * But the linter should pass `<text>` to `RuleContext#filename` in that\n * case.\n * Also, code blocks can have their virtual filename. If the parent filename was\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\n * it's not an absolute path).\n * @param {string} filename The filename to normalize.\n * @returns {string} The normalized filename.\n */\n\n\n/**\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\n * consistent shape.\n * @param {VerifyOptions} providedOptions Options\n * @param {ConfigData} config Config.\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\n */\n\n\n    // .noInlineConfig for eslintrc, .linterOptions.noInlineConfig for flat\n\n\n/**\n * Combines the provided parserOptions with the options from environments\n * @param {Parser} parser The parser which uses this options.\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {ParserOptions} Resulting parser options after merge\n */\n\n\n        /*\n         * can't have global return inside of modules\n         * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\n         */\n\n\n/**\n * Converts parserOptions to languageOptions for backwards compatibility with eslintrc.\n * @param {ConfigData} config Config object.\n * @param {Object} config.globals Global variable definitions.\n * @param {Parser} config.parser The parser to use.\n * @param {ParserOptions} config.parserOptions The parserOptions to use.\n * @returns {LanguageOptions} The languageOptions equivalent.\n */\n\n\n/**\n * Combines the provided globals object with the globals from environments\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\n * @returns {Record<string, GlobalConf>} The resolved globals object\n */\n\n\n/**\n * Strips Unicode BOM from a given text.\n * @param {string} text A text to strip.\n * @returns {string} The stripped text.\n */\n\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\n\n\n/**\n * Analyze scope of the given AST.\n * @param {ASTNode} ast The `Program` node to analyze.\n * @param {LanguageOptions} languageOptions The parser options.\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\n * @returns {ScopeManager} The analysis result.\n */\n\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {LanguageOptions} languageOptions Options to pass to the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: LintMessage}|{success: true, sourceCode: SourceCode}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\n\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n\n\n            /*\n             * Save all values that `parseForESLint()` returned.\n             * If a `SourceCode` object is given as the first parameter instead of source code text,\n             * linter skips the parsing process and reuses the source code object.\n             * In that case, linter needs all the values that `parseForESLint()` returned.\n             */\n\n\n        // If the message includes a leading line number, strip it:\n\n\n/**\n * Runs a rule, and gets its listeners\n * @param {Rule} rule A normalized rule with a `create` method\n * @param {Context} ruleContext The context that should be passed to the rule\n * @throws {any} Any error during the rule's `create`\n * @returns {Object} A map of selector listeners provided by the rule\n */\n\n\n// methods that exist on SourceCode object\n\n\n/**\n * Runs the given rules on the given SourceCode object\n * @param {SourceCode} sourceCode A SourceCode object for the given text\n * @param {Object} configuredRules The rules configuration\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\n * @param {string | undefined} parserName The name of the parser in the config\n * @param {LanguageOptions} languageOptions The options for parsing the code.\n * @param {Object} settings The settings that were enabled in the config\n * @param {string} filename The reported filename of the code\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\n * @param {string | undefined} cwd cwd of the cli\n * @param {string} physicalFilename The full path of the file on disk without any code block information\n * @returns {LintMessage[]} An array of reported problems\n */\n\n\n    /*\n     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n     * properties once for each rule.\n     */\n\n\n        // not load disabled rules\n\n\n                        /*\n                         * Create a report translator lazily.\n                         * In a vast majority of cases, any given rule reports zero errors on a given\n                         * piece of code. Creating a translator lazily avoids the performance cost of\n                         * creating a new translator function for each rule that usually doesn't get\n                         * called.\n                         *\n                         * Using lazy report translators improves end-to-end performance by about 3%\n                         * with Node 8.4.0.\n                         */\n\n\n                                // Encourage migration from the former property name.\n\n\n        /**\n         * Include `ruleId` in error logs\n         * @param {Function} ruleListener A rule method that listens for a node.\n         * @returns {Function} ruleListener wrapped in error handler\n         */\n\n\n        // add all the selectors from the rule as listeners\n\n\n    // only run code path analyzer if the top level node is \"Program\", skip otherwise\n\n\n/**\n * Ensure the source code to be a string.\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\n * @returns {string} The source code text.\n */\n\n\n/**\n * Get an environment.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} envId The environment ID to get.\n * @returns {Environment|null} The environment.\n */\n\n\n/**\n * Get a rule.\n * @param {LinterInternalSlots} slots The internal slots of Linter.\n * @param {string} ruleId The rule ID to get.\n * @returns {Rule|null} The rule.\n */\n\n\n/**\n * Normalize the value of the cwd\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\n * @returns {string | undefined} normalized cwd\n */\n\n\n    // It's more explicit to assign the undefined\n    // eslint-disable-next-line no-undefined -- Consistently returning a value\n\n\n/**\n * The map to store private data.\n * @type {WeakMap<Linter, LinterInternalSlots>}\n */\n\n\n/**\n * Throws an error when the given linter is in flat config mode.\n * @param {Linter} linter The linter to check.\n * @returns {void}\n * @throws {Error} If the linter is in flat config mode.\n */\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name Linter\n */\n\n\n    /**\n     * Initialize the Linter.\n     * @param {Object} [config] the config object\n     * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.\n     * @param {\"flat\"|\"eslintrc\"} [config.configType=\"eslintrc\"] the type of config used.\n     */\n\n\n    /**\n     * Getter for package version.\n     * @static\n     * @returns {string} The version from package.json.\n     */\n\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @throws {Error} If during rule execution.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n     */\n\n\n        // evaluate arguments\n\n\n        // Resolve parser.\n\n\n        // search and apply \"eslint-env *\".\n\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n\n\n        // augment global scope with declared global variables\n\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\n     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\n     */\n\n\n                /*\n                 * Because of how Webpack packages up the files, we can't\n                 * compare directly to `FlatConfigArray` using `instanceof`\n                 * because it's not the same `FlatConfigArray` as in the tests.\n                 * So, we work around it by assuming an array is, in fact, a\n                 * `FlatConfigArray` if it has a `getConfig()` method.\n                 */\n\n\n        /*\n         * If we get to here, it means `config` is just an object rather\n         * than a config array so we can go right into linting.\n         */\n\n        /*\n         * `Linter` doesn't support `overrides` property in configuration.\n         * So we cannot apply multiple processors.\n         */\n\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {FlatConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n\n\n            // If the message includes a leading line number, strip it:\n\n\n            // Keep the legacy behavior.\n\n\n            // Skip this block if filtered.\n\n\n            // Resolve configuration again if the file content or extension was changed.\n\n\n            // Does lint.\n\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\n     * @throws {Error} If during rule execution.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\n     */\n\n\n        // evaluate arguments\n\n\n        // double check that there is a parser to avoid mysterious error messages\n\n\n        // Espree expects this information to be passed in\n\n\n            /*\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\n             */\n\n\n        /*\n         * Make adjustments based on the language options. For JavaScript,\n         * this is primarily about adding variables into the global scope\n         * to account for ecmaVersion and configured globals.\n         */\n\n\n        /*\n         * Inline config can be either enabled or disabled. If disabled, it's possible\n         * to detect the inline config and emit a warning (though this is not required).\n         * So we first check to see if inline config is allowed at all, and if so, we\n         * need to check if it's a warning or not.\n         */\n\n\n            // if inline config should warn then add the warnings\n\n\n                // next we need to verify information about the specified rules\n\n\n            // debug(\"Parser Path:\", parserName);\n\n\n    /**\n     * Verify a given code with `ConfigArray`.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n\n\n        // Store the config array in order to get plugin envs and rules later.\n\n\n        // Extract the final config for this file.\n\n\n        // Verify.\n\n\n    /**\n     * Verify a given code with a flat config.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {FlatConfigArray} configArray The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {boolean} [firstCall=false] Indicates if this is being called directly\n     *      from verify(). (TODO: Remove once eslintrc is removed.)\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n\n\n        // we need a filename to match configs against\n\n\n        // Store the config array in order to get plugin envs and rules later.\n\n\n        // Verify.\n\n\n        // check for options-based processing\n\n\n    /**\n     * Verify with a processor.\n     * @param {string|SourceCode} textOrSourceCode The source code.\n     * @param {ConfigData|ExtractedConfig} config The config array.\n     * @param {VerifyOptions&ProcessorOptions} options The options.\n     * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\n     */\n\n\n            // If the message includes a leading line number, strip it:\n\n\n            // Keep the legacy behavior.\n\n\n            // Skip this block if filtered.\n\n\n            // Resolve configuration again if the file content or extension was changed.\n\n\n            // Does lint.\n\n\n    /**\n     * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.\n     * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.\n     * @param {Array<LintMessage|SuppressedLintMessage>} problems A list of reported problems.\n     * @returns {LintMessage[]} A list of LintMessage.\n     */\n\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n\n\n    /**\n     * Gets the list of SuppressedLintMessage produced in the last running.\n     * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage\n     */\n\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n\n\n    /**\n     * Defines many new linting rules.\n     * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map<string, Rule>} All loaded rules\n     */\n\n\n    /**\n     * Define a new parser module\n     * @param {string} parserId Name of the parser\n     * @param {Parser} parserModule The parser object\n     * @returns {void}\n     */\n\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.\n     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\n     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n\n\n            /*\n             * stop if there are any syntax errors.\n             * 'fixedResult.output' is a empty string.\n             */\n\n\n            // keep track if any fixes were ever applied - important for return value\n\n\n            // update to use the fixed output instead of the original text\n\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n\n\n        // ensure the last result properly reflects if fixes were done\n\n\n    /**\n     * Get the internal slots of a given Linter instance for tests.\n     * @param {Linter} instance The Linter instance to get.\n     * @returns {LinterInternalSlots} The internal slots.\n     */\n\n\n"
    }
}