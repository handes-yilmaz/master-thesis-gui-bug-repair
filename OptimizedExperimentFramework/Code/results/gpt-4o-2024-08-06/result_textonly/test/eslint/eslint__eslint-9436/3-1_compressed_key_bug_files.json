{
    "1": {
        "bug_file": "lib/rules/no-constant-condition.js",
        "compressed": "NO",
        "line_numbers": 210,
        "compressed_line_numbers": 210,
        "compressed_bug_file_content": "/**\n * @fileoverview Rule to flag use constant conditions\n * @author Christian Schulz <http://rndm.de>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow constant expressions in conditions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    checkLoops: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n\n        ]\n    },\n\n    create(context) {\n        const options = context.options[0] || {},\n            checkLoops = options.checkLoops !== false,\n            loopSetStack = [];\n\n        let loopsInCurrentScope = new Set();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n\n        /**\n         * Checks if a branch node of LogicalExpression short circuits the whole condition\n         * @param {ASTNode} node The branch of main condition which needs to be checked\n         * @param {string} operator The operator of the main LogicalExpression.\n         * @returns {boolean} true when condition short circuits whole condition\n         */\n        function isLogicalIdentity(node, operator) {\n            switch (node.type) {\n                case \"Literal\":\n                    return (operator === \"||\" && node.value === true) ||\n                           (operator === \"&&\" && node.value === false);\n\n                case \"UnaryExpression\":\n                    return (operator === \"&&\" && node.operator === \"void\");\n\n                case \"LogicalExpression\":\n                    return isLogicalIdentity(node.left, node.operator) ||\n                             isLogicalIdentity(node.right, node.operator);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Checks if a node has a constant truthiness value.\n         * @param {ASTNode} node The AST node to check.\n         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.\n         *  `true` in all other cases\n         * @returns {Bool} true when node's truthiness is constant\n         * @private\n         */\n        function isConstant(node, inBooleanPosition) {\n            switch (node.type) {\n                case \"Literal\":\n                case \"ArrowFunctionExpression\":\n                case \"FunctionExpression\":\n                case \"ObjectExpression\":\n                case \"ArrayExpression\":\n                    return true;\n\n                case \"UnaryExpression\":\n                    if (node.operator === \"void\") {\n                        return true;\n                    }\n\n                    return (node.operator === \"typeof\" && inBooleanPosition) ||\n                        isConstant(node.argument, true);\n\n                case \"BinaryExpression\":\n                    return isConstant(node.left, false) &&\n                            isConstant(node.right, false) &&\n                            node.operator !== \"in\";\n\n                case \"LogicalExpression\": {\n                    const isLeftConstant = isConstant(node.left, inBooleanPosition);\n                    const isRightConstant = isConstant(node.right, inBooleanPosition);\n                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\n                    const isRightShortCircuit = (isRightConstant && isLogicalIdentity(node.right, node.operator));\n\n                    return (isLeftConstant && isRightConstant) || isLeftShortCircuit || isRightShortCircuit;\n                }\n\n                case \"AssignmentExpression\":\n                    return (node.operator === \"=\") && isConstant(node.right, inBooleanPosition);\n\n                case \"SequenceExpression\":\n                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n                // no default\n            }\n            return false;\n        }\n\n        /**\n         * Tracks when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function trackConstantConditionLoop(node) {\n            if (node.test && isConstant(node.test, true)) {\n                loopsInCurrentScope.add(node);\n            }\n        }\n\n        /**\n         * Reports when the set contains the given constant condition node\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkConstantConditionLoopInSet(node) {\n            if (loopsInCurrentScope.has(node)) {\n                loopsInCurrentScope.delete(node);\n                context.report({ node, message: \"Unexpected constant condition.\" });\n            }\n        }\n\n        /**\n         * Reports when the given node contains a constant condition.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function reportIfConstant(node) {\n            if (node.test && isConstant(node.test, true)) {\n                context.report({ node, message: \"Unexpected constant condition.\" });\n            }\n        }\n\n        /**\n         * Stores current set of constant loops in loopSetStack temporarily\n         * and uses a new set to track constant loops\n         * @returns {void}\n         * @private\n         */\n        function enterFunction() {\n            loopSetStack.push(loopsInCurrentScope);\n            loopsInCurrentScope = new Set();\n        }\n\n        /**\n         * Reports when the set still contains stored constant conditions\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function exitFunction() {\n            loopsInCurrentScope = loopSetStack.pop();\n        }\n\n        /**\n         * Checks node when checkLoops option is enabled\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLoop(node) {\n            if (checkLoops) {\n                trackConstantConditionLoop(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ConditionalExpression: reportIfConstant,\n            IfStatement: reportIfConstant,\n            WhileStatement: checkLoop,\n            \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n            DoWhileStatement: checkLoop,\n            \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n            ForStatement: checkLoop,\n            \"ForStatement > .test\": node => checkLoop(node.parent),\n            \"ForStatement:exit\": checkConstantConditionLoopInSet,\n            FunctionDeclaration: enterFunction,\n            \"FunctionDeclaration:exit\": exitFunction,\n            YieldExpression: () => loopsInCurrentScope.clear()\n        };\n\n    }\n};"
    },
    "2": {
        "bug_file": "lib/linter.js",
        "compressed": "YES",
        "line_numbers": 1110,
        "compressed_line_numbers": 470,
        "compressed_bug_file_content": "/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The result of a parsing operation from parseForESLint()\n * @typedef {Object} CustomParseResult\n * @property {ASTNode} ast The ESTree AST Program node.\n * @property {Object} services An object containing additional services related\n *      to the parser.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Parses a list of \"name:boolean_value\" or/and \"name\" options divided by comma or\n * whitespace.\n * @param {string} string The string to parse.\n * @param {Comment} comment The comment node which has the string.\n * @returns {Object} Result map object of names and boolean values\n */\n\n\n    // Collapse whitespace around `:` and `,` to make parsing easier\n\n\n/**\n * Parses a JSON-like config.\n * @param {string} string The string to parse.\n * @param {Object} location Start line and column of comments for potential error message.\n * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n */\n\n\n    // Parses a JSON-like comment by the same way as parsing CLI option.\n\n\n        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n        // Also, commaless notations have invalid severity:\n        //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n        // Should ignore that case as well.\n\n\n        // ignore to parse the string by a fallback.\n\n\n    // Optionator cannot parse commaless notations.\n    // But we are supporting that. So this is a fallback for that.\n\n\n/**\n * Parses a config of values separated by comma.\n * @param {string} string The string to parse.\n * @returns {Object} Result map of values and true values\n */\n\n\n    // Collapse whitespace around ,\n\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} config The existing configuration data.\n * @param {Environments} envContext Env context\n * @returns {void}\n */\n\n\n        exportedGlobals = {},\n\n\n    // mark all exported variables as such\n\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type The type of directive comment\n * @param {{line: number, column: number}} loc The 0-based location of the comment token\n * @param {string} value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @returns {{\n *     type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *     line: number,\n *     column: number,\n *     ruleId: (string|null)\n * }[]} Directives from the comment\n */\n\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {Object} config The existing configuration data.\n * @param {Linter} linterContext Linter context object\n * @returns {{\n *      config: Object,\n *      problems: Problem[],\n *      disableDirectives: {\n *          type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *          line: number,\n *          column: number,\n *          ruleId: (string|null)\n *      }[]\n * }} Modified config object, along with any problems encountered\n * while parsing config comments\n */\n\n\n        exported: {},\n\n\n                    // no default\n\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param  {number} ecmaVersion ECMAScript version from the initial config\n * @param  {boolean} isModule Whether the source type is module or not\n * @returns {number} normalized ECMAScript version\n */\n\n\n    // Need at least ES6 for modules\n\n\n    // Calculate ECMAScript edition number from official year version starting with\n    // ES2015, which corresponds with ES6 (or a difference of 2009).\n\n\n/**\n * Process initial config to make it safe to extend by file comment config\n * @param  {Object} config Initial config\n * @param  {Environments} envContext Env context\n * @returns {Object}        Processed config\n */\n\n\n    // merge in environment parserOptions\n\n\n        // can't have global return inside of modules\n\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text - A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\n\n\n/**\n * Strips Unicode BOM from a given text.\n *\n * @param {string} text - A text to strip.\n * @returns {string} The stripped text.\n */\n\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\n\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {Object} providedParserOptions Options to pass to the parser\n * @param {string} parserName The name of the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: Problem}|{success: true,ast: ASTNode, services: Object}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\n\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n\n\n        // If the message includes a leading line number, strip it:\n\n\n/**\n * Gets the scope for the current node\n * @param {ScopeManager} scopeManager The scope manager for this AST\n * @param {ASTNode} currentNode The node to get the scope of\n * @param {number} ecmaVersion The `ecmaVersion` setting that this code was parsed with\n * @returns {eslint-scope.Scope} The scope information for this node\n */\n\n\n    // if current node introduces a scope, add it to the list\n\n\n    // Ascend the current node's parents\n\n\n        // Get the innermost scope\n\n\n/**\n * Marks a variable as used in the current scope\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\n * @param {ASTNode} currentNode The node currently being traversed\n * @param {Object} parserOptions The options used to parse this text\n * @param {string} name The name of the variable that should be marked as used.\n * @returns {boolean} True if the variable was found and marked as used, false if not.\n */\n\n\n    // Special Node.js scope means we need to start one level deeper\n\n\n// methods that exist on SourceCode object\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\n\n\n    /**\n     * Configuration object for the `verify` API. A JS representation of the eslintrc files.\n     * @typedef {Object} ESLintConfig\n     * @property {Object} rules The rule configuration to verify against.\n     * @property {string} [parser] Parser to use when generatig the AST.\n     * @property {Object} [parserOptions] Options for the parsed used.\n     * @property {Object} [settings] Global settings passed to each rule.\n     * @property {Object} [env] The environment to verify in.\n     * @property {Object} [globals] Available globals to the code.\n     */\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig=true] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @param {boolean} [filenameOrOptions.reportUnusedDisableDirectives=false] Adds reported errors for unused\n     *      eslint-disable directives\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n\n\n        // evaluate arguments\n\n\n        // search and apply \"eslint-env *\".\n\n\n        // process initial config to make it safe to extend\n\n\n            // there's no input, just exit here\n\n\n        // parse global comments and modify config\n\n\n        /*\n         * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n         * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n         * properties once for each rule.\n         */\n\n\n                    /**\n                     * This is used to avoid breaking rules that used to monkeypatch the `Linter#report` method\n                     * by using the `_linter` property on rule contexts.\n                     *\n                     * This should be removed in a major release after we create a better way to\n                     * lint for unused disable comments.\n                     * https://github.com/eslint/eslint/issues/9193\n                     */\n\n\n        // enable appropriate rules\n\n\n                            /*\n                             * Create a report translator lazily.\n                             * In a vast majority of cases, any given rule reports zero errors on a given\n                             * piece of code. Creating a translator lazily avoids the performance cost of\n                             * creating a new translator function for each rule that usually doesn't get\n                             * called.\n                             *\n                             * Using lazy report translators improves end-to-end performance by about 3%\n                             * with Node 8.4.0.\n                             */\n\n\n                            /*\n                             * This is used to avoid breaking rules that used monkeypatch Linter, and relied on\n                             * `linter.report` getting called with report info every time a rule reports a problem.\n                             * To continue to support this, make sure that `context._linter.report` is called every\n                             * time a problem is reported by a rule, even though `context._linter` is no longer a\n                             * `Linter` instance.\n                             *\n                             * This should be removed in a major release after we create a better way to\n                             * lint for unused disable comments.\n                             * https://github.com/eslint/eslint/issues/9193\n                             */\n\n\n                // add all the selectors from the rule as listeners\n\n\n        // augment global scope with declared global variables\n\n\n        /*\n         * Each node has a type property. Whenever a particular type of\n         * node is found, an event is fired. This allows any listeners to\n         * automatically be informed that this type of node has been found\n         * and react accordingly.\n         */\n\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.\n     *      Mostly useful for testing purposes.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @param {function(string): string[]} [filenameOrOptions.preprocess] preprocessor for source text. If provided,\n     *      this should accept a string of source text, and return an array of code blocks to lint.\n     * @param {function(Array<Object[]>): Object[]} [filenameOrOptions.postprocess] postprocessor for report messages. If provided,\n     *      this should accept an array of the message lists for each code block returned from the preprocessor,\n     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n\n\n    /**\n     * Defines many new linting rules.\n     * @param {Object} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map} All loaded rules\n     */\n\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {Object} config The ESLint config object to use.\n     * @param {Object} options The ESLint options object to use.\n     * @param {string} options.filename The filename from which the text was read.\n     * @param {boolean} options.allowInlineConfig Flag indicating if inline comments\n     *      should be allowed.\n     * @param {boolean|Function} options.fix Determines whether fixes should be applied\n     * @param {Function} options.preprocess preprocessor for source text. If provided, this should\n     *      accept a string of source text, and return an array of code blocks to lint.\n     * @param {Function} options.postprocess postprocessor for report messages. If provided,\n     *      this should accept an array of the message lists for each code block returned from the preprocessor,\n     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages\n     * @returns {Object} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n\n\n            // stop if there are any syntax errors.\n            // 'fixedResult.output' is a empty string.\n\n\n            // keep track if any fixes were ever applied - important for return value\n\n\n            // update to use the fixed output instead of the original text\n\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n\n\n        // ensure the last result properly reflects if fixes were done\n\n\n"
    },
    "3": {
        "bug_file": "lib/report-translator.js",
        "compressed": "NO",
        "line_numbers": 274,
        "compressed_line_numbers": 274,
        "compressed_bug_file_content": "/**\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\n * @author Teddy Katz\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\nconst ruleFixer = require(\"./util/rule-fixer\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * An error message description\n * @typedef {Object} MessageDescriptor\n * @property {ASTNode} [node] The reported node\n * @property {Location} loc The location of the problem.\n * @property {string} message The problem message.\n * @property {Object} [data] Optional data to use to fill in placeholders in the\n *      message.\n * @property {Function} [fix] The function to call that creates a fix command.\n */\n\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n\n/**\n * Translates a multi-argument context.report() call into a single object argument call\n * @param {...*} arguments A list of arguments passed to `context.report`\n * @returns {MessageDescriptor} A normalized object containing report information\n */\nfunction normalizeMultiArgReportCall() {\n\n    // If there is one argument, it is considered to be a new-style call already.\n    if (arguments.length === 1) {\n        return arguments[0];\n    }\n\n    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n    if (typeof arguments[1] === \"string\") {\n        return {\n            node: arguments[0],\n            message: arguments[1],\n            data: arguments[2],\n            fix: arguments[3]\n        };\n    }\n\n    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n    return {\n        node: arguments[0],\n        loc: arguments[1],\n        message: arguments[2],\n        data: arguments[3],\n        fix: arguments[4]\n    };\n}\n\n/**\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\n * @param {MessageDescriptor} descriptor A descriptor to validate\n * @returns {void}\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\n */\nfunction assertValidNodeInfo(descriptor) {\n    if (descriptor.node) {\n        assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n    } else {\n        assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n    }\n}\n\n/**\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\n */\nfunction normalizeReportLoc(descriptor) {\n    if (descriptor.loc) {\n        if (descriptor.loc.start) {\n            return descriptor.loc;\n        }\n        return { start: descriptor.loc, end: null };\n    }\n    return descriptor.node.loc;\n}\n\n/**\n * Interpolates data placeholders in report messages\n * @param {MessageDescriptor} descriptor The report message descriptor.\n * @returns {string} The interpolated message for the descriptor\n */\nfunction normalizeMessagePlaceholders(descriptor) {\n    if (!descriptor.data) {\n        return descriptor.message;\n    }\n    return descriptor.message.replace(/\\{\\{\\s*([^{}]+?)\\s*\\}\\}/g, (fullMatch, term) => {\n        if (term in descriptor.data) {\n            return descriptor.data[term];\n        }\n\n        return fullMatch;\n    });\n}\n\n/**\n * Compares items in a fixes array by range.\n * @param {Fix} a The first message.\n * @param {Fix} b The second message.\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\n * @private\n */\nfunction compareFixesByRange(a, b) {\n    return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n\n/**\n * Merges the given fixes array into one.\n * @param {Fix[]} fixes The fixes to merge.\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\n * @returns {{text: string, range: [number, number]}} The merged fixes\n */\nfunction mergeFixes(fixes, sourceCode) {\n    if (fixes.length === 0) {\n        return null;\n    }\n    if (fixes.length === 1) {\n        return fixes[0];\n    }\n\n    fixes.sort(compareFixesByRange);\n\n    const originalText = sourceCode.text;\n    const start = fixes[0].range[0];\n    const end = fixes[fixes.length - 1].range[1];\n    let text = \"\";\n    let lastPos = Number.MIN_SAFE_INTEGER;\n\n    for (const fix of fixes) {\n        assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n        if (fix.range[0] >= 0) {\n            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n        }\n        text += fix.text;\n        lastPos = fix.range[1];\n    }\n    text += originalText.slice(Math.max(0, start, lastPos), end);\n\n    return { range: [start, end], text };\n}\n\n/**\n * Gets one fix object from the given descriptor.\n * If the descriptor retrieves multiple fixes, this merges those to one.\n * @param {MessageDescriptor} descriptor The report descriptor.\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\n * @returns {({text: string, range: [number, number]}|null)} The fix for the descriptor\n */\nfunction normalizeFixes(descriptor, sourceCode) {\n    if (typeof descriptor.fix !== \"function\") {\n        return null;\n    }\n\n    // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n    const fix = descriptor.fix(ruleFixer);\n\n    // Merge to one.\n    if (fix && Symbol.iterator in fix) {\n        return mergeFixes(Array.from(fix), sourceCode);\n    }\n    return fix;\n}\n\n/**\n * Creates information about the report from a descriptor\n * @param {{\n *     ruleId: string,\n *     severity: (0|1|2),\n *     node: (ASTNode|null),\n *     message: string,\n *     loc: {start: SourceLocation, end: (SourceLocation|null)},\n *     fix: ({text: string, range: [number, number]}|null),\n *     sourceLines: string[]\n * }} options Information about the problem\n * @returns {function(...args): {\n *      ruleId: string,\n *      severity: (0|1|2),\n *      message: string,\n *      line: number,\n *      column: number,\n *      endLine: (number|undefined),\n *      endColumn: (number|undefined),\n *      nodeType: (string|null),\n *      source: string,\n *      fix: ({text: string, range: [number, number]}|null)\n * }} Information about the report\n */\nfunction createProblem(options) {\n    const problem = {\n        ruleId: options.ruleId,\n        severity: options.severity,\n        message: options.message,\n        line: options.loc.start.line,\n        column: options.loc.start.column + 1,\n        nodeType: options.node && options.node.type || null,\n        source: options.sourceLines[options.loc.start.line - 1] || \"\"\n    };\n\n    if (options.loc.end) {\n        problem.endLine = options.loc.end.line;\n        problem.endColumn = options.loc.end.column + 1;\n    }\n\n    if (options.fix) {\n        problem.fix = options.fix;\n    }\n\n    return problem;\n}\n\n/**\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\n * problem for the Node.js API.\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode}} metadata Metadata for the reported problem\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\n * @returns {function(...args): {\n *      ruleId: string,\n *      severity: (0|1|2),\n *      message: string,\n *      line: number,\n *      column: number,\n *      endLine: (number|undefined),\n *      endColumn: (number|undefined),\n *      nodeType: (string|null),\n *      source: string,\n *      fix: ({text: string, range: [number, number]}|null)\n * }}\n * Information about the report\n */\n\nmodule.exports = function createReportTranslator(metadata) {\n\n    /*\n     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\n     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\n     * called every time a rule reports a problem, which happens much less frequently (usually, the vast\n     * majority of rules don't report any problems for a given file).\n     */\n    return function() {\n        const descriptor = normalizeMultiArgReportCall.apply(null, arguments);\n\n        assertValidNodeInfo(descriptor);\n\n        return createProblem({\n            ruleId: metadata.ruleId,\n            severity: metadata.severity,\n            node: descriptor.node,\n            message: normalizeMessagePlaceholders(descriptor),\n            loc: normalizeReportLoc(descriptor),\n            fix: normalizeFixes(descriptor, metadata.sourceCode),\n            sourceLines: metadata.sourceCode.lines\n        });\n    };\n};"
    }
}