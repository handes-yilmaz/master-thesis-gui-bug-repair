{
    "1": {
        "bug_file": "lib/cli-engine/cli-engine.js",
        "compressed": "YES",
        "line_numbers": 1059,
        "compressed_line_numbers": 475,
        "compressed_bug_file_content": "/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {ReturnType<CascadingConfigArrayFactory.getConfigArrayForFile>} ConfigArray */\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this CLIEngine instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {string} [configFile] The configuration file to use.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {string[]} [envs] An array of environments to load.\n * @property {string[]|null} [extensions] An array of file extensions to check.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {string[]} [globals] An array of global variables to declare.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {string|string[]} [ignorePattern] One or more glob patterns to ignore.\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc\n * @property {string} [parser] The name of the parser to use.\n * @property {ParserOptions} [parserOptions] An object of parserOption settings to use.\n * @property {string[]} [plugins] An array of plugins to load.\n * @property {Record<string,RuleConf>} [rules] An object of rules to use.\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\n * @property {boolean} [reportUnusedDisableDirectives] `true` adds reports for unused eslint-disable directives\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string} [source] The source code of the file that was linted.\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n/**\n * Linting results.\n * @typedef {Object} LintReport\n * @property {LintResult[]} results All of the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\n */\n\n/**\n * Private data for CLIEngine.\n * @typedef {Object} CLIEngineInternalSlots\n * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cacheFilePath The path to the cache of lint results.\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.\n * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.\n * @property {FileEnumerator} fileEnumerator The file enumerator.\n * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\n * @property {LintResultCache|null} lintResultCache The cache of lint results.\n * @property {Linter} linter The linter instance which has loaded rules.\n * @property {CLIEngineOptions} options The normalized options of this instance.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */\n\n\n/**\n * Determines if each fix type in an array is supported by ESLint and throws\n * an error if not.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {void}\n * @throws {Error} If an invalid fix type is found.\n */\n\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\n\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {LintResult[]} results Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\n\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {ConfigArray} config.config The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.\n * @param {FileEnumerator} config.fileEnumerator The file enumerator to check if a path is a target or not.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\n\n\n    /*\n     * Verify.\n     * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n     * doesn't know CWD, so it gives `linter` an absolute path always.\n     */\n\n\n            /**\n             * Check if the linter should adopt a given code block or not.\n             * @param {string} blockFilename The virtual filename of a code block.\n             * @returns {boolean} `true` if the linter should adopt the code block.\n             */\n\n\n    // Tweak and return.\n\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath File path of checked code\n * @param {string} baseDir Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\n\n\n/**\n * Get a rule.\n * @param {string} ruleId The rule ID to get.\n * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.\n * @returns {Rule|null} The rule or null.\n */\n\n\n/**\n * Checks whether a message's rule type should be fixed.\n * @param {LintMessage} message The message to check.\n * @param {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {boolean} Whether the message should be fixed.\n */\n\n\n/**\n * Collect used deprecated rules.\n * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\n */\n\n\n    // Flatten used configs.\n    /** @type {ExtractedConfig[]} */\n\n\n    // Traverse rule configs.\n\n\n            // Skip if it was processed.\n\n\n            // Skip if it's not used.\n\n\n            // Skip if it's not deprecated.\n\n\n            // This rule was used and deprecated.\n\n\n/**\n * Checks if the given message is an error message.\n * @param {LintMessage} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\n\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n\n\n        // is file so just use that file\n\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n\n\n/**\n * Convert a string array to a boolean map.\n * @param {string[]|null} keys The keys to assign true.\n * @param {boolean} defaultValue The default value for each property.\n * @param {string} displayName The property name which is used in error message.\n * @throws {Error} Requires array.\n * @returns {Record<string,boolean>} The boolean map.\n */\n\n\n/**\n * Create a config data from CLI options.\n * @param {CLIEngineOptions} options The options\n * @returns {ConfigData|null} The created config data.\n */\n\n\n/**\n * Checks whether a directory exists at the given location\n * @param {string} resolvedPath A path from the CWD\n * @throws {Error} As thrown by `fs.statSync` or `fs.isDirectory`.\n * @returns {boolean} `true` if a directory exists\n */\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Core CLI.\n */\n\n\n    /**\n     * Creates a new instance of the core CLI engine.\n     * @param {CLIEngineOptions} providedOptions The options for this instance.\n     * @param {Object} [additionalData] Additional settings that are not CLIEngineOptions.\n     * @param {Record<string,Plugin>|null} [additionalData.preloadedPlugins] Preloaded plugins.\n     */\n\n\n        /** @type {ConfigArray[]} */\n\n\n        // Store private data.\n\n\n        // setup special filter for fixes\n\n\n            // throw an error if any invalid fix types are found\n\n\n            // convert to Set for faster lookup\n\n\n            // save original value of options.fix in case it's a function\n\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintReport} report The report object created by CLIEngine.\n     * @returns {void}\n     */\n\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @throws {Error} As may be thrown by `fs.unlinkSync`.\n     * @returns {LintReport} The results for all files that were linted.\n     */\n\n\n        // Clear the last used config arrays.\n\n\n        // Delete cache file; should this do here?\n\n\n                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n\n\n        // Iterate source code files.\n\n\n            /*\n             * Store used configs for:\n             * - this method uses to collect used deprecated rules.\n             * - `getRules()` method uses to collect all loaded rules.\n             * - `--fix-type` option uses to get the loaded rule's meta data.\n             */\n\n\n            // Skip if there is cached result.\n\n\n            // Do lint.\n\n\n            /*\n             * Store the lint result in the LintResultCache.\n             * NOTE: The LintResultCache will remove the file source and any\n             * other properties that are difficult to serialize, and will\n             * hydrate those properties back in on future lint runs.\n             */\n\n\n        // Persist the cache to disk.\n\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} [filename] An optional string representing the texts filename.\n     * @param {boolean} [warnIgnored] Always warn when a file is ignored\n     * @returns {LintReport} The results for the linting.\n     */\n\n\n        // Clear the last used config arrays.\n\n\n            /*\n             * Store used configs for:\n             * - this method uses to collect used deprecated rules.\n             * - `getRules()` method uses to collect all loaded rules.\n             * - `--fix-type` option uses to get the loaded rule's meta data.\n             */\n\n\n            // Do lint.\n\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @throws {Error} If filepath a directory path.\n     * @returns {ConfigData} A configuration object for the file.\n     */\n\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n\n\n    /**\n     * Returns the formatter representing the given format or null if the `format` is not a string.\n     * @param {string} [format] The name of the format to load or the path to a\n     *      custom formatter.\n     * @throws {any} As may be thrown by requiring of formatter\n     * @returns {(Function|null)} The formatter function or null if the `format` is not a string.\n     */\n\n\n        // default is stylish\n\n\n        // only strings are valid formatters\n\n\n            // replace \\ with / for Windows compatibility\n\n\n            // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n\n\n    /**\n     * Get the internal slots of a given CLIEngine instance for tests.\n     * @param {CLIEngine} instance The CLIEngine instance to get.\n     * @returns {CLIEngineInternalSlots} The internal slots.\n     */\n\n\n"
    },
    "2": {
        "bug_file": "lib/cli-engine/formatters/checkstyle.js",
        "compressed": "NO",
        "line_numbers": 60,
        "compressed_line_numbers": 60,
        "compressed_bug_file_content": "/**\n * @fileoverview CheckStyle XML reporter\n * @author Ian Christian Myers\n */\n\"use strict\";\n\nconst xmlEscape = require(\"../xml-escape\");\n\n//------------------------------------------------------------------------------\n// Helper Functions\n//------------------------------------------------------------------------------\n\n/**\n * Returns the severity of warning or error\n * @param {Object} message message object to examine\n * @returns {string} severity level\n * @private\n */\nfunction getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n        return \"error\";\n    }\n    return \"warning\";\n\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\";\n\n    output += \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\";\n    output += \"<checkstyle version=\\\"4.3\\\">\";\n\n    results.forEach(result => {\n        const messages = result.messages;\n\n        output += `<file name=\"${xmlEscape(result.filePath)}\">`;\n\n        messages.forEach(message => {\n            output += [\n                `<error line=\"${xmlEscape(message.line || 0)}\"`,\n                `column=\"${xmlEscape(message.column || 0)}\"`,\n                `severity=\"${xmlEscape(getMessageType(message))}\"`,\n                `message=\"${xmlEscape(message.message)}${message.ruleId ? ` (${message.ruleId})` : \"\"}\"`,\n                `source=\"${message.ruleId ? xmlEscape(`eslint.rules.${message.ruleId}`) : \"\"}\" />`\n            ].join(\" \");\n        });\n\n        output += \"</file>\";\n\n    });\n\n    output += \"</checkstyle>\";\n\n    return output;\n};"
    },
    "3": {
        "bug_file": "lib/cli-engine/formatters/compact.js",
        "compressed": "NO",
        "line_numbers": 60,
        "compressed_line_numbers": 60,
        "compressed_bug_file_content": "/**\n * @fileoverview Compact reporter\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helper Functions\n//------------------------------------------------------------------------------\n\n/**\n * Returns the severity of warning or error\n * @param {Object} message message object to examine\n * @returns {string} severity level\n * @private\n */\nfunction getMessageType(message) {\n    if (message.fatal || message.severity === 2) {\n        return \"Error\";\n    }\n    return \"Warning\";\n\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results) {\n\n    let output = \"\",\n        total = 0;\n\n    results.forEach(result => {\n\n        const messages = result.messages;\n\n        total += messages.length;\n\n        messages.forEach(message => {\n\n            output += `${result.filePath}: `;\n            output += `line ${message.line || 0}`;\n            output += `, col ${message.column || 0}`;\n            output += `, ${getMessageType(message)}`;\n            output += ` - ${message.message}`;\n            output += message.ruleId ? ` (${message.ruleId})` : \"\";\n            output += \"\\n\";\n\n        });\n\n    });\n\n    if (total > 0) {\n        output += `\\n${total} problem${total !== 1 ? \"s\" : \"\"}`;\n    }\n\n    return output;\n};"
    },
    "4": {
        "bug_file": "lib/cli-engine/formatters/html.js",
        "compressed": "NO",
        "line_numbers": 324,
        "compressed_line_numbers": 324,
        "compressed_bug_file_content": "/**\n * @fileoverview HTML reporter\n * @author Julian Laval\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst encodeHTML = (function() {\n    const encodeHTMLRules = {\n        \"&\": \"&#38;\",\n        \"<\": \"&#60;\",\n        \">\": \"&#62;\",\n        '\"': \"&#34;\",\n        \"'\": \"&#39;\"\n    };\n    const matchHTML = /[&<>\"']/ug;\n\n    return function(code) {\n        return code\n            ? code.toString().replace(matchHTML, m => encodeHTMLRules[m] || m)\n            : \"\";\n    };\n}());\n\n/**\n * Get the final HTML document.\n * @param {Object} it data for the document.\n * @returns {string} HTML document.\n */\nfunction pageTemplate(it) {\n    const { reportColor, reportSummary, date, results } = it;\n\n    return `\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>ESLint Report</title>\n        <style>\n            body {\n                font-family:Arial, \"Helvetica Neue\", Helvetica, sans-serif;\n                font-size:16px;\n                font-weight:normal;\n                margin:0;\n                padding:0;\n                color:#333\n            }\n            #overview {\n                padding:20px 30px\n            }\n            td, th {\n                padding:5px 10px\n            }\n            h1 {\n                margin:0\n            }\n            table {\n                margin:30px;\n                width:calc(100% - 60px);\n                max-width:1000px;\n                border-radius:5px;\n                border:1px solid #ddd;\n                border-spacing:0px;\n            }\n            th {\n                font-weight:400;\n                font-size:medium;\n                text-align:left;\n                cursor:pointer\n            }\n            td.clr-1, td.clr-2, th span {\n                font-weight:700\n            }\n            th span {\n                float:right;\n                margin-left:20px\n            }\n            th span:after {\n                content:\"\";\n                clear:both;\n                display:block\n            }\n            tr:last-child td {\n                border-bottom:none\n            }\n            tr td:first-child, tr td:last-child {\n                color:#9da0a4\n            }\n            #overview.bg-0, tr.bg-0 th {\n                color:#468847;\n                background:#dff0d8;\n                border-bottom:1px solid #d6e9c6\n            }\n            #overview.bg-1, tr.bg-1 th {\n                color:#f0ad4e;\n                background:#fcf8e3;\n                border-bottom:1px solid #fbeed5\n            }\n            #overview.bg-2, tr.bg-2 th {\n                color:#b94a48;\n                background:#f2dede;\n                border-bottom:1px solid #eed3d7\n            }\n            td {\n                border-bottom:1px solid #ddd\n            }\n            td.clr-1 {\n                color:#f0ad4e\n            }\n            td.clr-2 {\n                color:#b94a48\n            }\n            td a {\n                color:#3a33d1;\n                text-decoration:none\n            }\n            td a:hover {\n                color:#272296;\n                text-decoration:underline\n            }\n        </style>\n    </head>\n    <body>\n        <div id=\"overview\" class=\"bg-${reportColor}\">\n            <h1>ESLint Report</h1>\n            <div>\n                <span>${reportSummary}</span> - Generated on ${date}\n            </div>\n        </div>\n        <table>\n            <tbody>\n                ${results}\n            </tbody>\n        </table>\n        <script type=\"text/javascript\">\n            var groups = document.querySelectorAll(\"tr[data-group]\");\n            for (i = 0; i < groups.length; i++) {\n                groups[i].addEventListener(\"click\", function() {\n                    var inGroup = document.getElementsByClassName(this.getAttribute(\"data-group\"));\n                    this.innerHTML = (this.innerHTML.indexOf(\"+\") > -1) ? this.innerHTML.replace(\"+\", \"-\") : this.innerHTML.replace(\"-\", \"+\");\n                    for (var j = 0; j < inGroup.length; j++) {\n                        inGroup[j].style.display = (inGroup[j].style.display !== \"none\") ? \"none\" : \"table-row\";\n                    }\n                });\n            }\n        </script>\n    </body>\n</html>\n`.trimLeft();\n}\n\n/**\n * Given a word and a count, append an s if count is not one.\n * @param {string} word A word in its singular form.\n * @param {int} count A number controlling whether word should be pluralized.\n * @returns {string} The original word with an s on the end if count is not one.\n */\nfunction pluralize(word, count) {\n    return (count === 1 ? word : `${word}s`);\n}\n\n/**\n * Renders text along the template of x problems (x errors, x warnings)\n * @param {string} totalErrors Total errors\n * @param {string} totalWarnings Total warnings\n * @returns {string} The formatted string, pluralized where necessary\n */\nfunction renderSummary(totalErrors, totalWarnings) {\n    const totalProblems = totalErrors + totalWarnings;\n    let renderedText = `${totalProblems} ${pluralize(\"problem\", totalProblems)}`;\n\n    if (totalProblems !== 0) {\n        renderedText += ` (${totalErrors} ${pluralize(\"error\", totalErrors)}, ${totalWarnings} ${pluralize(\"warning\", totalWarnings)})`;\n    }\n    return renderedText;\n}\n\n/**\n * Get the color based on whether there are errors/warnings...\n * @param {string} totalErrors Total errors\n * @param {string} totalWarnings Total warnings\n * @returns {int} The color code (0 = green, 1 = yellow, 2 = red)\n */\nfunction renderColor(totalErrors, totalWarnings) {\n    if (totalErrors !== 0) {\n        return 2;\n    }\n    if (totalWarnings !== 0) {\n        return 1;\n    }\n    return 0;\n}\n\n/**\n * Get HTML (table row) describing a single message.\n * @param {Object} it data for the message.\n * @returns {string} HTML (table row) describing the message.\n */\nfunction messageTemplate(it) {\n    const {\n        parentIndex,\n        lineNumber,\n        columnNumber,\n        severityNumber,\n        severityName,\n        message,\n        ruleUrl,\n        ruleId\n    } = it;\n\n    return `\n<tr style=\"display:none\" class=\"f-${parentIndex}\">\n    <td>${lineNumber}:${columnNumber}</td>\n    <td class=\"clr-${severityNumber}\">${severityName}</td>\n    <td>${encodeHTML(message)}</td>\n    <td>\n        <a href=\"${ruleUrl ? ruleUrl : \"\"}\" target=\"_blank\" rel=\"noopener noreferrer\">${ruleId ? ruleId : \"\"}</a>\n    </td>\n</tr>\n`.trimLeft();\n}\n\n/**\n * Get HTML (table rows) describing the messages.\n * @param {Array} messages Messages.\n * @param {int} parentIndex Index of the parent HTML row.\n * @param {Object} rulesMeta Dictionary containing metadata for each rule executed by the analysis.\n * @returns {string} HTML (table rows) describing the messages.\n */\nfunction renderMessages(messages, parentIndex, rulesMeta) {\n\n    /**\n     * Get HTML (table row) describing a message.\n     * @param {Object} message Message.\n     * @returns {string} HTML (table row) describing a message.\n     */\n    return messages.map(message => {\n        const lineNumber = message.line || 0;\n        const columnNumber = message.column || 0;\n        let ruleUrl;\n\n        if (rulesMeta) {\n            const meta = rulesMeta[message.ruleId];\n\n            if (meta && meta.docs && meta.docs.url) {\n                ruleUrl = meta.docs.url;\n            }\n        }\n\n        return messageTemplate({\n            parentIndex,\n            lineNumber,\n            columnNumber,\n            severityNumber: message.severity,\n            severityName: message.severity === 1 ? \"Warning\" : \"Error\",\n            message: message.message,\n            ruleId: message.ruleId,\n            ruleUrl\n        });\n    }).join(\"\\n\");\n}\n\n/**\n * Get HTML (table row) describing the result for a single file.\n * @param {Object} it data for the file.\n * @returns {string} HTML (table row) describing the result for the file.\n */\nfunction resultTemplate(it) {\n    const { color, index, filePath, summary } = it;\n\n    return `\n<tr class=\"bg-${color}\" data-group=\"f-${index}\">\n    <th colspan=\"4\">\n        [+] ${encodeHTML(filePath)}\n        <span>${encodeHTML(summary)}</span>\n    </th>\n</tr>\n`.trimLeft();\n}\n\n/**\n * Render the results.\n * @param {Array} results Test results.\n * @param {Object} rulesMeta Dictionary containing metadata for each rule executed by the analysis.\n * @returns {string} HTML string describing the results.\n */\nfunction renderResults(results, rulesMeta) {\n    return results.map((result, index) => resultTemplate({\n        index,\n        color: renderColor(result.errorCount, result.warningCount),\n        filePath: result.filePath,\n        summary: renderSummary(result.errorCount, result.warningCount)\n    }) + renderMessages(result.messages, index, rulesMeta)).join(\"\\n\");\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = function(results, data) {\n    let totalErrors,\n        totalWarnings;\n\n    const metaData = data ? data.rulesMeta : {};\n\n    totalErrors = 0;\n    totalWarnings = 0;\n\n    // Iterate over results to get totals\n    results.forEach(result => {\n        totalErrors += result.errorCount;\n        totalWarnings += result.warningCount;\n    });\n\n    return pageTemplate({\n        date: new Date(),\n        reportColor: renderColor(totalErrors, totalWarnings),\n        reportSummary: renderSummary(totalErrors, totalWarnings),\n        results: renderResults(results, metaData)\n    });\n};"
    }
}