{
    "1": {
        "bug_file": "lib/rules/constructor-super.js",
        "compressed": "NO",
        "line_numbers": 385,
        "compressed_line_numbers": 385,
        "compressed_bug_file_content": "/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n *\n * @param {CodePathSegment} segment - A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            return isPossibleConstructor(node.right);\n\n        case \"LogicalExpression\":\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        message: calledInSomePaths\n                            ? \"Lacked a call of 'super()' in some code paths.\"\n                            : \"Expected to call 'super()'.\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    message: \"Unexpected duplicate 'super()'.\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node - A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                message: \"Unexpected duplicate 'super()'.\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                message: \"Unexpected 'super()' because 'super' is not a constructor.\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        message: \"Unexpected 'super()'.\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node - A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};"
    },
    "2": {
        "bug_file": "lib/linter.js",
        "compressed": "YES",
        "line_numbers": 1115,
        "compressed_line_numbers": 471,
        "compressed_bug_file_content": "/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The result of a parsing operation from parseForESLint()\n * @typedef {Object} CustomParseResult\n * @property {ASTNode} ast The ESTree AST Program node.\n * @property {Object} services An object containing additional services related\n *      to the parser.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Parses a list of \"name:boolean_value\" or/and \"name\" options divided by comma or\n * whitespace.\n * @param {string} string The string to parse.\n * @param {Comment} comment The comment node which has the string.\n * @returns {Object} Result map object of names and boolean values\n */\n\n\n    // Collapse whitespace around `:` and `,` to make parsing easier\n\n\n/**\n * Parses a JSON-like config.\n * @param {string} string The string to parse.\n * @param {Object} location Start line and column of comments for potential error message.\n * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n */\n\n\n    // Parses a JSON-like comment by the same way as parsing CLI option.\n\n\n        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n        // Also, commaless notations have invalid severity:\n        //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n        // Should ignore that case as well.\n\n\n        // ignore to parse the string by a fallback.\n\n\n    // Optionator cannot parse commaless notations.\n    // But we are supporting that. So this is a fallback for that.\n\n\n/**\n * Parses a config of values separated by comma.\n * @param {string} string The string to parse.\n * @returns {Object} Result map of values and true values\n */\n\n\n    // Collapse whitespace around ,\n\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} config The existing configuration data.\n * @param {Environments} envContext Env context\n * @returns {void}\n */\n\n\n        exportedGlobals = {},\n\n\n    // mark all exported variables as such\n\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type The type of directive comment\n * @param {{line: number, column: number}} loc The 0-based location of the comment token\n * @param {string} value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @returns {{\n *     type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *     line: number,\n *     column: number,\n *     ruleId: (string|null)\n * }[]} Directives from the comment\n */\n\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {Object} config The existing configuration data.\n * @param {Linter} linterContext Linter context object\n * @returns {{\n *      config: Object,\n *      problems: Problem[],\n *      disableDirectives: {\n *          type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *          line: number,\n *          column: number,\n *          ruleId: (string|null)\n *      }[]\n * }} Modified config object, along with any problems encountered\n * while parsing config comments\n */\n\n\n        exported: {},\n\n\n                    // no default\n\n\n    // apply environment configs\n\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param  {number} ecmaVersion ECMAScript version from the initial config\n * @param  {boolean} isModule Whether the source type is module or not\n * @returns {number} normalized ECMAScript version\n */\n\n\n    // Need at least ES6 for modules\n\n\n    // Calculate ECMAScript edition number from official year version starting with\n    // ES2015, which corresponds with ES6 (or a difference of 2009).\n\n\n/**\n * Process initial config to make it safe to extend by file comment config\n * @param  {Object} config Initial config\n * @param  {Environments} envContext Env context\n * @returns {Object}        Processed config\n */\n\n\n    // merge in environment parserOptions\n\n\n        // can't have global return inside of modules\n\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text - A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\n\n\n/**\n * Strips Unicode BOM from a given text.\n *\n * @param {string} text - A text to strip.\n * @returns {string} The stripped text.\n */\n\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\n\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {Object} providedParserOptions Options to pass to the parser\n * @param {string} parserName The name of the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: Problem}|{success: true,ast: ASTNode, services: Object}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\n\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n\n\n        // If the message includes a leading line number, strip it:\n\n\n/**\n * Gets the scope for the current node\n * @param {ScopeManager} scopeManager The scope manager for this AST\n * @param {ASTNode} currentNode The node to get the scope of\n * @param {number} ecmaVersion The `ecmaVersion` setting that this code was parsed with\n * @returns {eslint-scope.Scope} The scope information for this node\n */\n\n\n    // if current node introduces a scope, add it to the list\n\n\n    // Ascend the current node's parents\n\n\n        // Get the innermost scope\n\n\n/**\n * Marks a variable as used in the current scope\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\n * @param {ASTNode} currentNode The node currently being traversed\n * @param {Object} parserOptions The options used to parse this text\n * @param {string} name The name of the variable that should be marked as used.\n * @returns {boolean} True if the variable was found and marked as used, false if not.\n */\n\n\n    // Special Node.js scope means we need to start one level deeper\n\n\n// methods that exist on SourceCode object\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\n\n\n    /**\n     * Configuration object for the `verify` API. A JS representation of the eslintrc files.\n     * @typedef {Object} ESLintConfig\n     * @property {Object} rules The rule configuration to verify against.\n     * @property {string} [parser] Parser to use when generatig the AST.\n     * @property {Object} [parserOptions] Options for the parsed used.\n     * @property {Object} [settings] Global settings passed to each rule.\n     * @property {Object} [env] The environment to verify in.\n     * @property {Object} [globals] Available globals to the code.\n     */\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n\n\n        // evaluate arguments\n\n\n        // search and apply \"eslint-env *\".\n\n\n        // process initial config to make it safe to extend\n\n\n            // there's no input, just exit here\n\n\n        // parse global comments and modify config\n\n\n        /*\n         * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n         * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n         * properties once for each rule.\n         */\n\n\n                    /**\n                     * This is used to avoid breaking rules that used to monkeypatch the `Linter#report` method\n                     * by using the `_linter` property on rule contexts.\n                     *\n                     * This should be removed in a major release after we create a better way to\n                     * lint for unused disable comments.\n                     * https://github.com/eslint/eslint/issues/9193\n                     */\n\n\n        // enable appropriate rules\n\n\n                            /*\n                             * Create a report translator lazily.\n                             * In a vast majority of cases, any given rule reports zero errors on a given\n                             * piece of code. Creating a translator lazily avoids the performance cost of\n                             * creating a new translator function for each rule that usually doesn't get\n                             * called.\n                             *\n                             * Using lazy report translators improves end-to-end performance by about 3%\n                             * with Node 8.4.0.\n                             */\n\n\n                            /*\n                             * This is used to avoid breaking rules that used monkeypatch Linter, and relied on\n                             * `linter.report` getting called with report info every time a rule reports a problem.\n                             * To continue to support this, make sure that `context._linter.report` is called every\n                             * time a problem is reported by a rule, even though `context._linter` is no longer a\n                             * `Linter` instance.\n                             *\n                             * This should be removed in a major release after we create a better way to\n                             * lint for unused disable comments.\n                             * https://github.com/eslint/eslint/issues/9193\n                             */\n\n\n                // add all the selectors from the rule as listeners\n\n\n        // augment global scope with declared global variables\n\n\n        /*\n         * Each node has a type property. Whenever a particular type of\n         * node is found, an event is fired. This allows any listeners to\n         * automatically be informed that this type of node has been found\n         * and react accordingly.\n         */\n\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.\n     *      Mostly useful for testing purposes.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @param {function(string): string[]} [filenameOrOptions.preprocess] preprocessor for source text. If provided,\n     *      this should accept a string of source text, and return an array of code blocks to lint.\n     * @param {function(Array<Object[]>): Object[]} [filenameOrOptions.postprocess] postprocessor for report messages. If provided,\n     *      this should accept an array of the message lists for each code block returned from the preprocessor,\n     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n\n\n    /**\n     * Defines many new linting rules.\n     * @param {Object} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map} All loaded rules\n     */\n\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {Object} config The ESLint config object to use.\n     * @param {Object} options The ESLint options object to use.\n     * @param {string} options.filename The filename from which the text was read.\n     * @param {boolean} options.allowInlineConfig Flag indicating if inline comments\n     *      should be allowed.\n     * @param {boolean|Function} options.fix Determines whether fixes should be applied\n     * @param {Function} options.preprocess preprocessor for source text. If provided, this should\n     *      accept a string of source text, and return an array of code blocks to lint.\n     * @param {Function} options.postprocess postprocessor for report messages. If provided,\n     *      this should accept an array of the message lists for each code block returned from the preprocessor,\n     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages\n     * @returns {Object} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n\n\n            // stop if there are any syntax errors.\n            // 'fixedResult.output' is a empty string.\n\n\n            // keep track if any fixes were ever applied - important for return value\n\n\n            // update to use the fixed output instead of the original text\n\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n\n\n        // ensure the last result properly reflects if fixes were done\n\n\n"
    }
}