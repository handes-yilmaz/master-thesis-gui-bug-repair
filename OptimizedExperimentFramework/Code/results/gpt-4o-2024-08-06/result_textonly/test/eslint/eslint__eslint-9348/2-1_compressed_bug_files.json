{
    "1": {
        "bug_file": "lib/rules/constructor-super.js",
        "compressed": "NO",
        "line_numbers": 385,
        "compressed_line_numbers": 385,
        "compressed_bug_file_content": "/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n *\n * @param {CodePathSegment} segment - A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            return isPossibleConstructor(node.right);\n\n        case \"LogicalExpression\":\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\": {\n            const lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n        }\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        let funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        let segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    const classNode = node.parent.parent.parent;\n                    const superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd(codePath, node) {\n                const hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                const segments = codePath.returnedSegments;\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\n                const calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        message: calledInSomePaths\n                            ? \"Lacked a call of 'super()' in some code paths.\"\n                            : \"Expected to call 'super()'.\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                const info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                const prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                const isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    { first: toSegment, last: fromSegment },\n                    segment => {\n                        const info = segInfoMap[segment.id];\n                        const prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            const nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (let i = 0; i < nodes.length; ++i) {\n                                const node = nodes[i];\n\n                                context.report({\n                                    message: \"Unexpected duplicate 'super()'.\",\n                                    node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node - A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\"(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    const segments = funcInfo.codePath.currentSegments;\n                    let duplicate = false;\n                    let info = null;\n\n                    for (let i = 0; i < segments.length; ++i) {\n                        const segment = segments[i];\n\n                        if (segment.reachable) {\n                            info = segInfoMap[segment.id];\n\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (info) {\n                        if (duplicate) {\n                            context.report({\n                                message: \"Unexpected duplicate 'super()'.\",\n                                node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                message: \"Unexpected 'super()' because 'super' is not a constructor.\",\n                                node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        message: \"Unexpected 'super()'.\",\n                        node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node - A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                const segments = funcInfo.codePath.currentSegments;\n\n                for (let i = 0; i < segments.length; ++i) {\n                    const segment = segments[i];\n\n                    if (segment.reachable) {\n                        const info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\"() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};"
    },
    "2": {
        "bug_file": "lib/linter.js",
        "compressed": "YES",
        "line_numbers": 1115,
        "compressed_line_numbers": 471,
        "compressed_bug_file_content": "/**\n * @fileoverview Main Linter Class\n * @author Gyandeep Singh\n */\n\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The result of a parsing operation from parseForESLint()\n * @typedef {Object} CustomParseResult\n * @property {ASTNode} ast The ESTree AST Program node.\n * @property {Object} services An object containing additional services related\n *      to the parser.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Parses a list of \"name:boolean_value\" or/and \"name\" options divided by comma or\n * whitespace.\n * @param {string} string The string to parse.\n * @param {Comment} comment The comment node which has the string.\n * @returns {Object} Result map object of names and boolean values\n */\n\n\n    // Collapse whitespace around `:` and `,` to make parsing easier\n\n\n/**\n * Parses a JSON-like config.\n * @param {string} string The string to parse.\n * @param {Object} location Start line and column of comments for potential error message.\n * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\n */\n\n\n    // Parses a JSON-like comment by the same way as parsing CLI option.\n\n\n        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n        // Also, commaless notations have invalid severity:\n        //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n        // Should ignore that case as well.\n\n\n        // ignore to parse the string by a fallback.\n\n\n    // Optionator cannot parse commaless notations.\n    // But we are supporting that. So this is a fallback for that.\n\n\n/**\n * Parses a config of values separated by comma.\n * @param {string} string The string to parse.\n * @returns {Object} Result map of values and true values\n */\n\n\n    // Collapse whitespace around ,\n\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {Scope} globalScope The global scope.\n * @param {Object} config The existing configuration data.\n * @param {Environments} envContext Env context\n * @returns {void}\n */\n\n\n        exportedGlobals = {},\n\n\n    // mark all exported variables as such\n\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n\n\n/**\n * Creates a collection of disable directives from a comment\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type The type of directive comment\n * @param {{line: number, column: number}} loc The 0-based location of the comment token\n * @param {string} value The value after the directive in the comment\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\n * @returns {{\n *     type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *     line: number,\n *     column: number,\n *     ruleId: (string|null)\n * }[]} Directives from the comment\n */\n\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {Object} config The existing configuration data.\n * @param {Linter} linterContext Linter context object\n * @returns {{\n *      config: Object,\n *      problems: Problem[],\n *      disableDirectives: {\n *          type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *          line: number,\n *          column: number,\n *          ruleId: (string|null)\n *      }[]\n * }} Modified config object, along with any problems encountered\n * while parsing config comments\n */\n\n\n        exported: {},\n\n\n                    // no default\n\n\n    // apply environment configs\n\n\n/**\n * Normalize ECMAScript version from the initial config\n * @param  {number} ecmaVersion ECMAScript version from the initial config\n * @param  {boolean} isModule Whether the source type is module or not\n * @returns {number} normalized ECMAScript version\n */\n\n\n    // Need at least ES6 for modules\n\n\n    // Calculate ECMAScript edition number from official year version starting with\n    // ES2015, which corresponds with ES6 (or a difference of 2009).\n\n\n/**\n * Process initial config to make it safe to extend by file comment config\n * @param  {Object} config Initial config\n * @param  {Environments} envContext Env context\n * @returns {Object}        Processed config\n */\n\n\n    // merge in environment parserOptions\n\n\n        // can't have global return inside of modules\n\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text - A source code text to check.\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\n\n\n/**\n * Strips Unicode BOM from a given text.\n *\n * @param {string} text - A text to strip.\n * @returns {string} The stripped text.\n */\n\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n\n\n/**\n * Get the options for a rule (not including severity), if any\n * @param {Array|number} ruleConfig rule configuration\n * @returns {Array} of rule options, empty Array if none\n */\n\n\n/**\n * Parses text into an AST. Moved out here because the try-catch prevents\n * optimization of functions, so it's best to keep the try-catch as isolated\n * as possible\n * @param {string} text The text to parse.\n * @param {Object} providedParserOptions Options to pass to the parser\n * @param {string} parserName The name of the parser\n * @param {string} filePath The path to the file being parsed.\n * @returns {{success: false, error: Problem}|{success: true,ast: ASTNode, services: Object}}\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\n * @private\n */\n\n\n    /*\n     * Check for parsing errors first. If there's a parsing error, nothing\n     * else can happen. However, a parsing error does not throw an error\n     * from this method - it's just considered a fatal error message, a\n     * problem that ESLint identified just like any other.\n     */\n\n\n        // If the message includes a leading line number, strip it:\n\n\n/**\n * Gets the scope for the current node\n * @param {ScopeManager} scopeManager The scope manager for this AST\n * @param {ASTNode} currentNode The node to get the scope of\n * @param {number} ecmaVersion The `ecmaVersion` setting that this code was parsed with\n * @returns {eslint-scope.Scope} The scope information for this node\n */\n\n\n    // if current node introduces a scope, add it to the list\n\n\n    // Ascend the current node's parents\n\n\n        // Get the innermost scope\n\n\n/**\n * Marks a variable as used in the current scope\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\n * @param {ASTNode} currentNode The node currently being traversed\n * @param {Object} parserOptions The options used to parse this text\n * @param {string} name The name of the variable that should be marked as used.\n * @returns {boolean} True if the variable was found and marked as used, false if not.\n */\n\n\n    // Special Node.js scope means we need to start one level deeper\n\n\n// methods that exist on SourceCode object\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\n\n\n    /**\n     * Configuration object for the `verify` API. A JS representation of the eslintrc files.\n     * @typedef {Object} ESLintConfig\n     * @property {Object} rules The rule configuration to verify against.\n     * @property {string} [parser] Parser to use when generatig the AST.\n     * @property {Object} [parserOptions] Options for the parsed used.\n     * @property {Object} [settings] Global settings passed to each rule.\n     * @property {Object} [env] The environment to verify in.\n     * @property {Object} [globals] Available globals to the code.\n     */\n\n    /**\n     * Same as linter.verify, except without support for processors.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n\n\n        // evaluate arguments\n\n\n        // search and apply \"eslint-env *\".\n\n\n        // process initial config to make it safe to extend\n\n\n            // there's no input, just exit here\n\n\n        // parse global comments and modify config\n\n\n        /*\n         * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\n         * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\n         * properties once for each rule.\n         */\n\n\n                    /**\n                     * This is used to avoid breaking rules that used to monkeypatch the `Linter#report` method\n                     * by using the `_linter` property on rule contexts.\n                     *\n                     * This should be removed in a major release after we create a better way to\n                     * lint for unused disable comments.\n                     * https://github.com/eslint/eslint/issues/9193\n                     */\n\n\n        // enable appropriate rules\n\n\n                            /*\n                             * Create a report translator lazily.\n                             * In a vast majority of cases, any given rule reports zero errors on a given\n                             * piece of code. Creating a translator lazily avoids the performance cost of\n                             * creating a new translator function for each rule that usually doesn't get\n                             * called.\n                             *\n                             * Using lazy report translators improves end-to-end performance by about 3%\n                             * with Node 8.4.0.\n                             */\n\n\n                            /*\n                             * This is used to avoid breaking rules that used monkeypatch Linter, and relied on\n                             * `linter.report` getting called with report info every time a rule reports a problem.\n                             * To continue to support this, make sure that `context._linter.report` is called every\n                             * time a problem is reported by a rule, even though `context._linter` is no longer a\n                             * `Linter` instance.\n                             *\n                             * This should be removed in a major release after we create a better way to\n                             * lint for unused disable comments.\n                             * https://github.com/eslint/eslint/issues/9193\n                             */\n\n\n                // add all the selectors from the rule as listeners\n\n\n        // augment global scope with declared global variables\n\n\n        /*\n         * Each node has a type property. Whenever a particular type of\n         * node is found, an event is fired. This allows any listeners to\n         * automatically be informed that this type of node has been found\n         * and react accordingly.\n         */\n\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.\n     *      Mostly useful for testing purposes.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @param {function(string): string[]} [filenameOrOptions.preprocess] preprocessor for source text. If provided,\n     *      this should accept a string of source text, and return an array of code blocks to lint.\n     * @param {function(Array<Object[]>): Object[]} [filenameOrOptions.postprocess] postprocessor for report messages. If provided,\n     *      this should accept an array of the message lists for each code block returned from the preprocessor,\n     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n\n\n    /**\n     * Defines many new linting rules.\n     * @param {Object} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n\n\n    /**\n     * Gets an object with all loaded rules.\n     * @returns {Map} All loaded rules\n     */\n\n\n    /**\n     * Performs multiple autofix passes over the text until as many fixes as possible\n     * have been applied.\n     * @param {string} text The source text to apply fixes to.\n     * @param {Object} config The ESLint config object to use.\n     * @param {Object} options The ESLint options object to use.\n     * @param {string} options.filename The filename from which the text was read.\n     * @param {boolean} options.allowInlineConfig Flag indicating if inline comments\n     *      should be allowed.\n     * @param {boolean|Function} options.fix Determines whether fixes should be applied\n     * @param {Function} options.preprocess preprocessor for source text. If provided, this should\n     *      accept a string of source text, and return an array of code blocks to lint.\n     * @param {Function} options.postprocess postprocessor for report messages. If provided,\n     *      this should accept an array of the message lists for each code block returned from the preprocessor,\n     *      apply a mapping to the messages as appropriate, and return a one-dimensional array of messages\n     * @returns {Object} The result of the fix operation as returned from the\n     *      SourceCodeFixer.\n     */\n\n\n        /**\n         * This loop continues until one of the following is true:\n         *\n         * 1. No more fixes have been applied.\n         * 2. Ten passes have been made.\n         *\n         * That means anytime a fix is successfully applied, there will be another pass.\n         * Essentially, guaranteeing a minimum of two passes.\n         */\n\n\n            // stop if there are any syntax errors.\n            // 'fixedResult.output' is a empty string.\n\n\n            // keep track if any fixes were ever applied - important for return value\n\n\n            // update to use the fixed output instead of the original text\n\n\n        /*\n         * If the last result had fixes, we need to lint again to be sure we have\n         * the most up-to-date information.\n         */\n\n\n        // ensure the last result properly reflects if fixes were done\n\n\n"
    },
    "3": {
        "bug_file": "lib/cli-engine.js",
        "compressed": "YES",
        "line_numbers": 679,
        "compressed_line_numbers": 331,
        "compressed_bug_file_content": "/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {boolean} allowInlineConfig Enable or disable inline configuration comments.\n * @property {boolean|Object} baseConfig Base config object. True enables recommend rules and environments.\n * @property {boolean} cache Enable result caching.\n * @property {string} cacheLocation The cache file to use instead of .eslintcache.\n * @property {string} configFile The configuration file to use.\n * @property {string} cwd The value to use for the current working directory.\n * @property {string[]} envs An array of environments to load.\n * @property {string[]} extensions An array of file extensions to check.\n * @property {boolean|Function} fix Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} globals An array of global variables to declare.\n * @property {boolean} ignore False disables use of .eslintignore.\n * @property {string} ignorePath The ignore file to use instead of .eslintignore.\n * @property {string} ignorePattern A glob pattern of files to ignore.\n * @property {boolean} useEslintrc False disables looking for .eslintrc\n * @property {string} parser The name of the parser to use.\n * @property {Object} parserOptions An object of parserOption settings to use.\n * @property {string[]} plugins An array of plugins to load.\n * @property {Object<string,*>} rules An object of rules to use.\n * @property {string[]} rulePaths An array of directories to load custom rules from.\n */\n\n/**\n * A linting warning or error.\n * @typedef {Object} LintMessage\n * @property {string} message The message to display to the user.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number of errors for the result.\n * @property {number} warningCount Number of warnings for the result.\n * @property {number} fixableErrorCount Number of fixable errors for the result.\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\n * @property {string=} [source] The source code of the file that was linted.\n * @property {string=} [output] The source code of the file that was linted, with as many fixes applied as possible.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {Object[]} messages - Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\n\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {Object[]} results - Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\n\n\n/**\n * Processes an source code using ESLint.\n * @param {string} text The source code to check.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {string} filename An optional string representing the texts filename.\n * @param {boolean|Function} fix Indicates if fixes should be processed.\n * @param {boolean} allowInlineConfig Allow/ignore comments that change config.\n * @param {Linter} linter Linter context\n * @returns {LintResult} The results for linting on this text.\n * @private\n */\n\n\n/**\n * Processes an individual file using ESLint. Files used here are known to\n * exist, so no need to check that here.\n * @param {string} filename The filename of the file being checked.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {Object} options The CLIEngine options object.\n * @param {Linter} linter Linter context\n * @returns {LintResult} The results for linting on this file.\n * @private\n */\n\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath - File path of checked code\n * @param {string} baseDir  - Absolute path of base directory\n * @returns {LintResult} Result with single warning\n * @private\n */\n\n\n/**\n * Checks if the given message is an error message.\n * @param {Object} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n *\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\n\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n\n\n        // is file so just use that file\n\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\n    /**\n     * Creates a new instance of the core CLI engine.\n     * @param {CLIEngineOptions} options The options for this instance.\n     * @constructor\n     */\n\n\n        /**\n         * Stored options for this instance\n         * @type {Object}\n         */\n\n\n            /**\n             * Cache used to avoid operating on files that haven't changed since the\n             * last successful execution (e.g., file passed linting with no errors and\n             * no warnings).\n             * @type {Object}\n             */\n\n\n        // load in additional rules\n\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {Object} report The report object created by CLIEngine.\n     * @returns {void}\n     */\n\n\n    /**\n     * Add a plugin by passing its configuration\n     * @param {string} name Name of the plugin.\n     * @param {Object} pluginobject Plugin configuration object.\n     * @returns {void}\n     */\n\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {Object} The results for all files that were linted.\n     */\n\n\n        /**\n         * Calculates the hash of the config file used to validate a given file\n         * @param  {string} filename The path of the file to retrieve a config object for to calculate the hash\n         * @returns {string}         the hash of the config\n         */\n\n\n                /*\n                 * get the descriptor for this file\n                 * with the metadata and the flag that determines if\n                 * the file has changed\n                 */\n\n\n                    /*\n                     * Add the the cached results (always will be 0 error and\n                     * 0 warnings). We should not cache results for files that\n                     * failed, in order to guarantee that next execution will\n                     * process those files as well.\n                     */\n\n\n                    /*\n                    * if a file contains errors or warnings we don't want to\n                    * store the file in the cache so we can guarantee that\n                    * next execution will also operate on this file\n                    */\n\n\n                    /*\n                     * since the file passed we store the result here\n                     * TODO: it might not be necessary to store the results list in the cache,\n                     * since it should always be 0 errors/warnings\n                     */\n\n\n            // persist the cache to disk\n\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} filename An optional string representing the texts filename.\n     * @param {boolean} warnIgnored Always warn when a file is ignored\n     * @returns {Object} The results for the linting.\n     */\n\n\n        // resolve filename based on options.cwd (for reporting, ignoredPaths also resolves)\n\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Object} A configuration object for the file.\n     */\n\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n\n\n    /**\n     * Returns the formatter representing the given format or null if no formatter\n     * with the given name can be found.\n     * @param {string} [format] The name of the format to load or the path to a\n     *      custom formatter.\n     * @returns {Function} The formatter function or null if not found.\n     */\n\n\n        // default is stylish\n\n\n        // only strings are valid formatters\n\n\n            // replace \\ with / for Windows compatibility\n\n\n            // if there's a slash, then it's a file\n\n\n"
    },
    "4": {
        "bug_file": "lib/rules/no-multiple-empty-lines.js",
        "compressed": "NO",
        "line_numbers": 136,
        "compressed_line_numbers": 136,
        "compressed_bug_file_content": "/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create(context) {\n\n        // Use options.max or 2 as default\n        let max = 2,\n            maxEOF = max,\n            maxBOF = max;\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n        const templateLiteralLines = new Set();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            TemplateLiteral(node) {\n                node.quasis.forEach(literalPart => {\n\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n                        templateLiteralLines.add(ignoredLine);\n                    }\n                });\n            },\n            \"Program:exit\"(node) {\n                return allLines\n\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\n                    .reduce((nonEmptyLineNumbers, line, index) => {\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\n                            nonEmptyLineNumbers.push(index + 1);\n                        }\n                        return nonEmptyLineNumbers;\n                    }, [])\n\n                    // Add a value at the end to allow trailing empty lines to be checked.\n                    .concat(allLines.length + 1)\n\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n                    .reduce((lastLineNumber, lineNumber) => {\n                        let message, maxAllowed;\n\n                        if (lastLineNumber === 0) {\n                            message = \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxBOF;\n                        } else if (lineNumber === allLines.length + 1) {\n                            message = \"Too many blank lines at the end of file. Max of {{max}} allowed.\";\n                            maxAllowed = maxEOF;\n                        } else {\n                            message = \"More than {{max}} blank {{pluralizedLines}} not allowed.\";\n                            maxAllowed = max;\n                        }\n\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n                            context.report({\n                                node,\n                                loc: { start: { line: lastLineNumber + 1, column: 0 }, end: { line: lineNumber, column: 0 } },\n                                message,\n                                data: { max: maxAllowed, pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\" },\n                                fix(fixer) {\n                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });\n\n                                    /*\n                                     * The end of the removal range is usually the start index of the next line.\n                                     * However, at the end of the file there is no next line, so the end of the\n                                     * range is just the length of the text.\n                                     */\n                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length\n                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })\n                                        : sourceCode.text.length;\n\n                                    return fixer.removeRange([rangeStart, rangeEnd]);\n                                }\n                            });\n                        }\n\n                        return lineNumber;\n                    }, 0);\n            }\n        };\n    }\n};"
    },
    "5": {
        "bug_file": "lib/rules/no-mixed-spaces-and-tabs.js",
        "compressed": "NO",
        "line_numbers": 143,
        "compressed_line_numbers": 143,
        "compressed_bug_file_content": "/**\n * @fileoverview Disallow mixed spaces and tabs for indentation\n * @author Jary Niebur\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow mixed spaces and tabs for indentation\",\n            category: \"Stylistic Issues\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"smart-tabs\", true, false]\n            }\n        ]\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        let smartTabs;\n        const ignoredLocs = [];\n\n        switch (context.options[0]) {\n            case true: // Support old syntax, maybe add deprecation warning here\n            case \"smart-tabs\":\n                smartTabs = true;\n                break;\n            default:\n                smartTabs = false;\n        }\n\n        /**\n         * Determines if a given line and column are before a location.\n         * @param {Location} loc The location object from an AST node.\n         * @param {int} line The line to check.\n         * @param {int} column The column to check.\n         * @returns {boolean} True if the line and column are before the location, false if not.\n         * @private\n         */\n        function beforeLoc(loc, line, column) {\n            if (line < loc.start.line) {\n                return true;\n            }\n            return line === loc.start.line && column < loc.start.column;\n        }\n\n        /**\n         * Determines if a given line and column are after a location.\n         * @param {Location} loc The location object from an AST node.\n         * @param {int} line The line to check.\n         * @param {int} column The column to check.\n         * @returns {boolean} True if the line and column are after the location, false if not.\n         * @private\n         */\n        function afterLoc(loc, line, column) {\n            if (line > loc.end.line) {\n                return true;\n            }\n            return line === loc.end.line && column > loc.end.column;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            TemplateElement(node) {\n                ignoredLocs.push(node.loc);\n            },\n\n            \"Program:exit\"(node) {\n\n                /*\n                 * At least one space followed by a tab\n                 * or the reverse before non-tab/-space\n                 * characters begin.\n                 */\n                let regex = /^(?=[\\t ]*(\\t | \\t))/;\n                const lines = sourceCode.lines,\n                    comments = sourceCode.getAllComments();\n\n                comments.forEach(comment => {\n                    ignoredLocs.push(comment.loc);\n                });\n\n                ignoredLocs.sort((first, second) => {\n                    if (beforeLoc(first, second.start.line, second.start.column)) {\n                        return 1;\n                    }\n\n                    if (beforeLoc(second, first.start.line, second.start.column)) {\n                        return -1;\n                    }\n\n                    return 0;\n                });\n\n                if (smartTabs) {\n\n                    /*\n                     * At least one space followed by a tab\n                     * before non-tab/-space characters begin.\n                     */\n                    regex = /^(?=[\\t ]* \\t)/;\n                }\n\n                lines.forEach((line, i) => {\n                    const match = regex.exec(line);\n\n                    if (match) {\n                        const lineNumber = i + 1,\n                            column = match.index + 1;\n\n                        for (let j = 0; j < ignoredLocs.length; j++) {\n                            if (beforeLoc(ignoredLocs[j], lineNumber, column)) {\n                                continue;\n                            }\n                            if (afterLoc(ignoredLocs[j], lineNumber, column)) {\n                                continue;\n                            }\n\n                            return;\n                        }\n\n                        context.report({ node, loc: { line: lineNumber, column }, message: \"Mixed spaces and tabs.\" });\n                    }\n                });\n            }\n\n        };\n\n    }\n};"
    }
}