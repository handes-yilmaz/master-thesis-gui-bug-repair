{
    "bug_classes": {
        "1": {
            "class_name": "DateInput (not found) ",
            "file_path": "src/js/components/DateInput/DateInput.js",
            "class_details": [
                {
                    "name": "DateInput",
                    "start_line": 1,
                    "end_line": 343
                }
            ],
            "class_code": [
                "import React, {",
                "  useRef,",
                "  forwardRef,",
                "  useContext,",
                "  useEffect,",
                "  useMemo,",
                "  useState,",
                "  useCallback,",
                "} from 'react';",
                "import { ThemeContext } from 'styled-components';",
                "import { Calendar as CalendarIcon } from 'grommet-icons/icons/Calendar';",
                "import { defaultProps } from '../../default-props';",
                "import { AnnounceContext } from '../../contexts/AnnounceContext';",
                "import { MessageContext } from '../../contexts/MessageContext';",
                "import { Box } from '../Box';",
                "import { Button } from '../Button';",
                "import { Calendar } from '../Calendar';",
                "import { Drop } from '../Drop';",
                "import { DropButton } from '../DropButton';",
                "import { FormContext } from '../Form';",
                "import { Keyboard } from '../Keyboard';",
                "import { MaskedInput } from '../MaskedInput';",
                "import { useForwardedRef, setHoursWithOffset } from '../../utils';",
                "import {",
                "  formatToSchema,",
                "  schemaToMask,",
                "  valuesAreEqual,",
                "  valueToText,",
                "  textToValue,",
                "} from './utils';",
                "import { DateInputPropTypes } from './propTypes';",
                "import { getOutputFormat } from '../Calendar/Calendar';",
                "",
                "const getReference = (value) => {",
                "  let adjustedDate;",
                "  let res;",
                "  if (typeof value === 'string') res = value;",
                "  else if (Array.isArray(value) && Array.isArray(value[0]))",
                "    res = value[0].find((date) => date);",
                "  else if (Array.isArray(value) && value.length) [res] = value;",
                "",
                "  if (res) {",
                "    adjustedDate = setHoursWithOffset(res);",
                "  }",
                "  return adjustedDate;",
                "};",
                "",
                "const DateInput = forwardRef(",
                "  (",
                "    {",
                "      buttonProps, // when no format and not inline",
                "      calendarProps,",
                "      defaultValue,",
                "      disabled,",
                "      dropProps, // when inline isn't true",
                "      format,",
                "      id,",
                "      icon,",
                "      inline = false,",
                "      inputProps, // for MaskedInput, when format is specified",
                "      name,",
                "      onChange,",
                "      onFocus,",
                "      plain,",
                "      reverse: reverseProp = false,",
                "      value: valueArg,",
                "      messages,",
                "      ...rest",
                "    },",
                "    refArg,",
                "  ) => {",
                "    const theme = useContext(ThemeContext) || defaultProps.theme;",
                "    const announce = useContext(AnnounceContext);",
                "    const { format: formatMessage } = useContext(MessageContext);",
                "    const iconSize =",
                "      (theme.dateInput.icon && theme.dateInput.icon.size) || 'medium';",
                "    const { useFormInput } = useContext(FormContext);",
                "    const ref = useForwardedRef(refArg);",
                "    const containerRef = useRef();",
                "    const [value, setValue] = useFormInput({",
                "      name,",
                "      value: valueArg,",
                "      initialValue: defaultValue,",
                "    });",
                "",
                "    const [outputFormat, setOutputFormat] = useState(getOutputFormat(value));",
                "    useEffect(() => {",
                "      setOutputFormat((previousFormat) => {",
                "        const nextFormat = getOutputFormat(value);",
                "        // when user types, date could become something like 07//2020",
                "        // and value becomes undefined. don't lose the format from the",
                "        // previous valid date",
                "        return previousFormat !== nextFormat ? previousFormat : nextFormat;",
                "      });",
                "    }, [value]);",
                "",
                "    // keep track of timestamp from original date(s)",
                "    const [reference, setReference] = useState(getReference(value));",
                "",
                "    // do we expect multiple dates?",
                "    const range = Array.isArray(value) || (format && format.includes('-'));",
                "",
                "    // parse format and build a formal schema we can use elsewhere",
                "    const schema = useMemo(() => formatToSchema(format), [format]);",
                "",
                "    // mask is only used when a format is provided",
                "    const mask = useMemo(() => schemaToMask(schema), [schema]);",
                "",
                "    // textValue is only used when a format is provided",
                "    const [textValue, setTextValue] = useState(",
                "      schema ? valueToText(value, schema) : undefined,",
                "    );",
                "",
                "    // Setting the icon through `inputProps` is deprecated.",
                "    // The `icon` prop should be used instead.",
                "    const { icon: MaskedInputIcon, ...restOfInputProps } = inputProps || {};",
                "    if (MaskedInputIcon) {",
                "      console.warn(",
                "        `Customizing the DateInput icon through inputProps is deprecated.",
                "Use the icon prop instead.`,",
                "      );",
                "    }",
                "",
                "    const reverse = reverseProp || restOfInputProps.reverse;",
                "",
                "    const calendarDropdownAlign = { top: 'bottom', left: 'left' };",
                "",
                "    // We need to distinguish between the caller changing a Form value",
                "    // and the user typing a date that he isn't finished with yet.",
                "    // To handle this, we see if we have a value and the text value",
                "    // associated with it doesn't align to it, then we update the text value.",
                "    // We compare using textToValue to avoid \"06/01/2021\" not",
                "    // matching \"06/1/2021\".",
                "    useEffect(() => {",
                "      if (schema && value !== undefined) {",
                "        const nextTextValue = valueToText(value, schema);",
                "        if (",
                "          !valuesAreEqual(",
                "            textToValue(textValue, schema, range, reference),",
                "            textToValue(nextTextValue, schema, range, reference),",
                "          ) ||",
                "          (textValue === '' && nextTextValue !== '')",
                "        ) {",
                "          setTextValue(nextTextValue);",
                "        }",
                "      }",
                "    }, [range, schema, textValue, reference, value]);",
                "",
                "    // when format and not inline, whether to show the Calendar in a Drop",
                "    const [open, setOpen] = useState();",
                "",
                "    const openCalendar = useCallback(() => {",
                "      setOpen(true);",
                "      announce(formatMessage({ id: 'dateInput.enterCalendar', messages }));",
                "    }, [announce, formatMessage, messages]);",
                "",
                "    const closeCalendar = useCallback(() => {",
                "      setOpen(false);",
                "      announce(formatMessage({ id: 'dateInput.exitCalendar', messages }));",
                "    }, [announce, formatMessage, messages]);",
                "",
                "    const dates = useMemo(",
                "      () => (range && value?.length ? [value] : undefined),",
                "      [range, value],",
                "    );",
                "",
                "    const calendar = (",
                "      <Calendar",
                "        ref={inline ? ref : undefined}",
                "        id={inline && !format ? id : undefined}",
                "        range={range}",
                "        date={range ? undefined : value}",
                "        // when caller initializes with empty array, dates should be undefined",
                "        // allowing the user to select both begin and end of the range",
                "        dates={dates}",
                "        // places focus on days grid when Calendar opens",
                "        initialFocus={open ? 'days' : undefined}",
                "        onSelect={",
                "          disabled",
                "            ? undefined",
                "            : (nextValue) => {",
                "                let normalizedValue;",
                "                if (range && Array.isArray(nextValue))",
                "                  [normalizedValue] = nextValue;",
                "                // clicking an edge date removes it",
                "                else if (range) normalizedValue = [nextValue, nextValue];",
                "                else normalizedValue = nextValue;",
                "",
                "                if (schema) setTextValue(valueToText(normalizedValue, schema));",
                "                setValue(normalizedValue);",
                "                setReference(getReference(nextValue));",
                "                if (onChange) onChange({ value: normalizedValue });",
                "                if (open && !range) {",
                "                  closeCalendar();",
                "                  setTimeout(() => ref.current.focus(), 1);",
                "                }",
                "              }",
                "        }",
                "        {...calendarProps}",
                "      />",
                "    );",
                "",
                "    const formContextValue = useMemo(",
                "      () => ({",
                "        useFormInput: ({ value: valueProp }) => [valueProp, () => {}],",
                "      }),",
                "      [],",
                "    );",
                "",
                "    if (!format) {",
                "      // When no format is specified, we don't give the user a way to type",
                "      if (inline) return calendar;",
                "",
                "      return (",
                "        <DropButton",
                "          ref={ref}",
                "          id={id}",
                "          dropProps={{ align: calendarDropdownAlign, ...dropProps }}",
                "          dropContent={calendar}",
                "          icon={icon || MaskedInputIcon || <CalendarIcon size={iconSize} />}",
                "          {...buttonProps}",
                "        />",
                "      );",
                "    }",
                "",
                "    const calendarButton = (",
                "      <Button",
                "        onClick={open ? closeCalendar : openCalendar}",
                "        plain",
                "        icon={icon || MaskedInputIcon || <CalendarIcon size={iconSize} />}",
                "        margin={reverse ? { left: 'small' } : { right: 'small' }}",
                "      />",
                "    );",
                "",
                "    const input = (",
                "      <FormContext.Provider",
                "        key=\"input\"",
                "        // don't let MaskedInput drive the Form",
                "        value={formContextValue}",
                "      >",
                "        <Keyboard",
                "          onEsc={open ? () => closeCalendar() : undefined}",
                "          onSpace={(event) => {",
                "            event.preventDefault();",
                "            openCalendar();",
                "          }}",
                "        >",
                "          <Box",
                "            ref={containerRef}",
                "            border={!plain}",
                "            round={theme.dateInput.container.round}",
                "            direction=\"row\"",
                "            fill",
                "          >",
                "            {reverse && calendarButton}",
                "            <MaskedInput",
                "              ref={ref}",
                "              id={id}",
                "              name={name}",
                "              reverse",
                "              disabled={disabled}",
                "              mask={mask}",
                "              plain",
                "              {...restOfInputProps}",
                "              {...rest}",
                "              value={textValue}",
                "              onChange={(event) => {",
                "                const nextTextValue = event.target.value;",
                "                setTextValue(nextTextValue);",
                "                const nextValue = textToValue(",
                "                  nextTextValue,",
                "                  schema,",
                "                  range,",
                "                  reference,",
                "                  outputFormat,",
                "                );",
                "                if (nextValue !== undefined)",
                "                  setReference(getReference(nextValue));",
                "                // update value even when undefined",
                "                setValue(nextValue);",
                "                if (onChange) {",
                "                  event.persist(); // extract from React synthetic event pool",
                "                  const adjustedEvent = event;",
                "                  adjustedEvent.value = nextValue;",
                "                  onChange(adjustedEvent);",
                "                }",
                "              }}",
                "              onFocus={(event) => {",
                "                announce(",
                "                  formatMessage({ id: 'dateInput.openCalendar', messages }),",
                "                );",
                "                if (onFocus) onFocus(event);",
                "              }}",
                "            />",
                "            {!reverse && calendarButton}",
                "          </Box>",
                "        </Keyboard>",
                "      </FormContext.Provider>",
                "    );",
                "",
                "    if (inline) {",
                "      return (",
                "        <Box>",
                "          {input}",
                "          {calendar}",
                "        </Box>",
                "      );",
                "    }",
                "",
                "    if (open) {",
                "      return [",
                "        input,",
                "        <Keyboard key=\"drop\" onEsc={() => ref.current.focus()}>",
                "          <Drop",
                "            overflow=\"visible\"",
                "            id={id ? `${id}__drop` : undefined}",
                "            target={containerRef.current}",
                "            align={{ ...calendarDropdownAlign, ...dropProps }}",
                "            onEsc={closeCalendar}",
                "            onClickOutside={({ target }) => {",
                "              if (",
                "                target !== containerRef.current &&",
                "                !containerRef.current.contains(target)",
                "              ) {",
                "                closeCalendar();",
                "              }",
                "            }}",
                "            {...dropProps}",
                "          >",
                "            {calendar}",
                "          </Drop>",
                "        </Keyboard>,",
                "      ];",
                "    }",
                "",
                "    return input;",
                "  },",
                ");",
                "",
                "DateInput.displayName = 'DateInput';",
                "DateInput.propTypes = DateInputPropTypes;",
                "",
                "export { DateInput };"
            ]
        },
        "2": {
            "class_name": "Calendar (not found) 21-521",
            "file_path": "src/js/components/Calendar/Calendar.js",
            "class_details": [
                {
                    "name": "Calendar",
                    "start_line": 21,
                    "end_line": 521
                }
            ],
            "class_code": [
                "  StyledCalendar,",
                "  StyledDay,",
                "  StyledDayContainer,",
                "  StyledWeek,",
                "  StyledWeeks,",
                "  StyledWeeksContainer,",
                "} from './StyledCalendar';",
                "import {",
                "  addDays,",
                "  addMonths,",
                "  betweenDates,",
                "  daysApart,",
                "  endOfMonth,",
                "  handleOffset,",
                "  startOfMonth,",
                "  subtractDays,",
                "  subtractMonths,",
                "  withinDates,",
                "} from './utils';",
                "import { CalendarPropTypes } from './propTypes';",
                "import { setHoursWithOffset } from '../../utils/dates';",
                "",
                "const headingPadMap = {",
                "  small: 'xsmall',",
                "  medium: 'small',",
                "  large: 'medium',",
                "};",
                "",
                "const getLocaleString = (value, locale) =>",
                "  value?.toLocaleDateString(locale, {",
                "    month: 'long',",
                "    day: 'numeric',",
                "    year: 'numeric',",
                "  });",
                "",
                "const currentlySelectedString = (value, locale) => {",
                "  let selected;",
                "  if (value instanceof Date) {",
                "    selected = `Currently selected ${getLocaleString(value, locale)};`;",
                "  } else if (value?.length) {",
                "    selected = `Currently selected ${value.map((item) => {",
                "      let dates;",
                "      if (!Array.isArray(item)) {",
                "        dates = `${getLocaleString(item, locale)}`;",
                "      } else {",
                "        const start =",
                "          item[0] !== undefined ? getLocaleString(item[0], locale) : 'none';",
                "        const end =",
                "          item[1] !== undefined ? getLocaleString(item[1], locale) : 'none';",
                "        dates = `${start} through ${end}`;",
                "      }",
                "      return dates;",
                "    })}`;",
                "  } else {",
                "    selected = 'No date selected';",
                "  }",
                "",
                "  return selected;",
                "};",
                "",
                "// calendar value may be a single date, multiple dates, a range of dates",
                "// supplied as ISOstrings.",
                "const normalizeInput = (dateValue) => {",
                "  let result;",
                "  if (dateValue instanceof Date) {",
                "    result = dateValue;",
                "  }",
                "  // date may be an empty string ''",
                "  else if (typeof dateValue === 'string' && dateValue.length) {",
                "    result = setHoursWithOffset(dateValue);",
                "  } else if (Array.isArray(dateValue)) {",
                "    result = dateValue.map((d) => normalizeInput(d));",
                "  }",
                "  return result;",
                "};",
                "",
                "const normalizeOutput = (dateValue, outputFormat) => {",
                "  let result;",
                "",
                "  const normalize = (value) => {",
                "    let normalizedValue = value.toISOString();",
                "    if (normalizedValue && outputFormat === 'no timezone') {",
                "      [normalizedValue] = handleOffset(normalizedValue)",
                "        .toISOString()",
                "        .split('T');",
                "    }",
                "    return normalizedValue;",
                "  };",
                "",
                "  if (dateValue instanceof Date) {",
                "    result = normalize(dateValue);",
                "  } else if (typeof dateValue === 'undefined') {",
                "    result = undefined;",
                "  } else {",
                "    result = dateValue.map((d) => normalizeOutput(d, outputFormat));",
                "  }",
                "  return result;",
                "};",
                "",
                "// format value to [[]] for internal functions",
                "const normalizeRange = (value, activeDate) => {",
                "  let range = value;",
                "  if (range instanceof Date)",
                "    range =",
                "      activeDate === 'start' ? [[undefined, range]] : [[range, undefined]];",
                "  else if (Array.isArray(range) && !Array.isArray(range[0])) range = [range];",
                "",
                "  return range;",
                "};",
                "",
                "const getReference = (reference, value) => {",
                "  let nextReference;",
                "  if (value) {",
                "    if (Array.isArray(value)) {",
                "      if (value[0] instanceof Date) {",
                "        [nextReference] = value;",
                "      } else if (Array.isArray(value[0])) {",
                "        nextReference = value[0][0] ? value[0][0] : value[0][1];",
                "      } else {",
                "        nextReference = new Date();",
                "        nextReference.setHours(0, 0, 0, 0);",
                "      }",
                "    } else nextReference = value;",
                "  } else if (reference) {",
                "    nextReference = reference;",
                "  } else {",
                "    nextReference = new Date();",
                "    nextReference.setHours(0, 0, 0, 0);",
                "  }",
                "  return nextReference;",
                "};",
                "",
                "const buildDisplayBounds = (reference, firstDayOfWeek) => {",
                "  let start = new Date(reference);",
                "  start.setDate(1); // first of month",
                "",
                "  // In case Sunday is the first day of the month, and the user asked for Monday",
                "  // to be the first day of the week, then we need to include Sunday and six",
                "  // days prior.",
                "  start =",
                "    start.getDay() === 0 && firstDayOfWeek === 1",
                "      ? (start = subtractDays(start, 6))",
                "      : // beginning of week",
                "        (start = subtractDays(start, start.getDay() - firstDayOfWeek));",
                "",
                "  const end = addDays(start, 7 * 5 + 7); // 5 weeks to end of week",
                "  return [start, end];",
                "};",
                "",
                "export const getOutputFormat = (dates) => {",
                "  if (typeof dates === 'string' && dates?.indexOf('T') === -1) {",
                "    return 'no timezone';",
                "  }",
                "  if (Array.isArray(dates)) {",
                "    return getOutputFormat(dates[0]);",
                "  }",
                "  return 'date timezone';",
                "};",
                "",
                "const millisecondsPerYear = 31557600000;",
                "",
                "const CalendarDayButton = (props) => <Button tabIndex={-1} plain {...props} />;",
                "",
                "const CalendarDay = ({",
                "  children,",
                "  fill,",
                "  size,",
                "  isInRange,",
                "  isSelected,",
                "  otherMonth,",
                "  buttonProps = {},",
                "}) => (",
                "  <StyledDayContainer role=\"gridcell\" sizeProp={size} fillContainer={fill}>",
                "    <CalendarDayButton fill={fill} {...buttonProps}>",
                "      <StyledDay",
                "        disabledProp={buttonProps.disabled}",
                "        inRange={isInRange}",
                "        otherMonth={otherMonth}",
                "        isSelected={isSelected}",
                "        sizeProp={size}",
                "        fillContainer={fill}",
                "      >",
                "        {children}",
                "      </StyledDay>",
                "    </CalendarDayButton>",
                "  </StyledDayContainer>",
                ");",
                "",
                "const CalendarCustomDay = ({ children, fill, size, buttonProps }) => {",
                "  if (!buttonProps) {",
                "    return (",
                "      <StyledDayContainer role=\"gridcell\" sizeProp={size} fillContainer={fill}>",
                "        {children}",
                "      </StyledDayContainer>",
                "    );",
                "  }",
                "",
                "  return (",
                "    <StyledDayContainer role=\"gridcell\" sizeProp={size} fillContainer={fill}>",
                "      <CalendarDayButton fill={fill} {...buttonProps}>",
                "        {children}",
                "      </CalendarDayButton>",
                "    </StyledDayContainer>",
                "  );",
                "};",
                "",
                "const Calendar = forwardRef(",
                "  (",
                "    {",
                "      activeDate: activeDateProp,",
                "      animate = true,",
                "      bounds: boundsProp,",
                "      children,",
                "      date: dateProp,",
                "      dates: datesProp,",
                "      daysOfWeek,",
                "      disabled,",
                "      initialFocus, // internal only for DateInput",
                "      fill,",
                "      firstDayOfWeek = 0,",
                "      header,",
                "      locale = 'en-US',",
                "      messages,",
                "      onReference,",
                "      onSelect,",
                "      range,",
                "      reference: referenceProp,",
                "      showAdjacentDays = true,",
                "      size = 'medium',",
                "      timestamp: timestampProp,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const theme = useContext(ThemeContext) || defaultProps.theme;",
                "    const announce = useContext(AnnounceContext);",
                "    const { format } = useContext(MessageContext);",
                "",
                "    // when mousedown, we don't want to let Calendar set",
                "    // active date to firstInMonth",
                "    const [mouseDown, setMouseDown] = useState(false);",
                "    const onMouseDown = () => setMouseDown(true);",
                "    const onMouseUp = () => setMouseDown(false);",
                "    useEffect(() => {",
                "      document.addEventListener('mousedown', onMouseDown);",
                "      document.addEventListener('mouseup', onMouseUp);",
                "      return () => {",
                "        document.removeEventListener('mousedown', onMouseDown);",
                "        document.removeEventListener('mouseup', onMouseUp);",
                "      };",
                "    }, []);",
                "",
                "    // set activeDate when caller changes it, allows us to change",
                "    // it internally too",
                "    const [activeDate, setActiveDate] = useState(",
                "      dateProp && typeof dateProp === 'string' && range ? 'end' : 'start',",
                "    );",
                "    useEffect(() => {",
                "      if (activeDateProp) setActiveDate(activeDateProp);",
                "    }, [activeDateProp]);",
                "",
                "    const [value, setValue] = useState(normalizeInput(dateProp || datesProp));",
                "    useEffect(() => {",
                "      const val = dateProp || datesProp;",
                "      setValue(normalizeInput(val));",
                "    }, [dateProp, datesProp]);",
                "",
                "    const [reference, setReference] = useState(",
                "      getReference(normalizeInput(referenceProp), value),",
                "    );",
                "    useEffect(() => {",
                "      if (value) {",
                "        setReference(getReference(normalizeInput(referenceProp), value));",
                "      }",
                "    }, [referenceProp, value]);",
                "",
                "    const [outputFormat, setOutputFormat] = useState(",
                "      getOutputFormat(dateProp || datesProp),",
                "    );",
                "    useEffect(() => {",
                "      setOutputFormat(getOutputFormat(dateProp || datesProp));",
                "    }, [dateProp, datesProp]);",
                "",
                "    // normalize bounds",
                "    const [bounds, setBounds] = useState(boundsProp);",
                "    useEffect(() => {",
                "      if (boundsProp) setBounds(boundsProp);",
                "      else setBounds(undefined);",
                "    }, [boundsProp]);",
                "",
                "    // calculate the bounds we display based on the reference",
                "    const [displayBounds, setDisplayBounds] = useState(",
                "      buildDisplayBounds(reference, firstDayOfWeek),",
                "    );",
                "    const [targetDisplayBounds, setTargetDisplayBounds] = useState();",
                "    const [slide, setSlide] = useState();",
                "    const [animating, setAnimating] = useState();",
                "",
                "    // When the reference changes, we need to update the displayBounds.",
                "    // This is easy when we aren't animating. If we are animating,",
                "    // we temporarily increase the displayBounds to be the union of the old",
                "    // and new ones and set slide to drive the animation. We keep track",
                "    // of where we are heading via targetDisplayBounds. When the animation",
                "    // finishes, we prune displayBounds down to where we are headed and",
                "    // clear the slide and targetDisplayBounds.",
                "    useEffect(() => {",
                "      const nextDisplayBounds = buildDisplayBounds(reference, firstDayOfWeek);",
                "",
                "      // Checks if the difference between the current and next DisplayBounds is",
                "      // greater than a year. If that's the case, calendar should update without",
                "      // animation.",
                "      if (",
                "        nextDisplayBounds[0].getTime() !== displayBounds[0].getTime() &&",
                "        nextDisplayBounds[1].getTime() !== displayBounds[1].getTime()",
                "      ) {",
                "        let diffBoundsAboveYear = false;",
                "        if (nextDisplayBounds[0].getTime() < displayBounds[0].getTime()) {",
                "          if (",
                "            displayBounds[0].getTime() - nextDisplayBounds[0].getTime() >",
                "            millisecondsPerYear",
                "          ) {",
                "            diffBoundsAboveYear = true;",
                "          }",
                "        } else if (",
                "          nextDisplayBounds[1].getTime() > displayBounds[1].getTime()",
                "        ) {",
                "          if (",
                "            nextDisplayBounds[1].getTime() - displayBounds[1].getTime() >",
                "            millisecondsPerYear",
                "          ) {",
                "            diffBoundsAboveYear = true;",
                "          }",
                "        }",
                "        if (!animate || diffBoundsAboveYear) {",
                "          setDisplayBounds(nextDisplayBounds);",
                "        } else {",
                "          setTargetDisplayBounds(nextDisplayBounds);",
                "        }",
                "      }",
                "    }, [animate, firstDayOfWeek, reference, displayBounds]);",
                "",
                "    useEffect(() => {",
                "      // if the reference timezone has changed (e.g., controlled component),",
                "      // both ends of the displayBounds should inherit that new timestamp",
                "      if (targetDisplayBounds) {",
                "        if (",
                "          targetDisplayBounds[0].getTime() < displayBounds[0].getTime() ||",
                "          targetDisplayBounds[1].getTime() > displayBounds[1].getTime()",
                "        ) {",
                "          setDisplayBounds([targetDisplayBounds[0], targetDisplayBounds[1]]);",
                "        }",
                "        if (targetDisplayBounds[0].getTime() < displayBounds[0].getTime()) {",
                "          // only animate if the duration is within a year",
                "          if (",
                "            displayBounds[0].getTime() - targetDisplayBounds[0].getTime() <",
                "              millisecondsPerYear &&",
                "            daysApart(displayBounds[0], targetDisplayBounds[0])",
                "          ) {",
                "            setSlide({",
                "              direction: 'down',",
                "              weeks: daysApart(displayBounds[0], targetDisplayBounds[0]) / 7,",
                "            });",
                "            setAnimating(true);",
                "          }",
                "        } else if (",
                "          targetDisplayBounds[1].getTime() > displayBounds[1].getTime()",
                "        ) {",
                "          if (",
                "            targetDisplayBounds[1].getTime() - displayBounds[1].getTime() <",
                "              millisecondsPerYear &&",
                "            daysApart(targetDisplayBounds[1], displayBounds[1])",
                "          ) {",
                "            setSlide({",
                "              direction: 'up',",
                "              weeks: daysApart(targetDisplayBounds[1], displayBounds[1]) / 7,",
                "            });",
                "            setAnimating(true);",
                "          }",
                "        }",
                "        return undefined;",
                "      }",
                "",
                "      setSlide(undefined);",
                "      return undefined;",
                "    }, [animating, displayBounds, targetDisplayBounds]);",
                "",
                "    // Last step in updating the displayBounds. Allows for pruning",
                "    // displayBounds and cleaning up states to occur after animation.",
                "    useEffect(() => {",
                "      if (animating && targetDisplayBounds) {",
                "        // Wait for animation to finish before cleaning up.",
                "        const timer = setTimeout(",
                "          () => {",
                "            setDisplayBounds(targetDisplayBounds);",
                "            setTargetDisplayBounds(undefined);",
                "            setSlide(undefined);",
                "            setAnimating(false);",
                "          },",
                "          400, // Empirically determined.",
                "        );",
                "        return () => clearTimeout(timer);",
                "      }",
                "      return undefined;",
                "    }, [animating, targetDisplayBounds]);",
                "",
                "    // We have to deal with reference being the end of a month with more",
                "    // days than the month we are changing to. So, we always set reference",
                "    // to the first of the month before changing the month.",
                "    const previousMonth = useMemo(",
                "      () => endOfMonth(subtractMonths(startOfMonth(reference), 1)),",
                "      [reference],",
                "    );",
                "    const nextMonth = useMemo(",
                "      () => startOfMonth(addMonths(startOfMonth(reference), 1)),",
                "      [reference],",
                "    );",
                "",
                "    const daysRef = useRef();",
                "    const [focus, setFocus] = useState();",
                "    const [active, setActive] = useState();",
                "",
                "    useEffect(() => {",
                "      if (initialFocus === 'days') daysRef.current.focus();",
                "    }, [initialFocus]);",
                "",
                "    const changeReference = useCallback(",
                "      (nextReference) => {",
                "        if (betweenDates(nextReference, bounds)) {",
                "          setReference(nextReference);",
                "          if (onReference) onReference(nextReference.toISOString());",
                "        }",
                "      },",
                "      [onReference, bounds],",
                "    );",
                "",
                "    const handleRange = useCallback(",
                "      (selectedDate) => {",
                "        let result;",
                "        const priorRange = normalizeRange(value, activeDate);",
                "        // deselect when date clicked was the start/end of the range",
                "        if (selectedDate.getTime() === priorRange?.[0]?.[0]?.getTime()) {",
                "          result = [[undefined, priorRange[0][1]]];",
                "          setActiveDate('start');",
                "        } else if (selectedDate.getTime() === priorRange?.[0]?.[1]?.getTime()) {",
                "          result = [[priorRange[0][0], undefined]];",
                "          setActiveDate('end');",
                "        }",
                "        // selecting start date",
                "        else if (activeDate === 'start') {",
                "          if (!priorRange) {",
                "            result = [[selectedDate, undefined]];",
                "          } else if (!priorRange[0][1]) {",
                "            result = [[selectedDate, priorRange[0][1]]];",
                "          } else if (selectedDate.getTime() < priorRange[0][1].getTime()) {",
                "            result = [[selectedDate, priorRange[0][1]]];",
                "          } else if (selectedDate.getTime() > priorRange[0][1].getTime()) {",
                "            result = [[selectedDate, undefined]];",
                "          }",
                "          setActiveDate('end');",
                "        }",
                "        // selecting end date",
                "        else if (!priorRange) {",
                "          result = [[undefined, selectedDate]];",
                "          setActiveDate('start');",
                "        } else if (selectedDate.getTime() < priorRange[0][0].getTime()) {",
                "          result = [[selectedDate, undefined]];",
                "          setActiveDate('end');",
                "        } else if (selectedDate.getTime() > priorRange[0][0].getTime()) {",
                "          result = [[priorRange[0][0], selectedDate]];",
                "          setActiveDate('start');",
                "        }",
                "",
                "        // If no dates selected, always return undefined; else format",
                "        // result according to specified range value.",
                "        if (result[0].includes(undefined)) {",
                "          if (range === 'array') {",
                "            result = !result[0][0] && !result[0][1] ? undefined : result;",
                "          } else {",
                "            result = result[0].find((d) => d !== undefined);",
                "          }",
                "        }",
                "        setValue(result);",
                "        return result;",
                "      },",
                "      [activeDate, value, range],",
                "    );",
                "",
                "    const selectDate = useCallback(",
                "      (selectedDate) => {",
                "        let nextValue;",
                "",
                "        if (range || Array.isArray(value?.[0])) {",
                "          nextValue = handleRange(selectedDate);",
                "        } else {",
                "          nextValue = selectedDate;",
                "        }",
                "",
                "        if (onSelect) {",
                "          nextValue = normalizeOutput(nextValue, outputFormat);",
                "          onSelect(nextValue);",
                "        }"
            ]
        }
    },
    "bug_functions": {
        "3": {
            "function_name": "withinDates (not found) ",
            "file_path": "src/js/components/Calendar/utils.js",
            "function_details": [
                {
                    "name": "withinDates",
                    "start_line": 1,
                    "end_line": 130
                }
            ],
            "function_code": [
                "// Utility functions for the Calendar.",
                "// Just what's needed to avoid having to include a dependency like momentjs.",
                "",
                "const DAY_MILLISECONDS = 24 * 60 * 60 * 1000;",
                "",
                "export const addDays = (date, days) => {",
                "  const result = new Date(date.getTime() + DAY_MILLISECONDS * days);",
                "  // Deal with crossing the daylight savings time boundary,",
                "  // where adding a day's worth when the time is midnight results in",
                "  // being a day off.",
                "  let hourDelta = result.getHours() - date.getHours();",
                "  // At this point, hourDelta is typically 0 (normal day),",
                "  // +23 (November daylight saving), or -23 (March Daylight saving)",
                "  // depending on which side of the switch we are on.",
                "  // Convert so that hourDelta is either +1 or -1.",
                "  if (hourDelta === 23) {",
                "    hourDelta -= 24;",
                "  } else if (hourDelta === -23) {",
                "    hourDelta += 24;",
                "  }",
                "  result.setHours(result.getHours() - hourDelta);",
                "  return result;",
                "};",
                "",
                "export const subtractDays = (date, days) => addDays(date, -days);",
                "",
                "export const addMonths = (date, months) => {",
                "  const result = new Date(date);",
                "  const years = Math.floor((date.getMonth() + months) / 12);",
                "  result.setFullYear(date.getFullYear() + years);",
                "  const targetMonth = (date.getMonth() + months) % 12;",
                "  result.setMonth(targetMonth < 0 ? 12 + targetMonth : targetMonth);",
                "  return result;",
                "};",
                "",
                "export const subtractMonths = (date, months) => addMonths(date, -months);",
                "",
                "export const startOfMonth = (date) => {",
                "  const result = new Date(date);",
                "  result.setDate(1);",
                "  return result;",
                "};",
                "",
                "export const endOfMonth = (date) => {",
                "  const result = addMonths(date, 1);",
                "  result.setDate(0);",
                "  return result;",
                "};",
                "",
                "export const sameDay = (date1, date2) =>",
                "  date1.getFullYear() === date2.getFullYear() &&",
                "  date1.getMonth() === date2.getMonth() &&",
                "  date1.getDate() === date2.getDate();",
                "",
                "export const sameDayOrAfter = (date1, date2) =>",
                "  date1.getFullYear() > date2.getFullYear() ||",
                "  (date1.getFullYear() === date2.getFullYear() &&",
                "    (date1.getMonth() > date2.getMonth() ||",
                "      (date1.getMonth() === date2.getMonth() &&",
                "        date1.getDate() >= date2.getDate())));",
                "",
                "export const sameDayOrBefore = (date1, date2) =>",
                "  date1.getFullYear() < date2.getFullYear() ||",
                "  (date1.getFullYear() === date2.getFullYear() &&",
                "    (date1.getMonth() < date2.getMonth() ||",
                "      (date1.getMonth() === date2.getMonth() &&",
                "        date1.getDate() <= date2.getDate())));",
                "",
                "export const daysApart = (date1, date2) =>",
                "  Math.floor((date1.getTime() - date2.getTime()) / DAY_MILLISECONDS);",
                "",
                "// betweenDates takes an array of two elements and checks if the",
                "// supplied date lies between them, inclusive.",
                "// returns 2 if exact match to one end, 1 if between, undefined otherwise",
                "export const betweenDates = (date, dates) => {",
                "  let result;",
                "  if (dates) {",
                "    const [from, to] = Array.isArray(dates)",
                "      ? dates.map((d) => (d ? new Date(d) : undefined))",
                "      : [dates, undefined];",
                "    if ((from && sameDay(date, from)) || (to && sameDay(date, to))) {",
                "      result = 2;",
                "    } else if (",
                "      from &&",
                "      sameDayOrAfter(date, from) &&",
                "      to &&",
                "      sameDayOrBefore(date, to)",
                "    ) {",
                "      result = 1;",
                "    }",
                "  } else {",
                "    result = 1;",
                "  }",
                "  return result;",
                "};",
                "",
                "// withinDates takes an array of string dates or 2 element arrays and",
                "// checks whether the supplied date matches any string or is between",
                "// any dates in arrays.",
                "// returns 2 if exact match, 1 if between, undefined otherwise",
                "export const withinDates = (date, dates) => {",
                "  let result;",
                "  if (dates) {",
                "    if (Array.isArray(dates)) {",
                "      dates.some((d) => {",
                "        if (d instanceof Date) {",
                "          if (sameDay(date, d)) {",
                "            result = 2;",
                "          }",
                "        } else {",
                "          result = betweenDates(date, d);",
                "        }",
                "        return result;",
                "      });",
                "    } else if (sameDay(date, dates)) {",
                "      result = 2;",
                "    }",
                "  }",
                "  return result;",
                "};",
                "",
                "export const handleOffset = (date) => {",
                "  const normalizedDate = new Date(date);",
                "  const offset = normalizedDate.getTimezoneOffset();",
                "  const hour = normalizedDate.getHours();",
                "  // add back offset",
                "  normalizedDate.setHours(hour, offset < 0 ? -offset : offset);",
                "",
                "  return normalizedDate;",
                "};"
            ]
        },
        "4": {
            "function_name": "betweenDates (not found) ",
            "file_path": "src/js/components/Calendar/utils.js",
            "function_details": [
                {
                    "name": "betweenDates",
                    "start_line": 1,
                    "end_line": 130
                }
            ],
            "function_code": [
                "// Utility functions for the Calendar.",
                "// Just what's needed to avoid having to include a dependency like momentjs.",
                "",
                "const DAY_MILLISECONDS = 24 * 60 * 60 * 1000;",
                "",
                "export const addDays = (date, days) => {",
                "  const result = new Date(date.getTime() + DAY_MILLISECONDS * days);",
                "  // Deal with crossing the daylight savings time boundary,",
                "  // where adding a day's worth when the time is midnight results in",
                "  // being a day off.",
                "  let hourDelta = result.getHours() - date.getHours();",
                "  // At this point, hourDelta is typically 0 (normal day),",
                "  // +23 (November daylight saving), or -23 (March Daylight saving)",
                "  // depending on which side of the switch we are on.",
                "  // Convert so that hourDelta is either +1 or -1.",
                "  if (hourDelta === 23) {",
                "    hourDelta -= 24;",
                "  } else if (hourDelta === -23) {",
                "    hourDelta += 24;",
                "  }",
                "  result.setHours(result.getHours() - hourDelta);",
                "  return result;",
                "};",
                "",
                "export const subtractDays = (date, days) => addDays(date, -days);",
                "",
                "export const addMonths = (date, months) => {",
                "  const result = new Date(date);",
                "  const years = Math.floor((date.getMonth() + months) / 12);",
                "  result.setFullYear(date.getFullYear() + years);",
                "  const targetMonth = (date.getMonth() + months) % 12;",
                "  result.setMonth(targetMonth < 0 ? 12 + targetMonth : targetMonth);",
                "  return result;",
                "};",
                "",
                "export const subtractMonths = (date, months) => addMonths(date, -months);",
                "",
                "export const startOfMonth = (date) => {",
                "  const result = new Date(date);",
                "  result.setDate(1);",
                "  return result;",
                "};",
                "",
                "export const endOfMonth = (date) => {",
                "  const result = addMonths(date, 1);",
                "  result.setDate(0);",
                "  return result;",
                "};",
                "",
                "export const sameDay = (date1, date2) =>",
                "  date1.getFullYear() === date2.getFullYear() &&",
                "  date1.getMonth() === date2.getMonth() &&",
                "  date1.getDate() === date2.getDate();",
                "",
                "export const sameDayOrAfter = (date1, date2) =>",
                "  date1.getFullYear() > date2.getFullYear() ||",
                "  (date1.getFullYear() === date2.getFullYear() &&",
                "    (date1.getMonth() > date2.getMonth() ||",
                "      (date1.getMonth() === date2.getMonth() &&",
                "        date1.getDate() >= date2.getDate())));",
                "",
                "export const sameDayOrBefore = (date1, date2) =>",
                "  date1.getFullYear() < date2.getFullYear() ||",
                "  (date1.getFullYear() === date2.getFullYear() &&",
                "    (date1.getMonth() < date2.getMonth() ||",
                "      (date1.getMonth() === date2.getMonth() &&",
                "        date1.getDate() <= date2.getDate())));",
                "",
                "export const daysApart = (date1, date2) =>",
                "  Math.floor((date1.getTime() - date2.getTime()) / DAY_MILLISECONDS);",
                "",
                "// betweenDates takes an array of two elements and checks if the",
                "// supplied date lies between them, inclusive.",
                "// returns 2 if exact match to one end, 1 if between, undefined otherwise",
                "export const betweenDates = (date, dates) => {",
                "  let result;",
                "  if (dates) {",
                "    const [from, to] = Array.isArray(dates)",
                "      ? dates.map((d) => (d ? new Date(d) : undefined))",
                "      : [dates, undefined];",
                "    if ((from && sameDay(date, from)) || (to && sameDay(date, to))) {",
                "      result = 2;",
                "    } else if (",
                "      from &&",
                "      sameDayOrAfter(date, from) &&",
                "      to &&",
                "      sameDayOrBefore(date, to)",
                "    ) {",
                "      result = 1;",
                "    }",
                "  } else {",
                "    result = 1;",
                "  }",
                "  return result;",
                "};",
                "",
                "// withinDates takes an array of string dates or 2 element arrays and",
                "// checks whether the supplied date matches any string or is between",
                "// any dates in arrays.",
                "// returns 2 if exact match, 1 if between, undefined otherwise",
                "export const withinDates = (date, dates) => {",
                "  let result;",
                "  if (dates) {",
                "    if (Array.isArray(dates)) {",
                "      dates.some((d) => {",
                "        if (d instanceof Date) {",
                "          if (sameDay(date, d)) {",
                "            result = 2;",
                "          }",
                "        } else {",
                "          result = betweenDates(date, d);",
                "        }",
                "        return result;",
                "      });",
                "    } else if (sameDay(date, dates)) {",
                "      result = 2;",
                "    }",
                "  }",
                "  return result;",
                "};",
                "",
                "export const handleOffset = (date) => {",
                "  const normalizedDate = new Date(date);",
                "  const offset = normalizedDate.getTimezoneOffset();",
                "  const hour = normalizedDate.getHours();",
                "  // add back offset",
                "  normalizedDate.setHours(hour, offset < 0 ? -offset : offset);",
                "",
                "  return normalizedDate;",
                "};"
            ]
        },
        "5": {
            "function_name": "getOutputFormat (not found) 170-670",
            "file_path": "src/js/components/Calendar/Calendar.js",
            "function_details": [
                {
                    "name": "getOutputFormat",
                    "start_line": 170,
                    "end_line": 670
                }
            ],
            "function_code": [
                "export const getOutputFormat = (dates) => {",
                "  if (typeof dates === 'string' && dates?.indexOf('T') === -1) {",
                "    return 'no timezone';",
                "  }",
                "  if (Array.isArray(dates)) {",
                "    return getOutputFormat(dates[0]);",
                "  }",
                "  return 'date timezone';",
                "};",
                "",
                "const millisecondsPerYear = 31557600000;",
                "",
                "const CalendarDayButton = (props) => <Button tabIndex={-1} plain {...props} />;",
                "",
                "const CalendarDay = ({",
                "  children,",
                "  fill,",
                "  size,",
                "  isInRange,",
                "  isSelected,",
                "  otherMonth,",
                "  buttonProps = {},",
                "}) => (",
                "  <StyledDayContainer role=\"gridcell\" sizeProp={size} fillContainer={fill}>",
                "    <CalendarDayButton fill={fill} {...buttonProps}>",
                "      <StyledDay",
                "        disabledProp={buttonProps.disabled}",
                "        inRange={isInRange}",
                "        otherMonth={otherMonth}",
                "        isSelected={isSelected}",
                "        sizeProp={size}",
                "        fillContainer={fill}",
                "      >",
                "        {children}",
                "      </StyledDay>",
                "    </CalendarDayButton>",
                "  </StyledDayContainer>",
                ");",
                "",
                "const CalendarCustomDay = ({ children, fill, size, buttonProps }) => {",
                "  if (!buttonProps) {",
                "    return (",
                "      <StyledDayContainer role=\"gridcell\" sizeProp={size} fillContainer={fill}>",
                "        {children}",
                "      </StyledDayContainer>",
                "    );",
                "  }",
                "",
                "  return (",
                "    <StyledDayContainer role=\"gridcell\" sizeProp={size} fillContainer={fill}>",
                "      <CalendarDayButton fill={fill} {...buttonProps}>",
                "        {children}",
                "      </CalendarDayButton>",
                "    </StyledDayContainer>",
                "  );",
                "};",
                "",
                "const Calendar = forwardRef(",
                "  (",
                "    {",
                "      activeDate: activeDateProp,",
                "      animate = true,",
                "      bounds: boundsProp,",
                "      children,",
                "      date: dateProp,",
                "      dates: datesProp,",
                "      daysOfWeek,",
                "      disabled,",
                "      initialFocus, // internal only for DateInput",
                "      fill,",
                "      firstDayOfWeek = 0,",
                "      header,",
                "      locale = 'en-US',",
                "      messages,",
                "      onReference,",
                "      onSelect,",
                "      range,",
                "      reference: referenceProp,",
                "      showAdjacentDays = true,",
                "      size = 'medium',",
                "      timestamp: timestampProp,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const theme = useContext(ThemeContext) || defaultProps.theme;",
                "    const announce = useContext(AnnounceContext);",
                "    const { format } = useContext(MessageContext);",
                "",
                "    // when mousedown, we don't want to let Calendar set",
                "    // active date to firstInMonth",
                "    const [mouseDown, setMouseDown] = useState(false);",
                "    const onMouseDown = () => setMouseDown(true);",
                "    const onMouseUp = () => setMouseDown(false);",
                "    useEffect(() => {",
                "      document.addEventListener('mousedown', onMouseDown);",
                "      document.addEventListener('mouseup', onMouseUp);",
                "      return () => {",
                "        document.removeEventListener('mousedown', onMouseDown);",
                "        document.removeEventListener('mouseup', onMouseUp);",
                "      };",
                "    }, []);",
                "",
                "    // set activeDate when caller changes it, allows us to change",
                "    // it internally too",
                "    const [activeDate, setActiveDate] = useState(",
                "      dateProp && typeof dateProp === 'string' && range ? 'end' : 'start',",
                "    );",
                "    useEffect(() => {",
                "      if (activeDateProp) setActiveDate(activeDateProp);",
                "    }, [activeDateProp]);",
                "",
                "    const [value, setValue] = useState(normalizeInput(dateProp || datesProp));",
                "    useEffect(() => {",
                "      const val = dateProp || datesProp;",
                "      setValue(normalizeInput(val));",
                "    }, [dateProp, datesProp]);",
                "",
                "    const [reference, setReference] = useState(",
                "      getReference(normalizeInput(referenceProp), value),",
                "    );",
                "    useEffect(() => {",
                "      if (value) {",
                "        setReference(getReference(normalizeInput(referenceProp), value));",
                "      }",
                "    }, [referenceProp, value]);",
                "",
                "    const [outputFormat, setOutputFormat] = useState(",
                "      getOutputFormat(dateProp || datesProp),",
                "    );",
                "    useEffect(() => {",
                "      setOutputFormat(getOutputFormat(dateProp || datesProp));",
                "    }, [dateProp, datesProp]);",
                "",
                "    // normalize bounds",
                "    const [bounds, setBounds] = useState(boundsProp);",
                "    useEffect(() => {",
                "      if (boundsProp) setBounds(boundsProp);",
                "      else setBounds(undefined);",
                "    }, [boundsProp]);",
                "",
                "    // calculate the bounds we display based on the reference",
                "    const [displayBounds, setDisplayBounds] = useState(",
                "      buildDisplayBounds(reference, firstDayOfWeek),",
                "    );",
                "    const [targetDisplayBounds, setTargetDisplayBounds] = useState();",
                "    const [slide, setSlide] = useState();",
                "    const [animating, setAnimating] = useState();",
                "",
                "    // When the reference changes, we need to update the displayBounds.",
                "    // This is easy when we aren't animating. If we are animating,",
                "    // we temporarily increase the displayBounds to be the union of the old",
                "    // and new ones and set slide to drive the animation. We keep track",
                "    // of where we are heading via targetDisplayBounds. When the animation",
                "    // finishes, we prune displayBounds down to where we are headed and",
                "    // clear the slide and targetDisplayBounds.",
                "    useEffect(() => {",
                "      const nextDisplayBounds = buildDisplayBounds(reference, firstDayOfWeek);",
                "",
                "      // Checks if the difference between the current and next DisplayBounds is",
                "      // greater than a year. If that's the case, calendar should update without",
                "      // animation.",
                "      if (",
                "        nextDisplayBounds[0].getTime() !== displayBounds[0].getTime() &&",
                "        nextDisplayBounds[1].getTime() !== displayBounds[1].getTime()",
                "      ) {",
                "        let diffBoundsAboveYear = false;",
                "        if (nextDisplayBounds[0].getTime() < displayBounds[0].getTime()) {",
                "          if (",
                "            displayBounds[0].getTime() - nextDisplayBounds[0].getTime() >",
                "            millisecondsPerYear",
                "          ) {",
                "            diffBoundsAboveYear = true;",
                "          }",
                "        } else if (",
                "          nextDisplayBounds[1].getTime() > displayBounds[1].getTime()",
                "        ) {",
                "          if (",
                "            nextDisplayBounds[1].getTime() - displayBounds[1].getTime() >",
                "            millisecondsPerYear",
                "          ) {",
                "            diffBoundsAboveYear = true;",
                "          }",
                "        }",
                "        if (!animate || diffBoundsAboveYear) {",
                "          setDisplayBounds(nextDisplayBounds);",
                "        } else {",
                "          setTargetDisplayBounds(nextDisplayBounds);",
                "        }",
                "      }",
                "    }, [animate, firstDayOfWeek, reference, displayBounds]);",
                "",
                "    useEffect(() => {",
                "      // if the reference timezone has changed (e.g., controlled component),",
                "      // both ends of the displayBounds should inherit that new timestamp",
                "      if (targetDisplayBounds) {",
                "        if (",
                "          targetDisplayBounds[0].getTime() < displayBounds[0].getTime() ||",
                "          targetDisplayBounds[1].getTime() > displayBounds[1].getTime()",
                "        ) {",
                "          setDisplayBounds([targetDisplayBounds[0], targetDisplayBounds[1]]);",
                "        }",
                "        if (targetDisplayBounds[0].getTime() < displayBounds[0].getTime()) {",
                "          // only animate if the duration is within a year",
                "          if (",
                "            displayBounds[0].getTime() - targetDisplayBounds[0].getTime() <",
                "              millisecondsPerYear &&",
                "            daysApart(displayBounds[0], targetDisplayBounds[0])",
                "          ) {",
                "            setSlide({",
                "              direction: 'down',",
                "              weeks: daysApart(displayBounds[0], targetDisplayBounds[0]) / 7,",
                "            });",
                "            setAnimating(true);",
                "          }",
                "        } else if (",
                "          targetDisplayBounds[1].getTime() > displayBounds[1].getTime()",
                "        ) {",
                "          if (",
                "            targetDisplayBounds[1].getTime() - displayBounds[1].getTime() <",
                "              millisecondsPerYear &&",
                "            daysApart(targetDisplayBounds[1], displayBounds[1])",
                "          ) {",
                "            setSlide({",
                "              direction: 'up',",
                "              weeks: daysApart(targetDisplayBounds[1], displayBounds[1]) / 7,",
                "            });",
                "            setAnimating(true);",
                "          }",
                "        }",
                "        return undefined;",
                "      }",
                "",
                "      setSlide(undefined);",
                "      return undefined;",
                "    }, [animating, displayBounds, targetDisplayBounds]);",
                "",
                "    // Last step in updating the displayBounds. Allows for pruning",
                "    // displayBounds and cleaning up states to occur after animation.",
                "    useEffect(() => {",
                "      if (animating && targetDisplayBounds) {",
                "        // Wait for animation to finish before cleaning up.",
                "        const timer = setTimeout(",
                "          () => {",
                "            setDisplayBounds(targetDisplayBounds);",
                "            setTargetDisplayBounds(undefined);",
                "            setSlide(undefined);",
                "            setAnimating(false);",
                "          },",
                "          400, // Empirically determined.",
                "        );",
                "        return () => clearTimeout(timer);",
                "      }",
                "      return undefined;",
                "    }, [animating, targetDisplayBounds]);",
                "",
                "    // We have to deal with reference being the end of a month with more",
                "    // days than the month we are changing to. So, we always set reference",
                "    // to the first of the month before changing the month.",
                "    const previousMonth = useMemo(",
                "      () => endOfMonth(subtractMonths(startOfMonth(reference), 1)),",
                "      [reference],",
                "    );",
                "    const nextMonth = useMemo(",
                "      () => startOfMonth(addMonths(startOfMonth(reference), 1)),",
                "      [reference],",
                "    );",
                "",
                "    const daysRef = useRef();",
                "    const [focus, setFocus] = useState();",
                "    const [active, setActive] = useState();",
                "",
                "    useEffect(() => {",
                "      if (initialFocus === 'days') daysRef.current.focus();",
                "    }, [initialFocus]);",
                "",
                "    const changeReference = useCallback(",
                "      (nextReference) => {",
                "        if (betweenDates(nextReference, bounds)) {",
                "          setReference(nextReference);",
                "          if (onReference) onReference(nextReference.toISOString());",
                "        }",
                "      },",
                "      [onReference, bounds],",
                "    );",
                "",
                "    const handleRange = useCallback(",
                "      (selectedDate) => {",
                "        let result;",
                "        const priorRange = normalizeRange(value, activeDate);",
                "        // deselect when date clicked was the start/end of the range",
                "        if (selectedDate.getTime() === priorRange?.[0]?.[0]?.getTime()) {",
                "          result = [[undefined, priorRange[0][1]]];",
                "          setActiveDate('start');",
                "        } else if (selectedDate.getTime() === priorRange?.[0]?.[1]?.getTime()) {",
                "          result = [[priorRange[0][0], undefined]];",
                "          setActiveDate('end');",
                "        }",
                "        // selecting start date",
                "        else if (activeDate === 'start') {",
                "          if (!priorRange) {",
                "            result = [[selectedDate, undefined]];",
                "          } else if (!priorRange[0][1]) {",
                "            result = [[selectedDate, priorRange[0][1]]];",
                "          } else if (selectedDate.getTime() < priorRange[0][1].getTime()) {",
                "            result = [[selectedDate, priorRange[0][1]]];",
                "          } else if (selectedDate.getTime() > priorRange[0][1].getTime()) {",
                "            result = [[selectedDate, undefined]];",
                "          }",
                "          setActiveDate('end');",
                "        }",
                "        // selecting end date",
                "        else if (!priorRange) {",
                "          result = [[undefined, selectedDate]];",
                "          setActiveDate('start');",
                "        } else if (selectedDate.getTime() < priorRange[0][0].getTime()) {",
                "          result = [[selectedDate, undefined]];",
                "          setActiveDate('end');",
                "        } else if (selectedDate.getTime() > priorRange[0][0].getTime()) {",
                "          result = [[priorRange[0][0], selectedDate]];",
                "          setActiveDate('start');",
                "        }",
                "",
                "        // If no dates selected, always return undefined; else format",
                "        // result according to specified range value.",
                "        if (result[0].includes(undefined)) {",
                "          if (range === 'array') {",
                "            result = !result[0][0] && !result[0][1] ? undefined : result;",
                "          } else {",
                "            result = result[0].find((d) => d !== undefined);",
                "          }",
                "        }",
                "        setValue(result);",
                "        return result;",
                "      },",
                "      [activeDate, value, range],",
                "    );",
                "",
                "    const selectDate = useCallback(",
                "      (selectedDate) => {",
                "        let nextValue;",
                "",
                "        if (range || Array.isArray(value?.[0])) {",
                "          nextValue = handleRange(selectedDate);",
                "        } else {",
                "          nextValue = selectedDate;",
                "        }",
                "",
                "        if (onSelect) {",
                "          nextValue = normalizeOutput(nextValue, outputFormat);",
                "          onSelect(nextValue);",
                "        }",
                "      },",
                "      [handleRange, onSelect, outputFormat, range, value],",
                "    );",
                "",
                "    const onClick = (selectedDate) => {",
                "      selectDate(selectedDate);",
                "      announce(",
                "        `Selected ${getLocaleString(selectedDate, locale)}`,",
                "        'assertive',",
                "      );",
                "      // Chrome moves the focus indicator to this button. Set",
                "      // the focus to the grid of days instead.",
                "      daysRef.current.focus();",
                "      setActive(selectedDate);",
                "    };",
                "",
                "    const renderCalendarHeader = () => {",
                "      const PreviousIcon =",
                "        size === 'small'",
                "          ? theme.calendar.icons.small.previous",
                "          : theme.calendar.icons.previous;",
                "",
                "      const NextIcon =",
                "        size === 'small'",
                "          ? theme.calendar.icons.small.next",
                "          : theme.calendar.icons.next;",
                "",
                "      return (",
                "        <Box direction=\"row\" justify=\"between\" align=\"center\">",
                "          <Box flex pad={{ horizontal: headingPadMap[size] || 'small' }}>",
                "            <Heading",
                "              level={",
                "                size === 'small'",
                "                  ? (theme.calendar.heading && theme.calendar.heading.level) ||",
                "                    4",
                "                  : ((theme.calendar.heading && theme.calendar.heading.level) ||",
                "                      4) - 1",
                "              }",
                "              size={size}",
                "              margin=\"none\"",
                "              overflowWrap=\"normal\"",
                "            >",
                "              {reference.toLocaleDateString(locale, {",
                "                month: 'long',",
                "                year: 'numeric',",
                "              })}",
                "            </Heading>",
                "          </Box>",
                "          <Box flex={false} direction=\"row\" align=\"center\">",
                "            <Button",
                "              a11yTitle={format({",
                "                id: 'calendar.previous',",
                "                messages,",
                "                values: {",
                "                  date: previousMonth.toLocaleDateString(locale, {",
                "                    month: 'long',",
                "                    year: 'numeric',",
                "                  }),",
                "                },",
                "              })}",
                "              icon={<PreviousIcon size={size !== 'small' ? size : undefined} />}",
                "              disabled={!betweenDates(previousMonth, bounds)}",
                "              onClick={() => {",
                "                changeReference(previousMonth);",
                "                announce(",
                "                  format({",
                "                    id: 'calendar.previousMove',",
                "                    messages,",
                "                    values: {",
                "                      date: previousMonth.toLocaleDateString(locale, {",
                "                        month: 'long',",
                "                        year: 'numeric',",
                "                      }),",
                "                    },",
                "                  }),",
                "                );",
                "              }}",
                "            />",
                "            <Button",
                "              a11yTitle={format({",
                "                id: 'calendar.next',",
                "                messages,",
                "                values: {",
                "                  date: nextMonth.toLocaleDateString(locale, {",
                "                    month: 'long',",
                "                    year: 'numeric',",
                "                  }),",
                "                },",
                "              })}",
                "              icon={<NextIcon size={size !== 'small' ? size : undefined} />}",
                "              disabled={!betweenDates(nextMonth, bounds)}",
                "              onClick={() => {",
                "                changeReference(nextMonth);",
                "                announce(",
                "                  format({",
                "                    id: 'calendar.nextMove',",
                "                    messages,",
                "                    values: {",
                "                      date: nextMonth.toLocaleDateString(locale, {",
                "                        month: 'long',",
                "                        year: 'numeric',",
                "                      }),",
                "                    },",
                "                  }),",
                "                );",
                "              }}",
                "            />",
                "          </Box>",
                "        </Box>",
                "      );",
                "    };",
                "",
                "    const renderDaysOfWeek = () => {",
                "      let day = new Date(displayBounds[0]);",
                "      const days = [];",
                "      while (days.length < 7) {",
                "        days.push(",
                "          <StyledDayContainer",
                "            role=\"gridcell\"",
                "            key={days.length}",
                "            sizeProp={size}",
                "            fillContainer={fill}",
                "          >",
                "            <StyledDay otherMonth sizeProp={size} fillContainer={fill}>",
                "              {day.toLocaleDateString(locale, { weekday: 'narrow' })}",
                "            </StyledDay>",
                "          </StyledDayContainer>,",
                "        );",
                "        day = addDays(day, 1);",
                "      }",
                "      return <StyledWeek role=\"row\">{days}</StyledWeek>;",
                "    };",
                "",
                "    const weeks = [];",
                "    let day = new Date(displayBounds[0]);",
                "    let days;",
                "    let firstDayInMonth;",
                "    let blankWeek = false;",
                "",
                "    while (day.getTime() < displayBounds[1].getTime()) {",
                "      if (day.getDay() === firstDayOfWeek) {",
                "        if (days) {",
                "          weeks.push(",
                "            <StyledWeek role=\"row\" key={day.getTime()} fillContainer={fill}>",
                "              {days}",
                "            </StyledWeek>,",
                "          );",
                "        }",
                "        days = [];"
            ]
        }
    }
}