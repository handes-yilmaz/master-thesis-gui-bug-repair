{
    "1": {
        "bug_file": "src/js/components/DataFilters/DataFilters.js",
        "compressed": "NO",
        "line_numbers": 137,
        "compressed_line_numbers": 137,
        "compressed_bug_file_content": "import React, { Children, useContext, useMemo, useState } from 'react';\nimport { Filter } from 'grommet-icons/icons/Filter';\nimport { Box } from '../Box';\nimport { Button } from '../Button';\nimport { DataFilter } from '../DataFilter';\nimport { DataForm } from '../Data/DataForm';\nimport { DataSort } from '../DataSort';\nimport { DropButton } from '../DropButton';\nimport { Header } from '../Header';\nimport { Heading } from '../Heading';\nimport { DataContext } from '../../contexts/DataContext';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { DataFiltersPropTypes } from './propTypes';\n\nconst dropProps = {\n  align: { top: 'bottom', right: 'right' },\n};\n\nexport const DataFilters = ({ drop, children, heading, ...rest }) => {\n  const { clearFilters, data, messages, properties, view } =\n    useContext(DataContext);\n  const { format } = useContext(MessageContext);\n  const [showContent, setShowContent] = useState();\n  // touched is a map of form field name to its value, it only has fields that\n  // were changed as part of the DataForm here. This is so we can track based\n  // on what's inside DataFilters as opposed to trying to track from the view\n  // object.\n  const [touched, setTouched] = useState({});\n  const controlled = useMemo(() => drop, [drop]);\n  // generate the badge value based on touched fields that have a value\n  const badge = useMemo(\n    () =>\n      (controlled && Object.keys(touched).filter((k) => touched[k]).length) ||\n      undefined,\n    [controlled, touched],\n  );\n\n  const clearControl = badge && (\n    <Box flex={false}>\n      <Button\n        label={format({\n          id: 'dataFilters.clear',\n          messages: messages?.dataFilters,\n        })}\n        onClick={() => {\n          setTouched({});\n          clearFilters();\n        }}\n      />\n    </Box>\n  );\n\n  let filters;\n  if (Children.count(children) === 0) {\n    let filtersFor;\n    if (!properties && data && data.length)\n      // build from a piece of data, ignore object values\n      filtersFor = Object.keys(data[0]).filter(\n        (k) => typeof data[0][k] !== 'object',\n      );\n    else if (Array.isArray(properties)) filtersFor = properties;\n    else if (typeof properties === 'object')\n      filtersFor = Object.keys(properties);\n    else filtersFor = [];\n    filters = filtersFor.map((property) => (\n      <DataFilter key={property} property={property} />\n    ));\n    if (view?.sort) {\n      filters.push(<DataSort key=\"_sort\" />);\n    }\n  }\n\n  const content = (\n    <DataForm\n      pad={controlled ? 'medium' : undefined}\n      gap=\"small\"\n      onDone={() => setShowContent(false)}\n      onTouched={\n        controlled\n          ? (currentTouched) =>\n              // we merge this with our prior state to handle the case where the\n              // user opens and closes the drop multiple times and we want to\n              // track both new changes and prior changes.\n              setTouched((prevTouched) => ({\n                ...prevTouched,\n                ...currentTouched,\n              }))\n          : undefined\n      }\n      {...(!controlled ? rest : {})}\n    >\n      {!drop && (\n        <Header>\n          <Heading margin=\"none\" level={2} size=\"small\">\n            {heading ||\n              format({\n                id: 'dataFilters.heading',\n                messages: messages?.dataFilters,\n              })}\n          </Heading>\n          {!controlled && clearControl}\n        </Header>\n      )}\n      {filters}\n      {children}\n    </DataForm>\n  );\n\n  if (!controlled) return content;\n\n  // drop\n  const control = (\n    <DropButton\n      aria-label={format({\n        id: 'dataFilters.open',\n        messages: messages?.dataFilters,\n      })}\n      kind=\"toolbar\"\n      icon={<Filter />}\n      dropProps={dropProps}\n      dropContent={content}\n      badge={badge}\n      open={showContent}\n      onOpen={() => setShowContent(undefined)}\n      onClose={() => setShowContent(undefined)}\n    />\n  );\n\n  return (\n    <Box flex={false} direction=\"row\" gap=\"small\" {...rest}>\n      {control}\n      {clearControl}\n    </Box>\n  );\n};\n\nDataFilters.propTypes = DataFiltersPropTypes;"
    },
    "2": {
        "bug_file": "src/js/components/DataFilters/propTypes.js",
        "compressed": "NO",
        "line_numbers": 10,
        "compressed_line_numbers": 10,
        "compressed_bug_file_content": "import PropTypes from 'prop-types';\n\nlet PropType = {};\nif (process.env.NODE_ENV !== 'production') {\n  PropType = {\n    drop: PropTypes.bool,\n    heading: PropTypes.string,\n  };\n}\nexport const DataFiltersPropTypes = PropType;"
    }
}