{
    "src/js/components/DataTable/Header.js": [
        "/* eslint-disable no-underscore-dangle */",
        "import React, {",
        "  forwardRef,",
        "  useCallback,",
        "  useContext,",
        "  useEffect,",
        "  useState,",
        "} from 'react';",
        "import styled, { css, ThemeContext } from 'styled-components';",
        "",
        "import { defaultProps } from '../../default-props';",
        "",
        "import { Box } from '../Box';",
        "import { Button } from '../Button';",
        "import { CheckBox } from '../CheckBox';",
        "import { TableCell, verticalAlignToJustify } from '../TableCell/TableCell';",
        "import { Text } from '../Text';",
        "",
        "import { Resizer } from './Resizer';",
        "import { Searcher } from './Searcher';",
        "import { ExpanderCell } from './ExpanderCell';",
        "import {",
        "  StyledDataTableCell,",
        "  StyledDataTableHeader,",
        "  StyledDataTableRow,",
        "} from './StyledDataTable';",
        "import { datumValue } from './buildState';",
        "import { kindPartStyles } from '../../utils/styles';",
        "import { normalizeColor } from '../../utils/colors';",
        "",
        "// separate theme values into groupings depending on what",
        "// part of header cell they should style",
        "const separateThemeProps = (theme) => {",
        "  const {",
        "    background, // covered by cellProps",
        "    border, // covered by cellProps",
        "    color,",
        "    font,",
        "    gap, // gap is used for space between header cell elements only",
        "    pad, // covered by cellProps",
        "    units,",
        "    ...rest",
        "  } = theme.dataTable.header;",
        "",
        "  const textProps = { color, ...font };",
        "  const iconProps = { color };",
        "  const layoutProps = { ...rest };",
        "",
        "  return [layoutProps, textProps, iconProps];",
        "};",
        "",
        "// build up CSS from basic to specific based on the supplied sub-object paths.",
        "// adapted from StyledButtonKind to only include parts relevant for DataTable",
        "const buttonStyle = ({ pad, theme, verticalAlign }) => {",
        "  const styles = [];",
        "  const [layoutProps, , iconProps] = separateThemeProps(theme);",
        "",
        "  // if cell is sortable, we want pad to be applied",
        "  // to the button instead of the cell",
        "  if (pad) {",
        "    styles.push(kindPartStyles({ pad }, theme));",
        "  }",
        "",
        "  if (layoutProps) {",
        "    styles.push(kindPartStyles(layoutProps, theme));",
        "  }",
        "",
        "  if (layoutProps.hover) {",
        "    // CSS for this sub-object in the theme",
        "    const partStyles = kindPartStyles(layoutProps.hover, theme);",
        "    if (partStyles.length > 0)",
        "      styles.push(",
        "        css`",
        "          &:hover {",
        "            ${partStyles}",
        "          }",
        "        `,",
        "      );",
        "  }",
        "",
        "  if (iconProps.color) {",
        "    styles.push(",
        "      css`",
        "        svg {",
        "          stroke: ${normalizeColor(iconProps.color, theme)};",
        "          fill: ${normalizeColor(iconProps.color, theme)};",
        "        }",
        "      `,",
        "    );",
        "  }",
        "",
        "  let align = 'center';",
        "  if (verticalAlign === 'bottom') align = 'end';",
        "  if (verticalAlign === 'top') align = 'start';",
        "",
        "  if (verticalAlign) {",
        "    styles.push(",
        "      css`",
        "        display: inline-flex;",
        "        align-items: ${align};",
        "      `,",
        "    );",
        "  }",
        "",
        "  return styles;",
        "};",
        "",
        "const StyledHeaderCellButton = styled(Button)`",
        "  ${(props) => buttonStyle(props)}",
        "`;",
        "",
        "// allow extend to spread onto Box that surrounds column label",
        "const StyledContentBox = styled(Box)`",
        "  ${(props) => props.extend}",
        "`;",
        "",
        "const Header = forwardRef(",
        "  (",
        "    {",
        "      cellProps,",
        "      columns,",
        "      data,",
        "      disabled,",
        "      fill,",
        "      filtering,",
        "      filters,",
        "      groupBy,",
        "      groups,",
        "      groupState,",
        "      onFilter,",
        "      onFiltering,",
        "      onResize,",
        "      onSelect,",
        "      onSort,",
        "      onToggle,",
        "      onWidths,",
        "      pin: pinProp,",
        "      pinnedOffset,",
        "      primaryProperty,",
        "      selected,",
        "      rowDetails,",
        "      sort,",
        "      widths,",
        "      verticalAlign,",
        "      ...rest",
        "    },",
        "    ref,",
        "  ) => {",
        "    const theme = useContext(ThemeContext) || defaultProps.theme;",
        "    const [layoutProps, textProps] = separateThemeProps(theme);",
        "",
        "    const [cellWidths, setCellWidths] = useState([]);",
        "",
        "    const updateWidths = useCallback(",
        "      (width) => setCellWidths((values) => [...values, width]),",
        "      [],",
        "    );",
        "",
        "    useEffect(() => {",
        "      if (onWidths && cellWidths.length !== 0) {",
        "        onWidths(cellWidths);",
        "      }",
        "    }, [cellWidths, onWidths]);",
        "",
        "    const pin = pinProp ? ['top'] : [];",
        "    const selectPin = pinnedOffset?._grommetDataTableSelect",
        "      ? [...pin, 'left']",
        "      : pin;",
        "",
        "    const totalSelectedGroups = groupBy?.select",
        "      ? Object.keys(groupBy.select).reduce(",
        "          (total, cur) =>",
        "            cur && groupBy.select[cur] === 'all' ? total + 1 : total,",
        "          0,",
        "        )",
        "      : 0;",
        "    const totalSelected = (selected?.length || 0) + totalSelectedGroups;",
        "",
        "    const onChangeSelection = useCallback(() => {",
        "      let nextSelected;",
        "      const nextGroupSelected = {};",
        "",
        "      // Since some rows might be disabled but already selected, we need to",
        "      // note which rows are enabled when determining how aggregate selection",
        "      // works.",
        "      const primaryValues =",
        "        data.map((datum) => datumValue(datum, primaryProperty)) || [];",
        "      // enabled includes what can be changed",
        "      const enabled =",
        "        (disabled && primaryValues.filter((v) => !disabled.includes(v))) ||",
        "        primaryValues;",
        "      // enabledSelected includes what can be changed and is currently selected",
        "      const enabledSelected =",
        "        (selected && enabled.filter((v) => selected.includes(v))) ||",
        "        primaryValues;",
        "",
        "      const allSelected = groupBy?.select",
        "        ? groupBy.select[''] === 'all'",
        "        : enabledSelected.length === enabled.length;",
        "",
        "      if (allSelected) {",
        "        // if any are disabled and selected, leave those, otherwise clear",
        "        nextSelected = disabled",
        "          ? primaryValues.filter(",
        "              (v) => disabled.includes(v) && selected.includes(v),",
        "            )",
        "          : [];",
        "        nextGroupSelected[''] = 'none';",
        "      } else {",
        "        // if some or none are selected, select all enabled plus all disabled",
        "        // that are already selected",
        "        nextSelected = disabled",
        "          ? primaryValues.filter(",
        "              (v) => !disabled.includes(v) || selected.includes(v),",
        "            )",
        "          : primaryValues;",
        "        nextGroupSelected[''] = 'all';",
        "        groupBy?.expandable?.forEach((key) => {",
        "          nextGroupSelected[key] = 'all';",
        "        });",
        "      }",
        "      if (groupBy?.onSelect) {",
        "        groupBy.onSelect(nextSelected, undefined, nextGroupSelected);",
        "      } else onSelect(nextSelected);",
        "    }, [data, disabled, groupBy, onSelect, primaryProperty, selected]);",
        "",
        "    return (",
        "      <StyledDataTableHeader ref={ref} fillProp={fill} {...rest}>",
        "        <StyledDataTableRow>",
        "          {groups && (",
        "            <ExpanderCell",
        "              background={cellProps.background}",
        "              border={cellProps.border}",
        "              context=\"header\"",
        "              expanded={",
        "                Object.keys(groupState).filter((k) => !groupState[k].expanded)",
        "                  .length === 0",
        "              }",
        "              onToggle={onToggle}",
        "              pad={cellProps.pad}",
        "            />",
        "          )}",
        "",
        "          {(selected || onSelect) && (",
        "            <StyledDataTableCell",
        "              background={cellProps.background}",
        "              onWidth={updateWidths}",
        "              plain=\"noPad\"",
        "              size=\"auto\"",
        "              context=\"header\"",
        "              scope=\"col\"",
        "              pin={selectPin}",
        "              pinnedOffset={pinnedOffset?._grommetDataTableSelect}",
        "              verticalAlign={verticalAlign}",
        "            >",
        "              {onSelect && (",
        "                <CheckBox",
        "                  a11yTitle={",
        "                    totalSelected === data.length",
        "                      ? 'unselect all'",
        "                      : 'select all'",
        "                  }",
        "                  checked={",
        "                    groupBy?.select",
        "                      ? groupBy.select[''] === 'all'",
        "                      : totalSelected > 0 &&",
        "                        data.length > 0 &&",
        "                        totalSelected === data.length",
        "                  }",
        "                  indeterminate={",
        "                    groupBy?.select",
        "                      ? groupBy.select[''] === 'some'",
        "                      : totalSelected > 0 && totalSelected < data.length",
        "                  }",
        "                  onChange={onChangeSelection}",
        "                  pad={cellProps.pad}",
        "                />",
        "              )}",
        "            </StyledDataTableCell>",
        "          )}",
        "          {rowDetails && <TableCell size=\"xxsmall\" plain pad=\"none\" />}",
        "          {columns.map(",
        "            ({",
        "              property,",
        "              header,",
        "              align,",
        "              pin: columnPin,",
        "              search,",
        "              sortable,",
        "              verticalAlign: columnVerticalAlign, // depcrecate in v3",
        "              size,",
        "              units,",
        "            }) => {",
        "              let content;",
        "              const unitsContent = units ? (",
        "                <Text {...textProps} {...theme.dataTable.header.units}>",
        "                  {units}",
        "                </Text>",
        "              ) : undefined;",
        "              if (typeof header === 'string') {",
        "                content = <Text {...textProps}>{header}</Text>;",
        "                if (",
        "                  Object.keys(layoutProps).length &&",
        "                  (sortable === false || !onSort)",
        "                ) {",
        "                  // apply rest of layout styling if cell is not sortable,",
        "                  // otherwise this styling will be applied by",
        "                  // StyledHeaderCellButton",
        "                  content = (",
        "                    <StyledContentBox {...layoutProps}>",
        "                      {content}",
        "                    </StyledContentBox>",
        "                  );",
        "                }",
        "              } else content = header;",
        "",
        "              if (unitsContent) {",
        "                content = (",
        "                  <Box justify={align} direction=\"row\">",
        "                    {content}",
        "                    {unitsContent}",
        "                  </Box>",
        "                );",
        "              }",
        "",
        "              if (verticalAlign || columnVerticalAlign) {",
        "                const vertical = verticalAlign || columnVerticalAlign;",
        "                content = (",
        "                  <Box height=\"100%\" justify={verticalAlignToJustify[vertical]}>",
        "                    {content}",
        "                  </Box>",
        "                );",
        "              }",
        "",
        "              if (onSort && sortable !== false) {",
        "                let Icon;",
        "                if (onSort && sortable !== false) {",
        "                  if (sort && sort.property === property) {",
        "                    Icon =",
        "                      theme.dataTable.icons[",
        "                        sort.direction !== 'asc' ? 'ascending' : 'descending'",
        "                      ];",
        "                  } else if (theme.dataTable.icons.sortable) {",
        "                    Icon = theme.dataTable.icons.sortable;",
        "                  }",
        "                }",
        "",
        "                content = (",
        "                  <StyledHeaderCellButton",
        "                    plain",
        "                    column={property}",
        "                    fill=\"vertical\"",
        "                    onClick={onSort(property)}",
        "                    sort={sort}",
        "                    pad={cellProps.pad}",
        "                    sortable",
        "                    verticalAlign={verticalAlign || columnVerticalAlign}",
        "                  >",
        "                    <Box",
        "                      direction=\"row\"",
        "                      align=\"center\"",
        "                      gap=\"xsmall\"",
        "                      justify={align}",
        "                    >",
        "                      {content}",
        "                      {Icon && <Icon />}",
        "                    </Box>",
        "                  </StyledHeaderCellButton>",
        "                );",
        "              }",
        "",
        "              // content should fill any available space in cell",
        "              // If `onResize` or `search` is true we need to explicitly set",
        "              // fill because later if either of these props is true content",
        "              // will be wrapped with an additional Box, preventing this Box",
        "              // from automatically filling the vertical space.",
        "              content = (",
        "                <Box flex=\"grow\" fill={onResize || search ? 'vertical' : false}>",
        "                  {content}",
        "                </Box>",
        "              );",
        "",
        "              if (search || onResize) {",
        "                const resizer = onResize ? (",
        "                  <Resizer property={property} onResize={onResize} />",
        "                ) : null;",
        "                const searcher =",
        "                  search && filters ? (",
        "                    <Searcher",
        "                      filtering={filtering}",
        "                      filters={filters}",
        "                      property={property}",
        "                      onFilter={onFilter}",
        "                      onFiltering={onFiltering}",
        "                    />",
        "                  ) : null;",
        "                content = (",
        "                  <Box",
        "                    direction=\"row\"",
        "                    align=\"center\"",
        "                    justify={!align || align === 'start' ? 'between' : align}",
        "                    gap={theme.dataTable.header.gap}",
        "                    fill=\"vertical\"",
        "                    style={onResize ? { position: 'relative' } : undefined}",
        "                  >",
        "                    {content}",
        "                    {searcher && resizer ? (",
        "                      <Box",
        "                        flex=\"shrink\"",
        "                        direction=\"row\"",
        "                        align=\"center\"",
        "                        gap={theme.dataTable.header.gap}",
        "                      >",
        "                        {searcher}",
        "                        {resizer}",
        "                      </Box>",
        "                    ) : (",
        "                      searcher || resizer",
        "                    )}",
        "                  </Box>",
        "                );",
        "              }",
        "              const cellPin = [...pin];",
        "              if (columnPin) cellPin.push('left');",
        "",
        "              return (",
        "                <StyledDataTableCell",
        "                  key={property}",
        "                  align={align}",
        "                  context=\"header\"",
        "                  verticalAlign={verticalAlign || columnVerticalAlign}",
        "                  background={cellProps.background}",
        "                  border={cellProps.border}",
        "                  onWidth={updateWidths}",
        "                  // if sortable, pad will be included in the button styling",
        "                  pad={sortable === false || !onSort ? cellProps.pad : 'none'}",
        "                  pin={cellPin}",
        "                  plain",
        "                  pinnedOffset={pinnedOffset && pinnedOffset[property]}",
        "                  scope=\"col\"",
        "                  size={widths && widths[property] ? undefined : size}",
        "                  style={",
        "                    widths && widths[property]",
        "                      ? { width: widths[property] }",
        "                      : undefined",
        "                  }",
        "                >",
        "                  {content}",
        "                </StyledDataTableCell>",
        "              );",
        "            },",
        "          )}",
        "        </StyledDataTableRow>",
        "      </StyledDataTableHeader>",
        "    );",
        "  },",
        ");",
        "",
        "Header.displayName = 'Header';",
        "",
        "Header.defaultProps = {};",
        "Object.setPrototypeOf(Header.defaultProps, defaultProps);",
        "",
        "export { Header };"
    ],
    "src/js/components/DataTable/Sorter.js": [
        "import React, { useContext } from 'react';",
        "import styled, { ThemeContext } from 'styled-components';",
        "",
        "import { defaultProps } from '../../default-props';",
        "",
        "import { Button } from '../Button';",
        "import { Box } from '../Box';",
        "",
        "const SorterButton = styled(Button)`",
        "  flex-shrink: 1;",
        "  height: 100%;",
        "`;",
        "",
        "const Sorter = ({",
        "  align,",
        "  children,",
        "  fill,",
        "  onSort,",
        "  property,",
        "  sort,",
        "  themeProps,",
        "}) => {",
        "  const theme = useContext(ThemeContext) || defaultProps.theme;",
        "  let icon;",
        "  if (sort && sort.property === property) {",
        "    const Icon =",
        "      theme.dataTable.icons[sort.ascending ? 'ascending' : 'descending'];",
        "    icon = <Icon />;",
        "  }",
        "  let content = (",
        "    <Box",
        "      {...themeProps}",
        "      flex=\"shrink\"",
        "      direction=\"row\"",
        "      justify={align}",
        "      align=\"center\"",
        "      gap=\"xsmall\"",
        "      fill={fill}",
        "    >",
        "      {children}",
        "      {icon}",
        "    </Box>",
        "  );",
        "  if (onSort) {",
        "    content = (",
        "      <SorterButton fill={fill} hoverIndicator onClick={onSort(property)}>",
        "        {content}",
        "      </SorterButton>",
        "    );",
        "  }",
        "",
        "  return content;",
        "};",
        "",
        "Sorter.displayName = 'Sorter';",
        "",
        "Sorter.defaultProps = {};",
        "Object.setPrototypeOf(Sorter.defaultProps, defaultProps);",
        "",
        "export { Sorter };"
    ],
    "src/js/components/DataTable/buildState.js": [
        "// This file contains helper functions for DataTable, to keep the component",
        "// files simpler.",
        "",
        "export const set = (obj, path, value) => {",
        "  let parts = path;",
        "  if (Object(obj) !== obj) return obj;",
        "  if (!Array.isArray(path)) parts = path.toString().match(/[^.[\\]]+/g) || [];",
        "",
        "  parts.slice(0, -1).reduce((acc, item, index) => {",
        "    if (Object(acc[item]) === acc[item]) {",
        "      return acc[item];",
        "    }",
        "    acc[item] = Math.abs(parts[index + 1]) > 0 === +parts[index + 1] ? [] : {};",
        "    return acc[item];",
        "  }, obj)[parts[parts.length - 1]] = value;",
        "",
        "  return obj;",
        "};",
        "",
        "// get the value for the property in the datum object",
        "export const datumValue = (datum, property) => {",
        "  if (!property) return undefined;",
        "  const parts = property.split('.');",
        "  if (parts.length === 1) {",
        "    return datum[property];",
        "  }",
        "  if (!datum[parts[0]]) {",
        "    return undefined;",
        "  }",
        "  return datumValue(datum[parts[0]], parts.slice(1).join('.'));",
        "};",
        "",
        "// get the primary property name",
        "export const normalizePrimaryProperty = (columns, primaryKey) => {",
        "  let result;",
        "  columns.forEach((column) => {",
        "    // remember the first key property",
        "    if (column.primary && !result) {",
        "      result = column.property;",
        "    }",
        "  });",
        "  if (!result) {",
        "    if (primaryKey === false) result = undefined;",
        "    else if (primaryKey) result = primaryKey;",
        "    else if (columns.length > 0) result = columns[0].property;",
        "  }",
        "  return result;",
        "};",
        "",
        "// initialize filters with empty strings",
        "export const initializeFilters = (columns) => {",
        "  const result = {};",
        "  columns.forEach((column) => {",
        "    if (column.search) {",
        "      result[column.property] = '';",
        "    }",
        "  });",
        "  return result;",
        "};",
        "",
        "// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping",
        "const escapeRegExp = (input) => input.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');",
        "",
        "// filter data based on filters then sort",
        "export const filterAndSortData = (data, filters, onSearch, sort) => {",
        "  let result = data;",
        "  if (!onSearch) {",
        "    const regexps = {};",
        "    Object.keys(filters)",
        "      .filter((n) => filters[n])",
        "      .forEach((n) => {",
        "        regexps[n] = new RegExp(escapeRegExp(filters[n]), 'i');",
        "      });",
        "    if (Object.keys(regexps).length > 0) {",
        "      result = data.filter(",
        "        (datum) =>",
        "          !Object.keys(regexps).some(",
        "            (property) => !regexps[property].test(datumValue(datum, property)),",
        "          ),",
        "      );",
        "    }",
        "  }",
        "",
        "  if (sort && !sort.external) {",
        "    const { property, direction } = sort;",
        "    result = result === data ? [...data] : result; // don't sort caller's data",
        "    const sortAsc = direction === 'asc';",
        "    const before = sortAsc ? 1 : -1;",
        "    const after = sortAsc ? -1 : 1;",
        "    result.sort((d1, d2) => {",
        "      const d1Val = datumValue(d1, property);",
        "      const d2Val = datumValue(d2, property);",
        "      if ((typeof d1Val === 'string' && typeof d2Val === 'string') ||",
        "        (typeof d1Val === 'string' && !d2Val) ||",
        "        (typeof d2Val === 'string' && !d1Val)) {",
        "        const sortResult = (d1Val || '').localeCompare(d2Val || '', undefined, {",
        "          sensitivity: 'base',",
        "        });",
        "        return sortAsc ? sortResult : -sortResult;",
        "      }",
        "      if (d1Val > d2Val) return before;",
        "      if (d1Val < d2Val) return after;",
        "      return 0;",
        "    });",
        "  }",
        "",
        "  return result;",
        "};",
        "",
        "// aggregate reducers",
        "const sumReducer = (accumulated, next) => accumulated + next;",
        "const minReducer = (accumulated, next) =>",
        "  accumulated === undefined ? next : Math.min(accumulated, next);",
        "const maxReducer = (accumulated, next) =>",
        "  accumulated === undefined ? next : Math.max(accumulated, next);",
        "",
        "const reducers = {",
        "  max: maxReducer,",
        "  min: minReducer,",
        "  sum: sumReducer,",
        "};",
        "",
        "// aggregate reducers init values",
        "const reducersInitValues = {",
        "  min: Number.MAX_VALUE,",
        "  max: Number.MIN_VALUE,",
        "  sum: 0,",
        "};",
        "",
        "// aggregate a single column",
        "const aggregateColumn = (column, data) => {",
        "  let value;",
        "  if (column.aggregate === 'avg') {",
        "    value = data.map((d) => datumValue(d, column.property)).reduce(sumReducer);",
        "    value /= data.length;",
        "  } else {",
        "    value = data",
        "      .map((d) => datumValue(d, column.property))",
        "      .reduce(reducers[column.aggregate], reducersInitValues[column.aggregate]);",
        "  }",
        "  return value;",
        "};",
        "",
        "// aggregate all columns that can",
        "const aggregate = (columns, data) => {",
        "  let result = {};",
        "  columns.forEach((column) => {",
        "    if (column.aggregate) {",
        "      const value = aggregateColumn(column, data);",
        "      result = set(result, column.property, value);",
        "    }",
        "  });",
        "",
        "  return result;",
        "};",
        "",
        "// build the values for the footer cells",
        "export const buildFooterValues = (columns, data) => {",
        "  const aggregateValues = aggregate(columns, data);",
        "",
        "  let result = {};",
        "  columns.forEach((column) => {",
        "    if (column.footer) {",
        "      if (column.footer.aggregate) {",
        "        const value = datumValue(aggregateValues, column.property);",
        "        result = set(result, column.property, value);",
        "      } else {",
        "        result = set(result, column.property, column.footer);",
        "      }",
        "    }",
        "  });",
        "",
        "  return result;",
        "};",
        "",
        "// looks at the groupBy property of each data object and returns an",
        "// array with one item for each unique value of that property.",
        "export const buildGroups = (columns, data, groupBy, primaryProperty) => {",
        "  let result;",
        "  if (groupBy?.property || typeof groupBy === 'string') {",
        "    result = [];",
        "    const groupMap = {};",
        "    data.forEach((datum) => {",
        "      const key = datumValue(datum, primaryProperty);",
        "      const isGroup = key && groupBy.expandable?.includes(key);",
        "",
        "      const groupByProperty = groupBy.property ? groupBy.property : groupBy;",
        "      const groupValue = isGroup ? key : datumValue(datum, groupByProperty);",
        "      if (!groupMap[groupValue]) {",
        "        const group = {",
        "          data: [],",
        "          datum: isGroup ? datum : {},",
        "          key: groupValue,",
        "        };",
        "        group.datum[groupByProperty] = groupValue;",
        "        result.push(group);",
        "        groupMap[groupValue] = group;",
        "      }",
        "      if (!isGroup) groupMap[groupValue].data.push(datum);",
        "    });",
        "",
        "    // include any aggregate column values across the data for each group",
        "    // If expandable was specified we let the onUpdate callback do it since",
        "    // we may not have access to all the data to aggregate it.",
        "    if (!groupBy.expandable) {",
        "      columns.forEach((column) => {",
        "        if (column.aggregate) {",
        "          result.forEach((group) => {",
        "            const { datum } = group;",
        "            datum[column.property] = aggregateColumn(column, group.data);",
        "          });",
        "        }",
        "      });",
        "    }",
        "  } else if (groupBy?.expandable) {",
        "    result = groupBy.expandable.map((key) => ({ data: [], datum: {}, key }));",
        "  }",
        "",
        "  return result;",
        "};",
        "",
        "// build group expanded state, expanding any in groupBy.expand",
        "export const buildGroupState = (groups, groupBy) => {",
        "  const result = {};",
        "  if (groups) {",
        "    groups.forEach(({ key }) => {",
        "      if (key) result[key] = { expanded: false };",
        "    });",
        "  }",
        "  if (groupBy && groupBy.expand) {",
        "    groupBy.expand.forEach((value) => {",
        "      result[value] = { expanded: true };",
        "    });",
        "  }",
        "  return result;",
        "};",
        "",
        "export const normalizeBackgroundColor = (theme) => {",
        "  const { background } = theme; // context background",
        "  if (typeof background === 'string') return background;",
        "  if (background.light && background.dark) return background;",
        "  if (background.color) return background.color;",
        "  return undefined;",
        "};",
        "",
        "export const normalizeRowProp = (name, rowProp, prop) => {",
        "  if (rowProp && rowProp[name]) return rowProp[name];",
        "  return prop;",
        "};",
        "",
        "const tableContextNames = ['header', 'body', 'footer'];",
        "const cellPropertyNames = ['background', 'border', 'pad'];",
        "",
        "// Convert property specific cell props to context specific cell props.",
        "// For example, background={{ header: { background } }}",
        "// will become cellProps.header.background",
        "export const normalizeCellProps = (props, theme) => {",
        "  const result = {};",
        "  tableContextNames.forEach((context) => {",
        "    result[context] = { pinned: {} };",
        "    cellPropertyNames.forEach((propName) => {",
        "      let value =",
        "        props?.[propName]?.[context] ||",
        "        // if the propName is used without context, it applies to all contexts",
        "        (tableContextNames.every((n) => !props?.[propName]?.[n]) &&",
        "          props?.[propName]) ||",
        "        theme?.dataTable?.[context]?.[propName] ||",
        "        theme?.table?.[context]?.[propName];",
        "      if (value !== undefined) result[context][propName] = value;",
        "",
        "      // pinned case",
        "      value =",
        "        props?.[propName]?.pinned?.[context] ||",
        "        (context === 'body' &&",
        "          tableContextNames.every((n) => !props?.[propName]?.pinned?.[n]) &&",
        "          props?.[propName]?.pinned) ||",
        "        theme?.dataTable?.pinned?.[context]?.[propName];",
        "      if (value !== undefined) {",
        "        if (",
        "          propName === 'background' &&",
        "          theme.background &&",
        "          value.opacity &&",
        "          !value.color",
        "        )",
        "          // theme context has an active background color but the",
        "          // theme doesn't set an explicit color, repeat the context",
        "          // background explicitly",
        "          value.color = normalizeBackgroundColor(theme);",
        "",
        "        if (context === 'body')",
        "          // in case we have pinned columns, store the pinned stuff in",
        "          // cellProps.body.pinned",
        "          result[context].pinned[propName] = value;",
        "        else if (props.pin === true || props.pin === context)",
        "          // this context is pinned, use the pinned value directly",
        "          result[context][propName] = value;",
        "      }",
        "    });",
        "  });",
        "  return result;",
        "};",
        "",
        "export const normalizeRowCellProps = (",
        "  rowProps,",
        "  cellProps,",
        "  primaryKey,",
        "  index,",
        ") => {",
        "  const result = { pinned: {} };",
        "  ['background', 'border', 'pad'].forEach((propName) => {",
        "    const row = primaryKey && rowProps && rowProps?.[primaryKey]?.[propName];",
        "    const cell = cellProps[propName];",
        "    let value =",
        "      (row && (Array.isArray(row) ? row[index % row.length] : row)) ||",
        "      (Array.isArray(cell) ? cell[index % cell.length] : cell);",
        "    if (value !== undefined) result[propName] = value;",
        "",
        "    const rowPin = rowProps && rowProps.pinned && rowProps.pinned[propName];",
        "    const cellPin = cellProps.pinned[propName];",
        "    value =",
        "      (rowPin &&",
        "        (Array.isArray(rowPin) ? rowPin[index % rowPin.length] : rowPin)) ||",
        "      (Array.isArray(cellPin) ? cellPin[index % cellPin.length] : cellPin);",
        "    if (value !== undefined) result.pinned[propName] = value;",
        "  });",
        "  return result;",
        "};"
    ]
}