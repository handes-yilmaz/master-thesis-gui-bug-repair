{
    "src/js/components/DataTable/DataTable.js": [
        "...",
        "import { GroupedBody } from './GroupedBody';",
        "import { Pagination } from '../Pagination';",
        "import {",
        "  buildFooterValues,",
        "  buildGroups,",
        "  buildGroupState,",
        "  filterAndSortData,",
        "  initializeFilters,",
        "  normalizeCellProps,",
        "  normalizePrimaryProperty,",
        "} from './buildState';",
        "import { normalizeShow, usePagination } from '../../utils';",
        "import {",
        "  StyledContainer,",
        "  StyledDataTable,",
        "  StyledPlaceholder,",
        "} from './StyledDataTable';",
        "import { DataTablePropTypes } from './propTypes';",
        "import { PlaceholderBody } from './PlaceholderBody';",
        "",
        "const emptyData = [];",
        "",
        "function useGroupState(groups, groupBy) {",
        "  const [groupState, setGroupState] = useState(() =>",
        "    buildGroupState(groups, groupBy),",
        "  );",
        "  const [prevDeps, setPrevDeps] = useState({ groups, groupBy });",
        "",
        "  const { groups: prevGroups, groupBy: prevGroupBy } = prevDeps;",
        "  if (groups !== prevGroups || groupBy !== prevGroupBy) {",
        "    setPrevDeps({ groups, groupBy });",
        "    const nextGroupState = buildGroupState(groups, groupBy);",
        "    setGroupState(nextGroupState);",
        "    return [nextGroupState, setGroupState];",
        "  }",
        "",
        "  return [groupState, setGroupState];",
        "}",
        "",
        "const DataTable = ({",
        "  background,",
        "  border,",
        "  columns: columnsProp,",
        "  data: dataProp,",
        "  disabled,",
        "  fill,",
        "  groupBy,",
        "  onClickRow, // removing unknown DOM attributes",
        "  onMore,",
        "  onSearch, // removing unknown DOM attributes",
        "  onSelect,",
        "  onSort: onSortProp,",
        "  onUpdate,",
        "  replace,",
        "  pad,",
        "  paginate,",
        "  pin,",
        "  placeholder,",
        "  primaryKey,",
        "  resizeable,",
        "  rowProps,",
        "  select,",
        "  show: showProp,",
        "  size,",
        "  sort: sortProp,",
        "  sortable,",
        "  rowDetails,",
        "  step = 50,",
        "  verticalAlign,",
        "  ...rest",
        "}) => {",
        "  const theme = useContext(ThemeContext) || defaultProps.theme;",
        "  const {",
        "    view,",
        "    data: contextData,",
        "    properties,",
        "    onView,",
        "  } = useContext(DataContext);",
        "  const data = dataProp || contextData || emptyData;",
        "",
        "  const columns = useMemo(() => {",
        "    let result = [];",
        "    if (columnsProp) result = columnsProp;",
        "    else if (properties)",
        "      result = Object.keys(properties).map((p) => ({",
        "        property: p,",
        "        ...properties[p],",
        "      }));",
        "    else if (data.length)",
        "      result = Object.keys(data[0]).map((p) => ({ property: p }));",
        "    if (view?.columns)",
        "      result = result",
        "        .filter((c) => view.columns.includes(c.property))",
        "        .sort(",
        "          (c1, c2) =>",
        "            view.columns.indexOf(c1.property) -",
        "            view.columns.indexOf(c2.property),",
        "        );",
        "    return result;",
        "  }, [columnsProp, data, properties, view]);",
        "",
        "  // property name of the primary property",
        "  const primaryProperty = useMemo(",
        "    () => normalizePrimaryProperty(columns, primaryKey),",
        "    [columns, primaryKey],",
        "  );",
        "",
        "  // whether or not we should show a footer",
        "  const showFooter = useMemo(",
        "    () => columns.filter((c) => c.footer).length > 0,",
        "    [columns],",
        "  );",
        "",
        "  // what column we are actively capturing filter input on",
        "  const [filtering, setFiltering] = useState();",
        "",
        "  // the currently active filters",
        "  const [filters, setFilters] = useState(initializeFilters(columns));",
        "",
        "  // which column we are sorting on, with direction",
        "  const [sort, setSort] = useState(sortProp || {});",
        "  useEffect(() => {",
        "    if (sortProp) setSort(sortProp);",
        "    else if (view?.sort) setSort(view.sort);",
        "  }, [sortProp, view]);",
        "",
        "  // the data filtered and sorted, if needed",
        "  // Note: onUpdate mode expects the data to be passed",
        "  //   in completely filtered and sorted already.",
        "  const adjustedData = useMemo(",
        "    () => (onUpdate ? data : filterAndSortData(data, filters, onSearch, sort)),",
        "    [data, filters, onSearch, onUpdate, sort],",
        "  );",
        "",
        "  // the values to put in the footer cells",
        "  const footerValues = useMemo(",
        "    () => buildFooterValues(columns, adjustedData),",
        "    [adjustedData, columns],",
        "  );",
        "",
        "  // cell styling properties: background, border, pad",
        "  const cellProps = useMemo(",
        "    () => normalizeCellProps({ background, border, pad, pin }, theme),",
        "    [background, border, pad, pin, theme],",
        "  );",
        "",
        "  // if groupBy, an array with one item per unique groupBy key value",
        "  const groups = useMemo(",
        "    () => buildGroups(columns, adjustedData, groupBy, primaryProperty),",
        "    [adjustedData, columns, groupBy, primaryProperty],",
        "  );",
        "",
        "  // an object indicating which group values are expanded",
        "  const [groupState, setGroupState] = useGroupState(groups, groupBy);",
        "",
        "  const [limit, setLimit] = useState(step);",
        "",
        "  const [selected, setSelected] = useState(",
        "    select || (onSelect && []) || undefined,",
        "  );",
        "  useEffect(",
        "    () => setSelected(select || (onSelect && []) || undefined),",
        "    [onSelect, select],",
        "  );",
        "",
        "  const [rowExpand, setRowExpand] = useState([]);",
        "",
        "  // any customized column widths",
        "  const [widths, setWidths] = useState({});",
        "",
        "  // placeholder placement stuff",
        "  const headerRef = useRef();",
        "  const bodyRef = useRef();",
        "  const footerRef = useRef();",
        "  const [headerHeight, setHeaderHeight] = useState();",
        "  const [footerHeight, setFooterHeight] = useState();",
        "",
        "  // offset compensation when body overflows",
        "  const [scrollOffset, setScrollOffset] = useState(0);",
        "",
        "  // multiple pinned columns offset",
        "  const [pinnedOffset, setPinnedOffset] = useState();",
        "",
        "  const onHeaderWidths = useCallback(",
        "    (columnWidths) => {",
        "      const hasSelectColumn = Boolean(select || onSelect);",
        "      let pinnedProperties = columns",
        "        .map((pinnedColumn) => pinnedColumn.pin && pinnedColumn.property)",
        "        .filter((n) => n);",
        "      if (hasSelectColumn && pinnedProperties.length > 0) {",
        "        pinnedProperties = ['_grommetDataTableSelect', ...pinnedProperties];",
        "      }",
        "      const nextPinnedOffset = {};",
        "",
        "      if (columnWidths !== []) {",
        "        pinnedProperties.forEach((property, index) => {",
        "          const columnIndex =",
        "            property === '_grommetDataTableSelect'",
        "              ? 0",
        "              : columns.findIndex((column) => column.property === property) +",
        "                hasSelectColumn;",
        "          if (columnWidths[columnIndex]) {",
        "            nextPinnedOffset[property] = {",
        "              width: columnWidths[columnIndex],",
        "              left:",
        "                index === 0",
        "                  ? 0",
        "                  : nextPinnedOffset[pinnedProperties[index - 1]].left +",
        "                    nextPinnedOffset[pinnedProperties[index - 1]].width,",
        "            };",
        "          }",
        "        });",
        "        setPinnedOffset(nextPinnedOffset);",
        "      }",
        "    },",
        "    [columns, setPinnedOffset, select, onSelect],",
        "  );",
        "",
        "  // eslint-disable-next-line react-hooks/exhaustive-deps",
        "  useLayoutEffect(() => {",
        "    const nextScrollOffset =",
        "      (bodyRef.current.parentElement?.clientWidth || 0) -",
        "      bodyRef.current.clientWidth;",
        "    if (nextScrollOffset !== scrollOffset) setScrollOffset(nextScrollOffset);",
        "  });",
        "",
        "  useLayoutEffect(() => {",
        "    if (placeholder) {",
        "      if (headerRef.current) {",
        "        const nextHeaderHeight =",
        "          headerRef.current.getBoundingClientRect().height;",
        "        setHeaderHeight(nextHeaderHeight);",
        "      } else setHeaderHeight(0);",
        "      if (footerRef.current) {",
        "        const nextFooterHeight =",
        "          footerRef.current.getBoundingClientRect().height;",
        "        setFooterHeight(nextFooterHeight);",
        "      } else setFooterHeight(0);",
        "    }",
        "  }, [footerRef, headerRef, placeholder]);",
        "",
        "  // remember that we are filtering on this property",
        "  const onFiltering = (property) => setFiltering(property);",
        "",
        "  // remember the search text we should filter this property by",
        "  const onFilter = (property, value) => {",
        "    const nextFilters = { ...filters };",
        "    nextFilters[property] = value;",
        "    setFilters(nextFilters);",
        "    // Let caller know about search, if interested",
        "    if (onSearch) onSearch(nextFilters);",
        "  };",
        "",
        "  // toggle the sort direction on this property",
        "  const onSort = (property) => () => {",
        "    const external = sort ? sort.external : false;",
        "    let direction;",
        "    if (!sort || property !== sort.property) direction = 'asc';",
        "    else if (sort.direction === 'asc') direction = 'desc';",
        "    else direction = 'asc';",
        "    const nextSort = { property, direction, external };",
        "    setSort(nextSort);",
        "    if (onView) {",
        "      onView({ ...view, sort: { property, direction } });",
        "    }",
        "    if (onUpdate) {",
        "      const opts = {",
        "        count: limit,",
        "        sort: nextSort,",
        "      };",
        "      if (groups) {",
        "        opts.expanded = Object.keys(groupState).filter(",
        "          (k) => groupState[k].expanded,",
        "        );",
        "      }",
        "      if (showProp) opts.show = showProp;",
        "      onUpdate(opts);",
        "    }",
        "    if (onSortProp) onSortProp(nextSort);",
        "  };",
        "",
        "  // toggle whether the group is expanded",
        "  const onToggleGroup = (groupValue) => () => {",
        "    const nextGroupState = { ...groupState };",
        "    nextGroupState[groupValue] = {",
        "      ...nextGroupState[groupValue],",
        "      expanded: !nextGroupState[groupValue].expanded,",
        "    };",
        "    setGroupState(nextGroupState);",
        "    const expandedKeys = Object.keys(nextGroupState).filter(",
        "      (k) => nextGroupState[k].expanded,",
        "    );",
        "    if (onUpdate) {",
        "      const opts = {",
        "        expanded: expandedKeys,",
        "        count: limit,",
        "      };",
        "      if (sort?.property) opts.sort = sort;",
        "      if (showProp) opts.show = showProp;",
        "      onUpdate(opts);",
        "    }",
        "    if (groupBy.onExpand) {",
        "      groupBy.onExpand(expandedKeys);",
        "    }",
        "  };",
        "",
        "  // toggle whether all groups are expanded",
        "  const onToggleGroups = () => {",
        "    const expanded =",
        "      Object.keys(groupState).filter((k) => !groupState[k].expanded).length ===",
        "      0;",
        "    const nextGroupState = {};",
        "    Object.keys(groupState).forEach((k) => {",
        "      nextGroupState[k] = { ...groupState[k], expanded: !expanded };",
        "    });",
        "    setGroupState(nextGroupState);",
        "    const expandedKeys = Object.keys(nextGroupState).filter(",
        "      (k) => nextGroupState[k].expanded,",
        "    );",
        "    if (onUpdate) {",
        "      const opts = {",
        "        expanded: expandedKeys,",
        "        count: limit,",
        "      };",
        "      if (showProp) opts.show = showProp;",
        "      if (sort?.property) opts.sort = sort;",
        "      onUpdate(opts);",
        "    }",
        "    if (groupBy.onExpand) {",
        "      groupBy.onExpand(expandedKeys);",
        "    }",
        "  };",
        "",
        "  // remember the width this property's column should be",
        "  const onResize = useCallback(",
        "    (property, width) => {",
        "      if (widths[property] !== width) {",
        "        const nextWidths = { ...widths };",
        "        nextWidths[property] = width;",
        "        setWidths(nextWidths);",
        "      }",
        "    },",
        "    [widths],",
        "  );",
        "",
        "  if (size && resizeable) {",
        "    console.warn('DataTable cannot combine \"size\" and \"resizeble\".');",
        "  }",
        "  if (onUpdate && onMore) {",
        "    console.warn('DataTable cannot combine \"onUpdate\" and \"onMore\".');",
        "  }",
        "",
        "  const [items, paginationProps] = usePagination({",
        "    data: adjustedData,",
        "    page: normalizeShow(showProp, step),",
        "    step,",
        "    ...paginate, // let any specifications from paginate prop override component",
        "  });",
        "  const { step: paginationStep } = paginationProps;",
        "",
        "  const Container = paginate ? StyledContainer : Fragment;",
        "  const containterProps = paginate",
        "    ? { ...theme.dataTable.container, fill }",
        "    : undefined;",
        "",
        "  // DataTable should overflow if paginating but pagination component",
        "  // should remain in its location",
        "  const OverflowContainer = paginate ? Box : Fragment;",
        "  const overflowContainerProps = paginate",
        "    ? { overflow: { horizontal: 'auto' } }",
        "    : undefined;",
        "",
        "  // necessary for Firefox, otherwise paginated DataTable will",
        "  // not fill its container like it does by default on other",
        "  // browsers like Chrome/Safari",
        "  const paginatedDataTableProps =",
        "    paginate && (fill === true || fill === 'horizontal')",
        "      ? { style: { minWidth: '100%' } }",
        "      : undefined;",
        "",
        "  let placeholderContent = placeholder;",
        "  if (placeholder && typeof placeholder === 'string') {",
        "    placeholderContent = (",
        "      <Box",
        "        background={{ color: 'background-front', opacity: 'strong' }}",
        "        align=\"center\"",
        "        justify=\"center\"",
        "        fill=\"vertical\"",
        "      >",
        "        <Text>{placeholder}</Text>",
        "      </Box>",
        "    );",
        "  }",
        "",
        "  const bodyContent = groups ? (",
        "    <GroupedBody",
        "      ref={bodyRef}",
        "      cellProps={cellProps.body}",
        "      columns={columns}",
        "      disabled={disabled}",
        "      groupBy={typeof groupBy === 'string' ? { property: groupBy } : groupBy}",
        "      groups={groups}",
        "      groupState={groupState}",
        "      pinnedOffset={pinnedOffset}",
        "      primaryProperty={primaryProperty}",
        "      onMore={",
        "        onUpdate",
        "          ? () => {",
        "              if (adjustedData.length === limit) {",
        "                const opts = {",
        "                  expanded: Object.keys(groupState).filter(",
        "                    (k) => groupState[k].expanded,",
        "                  ),",
        "                  count: limit + paginationStep,",
        "                };",
        "                if (sort?.property) opts.sort = sort;",
        "                if (showProp) opts.show = showProp;",
        "                onUpdate(opts);",
        "                setLimit((prev) => prev + paginationStep);",
        "              }",
        "            }",
        "          : onMore",
        "      }",
        "      onSelect={",
        "        onSelect",
        "          ? (nextSelected, row) => {",
        "              setSelected(nextSelected);",
        "              if (onSelect) onSelect(nextSelected, row);",
        "            }",
        "          : undefined",
        "      }",
        "      onToggle={onToggleGroup}",
        "      onUpdate={onUpdate}",
        "      replace={replace}",
        "      rowProps={rowProps}",
        "      selected={selected}",
        "      size={size}",
        "      step={paginationStep}",
        "      verticalAlign={",
        "        typeof verticalAlign === 'string' ? verticalAlign : verticalAlign?.body",
        "      }",
        "    />",
        "  ) : (",
        "    <Body",
        "      ref={bodyRef}",
        "      cellProps={cellProps.body}",
        "      columns={columns}",
        "      data={!paginate ? adjustedData : items}",
        "      disabled={disabled}",
        "      onMore={",
        "        onUpdate",
        "          ? () => {",
        "              if (adjustedData.length === limit) {",
        "                const opts = {",
        "                  count: limit + paginationStep,",
        "                };",
        "                if (sort?.property) opts.sort = sort;",
        "                if (showProp) opts.show = showProp;",
        "                onUpdate(opts);",
        "                setLimit((prev) => prev + paginationStep);",
        "              }",
        "            }",
        "          : onMore",
        "      }",
        "      replace={replace}",
        "      onClickRow={onClickRow}",
        "      onSelect={",
        "        onSelect",
        "          ? (nextSelected, row) => {",
        "              setSelected(nextSelected);",
        "              if (onSelect) onSelect(nextSelected, row);",
        "            }",
        "          : undefined",
        "      }",
        "      pinnedCellProps={cellProps.pinned}",
        "      pinnedOffset={pinnedOffset}",
        "      primaryProperty={primaryProperty}",
        "      rowProps={rowProps}",
        "      selected={selected}",
        "      show={!paginate ? showProp : undefined}",
        "      size={size}",
        "      step={paginationStep}",
        "      rowDetails={rowDetails}",
        "      rowExpand={rowExpand}",
        "      setRowExpand={setRowExpand}",
        "      verticalAlign={",
        "        typeof verticalAlign === 'string' ? verticalAlign : verticalAlign?.body",
        "      }",
        "    />",
        "  );",
        "",
        "  return (",
        "    <Container {...containterProps}>",
        "      <OverflowContainer {...overflowContainerProps}>",
        "        <StyledDataTable",
        "          fillProp={!paginate ? fill : undefined}",
        "          {...paginatedDataTableProps}",
        "          {...rest}",
        "        >",
        "          <Header",
        "            ref={headerRef}",
        "            cellProps={cellProps.header}",
        "            columns={columns}",
        "            data={adjustedData}",
        "            disabled={disabled}",
        "            fill={fill}",
        "            filtering={filtering}",
        "            filters={filters}",
        "            groupBy={groupBy}",
        "            groups={groups}",
        "            groupState={groupState}",
        "            pin={pin === true || pin === 'header'}",
        "            pinnedOffset={pinnedOffset}",
        "            selected={selected}",
        "            size={size}",
        "..."
    ],
    "src/js/components/DataTable/GroupedBody.js": [
        "import React, { forwardRef, useMemo } from 'react';",
        "",
        "import { Cell } from './Cell';",
        "import { ExpanderCell } from './ExpanderCell';",
        "import { StyledDataTableBody, StyledDataTableRow } from './StyledDataTable';",
        "import { CheckBox } from '../CheckBox/CheckBox';",
        "import { InfiniteScroll } from '../InfiniteScroll';",
        "import { TableRow } from '../TableRow';",
        "import { TableCell } from '../TableCell';",
        "import { datumValue, normalizeRowCellProps } from './buildState';",
        "",
        "export const GroupedBody = forwardRef(",
        "  (",
        "    {",
        "      cellProps: cellPropsProp,",
        "      columns,",
        "      data,",
        "      disabled,",
        "      groupBy,",
        "      groups,",
        "      groupState,",
        "      pinnedOffset,",
        "      primaryProperty,",
        "      onMore,",
        "      onSelect,",
        "      onToggle,",
        "      onUpdate,",
        "      replace,",
        "      rowProps,",
        "      selected,",
        "      size,",
        "      step,",
        "      verticalAlign,",
        "      ...rest",
        "    },",
        "    ref,",
        "  ) => {",
        "    const items = useMemo(() => {",
        "      const nextItems = [];",
        "      groups.forEach((group) => {",
        "        const { expanded } = groupState[group.key] || { expanded: true };",
        "        const memberCount = group.data.length;",
        "        let groupSelected = [];",
        "        let isGroupSelected = false;",
        "        let groupDisabled = [];",
        "        let isGroupDisabled = false;",
        "",
        "        if (memberCount > 1 || (onUpdate && group.key)) {",
        "          // need a header",
        "          const primaryKeys = group.data.map((datum) => datum[primaryProperty]);",
        "",
        "          groupSelected =",
        "            primaryKeys && selected",
        "              ? primaryKeys.filter((val) => selected.includes(val))",
        "              : [];",
        "",
        "          isGroupSelected = groupBy.select",
        "            ? groupBy.select[group.key] === 'all'",
        "            : groupSelected.length === group.data.length &&",
        "              groupSelected.length > 0;",
        "",
        "          const indeterminate = groupBy.select",
        "            ? groupBy.select[group.key] === 'some'",
        "            : groupSelected.length > 0 &&",
        "              groupSelected.length < group.data.length;",
        "",
        "          groupDisabled =",
        "            primaryKeys && disabled",
        "              ? primaryKeys.filter((val) => disabled.includes(val))",
        "              : [];",
        "",
        "          isGroupDisabled = groupBy.disable",
        "            ? groupBy.disable[group.key] === 'all'",
        "            : groupDisabled.length === group.data.length &&",
        "              groupDisabled.length > 0;",
        "",
        "          nextItems.push({",
        "            expanded,",
        "            key: group.key,",
        "            primaryValue: group.key,",
        "            datum: group.datum,",
        "            context: 'groupHeader',",
        "            isDisabled: isGroupDisabled,",
        "            isSelected: isGroupSelected,",
        "            indeterminate,",
        "            onChange: () => {",
        "              const nextSelected =",
        "                isGroupSelected || indeterminate",
        "                  ? selected.filter((s) => !groupSelected.includes(s))",
        "                  : [...selected, ...primaryKeys];",
        "              if (groupBy.onSelect) {",
        "                groupBy.onSelect(nextSelected, group.datum, groupBy.select);",
        "              } else {",
        "                onSelect(nextSelected, group.datum);",
        "              }",
        "            },",
        "          });",
        "        }",
        "        if ((!onUpdate && memberCount === 1) || expanded) {",
        "          // add the group members",
        "          group.data.forEach((datum, index) => {",
        "            const primaryValue = primaryProperty",
        "              ? datumValue(datum, primaryProperty)",
        "              : undefined;",
        "            const isSelected = selected?.includes(primaryValue);",
        "            const isDisabled = disabled?.includes(primaryValue);",
        "            nextItems.push({",
        "              key: datum[primaryProperty],",
        "              primaryValue: primaryProperty",
        "                ? datumValue(datum, primaryProperty)",
        "                : undefined,",
        "              datum,",
        "              context:",
        "                memberCount > 1 && index === memberCount - 1",
        "                  ? 'groupEnd'",
        "                  : 'body',",
        "              isDisabled,",
        "              isSelected,",
        "              onChange: () => {",
        "                const nextSelected = isSelected",
        "                  ? selected.filter((s) => s !== primaryValue)",
        "                  : [...selected, primaryValue];",
        "                onSelect(nextSelected, datum);",
        "              },",
        "            });",
        "          });",
        "        }",
        "      });",
        "      return nextItems;",
        "    }, [",
        "      disabled,",
        "      groups,",
        "      groupBy,",
        "      groupState,",
        "      primaryProperty,",
        "      selected,",
        "      onSelect,",
        "      onUpdate,",
        "    ]);",
        "",
        "    return (",
        "      <StyledDataTableBody ref={ref} size={size} {...rest}>",
        "        <InfiniteScroll",
        "          items={items}",
        "          onMore={onMore}",
        "          replace={replace}",
        "          renderMarker={(marker) => (",
        "            <TableRow>",
        "              <TableCell>{marker}</TableCell>",
        "            </TableRow>",
        "          )}",
        "          step={step}",
        "        >",
        "          {(row, index, rowRef) => {",
        "            const {",
        "              context,",
        "              datum,",
        "              expanded,",
        "              indeterminate,",
        "              isDisabled,",
        "              isSelected,",
        "              key,",
        "              onChange,",
        "              primaryValue,",
        "            } = row;",
        "            const cellProps = normalizeRowCellProps(",
        "              rowProps,",
        "              cellPropsProp,",
        "              primaryValue,",
        "              index,",
        "            );",
        "",
        "            return (",
        "              <StyledDataTableRow ref={rowRef} key={key} size={size}>",
        "                <ExpanderCell",
        "                  background={cellProps.background}",
        "                  border={cellProps.border}",
        "                  context={context}",
        "                  pad={cellProps.pad}",
        "                  onToggle={",
        "                    context === 'groupHeader' ? onToggle(key) : undefined",
        "                  }",
        "                  expanded={expanded}",
        "                  verticalAlign={verticalAlign}",
        "                />",
        "                {(selected || onSelect) && (",
        "                  <TableCell",
        "                    background={cellProps.background}",
        "                    border={cellProps.pinned.border || cellProps.border}",
        "                    plain=\"noPad\"",
        "                    size=\"auto\"",
        "                    verticalAlign={verticalAlign}",
        "                    aria-disabled={isDisabled || !onSelect || undefined}",
        "                  >",
        "                    <CheckBox",
        "                      a11yTitle={`${isSelected ? 'unselect' : 'select'} ${",
        "                        context === 'groupHeader' ? key : primaryValue",
        "                      }`}",
        "                      checked={isSelected}",
        "                      indeterminate={indeterminate}",
        "                      disabled={isDisabled || !onSelect}",
        "                      onChange={onChange}",
        "                      pad={cellProps.pad}",
        "                    />",
        "                  </TableCell>",
        "                )}",
        "                {columns.map((column) => {",
        "                  let scope;",
        "                  if (context === 'groupHeader') {",
        "                    scope =",
        "                      column.property === groupBy.property ? 'row' : undefined;",
        "                  } else {",
        "                    scope = column.primary ? 'row' : undefined;",
        "                  }",
        "                  return (",
        "                    <Cell",
        "                      key={column.property}",
        "                      background={cellProps.background}",
        "                      border={cellProps.border}",
        "                      context={context}",
        "                      column={column}",
        "                      datum={datum}",
        "                      pad={cellProps.pad}",
        "                      scope={scope}",
        "                      pinnedOffset={",
        "                        context === 'groupHeader' &&",
        "                        pinnedOffset &&",
        "                        pinnedOffset[column.property]",
        "                      }",
        "                      verticalAlign={verticalAlign}",
        "                    />",
        "                  );",
        "                })}",
        "              </StyledDataTableRow>",
        "            );",
        "          }}",
        "        </InfiniteScroll>",
        "      </StyledDataTableBody>",
        "    );",
        "  },",
        ");"
    ],
    "src/js/components/DataTable/Header.js": [
        "/* eslint-disable no-underscore-dangle */",
        "import React, {",
        "  forwardRef,",
        "  useCallback,",
        "  useContext,",
        "  useEffect,",
        "  useState,",
        "} from 'react';",
        "import styled, { css, ThemeContext } from 'styled-components';",
        "",
        "import { defaultProps } from '../../default-props';",
        "",
        "import { Box } from '../Box';",
        "import { Button } from '../Button';",
        "import { CheckBox } from '../CheckBox';",
        "import { TableCell, verticalAlignToJustify } from '../TableCell/TableCell';",
        "import { Text } from '../Text';",
        "",
        "import { Resizer } from './Resizer';",
        "import { Searcher } from './Searcher';",
        "import { ExpanderCell } from './ExpanderCell';",
        "import {",
        "  StyledDataTableCell,",
        "  StyledDataTableHeader,",
        "  StyledDataTableRow,",
        "} from './StyledDataTable';",
        "import { datumValue } from './buildState';",
        "import { kindPartStyles } from '../../utils/styles';",
        "import { normalizeColor } from '../../utils/colors';",
        "",
        "// separate theme values into groupings depending on what",
        "// part of header cell they should style",
        "const separateThemeProps = (theme) => {",
        "  const {",
        "    background, // covered by cellProps",
        "    border, // covered by cellProps",
        "    color,",
        "    font,",
        "    gap, // gap is used for space between header cell elements only",
        "    pad, // covered by cellProps",
        "    units,",
        "    ...rest",
        "  } = theme.dataTable.header;",
        "",
        "  const textProps = { color, ...font };",
        "  const iconProps = { color };",
        "  const layoutProps = { ...rest };",
        "",
        "  return [layoutProps, textProps, iconProps];",
        "};",
        "",
        "// build up CSS from basic to specific based on the supplied sub-object paths.",
        "// adapted from StyledButtonKind to only include parts relevant for DataTable",
        "const buttonStyle = ({ pad, theme, verticalAlign }) => {",
        "  const styles = [];",
        "  const [layoutProps, , iconProps] = separateThemeProps(theme);",
        "",
        "  // if cell is sortable, we want pad to be applied",
        "  // to the button instead of the cell",
        "  if (pad) {",
        "    styles.push(kindPartStyles({ pad }, theme));",
        "  }",
        "",
        "  if (layoutProps) {",
        "    styles.push(kindPartStyles(layoutProps, theme));",
        "  }",
        "",
        "  if (layoutProps.hover) {",
        "    // CSS for this sub-object in the theme",
        "    const partStyles = kindPartStyles(layoutProps.hover, theme);",
        "    if (partStyles.length > 0)",
        "      styles.push(",
        "        css`",
        "          &:hover {",
        "            ${partStyles}",
        "          }",
        "        `,",
        "      );",
        "  }",
        "",
        "  if (iconProps.color) {",
        "    styles.push(",
        "      css`",
        "        svg {",
        "          stroke: ${normalizeColor(iconProps.color, theme)};",
        "          fill: ${normalizeColor(iconProps.color, theme)};",
        "        }",
        "      `,",
        "    );",
        "  }",
        "",
        "  let align = 'center';",
        "  if (verticalAlign === 'bottom') align = 'end';",
        "  if (verticalAlign === 'top') align = 'start';",
        "",
        "  if (verticalAlign) {",
        "    styles.push(",
        "      css`",
        "        display: inline-flex;",
        "        align-items: ${align};",
        "      `,",
        "    );",
        "  }",
        "",
        "  return styles;",
        "};",
        "",
        "const StyledHeaderCellButton = styled(Button)`",
        "  ${(props) => buttonStyle(props)}",
        "`;",
        "",
        "// allow extend to spread onto Box that surrounds column label",
        "const StyledContentBox = styled(Box)`",
        "  ${(props) => props.extend}",
        "`;",
        "",
        "const Header = forwardRef(",
        "  (",
        "    {",
        "      cellProps,",
        "      columns,",
        "      data,",
        "      disabled,",
        "      fill,",
        "      filtering,",
        "      filters,",
        "      groupBy,",
        "      groups,",
        "      groupState,",
        "      onFilter,",
        "      onFiltering,",
        "      onResize,",
        "      onSelect,",
        "      onSort,",
        "      onToggle,",
        "      onWidths,",
        "      pin: pinProp,",
        "      pinnedOffset,",
        "      primaryProperty,",
        "      selected,",
        "      rowDetails,",
        "      sort,",
        "      widths,",
        "      verticalAlign,",
        "      ...rest",
        "    },",
        "    ref,",
        "  ) => {",
        "    const theme = useContext(ThemeContext) || defaultProps.theme;",
        "    const [layoutProps, textProps] = separateThemeProps(theme);",
        "",
        "    const [cellWidths, setCellWidths] = useState([]);",
        "",
        "    const updateWidths = useCallback(",
        "      (width) => setCellWidths((values) => [...values, width]),",
        "      [],",
        "    );",
        "",
        "    useEffect(() => {",
        "      if (onWidths && cellWidths.length !== 0) {",
        "        onWidths(cellWidths);",
        "      }",
        "    }, [cellWidths, onWidths]);",
        "",
        "    const pin = pinProp ? ['top'] : [];",
        "    const selectPin = pinnedOffset?._grommetDataTableSelect",
        "      ? [...pin, 'left']",
        "      : pin;",
        "",
        "    const totalSelectedGroups = groupBy?.select",
        "      ? Object.keys(groupBy.select).reduce(",
        "          (total, cur) =>",
        "            cur && groupBy.select[cur] === 'all' ? total + 1 : total,",
        "          0,",
        "        )",
        "      : 0;",
        "    const totalSelected = (selected?.length || 0) + totalSelectedGroups;",
        "",
        "    const onChangeSelection = useCallback(() => {",
        "      let nextSelected;",
        "      const nextGroupSelected = {};",
        "",
        "      // Since some rows might be disabled but already selected, we need to",
        "      // note which rows are enabled when determining how aggregate selection",
        "      // works.",
        "      const primaryValues =",
        "        data.map((datum) => datumValue(datum, primaryProperty)) || [];",
        "      // enabled includes what can be changed",
        "      const enabled =",
        "        (disabled && primaryValues.filter((v) => !disabled.includes(v))) ||",
        "        primaryValues;",
        "      // enabledSelected includes what can be changed and is currently selected",
        "      const enabledSelected =",
        "        (selected && enabled.filter((v) => selected.includes(v))) ||",
        "        primaryValues;",
        "",
        "      const allSelected = groupBy?.select",
        "        ? groupBy.select[''] === 'all'",
        "        : enabledSelected.length === enabled.length;",
        "",
        "      if (allSelected) {",
        "        // if any are disabled and selected, leave those, otherwise clear",
        "        nextSelected = disabled",
        "          ? primaryValues.filter(",
        "              (v) => disabled.includes(v) && selected.includes(v),",
        "            )",
        "          : [];",
        "        nextGroupSelected[''] = 'none';",
        "      } else {",
        "        // if some or none are selected, select all enabled plus all disabled",
        "        // that are already selected",
        "        nextSelected = disabled",
        "          ? primaryValues.filter(",
        "              (v) => !disabled.includes(v) || selected.includes(v),",
        "            )",
        "          : primaryValues;",
        "        nextGroupSelected[''] = 'all';",
        "        groupBy?.expandable?.forEach((key) => {",
        "          nextGroupSelected[key] = 'all';",
        "        });",
        "      }",
        "      if (groupBy?.onSelect) {",
        "        groupBy.onSelect(nextSelected, undefined, nextGroupSelected);",
        "      } else onSelect(nextSelected);",
        "    }, [data, disabled, groupBy, onSelect, primaryProperty, selected]);",
        "",
        "    return (",
        "      <StyledDataTableHeader ref={ref} fillProp={fill} {...rest}>",
        "        <StyledDataTableRow>",
        "          {groups && (",
        "            <ExpanderCell",
        "              background={cellProps.background}",
        "              border={cellProps.border}",
        "              context=\"header\"",
        "              expanded={",
        "                Object.keys(groupState).filter((k) => !groupState[k].expanded)",
        "                  .length === 0",
        "              }",
        "              onToggle={onToggle}",
        "              pad={cellProps.pad}",
        "            />",
        "          )}",
        "",
        "          {(selected || onSelect) && (",
        "            <StyledDataTableCell",
        "              background={cellProps.background}",
        "              onWidth={updateWidths}",
        "              plain=\"noPad\"",
        "              size=\"auto\"",
        "              context=\"header\"",
        "              scope=\"col\"",
        "              pin={selectPin}",
        "              pinnedOffset={pinnedOffset?._grommetDataTableSelect}",
        "              verticalAlign={verticalAlign}",
        "            >",
        "              {onSelect && (",
        "                <CheckBox",
        "                  a11yTitle={",
        "                    totalSelected === data.length",
        "                      ? 'unselect all'",
        "                      : 'select all'",
        "                  }",
        "                  checked={",
        "                    groupBy?.select",
        "                      ? groupBy.select[''] === 'all'",
        "                      : totalSelected > 0 &&",
        "                        data.length > 0 &&",
        "                        totalSelected === data.length",
        "                  }",
        "                  indeterminate={",
        "                    groupBy?.select",
        "                      ? groupBy.select[''] === 'some'",
        "                      : totalSelected > 0 && totalSelected < data.length",
        "                  }",
        "                  onChange={onChangeSelection}",
        "                  pad={cellProps.pad}",
        "                />",
        "              )}",
        "            </StyledDataTableCell>",
        "          )}",
        "          {rowDetails && <TableCell size=\"xxsmall\" plain pad=\"none\" />}",
        "          {columns.map(",
        "            ({",
        "              property,",
        "              header,",
        "              align,",
        "              pin: columnPin,",
        "              search,",
        "              sortable,",
        "              verticalAlign: columnVerticalAlign, // depcrecate in v3",
        "              size,",
        "              units,",
        "            }) => {",
        "              let content;",
        "              const unitsContent = units ? (",
        "                <Text {...textProps} {...theme.dataTable.header.units}>",
        "                  {units}",
        "                </Text>",
        "              ) : undefined;",
        "              if (typeof header === 'string') {",
        "                content = <Text {...textProps}>{header}</Text>;",
        "                if (",
        "                  Object.keys(layoutProps).length &&",
        "                  (sortable === false || !onSort)",
        "                ) {",
        "                  // apply rest of layout styling if cell is not sortable,",
        "                  // otherwise this styling will be applied by",
        "                  // StyledHeaderCellButton",
        "                  content = (",
        "                    <StyledContentBox {...layoutProps}>",
        "                      {content}",
        "                    </StyledContentBox>",
        "                  );",
        "                }",
        "              } else content = header;",
        "",
        "              if (unitsContent) {",
        "                content = (",
        "                  <Box justify={align} direction=\"row\">",
        "                    {content}",
        "                    {unitsContent}",
        "                  </Box>",
        "                );",
        "              }",
        "",
        "              if (verticalAlign || columnVerticalAlign) {",
        "                const vertical = verticalAlign || columnVerticalAlign;",
        "                content = (",
        "                  <Box height=\"100%\" justify={verticalAlignToJustify[vertical]}>",
        "                    {content}",
        "                  </Box>",
        "                );",
        "              }",
        "",
        "              if (onSort && sortable !== false) {",
        "                let Icon;",
        "                if (onSort && sortable !== false) {",
        "                  if (sort && sort.property === property) {",
        "                    Icon =",
        "                      theme.dataTable.icons[",
        "                        sort.direction !== 'asc' ? 'ascending' : 'descending'",
        "                      ];",
        "                  } else if (theme.dataTable.icons.sortable) {",
        "                    Icon = theme.dataTable.icons.sortable;",
        "                  }",
        "                }",
        "",
        "                content = (",
        "                  <StyledHeaderCellButton",
        "                    plain",
        "                    column={property}",
        "                    fill=\"vertical\"",
        "                    onClick={onSort(property)}",
        "                    sort={sort}",
        "                    pad={cellProps.pad}",
        "                    sortable",
        "                    verticalAlign={verticalAlign || columnVerticalAlign}",
        "                  >",
        "                    <Box",
        "                      direction=\"row\"",
        "                      align=\"center\"",
        "                      gap=\"xsmall\"",
        "                      justify={align}",
        "                    >",
        "                      {content}",
        "                      {Icon && <Icon />}",
        "                    </Box>",
        "                  </StyledHeaderCellButton>",
        "                );",
        "              }",
        "",
        "              // content should fill any available space in cell",
        "              // If `onResize` or `search` is true we need to explicitly set",
        "              // fill because later if either of these props is true content",
        "              // will be wrapped with an additional Box, preventing this Box",
        "              // from automatically filling the vertical space.",
        "              content = (",
        "                <Box",
        "                  flex=\"grow\"",
        "                  fill={onResize || search ? 'vertical' : false}",
        "                  justify={(!align && 'center') || align}",
        "                >",
        "                  {content}",
        "                </Box>",
        "              );",
        "",
        "              if (search || onResize) {",
        "                const resizer = onResize ? (",
        "                  <Resizer property={property} onResize={onResize} />",
        "                ) : null;",
        "                const searcher =",
        "                  search && filters ? (",
        "                    <Searcher",
        "                      filtering={filtering}",
        "                      filters={filters}",
        "                      property={property}",
        "                      onFilter={onFilter}",
        "                      onFiltering={onFiltering}",
        "                    />",
        "                  ) : null;",
        "                content = (",
        "                  <Box",
        "                    direction=\"row\"",
        "                    align=\"center\"",
        "                    justify={!align || align === 'start' ? 'between' : align}",
        "                    gap={theme.dataTable.header.gap}",
        "                    fill=\"vertical\"",
        "                    style={onResize ? { position: 'relative' } : undefined}",
        "                  >",
        "                    {content}",
        "                    {searcher && resizer ? (",
        "                      <Box",
        "                        flex=\"shrink\"",
        "                        direction=\"row\"",
        "                        align=\"center\"",
        "                        gap={theme.dataTable.header.gap}",
        "                      >",
        "                        {searcher}",
        "                        {resizer}",
        "                      </Box>",
        "                    ) : (",
        "                      searcher || resizer",
        "                    )}",
        "                  </Box>",
        "                );",
        "              }",
        "              const cellPin = [...pin];",
        "              if (columnPin) cellPin.push('left');",
        "",
        "              return (",
        "                <StyledDataTableCell",
        "                  key={property}",
        "                  align={align}",
        "                  context=\"header\"",
        "                  verticalAlign={verticalAlign || columnVerticalAlign}",
        "                  background={cellProps.background}",
        "                  border={cellProps.border}",
        "                  onWidth={updateWidths}",
        "                  // if sortable, pad will be included in the button styling",
        "                  pad={sortable === false || !onSort ? cellProps.pad : 'none'}",
        "                  pin={cellPin}",
        "                  plain",
        "                  pinnedOffset={pinnedOffset && pinnedOffset[property]}",
        "                  scope=\"col\"",
        "                  size={widths && widths[property] ? undefined : size}",
        "                  style={",
        "                    widths && widths[property]",
        "                      ? { width: widths[property] }",
        "                      : undefined",
        "                  }",
        "                >",
        "                  {content}",
        "                </StyledDataTableCell>",
        "              );",
        "            },",
        "          )}",
        "        </StyledDataTableRow>",
        "      </StyledDataTableHeader>",
        "    );",
        "  },",
        ");",
        "",
        "Header.displayName = 'Header';",
        "",
        "Header.defaultProps = {};",
        "Object.setPrototypeOf(Header.defaultProps, defaultProps);",
        "",
        "export { Header };"
    ]
}