{
    "1": {
        "bug_file": "src/js/components/Meter/Meter.js",
        "compressed": "NO",
        "line_numbers": 76,
        "compressed_line_numbers": 76,
        "compressed_bug_file_content": "import React, { forwardRef, useMemo } from 'react';\n\nimport { Bar } from './Bar';\nimport { Circle } from './Circle';\nimport { MeterPropTypes } from './propTypes';\n\nconst deriveMax = (values) => {\n  let max = 100;\n  if (values && values.length > 1) {\n    max = 0;\n    values.forEach((v) => {\n      max += v.value;\n    });\n  }\n  return max;\n};\n\nconst Meter = forwardRef(\n  (\n    {\n      background = { color: 'light-2', opacity: 'medium' },\n      color,\n      direction = 'horizontal',\n      size = 'medium',\n      thickness = 'medium',\n      type = 'bar',\n      value,\n      values: valuesProp,\n      ...rest\n    },\n    ref,\n  ) => {\n    // normalize values to an array of objects\n    const values = useMemo(() => {\n      if (valuesProp) return valuesProp;\n      if (value) return [{ color, value }];\n      return [];\n    }, [color, value, valuesProp]);\n\n    const memoizedMax = useMemo(() => deriveMax(values), [values]);\n    let content;\n    if (type === 'bar') {\n      content = (\n        <Bar\n          ref={ref}\n          max={memoizedMax}\n          values={values}\n          size={size}\n          thickness={thickness}\n          background={background}\n          direction={direction}\n          {...rest}\n        />\n      );\n    } else if (type === 'circle' || type === 'pie' || type === 'semicircle') {\n      content = (\n        <Circle\n          ref={ref}\n          max={memoizedMax}\n          values={values}\n          size={size}\n          thickness={thickness}\n          type={type}\n          background={background}\n          {...rest}\n        />\n      );\n    }\n    return content;\n  },\n);\n\nMeter.displayName = 'Meter';\nMeter.prototype = MeterPropTypes;\n\nexport { Meter };"
    },
    "2": {
        "bug_file": "src/js/components/Meter/Circle.js",
        "compressed": "NO",
        "line_numbers": 168,
        "compressed_line_numbers": 168,
        "compressed_bug_file_content": "import React, { forwardRef, useContext } from 'react';\nimport { ThemeContext } from 'styled-components';\n\nimport { defaultProps } from '../../default-props';\nimport { arcCommands, parseMetricToNum, translateEndAngle } from '../../utils';\n\nimport { StyledMeter } from './StyledMeter';\nimport { strokeProps, defaultColor } from './utils';\n\nconst Circle = forwardRef((props, ref) => {\n  const { background, max, round, size, thickness, type, values, ...rest } =\n    props;\n  const theme = useContext(ThemeContext);\n  const width =\n    size === 'full' ? 288 : parseMetricToNum(theme.global.size[size] || size);\n  const strokeWidth =\n    type === 'pie'\n      ? width / 2\n      : parseMetricToNum(theme.global.edgeSize[thickness] || thickness);\n  const centerX = width / 2;\n  const centerY = width / 2;\n  const radius = width / 2 - strokeWidth / 2;\n  // truncate to avoid floating point arithmetic errors\n  // see: https://github.com/grommet/grommet/issues/6190\n  const anglePer =\n    Math.floor(((type === 'semicircle' ? 180 : 360) / max) * 10000) / 10000;\n  const someHighlight = (values || []).some((v) => v.highlight);\n\n  let startValue = 0;\n  let startAngle = type === 'semicircle' ? 270 : 0;\n  const paths = [];\n  let pathCaps = [];\n  (values || [])\n    .filter((v) => v.value > 0)\n    .forEach((valueArg, index) => {\n      const { color, highlight, label, onHover, value, ...pathRest } = valueArg;\n      const key = `p-${index}`;\n      const colorName =\n        color || defaultColor(index, theme, values ? values.length : 0);\n\n      let endAngle;\n      if (startValue + value >= max) {\n        endAngle = type === 'semicircle' ? 90 : 360;\n      } else {\n        endAngle = translateEndAngle(startAngle, anglePer, value);\n      }\n      let hoverProps;\n      if (onHover) {\n        hoverProps = {\n          onMouseOver: () => onHover(true),\n          onMouseLeave: () => onHover(false),\n        };\n      }\n      const stroke = strokeProps(\n        someHighlight && !highlight ? background : colorName,\n        theme,\n      );\n      if (round) {\n        const d1 = arcCommands(centerX, centerY, radius, startAngle, endAngle);\n        paths.unshift(\n          <path\n            key={key}\n            d={d1}\n            fill=\"none\"\n            {...stroke}\n            strokeWidth={strokeWidth}\n            strokeLinecap=\"round\"\n            {...hoverProps}\n            {...pathRest}\n          />,\n        );\n\n        // To handle situations where the last values are small, redraw\n        // a dot at the end. Give just a bit of angle to avoid anti-aliasing\n        // leakage around the edge.\n        const d2 = arcCommands(\n          centerX,\n          centerY,\n          radius,\n          endAngle - 0.5,\n          endAngle,\n        );\n        const pathCap = (\n          <path\n            key={`${key}-`}\n            d={d2}\n            fill=\"none\"\n            {...stroke}\n            strokeWidth={strokeWidth}\n            strokeLinecap=\"round\"\n            {...hoverProps}\n            {...pathRest}\n          />\n        );\n        // If we are on a large enough path to not need re-drawing previous\n        // ones, clear the pathCaps we've collected already.\n        if (endAngle - startAngle > 2 * anglePer) {\n          pathCaps = [];\n        }\n        pathCaps.unshift(pathCap);\n      } else {\n        const d = arcCommands(centerX, centerY, radius, startAngle, endAngle);\n        paths.push(\n          <path\n            key={key}\n            d={d}\n            fill=\"none\"\n            {...stroke}\n            strokeWidth={strokeWidth}\n            strokeLinecap=\"butt\"\n            {...hoverProps}\n            {...pathRest}\n          />,\n        );\n      }\n      startValue += value;\n      startAngle = endAngle;\n    });\n\n  let track;\n  if (type === 'semicircle') {\n    const d1 = arcCommands(centerX, centerY, radius, 270, 90);\n    track = (\n      <path\n        d={d1}\n        strokeWidth={strokeWidth}\n        fill=\"none\"\n        {...strokeProps(background, theme)}\n        strokeLinecap={round ? 'round' : 'square'}\n      />\n    );\n  } else {\n    track = (\n      <circle\n        cx={centerX}\n        cy={centerY}\n        r={radius}\n        {...strokeProps(background, theme)}\n        strokeWidth={strokeWidth}\n        strokeLinecap={round ? 'round' : 'square'}\n        fill=\"none\"\n      />\n    );\n  }\n\n  const viewBoxHeight = type === 'semicircle' ? width / 2 : width;\n\n  return (\n    <StyledMeter\n      ref={ref}\n      viewBox={`0 0 ${width} ${viewBoxHeight}`}\n      width={size === 'full' ? '100%' : width}\n      height={size === 'full' ? '100%' : viewBoxHeight}\n      {...rest}\n    >\n      {track}\n      {paths}\n      {pathCaps}\n    </StyledMeter>\n  );\n});\n\nCircle.displayName = 'Circle';\n\nCircle.defaultProps = {};\nObject.setPrototypeOf(Circle.defaultProps, defaultProps);\n\nexport { Circle };"
    },
    "3": {
        "bug_file": "src/js/components/Meter/utils.js",
        "compressed": "NO",
        "line_numbers": 46,
        "compressed_line_numbers": 46,
        "compressed_bug_file_content": "import { normalizeColor } from '../../utils';\n\nexport const strokeProps = (color, theme) => {\n  const result = {};\n  if (color) {\n    if (typeof color === 'object') {\n      result.stroke = normalizeColor(color.color, theme);\n      if (color.opacity) {\n        result.strokeOpacity = `${\n          color.opacity === true\n            ? theme.global.opacity.medium\n            : theme.global.opacity[color.opacity] || color.opacity\n        }`;\n      }\n    } else {\n      result.stroke = normalizeColor(color, theme);\n    }\n  }\n  return result;\n};\n\nconst neutralExp = /^neutral-\\d+/;\n\nexport const defaultColor = (index, theme, valuesLength) => {\n  if (index === valuesLength - 1 && theme.meter.color) {\n    return theme.meter.color;\n  }\n  // We want the last value to have the first color\n  const colorIndex = valuesLength - index - 1;\n  if (theme.meter && theme.meter.colors) {\n    const colors =\n      theme.meter.colors[theme.dark ? 'dark' : 'light'] || theme.meter.colors;\n    return colors[colorIndex % colors.length];\n  }\n  const colors = Object.keys(theme.global.colors).filter(n =>\n    n.match(/^graph-[0-9]$/),\n  );\n  if (colors.length > 0) {\n    return colors[colorIndex % colors.length];\n  }\n  // Deprecate using \"neutral-*\" color names. Remove eventually.\n  const neutralColors = Object.keys(theme.global.colors).filter(k =>\n    neutralExp.test(k),\n  );\n  return neutralColors[colorIndex % neutralColors.length];\n};"
    },
    "4": {
        "bug_file": "src/js/components/Meter/__tests__/Meter-test.tsx",
        "compressed": "NO",
        "line_numbers": 193,
        "compressed_line_numbers": 193,
        "compressed_bug_file_content": "import React from 'react';\nimport { render } from '@testing-library/react';\nimport 'jest-styled-components';\n\nimport { Grommet } from '../../Grommet';\nimport { Meter } from '..';\n\nconst VALUES = [{ value: 20, label: 'twenty', onHover: () => {} }];\n\ndescribe('Meter', () => {\n  test('default', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('single', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter value={25} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('basic', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter values={VALUES} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('many values', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter\n          values={[\n            { value: 5 },\n            { value: 5 },\n            { value: 5 },\n            { value: 5 },\n            { value: 5 },\n            { value: 5 },\n            { value: 5 },\n            { value: 5 },\n          ]}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('boundary values', () => {\n    // for https://github.com/grommet/grommet/issues/6190\n    const { container } = render(\n      <Grommet>\n        <Meter\n          type=\"circle\"\n          values={[{ value: 2.26 }, { value: 8.04 }]}\n          max={10.3}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('type', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter type=\"bar\" values={VALUES} />\n        <Meter type=\"circle\" values={VALUES} />\n        <Meter type=\"pie\" values={VALUES} />\n        <Meter type=\"semicircle\" values={VALUES} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('size', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter size=\"xsmall\" values={VALUES} />\n        <Meter size=\"small\" values={VALUES} />\n        <Meter size=\"medium\" values={VALUES} />\n        <Meter size=\"large\" values={VALUES} />\n        <Meter size=\"xlarge\" values={VALUES} />\n        <Meter size=\"24px\" values={VALUES} />\n        <Meter size=\"full\" values={VALUES} />\n        <Meter type=\"circle\" size=\"xsmall\" values={VALUES} />\n        <Meter type=\"circle\" size=\"small\" values={VALUES} />\n        <Meter type=\"circle\" size=\"medium\" values={VALUES} />\n        <Meter type=\"circle\" size=\"large\" values={VALUES} />\n        <Meter type=\"circle\" size=\"xlarge\" values={VALUES} />\n        <Meter type=\"circle\" size=\"55px\" values={VALUES} />\n        <Meter type=\"circle\" size=\"full\" values={VALUES} />\n        <Meter type=\"pie\" size=\"xsmall\" values={VALUES} />\n        <Meter type=\"pie\" size=\"small\" values={VALUES} />\n        <Meter type=\"pie\" size=\"medium\" values={VALUES} />\n        <Meter type=\"pie\" size=\"large\" values={VALUES} />\n        <Meter type=\"pie\" size=\"xlarge\" values={VALUES} />\n        <Meter type=\"pie\" size=\"55px\" values={VALUES} />\n        <Meter type=\"pie\" size=\"full\" values={VALUES} />\n        <Meter type=\"semicircle\" size=\"xsmall\" values={VALUES} />\n        <Meter type=\"semicircle\" size=\"small\" values={VALUES} />\n        <Meter type=\"semicircle\" size=\"medium\" values={VALUES} />\n        <Meter type=\"semicircle\" size=\"large\" values={VALUES} />\n        <Meter type=\"semicircle\" size=\"xlarge\" values={VALUES} />\n        <Meter type=\"semicircle\" size=\"55px\" values={VALUES} />\n        <Meter type=\"semicircle\" size=\"full\" values={VALUES} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('thickness', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter thickness=\"xsmall\" values={VALUES} />\n        <Meter thickness=\"small\" values={VALUES} />\n        <Meter thickness=\"medium\" values={VALUES} />\n        <Meter thickness=\"large\" values={VALUES} />\n        <Meter thickness=\"xlarge\" values={VALUES} />\n        <Meter thickness=\"55px\" values={VALUES} />\n        <Meter type=\"circle\" thickness=\"xsmall\" values={VALUES} />\n        <Meter type=\"circle\" thickness=\"small\" values={VALUES} />\n        <Meter type=\"circle\" thickness=\"medium\" values={VALUES} />\n        <Meter type=\"circle\" thickness=\"large\" values={VALUES} />\n        <Meter type=\"circle\" thickness=\"xlarge\" values={VALUES} />\n        <Meter type=\"circle\" thickness=\"55px\" values={VALUES} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('round', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter round values={VALUES} />\n        <Meter type=\"circle\" round values={VALUES} />\n        <Meter type=\"semicircle\" round values={VALUES} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('background', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter background=\"light-3\" values={VALUES} />\n        <Meter\n          background={{ color: 'light-3', opacity: 'medium' }}\n          values={VALUES}\n        />\n        <Meter type=\"circle\" background=\"light-3\" values={VALUES} />\n        <Meter\n          type=\"circle\"\n          background={{ color: 'light-3', opacity: 'medium' }}\n          values={VALUES}\n        />\n        <Meter\n          background={{ color: 'light-3', opacity: 0.2 }}\n          values={VALUES}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('vertical', () => {\n    const { container } = render(\n      <Grommet>\n        <Meter direction=\"vertical\" values={VALUES} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n});"
    }
}