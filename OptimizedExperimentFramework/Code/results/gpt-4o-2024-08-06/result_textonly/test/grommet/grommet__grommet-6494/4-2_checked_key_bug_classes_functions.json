{
    "bug_classes": {
        "1": {
            "class_name": "FormField (not found) 23-513",
            "file_path": "src/js/components/FormField/FormField.js",
            "class_details": [
                {
                    "name": "FormField",
                    "start_line": 23,
                    "end_line": 513
                }
            ],
            "class_code": [
                "import { FormFieldPropTypes } from './propTypes';",
                "",
                "const grommetInputNames = [",
                "  'CheckBox',",
                "  'CheckBoxGroup',",
                "  'TextInput',",
                "  'Select',",
                "  'MaskedInput',",
                "  'SelectMultiple',",
                "  'TextArea',",
                "  'DateInput',",
                "  'FileInput',",
                "  'RadioButtonGroup',",
                "  'RangeInput',",
                "];",
                "const grommetInputPadNames = [",
                "  'CheckBox',",
                "  'CheckBoxGroup',",
                "  'RadioButtonGroup',",
                "  'RangeInput',",
                "];",
                "",
                "const isGrommetInput = (comp) =>",
                "  comp &&",
                "  (grommetInputNames.indexOf(comp.displayName) !== -1 ||",
                "    grommetInputPadNames.indexOf(comp.displayName) !== -1);",
                "",
                "const FormFieldBox = styled(Box)`",
                "  ${(props) => props.focus && focusStyle({ justBorder: true })}",
                "  ${(props) => props.theme.formField && props.theme.formField.extend}",
                "`;",
                "",
                "const FormFieldContentBox = styled(Box)`",
                "  ${(props) => props.focus && focusStyle({ justBorder: true })}",
                "`;",
                "",
                "const StyledMessageContainer = styled(Box)`",
                "  ${(props) =>",
                "    props.messageType &&",
                "    props.theme.formField[props.messageType].container &&",
                "    props.theme.formField[props.messageType].container.extend}",
                "`;",
                "",
                "const RequiredText = styled(Text)`",
                "  color: inherit;",
                "  font-weight: inherit;",
                "  line-height: inherit;",
                "`;",
                "",
                "const Message = ({ error, info, message, type, ...rest }) => {",
                "  const theme = useContext(ThemeContext) || defaultProps.theme;",
                "",
                "  if (message) {",
                "    let icon;",
                "    let containerProps;",
                "",
                "    if (type) {",
                "      icon = theme.formField[type] && theme.formField[type].icon;",
                "      containerProps = theme.formField[type] && theme.formField[type].container;",
                "    }",
                "",
                "    let messageContent;",
                "    if (typeof message === 'string')",
                "      messageContent = <Text {...rest}>{message}</Text>;",
                "    else messageContent = <Box {...rest}>{message}</Box>;",
                "",
                "    return icon || containerProps ? (",
                "      <StyledMessageContainer",
                "        direction=\"row\"",
                "        messageType={type}",
                "        {...containerProps}",
                "      >",
                "        {icon && <Box flex={false}>{icon}</Box>}",
                "        {messageContent}",
                "      </StyledMessageContainer>",
                "    ) : (",
                "      messageContent",
                "    );",
                "  }",
                "  return null;",
                "};",
                "",
                "const Input = ({ component, disabled, invalid, name, onChange, ...rest }) => {",
                "  const formContext = useContext(FormContext);",
                "  const [value, setValue] = formContext.useFormInput({",
                "    name,",
                "    value: rest.value,",
                "  });",
                "  const InputComponent = component || TextInput;",
                "  // Grommet input components already check for FormContext",
                "  // and, using their `name`, end up calling the useFormInput.setValue()",
                "  // already. For custom components, we expect they will call",
                "  // this onChange() and we'll call setValue() here, primarily",
                "  // for backwards compatibility.",
                "  const extraProps = isGrommetInput(InputComponent)",
                "    ? { focusIndicator: false, onChange, plain: true }",
                "    : {",
                "        value,",
                "        onChange: (event) => {",
                "          setValue(",
                "            event.value !== undefined ? event.value : event.target.value,",
                "          );",
                "          if (onChange) onChange(event);",
                "        },",
                "      };",
                "  return (",
                "    <InputComponent",
                "      name={name}",
                "      disabled={disabled}",
                "      aria-invalid={invalid || undefined}",
                "      {...rest}",
                "      {...extraProps}",
                "    />",
                "  );",
                "};",
                "",
                "const useDebounce = () => {",
                "  const [func, setFunc] = useState();",
                "  const theme = useContext(ThemeContext) || defaultProps.theme;",
                "",
                "  useEffect(() => {",
                "    let timer;",
                "    if (func) timer = setTimeout(() => func(), theme.global.debounceDelay);",
                "    return () => clearTimeout(timer);",
                "  }, [func, theme.global.debounceDelay]);",
                "",
                "  return setFunc;",
                "};",
                "",
                "const FormField = forwardRef(",
                "  (",
                "    {",
                "      children,",
                "      className,",
                "      component,",
                "      contentProps,",
                "      disabled, // pass through in renderInput()",
                "      error: errorProp,",
                "      help,",
                "      htmlFor,",
                "      info: infoProp,",
                "      label,",
                "      margin,",
                "      name, // pass through in renderInput()",
                "      onBlur,",
                "      onChange,",
                "      onFocus,",
                "      pad,",
                "      required,",
                "      style,",
                "      validate,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const theme = useContext(ThemeContext) || defaultProps.theme;",
                "    const formContext = useContext(FormContext);",
                "    const {",
                "      error,",
                "      info,",
                "      inForm,",
                "      onBlur: contextOnBlur,",
                "      onChange: contextOnChange,",
                "    } = formContext.useFormField({",
                "      disabled,",
                "      error: errorProp,",
                "      info: infoProp,",
                "      name,",
                "      required,",
                "      validate,",
                "    });",
                "    const [focus, setFocus] = useState();",
                "    const formFieldRef = useForwardedRef(ref);",
                "",
                "    const { formField: formFieldTheme } = theme;",
                "    const { border: themeBorder } = formFieldTheme;",
                "    const debounce = useDebounce();",
                "",
                "    // This is here for backwards compatibility. In case the child is a grommet",
                "    // input component, set plain and focusIndicator props, if they aren't",
                "    // already set.",
                "    let wantContentPad =",
                "      component &&",
                "      (component === CheckBox ||",
                "        component === CheckBoxGroup ||",
                "        component === RadioButtonGroup);",
                "",
                "    let contents =",
                "      (themeBorder &&",
                "        children &&",
                "        Children.map(children, (child) => {",
                "          if (",
                "            child &&",
                "            child.type &&",
                "            grommetInputPadNames.indexOf(child.type.displayName) !== -1",
                "          ) {",
                "            wantContentPad = true;",
                "          }",
                "          if (",
                "            child &&",
                "            child.type &&",
                "            grommetInputNames.indexOf(child.type.displayName) !== -1 &&",
                "            child.props.plain === undefined &&",
                "            child.props.focusIndicator === undefined",
                "          ) {",
                "            return cloneElement(child, {",
                "              plain: true,",
                "              focusIndicator: false,",
                "              pad:",
                "                'CheckBox'.indexOf(child.type.displayName) !== -1",
                "                  ? formFieldTheme?.checkBox?.pad",
                "                  : undefined,",
                "            });",
                "          }",
                "          return child;",
                "        })) ||",
                "      children;",
                "",
                "    // put rest on container, unless we use internal Input",
                "    let containerRest = rest;",
                "    if (inForm) {",
                "      if (!contents) containerRest = {};",
                "      contents = contents || (",
                "        <Input",
                "          component={component}",
                "          disabled={disabled}",
                "          invalid={!!error}",
                "          name={name}",
                "          label={component === CheckBox ? label : undefined}",
                "          {...rest}",
                "        />",
                "      );",
                "    }",
                "",
                "    const themeContentProps = { ...formFieldTheme.content };",
                "",
                "    if (!pad && !wantContentPad) {",
                "      themeContentProps.pad = undefined;",
                "    }",
                "",
                "    if (themeBorder && themeBorder.position === 'inner') {",
                "      if (error && formFieldTheme.error) {",
                "        themeContentProps.background = formFieldTheme.error.background;",
                "      } else if (disabled && formFieldTheme.disabled) {",
                "        themeContentProps.background = formFieldTheme.disabled.background;",
                "      }",
                "    }",
                "",
                "    // fileinput handle",
                "    // use fileinput plain use formfield to drive the border",
                "    let isFileInputComponent;",
                "    if (",
                "      children &&",
                "      Children.forEach(children, (child) => {",
                "        if (",
                "          child &&",
                "          child.type &&",
                "          'FileInput'.indexOf(child.type.displayName) !== -1",
                "        )",
                "          isFileInputComponent = true;",
                "      })",
                "    );",
                "",
                "    if (",
                "      component &&",
                "      component.displayName === 'FileInput' &&",
                "      !isFileInputComponent",
                "    ) {",
                "      isFileInputComponent = true;",
                "    }",
                "",
                "    if (!themeBorder) {",
                "      contents = (",
                "        <Box {...themeContentProps} {...contentProps}>",
                "          {contents}",
                "        </Box>",
                "      );",
                "    }",
                "",
                "    let borderColor;",
                "",
                "    if (",
                "      disabled &&",
                "      formFieldTheme.disabled.border &&",
                "      formFieldTheme.disabled.border.color",
                "    ) {",
                "      borderColor = formFieldTheme.disabled.border.color;",
                "    } else if (",
                "      // backward compatibility check",
                "      (error && themeBorder && themeBorder.error.color) ||",
                "      (error && formFieldTheme.error && formFieldTheme.error.border)",
                "    ) {",
                "      if (",
                "        themeBorder.error.color &&",
                "        formFieldTheme.error.border === undefined",
                "      ) {",
                "        borderColor = themeBorder.error.color || 'status-critical';",
                "      } else if (",
                "        formFieldTheme.error.border &&",
                "        formFieldTheme.error.border.color",
                "      ) {",
                "        borderColor = formFieldTheme.error.border.color || 'status-critical';",
                "      }",
                "    } else if (",
                "      focus &&",
                "      formFieldTheme.focus &&",
                "      formFieldTheme.focus.border &&",
                "      formFieldTheme.focus.border.color",
                "    ) {",
                "      borderColor = formFieldTheme.focus.border.color;",
                "    } else {",
                "      borderColor = (themeBorder && themeBorder.color) || 'border';",
                "    }",
                "",
                "    const labelStyle = { ...formFieldTheme.label };",
                "",
                "    if (disabled) {",
                "      labelStyle.color =",
                "        formFieldTheme.disabled && formFieldTheme.disabled.label",
                "          ? formFieldTheme.disabled.label.color",
                "          : labelStyle.color;",
                "    }",
                "",
                "    let abut;",
                "    let abutMargin;",
                "    let outerStyle = style;",
                "",
                "    // If fileinput is wrapped in a formfield we want to use",
                "    // the border style from the fileInput.theme. We also do not",
                "    // want the foocus around the formfield since the the focus",
                "    // is on the anchor/button inside fileinput",
                "",
                "    if (themeBorder) {",
                "      const innerProps =",
                "        themeBorder.position === 'inner'",
                "          ? {",
                "              border: {",
                "                ...themeBorder,",
                "                size: isFileInputComponent",
                "                  ? theme.fileInput.border.size",
                "                  : undefined,",
                "                style: isFileInputComponent",
                "                  ? theme.fileInput.border.style",
                "                  : undefined,",
                "                side: isFileInputComponent",
                "                  ? theme.fileInput.border.side",
                "                  : themeBorder.side || 'bottom',",
                "                color: borderColor,",
                "              },",
                "              round: formFieldTheme.round,",
                "              focus: isFileInputComponent ? undefined : focus,",
                "            }",
                "          : {};",
                "      contents = (",
                "        <FormFieldContentBox",
                "          {...themeContentProps}",
                "          {...innerProps}",
                "          {...contentProps}",
                "        >",
                "          {contents}",
                "        </FormFieldContentBox>",
                "      );",
                "",
                "      const mergedMargin = margin || formFieldTheme.margin;",
                "      abut =",
                "        themeBorder.position === 'outer' &&",
                "        (themeBorder.side === 'all' ||",
                "          themeBorder.side === 'horizontal' ||",
                "          !themeBorder.side) &&",
                "        !(",
                "          mergedMargin &&",
                "          ((typeof mergedMargin === 'string' && mergedMargin !== 'none') ||",
                "            (mergedMargin.bottom && mergedMargin.bottom !== 'none') ||",
                "            (mergedMargin.horizontal && mergedMargin.horizontal !== 'none'))",
                "        );",
                "      if (abut) {",
                "        // marginBottom is set to overlap adjacent fields",
                "        abutMargin = { bottom: '-1px' };",
                "        if (margin) {",
                "          abutMargin = margin;",
                "        } else if (themeBorder.size) {",
                "          // if the user defines a margin,",
                "          // then the default margin below will be overridden",
                "          abutMargin = {",
                "            bottom: `-${parseMetricToNum(",
                "              theme.global.borderSize[themeBorder.size] || themeBorder.size,",
                "            )}px`,",
                "          };",
                "        }",
                "",
                "        outerStyle = {",
                "          position: focus ? 'relative' : undefined,",
                "          zIndex: focus ? 10 : undefined,",
                "          ...style,",
                "        };",
                "      }",
                "    }",
                "",
                "    let outerBackground;",
                "",
                "    if (themeBorder && themeBorder.position === 'outer') {",
                "      if (error && formFieldTheme.error && formFieldTheme.error.background) {",
                "        outerBackground = formFieldTheme.error.background;",
                "      } else if (",
                "        focus &&",
                "        formFieldTheme.focus &&",
                "        formFieldTheme.focus.background &&",
                "        formFieldTheme.focus.background.color",
                "      ) {",
                "        outerBackground = formFieldTheme.focus.background.color;",
                "      } else if (",
                "        disabled &&",
                "        formFieldTheme.disabled &&",
                "        formFieldTheme.disabled.background",
                "      ) {",
                "        outerBackground = formFieldTheme.disabled.background;",
                "      }",
                "    }",
                "",
                "    const outerProps =",
                "      themeBorder && themeBorder.position === 'outer'",
                "        ? {",
                "            border: { ...themeBorder, color: borderColor },",
                "            round: formFieldTheme.round,",
                "            focus,",
                "          }",
                "        : {};",
                "",
                "    let { requiredIndicator } = theme.formField.label;",
                "    if (requiredIndicator === true)",
                "      // a11yTitle necessary so screenreader announces as \"required\"",
                "      // as opposed to \"star\"",
                "      // accessibility resource: https://www.deque.com/blog/anatomy-of-accessible-forms-required-form-fields/",
                "      requiredIndicator = <RequiredText a11yTitle=\"required\">*</RequiredText>;",
                "",
                "    let showRequiredIndicator = required && requiredIndicator;",
                "    if (typeof required === 'object' && required.indicator === false)",
                "      showRequiredIndicator = false;",
                "",
                "    return (",
                "      <FormFieldBox",
                "        ref={formFieldRef}",
                "        className={className}",
                "        background={outerBackground}",
                "        margin={abut ? abutMargin : margin || { ...formFieldTheme.margin }}",
                "        {...outerProps}",
                "        style={outerStyle}",
                "        onFocus={(event) => {",
                "          setFocus(containsFocus(formFieldRef.current) && shouldKeepFocus());",
                "          if (onFocus) onFocus(event);",
                "        }}",
                "        onBlur={(event) => {",
                "          setFocus(false);",
                "          if (contextOnBlur) contextOnBlur(event);",
                "          if (onBlur) onBlur(event);",
                "        }}",
                "        onChange={",
                "          contextOnChange || onChange",
                "            ? (event) => {",
                "                event.persist();",
                "                if (onChange) onChange(event);",
                "                if (contextOnChange)",
                "                  debounce(() => () => contextOnChange(event));",
                "              }",
                "            : undefined",
                "        }",
                "        {...containerRest}",
                "      >",
                "        {(label && component !== CheckBox) || help ? (",
                "          <>",
                "            {label && component !== CheckBox && (",
                "              <Text as=\"label\" htmlFor={htmlFor} {...labelStyle}>",
                "                {label}",
                "                {showRequiredIndicator ? requiredIndicator : undefined}",
                "              </Text>",
                "            )}",
                "            <Message message={help} {...formFieldTheme.help} />",
                "          </>",
                "        ) : undefined}",
                "        {contents}",
                "        <Message type=\"error\" message={error} {...formFieldTheme.error} />",
                "        <Message type=\"info\" message={info} {...formFieldTheme.info} />",
                "      </FormFieldBox>",
                "    );",
                "  },",
                ");",
                "",
                "FormField.displayName = 'FormField';",
                "FormField.propTypes = FormFieldPropTypes;",
                "",
                "export { FormField };"
            ]
        },
        "2": {
            "class_name": "RangeInput (not found) ",
            "file_path": "src/js/components/RangeInput/RangeInput.js",
            "class_details": [
                {
                    "name": "RangeInput",
                    "start_line": 1,
                    "end_line": 132
                }
            ],
            "class_code": [
                "import React, {",
                "  forwardRef,",
                "  useContext,",
                "  useState,",
                "  useCallback,",
                "  useEffect,",
                "} from 'react';",
                "",
                "import { FormContext } from '../Form/FormContext';",
                "import { StyledRangeInput } from './StyledRangeInput';",
                "import { RangeInputPropTypes } from './propTypes';",
                "import { useForwardedRef } from '../../utils';",
                "",
                "const RangeInput = forwardRef(",
                "  (",
                "    {",
                "      a11yTitle,",
                "      color,",
                "      focus: focusProp,",
                "      // When in a FormField, focusIndicator = false,",
                "      // so that the FormField has focus style. If RangeInput",
                "      // is not in a FormField, it will have focus.",
                "      focusIndicator = true,",
                "      name,",
                "      onChange,",
                "      onFocus,",
                "      onBlur,",
                "      value: valueProp,",
                "      step = 1,",
                "      min = 0,",
                "      max = 100,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const formContext = useContext(FormContext);",
                "    const [focus, setFocus] = useState(focusProp);",
                "",
                "    const [value, setValue] = formContext.useFormInput({",
                "      name,",
                "      value: valueProp,",
                "    });",
                "",
                "    const [scroll, setScroll] = useState({",
                "      x: null,",
                "      y: null,",
                "    });",
                "    const rangeInputRef = useForwardedRef(ref);",
                "",
                "    useEffect(() => {",
                "      const { x, y } = scroll;",
                "      if (x !== null && y !== null) {",
                "        const handleScrollTo = () => window.scrollTo(x, y);",
                "        window.addEventListener('scroll', handleScrollTo);",
                "        return () => window.removeEventListener('scroll', handleScrollTo);",
                "      }",
                "      return undefined;",
                "    }, [scroll]);",
                "",
                "    const setRangeInputValue = useCallback(",
                "      (nextValue) => {",
                "        if (nextValue > max || nextValue < min) return;",
                "        // Calling set value function directly on input because React library",
                "        // overrides setter `event.target.value =` and loses original event",
                "        // target fidelity.",
                "        // https://stackoverflow.com/a/46012210",
                "        const nativeInputValueSetter = Object.getOwnPropertyDescriptor(",
                "          window.HTMLInputElement.prototype,",
                "          'value',",
                "        ).set;",
                "        nativeInputValueSetter.call(rangeInputRef.current, nextValue);",
                "        const event = new Event('input', { bubbles: true });",
                "        rangeInputRef.current.dispatchEvent(event);",
                "      },",
                "      [rangeInputRef, min, max],",
                "    );",
                "",
                "    const handleOnWheel = (event) => {",
                "      const newValue = parseFloat(value);",
                "      if (event.deltaY < 0) {",
                "        setRangeInputValue(newValue + step);",
                "      } else {",
                "        setRangeInputValue(newValue - step);",
                "      }",
                "    };",
                "    // This is to make sure scrollbar doesn't move",
                "    // when user changes RangeInput value.",
                "    const handleMouseOver = () =>",
                "      setScroll({ x: window.scrollX, y: window.scrollY });",
                "    const handleMouseOut = () => setScroll({ x: null, y: null });",
                "",
                "    return (",
                "      <StyledRangeInput",
                "        aria-label={a11yTitle}",
                "        aria-valuemax={max}",
                "        aria-valuemin={min}",
                "        aria-valuenow={value}",
                "        ref={rangeInputRef}",
                "        name={name}",
                "        focus={focus}",
                "        focusIndicator={focusIndicator}",
                "        value={value}",
                "        {...rest}",
                "        color={color}",
                "        onFocus={(event) => {",
                "          setFocus(true);",
                "          if (onFocus) onFocus(event);",
                "        }}",
                "        onBlur={(event) => {",
                "          setFocus(false);",
                "          if (onBlur) onBlur(event);",
                "        }}",
                "        onChange={(event) => {",
                "          setValue(event.target.value);",
                "          if (onChange) onChange(event);",
                "        }}",
                "        onMouseOver={handleMouseOver}",
                "        onMouseOut={handleMouseOut}",
                "        onWheel={handleOnWheel}",
                "        step={step}",
                "        type=\"range\"",
                "        min={min}",
                "        max={max}",
                "      />",
                "    );",
                "  },",
                ");",
                "",
                "RangeInput.displayName = 'RangeInput';",
                "RangeInput.propTypes = RangeInputPropTypes;",
                "",
                "export { RangeInput };"
            ]
        },
        "3": {
            "class_name": "StyledRangeInput (not found) ",
            "file_path": "src/js/components/RangeInput/StyledRangeInput.js",
            "class_details": [
                {
                    "name": "StyledRangeInput",
                    "start_line": 1,
                    "end_line": 320
                }
            ],
            "class_code": [
                "import styled, { css } from 'styled-components';",
                "",
                "import {",
                "  disabledStyle,",
                "  edgeStyle,",
                "  focusStyle,",
                "  normalizeColor,",
                "  parseMetricToNum,",
                "  getRGBA,",
                "} from '../../utils';",
                "import { defaultProps } from '../../default-props';",
                "",
                "// opacity of the bound trumps the track opacity",
                "const getBoundOpacity = (props, bound) =>",
                "  props.theme.rangeInput &&",
                "  props.theme.rangeInput.track &&",
                "  props.theme.rangeInput.track[bound] &&",
                "  props.theme.rangeInput.track[bound].opacity",
                "    ? props.theme.rangeInput.track[bound].opacity",
                "    : 1;",
                "",
                "const getBoundColor = (props, bound) => {",
                "  if (",
                "    props.theme.rangeInput &&",
                "    props.theme.rangeInput.track &&",
                "    props.theme.rangeInput.track[bound] &&",
                "    props.theme.rangeInput.track[bound].color",
                "  ) {",
                "    return getRGBA(",
                "      normalizeColor(props.theme.rangeInput.track[bound].color, props.theme),",
                "      getBoundOpacity(props, bound),",
                "    );",
                "  }",
                "  // If bound color is undefined pick the default track color with bound opacity",
                "  return getRGBA(",
                "    normalizeColor(props.theme.rangeInput.track.color, props.theme),",
                "    getBoundOpacity(props, bound),",
                "  );",
                "};",
                "",
                "const trackColorStyle = (props) => {",
                "  const { max, min } = props;",
                "  const thumbPosition = `${(((props.value || 0) - min) / (max - min)) * 100}%`;",
                "  let defaultTrackColor;",
                "",
                "  // backward compatibility in case no bounds are defined",
                "  if (",
                "    props.theme.rangeInput &&",
                "    props.theme.rangeInput.track &&",
                "    !props.theme.rangeInput.track.lower &&",
                "    !props.theme.rangeInput.track.upper",
                "  ) {",
                "    const color = getRGBA(",
                "      normalizeColor(props.theme.rangeInput.track.color, props.theme),",
                "      0.2,",
                "    );",
                "    // Since the track color was changed from border-with-opacity to just border",
                "    // this condition is used to make sure we are applying the opacity correctly",
                "    // for 'border' color (for backward compatibility purposes).",
                "    if (color === 'rgba(0, 0, 0, 0.2)') {",
                "      defaultTrackColor = color;",
                "    }",
                "    // no bounds are defined but color may have changed",
                "    else {",
                "      defaultTrackColor = getRGBA(",
                "        normalizeColor(props.theme.rangeInput.track.color, props.theme),",
                "        props.theme.rangeInput.track.opacity || 1,",
                "      );",
                "    }",
                "",
                "    if (!props.color) return `background: ${defaultTrackColor}`;",
                "  }",
                "",
                "  const upperTrackColor = props.theme.rangeInput.track?.upper",
                "    ? getBoundColor(props, 'upper')",
                "    : defaultTrackColor;",
                "",
                "  let lowerTrackColor = props.theme.rangeInput.track?.lower",
                "    ? getBoundColor(props, 'lower')",
                "    : getRGBA(",
                "        normalizeColor(props.theme.global.colors.control, props.theme),",
                "        props.theme.rangeInput.track.opacity || 1,",
                "      );",
                "",
                "  if (",
                "    typeof props.color === 'string' ||",
                "    (typeof props.color === 'object' && !Array.isArray(props.color))",
                "  ) {",
                "    lowerTrackColor = normalizeColor(props.color, props.theme);",
                "",
                "    return `background: linear-gradient(",
                "        to right,",
                "        ${lowerTrackColor},",
                "        ${lowerTrackColor} ${thumbPosition},",
                "        ${upperTrackColor} ${thumbPosition},",
                "        ${upperTrackColor}",
                "      );",
                "    `;",
                "  }",
                "  if (Array.isArray(props.color)) {",
                "    const arrayOfTrackColors = props.color;",
                "    let valuePercentage = 0;",
                "    let result = `background: linear-gradient(to right,`;",
                "    for (let index = 0; index < arrayOfTrackColors.length; index += 1) {",
                "      const { value, color, opacity } = arrayOfTrackColors[index];",
                "      result += `${getRGBA(",
                "        normalizeColor(color, props.theme),",
                "        opacity || 1,",
                "      )} ${valuePercentage}%,`;",
                "",
                "      if (props.value >= value) {",
                "        valuePercentage = ((value - min) / (max - min)) * 100;",
                "        result += `${getRGBA(",
                "          normalizeColor(color, props.theme),",
                "          opacity || 1,",
                "        )} ${valuePercentage}%,`;",
                "      } else {",
                "        result += `${getRGBA(",
                "          normalizeColor(color, props.theme),",
                "          opacity || 1,",
                "        )} ${thumbPosition},`;",
                "        result += `${upperTrackColor} ${thumbPosition}, ${upperTrackColor})`;",
                "        break;",
                "      }",
                "      if (index === arrayOfTrackColors.length - 1) {",
                "        result += `${upperTrackColor} ${valuePercentage}%, ${upperTrackColor})`;",
                "      }",
                "    }",
                "    return result;",
                "  }",
                "",
                "  return `background: linear-gradient(",
                "      to right,",
                "      ${lowerTrackColor},",
                "      ${lowerTrackColor} ${thumbPosition},",
                "      ${upperTrackColor} ${thumbPosition},",
                "      ${upperTrackColor}",
                "    );",
                "  `;",
                "};",
                "",
                "const disabledRangeInputStyle = (props, context) => css`",
                "  ${disabledStyle(props.theme.rangeInput.disabled.opacity)}",
                "  ${props.theme.rangeInput.disabled[context]?.color &&",
                "  `background: ${normalizeColor(",
                "    props.theme.rangeInput.disabled[context].color,",
                "    props.theme,",
                "  )};`}",
                "`;",
                "",
                "const hoverStyle = (props) => css`",
                "  box-shadow: 0px 0px 0px 2px",
                "    ${normalizeColor(",
                "      props.theme.rangeInput.thumb.color || 'control',",
                "      props.theme,",
                "    )};",
                "`;",
                "",
                "const rangeTrackStyle = css`",
                "  box-sizing: border-box;",
                "  width: 100%;",
                "  height: ${(props) => props.theme.rangeInput.track.height};",
                "  ${(props) => trackColorStyle(props)};",
                "  ${(props) =>",
                "    props.theme.rangeInput &&",
                "    props.theme.rangeInput.track &&",
                "    props.theme.rangeInput.track.extend}",
                "  ${(props) =>",
                "    props.disabled &&",
                "    props.theme?.rangeInput?.disabled &&",
                "    disabledRangeInputStyle(props, 'track')};",
                "`;",
                "",
                "const rangeThumbStyle = css`",
                "  box-sizing: border-box;",
                "  position: relative;",
                "  border-radius: ${(props) => props.theme.global.spacing};",
                "  height: ${(props) => props.theme.global.spacing};",
                "  width: ${(props) => props.theme.global.spacing};",
                "  overflow: visible;",
                "  background: ${(props) =>",
                "    normalizeColor(",
                "      props.theme.rangeInput.thumb.color || 'control',",
                "      props.theme,",
                "    )};",
                "  -webkit-appearance: none;",
                "  cursor: pointer;",
                "  ${(props) =>",
                "    props.theme.rangeInput &&",
                "    props.theme.rangeInput.thumb &&",
                "    props.theme.rangeInput.thumb.extend}",
                "  ${(props) =>",
                "    props.disabled &&",
                "    props.theme?.rangeInput?.disabled &&",
                "    disabledRangeInputStyle(props, 'thumb')};",
                "`;",
                "",
                "const firefoxMicrosoftThumbStyle = css`",
                "  ${rangeThumbStyle} margin-top: 0px;",
                "  height: ${(props) => props.theme.global.spacing};",
                "  width: ${(props) => props.theme.global.spacing};",
                "  ${(props) => props.focus && props.focusIndicator && focusStyle()}",
                "  ${(props) =>",
                "    props.theme.rangeInput &&",
                "    props.theme.rangeInput.thumb &&",
                "    props.theme.rangeInput.thumb.extend}",
                "`;",
                "",
                "/* eslint-disable max-len */",
                "const StyledRangeInput = styled.input`",
                "  box-sizing: border-box;",
                "  position: relative;",
                "  -webkit-appearance: none;",
                "  border-color: transparent;",
                "  height: ${(props) => props.theme.global.spacing};",
                "  width: 100%;",
                "  padding: 0px;",
                "  cursor: ${(props) => (props.disabled ? 'default' : 'pointer')};",
                "  background: transparent;",
                "",
                "  ${(props) =>",
                "    props.theme.rangeInput.pad &&",
                "    edgeStyle(",
                "      'padding',",
                "      props.theme.rangeInput.pad,",
                "      props.responsive,",
                "      props.theme.box.responsiveBreakpoint,",
                "      props.theme,",
                "    )}",
                "",
                "  &::-moz-focus-inner {",
                "    border: none;",
                "  }",
                "",
                "  &::-moz-focus-outer {",
                "    border: none;",
                "  }",
                "",
                "  &::-webkit-slider-runnable-track {",
                "    ${rangeTrackStyle}",
                "  }",
                "",
                "  &::-webkit-slider-thumb {",
                "    margin-top: -${(props) => (parseMetricToNum(props.theme.global.spacing) - parseMetricToNum(props.theme.rangeInput.track.height || 0)) * 0.5}px;",
                "    ${rangeThumbStyle}",
                "    ${(props) =>",
                "      !props.disabled &&",
                "      css`",
                "        &:hover {",
                "          ${hoverStyle(props)}",
                "        }",
                "      `}",
                "    ${(props) =>",
                "      props.focus &&",
                "      !props.focusIndicator &&",
                "      css`",
                "        ${hoverStyle(props)}",
                "      `}",
                "  }",
                "",
                "  &::-moz-range-track {",
                "    ${rangeTrackStyle}",
                "  }",
                "",
                "  &::-moz-range-thumb {",
                "    ${firefoxMicrosoftThumbStyle}",
                "  }",
                "",
                "  &::-ms-thumb {",
                "    ${firefoxMicrosoftThumbStyle}",
                "  }",
                "",
                "  ${(props) =>",
                "    !props.disabled &&",
                "    css`",
                "      &:hover::-moz-range-thumb {",
                "        ${hoverStyle(props)}",
                "      }",
                "",
                "      &:hover::-ms-thumb {",
                "        ${hoverStyle(props)}",
                "      }",
                "    `}",
                "",
                "  &::-ms-track {",
                "    ${rangeTrackStyle}",
                "    border-color: transparent;",
                "    color: transparent;",
                "  }",
                "",
                "  &::-ms-fill-lower {",
                "    ${(props) => trackColorStyle(props, 'lower')};",
                "    border-color: transparent;",
                "  }",
                "",
                "  &::-ms-fill-upper {",
                "    ${(props) => trackColorStyle(props, 'upper')};",
                "    border-color: transparent;",
                "  }",
                "",
                "  &:focus::-webkit-slider-thumb {",
                "    ${(props) => props.focus && props.focusIndicator && focusStyle()}",
                "  }",
                "",
                "  &:focus-visible {",
                "    outline: 0;",
                "  }",
                "  // to remove browser default on safari",
                "  &:focus {",
                "    outline: none;",
                "  }",
                "",
                "  ${(props) => props.theme.rangeInput && props.theme.rangeInput.extend}",
                "`;",
                "/* eslint-enable max-len */",
                "",
                "StyledRangeInput.defaultProps = {};",
                "Object.setPrototypeOf(StyledRangeInput.defaultProps, defaultProps);",
                "",
                "export { StyledRangeInput };"
            ]
        }
    },
    "bug_functions": {}
}