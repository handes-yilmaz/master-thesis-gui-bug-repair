{
    "bug_classes": {
        "1": {
            "class_name": "FormContext (not found) ",
            "file_path": "src/js/components/Form/FormContext.js",
            "class_details": [
                {
                    "name": "FormContext",
                    "start_line": 1,
                    "end_line": 24
                }
            ],
            "class_code": [
                "import React, { useState } from 'react';",
                "",
                "// When not a descendant of a Form, FormContext still provides a basic",
                "// useFormInput. It doesn't do anything for components like TextInput.",
                "// But, it does store the value for components like CheckBox or Select",
                "// where the grommet component needs to know the value in order to",
                "// render custom visuals.",
                "const useFormInput = ({ value: valueProp, initialValue }) => {",
                "  const [value, setValue] = useState(",
                "    valueProp !== undefined ? valueProp : initialValue,",
                "  );",
                "",
                "  // Returns an array [value and function to set the value]",
                "  return [",
                "    valueProp !== undefined ? valueProp : value,",
                "    (nextValue) => {",
                "      if (initialValue !== undefined) setValue(nextValue);",
                "    },",
                "  ];",
                "};",
                "",
                "const useFormField = ({ error, info, disabled }) => ({ error, info, disabled });",
                "",
                "export const FormContext = React.createContext({ useFormField, useFormInput });"
            ]
        }
    },
    "bug_functions": {
        "2": {
            "function_name": "onValidate (not found) 169-604",
            "file_path": "src/js/components/Form/Form.js",
            "function_details": [
                {
                    "name": "onValidate",
                    "start_line": 169,
                    "end_line": 604
                }
            ],
            "function_code": [
                "      onValidate,",
                "      validate: validateOn = 'submit',",
                "      value: valueProp,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const { format } = useContext(MessageContext);",
                "    const [valueState, setValueState] = useState(valueProp || defaultValue);",
                "    const value = useMemo(",
                "      () => valueProp || valueState,",
                "      [valueProp, valueState],",
                "    );",
                "    const [touched, setTouched] = useState(defaultTouched);",
                "    const [validationResults, setValidationResults] = useState({",
                "      errors: errorsProp,",
                "      infos: infosProp,",
                "    });",
                "    // maintain a copy of validationResults in a ref for useEffects",
                "    // which can't depend on validationResults directly without",
                "    // causing infinite renders.",
                "    const validationResultsRef = useRef({});",
                "    // Simulated onMount state. Consider Form to be mounted once it has",
                "    // accounted for values originating from controlled inputs (available",
                "    // at second rendering).",
                "    const [mounted, setMounted] = useState('unmounted');",
                "    useEffect(() => {",
                "      if (!mounted) setMounted('mounting');",
                "      else if (mounted === 'mounting') setMounted('mounted');",
                "    }, [mounted]);",
                "    // `pendingValidation` is the name of the FormField awaiting validation.",
                "    const [pendingValidation, setPendingValidation] = useState(undefined);",
                "",
                "    const validationRulesRef = useRef({});",
                "    const requiredFields = useRef([]);",
                "",
                "    const buildValid = useCallback(",
                "      (nextErrors) => {",
                "        let valid = false;",
                "        valid = requiredFields.current",
                "          .filter((n) => Object.keys(validationRulesRef.current).includes(n))",
                "          .every(",
                "            (field) =>",
                "              value[field] && (value[field] !== '' || value[field] !== false),",
                "          );",
                "",
                "        if (Object.keys(nextErrors).length > 0) valid = false;",
                "        return valid;",
                "      },",
                "      [value],",
                "    );",
                "",
                "    // Only keep validation results for current form fields. In the case of a",
                "    // dynamic form, a field possessing an error may have been removed from the",
                "    // form; need to clean up any previous related validation results.",
                "    const filterRemovedFields = (prevValidations) => {",
                "      const nextValidations = prevValidations;",
                "      return Object.keys(nextValidations)",
                "        .filter(",
                "          (n) =>",
                "            !validationRulesRef.current[n] || nextValidations[n] === undefined,",
                "        )",
                "        .forEach((n) => delete nextValidations[n]);",
                "    };",
                "",
                "    const applyValidationRules = useCallback(",
                "      (validationRules) => {",
                "        const [validatedErrors, validatedInfos] = validateForm(",
                "          validationRules,",
                "          value,",
                "          format,",
                "          messages,",
                "        );",
                "",
                "        setValidationResults((prevValidationResults) => {",
                "          // Keep any previous errors and infos for untouched keys,",
                "          // these may have come from a Submit.",
                "          const nextErrors = {",
                "            ...prevValidationResults.errors,",
                "            ...validatedErrors,",
                "          };",
                "          const nextInfos = {",
                "            ...prevValidationResults.infos,",
                "            ...validatedInfos,",
                "          };",
                "          // Remove previous errors and infos for keys no longer in the",
                "          // form, these may have been fields removed from a dynamic form.",
                "          filterRemovedFields(nextErrors);",
                "          filterRemovedFields(nextInfos);",
                "          const nextValidationResults = {",
                "            errors: nextErrors,",
                "            infos: nextInfos,",
                "          };",
                "          if (onValidate)",
                "            onValidate({",
                "              ...nextValidationResults,",
                "              valid: buildValid(nextErrors),",
                "            });",
                "          validationResultsRef.current = nextValidationResults;",
                "          return nextValidationResults;",
                "        });",
                "      },",
                "      [buildValid, format, messages, onValidate, value],",
                "    );",
                "",
                "    // Validate all fields holding values onMount if set to",
                "    // validate when blur or change.",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      // Use simulated onMount state to account for values provided by",
                "      // controlled inputs.",
                "      if (",
                "        mounted !== 'mounted' &&",
                "        ['blur', 'change'].includes(validateOn) &&",
                "        Object.keys(value).length > 0 &&",
                "        Object.keys(touched).length === 0",
                "      ) {",
                "        applyValidationRules(",
                "          validationRules",
                "            .filter(([n]) => value[n])",
                "            // Exlude empty arrays which may be initial values in",
                "            // an input such as DateInput.",
                "            .filter(",
                "              ([n]) => !(Array.isArray(value[n]) && value[n].length === 0),",
                "            ),",
                "        );",
                "      }",
                "    }, [applyValidationRules, mounted, touched, validateOn, value]);",
                "",
                "    // Run validation against fields with pendingValidations from onBlur",
                "    // and/or onChange.",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      const timer = setTimeout(() => {",
                "        if (pendingValidation && ['blur', 'change'].includes(validateOn)) {",
                "          applyValidationRules(",
                "            validationRules.filter(",
                "              ([n]) => touched[n] || pendingValidation.includes(n),",
                "            ),",
                "          );",
                "          setPendingValidation(undefined);",
                "        }",
                "        // Complete any potential click events before running onBlur validation.",
                "        // Otherwise, click events like reset, etc. may not be registered. For a",
                "        // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863",
                "        // Values empirically tested; 120 was selected because it is the largest",
                "        // Chrome: 100, Safari: 120, Firefox: 80",
                "      }, 120);",
                "      return () => clearTimeout(timer);",
                "    }, [applyValidationRules, pendingValidation, touched, validateOn]);",
                "",
                "    // Re-run validation rules for all fields with prior errors.",
                "    // if validate=blur this helps re-validate if there are errors",
                "    // as the user fixes them (basically act like validate=change for that)",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      if (",
                "        validationResultsRef.current?.errors &&",
                "        Object.keys(validationResultsRef.current.errors).length > 0",
                "      ) {",
                "        applyValidationRules(",
                "          validationRules.filter(",
                "            ([n]) => touched[n] && validationResultsRef.current.errors[n],",
                "          ),",
                "        );",
                "      }",
                "    }, [applyValidationRules, touched]);",
                "",
                "    // There are three basic patterns of handling form input value state:",
                "    //",
                "    // 1 - form controlled",
                "    //",
                "    // In this model, the caller sets `value` and `onChange` properties",
                "    // on the Form component to supply the values used by the input fields.",
                "    // In useFormContext(), componentValue would be undefined and formValue",
                "    // is be set to whatever the form state has. Whenever the form state",
                "    // changes, we update the contextValue so the input component will use",
                "    // that. When the input component changes, we will call update() to",
                "    // update the form state.",
                "    //",
                "    // 2 - input controlled",
                "    //",
                "    // In this model, the caller sets `value` and `onChange` properties",
                "    // on the input components, like TextInput, to supply the value for it.",
                "    // In useFormContext(), componentValue is this value and we ensure to",
                "    // update the form state, via update(), and set the contextValue from",
                "    // the componentValue. When the input component changes, we will",
                "    // call update() to update the form state.",
                "    //",
                "    // 3 - uncontrolled",
                "    //",
                "    // In this model, the caller doesn't set a `value` or `onChange` property",
                "    // at either the form or input component levels.",
                "    // In useFormContext(), componentValue is undefined and valueProp is",
                "    // undefined and nothing much happens here. That is, unless the",
                "    // calling component needs to know the state in order to work, such",
                "    // as CheckBox or Select. In this case, those components supply",
                "    // an initialValue, which will trigger updating the contextValue so",
                "    // they can have access to it.",
                "    //",
                "    const formContextValue = useMemo(() => {",
                "      const useFormInput = ({",
                "        name,",
                "        value: componentValue,",
                "        initialValue,",
                "        validate: validateArg,",
                "      }) => {",
                "        const [inputValue, setInputValue] = useState(initialValue);",
                "        const formValue = name ? getFieldValue(name, value) : undefined;",
                "        // for dynamic forms, we need to track when an input has been added to",
                "        // the form value. if the input is unmounted, we will delete its",
                "        // key/value from the form value.",
                "        const keyCreated = useRef(false);",
                "",
                "        // This effect is for pattern #2, where the controlled input",
                "        // component is driving the value via componentValue.",
                "        useEffect(() => {",
                "          if (",
                "            name && // we have somewhere to put this",
                "            componentValue !== undefined && // input driving",
                "            componentValue !== formValue // don't already have it",
                "          ) {",
                "            setValueState((prevValue) =>",
                "              setFieldValue(name, componentValue, prevValue),",
                "            );",
                "            // don't onChange on programmatic changes",
                "          }",
                "        }, [componentValue, formValue, name]);",
                "",
                "        // on unmount, if the form is uncontrolled, remove the key/value",
                "        // from the form value",
                "        useEffect(",
                "          () => () => {",
                "            if (keyCreated.current) {",
                "              keyCreated.current = false;",
                "              setValueState((prevValue) => {",
                "                const nextValue = { ...prevValue };",
                "                const isArrayField = stringToArray(name);",
                "                if (isArrayField) {",
                "                  const { arrayName } = isArrayField;",
                "                  delete nextValue[arrayName];",
                "                } else {",
                "                  delete nextValue[name];",
                "                }",
                "                return nextValue;",
                "              });",
                "            }",
                "          },",
                "          // eslint-disable-next-line react-hooks/exhaustive-deps",
                "          [], // only run onmount and unmount",
                "        );",
                "",
                "        // Create validation rules for fields",
                "        useEffect(() => {",
                "          if (validateArg) {",
                "            if (!validationRulesRef.current[name]) {",
                "              validationRulesRef.current[name] = {};",
                "            }",
                "            validationRulesRef.current[name].input = validateName(validateArg);",
                "            return () => delete validationRulesRef.current[name].input;",
                "          }",
                "          return undefined;",
                "        }, [validateArg, name]);",
                "",
                "        let useValue;",
                "        if (componentValue !== undefined)",
                "          // input component drives, pattern #2",
                "          useValue = componentValue;",
                "        else if (valueProp && name && formValue !== undefined)",
                "          // form drives, pattern #1",
                "          useValue = formValue;",
                "        else if (formValue === undefined && name)",
                "          // form has reset, so reset input value as well",
                "          useValue = initialValue;",
                "        else useValue = inputValue;",
                "",
                "        return [",
                "          useValue,",
                "          (nextComponentValue) => {",
                "            if (name) {",
                "              // we have somewhere to put this",
                "              const nextTouched = { ...touched };",
                "              nextTouched[name] = true;",
                "",
                "              if (!touched[name]) {",
                "                // don't update if not needed",
                "                setTouched(nextTouched);",
                "              }",
                "",
                "              // if nextValue doesn't have a key for name, this must be",
                "              // uncontrolled form. we will flag this field was added so",
                "              // we know to remove its value from the form if it is dynamically",
                "              // removed",
                "              if (!(name in value)) keyCreated.current = true;",
                "              const nextValue = setFieldValue(name, nextComponentValue, value);",
                "              setValueState(nextValue);",
                "              if (onChange) onChange(nextValue, { touched: nextTouched });",
                "            }",
                "            if (initialValue !== undefined) setInputValue(nextComponentValue);",
                "          },",
                "        ];",
                "      };",
                "",
                "      const useFormField = ({",
                "        error: errorArg,",
                "        info: infoArg,",
                "        name,",
                "        required,",
                "        disabled,",
                "        validate: validateArg,",
                "      }) => {",
                "        const error = disabled",
                "          ? undefined",
                "          : errorArg || validationResults.errors[name];",
                "        const info = infoArg || validationResults.infos[name];",
                "",
                "        // Create validation rules for field",
                "        useEffect(() => {",
                "          const index = requiredFields.current.indexOf(name);",
                "          if (required) {",
                "            if (index === -1) requiredFields.current.push(name);",
                "          } else if (index !== -1) requiredFields.current.splice(index, 1);",
                "",
                "          if (validateArg || required) {",
                "            if (!validationRulesRef.current[name]) {",
                "              validationRulesRef.current[name] = {};",
                "            }",
                "            validationRulesRef.current[name].field = validateName(",
                "              validateArg,",
                "              required,",
                "            );",
                "            return () => delete validationRulesRef.current[name].field;",
                "          }",
                "",
                "          return undefined;",
                "        }, [error, name, required, validateArg, disabled]);",
                "",
                "        return {",
                "          error,",
                "          info,",
                "          inForm: true,",
                "          onBlur:",
                "            validateOn === 'blur'",
                "              ? () =>",
                "                  setPendingValidation(",
                "                    pendingValidation ? [...pendingValidation, name] : [name],",
                "                  )",
                "              : undefined,",
                "          onChange:",
                "            validateOn === 'change'",
                "              ? () =>",
                "                  setPendingValidation(",
                "                    pendingValidation ? [...pendingValidation, name] : [name],",
                "                  )",
                "              : undefined,",
                "        };",
                "      };",
                "",
                "      return { useFormField, useFormInput };",
                "    }, [",
                "      onChange,",
                "      pendingValidation,",
                "      touched,",
                "      validateOn,",
                "      validationResults.errors,",
                "      validationResults.infos,",
                "      value,",
                "      valueProp,",
                "    ]);",
                "",
                "    return (",
                "      <form",
                "        ref={ref}",
                "        {...rest}",
                "        onReset={(event) => {",
                "          setPendingValidation(undefined);",
                "          if (!valueProp) {",
                "            setValueState(defaultValue);",
                "            if (onChange) onChange(defaultValue, { touched: defaultTouched });",
                "          }",
                "          setTouched(defaultTouched);",
                "          setValidationResults(defaultValidationResults);",
                "          if (onReset) {",
                "            event.persist(); // extract from React's synthetic event pool",
                "            const adjustedEvent = event;",
                "            adjustedEvent.value = defaultValue;",
                "            onReset(adjustedEvent);",
                "          }",
                "        }}",
                "        onSubmit={(event) => {",
                "          // Don't submit the form via browser form action. We don't want it",
                "          // if the validation fails. And, we assume a javascript action handler",
                "          // otherwise.",
                "          event.preventDefault();",
                "          setPendingValidation(undefined);",
                "          const [nextErrors, nextInfos] = validateForm(",
                "            Object.entries(validationRulesRef.current),",
                "            value,",
                "            format,",
                "            messages,",
                "            true,",
                "          );",
                "",
                "          setValidationResults(() => {",
                "            const nextValidationResults = {",
                "              errors: nextErrors,",
                "              infos: nextInfos,",
                "              // Show form's validity when clicking on Submit",
                "              valid: buildValid(nextErrors),",
                "            };",
                "            if (onValidate) onValidate(nextValidationResults);",
                "            validationResultsRef.current = nextValidationResults;",
                "            return nextValidationResults;",
                "          });",
                "",
                "          if (Object.keys(nextErrors).length === 0 && onSubmit) {",
                "            event.persist(); // extract from React's synthetic event pool",
                "            const adjustedEvent = event;",
                "            adjustedEvent.value = value;",
                "            adjustedEvent.touched = touched;",
                "            onSubmit(adjustedEvent);",
                "          }",
                "        }}",
                "      >",
                "        <FormContext.Provider value={formContextValue}>",
                "          {children}",
                "        </FormContext.Provider>",
                "      </form>",
                "    );",
                "  },",
                ");",
                "",
                "Form.displayName = 'Form';",
                "Form.propTypes = FormPropTypes;",
                "",
                "export { Form };"
            ]
        },
        "3": {
            "function_name": "validate (not found) 64-564",
            "file_path": "src/js/components/Form/Form.js",
            "function_details": [
                {
                    "name": "validate",
                    "start_line": 64,
                    "end_line": 564
                }
            ],
            "function_code": [
                "const validate = (rule, fieldValue, formValue, format, messages) => {",
                "  let result;",
                "  if (typeof rule === 'function') {",
                "    result = rule(fieldValue, formValue);",
                "  } else if (rule.regexp) {",
                "    if (!rule.regexp.test(fieldValue)) {",
                "      result = rule.message || format({ id: 'form.invalid', messages });",
                "      if (rule.status) {",
                "        result = { message: result, status: rule.status };",
                "      }",
                "    }",
                "  }",
                "  return result;",
                "};",
                "",
                "// Validates particular key in formValue",
                "const validateName =",
                "  (validationRules, required) => (name, formValue, format, messages) => {",
                "    const fieldValue = getFieldValue(name, formValue);",
                "    let validationResult;",
                "",
                "    if (",
                "      required &&",
                "      // false is for CheckBox",
                "      (fieldValue === undefined ||",
                "        fieldValue === '' ||",
                "        fieldValue === false ||",
                "        (Array.isArray(fieldValue) && !fieldValue.length))",
                "    ) {",
                "      validationResult = format({ id: 'form.required', messages });",
                "    } else if (validationRules) {",
                "      if (Array.isArray(validationRules)) {",
                "        validationRules.some((rule) => {",
                "          validationResult = validate(",
                "            rule,",
                "            fieldValue,",
                "            formValue,",
                "            format,",
                "            messages,",
                "          );",
                "          return !!validationResult;",
                "        });",
                "      } else {",
                "        validationResult = validate(",
                "          validationRules,",
                "          fieldValue,",
                "          formValue,",
                "          format,",
                "          messages,",
                "        );",
                "      }",
                "    }",
                "    return validationResult;",
                "  };",
                "",
                "// Validates all keys in formValue",
                "const validateForm = (",
                "  validationRules,",
                "  formValue,",
                "  format,",
                "  messages,",
                "  omitValid,",
                ") => {",
                "  const nextErrors = {};",
                "  const nextInfos = {};",
                "  validationRules.forEach(([name, { field, input }]) => {",
                "    if (!omitValid) {",
                "      nextErrors[name] = undefined;",
                "      nextInfos[name] = undefined;",
                "    }",
                "",
                "    let result;",
                "    if (input) {",
                "      // input() a validation function supplied through useFormInput()",
                "      result = input(name, formValue, format, messages);",
                "    }",
                "    if (field && !result) {",
                "      // field() a validation function supplied through useFormField()",
                "      result = field(name, formValue, format, messages);",
                "    }",
                "    // typeof error === 'object' is implied for both cases of error with",
                "    // a status message and for an error object that is a react node",
                "    if (typeof result === 'object') {",
                "      if (result.status === 'info') {",
                "        nextInfos[name] = result.message;",
                "      } else {",
                "        nextErrors[name] = result.message || result; // could be a node",
                "      }",
                "    } else if (typeof result === 'string') {",
                "      nextErrors[name] = result;",
                "    }",
                "  });",
                "  return [nextErrors, nextInfos];",
                "};",
                "",
                "const Form = forwardRef(",
                "  (",
                "    {",
                "      children,",
                "      errors: errorsProp = defaultValidationResults.errors,",
                "      infos: infosProp = defaultValidationResults.infos,",
                "      messages,",
                "      onChange,",
                "      onReset,",
                "      onSubmit,",
                "      onValidate,",
                "      validate: validateOn = 'submit',",
                "      value: valueProp,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const { format } = useContext(MessageContext);",
                "    const [valueState, setValueState] = useState(valueProp || defaultValue);",
                "    const value = useMemo(",
                "      () => valueProp || valueState,",
                "      [valueProp, valueState],",
                "    );",
                "    const [touched, setTouched] = useState(defaultTouched);",
                "    const [validationResults, setValidationResults] = useState({",
                "      errors: errorsProp,",
                "      infos: infosProp,",
                "    });",
                "    // maintain a copy of validationResults in a ref for useEffects",
                "    // which can't depend on validationResults directly without",
                "    // causing infinite renders.",
                "    const validationResultsRef = useRef({});",
                "    // Simulated onMount state. Consider Form to be mounted once it has",
                "    // accounted for values originating from controlled inputs (available",
                "    // at second rendering).",
                "    const [mounted, setMounted] = useState('unmounted');",
                "    useEffect(() => {",
                "      if (!mounted) setMounted('mounting');",
                "      else if (mounted === 'mounting') setMounted('mounted');",
                "    }, [mounted]);",
                "    // `pendingValidation` is the name of the FormField awaiting validation.",
                "    const [pendingValidation, setPendingValidation] = useState(undefined);",
                "",
                "    const validationRulesRef = useRef({});",
                "    const requiredFields = useRef([]);",
                "",
                "    const buildValid = useCallback(",
                "      (nextErrors) => {",
                "        let valid = false;",
                "        valid = requiredFields.current",
                "          .filter((n) => Object.keys(validationRulesRef.current).includes(n))",
                "          .every(",
                "            (field) =>",
                "              value[field] && (value[field] !== '' || value[field] !== false),",
                "          );",
                "",
                "        if (Object.keys(nextErrors).length > 0) valid = false;",
                "        return valid;",
                "      },",
                "      [value],",
                "    );",
                "",
                "    // Only keep validation results for current form fields. In the case of a",
                "    // dynamic form, a field possessing an error may have been removed from the",
                "    // form; need to clean up any previous related validation results.",
                "    const filterRemovedFields = (prevValidations) => {",
                "      const nextValidations = prevValidations;",
                "      return Object.keys(nextValidations)",
                "        .filter(",
                "          (n) =>",
                "            !validationRulesRef.current[n] || nextValidations[n] === undefined,",
                "        )",
                "        .forEach((n) => delete nextValidations[n]);",
                "    };",
                "",
                "    const applyValidationRules = useCallback(",
                "      (validationRules) => {",
                "        const [validatedErrors, validatedInfos] = validateForm(",
                "          validationRules,",
                "          value,",
                "          format,",
                "          messages,",
                "        );",
                "",
                "        setValidationResults((prevValidationResults) => {",
                "          // Keep any previous errors and infos for untouched keys,",
                "          // these may have come from a Submit.",
                "          const nextErrors = {",
                "            ...prevValidationResults.errors,",
                "            ...validatedErrors,",
                "          };",
                "          const nextInfos = {",
                "            ...prevValidationResults.infos,",
                "            ...validatedInfos,",
                "          };",
                "          // Remove previous errors and infos for keys no longer in the",
                "          // form, these may have been fields removed from a dynamic form.",
                "          filterRemovedFields(nextErrors);",
                "          filterRemovedFields(nextInfos);",
                "          const nextValidationResults = {",
                "            errors: nextErrors,",
                "            infos: nextInfos,",
                "          };",
                "          if (onValidate)",
                "            onValidate({",
                "              ...nextValidationResults,",
                "              valid: buildValid(nextErrors),",
                "            });",
                "          validationResultsRef.current = nextValidationResults;",
                "          return nextValidationResults;",
                "        });",
                "      },",
                "      [buildValid, format, messages, onValidate, value],",
                "    );",
                "",
                "    // Validate all fields holding values onMount if set to",
                "    // validate when blur or change.",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      // Use simulated onMount state to account for values provided by",
                "      // controlled inputs.",
                "      if (",
                "        mounted !== 'mounted' &&",
                "        ['blur', 'change'].includes(validateOn) &&",
                "        Object.keys(value).length > 0 &&",
                "        Object.keys(touched).length === 0",
                "      ) {",
                "        applyValidationRules(",
                "          validationRules",
                "            .filter(([n]) => value[n])",
                "            // Exlude empty arrays which may be initial values in",
                "            // an input such as DateInput.",
                "            .filter(",
                "              ([n]) => !(Array.isArray(value[n]) && value[n].length === 0),",
                "            ),",
                "        );",
                "      }",
                "    }, [applyValidationRules, mounted, touched, validateOn, value]);",
                "",
                "    // Run validation against fields with pendingValidations from onBlur",
                "    // and/or onChange.",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      const timer = setTimeout(() => {",
                "        if (pendingValidation && ['blur', 'change'].includes(validateOn)) {",
                "          applyValidationRules(",
                "            validationRules.filter(",
                "              ([n]) => touched[n] || pendingValidation.includes(n),",
                "            ),",
                "          );",
                "          setPendingValidation(undefined);",
                "        }",
                "        // Complete any potential click events before running onBlur validation.",
                "        // Otherwise, click events like reset, etc. may not be registered. For a",
                "        // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863",
                "        // Values empirically tested; 120 was selected because it is the largest",
                "        // Chrome: 100, Safari: 120, Firefox: 80",
                "      }, 120);",
                "      return () => clearTimeout(timer);",
                "    }, [applyValidationRules, pendingValidation, touched, validateOn]);",
                "",
                "    // Re-run validation rules for all fields with prior errors.",
                "    // if validate=blur this helps re-validate if there are errors",
                "    // as the user fixes them (basically act like validate=change for that)",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      if (",
                "        validationResultsRef.current?.errors &&",
                "        Object.keys(validationResultsRef.current.errors).length > 0",
                "      ) {",
                "        applyValidationRules(",
                "          validationRules.filter(",
                "            ([n]) => touched[n] && validationResultsRef.current.errors[n],",
                "          ),",
                "        );",
                "      }",
                "    }, [applyValidationRules, touched]);",
                "",
                "    // There are three basic patterns of handling form input value state:",
                "    //",
                "    // 1 - form controlled",
                "    //",
                "    // In this model, the caller sets `value` and `onChange` properties",
                "    // on the Form component to supply the values used by the input fields.",
                "    // In useFormContext(), componentValue would be undefined and formValue",
                "    // is be set to whatever the form state has. Whenever the form state",
                "    // changes, we update the contextValue so the input component will use",
                "    // that. When the input component changes, we will call update() to",
                "    // update the form state.",
                "    //",
                "    // 2 - input controlled",
                "    //",
                "    // In this model, the caller sets `value` and `onChange` properties",
                "    // on the input components, like TextInput, to supply the value for it.",
                "    // In useFormContext(), componentValue is this value and we ensure to",
                "    // update the form state, via update(), and set the contextValue from",
                "    // the componentValue. When the input component changes, we will",
                "    // call update() to update the form state.",
                "    //",
                "    // 3 - uncontrolled",
                "    //",
                "    // In this model, the caller doesn't set a `value` or `onChange` property",
                "    // at either the form or input component levels.",
                "    // In useFormContext(), componentValue is undefined and valueProp is",
                "    // undefined and nothing much happens here. That is, unless the",
                "    // calling component needs to know the state in order to work, such",
                "    // as CheckBox or Select. In this case, those components supply",
                "    // an initialValue, which will trigger updating the contextValue so",
                "    // they can have access to it.",
                "    //",
                "    const formContextValue = useMemo(() => {",
                "      const useFormInput = ({",
                "        name,",
                "        value: componentValue,",
                "        initialValue,",
                "        validate: validateArg,",
                "      }) => {",
                "        const [inputValue, setInputValue] = useState(initialValue);",
                "        const formValue = name ? getFieldValue(name, value) : undefined;",
                "        // for dynamic forms, we need to track when an input has been added to",
                "        // the form value. if the input is unmounted, we will delete its",
                "        // key/value from the form value.",
                "        const keyCreated = useRef(false);",
                "",
                "        // This effect is for pattern #2, where the controlled input",
                "        // component is driving the value via componentValue.",
                "        useEffect(() => {",
                "          if (",
                "            name && // we have somewhere to put this",
                "            componentValue !== undefined && // input driving",
                "            componentValue !== formValue // don't already have it",
                "          ) {",
                "            setValueState((prevValue) =>",
                "              setFieldValue(name, componentValue, prevValue),",
                "            );",
                "            // don't onChange on programmatic changes",
                "          }",
                "        }, [componentValue, formValue, name]);",
                "",
                "        // on unmount, if the form is uncontrolled, remove the key/value",
                "        // from the form value",
                "        useEffect(",
                "          () => () => {",
                "            if (keyCreated.current) {",
                "              keyCreated.current = false;",
                "              setValueState((prevValue) => {",
                "                const nextValue = { ...prevValue };",
                "                const isArrayField = stringToArray(name);",
                "                if (isArrayField) {",
                "                  const { arrayName } = isArrayField;",
                "                  delete nextValue[arrayName];",
                "                } else {",
                "                  delete nextValue[name];",
                "                }",
                "                return nextValue;",
                "              });",
                "            }",
                "          },",
                "          // eslint-disable-next-line react-hooks/exhaustive-deps",
                "          [], // only run onmount and unmount",
                "        );",
                "",
                "        // Create validation rules for fields",
                "        useEffect(() => {",
                "          if (validateArg) {",
                "            if (!validationRulesRef.current[name]) {",
                "              validationRulesRef.current[name] = {};",
                "            }",
                "            validationRulesRef.current[name].input = validateName(validateArg);",
                "            return () => delete validationRulesRef.current[name].input;",
                "          }",
                "          return undefined;",
                "        }, [validateArg, name]);",
                "",
                "        let useValue;",
                "        if (componentValue !== undefined)",
                "          // input component drives, pattern #2",
                "          useValue = componentValue;",
                "        else if (valueProp && name && formValue !== undefined)",
                "          // form drives, pattern #1",
                "          useValue = formValue;",
                "        else if (formValue === undefined && name)",
                "          // form has reset, so reset input value as well",
                "          useValue = initialValue;",
                "        else useValue = inputValue;",
                "",
                "        return [",
                "          useValue,",
                "          (nextComponentValue) => {",
                "            if (name) {",
                "              // we have somewhere to put this",
                "              const nextTouched = { ...touched };",
                "              nextTouched[name] = true;",
                "",
                "              if (!touched[name]) {",
                "                // don't update if not needed",
                "                setTouched(nextTouched);",
                "              }",
                "",
                "              // if nextValue doesn't have a key for name, this must be",
                "              // uncontrolled form. we will flag this field was added so",
                "              // we know to remove its value from the form if it is dynamically",
                "              // removed",
                "              if (!(name in value)) keyCreated.current = true;",
                "              const nextValue = setFieldValue(name, nextComponentValue, value);",
                "              setValueState(nextValue);",
                "              if (onChange) onChange(nextValue, { touched: nextTouched });",
                "            }",
                "            if (initialValue !== undefined) setInputValue(nextComponentValue);",
                "          },",
                "        ];",
                "      };",
                "",
                "      const useFormField = ({",
                "        error: errorArg,",
                "        info: infoArg,",
                "        name,",
                "        required,",
                "        disabled,",
                "        validate: validateArg,",
                "      }) => {",
                "        const error = disabled",
                "          ? undefined",
                "          : errorArg || validationResults.errors[name];",
                "        const info = infoArg || validationResults.infos[name];",
                "",
                "        // Create validation rules for field",
                "        useEffect(() => {",
                "          const index = requiredFields.current.indexOf(name);",
                "          if (required) {",
                "            if (index === -1) requiredFields.current.push(name);",
                "          } else if (index !== -1) requiredFields.current.splice(index, 1);",
                "",
                "          if (validateArg || required) {",
                "            if (!validationRulesRef.current[name]) {",
                "              validationRulesRef.current[name] = {};",
                "            }",
                "            validationRulesRef.current[name].field = validateName(",
                "              validateArg,",
                "              required,",
                "            );",
                "            return () => delete validationRulesRef.current[name].field;",
                "          }",
                "",
                "          return undefined;",
                "        }, [error, name, required, validateArg, disabled]);",
                "",
                "        return {",
                "          error,",
                "          info,",
                "          inForm: true,",
                "          onBlur:",
                "            validateOn === 'blur'",
                "              ? () =>",
                "                  setPendingValidation(",
                "                    pendingValidation ? [...pendingValidation, name] : [name],",
                "                  )",
                "              : undefined,",
                "          onChange:",
                "            validateOn === 'change'",
                "              ? () =>",
                "                  setPendingValidation(",
                "                    pendingValidation ? [...pendingValidation, name] : [name],",
                "                  )",
                "              : undefined,",
                "        };",
                "      };",
                "",
                "      return { useFormField, useFormInput };",
                "    }, [",
                "      onChange,",
                "      pendingValidation,",
                "      touched,",
                "      validateOn,",
                "      validationResults.errors,",
                "      validationResults.infos,",
                "      value,",
                "      valueProp,",
                "    ]);",
                "",
                "    return (",
                "      <form",
                "        ref={ref}",
                "        {...rest}",
                "        onReset={(event) => {",
                "          setPendingValidation(undefined);",
                "          if (!valueProp) {",
                "            setValueState(defaultValue);",
                "            if (onChange) onChange(defaultValue, { touched: defaultTouched });",
                "          }",
                "          setTouched(defaultTouched);",
                "          setValidationResults(defaultValidationResults);",
                "          if (onReset) {",
                "            event.persist(); // extract from React's synthetic event pool",
                "            const adjustedEvent = event;",
                "            adjustedEvent.value = defaultValue;",
                "            onReset(adjustedEvent);",
                "          }",
                "        }}",
                "        onSubmit={(event) => {",
                "          // Don't submit the form via browser form action. We don't want it",
                "          // if the validation fails. And, we assume a javascript action handler",
                "          // otherwise.",
                "          event.preventDefault();",
                "          setPendingValidation(undefined);",
                "          const [nextErrors, nextInfos] = validateForm("
            ]
        },
        "4": {
            "function_name": "useFormInput (not found) 137-604",
            "file_path": "src/js/components/Form/Form.js",
            "function_details": [
                {
                    "name": "useFormInput",
                    "start_line": 137,
                    "end_line": 604
                }
            ],
            "function_code": [
                "      // input() a validation function supplied through useFormInput()",
                "      result = input(name, formValue, format, messages);",
                "    }",
                "    if (field && !result) {",
                "      // field() a validation function supplied through useFormField()",
                "      result = field(name, formValue, format, messages);",
                "    }",
                "    // typeof error === 'object' is implied for both cases of error with",
                "    // a status message and for an error object that is a react node",
                "    if (typeof result === 'object') {",
                "      if (result.status === 'info') {",
                "        nextInfos[name] = result.message;",
                "      } else {",
                "        nextErrors[name] = result.message || result; // could be a node",
                "      }",
                "    } else if (typeof result === 'string') {",
                "      nextErrors[name] = result;",
                "    }",
                "  });",
                "  return [nextErrors, nextInfos];",
                "};",
                "",
                "const Form = forwardRef(",
                "  (",
                "    {",
                "      children,",
                "      errors: errorsProp = defaultValidationResults.errors,",
                "      infos: infosProp = defaultValidationResults.infos,",
                "      messages,",
                "      onChange,",
                "      onReset,",
                "      onSubmit,",
                "      onValidate,",
                "      validate: validateOn = 'submit',",
                "      value: valueProp,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const { format } = useContext(MessageContext);",
                "    const [valueState, setValueState] = useState(valueProp || defaultValue);",
                "    const value = useMemo(",
                "      () => valueProp || valueState,",
                "      [valueProp, valueState],",
                "    );",
                "    const [touched, setTouched] = useState(defaultTouched);",
                "    const [validationResults, setValidationResults] = useState({",
                "      errors: errorsProp,",
                "      infos: infosProp,",
                "    });",
                "    // maintain a copy of validationResults in a ref for useEffects",
                "    // which can't depend on validationResults directly without",
                "    // causing infinite renders.",
                "    const validationResultsRef = useRef({});",
                "    // Simulated onMount state. Consider Form to be mounted once it has",
                "    // accounted for values originating from controlled inputs (available",
                "    // at second rendering).",
                "    const [mounted, setMounted] = useState('unmounted');",
                "    useEffect(() => {",
                "      if (!mounted) setMounted('mounting');",
                "      else if (mounted === 'mounting') setMounted('mounted');",
                "    }, [mounted]);",
                "    // `pendingValidation` is the name of the FormField awaiting validation.",
                "    const [pendingValidation, setPendingValidation] = useState(undefined);",
                "",
                "    const validationRulesRef = useRef({});",
                "    const requiredFields = useRef([]);",
                "",
                "    const buildValid = useCallback(",
                "      (nextErrors) => {",
                "        let valid = false;",
                "        valid = requiredFields.current",
                "          .filter((n) => Object.keys(validationRulesRef.current).includes(n))",
                "          .every(",
                "            (field) =>",
                "              value[field] && (value[field] !== '' || value[field] !== false),",
                "          );",
                "",
                "        if (Object.keys(nextErrors).length > 0) valid = false;",
                "        return valid;",
                "      },",
                "      [value],",
                "    );",
                "",
                "    // Only keep validation results for current form fields. In the case of a",
                "    // dynamic form, a field possessing an error may have been removed from the",
                "    // form; need to clean up any previous related validation results.",
                "    const filterRemovedFields = (prevValidations) => {",
                "      const nextValidations = prevValidations;",
                "      return Object.keys(nextValidations)",
                "        .filter(",
                "          (n) =>",
                "            !validationRulesRef.current[n] || nextValidations[n] === undefined,",
                "        )",
                "        .forEach((n) => delete nextValidations[n]);",
                "    };",
                "",
                "    const applyValidationRules = useCallback(",
                "      (validationRules) => {",
                "        const [validatedErrors, validatedInfos] = validateForm(",
                "          validationRules,",
                "          value,",
                "          format,",
                "          messages,",
                "        );",
                "",
                "        setValidationResults((prevValidationResults) => {",
                "          // Keep any previous errors and infos for untouched keys,",
                "          // these may have come from a Submit.",
                "          const nextErrors = {",
                "            ...prevValidationResults.errors,",
                "            ...validatedErrors,",
                "          };",
                "          const nextInfos = {",
                "            ...prevValidationResults.infos,",
                "            ...validatedInfos,",
                "          };",
                "          // Remove previous errors and infos for keys no longer in the",
                "          // form, these may have been fields removed from a dynamic form.",
                "          filterRemovedFields(nextErrors);",
                "          filterRemovedFields(nextInfos);",
                "          const nextValidationResults = {",
                "            errors: nextErrors,",
                "            infos: nextInfos,",
                "          };",
                "          if (onValidate)",
                "            onValidate({",
                "              ...nextValidationResults,",
                "              valid: buildValid(nextErrors),",
                "            });",
                "          validationResultsRef.current = nextValidationResults;",
                "          return nextValidationResults;",
                "        });",
                "      },",
                "      [buildValid, format, messages, onValidate, value],",
                "    );",
                "",
                "    // Validate all fields holding values onMount if set to",
                "    // validate when blur or change.",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      // Use simulated onMount state to account for values provided by",
                "      // controlled inputs.",
                "      if (",
                "        mounted !== 'mounted' &&",
                "        ['blur', 'change'].includes(validateOn) &&",
                "        Object.keys(value).length > 0 &&",
                "        Object.keys(touched).length === 0",
                "      ) {",
                "        applyValidationRules(",
                "          validationRules",
                "            .filter(([n]) => value[n])",
                "            // Exlude empty arrays which may be initial values in",
                "            // an input such as DateInput.",
                "            .filter(",
                "              ([n]) => !(Array.isArray(value[n]) && value[n].length === 0),",
                "            ),",
                "        );",
                "      }",
                "    }, [applyValidationRules, mounted, touched, validateOn, value]);",
                "",
                "    // Run validation against fields with pendingValidations from onBlur",
                "    // and/or onChange.",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      const timer = setTimeout(() => {",
                "        if (pendingValidation && ['blur', 'change'].includes(validateOn)) {",
                "          applyValidationRules(",
                "            validationRules.filter(",
                "              ([n]) => touched[n] || pendingValidation.includes(n),",
                "            ),",
                "          );",
                "          setPendingValidation(undefined);",
                "        }",
                "        // Complete any potential click events before running onBlur validation.",
                "        // Otherwise, click events like reset, etc. may not be registered. For a",
                "        // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863",
                "        // Values empirically tested; 120 was selected because it is the largest",
                "        // Chrome: 100, Safari: 120, Firefox: 80",
                "      }, 120);",
                "      return () => clearTimeout(timer);",
                "    }, [applyValidationRules, pendingValidation, touched, validateOn]);",
                "",
                "    // Re-run validation rules for all fields with prior errors.",
                "    // if validate=blur this helps re-validate if there are errors",
                "    // as the user fixes them (basically act like validate=change for that)",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      if (",
                "        validationResultsRef.current?.errors &&",
                "        Object.keys(validationResultsRef.current.errors).length > 0",
                "      ) {",
                "        applyValidationRules(",
                "          validationRules.filter(",
                "            ([n]) => touched[n] && validationResultsRef.current.errors[n],",
                "          ),",
                "        );",
                "      }",
                "    }, [applyValidationRules, touched]);",
                "",
                "    // There are three basic patterns of handling form input value state:",
                "    //",
                "    // 1 - form controlled",
                "    //",
                "    // In this model, the caller sets `value` and `onChange` properties",
                "    // on the Form component to supply the values used by the input fields.",
                "    // In useFormContext(), componentValue would be undefined and formValue",
                "    // is be set to whatever the form state has. Whenever the form state",
                "    // changes, we update the contextValue so the input component will use",
                "    // that. When the input component changes, we will call update() to",
                "    // update the form state.",
                "    //",
                "    // 2 - input controlled",
                "    //",
                "    // In this model, the caller sets `value` and `onChange` properties",
                "    // on the input components, like TextInput, to supply the value for it.",
                "    // In useFormContext(), componentValue is this value and we ensure to",
                "    // update the form state, via update(), and set the contextValue from",
                "    // the componentValue. When the input component changes, we will",
                "    // call update() to update the form state.",
                "    //",
                "    // 3 - uncontrolled",
                "    //",
                "    // In this model, the caller doesn't set a `value` or `onChange` property",
                "    // at either the form or input component levels.",
                "    // In useFormContext(), componentValue is undefined and valueProp is",
                "    // undefined and nothing much happens here. That is, unless the",
                "    // calling component needs to know the state in order to work, such",
                "    // as CheckBox or Select. In this case, those components supply",
                "    // an initialValue, which will trigger updating the contextValue so",
                "    // they can have access to it.",
                "    //",
                "    const formContextValue = useMemo(() => {",
                "      const useFormInput = ({",
                "        name,",
                "        value: componentValue,",
                "        initialValue,",
                "        validate: validateArg,",
                "      }) => {",
                "        const [inputValue, setInputValue] = useState(initialValue);",
                "        const formValue = name ? getFieldValue(name, value) : undefined;",
                "        // for dynamic forms, we need to track when an input has been added to",
                "        // the form value. if the input is unmounted, we will delete its",
                "        // key/value from the form value.",
                "        const keyCreated = useRef(false);",
                "",
                "        // This effect is for pattern #2, where the controlled input",
                "        // component is driving the value via componentValue.",
                "        useEffect(() => {",
                "          if (",
                "            name && // we have somewhere to put this",
                "            componentValue !== undefined && // input driving",
                "            componentValue !== formValue // don't already have it",
                "          ) {",
                "            setValueState((prevValue) =>",
                "              setFieldValue(name, componentValue, prevValue),",
                "            );",
                "            // don't onChange on programmatic changes",
                "          }",
                "        }, [componentValue, formValue, name]);",
                "",
                "        // on unmount, if the form is uncontrolled, remove the key/value",
                "        // from the form value",
                "        useEffect(",
                "          () => () => {",
                "            if (keyCreated.current) {",
                "              keyCreated.current = false;",
                "              setValueState((prevValue) => {",
                "                const nextValue = { ...prevValue };",
                "                const isArrayField = stringToArray(name);",
                "                if (isArrayField) {",
                "                  const { arrayName } = isArrayField;",
                "                  delete nextValue[arrayName];",
                "                } else {",
                "                  delete nextValue[name];",
                "                }",
                "                return nextValue;",
                "              });",
                "            }",
                "          },",
                "          // eslint-disable-next-line react-hooks/exhaustive-deps",
                "          [], // only run onmount and unmount",
                "        );",
                "",
                "        // Create validation rules for fields",
                "        useEffect(() => {",
                "          if (validateArg) {",
                "            if (!validationRulesRef.current[name]) {",
                "              validationRulesRef.current[name] = {};",
                "            }",
                "            validationRulesRef.current[name].input = validateName(validateArg);",
                "            return () => delete validationRulesRef.current[name].input;",
                "          }",
                "          return undefined;",
                "        }, [validateArg, name]);",
                "",
                "        let useValue;",
                "        if (componentValue !== undefined)",
                "          // input component drives, pattern #2",
                "          useValue = componentValue;",
                "        else if (valueProp && name && formValue !== undefined)",
                "          // form drives, pattern #1",
                "          useValue = formValue;",
                "        else if (formValue === undefined && name)",
                "          // form has reset, so reset input value as well",
                "          useValue = initialValue;",
                "        else useValue = inputValue;",
                "",
                "        return [",
                "          useValue,",
                "          (nextComponentValue) => {",
                "            if (name) {",
                "              // we have somewhere to put this",
                "              const nextTouched = { ...touched };",
                "              nextTouched[name] = true;",
                "",
                "              if (!touched[name]) {",
                "                // don't update if not needed",
                "                setTouched(nextTouched);",
                "              }",
                "",
                "              // if nextValue doesn't have a key for name, this must be",
                "              // uncontrolled form. we will flag this field was added so",
                "              // we know to remove its value from the form if it is dynamically",
                "              // removed",
                "              if (!(name in value)) keyCreated.current = true;",
                "              const nextValue = setFieldValue(name, nextComponentValue, value);",
                "              setValueState(nextValue);",
                "              if (onChange) onChange(nextValue, { touched: nextTouched });",
                "            }",
                "            if (initialValue !== undefined) setInputValue(nextComponentValue);",
                "          },",
                "        ];",
                "      };",
                "",
                "      const useFormField = ({",
                "        error: errorArg,",
                "        info: infoArg,",
                "        name,",
                "        required,",
                "        disabled,",
                "        validate: validateArg,",
                "      }) => {",
                "        const error = disabled",
                "          ? undefined",
                "          : errorArg || validationResults.errors[name];",
                "        const info = infoArg || validationResults.infos[name];",
                "",
                "        // Create validation rules for field",
                "        useEffect(() => {",
                "          const index = requiredFields.current.indexOf(name);",
                "          if (required) {",
                "            if (index === -1) requiredFields.current.push(name);",
                "          } else if (index !== -1) requiredFields.current.splice(index, 1);",
                "",
                "          if (validateArg || required) {",
                "            if (!validationRulesRef.current[name]) {",
                "              validationRulesRef.current[name] = {};",
                "            }",
                "            validationRulesRef.current[name].field = validateName(",
                "              validateArg,",
                "              required,",
                "            );",
                "            return () => delete validationRulesRef.current[name].field;",
                "          }",
                "",
                "          return undefined;",
                "        }, [error, name, required, validateArg, disabled]);",
                "",
                "        return {",
                "          error,",
                "          info,",
                "          inForm: true,",
                "          onBlur:",
                "            validateOn === 'blur'",
                "              ? () =>",
                "                  setPendingValidation(",
                "                    pendingValidation ? [...pendingValidation, name] : [name],",
                "                  )",
                "              : undefined,",
                "          onChange:",
                "            validateOn === 'change'",
                "              ? () =>",
                "                  setPendingValidation(",
                "                    pendingValidation ? [...pendingValidation, name] : [name],",
                "                  )",
                "              : undefined,",
                "        };",
                "      };",
                "",
                "      return { useFormField, useFormInput };",
                "    }, [",
                "      onChange,",
                "      pendingValidation,",
                "      touched,",
                "      validateOn,",
                "      validationResults.errors,",
                "      validationResults.infos,",
                "      value,",
                "      valueProp,",
                "    ]);",
                "",
                "    return (",
                "      <form",
                "        ref={ref}",
                "        {...rest}",
                "        onReset={(event) => {",
                "          setPendingValidation(undefined);",
                "          if (!valueProp) {",
                "            setValueState(defaultValue);",
                "            if (onChange) onChange(defaultValue, { touched: defaultTouched });",
                "          }",
                "          setTouched(defaultTouched);",
                "          setValidationResults(defaultValidationResults);",
                "          if (onReset) {",
                "            event.persist(); // extract from React's synthetic event pool",
                "            const adjustedEvent = event;",
                "            adjustedEvent.value = defaultValue;",
                "            onReset(adjustedEvent);",
                "          }",
                "        }}",
                "        onSubmit={(event) => {",
                "          // Don't submit the form via browser form action. We don't want it",
                "          // if the validation fails. And, we assume a javascript action handler",
                "          // otherwise.",
                "          event.preventDefault();",
                "          setPendingValidation(undefined);",
                "          const [nextErrors, nextInfos] = validateForm(",
                "            Object.entries(validationRulesRef.current),",
                "            value,",
                "            format,",
                "            messages,",
                "            true,",
                "          );",
                "",
                "          setValidationResults(() => {",
                "            const nextValidationResults = {",
                "              errors: nextErrors,",
                "              infos: nextInfos,",
                "              // Show form's validity when clicking on Submit",
                "              valid: buildValid(nextErrors),",
                "            };",
                "            if (onValidate) onValidate(nextValidationResults);",
                "            validationResultsRef.current = nextValidationResults;",
                "            return nextValidationResults;",
                "          });",
                "",
                "          if (Object.keys(nextErrors).length === 0 && onSubmit) {",
                "            event.persist(); // extract from React's synthetic event pool",
                "            const adjustedEvent = event;",
                "            adjustedEvent.value = value;",
                "            adjustedEvent.touched = touched;",
                "            onSubmit(adjustedEvent);",
                "          }",
                "        }}",
                "      >",
                "        <FormContext.Provider value={formContextValue}>",
                "          {children}",
                "        </FormContext.Provider>",
                "      </form>",
                "    );",
                "  },",
                ");",
                "",
                "Form.displayName = 'Form';",
                "Form.propTypes = FormPropTypes;",
                "",
                "export { Form };"
            ]
        },
        "5": {
            "function_name": "useFormField (not found) 141-604",
            "file_path": "src/js/components/Form/Form.js",
            "function_details": [
                {
                    "name": "useFormField",
                    "start_line": 141,
                    "end_line": 604
                }
            ],
            "function_code": [
                "      // field() a validation function supplied through useFormField()",
                "      result = field(name, formValue, format, messages);",
                "    }",
                "    // typeof error === 'object' is implied for both cases of error with",
                "    // a status message and for an error object that is a react node",
                "    if (typeof result === 'object') {",
                "      if (result.status === 'info') {",
                "        nextInfos[name] = result.message;",
                "      } else {",
                "        nextErrors[name] = result.message || result; // could be a node",
                "      }",
                "    } else if (typeof result === 'string') {",
                "      nextErrors[name] = result;",
                "    }",
                "  });",
                "  return [nextErrors, nextInfos];",
                "};",
                "",
                "const Form = forwardRef(",
                "  (",
                "    {",
                "      children,",
                "      errors: errorsProp = defaultValidationResults.errors,",
                "      infos: infosProp = defaultValidationResults.infos,",
                "      messages,",
                "      onChange,",
                "      onReset,",
                "      onSubmit,",
                "      onValidate,",
                "      validate: validateOn = 'submit',",
                "      value: valueProp,",
                "      ...rest",
                "    },",
                "    ref,",
                "  ) => {",
                "    const { format } = useContext(MessageContext);",
                "    const [valueState, setValueState] = useState(valueProp || defaultValue);",
                "    const value = useMemo(",
                "      () => valueProp || valueState,",
                "      [valueProp, valueState],",
                "    );",
                "    const [touched, setTouched] = useState(defaultTouched);",
                "    const [validationResults, setValidationResults] = useState({",
                "      errors: errorsProp,",
                "      infos: infosProp,",
                "    });",
                "    // maintain a copy of validationResults in a ref for useEffects",
                "    // which can't depend on validationResults directly without",
                "    // causing infinite renders.",
                "    const validationResultsRef = useRef({});",
                "    // Simulated onMount state. Consider Form to be mounted once it has",
                "    // accounted for values originating from controlled inputs (available",
                "    // at second rendering).",
                "    const [mounted, setMounted] = useState('unmounted');",
                "    useEffect(() => {",
                "      if (!mounted) setMounted('mounting');",
                "      else if (mounted === 'mounting') setMounted('mounted');",
                "    }, [mounted]);",
                "    // `pendingValidation` is the name of the FormField awaiting validation.",
                "    const [pendingValidation, setPendingValidation] = useState(undefined);",
                "",
                "    const validationRulesRef = useRef({});",
                "    const requiredFields = useRef([]);",
                "",
                "    const buildValid = useCallback(",
                "      (nextErrors) => {",
                "        let valid = false;",
                "        valid = requiredFields.current",
                "          .filter((n) => Object.keys(validationRulesRef.current).includes(n))",
                "          .every(",
                "            (field) =>",
                "              value[field] && (value[field] !== '' || value[field] !== false),",
                "          );",
                "",
                "        if (Object.keys(nextErrors).length > 0) valid = false;",
                "        return valid;",
                "      },",
                "      [value],",
                "    );",
                "",
                "    // Only keep validation results for current form fields. In the case of a",
                "    // dynamic form, a field possessing an error may have been removed from the",
                "    // form; need to clean up any previous related validation results.",
                "    const filterRemovedFields = (prevValidations) => {",
                "      const nextValidations = prevValidations;",
                "      return Object.keys(nextValidations)",
                "        .filter(",
                "          (n) =>",
                "            !validationRulesRef.current[n] || nextValidations[n] === undefined,",
                "        )",
                "        .forEach((n) => delete nextValidations[n]);",
                "    };",
                "",
                "    const applyValidationRules = useCallback(",
                "      (validationRules) => {",
                "        const [validatedErrors, validatedInfos] = validateForm(",
                "          validationRules,",
                "          value,",
                "          format,",
                "          messages,",
                "        );",
                "",
                "        setValidationResults((prevValidationResults) => {",
                "          // Keep any previous errors and infos for untouched keys,",
                "          // these may have come from a Submit.",
                "          const nextErrors = {",
                "            ...prevValidationResults.errors,",
                "            ...validatedErrors,",
                "          };",
                "          const nextInfos = {",
                "            ...prevValidationResults.infos,",
                "            ...validatedInfos,",
                "          };",
                "          // Remove previous errors and infos for keys no longer in the",
                "          // form, these may have been fields removed from a dynamic form.",
                "          filterRemovedFields(nextErrors);",
                "          filterRemovedFields(nextInfos);",
                "          const nextValidationResults = {",
                "            errors: nextErrors,",
                "            infos: nextInfos,",
                "          };",
                "          if (onValidate)",
                "            onValidate({",
                "              ...nextValidationResults,",
                "              valid: buildValid(nextErrors),",
                "            });",
                "          validationResultsRef.current = nextValidationResults;",
                "          return nextValidationResults;",
                "        });",
                "      },",
                "      [buildValid, format, messages, onValidate, value],",
                "    );",
                "",
                "    // Validate all fields holding values onMount if set to",
                "    // validate when blur or change.",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      // Use simulated onMount state to account for values provided by",
                "      // controlled inputs.",
                "      if (",
                "        mounted !== 'mounted' &&",
                "        ['blur', 'change'].includes(validateOn) &&",
                "        Object.keys(value).length > 0 &&",
                "        Object.keys(touched).length === 0",
                "      ) {",
                "        applyValidationRules(",
                "          validationRules",
                "            .filter(([n]) => value[n])",
                "            // Exlude empty arrays which may be initial values in",
                "            // an input such as DateInput.",
                "            .filter(",
                "              ([n]) => !(Array.isArray(value[n]) && value[n].length === 0),",
                "            ),",
                "        );",
                "      }",
                "    }, [applyValidationRules, mounted, touched, validateOn, value]);",
                "",
                "    // Run validation against fields with pendingValidations from onBlur",
                "    // and/or onChange.",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      const timer = setTimeout(() => {",
                "        if (pendingValidation && ['blur', 'change'].includes(validateOn)) {",
                "          applyValidationRules(",
                "            validationRules.filter(",
                "              ([n]) => touched[n] || pendingValidation.includes(n),",
                "            ),",
                "          );",
                "          setPendingValidation(undefined);",
                "        }",
                "        // Complete any potential click events before running onBlur validation.",
                "        // Otherwise, click events like reset, etc. may not be registered. For a",
                "        // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863",
                "        // Values empirically tested; 120 was selected because it is the largest",
                "        // Chrome: 100, Safari: 120, Firefox: 80",
                "      }, 120);",
                "      return () => clearTimeout(timer);",
                "    }, [applyValidationRules, pendingValidation, touched, validateOn]);",
                "",
                "    // Re-run validation rules for all fields with prior errors.",
                "    // if validate=blur this helps re-validate if there are errors",
                "    // as the user fixes them (basically act like validate=change for that)",
                "    useEffect(() => {",
                "      const validationRules = Object.entries(validationRulesRef.current);",
                "      if (",
                "        validationResultsRef.current?.errors &&",
                "        Object.keys(validationResultsRef.current.errors).length > 0",
                "      ) {",
                "        applyValidationRules(",
                "          validationRules.filter(",
                "            ([n]) => touched[n] && validationResultsRef.current.errors[n],",
                "          ),",
                "        );",
                "      }",
                "    }, [applyValidationRules, touched]);",
                "",
                "    // There are three basic patterns of handling form input value state:",
                "    //",
                "    // 1 - form controlled",
                "    //",
                "    // In this model, the caller sets `value` and `onChange` properties",
                "    // on the Form component to supply the values used by the input fields.",
                "    // In useFormContext(), componentValue would be undefined and formValue",
                "    // is be set to whatever the form state has. Whenever the form state",
                "    // changes, we update the contextValue so the input component will use",
                "    // that. When the input component changes, we will call update() to",
                "    // update the form state.",
                "    //",
                "    // 2 - input controlled",
                "    //",
                "    // In this model, the caller sets `value` and `onChange` properties",
                "    // on the input components, like TextInput, to supply the value for it.",
                "    // In useFormContext(), componentValue is this value and we ensure to",
                "    // update the form state, via update(), and set the contextValue from",
                "    // the componentValue. When the input component changes, we will",
                "    // call update() to update the form state.",
                "    //",
                "    // 3 - uncontrolled",
                "    //",
                "    // In this model, the caller doesn't set a `value` or `onChange` property",
                "    // at either the form or input component levels.",
                "    // In useFormContext(), componentValue is undefined and valueProp is",
                "    // undefined and nothing much happens here. That is, unless the",
                "    // calling component needs to know the state in order to work, such",
                "    // as CheckBox or Select. In this case, those components supply",
                "    // an initialValue, which will trigger updating the contextValue so",
                "    // they can have access to it.",
                "    //",
                "    const formContextValue = useMemo(() => {",
                "      const useFormInput = ({",
                "        name,",
                "        value: componentValue,",
                "        initialValue,",
                "        validate: validateArg,",
                "      }) => {",
                "        const [inputValue, setInputValue] = useState(initialValue);",
                "        const formValue = name ? getFieldValue(name, value) : undefined;",
                "        // for dynamic forms, we need to track when an input has been added to",
                "        // the form value. if the input is unmounted, we will delete its",
                "        // key/value from the form value.",
                "        const keyCreated = useRef(false);",
                "",
                "        // This effect is for pattern #2, where the controlled input",
                "        // component is driving the value via componentValue.",
                "        useEffect(() => {",
                "          if (",
                "            name && // we have somewhere to put this",
                "            componentValue !== undefined && // input driving",
                "            componentValue !== formValue // don't already have it",
                "          ) {",
                "            setValueState((prevValue) =>",
                "              setFieldValue(name, componentValue, prevValue),",
                "            );",
                "            // don't onChange on programmatic changes",
                "          }",
                "        }, [componentValue, formValue, name]);",
                "",
                "        // on unmount, if the form is uncontrolled, remove the key/value",
                "        // from the form value",
                "        useEffect(",
                "          () => () => {",
                "            if (keyCreated.current) {",
                "              keyCreated.current = false;",
                "              setValueState((prevValue) => {",
                "                const nextValue = { ...prevValue };",
                "                const isArrayField = stringToArray(name);",
                "                if (isArrayField) {",
                "                  const { arrayName } = isArrayField;",
                "                  delete nextValue[arrayName];",
                "                } else {",
                "                  delete nextValue[name];",
                "                }",
                "                return nextValue;",
                "              });",
                "            }",
                "          },",
                "          // eslint-disable-next-line react-hooks/exhaustive-deps",
                "          [], // only run onmount and unmount",
                "        );",
                "",
                "        // Create validation rules for fields",
                "        useEffect(() => {",
                "          if (validateArg) {",
                "            if (!validationRulesRef.current[name]) {",
                "              validationRulesRef.current[name] = {};",
                "            }",
                "            validationRulesRef.current[name].input = validateName(validateArg);",
                "            return () => delete validationRulesRef.current[name].input;",
                "          }",
                "          return undefined;",
                "        }, [validateArg, name]);",
                "",
                "        let useValue;",
                "        if (componentValue !== undefined)",
                "          // input component drives, pattern #2",
                "          useValue = componentValue;",
                "        else if (valueProp && name && formValue !== undefined)",
                "          // form drives, pattern #1",
                "          useValue = formValue;",
                "        else if (formValue === undefined && name)",
                "          // form has reset, so reset input value as well",
                "          useValue = initialValue;",
                "        else useValue = inputValue;",
                "",
                "        return [",
                "          useValue,",
                "          (nextComponentValue) => {",
                "            if (name) {",
                "              // we have somewhere to put this",
                "              const nextTouched = { ...touched };",
                "              nextTouched[name] = true;",
                "",
                "              if (!touched[name]) {",
                "                // don't update if not needed",
                "                setTouched(nextTouched);",
                "              }",
                "",
                "              // if nextValue doesn't have a key for name, this must be",
                "              // uncontrolled form. we will flag this field was added so",
                "              // we know to remove its value from the form if it is dynamically",
                "              // removed",
                "              if (!(name in value)) keyCreated.current = true;",
                "              const nextValue = setFieldValue(name, nextComponentValue, value);",
                "              setValueState(nextValue);",
                "              if (onChange) onChange(nextValue, { touched: nextTouched });",
                "            }",
                "            if (initialValue !== undefined) setInputValue(nextComponentValue);",
                "          },",
                "        ];",
                "      };",
                "",
                "      const useFormField = ({",
                "        error: errorArg,",
                "        info: infoArg,",
                "        name,",
                "        required,",
                "        disabled,",
                "        validate: validateArg,",
                "      }) => {",
                "        const error = disabled",
                "          ? undefined",
                "          : errorArg || validationResults.errors[name];",
                "        const info = infoArg || validationResults.infos[name];",
                "",
                "        // Create validation rules for field",
                "        useEffect(() => {",
                "          const index = requiredFields.current.indexOf(name);",
                "          if (required) {",
                "            if (index === -1) requiredFields.current.push(name);",
                "          } else if (index !== -1) requiredFields.current.splice(index, 1);",
                "",
                "          if (validateArg || required) {",
                "            if (!validationRulesRef.current[name]) {",
                "              validationRulesRef.current[name] = {};",
                "            }",
                "            validationRulesRef.current[name].field = validateName(",
                "              validateArg,",
                "              required,",
                "            );",
                "            return () => delete validationRulesRef.current[name].field;",
                "          }",
                "",
                "          return undefined;",
                "        }, [error, name, required, validateArg, disabled]);",
                "",
                "        return {",
                "          error,",
                "          info,",
                "          inForm: true,",
                "          onBlur:",
                "            validateOn === 'blur'",
                "              ? () =>",
                "                  setPendingValidation(",
                "                    pendingValidation ? [...pendingValidation, name] : [name],",
                "                  )",
                "              : undefined,",
                "          onChange:",
                "            validateOn === 'change'",
                "              ? () =>",
                "                  setPendingValidation(",
                "                    pendingValidation ? [...pendingValidation, name] : [name],",
                "                  )",
                "              : undefined,",
                "        };",
                "      };",
                "",
                "      return { useFormField, useFormInput };",
                "    }, [",
                "      onChange,",
                "      pendingValidation,",
                "      touched,",
                "      validateOn,",
                "      validationResults.errors,",
                "      validationResults.infos,",
                "      value,",
                "      valueProp,",
                "    ]);",
                "",
                "    return (",
                "      <form",
                "        ref={ref}",
                "        {...rest}",
                "        onReset={(event) => {",
                "          setPendingValidation(undefined);",
                "          if (!valueProp) {",
                "            setValueState(defaultValue);",
                "            if (onChange) onChange(defaultValue, { touched: defaultTouched });",
                "          }",
                "          setTouched(defaultTouched);",
                "          setValidationResults(defaultValidationResults);",
                "          if (onReset) {",
                "            event.persist(); // extract from React's synthetic event pool",
                "            const adjustedEvent = event;",
                "            adjustedEvent.value = defaultValue;",
                "            onReset(adjustedEvent);",
                "          }",
                "        }}",
                "        onSubmit={(event) => {",
                "          // Don't submit the form via browser form action. We don't want it",
                "          // if the validation fails. And, we assume a javascript action handler",
                "          // otherwise.",
                "          event.preventDefault();",
                "          setPendingValidation(undefined);",
                "          const [nextErrors, nextInfos] = validateForm(",
                "            Object.entries(validationRulesRef.current),",
                "            value,",
                "            format,",
                "            messages,",
                "            true,",
                "          );",
                "",
                "          setValidationResults(() => {",
                "            const nextValidationResults = {",
                "              errors: nextErrors,",
                "              infos: nextInfos,",
                "              // Show form's validity when clicking on Submit",
                "              valid: buildValid(nextErrors),",
                "            };",
                "            if (onValidate) onValidate(nextValidationResults);",
                "            validationResultsRef.current = nextValidationResults;",
                "            return nextValidationResults;",
                "          });",
                "",
                "          if (Object.keys(nextErrors).length === 0 && onSubmit) {",
                "            event.persist(); // extract from React's synthetic event pool",
                "            const adjustedEvent = event;",
                "            adjustedEvent.value = value;",
                "            adjustedEvent.touched = touched;",
                "            onSubmit(adjustedEvent);",
                "          }",
                "        }}",
                "      >",
                "        <FormContext.Provider value={formContextValue}>",
                "          {children}",
                "        </FormContext.Provider>",
                "      </form>",
                "    );",
                "  },",
                ");",
                "",
                "Form.displayName = 'Form';",
                "Form.propTypes = FormPropTypes;",
                "",
                "export { Form };"
            ]
        }
    }
}