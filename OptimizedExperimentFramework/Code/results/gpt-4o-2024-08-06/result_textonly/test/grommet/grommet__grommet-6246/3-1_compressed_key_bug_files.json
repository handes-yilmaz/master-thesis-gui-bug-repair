{
    "1": {
        "bug_file": "src/js/components/DataChart/DataChart.js",
        "compressed": "YES",
        "line_numbers": 725,
        "compressed_line_numbers": 170,
        "compressed_bug_file_content": "import React, { forwardRef, useContext, useMemo, useState } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { Box } from '../Box';\nimport { Chart, calcs, calcBounds } from '../Chart';\nimport { Grid } from '../Grid';\nimport { Stack } from '../Stack';\nimport { Text } from '../Text';\nimport { parseMetricToNum } from '../../utils';\nimport { Detail } from './Detail';\nimport { Legend } from './Legend';\nimport { XAxis } from './XAxis';\nimport { YAxis } from './YAxis';\nimport { XGuide } from './XGuide';\nimport { YGuide } from './YGuide';\nimport {\n\n\nimport { DataChartPropTypes } from './propTypes';\n\n\n// DataChart takes a generic data array of objects plus as few properties\n// as possible, and creates a Stack of Charts with x and y axes, a legend,\n// and interactive detail.\n// Much of the code here-in involves the \"few properties\" aspect where we\n// normalize and automatically handle whatever the caller didn't specify.\n\n\n    // legend interaction, if any\n\n\n    // normalize seriesProp to an array of objects, one per property\n\n\n    // Normalize chart to an array of objects.\n    // Each chart has one or more properties associated with it.\n    // A stacked bar or area chart has an array of properties.\n    // A point chart can have x, y, thickness, and color each driven\n    // by a separate property.\n\n\n        // if we have more than one property, we'll use the first for\n        // the x-axis and we'll plot the rest\n\n\n    // map the series property values into their own arrays\n\n\n    // Setup the values property for each chart.\n    // The index into 'charts' can be used to index into 'chartValues'.\n\n\n              // A range chart or a stacked bar or area chart has multiple\n              // properties.\n              // In this case, this returns an array of values,\n              // one per property.\n\n                // Further down, where we render, each property is rendered\n                // using a separate Chart component and the values are stacked\n                // such that they line up appropriately.\n\n\n                  // handle object or string\n\n\n              // When 'property' is an array, the keys of this array indicate\n              // which property drives which part of the rendered Chart.\n\n\n    // map granularities to work well with the number of data points we have\n\n\n      // determine a good medium granularity that will align well with the\n      // length of the data\n\n      // special case property driven point charts\n\n\n    // normalize axis to objects, convert granularity to a number\n\n\n          // see if we have a point chart that has an x property\n\n\n          // see if we have a point chart that has an x property\n\n\n      // calculate number of entries based on granularity\n\n\n    // calculate axis, bounds, and thickness for each chart\n\n\n          // merge values for bars, areas, and lines cases\n\n\n        // if this is a data driven x chart, set coarseness for x\n\n\n    // normalize how we style data properties for use by Legend and Detail\n\n\n      // start from what we were explicitly given\n\n\n            // data driven point chart\n\n\n      // set color for any non-aspect properties we don't have one for yet\n\n\n        // set opacity if it isn't set and this isn't the active property\n\n\n    // normalize guide\n\n\n      // set counts\n\n        // if no granularity and axis, align count with axis\n\n\n        // if no granularity and axis, align count with axis\n\n\n    // set the pad to half the thickness, based on the chart types\n    // except when using offset, then add even more horizontal pad\n\n\n    // calculate the thickness in pixels of each chart\n\n\n    // normalize any offset gap\n\n\n    // calculate the offset for each chart, which is a sum of the thicknesses\n    // any offset gaps that preceded it\n\n\n    // Calculate the total pad we should add to the end of each chart.\n    // We do this to shrink the width of each chart so we can shift them\n    // via `translate` and have them take up the right amount of width.\n\n\n    // The thickness of the Detail segments. We need to convert to numbers\n    // to be able to compare across charts where some might be using T-shirt\n    // labels and others might be pixel values.\n\n\n    // TODO: revisit how x/y axis are hooked up to charts and series\n\n\n          // When we offset, we increase the padding on the end for all charts\n          // by the same amount and we shift each successive chart to the\n          // right by an offset for that chart. The last chart's right side\n          // will end up aligning with where the charts would have been\n          // had we not padded their ends.\n\n\n            // reverse to ensure area Charts are stacked in the right order\n\n\n                    // eslint-disable-next-line react/no-array-index-key\n\n                    // when property name isn't valid, send empty array\n\n\n              // eslint-disable-next-line react/no-array-index-key\n\n\nexport { DataChart };\n"
    },
    "2": {
        "bug_file": "src/js/components/DataChart/YAxis.js",
        "compressed": "NO",
        "line_numbers": 55,
        "compressed_line_numbers": 55,
        "compressed_bug_file_content": "import React, { forwardRef, useContext } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { Box } from '../Box';\nimport { round } from '../Chart';\nimport { doublePad } from './utils';\n\nconst YAxis = forwardRef(({ values, pad, renderValue, serie = {} }, ref) => {\n  const theme = useContext(ThemeContext);\n  const { render, suffix } = serie;\n\n  let divideBy;\n  let unit;\n  if (!render && !suffix) {\n    // figure out how many digits to show\n    const maxValue = Math.max(...values.map((v) => Math.abs(v)));\n    if (maxValue > 10000000) {\n      divideBy = 1000000;\n      unit = 'M';\n    } else if (maxValue > 10000) {\n      divideBy = 1000;\n      unit = 'K';\n    }\n  }\n\n  // Set basis to match double the vertical pad, so we can align the\n  // text with the guides\n  const edgeSize = doublePad[pad.vertical || pad];\n  const basis = theme.global.edgeSize[edgeSize] || edgeSize;\n\n  return (\n    <Box ref={ref} gridArea=\"yAxis\" justify=\"between\" flex>\n      {values.map((axisValue, i) => {\n        let content = renderValue(serie, undefined, axisValue);\n        if (content === axisValue) {\n          if (divideBy) content = round(content / divideBy, 0);\n          if (unit) content = `${content}${unit}`;\n        }\n        return (\n          <Box\n            // eslint-disable-next-line react/no-array-index-key\n            key={i}\n            align=\"end\"\n            basis={basis}\n            flex=\"shrink\"\n            justify={basis ? 'center' : undefined}\n          >\n            {content}\n          </Box>\n        );\n      })}\n    </Box>\n  );\n});\n\nexport { YAxis };"
    }
}