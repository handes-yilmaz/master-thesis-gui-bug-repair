{
    "1": {
        "bug_file": "src/js/components/DataChart/DataChart.js",
        "compressed": "YES",
        "line_numbers": 725,
        "compressed_line_numbers": 170,
        "compressed_bug_file_content": "import React, { forwardRef, useContext, useMemo, useState } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { Box } from '../Box';\nimport { Chart, calcs, calcBounds } from '../Chart';\nimport { Grid } from '../Grid';\nimport { Stack } from '../Stack';\nimport { Text } from '../Text';\nimport { parseMetricToNum } from '../../utils';\nimport { Detail } from './Detail';\nimport { Legend } from './Legend';\nimport { XAxis } from './XAxis';\nimport { YAxis } from './YAxis';\nimport { XGuide } from './XGuide';\nimport { YGuide } from './YGuide';\nimport {\n\n\nimport { DataChartPropTypes } from './propTypes';\n\n\n// DataChart takes a generic data array of objects plus as few properties\n// as possible, and creates a Stack of Charts with x and y axes, a legend,\n// and interactive detail.\n// Much of the code here-in involves the \"few properties\" aspect where we\n// normalize and automatically handle whatever the caller didn't specify.\n\n\n    // legend interaction, if any\n\n\n    // normalize seriesProp to an array of objects, one per property\n\n\n    // Normalize chart to an array of objects.\n    // Each chart has one or more properties associated with it.\n    // A stacked bar or area chart has an array of properties.\n    // A point chart can have x, y, thickness, and color each driven\n    // by a separate property.\n\n\n        // if we have more than one property, we'll use the first for\n        // the x-axis and we'll plot the rest\n\n\n    // map the series property values into their own arrays\n\n\n    // Setup the values property for each chart.\n    // The index into 'charts' can be used to index into 'chartValues'.\n\n\n              // A range chart or a stacked bar or area chart has multiple\n              // properties.\n              // In this case, this returns an array of values,\n              // one per property.\n\n                // Further down, where we render, each property is rendered\n                // using a separate Chart component and the values are stacked\n                // such that they line up appropriately.\n\n\n                  // handle object or string\n\n\n              // When 'property' is an array, the keys of this array indicate\n              // which property drives which part of the rendered Chart.\n\n\n    // map granularities to work well with the number of data points we have\n\n\n      // determine a good medium granularity that will align well with the\n      // length of the data\n\n      // special case property driven point charts\n\n\n    // normalize axis to objects, convert granularity to a number\n\n\n          // see if we have a point chart that has an x property\n\n\n          // see if we have a point chart that has an x property\n\n\n      // calculate number of entries based on granularity\n\n\n    // calculate axis, bounds, and thickness for each chart\n\n\n          // merge values for bars, areas, and lines cases\n\n\n        // if this is a data driven x chart, set coarseness for x\n\n\n    // normalize how we style data properties for use by Legend and Detail\n\n\n      // start from what we were explicitly given\n\n\n            // data driven point chart\n\n\n      // set color for any non-aspect properties we don't have one for yet\n\n\n        // set opacity if it isn't set and this isn't the active property\n\n\n    // normalize guide\n\n\n      // set counts\n\n        // if no granularity and axis, align count with axis\n\n\n        // if no granularity and axis, align count with axis\n\n\n    // set the pad to half the thickness, based on the chart types\n    // except when using offset, then add even more horizontal pad\n\n\n    // calculate the thickness in pixels of each chart\n\n\n    // normalize any offset gap\n\n\n    // calculate the offset for each chart, which is a sum of the thicknesses\n    // any offset gaps that preceded it\n\n\n    // Calculate the total pad we should add to the end of each chart.\n    // We do this to shrink the width of each chart so we can shift them\n    // via `translate` and have them take up the right amount of width.\n\n\n    // The thickness of the Detail segments. We need to convert to numbers\n    // to be able to compare across charts where some might be using T-shirt\n    // labels and others might be pixel values.\n\n\n    // TODO: revisit how x/y axis are hooked up to charts and series\n\n\n          // When we offset, we increase the padding on the end for all charts\n          // by the same amount and we shift each successive chart to the\n          // right by an offset for that chart. The last chart's right side\n          // will end up aligning with where the charts would have been\n          // had we not padded their ends.\n\n\n            // reverse to ensure area Charts are stacked in the right order\n\n\n                    // eslint-disable-next-line react/no-array-index-key\n\n                    // when property name isn't valid, send empty array\n\n\n              // eslint-disable-next-line react/no-array-index-key\n\n\nexport { DataChart };\n"
    },
    "2": {
        "bug_file": "src/js/components/DataChart/utils.js",
        "compressed": "NO",
        "line_numbers": 96,
        "compressed_line_numbers": 96,
        "compressed_bug_file_content": "export const points = [\n  'circle',\n  'diamond',\n  'square',\n  'star',\n  'triangle',\n  'triangleDown',\n];\n\nexport const heightYGranularity = {\n  xxsmall: { fine: 2, medium: 2 },\n  xsmall: { fine: 3, medium: 2 },\n  small: { fine: 5, medium: 3 },\n  medium: { fine: 7, medium: 5 },\n  large: { fine: 9, medium: 5 },\n  xlarge: { fine: 11, medium: 5 },\n};\n\nexport const halfPad = {\n  xlarge: 'large',\n  large: 'medium',\n  medium: 'small',\n  small: 'xsmall',\n  xsmall: 'xxsmall',\n};\n\nexport const doublePad = {\n  large: 'xlarge',\n  medium: 'large',\n  small: 'medium',\n  xsmall: 'small',\n  xxsmall: 'xsmall',\n};\n\nconst orderedSizes = [\n  'xlarge',\n  'large',\n  'medium',\n  'small',\n  'xsmall',\n  'xxsmall',\n  'hair',\n];\n\nexport const largestSize = (size1, size2) => {\n  if (size1 && !size2) return size1;\n  if (size2 && !size1) return size2;\n  if (orderedSizes.indexOf(size1) < orderedSizes.indexOf(size2)) return size1;\n  return size2;\n};\n\nexport const createDateFormat = (firstValue, lastValue, full) => {\n  let dateFormat;\n  const startDate = new Date(firstValue);\n  const endDate = new Date(lastValue);\n  if (\n    // check for valid dates, this is the fastest way\n    !Number.isNaN(startDate.getTime()) &&\n    !Number.isNaN(endDate.getTime())\n  ) {\n    const delta = Math.abs(endDate - startDate);\n    let options;\n    if (delta < 60000)\n      // less than 1 minute\n      options = full\n        ? {\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n            day: undefined,\n          }\n        : { second: '2-digit', day: undefined };\n    else if (delta < 3600000)\n      // less than 1 hour\n      options = full\n        ? { hour: 'numeric', minute: '2-digit', day: undefined }\n        : { minute: '2-digit', day: undefined };\n    else if (delta < 86400000)\n      // less than 1 day\n      options = { hour: 'numeric' };\n    else if (delta < 2592000000)\n      // less than 30 days\n      options = {\n        month: full ? 'short' : 'numeric',\n        day: 'numeric',\n      };\n    else if (delta < 31557600000)\n      // less than 1 year\n      options = { month: full ? 'long' : 'short' };\n    // 1 year or more\n    else options = { year: 'numeric' };\n    if (options)\n      dateFormat = new Intl.DateTimeFormat(undefined, options).format;\n  }\n  return dateFormat;\n};"
    },
    "3": {
        "bug_file": "src/js/components/DataChart/XAxis.js",
        "compressed": "NO",
        "line_numbers": 35,
        "compressed_line_numbers": 35,
        "compressed_bug_file_content": "import React, { forwardRef } from 'react';\nimport { Box } from '../Box';\n\nconst XAxis = forwardRef(\n  ({ values, pad, renderValue, serie, ...rest }, ref) => {\n    // When there are only labels at the end of the axis, let them take as much\n    // space as they like. If there are more, align their container to the\n    // data/guide lines and then let their content overflow that.\n    const itemProps =\n      values.length === 2\n        ? {}\n        : { width: '1px', overflow: 'visible', align: 'center' };\n    const { horizontal, start, end } = pad; // ignore vertical parts\n\n    return (\n      <Box\n        ref={ref}\n        gridArea=\"xAxis\"\n        direction=\"row\"\n        justify=\"between\"\n        pad={{ horizontal, start, end }}\n        {...rest}\n      >\n        {values.map((dataIndex, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <Box key={i} {...itemProps}>\n            {serie ? renderValue(serie, dataIndex) : dataIndex}\n          </Box>\n        ))}\n      </Box>\n    );\n  },\n);\n\nexport { XAxis };"
    },
    "4": {
        "bug_file": "src/js/components/DataChart/YAxis.js",
        "compressed": "NO",
        "line_numbers": 55,
        "compressed_line_numbers": 55,
        "compressed_bug_file_content": "import React, { forwardRef, useContext } from 'react';\nimport { ThemeContext } from 'styled-components';\nimport { Box } from '../Box';\nimport { round } from '../Chart';\nimport { doublePad } from './utils';\n\nconst YAxis = forwardRef(({ values, pad, renderValue, serie = {} }, ref) => {\n  const theme = useContext(ThemeContext);\n  const { render, suffix } = serie;\n\n  let divideBy;\n  let unit;\n  if (!render && !suffix) {\n    // figure out how many digits to show\n    const maxValue = Math.max(...values.map((v) => Math.abs(v)));\n    if (maxValue > 10000000) {\n      divideBy = 1000000;\n      unit = 'M';\n    } else if (maxValue > 10000) {\n      divideBy = 1000;\n      unit = 'K';\n    }\n  }\n\n  // Set basis to match double the vertical pad, so we can align the\n  // text with the guides\n  const edgeSize = doublePad[pad.vertical || pad];\n  const basis = theme.global.edgeSize[edgeSize] || edgeSize;\n\n  return (\n    <Box ref={ref} gridArea=\"yAxis\" justify=\"between\" flex>\n      {values.map((axisValue, i) => {\n        let content = renderValue(serie, undefined, axisValue);\n        if (content === axisValue) {\n          if (divideBy) content = round(content / divideBy, 0);\n          if (unit) content = `${content}${unit}`;\n        }\n        return (\n          <Box\n            // eslint-disable-next-line react/no-array-index-key\n            key={i}\n            align=\"end\"\n            basis={basis}\n            flex=\"shrink\"\n            justify={basis ? 'center' : undefined}\n          >\n            {content}\n          </Box>\n        );\n      })}\n    </Box>\n  );\n});\n\nexport { YAxis };"
    },
    "5": {
        "bug_file": "src/js/components/DataChart/__tests__/DataChart-test.js",
        "compressed": "NO",
        "line_numbers": 438,
        "compressed_line_numbers": 438,
        "compressed_bug_file_content": "import React, { Fragment } from 'react';\nimport { render } from '@testing-library/react';\nimport 'jest-styled-components';\n\nimport { Grommet } from '../../Grommet';\nimport { Box } from '../../Box';\nimport { Text } from '../../Text';\nimport { DataChart } from '..';\n\nconst data = [\n  { a: 1, b: 'one', c: 111111, d: '2020-06-24' },\n  { a: 2, b: 'two', c: 222222, d: '2020-06-23' },\n];\n\ndescribe('DataChart', () => {\n  let warnSpy;\n\n  beforeEach(() => {\n    warnSpy = jest.spyOn(console, 'warn').mockImplementation();\n  });\n\n  afterEach(() => {\n    warnSpy.mockRestore();\n  });\n\n  test('default', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart data={data} series=\"a\" />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('nothing', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart data={data} />\n        <DataChart data={data} series={[]} />\n        <DataChart data={data} series={[{}]} />\n        <DataChart data={data} series={[{ property: 'a' }, {}]} />\n        <DataChart data={data} chart={[]} />\n        <DataChart data={data} chart={[{}]} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('single', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={[data[0]]}\n          series={['d', 'a']}\n          axis={{\n            x: { property: 'd' },\n            y: { property: 'a' },\n          }}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('gap', () => {\n    const { container } = render(\n      <Grommet>\n        {['small', 'medium', 'large'].map((gap) => (\n          <DataChart key={gap} data={data} series=\"a\" gap={gap} />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('pad', () => {\n    const { container } = render(\n      <Grommet>\n        {['small', 'medium', 'large'].map((pad) => (\n          <DataChart key={pad} data={data} series=\"a\" pad={pad} />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('size', () => {\n    const { container } = render(\n      <Grommet>\n        {['fill', { width: 'fill' }, { width: 'auto' }].map((size, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <DataChart key={i} data={data} series=\"a\" size={size} />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('axis', () => {\n    const { container } = render(\n      <Grommet>\n        {[\n          true,\n          false,\n          { x: { property: 'd' } },\n          { y: { property: 'a' } },\n          { x: { property: 'd', granularity: 'fine' } },\n          { y: { property: 'a', granularity: 'fine' } },\n        ].map((axis, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <DataChart key={i} data={data} series=\"a\" axis={axis} />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('dates', () => {\n    const dateData = [];\n    for (let i = 0; i < 4; i += 1) {\n      const digits = ((i % 12) + 1).toString().padStart(2, 0);\n      dateData.push({\n        second: `2020-05-15T08:04:${digits}`,\n        minute: `2020-05-15T08:${digits}:00`,\n        hour: `2020-05-15T${digits}:00:00`,\n        day: `2020-05-${digits}T08:00:00`,\n        month: `2020-${digits}-15`,\n        year: `20${digits}-01-15`,\n        percent: Math.abs(i * 10),\n        amount: i * 111111,\n      });\n    }\n    const { container } = render(\n      <Grommet>\n        {['second', 'minute', 'hour', 'day', 'month', 'year'].map((key) => (\n          <Fragment key={key}>\n            <DataChart\n              data={dateData}\n              series={[{ property: key }, 'amount']}\n              axis\n              guide\n            />\n          </Fragment>\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('guide', () => {\n    const { container } = render(\n      <Grommet>\n        {[\n          true,\n          false,\n          { x: { granularity: 'fine' } },\n          { y: { granularity: 'fine' } },\n        ].map((guide, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <DataChart key={i} data={data} series=\"a\" guide={guide} />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('legend', () => {\n    const { container } = render(\n      <Grommet>\n        {[true, false].map((legend, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <DataChart key={i} data={data} series=\"a\" legend={legend} />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('detail', () => {\n    const { container } = render(\n      <Grommet>\n        {[true, false].map((detail, i) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <DataChart key={i} data={data} series=\"a\" detail={detail} />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('detail pad + thickness', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart data={data} series=\"a\" detail />\n        <DataChart data={data} series=\"a\" detail pad=\"small\" />\n        <DataChart\n          data={data}\n          series=\"a\"\n          detail\n          pad={{ horizontal: 'small' }}\n        />\n        <DataChart data={data} series=\"a\" detail pad={{ vertical: 'small' }} />\n        <DataChart\n          data={data}\n          series=\"a\"\n          chart={[{ property: 'a', thickness: 'large' }]}\n          detail\n          pad={{ horizontal: 'xlarge' }}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('axis x granularity', () => {\n    const { container } = render(\n      <Grommet>\n        {[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13].map((count) => (\n          <DataChart\n            key={count}\n            data={Array.from({ length: count }, (x, i) => ({ a: i }))}\n            series=\"a\"\n            axis={{ x: { granularity: 'medium' } }}\n          />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('type', () => {\n    const { container } = render(\n      <Grommet>\n        {['bar', 'line', 'area'].map((type) => (\n          <DataChart\n            key={type}\n            data={data}\n            series=\"a\"\n            chart={[{ property: 'a', type }]}\n          />\n        ))}\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('bars', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data}\n          series={['a', 'c']}\n          chart={[{ property: ['a', 'c'], type: 'bars' }]}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('bars colors', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data}\n          series={['a', 'c']}\n          chart={[\n            {\n              property: [\n                { property: 'a', color: 'graph-1' },\n                { property: 'c', color: 'graph-3' },\n              ],\n              type: 'bars',\n            },\n          ]}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('bars invalid', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data}\n          series={['a']}\n          chart={[{ property: ['a', 'c', ''], type: 'bars' }]}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('bars empty', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data}\n          series={['a']}\n          chart={[{ property: [], type: 'bars' }]}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('areas', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data}\n          series={['a', 'c']}\n          chart={[\n            {\n              property: [\n                { property: 'a', thickness: 'hair', opacity: 'medium' },\n                'c',\n              ],\n              type: 'areas',\n            },\n          ]}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('lines', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data}\n          series={['a', 'c']}\n          chart={[{ property: ['a', 'c'], type: 'lines' }]}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('offset', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart data={data} series={['a', 'c']} offset />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('offset gap', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data}\n          series={['a', 'c']}\n          offset={{ gap: 'xxsmall' }}\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('bounds align', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart data={data} series={['a', 'c']} bounds=\"align\" />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('bounds explicit', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart data={data} series={['a', 'c']} bounds={{ y: [0, 100] }} />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('placeholder text', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data.map(({ d }) => ({ d }))} // date only\n          series={['d', 'a']}\n          bounds={{ y: [0, 100] }}\n          placeholder=\"no data\"\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n\n  test('placeholder node', () => {\n    const { container } = render(\n      <Grommet>\n        <DataChart\n          data={data.map(({ d }) => ({ d }))} // date only\n          series={['d', 'a']}\n          bounds={{ y: [0, 100] }}\n          placeholder={\n            <Box fill background=\"light-3\" align=\"center\" justify=\"center\">\n              <Text>no data</Text>\n            </Box>\n          }\n        />\n      </Grommet>,\n    );\n\n    expect(container.firstChild).toMatchSnapshot();\n  });\n});"
    }
}