{
    "bug_classes": {
        "1": {
            "class_name": "Prism.languages.rest (not found) ",
            "file_path": "components/prism-rest.js",
            "class_details": [
                {
                    "name": "Prism.languages.rest",
                    "start_line": 1,
                    "end_line": 205
                }
            ],
            "class_code": [
                "Prism.languages.rest = {",
                "\t'table': [",
                "\t\t{",
                "\t\t\tpattern: /(^[\\t ]*)(?:\\+[=-]+)+\\+(?:\\r?\\n|\\r)(?:\\1[+|].+[+|](?:\\r?\\n|\\r))+\\1(?:\\+[=-]+)+\\+/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /\\||(?:\\+[=-]+)+\\+/",
                "\t\t\t}",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(^[\\t ]*)=+ [ =]*=(?:(?:\\r?\\n|\\r)\\1.+)+(?:\\r?\\n|\\r)\\1=+ [ =]*=(?=(?:\\r?\\n|\\r){2}|\\s*$)/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /[=-]+/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "",
                "\t// Directive-like patterns",
                "",
                "\t'substitution-def': {",
                "\t\tpattern: /(^[\\t ]*\\.\\. )\\|(?:[^|\\s](?:[^|]*[^|\\s])?)\\| [^:]+::/m,",
                "\t\tlookbehind: true,",
                "\t\tinside: {",
                "\t\t\t'substitution': {",
                "\t\t\t\tpattern: /^\\|(?:[^|\\s]|[^|\\s][^|]*[^|\\s])\\|/,",
                "\t\t\t\talias: 'attr-value',",
                "\t\t\t\tinside: {",
                "\t\t\t\t\t'punctuation': /^\\||\\|$/",
                "\t\t\t\t}",
                "\t\t\t},",
                "\t\t\t'directive': {",
                "\t\t\t\tpattern: /( )(?! )[^:]+::/,",
                "\t\t\t\tlookbehind: true,",
                "\t\t\t\talias: 'function',",
                "\t\t\t\tinside: {",
                "\t\t\t\t\t'punctuation': /::$/",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "\t},",
                "\t'link-target': [",
                "\t\t{",
                "\t\t\tpattern: /(^[\\t ]*\\.\\. )\\[[^\\]]+\\]/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\talias: 'string',",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^\\[|\\]$/",
                "\t\t\t}",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(^[\\t ]*\\.\\. )_(?:`[^`]+`|(?:[^:\\\\]|\\\\.)+):/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\talias: 'string',",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^_|:$/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "\t'directive': {",
                "\t\tpattern: /(^[\\t ]*\\.\\. )[^:]+::/m,",
                "\t\tlookbehind: true,",
                "\t\talias: 'function',",
                "\t\tinside: {",
                "\t\t\t'punctuation': /::$/",
                "\t\t}",
                "\t},",
                "\t'comment': {",
                "\t\t// The two alternatives try to prevent highlighting of blank comments",
                "\t\tpattern: /(^[\\t ]*\\.\\.)(?:(?: .+)?(?:(?:\\r?\\n|\\r).+)+| .+)(?=(?:\\r?\\n|\\r){2}|$)/m,",
                "\t\tlookbehind: true",
                "\t},",
                "",
                "\t'title': [",
                "\t\t// Overlined and underlined",
                "\t\t{",
                "\t\t\tpattern: /^(([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2+)(?:\\r?\\n|\\r).+(?:\\r?\\n|\\r)\\1$/m,",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+|[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+$/,",
                "\t\t\t\t'important': /.+/",
                "\t\t\t}",
                "\t\t},",
                "",
                "\t\t// Underlined only",
                "\t\t{",
                "\t\t\tpattern: /(^|(?:\\r?\\n|\\r){2}).+(?:\\r?\\n|\\r)([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2+(?=\\r?\\n|\\r|$)/,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+$/,",
                "\t\t\t\t'important': /.+/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "\t'hr': {",
                "\t\tpattern: /((?:\\r?\\n|\\r){2})([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2{3,}(?=(?:\\r?\\n|\\r){2})/,",
                "\t\tlookbehind: true,",
                "\t\talias: 'punctuation'",
                "\t},",
                "\t'field': {",
                "\t\tpattern: /(^[\\t ]*):[^:\\r\\n]+:(?= )/m,",
                "\t\tlookbehind: true,",
                "\t\talias: 'attr-name'",
                "\t},",
                "\t'command-line-option': {",
                "\t\tpattern: /(^[\\t ]*)(?:[+-][a-z\\d]|(?:--|\\/)[a-z\\d-]+)(?:[ =](?:[a-z][\\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\\d]|(?:--|\\/)[a-z\\d-]+)(?:[ =](?:[a-z][\\w-]*|<[^<>]+>))?)*(?=(?:\\r?\\n|\\r)? {2,}\\S)/im,",
                "\t\tlookbehind: true,",
                "\t\talias: 'symbol'",
                "\t},",
                "\t'literal-block': {",
                "\t\tpattern: /::(?:\\r?\\n|\\r){2}([ \\t]+)(?![ \\t]).+(?:(?:\\r?\\n|\\r)\\1.+)*/,",
                "\t\tinside: {",
                "\t\t\t'literal-block-punctuation': {",
                "\t\t\t\tpattern: /^::/,",
                "\t\t\t\talias: 'punctuation'",
                "\t\t\t}",
                "\t\t}",
                "\t},",
                "\t'quoted-literal-block': {",
                "\t\tpattern: /::(?:\\r?\\n|\\r){2}([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]).*(?:(?:\\r?\\n|\\r)\\1.*)*/,",
                "\t\tinside: {",
                "\t\t\t'literal-block-punctuation': {",
                "\t\t\t\tpattern: /^(?:::|([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\1*)/m,",
                "\t\t\t\talias: 'punctuation'",
                "\t\t\t}",
                "\t\t}",
                "\t},",
                "\t'list-bullet': {",
                "\t\tpattern: /(^[\\t ]*)(?:[*+\\-\u2022\u2023\u2043]|\\(?(?:\\d+|[a-z]|[ivxdclm]+)\\)|(?:\\d+|[a-z]|[ivxdclm]+)\\.)(?= )/im,",
                "\t\tlookbehind: true,",
                "\t\talias: 'punctuation'",
                "\t},",
                "\t'doctest-block': {",
                "\t\tpattern: /(^[\\t ]*)>>> .+(?:(?:\\r?\\n|\\r).+)*/m,",
                "\t\tlookbehind: true,",
                "\t\tinside: {",
                "\t\t\t'punctuation': /^>>>/",
                "\t\t}",
                "\t},",
                "",
                "\t'inline': [",
                "\t\t{",
                "\t\t\tpattern: /(^|[\\s\\-:\\/'\"<(\\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\\*\\*?|``?|\\|)(?!\\s).*?\\S\\2(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$))/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'bold': {",
                "\t\t\t\t\tpattern: /(^\\*\\*).+(?=\\*\\*$)/,",
                "\t\t\t\t\tlookbehind: true",
                "\t\t\t\t},",
                "\t\t\t\t'italic': {",
                "\t\t\t\t\tpattern: /(^\\*).+(?=\\*$)/,",
                "\t\t\t\t\tlookbehind: true",
                "\t\t\t\t},",
                "\t\t\t\t'inline-literal': {",
                "\t\t\t\t\tpattern: /(^``).+(?=``$)/,",
                "\t\t\t\t\tlookbehind: true,",
                "\t\t\t\t\talias: 'symbol'",
                "\t\t\t\t},",
                "\t\t\t\t'role': {",
                "\t\t\t\t\tpattern: /^:[^:]+:|:[^:]+:$/,",
                "\t\t\t\t\talias: 'function',",
                "\t\t\t\t\tinside: {",
                "\t\t\t\t\t\t'punctuation': /^:|:$/",
                "\t\t\t\t\t}",
                "\t\t\t\t},",
                "\t\t\t\t'interpreted-text': {",
                "\t\t\t\t\tpattern: /(^`).+(?=`$)/,",
                "\t\t\t\t\tlookbehind: true,",
                "\t\t\t\t\talias: 'attr-value'",
                "\t\t\t\t},",
                "\t\t\t\t'substitution': {",
                "\t\t\t\t\tpattern: /(^\\|).+(?=\\|$)/,",
                "\t\t\t\t\tlookbehind: true,",
                "\t\t\t\t\talias: 'attr-value'",
                "\t\t\t\t},",
                "\t\t\t\t'punctuation': /\\*\\*?|``?|\\|/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "",
                "\t'link': [",
                "\t\t{",
                "\t\t\tpattern: /\\[[^\\[\\]]+\\]_(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$)/,",
                "\t\t\talias: 'string',",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^\\[|\\]_$/",
                "\t\t\t}",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(?:\\b[a-z\\d]+(?:[_.:+][a-z\\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$)/i,",
                "\t\t\talias: 'string',",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^_?`|`$|`?_?_$/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "",
                "\t// Line block start,",
                "\t// quote attribution,",
                "\t// explicit markup start,",
                "\t// and anonymous hyperlink target shortcut (__)",
                "\t'punctuation': {",
                "\t\tpattern: /(^[\\t ]*)(?:\\|(?= |$)|(?:---?|\u2014|\\.\\.|__)(?= )|\\.\\.$)/m,",
                "\t\tlookbehind: true",
                "\t}",
                "};"
            ]
        },
        "2": {
            "class_name": "  (not found) 1-501",
            "file_path": "components/prism-core.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "/// <reference lib=\"WebWorker\"/>",
                "",
                "var _self = (typeof window !== 'undefined')",
                "\t? window   // if in browser",
                "\t: (",
                "\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)",
                "\t\t\t? self // if in worker",
                "\t\t\t: {}   // if in node js",
                "\t);",
                "",
                "/**",
                " * Prism: Lightweight, robust, elegant syntax highlighting",
                " *",
                " * @license MIT <https://opensource.org/licenses/MIT>",
                " * @author Lea Verou <https://lea.verou.me>",
                " * @namespace",
                " * @public",
                " */",
                "var Prism = (function (_self) {",
                "",
                "\t// Private helper vars",
                "\tvar lang = /\\blang(?:uage)?-([\\w-]+)\\b/i;",
                "\tvar uniqueId = 0;",
                "",
                "\t// The grammar object for plaintext",
                "\tvar plainTextGrammar = {};",
                "",
                "",
                "\tvar _ = {",
                "\t\t/**",
                "\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the",
                "\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load",
                "\t\t * additional languages or plugins yourself.",
                "\t\t *",
                "\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.",
                "\t\t *",
                "\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an",
                "\t\t * empty Prism object into the global scope before loading the Prism script like this:",
                "\t\t *",
                "\t\t * ```js",
                "\t\t * window.Prism = window.Prism || {};",
                "\t\t * Prism.manual = true;",
                "\t\t * // add a new <script> to load Prism's script",
                "\t\t * ```",
                "\t\t *",
                "\t\t * @default false",
                "\t\t * @type {boolean}",
                "\t\t * @memberof Prism",
                "\t\t * @public",
                "\t\t */",
                "\t\tmanual: _self.Prism && _self.Prism.manual,",
                "\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,",
                "",
                "\t\t/**",
                "\t\t * A namespace for utility methods.",
                "\t\t *",
                "\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may",
                "\t\t * change or disappear at any time.",
                "\t\t *",
                "\t\t * @namespace",
                "\t\t * @memberof Prism",
                "\t\t */",
                "\t\tutil: {",
                "\t\t\tencode: function encode(tokens) {",
                "\t\t\t\tif (tokens instanceof Token) {",
                "\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);",
                "\t\t\t\t} else if (Array.isArray(tokens)) {",
                "\t\t\t\t\treturn tokens.map(encode);",
                "\t\t\t\t} else {",
                "\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');",
                "\t\t\t\t}",
                "\t\t\t},",
                "",
                "\t\t\t/**",
                "\t\t\t * Returns the name of the type of the given value.",
                "\t\t\t *",
                "\t\t\t * @param {any} o",
                "\t\t\t * @returns {string}",
                "\t\t\t * @example",
                "\t\t\t * type(null)      === 'Null'",
                "\t\t\t * type(undefined) === 'Undefined'",
                "\t\t\t * type(123)       === 'Number'",
                "\t\t\t * type('foo')     === 'String'",
                "\t\t\t * type(true)      === 'Boolean'",
                "\t\t\t * type([1, 2])    === 'Array'",
                "\t\t\t * type({})        === 'Object'",
                "\t\t\t * type(String)    === 'Function'",
                "\t\t\t * type(/abc+/)    === 'RegExp'",
                "\t\t\t */",
                "\t\t\ttype: function (o) {",
                "\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);",
                "\t\t\t},",
                "",
                "\t\t\t/**",
                "\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.",
                "\t\t\t *",
                "\t\t\t * @param {Object} obj",
                "\t\t\t * @returns {number}",
                "\t\t\t */",
                "\t\t\tobjId: function (obj) {",
                "\t\t\t\tif (!obj['__id']) {",
                "\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });",
                "\t\t\t\t}",
                "\t\t\t\treturn obj['__id'];",
                "\t\t\t},",
                "",
                "\t\t\t/**",
                "\t\t\t * Creates a deep clone of the given object.",
                "\t\t\t *",
                "\t\t\t * The main intended use of this function is to clone language definitions.",
                "\t\t\t *",
                "\t\t\t * @param {T} o",
                "\t\t\t * @param {Record<number, any>} [visited]",
                "\t\t\t * @returns {T}",
                "\t\t\t * @template T",
                "\t\t\t */",
                "\t\t\tclone: function deepClone(o, visited) {",
                "\t\t\t\tvisited = visited || {};",
                "",
                "\t\t\t\tvar clone; var id;",
                "\t\t\t\tswitch (_.util.type(o)) {",
                "\t\t\t\t\tcase 'Object':",
                "\t\t\t\t\t\tid = _.util.objId(o);",
                "\t\t\t\t\t\tif (visited[id]) {",
                "\t\t\t\t\t\t\treturn visited[id];",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});",
                "\t\t\t\t\t\tvisited[id] = clone;",
                "",
                "\t\t\t\t\t\tfor (var key in o) {",
                "\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {",
                "\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);",
                "\t\t\t\t\t\t\t}",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\treturn /** @type {any} */ (clone);",
                "",
                "\t\t\t\t\tcase 'Array':",
                "\t\t\t\t\t\tid = _.util.objId(o);",
                "\t\t\t\t\t\tif (visited[id]) {",
                "\t\t\t\t\t\t\treturn visited[id];",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t\tclone = [];",
                "\t\t\t\t\t\tvisited[id] = clone;",
                "",
                "\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {",
                "\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);",
                "\t\t\t\t\t\t});",
                "",
                "\t\t\t\t\t\treturn /** @type {any} */ (clone);",
                "",
                "\t\t\t\t\tdefault:",
                "\t\t\t\t\t\treturn o;",
                "\t\t\t\t}",
                "\t\t\t},",
                "",
                "\t\t\t/**",
                "\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.",
                "\t\t\t *",
                "\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.",
                "\t\t\t *",
                "\t\t\t * @param {Element} element",
                "\t\t\t * @returns {string}",
                "\t\t\t */",
                "\t\t\tgetLanguage: function (element) {",
                "\t\t\t\twhile (element && !lang.test(element.className)) {",
                "\t\t\t\t\telement = element.parentElement;",
                "\t\t\t\t}",
                "\t\t\t\tif (element) {",
                "\t\t\t\t\treturn (element.className.match(lang) || [, 'none'])[1].toLowerCase();",
                "\t\t\t\t}",
                "\t\t\t\treturn 'none';",
                "\t\t\t},",
                "",
                "\t\t\t/**",
                "\t\t\t * Returns the script element that is currently executing.",
                "\t\t\t *",
                "\t\t\t * This does __not__ work for line script element.",
                "\t\t\t *",
                "\t\t\t * @returns {HTMLScriptElement | null}",
                "\t\t\t */",
                "\t\t\tcurrentScript: function () {",
                "\t\t\t\tif (typeof document === 'undefined') {",
                "\t\t\t\t\treturn null;",
                "\t\t\t\t}",
                "\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {",
                "\t\t\t\t\treturn /** @type {any} */ (document.currentScript);",
                "\t\t\t\t}",
                "",
                "\t\t\t\t// IE11 workaround",
                "\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace",
                "\t\t\t\t// this will not work for inline scripts",
                "",
                "\t\t\t\ttry {",
                "\t\t\t\t\tthrow new Error();",
                "\t\t\t\t} catch (err) {",
                "\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.",
                "\t\t\t\t\t// A stack will look like this:",
                "\t\t\t\t\t//",
                "\t\t\t\t\t// Error",
                "\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)",
                "\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)",
                "",
                "\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):.+:.+\\)$/i.exec(err.stack) || [])[1];",
                "\t\t\t\t\tif (src) {",
                "\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');",
                "\t\t\t\t\t\tfor (var i in scripts) {",
                "\t\t\t\t\t\t\tif (scripts[i].src == src) {",
                "\t\t\t\t\t\t\t\treturn scripts[i];",
                "\t\t\t\t\t\t\t}",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t}",
                "\t\t\t\t\treturn null;",
                "\t\t\t\t}",
                "\t\t\t},",
                "",
                "\t\t\t/**",
                "\t\t\t * Returns whether a given class is active for `element`.",
                "\t\t\t *",
                "\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated",
                "\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the",
                "\t\t\t * given class is just the given class with a `no-` prefix.",
                "\t\t\t *",
                "\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is",
                "\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its",
                "\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.",
                "\t\t\t *",
                "\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated",
                "\t\t\t * version of it, the class is considered active.",
                "\t\t\t *",
                "\t\t\t * @param {Element} element",
                "\t\t\t * @param {string} className",
                "\t\t\t * @param {boolean} [defaultActivation=false]",
                "\t\t\t * @returns {boolean}",
                "\t\t\t */",
                "\t\t\tisActive: function (element, className, defaultActivation) {",
                "\t\t\t\tvar no = 'no-' + className;",
                "",
                "\t\t\t\twhile (element) {",
                "\t\t\t\t\tvar classList = element.classList;",
                "\t\t\t\t\tif (classList.contains(className)) {",
                "\t\t\t\t\t\treturn true;",
                "\t\t\t\t\t}",
                "\t\t\t\t\tif (classList.contains(no)) {",
                "\t\t\t\t\t\treturn false;",
                "\t\t\t\t\t}",
                "\t\t\t\t\telement = element.parentElement;",
                "\t\t\t\t}",
                "\t\t\t\treturn !!defaultActivation;",
                "\t\t\t}",
                "\t\t},",
                "",
                "\t\t/**",
                "\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.",
                "\t\t *",
                "\t\t * @namespace",
                "\t\t * @memberof Prism",
                "\t\t * @public",
                "\t\t */",
                "\t\tlanguages: {",
                "\t\t\t/**",
                "\t\t\t * The grammar for plain, unformatted text.",
                "\t\t\t */",
                "\t\t\tplain: plainTextGrammar,",
                "\t\t\tplaintext: plainTextGrammar,",
                "\t\t\ttext: plainTextGrammar,",
                "\t\t\ttxt: plainTextGrammar,",
                "",
                "\t\t\t/**",
                "\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.",
                "\t\t\t *",
                "\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language",
                "\t\t\t * will be overwritten at its original position.",
                "\t\t\t *",
                "\t\t\t * ## Best practices",
                "\t\t\t *",
                "\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)",
                "\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to",
                "\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.",
                "\t\t\t *",
                "\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.",
                "\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.",
                "\t\t\t *",
                "\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.",
                "\t\t\t * @param {Grammar} redef The new tokens to append.",
                "\t\t\t * @returns {Grammar} The new language created.",
                "\t\t\t * @public",
                "\t\t\t * @example",
                "\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {",
                "\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token",
                "\t\t\t *     // at its original position",
                "\t\t\t *     'comment': { ... },",
                "\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended",
                "\t\t\t *     'color': /\\b(?:red|green|blue)\\b/",
                "\t\t\t * });",
                "\t\t\t */",
                "\t\t\textend: function (id, redef) {",
                "\t\t\t\tvar lang = _.util.clone(_.languages[id]);",
                "",
                "\t\t\t\tfor (var key in redef) {",
                "\t\t\t\t\tlang[key] = redef[key];",
                "\t\t\t\t}",
                "",
                "\t\t\t\treturn lang;",
                "\t\t\t},",
                "",
                "\t\t\t/**",
                "\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.",
                "\t\t\t *",
                "\t\t\t * ## Usage",
                "\t\t\t *",
                "\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition",
                "\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded",
                "\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the",
                "\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do",
                "\t\t\t * this:",
                "\t\t\t *",
                "\t\t\t * ```js",
                "\t\t\t * Prism.languages.markup.style = {",
                "\t\t\t *     // token",
                "\t\t\t * };",
                "\t\t\t * ```",
                "\t\t\t *",
                "\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens",
                "\t\t\t * before existing tokens. For the CSS example above, you would use it like this:",
                "\t\t\t *",
                "\t\t\t * ```js",
                "\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {",
                "\t\t\t *     'style': {",
                "\t\t\t *         // token",
                "\t\t\t *     }",
                "\t\t\t * });",
                "\t\t\t * ```",
                "\t\t\t *",
                "\t\t\t * ## Special cases",
                "\t\t\t *",
                "\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar",
                "\t\t\t * will be ignored.",
                "\t\t\t *",
                "\t\t\t * This behavior can be used to insert tokens after `before`:",
                "\t\t\t *",
                "\t\t\t * ```js",
                "\t\t\t * Prism.languages.insertBefore('markup', 'comment', {",
                "\t\t\t *     'comment': Prism.languages.markup.comment,",
                "\t\t\t *     // tokens after 'comment'",
                "\t\t\t * });",
                "\t\t\t * ```",
                "\t\t\t *",
                "\t\t\t * ## Limitations",
                "\t\t\t *",
                "\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object",
                "\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave",
                "\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily",
                "\t\t\t * deleting properties which is necessary to insert at arbitrary positions.",
                "\t\t\t *",
                "\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.",
                "\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This",
                "\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.",
                "\t\t\t *",
                "\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if",
                "\t\t\t * you hold the target object in a variable, then the value of the variable will not change.",
                "\t\t\t *",
                "\t\t\t * ```js",
                "\t\t\t * var oldMarkup = Prism.languages.markup;",
                "\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });",
                "\t\t\t *",
                "\t\t\t * assert(oldMarkup !== Prism.languages.markup);",
                "\t\t\t * assert(newMarkup === Prism.languages.markup);",
                "\t\t\t * ```",
                "\t\t\t *",
                "\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the",
                "\t\t\t * object to be modified.",
                "\t\t\t * @param {string} before The key to insert before.",
                "\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.",
                "\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the",
                "\t\t\t * object to be modified.",
                "\t\t\t *",
                "\t\t\t * Defaults to `Prism.languages`.",
                "\t\t\t * @returns {Grammar} The new grammar object.",
                "\t\t\t * @public",
                "\t\t\t */",
                "\t\t\tinsertBefore: function (inside, before, insert, root) {",
                "\t\t\t\troot = root || /** @type {any} */ (_.languages);",
                "\t\t\t\tvar grammar = root[inside];",
                "\t\t\t\t/** @type {Grammar} */",
                "\t\t\t\tvar ret = {};",
                "",
                "\t\t\t\tfor (var token in grammar) {",
                "\t\t\t\t\tif (grammar.hasOwnProperty(token)) {",
                "",
                "\t\t\t\t\t\tif (token == before) {",
                "\t\t\t\t\t\t\tfor (var newToken in insert) {",
                "\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {",
                "\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];",
                "\t\t\t\t\t\t\t\t}",
                "\t\t\t\t\t\t\t}",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525",
                "\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {",
                "\t\t\t\t\t\t\tret[token] = grammar[token];",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t}",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar old = root[inside];",
                "\t\t\t\troot[inside] = ret;",
                "",
                "\t\t\t\t// Update references in other language definitions",
                "\t\t\t\t_.languages.DFS(_.languages, function (key, value) {",
                "\t\t\t\t\tif (value === old && key != inside) {",
                "\t\t\t\t\t\tthis[key] = ret;",
                "\t\t\t\t\t}",
                "\t\t\t\t});",
                "",
                "\t\t\t\treturn ret;",
                "\t\t\t},",
                "",
                "\t\t\t// Traverse a language definition with Depth First Search",
                "\t\t\tDFS: function DFS(o, callback, type, visited) {",
                "\t\t\t\tvisited = visited || {};",
                "",
                "\t\t\t\tvar objId = _.util.objId;",
                "",
                "\t\t\t\tfor (var i in o) {",
                "\t\t\t\t\tif (o.hasOwnProperty(i)) {",
                "\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);",
                "",
                "\t\t\t\t\t\tvar property = o[i];",
                "\t\t\t\t\t\tvar propertyType = _.util.type(property);",
                "",
                "\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {",
                "\t\t\t\t\t\t\tvisited[objId(property)] = true;",
                "\t\t\t\t\t\t\tDFS(property, callback, null, visited);",
                "\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {",
                "\t\t\t\t\t\t\tvisited[objId(property)] = true;",
                "\t\t\t\t\t\t\tDFS(property, callback, i, visited);",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t}",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t},",
                "",
                "\t\tplugins: {},",
                "",
                "\t\t/**",
                "\t\t * This is the most high-level function in Prism\u2019s API.",
                "\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on",
                "\t\t * each one of them.",
                "\t\t *",
                "\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.",
                "\t\t *",
                "\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.",
                "\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.",
                "\t\t * @memberof Prism",
                "\t\t * @public",
                "\t\t */",
                "\t\thighlightAll: function (async, callback) {",
                "\t\t\t_.highlightAllUnder(document, async, callback);",
                "\t\t},",
                "",
                "\t\t/**",
                "\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls",
                "\t\t * {@link Prism.highlightElement} on each one of them.",
                "\t\t *",
                "\t\t * The following hooks will be run:",
                "\t\t * 1. `before-highlightall`",
                "\t\t * 2. `before-all-elements-highlight`",
                "\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.",
                "\t\t *",
                "\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.",
                "\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.",
                "\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.",
                "\t\t * @memberof Prism",
                "\t\t * @public",
                "\t\t */",
                "\t\thighlightAllUnder: function (container, async, callback) {",
                "\t\t\tvar env = {",
                "\t\t\t\tcallback: callback,",
                "\t\t\t\tcontainer: container,",
                "\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'",
                "\t\t\t};",
                "",
                "\t\t\t_.hooks.run('before-highlightall', env);",
                "",
                "\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));",
                "",
                "\t\t\t_.hooks.run('before-all-elements-highlight', env);",
                "",
                "\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {",
                "\t\t\t\t_.highlightElement(element, async === true, env.callback);",
                "\t\t\t}",
                "\t\t},",
                "",
                "\t\t/**",
                "\t\t * Highlights the code inside a single element.",
                "\t\t *",
                "\t\t * The following hooks will be run:",
                "\t\t * 1. `before-sanity-check`",
                "\t\t * 2. `before-highlight`",
                "\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`."
            ]
        },
        "3": {
            "class_name": "  (not found) ",
            "file_path": "components/prism-rest.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 205
                }
            ],
            "class_code": [
                "Prism.languages.rest = {",
                "\t'table': [",
                "\t\t{",
                "\t\t\tpattern: /(^[\\t ]*)(?:\\+[=-]+)+\\+(?:\\r?\\n|\\r)(?:\\1[+|].+[+|](?:\\r?\\n|\\r))+\\1(?:\\+[=-]+)+\\+/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /\\||(?:\\+[=-]+)+\\+/",
                "\t\t\t}",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(^[\\t ]*)=+ [ =]*=(?:(?:\\r?\\n|\\r)\\1.+)+(?:\\r?\\n|\\r)\\1=+ [ =]*=(?=(?:\\r?\\n|\\r){2}|\\s*$)/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /[=-]+/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "",
                "\t// Directive-like patterns",
                "",
                "\t'substitution-def': {",
                "\t\tpattern: /(^[\\t ]*\\.\\. )\\|(?:[^|\\s](?:[^|]*[^|\\s])?)\\| [^:]+::/m,",
                "\t\tlookbehind: true,",
                "\t\tinside: {",
                "\t\t\t'substitution': {",
                "\t\t\t\tpattern: /^\\|(?:[^|\\s]|[^|\\s][^|]*[^|\\s])\\|/,",
                "\t\t\t\talias: 'attr-value',",
                "\t\t\t\tinside: {",
                "\t\t\t\t\t'punctuation': /^\\||\\|$/",
                "\t\t\t\t}",
                "\t\t\t},",
                "\t\t\t'directive': {",
                "\t\t\t\tpattern: /( )(?! )[^:]+::/,",
                "\t\t\t\tlookbehind: true,",
                "\t\t\t\talias: 'function',",
                "\t\t\t\tinside: {",
                "\t\t\t\t\t'punctuation': /::$/",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "\t},",
                "\t'link-target': [",
                "\t\t{",
                "\t\t\tpattern: /(^[\\t ]*\\.\\. )\\[[^\\]]+\\]/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\talias: 'string',",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^\\[|\\]$/",
                "\t\t\t}",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(^[\\t ]*\\.\\. )_(?:`[^`]+`|(?:[^:\\\\]|\\\\.)+):/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\talias: 'string',",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^_|:$/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "\t'directive': {",
                "\t\tpattern: /(^[\\t ]*\\.\\. )[^:]+::/m,",
                "\t\tlookbehind: true,",
                "\t\talias: 'function',",
                "\t\tinside: {",
                "\t\t\t'punctuation': /::$/",
                "\t\t}",
                "\t},",
                "\t'comment': {",
                "\t\t// The two alternatives try to prevent highlighting of blank comments",
                "\t\tpattern: /(^[\\t ]*\\.\\.)(?:(?: .+)?(?:(?:\\r?\\n|\\r).+)+| .+)(?=(?:\\r?\\n|\\r){2}|$)/m,",
                "\t\tlookbehind: true",
                "\t},",
                "",
                "\t'title': [",
                "\t\t// Overlined and underlined",
                "\t\t{",
                "\t\t\tpattern: /^(([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2+)(?:\\r?\\n|\\r).+(?:\\r?\\n|\\r)\\1$/m,",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+|[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+$/,",
                "\t\t\t\t'important': /.+/",
                "\t\t\t}",
                "\t\t},",
                "",
                "\t\t// Underlined only",
                "\t\t{",
                "\t\t\tpattern: /(^|(?:\\r?\\n|\\r){2}).+(?:\\r?\\n|\\r)([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2+(?=\\r?\\n|\\r|$)/,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+$/,",
                "\t\t\t\t'important': /.+/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "\t'hr': {",
                "\t\tpattern: /((?:\\r?\\n|\\r){2})([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2{3,}(?=(?:\\r?\\n|\\r){2})/,",
                "\t\tlookbehind: true,",
                "\t\talias: 'punctuation'",
                "\t},",
                "\t'field': {",
                "\t\tpattern: /(^[\\t ]*):[^:\\r\\n]+:(?= )/m,",
                "\t\tlookbehind: true,",
                "\t\talias: 'attr-name'",
                "\t},",
                "\t'command-line-option': {",
                "\t\tpattern: /(^[\\t ]*)(?:[+-][a-z\\d]|(?:--|\\/)[a-z\\d-]+)(?:[ =](?:[a-z][\\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\\d]|(?:--|\\/)[a-z\\d-]+)(?:[ =](?:[a-z][\\w-]*|<[^<>]+>))?)*(?=(?:\\r?\\n|\\r)? {2,}\\S)/im,",
                "\t\tlookbehind: true,",
                "\t\talias: 'symbol'",
                "\t},",
                "\t'literal-block': {",
                "\t\tpattern: /::(?:\\r?\\n|\\r){2}([ \\t]+)(?![ \\t]).+(?:(?:\\r?\\n|\\r)\\1.+)*/,",
                "\t\tinside: {",
                "\t\t\t'literal-block-punctuation': {",
                "\t\t\t\tpattern: /^::/,",
                "\t\t\t\talias: 'punctuation'",
                "\t\t\t}",
                "\t\t}",
                "\t},",
                "\t'quoted-literal-block': {",
                "\t\tpattern: /::(?:\\r?\\n|\\r){2}([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]).*(?:(?:\\r?\\n|\\r)\\1.*)*/,",
                "\t\tinside: {",
                "\t\t\t'literal-block-punctuation': {",
                "\t\t\t\tpattern: /^(?:::|([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\1*)/m,",
                "\t\t\t\talias: 'punctuation'",
                "\t\t\t}",
                "\t\t}",
                "\t},",
                "\t'list-bullet': {",
                "\t\tpattern: /(^[\\t ]*)(?:[*+\\-\u2022\u2023\u2043]|\\(?(?:\\d+|[a-z]|[ivxdclm]+)\\)|(?:\\d+|[a-z]|[ivxdclm]+)\\.)(?= )/im,",
                "\t\tlookbehind: true,",
                "\t\talias: 'punctuation'",
                "\t},",
                "\t'doctest-block': {",
                "\t\tpattern: /(^[\\t ]*)>>> .+(?:(?:\\r?\\n|\\r).+)*/m,",
                "\t\tlookbehind: true,",
                "\t\tinside: {",
                "\t\t\t'punctuation': /^>>>/",
                "\t\t}",
                "\t},",
                "",
                "\t'inline': [",
                "\t\t{",
                "\t\t\tpattern: /(^|[\\s\\-:\\/'\"<(\\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\\*\\*?|``?|\\|)(?!\\s).*?\\S\\2(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$))/m,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'bold': {",
                "\t\t\t\t\tpattern: /(^\\*\\*).+(?=\\*\\*$)/,",
                "\t\t\t\t\tlookbehind: true",
                "\t\t\t\t},",
                "\t\t\t\t'italic': {",
                "\t\t\t\t\tpattern: /(^\\*).+(?=\\*$)/,",
                "\t\t\t\t\tlookbehind: true",
                "\t\t\t\t},",
                "\t\t\t\t'inline-literal': {",
                "\t\t\t\t\tpattern: /(^``).+(?=``$)/,",
                "\t\t\t\t\tlookbehind: true,",
                "\t\t\t\t\talias: 'symbol'",
                "\t\t\t\t},",
                "\t\t\t\t'role': {",
                "\t\t\t\t\tpattern: /^:[^:]+:|:[^:]+:$/,",
                "\t\t\t\t\talias: 'function',",
                "\t\t\t\t\tinside: {",
                "\t\t\t\t\t\t'punctuation': /^:|:$/",
                "\t\t\t\t\t}",
                "\t\t\t\t},",
                "\t\t\t\t'interpreted-text': {",
                "\t\t\t\t\tpattern: /(^`).+(?=`$)/,",
                "\t\t\t\t\tlookbehind: true,",
                "\t\t\t\t\talias: 'attr-value'",
                "\t\t\t\t},",
                "\t\t\t\t'substitution': {",
                "\t\t\t\t\tpattern: /(^\\|).+(?=\\|$)/,",
                "\t\t\t\t\tlookbehind: true,",
                "\t\t\t\t\talias: 'attr-value'",
                "\t\t\t\t},",
                "\t\t\t\t'punctuation': /\\*\\*?|``?|\\|/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "",
                "\t'link': [",
                "\t\t{",
                "\t\t\tpattern: /\\[[^\\[\\]]+\\]_(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$)/,",
                "\t\t\talias: 'string',",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^\\[|\\]_$/",
                "\t\t\t}",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(?:\\b[a-z\\d]+(?:[_.:+][a-z\\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$)/i,",
                "\t\t\talias: 'string',",
                "\t\t\tinside: {",
                "\t\t\t\t'punctuation': /^_?`|`$|`?_?_$/",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "",
                "\t// Line block start,",
                "\t// quote attribution,",
                "\t// explicit markup start,",
                "\t// and anonymous hyperlink target shortcut (__)",
                "\t'punctuation': {",
                "\t\tpattern: /(^[\\t ]*)(?:\\|(?= |$)|(?:---?|\u2014|\\.\\.|__)(?= )|\\.\\.$)/m,",
                "\t\tlookbehind: true",
                "\t}",
                "};"
            ]
        }
    },
    "bug_functions": {}
}