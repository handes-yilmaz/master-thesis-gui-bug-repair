{
    "prism.js": [
        "...",
        "\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.",
        "\t\t\t * @param {Grammar} redef The new tokens to append.",
        "\t\t\t * @returns {Grammar} The new language created.",
        "\t\t\t * @public",
        "\t\t\t * @example",
        "\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {",
        "\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token",
        "\t\t\t *     // at its original position",
        "\t\t\t *     'comment': { ... },",
        "\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended",
        "\t\t\t *     'color': /\\b(?:red|green|blue)\\b/",
        "\t\t\t * });",
        "\t\t\t */",
        "\t\t\textend: function (id, redef) {",
        "\t\t\t\tvar lang = _.util.clone(_.languages[id]);",
        "",
        "\t\t\t\tfor (var key in redef) {",
        "\t\t\t\t\tlang[key] = redef[key];",
        "\t\t\t\t}",
        "",
        "\t\t\t\treturn lang;",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.",
        "\t\t\t *",
        "\t\t\t * ## Usage",
        "\t\t\t *",
        "\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition",
        "\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded",
        "\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the",
        "\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do",
        "\t\t\t * this:",
        "\t\t\t *",
        "\t\t\t * ```js",
        "\t\t\t * Prism.languages.markup.style = {",
        "\t\t\t *     // token",
        "\t\t\t * };",
        "\t\t\t * ```",
        "\t\t\t *",
        "\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens",
        "\t\t\t * before existing tokens. For the CSS example above, you would use it like this:",
        "\t\t\t *",
        "\t\t\t * ```js",
        "\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {",
        "\t\t\t *     'style': {",
        "\t\t\t *         // token",
        "\t\t\t *     }",
        "\t\t\t * });",
        "\t\t\t * ```",
        "\t\t\t *",
        "\t\t\t * ## Special cases",
        "\t\t\t *",
        "\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar",
        "\t\t\t * will be ignored.",
        "\t\t\t *",
        "\t\t\t * This behavior can be used to insert tokens after `before`:",
        "\t\t\t *",
        "\t\t\t * ```js",
        "\t\t\t * Prism.languages.insertBefore('markup', 'comment', {",
        "\t\t\t *     'comment': Prism.languages.markup.comment,",
        "\t\t\t *     // tokens after 'comment'",
        "\t\t\t * });",
        "\t\t\t * ```",
        "\t\t\t *",
        "\t\t\t * ## Limitations",
        "\t\t\t *",
        "\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object",
        "\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave",
        "\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily",
        "\t\t\t * deleting properties which is necessary to insert at arbitrary positions.",
        "\t\t\t *",
        "\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.",
        "\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This",
        "\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.",
        "\t\t\t *",
        "\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if",
        "\t\t\t * you hold the target object in a variable, then the value of the variable will not change.",
        "\t\t\t *",
        "\t\t\t * ```js",
        "\t\t\t * var oldMarkup = Prism.languages.markup;",
        "\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });",
        "\t\t\t *",
        "\t\t\t * assert(oldMarkup !== Prism.languages.markup);",
        "\t\t\t * assert(newMarkup === Prism.languages.markup);",
        "\t\t\t * ```",
        "\t\t\t *",
        "\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the",
        "\t\t\t * object to be modified.",
        "\t\t\t * @param {string} before The key to insert before.",
        "\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.",
        "\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the",
        "\t\t\t * object to be modified.",
        "\t\t\t *",
        "\t\t\t * Defaults to `Prism.languages`.",
        "\t\t\t * @returns {Grammar} The new grammar object.",
        "\t\t\t * @public",
        "\t\t\t */",
        "\t\t\tinsertBefore: function (inside, before, insert, root) {",
        "\t\t\t\troot = root || /** @type {any} */ (_.languages);",
        "\t\t\t\tvar grammar = root[inside];",
        "\t\t\t\t/** @type {Grammar} */",
        "\t\t\t\tvar ret = {};",
        "",
        "\t\t\t\tfor (var token in grammar) {",
        "\t\t\t\t\tif (grammar.hasOwnProperty(token)) {",
        "",
        "\t\t\t\t\t\tif (token == before) {",
        "\t\t\t\t\t\t\tfor (var newToken in insert) {",
        "\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {",
        "\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];",
        "\t\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525",
        "\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {",
        "\t\t\t\t\t\t\tret[token] = grammar[token];",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "",
        "\t\t\t\tvar old = root[inside];",
        "\t\t\t\troot[inside] = ret;",
        "",
        "\t\t\t\t// Update references in other language definitions",
        "\t\t\t\t_.languages.DFS(_.languages, function (key, value) {",
        "\t\t\t\t\tif (value === old && key != inside) {",
        "\t\t\t\t\t\tthis[key] = ret;",
        "\t\t\t\t\t}",
        "\t\t\t\t});",
        "",
        "\t\t\t\treturn ret;",
        "\t\t\t},",
        "",
        "\t\t\t// Traverse a language definition with Depth First Search",
        "\t\t\tDFS: function DFS(o, callback, type, visited) {",
        "\t\t\t\tvisited = visited || {};",
        "",
        "\t\t\t\tvar objId = _.util.objId;",
        "",
        "\t\t\t\tfor (var i in o) {",
        "\t\t\t\t\tif (o.hasOwnProperty(i)) {",
        "\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);",
        "",
        "\t\t\t\t\t\tvar property = o[i];",
        "\t\t\t\t\t\tvar propertyType = _.util.type(property);",
        "",
        "\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {",
        "\t\t\t\t\t\t\tvisited[objId(property)] = true;",
        "\t\t\t\t\t\t\tDFS(property, callback, null, visited);",
        "\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {",
        "\t\t\t\t\t\t\tvisited[objId(property)] = true;",
        "\t\t\t\t\t\t\tDFS(property, callback, i, visited);",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\tplugins: {},",
        "",
        "\t\t/**",
        "\t\t * This is the most high-level function in Prism\u2019s API.",
        "\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on",
        "\t\t * each one of them.",
        "\t\t *",
        "\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.",
        "\t\t *",
        "\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.",
        "\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\thighlightAll: function (async, callback) {",
        "\t\t\t_.highlightAllUnder(document, async, callback);",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls",
        "\t\t * {@link Prism.highlightElement} on each one of them.",
        "\t\t *",
        "\t\t * The following hooks will be run:",
        "\t\t * 1. `before-highlightall`",
        "\t\t * 2. `before-all-elements-highlight`",
        "\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.",
        "\t\t *",
        "\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.",
        "\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.",
        "\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\thighlightAllUnder: function (container, async, callback) {",
        "\t\t\tvar env = {",
        "\t\t\t\tcallback: callback,",
        "\t\t\t\tcontainer: container,",
        "\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'",
        "\t\t\t};",
        "",
        "\t\t\t_.hooks.run('before-highlightall', env);",
        "",
        "\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));",
        "",
        "\t\t\t_.hooks.run('before-all-elements-highlight', env);",
        "",
        "\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {",
        "\t\t\t\t_.highlightElement(element, async === true, env.callback);",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * Highlights the code inside a single element.",
        "\t\t *",
        "\t\t * The following hooks will be run:",
        "\t\t * 1. `before-sanity-check`",
        "\t\t * 2. `before-highlight`",
        "\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.",
        "\t\t * 4. `before-insert`",
        "\t\t * 5. `after-highlight`",
        "\t\t * 6. `complete`",
        "\t\t *",
        "\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for",
        "\t\t * the element's language.",
        "\t\t *",
        "\t\t * @param {Element} element The element containing the code.",
        "\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.",
        "\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers",
        "\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is",
        "\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).",
        "\t\t *",
        "\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for",
        "\t\t * asynchronous highlighting to work. You can build your own bundle on the",
        "\t\t * [Download page](https://prismjs.com/download.html).",
        "\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.",
        "\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\thighlightElement: function (element, async, callback) {",
        "\t\t\t// Find language",
        "\t\t\tvar language = _.util.getLanguage(element);",
        "\t\t\tvar grammar = _.languages[language];",
        "",
        "\t\t\t// Set language on the element, if not present",
        "\t\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;",
        "",
        "\t\t\t// Set language on the parent, for styling",
        "\t\t\tvar parent = element.parentElement;",
        "\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {",
        "\t\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;",
        "\t\t\t}",
        "",
        "\t\t\tvar code = element.textContent;",
        "",
        "\t\t\tvar env = {",
        "\t\t\t\telement: element,",
        "\t\t\t\tlanguage: language,",
        "\t\t\t\tgrammar: grammar,",
        "\t\t\t\tcode: code",
        "\t\t\t};",
        "",
        "\t\t\tfunction insertHighlightedCode(highlightedCode) {",
        "\t\t\t\tenv.highlightedCode = highlightedCode;",
        "",
        "\t\t\t\t_.hooks.run('before-insert', env);",
        "",
        "\t\t\t\tenv.element.innerHTML = env.highlightedCode;",
        "",
        "\t\t\t\t_.hooks.run('after-highlight', env);",
        "\t\t\t\t_.hooks.run('complete', env);",
        "\t\t\t\tcallback && callback.call(env.element);",
        "\t\t\t}",
        "",
        "\t\t\t_.hooks.run('before-sanity-check', env);",
        "",
        "\t\t\t// plugins may change/add the parent/element",
        "\t\t\tparent = env.element.parentElement;",
        "\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {",
        "\t\t\t\tparent.setAttribute('tabindex', '0');",
        "\t\t\t}",
        "",
        "\t\t\tif (!env.code) {",
        "\t\t\t\t_.hooks.run('complete', env);",
        "\t\t\t\tcallback && callback.call(env.element);",
        "\t\t\t\treturn;",
        "\t\t\t}",
        "",
        "\t\t\t_.hooks.run('before-highlight', env);",
        "",
        "\t\t\tif (!env.grammar) {",
        "\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));",
        "\t\t\t\treturn;",
        "\t\t\t}",
        "",
        "\t\t\tif (async && _self.Worker) {",
        "\t\t\t\tvar worker = new Worker(_.filename);",
        "",
        "\t\t\t\tworker.onmessage = function (evt) {",
        "\t\t\t\t\tinsertHighlightedCode(evt.data);",
        "\t\t\t\t};",
        "",
        "\t\t\t\tworker.postMessage(JSON.stringify({",
        "\t\t\t\t\tlanguage: env.language,",
        "\t\t\t\t\tcode: env.code,",
        "\t\t\t\t\timmediateClose: true",
        "\t\t\t\t}));",
        "\t\t\t} else {",
        "\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * Low-level function, only use if you know what you\u2019re doing. It accepts a string of text as input",
        "\t\t * and the language definitions to use, and returns a string with the HTML produced.",
        "\t\t *",
        "\t\t * The following hooks will be run:",
        "\t\t * 1. `before-tokenize`",
        "\t\t * 2. `after-tokenize`",
        "\t\t * 3. `wrap`: On each {@link Token}.",
        "\t\t *",
        "\t\t * @param {string} text A string with the code to be highlighted.",
        "\t\t * @param {Grammar} grammar An object containing the tokens to use.",
        "\t\t *",
        "\t\t * Usually a language definition like `Prism.languages.markup`.",
        "\t\t * @param {string} language The name of the language definition passed to `grammar`.",
        "\t\t * @returns {string} The highlighted HTML.",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t * @example",
        "\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');",
        "\t\t */",
        "\t\thighlight: function (text, grammar, language) {",
        "\t\t\tvar env = {",
        "\t\t\t\tcode: text,",
        "\t\t\t\tgrammar: grammar,",
        "\t\t\t\tlanguage: language",
        "\t\t\t};",
        "\t\t\t_.hooks.run('before-tokenize', env);",
        "\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);",
        "\t\t\t_.hooks.run('after-tokenize', env);",
        "\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input",
        "\t\t * and the language definitions to use, and returns an array with the tokenized code.",
        "\t\t *",
        "\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.",
        "\t\t *",
        "\t\t * This method could be useful in other contexts as well, as a very crude parser.",
        "\t\t *",
        "\t\t * @param {string} text A string with the code to be highlighted.",
        "\t\t * @param {Grammar} grammar An object containing the tokens to use.",
        "\t\t *",
        "\t\t * Usually a language definition like `Prism.languages.markup`.",
        "\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t * @example",
        "\t\t * let code = `var foo = 0;`;",
        "\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);",
        "\t\t * tokens.forEach(token => {",
        "\t\t *     if (token instanceof Prism.Token && token.type === 'number') {",
        "\t\t *         console.log(`Found numeric literal: ${token.content}`);",
        "\t\t *     }",
        "\t\t * });",
        "\t\t */",
        "\t\ttokenize: function (text, grammar) {",
        "\t\t\tvar rest = grammar.rest;",
        "\t\t\tif (rest) {",
        "\t\t\t\tfor (var token in rest) {",
        "\t\t\t\t\tgrammar[token] = rest[token];",
        "\t\t\t\t}",
        "",
        "\t\t\t\tdelete grammar.rest;",
        "\t\t\t}",
        "",
        "\t\t\tvar tokenList = new LinkedList();",
        "\t\t\taddAfter(tokenList, tokenList.head, text);",
        "",
        "\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);",
        "",
        "\t\t\treturn toArray(tokenList);",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * @namespace",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\thooks: {",
        "\t\t\tall: {},",
        "",
        "\t\t\t/**",
        "\t\t\t * Adds the given callback to the list of callbacks for the given hook.",
        "\t\t\t *",
        "\t\t\t * The callback will be invoked when the hook it is registered for is run.",
        "\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.",
        "\t\t\t *",
        "\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.",
        "\t\t\t *",
        "\t\t\t * @param {string} name The name of the hook.",
        "\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.",
        "\t\t\t * @public",
        "\t\t\t */",
        "\t\t\tadd: function (name, callback) {",
        "\t\t\t\tvar hooks = _.hooks.all;",
        "",
        "\t\t\t\thooks[name] = hooks[name] || [];",
        "",
        "\t\t\t\thooks[name].push(callback);",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.",
        "\t\t\t *",
        "\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.",
        "\t\t\t *",
        "\t\t\t * @param {string} name The name of the hook.",
        "\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.",
        "\t\t\t * @public",
        "\t\t\t */",
        "\t\t\trun: function (name, env) {",
        "\t\t\t\tvar callbacks = _.hooks.all[name];",
        "",
        "\t\t\t\tif (!callbacks || !callbacks.length) {",
        "\t\t\t\t\treturn;",
        "\t\t\t\t}",
        "",
        "\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {",
        "\t\t\t\t\tcallback(env);",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\tToken: Token",
        "\t};",
        "\t_self.Prism = _;",
        "",
        "",
        "\t// Typescript note:",
        "\t// The following can be used to import the Token type in JSDoc:",
        "\t//",
        "\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token",
        "",
        "\t/**",
        "\t * Creates a new token.",
        "\t *",
        "\t * @param {string} type See {@link Token#type type}",
        "\t * @param {string | TokenStream} content See {@link Token#content content}",
        "\t * @param {string|string[]} [alias] The alias(es) of the token.",
        "\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.",
        "\t * @class",
        "\t * @global",
        "\t * @public",
        "\t */",
        "\tfunction Token(type, content, alias, matchedStr) {",
        "\t\t/**",
        "\t\t * The type of the token.",
        "\t\t *",
        "\t\t * This is usually the key of a pattern in a {@link Grammar}.",
        "\t\t *",
        "\t\t * @type {string}",
        "\t\t * @see GrammarToken",
        "\t\t * @public",
        "\t\t */",
        "\t\tthis.type = type;",
        "\t\t/**",
        "\t\t * The strings or tokens contained by this token.",
        "\t\t *",
        "\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.",
        "\t\t *",
        "\t\t * @type {string | TokenStream}",
        "\t\t * @public",
        "\t\t */",
        "\t\tthis.content = content;",
        "\t\t/**",
        "\t\t * The alias(es) of the token.",
        "\t\t *",
        "\t\t * @type {string|string[]}",
        "\t\t * @see GrammarToken",
        "\t\t * @public",
        "\t\t */",
        "\t\tthis.alias = alias;",
        "\t\t// Copy of the full string this token was created from",
        "\t\tthis.length = (matchedStr || '').length | 0;",
        "\t}",
        "",
        "\t/**",
        "\t * A token stream is an array of strings and {@link Token Token} objects.",
        "\t *",
        "\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process",
        "\t * them.",
        "\t *",
        "\t * 1. No adjacent strings.",
        "\t * 2. No empty strings.",
        "\t *",
        "\t *    The only exception here is the token stream that only contains the empty string and nothing else.",
        "\t *",
        "\t * @typedef {Array<string | Token>} TokenStream",
        "..."
    ],
    "components/index.js": [
        "const components = require('../components.js');",
        "const getLoader = require('../dependencies');",
        "",
        "",
        "/**",
        " * The set of all languages which have been loaded using the below function.",
        " *",
        " * @type {Set<string>}",
        " */",
        "const loadedLanguages = new Set();",
        "",
        "/**",
        " * Loads the given languages and adds them to the current Prism instance.",
        " *",
        " * If no languages are provided, __all__ Prism languages will be loaded.",
        " *",
        " * @param {string|string[]} [languages]",
        " * @returns {void}",
        " */",
        "function loadLanguages(languages) {",
        "\tif (languages === undefined) {",
        "\t\tlanguages = Object.keys(components.languages).filter(l => l != 'meta');",
        "\t} else if (!Array.isArray(languages)) {",
        "\t\tlanguages = [languages];",
        "\t}",
        "",
        "\t// the user might have loaded languages via some other way or used `prism.js` which already includes some",
        "\t// we don't need to validate the ids because `getLoader` will ignore invalid ones",
        "\tconst loaded = [...loadedLanguages, ...Object.keys(Prism.languages)];",
        "",
        "\tgetLoader(components, languages, loaded).load(lang => {",
        "\t\tif (!(lang in components.languages)) {",
        "\t\t\tif (!loadLanguages.silent) {",
        "\t\t\t\tconsole.warn('Language does not exist: ' + lang);",
        "\t\t\t}",
        "\t\t\treturn;",
        "\t\t}",
        "",
        "\t\tconst pathToLanguage = './prism-' + lang;",
        "",
        "\t\t// remove from require cache and from Prism",
        "\t\tdelete require.cache[require.resolve(pathToLanguage)];",
        "\t\tdelete Prism.languages[lang];",
        "",
        "\t\trequire(pathToLanguage);",
        "",
        "\t\tloadedLanguages.add(lang);",
        "\t});",
        "}",
        "",
        "/**",
        " * Set this to `true` to prevent all warning messages `loadLanguages` logs.",
        " */",
        "loadLanguages.silent = false;",
        "",
        "module.exports = loadLanguages;"
    ]
}