{
    "components/prism-core.js": [
        "var _self = (typeof window !== 'undefined')",
        "\t? window   // if in browser",
        "\t: (",
        "\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)",
        "\t\t? self // if in worker",
        "\t\t: {}   // if in node js",
        "\t);",
        "",
        "/**",
        " * Prism: Lightweight, robust, elegant syntax highlighting",
        " * MIT license http://www.opensource.org/licenses/mit-license.php/",
        " * @author Lea Verou http://lea.verou.me",
        " */",
        "",
        "var Prism = (function(){",
        "",
        "// Private helper vars",
        "var lang = /\\blang(?:uage)?-([\\w-]+)\\b/i;",
        "var uniqueId = 0;",
        "",
        "var _ = _self.Prism = {",
        "\tmanual: _self.Prism && _self.Prism.manual,",
        "\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,",
        "\tutil: {",
        "\t\tencode: function (tokens) {",
        "\t\t\tif (tokens instanceof Token) {",
        "\t\t\t\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);",
        "\t\t\t} else if (_.util.type(tokens) === 'Array') {",
        "\t\t\t\treturn tokens.map(_.util.encode);",
        "\t\t\t} else {",
        "\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\ttype: function (o) {",
        "\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);",
        "\t\t},",
        "",
        "\t\tobjId: function (obj) {",
        "\t\t\tif (!obj['__id']) {",
        "\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });",
        "\t\t\t}",
        "\t\t\treturn obj['__id'];",
        "\t\t},",
        "",
        "\t\t// Deep clone a language definition (e.g. to extend it)",
        "\t\tclone: function (o, visited) {",
        "\t\t\tvar type = _.util.type(o);",
        "\t\t\tvisited = visited || {};",
        "",
        "\t\t\tswitch (type) {",
        "\t\t\t\tcase 'Object':",
        "\t\t\t\t\tif (visited[_.util.objId(o)]) {",
        "\t\t\t\t\t\treturn visited[_.util.objId(o)];",
        "\t\t\t\t\t}",
        "\t\t\t\t\tvar clone = {};",
        "\t\t\t\t\tvisited[_.util.objId(o)] = clone;",
        "",
        "\t\t\t\t\tfor (var key in o) {",
        "\t\t\t\t\t\tif (o.hasOwnProperty(key)) {",
        "\t\t\t\t\t\t\tclone[key] = _.util.clone(o[key], visited);",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\treturn clone;",
        "",
        "\t\t\t\tcase 'Array':",
        "\t\t\t\t\tif (visited[_.util.objId(o)]) {",
        "\t\t\t\t\t\treturn visited[_.util.objId(o)];",
        "\t\t\t\t\t}",
        "\t\t\t\t\tvar clone = [];",
        "\t\t\t\t\tvisited[_.util.objId(o)] = clone;",
        "",
        "\t\t\t\t\to.forEach(function (v, i) {",
        "\t\t\t\t\t\tclone[i] = _.util.clone(v, visited);",
        "\t\t\t\t\t});",
        "",
        "\t\t\t\t\treturn clone;",
        "\t\t\t}",
        "",
        "\t\t\treturn o;",
        "\t\t}",
        "\t},",
        "",
        "\tlanguages: {",
        "\t\textend: function (id, redef) {",
        "\t\t\tvar lang = _.util.clone(_.languages[id]);",
        "",
        "\t\t\tfor (var key in redef) {",
        "\t\t\t\tlang[key] = redef[key];",
        "\t\t\t}",
        "",
        "\t\t\treturn lang;",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * Insert a token before another token in a language literal",
        "\t\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),",
        "\t\t * we cannot just provide an object, we need anobject and a key.",
        "\t\t * @param inside The key (or language id) of the parent",
        "\t\t * @param before The key to insert before. If not provided, the function appends instead.",
        "\t\t * @param insert Object with the key/value pairs to insert",
        "\t\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.",
        "\t\t */",
        "\t\tinsertBefore: function (inside, before, insert, root) {",
        "\t\t\troot = root || _.languages;",
        "\t\t\tvar grammar = root[inside];",
        "",
        "\t\t\tif (arguments.length == 2) {",
        "\t\t\t\tinsert = arguments[1];",
        "",
        "\t\t\t\tfor (var newToken in insert) {",
        "\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {",
        "\t\t\t\t\t\tgrammar[newToken] = insert[newToken];",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "",
        "\t\t\t\treturn grammar;",
        "\t\t\t}",
        "",
        "\t\t\tvar ret = {};",
        "",
        "\t\t\tfor (var token in grammar) {",
        "",
        "\t\t\t\tif (grammar.hasOwnProperty(token)) {",
        "",
        "\t\t\t\t\tif (token == before) {",
        "",
        "\t\t\t\t\t\tfor (var newToken in insert) {",
        "",
        "\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {",
        "\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];",
        "\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tret[token] = grammar[token];",
        "\t\t\t\t}",
        "\t\t\t}",
        "",
        "\t\t\tvar old = root[inside];",
        "\t\t\troot[inside] = ret;",
        "",
        "\t\t\t// Update references in other language definitions",
        "\t\t\t_.languages.DFS(_.languages, function(key, value) {",
        "\t\t\t\tif (value === old && key != inside) {",
        "\t\t\t\t\tthis[key] = ret;",
        "\t\t\t\t}",
        "\t\t\t});",
        "",
        "\t\t\treturn ret;",
        "\t\t},",
        "",
        "\t\t// Traverse a language definition with Depth First Search",
        "\t\tDFS: function(o, callback, type, visited) {",
        "\t\t\tvisited = visited || {};",
        "\t\t\tfor (var i in o) {",
        "\t\t\t\tif (o.hasOwnProperty(i)) {",
        "\t\t\t\t\tcallback.call(o, i, o[i], type || i);",
        "",
        "\t\t\t\t\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {",
        "\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;",
        "\t\t\t\t\t\t_.languages.DFS(o[i], callback, null, visited);",
        "\t\t\t\t\t}",
        "\t\t\t\t\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {",
        "\t\t\t\t\t\tvisited[_.util.objId(o[i])] = true;",
        "\t\t\t\t\t\t_.languages.DFS(o[i], callback, i, visited);",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t},",
        "\tplugins: {},",
        "",
        "\thighlightAll: function(async, callback) {",
        "\t\t_.highlightAllUnder(document, async, callback);",
        "\t},",
        "",
        "\thighlightAllUnder: function(container, async, callback) {",
        "\t\tvar env = {",
        "\t\t\tcallback: callback,",
        "\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'",
        "\t\t};",
        "",
        "\t\t_.hooks.run(\"before-highlightall\", env);",
        "",
        "\t\tvar elements = env.elements || container.querySelectorAll(env.selector);",
        "",
        "\t\tfor (var i=0, element; element = elements[i++];) {",
        "\t\t\t_.highlightElement(element, async === true, env.callback);",
        "\t\t}",
        "\t},",
        "",
        "\thighlightElement: function(element, async, callback) {",
        "\t\t// Find language",
        "\t\tvar language, grammar, parent = element;",
        "",
        "\t\twhile (parent && !lang.test(parent.className)) {",
        "\t\t\tparent = parent.parentNode;",
        "\t\t}",
        "",
        "\t\tif (parent) {",
        "\t\t\tlanguage = (parent.className.match(lang) || [,''])[1].toLowerCase();",
        "\t\t\tgrammar = _.languages[language];",
        "\t\t}",
        "",
        "\t\t// Set language on the element, if not present",
        "\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;",
        "",
        "\t\tif (element.parentNode) {",
        "\t\t\t// Set language on the parent, for styling",
        "\t\t\tparent = element.parentNode;",
        "",
        "\t\t\tif (/pre/i.test(parent.nodeName)) {",
        "\t\t\t\tparent.className = parent.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;",
        "\t\t\t}",
        "\t\t}",
        "",
        "\t\tvar code = element.textContent;",
        "",
        "\t\tvar env = {",
        "\t\t\telement: element,",
        "\t\t\tlanguage: language,",
        "\t\t\tgrammar: grammar,",
        "\t\t\tcode: code",
        "\t\t};",
        "",
        "\t\t_.hooks.run('before-sanity-check', env);",
        "",
        "\t\tif (!env.code || !env.grammar) {",
        "\t\t\tif (env.code) {",
        "\t\t\t\t_.hooks.run('before-highlight', env);",
        "\t\t\t\tenv.element.textContent = env.code;",
        "\t\t\t\t_.hooks.run('after-highlight', env);",
        "\t\t\t}",
        "\t\t\t_.hooks.run('complete', env);",
        "\t\t\treturn;",
        "\t\t}",
        "",
        "\t\t_.hooks.run('before-highlight', env);",
        "",
        "\t\tif (async && _self.Worker) {",
        "\t\t\tvar worker = new Worker(_.filename);",
        "",
        "\t\t\tworker.onmessage = function(evt) {",
        "\t\t\t\tenv.highlightedCode = evt.data;",
        "",
        "\t\t\t\t_.hooks.run('before-insert', env);",
        "",
        "\t\t\t\tenv.element.innerHTML = env.highlightedCode;",
        "",
        "\t\t\t\t_.hooks.run('after-highlight', env);",
        "\t\t\t\t_.hooks.run('complete', env);",
        "\t\t\t\tcallback && callback.call(env.element);",
        "\t\t\t};",
        "",
        "\t\t\tworker.postMessage(JSON.stringify({",
        "\t\t\t\tlanguage: env.language,",
        "\t\t\t\tcode: env.code,",
        "\t\t\t\timmediateClose: true",
        "\t\t\t}));",
        "\t\t}",
        "\t\telse {",
        "\t\t\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);",
        "",
        "\t\t\t_.hooks.run('before-insert', env);",
        "",
        "\t\t\tenv.element.innerHTML = env.highlightedCode;",
        "",
        "\t\t\t_.hooks.run('after-highlight', env);",
        "",
        "\t\t\t_.hooks.run('complete', env);",
        "",
        "\t\t\tcallback && callback.call(element);",
        "\t\t}",
        "\t},",
        "",
        "\thighlight: function (text, grammar, language) {",
        "\t\tvar env = {",
        "\t\t\tcode: text,",
        "\t\t\tgrammar: grammar,",
        "\t\t\tlanguage: language",
        "\t\t};",
        "\t\t_.hooks.run('before-tokenize', env);",
        "\t\tenv.tokens = _.tokenize(env.code, env.grammar);",
        "\t\t_.hooks.run('after-tokenize', env);",
        "\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);",
        "\t},",
        "",
        "\tmatchGrammar: function (text, strarr, grammar, index, startPos, oneshot, target) {",
        "\t\tvar Token = _.Token;",
        "",
        "\t\tfor (var token in grammar) {",
        "\t\t\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "",
        "\t\t\tif (token == target) {",
        "\t\t\t\treturn;",
        "\t\t\t}",
        "",
        "\t\t\tvar patterns = grammar[token];",
        "\t\t\tpatterns = (_.util.type(patterns) === \"Array\") ? patterns : [patterns];",
        "",
        "\t\t\tfor (var j = 0; j < patterns.length; ++j) {",
        "\t\t\t\tvar pattern = patterns[j],",
        "\t\t\t\t\tinside = pattern.inside,",
        "\t\t\t\t\tlookbehind = !!pattern.lookbehind,",
        "\t\t\t\t\tgreedy = !!pattern.greedy,",
        "\t\t\t\t\tlookbehindLength = 0,",
        "\t\t\t\t\talias = pattern.alias;",
        "",
        "\t\t\t\tif (greedy && !pattern.pattern.global) {",
        "\t\t\t\t\t// Without the global flag, lastIndex won't work",
        "\t\t\t\t\tvar flags = pattern.pattern.toString().match(/[imuy]*$/)[0];",
        "\t\t\t\t\tpattern.pattern = RegExp(pattern.pattern.source, flags + \"g\");",
        "\t\t\t\t}",
        "",
        "\t\t\t\tpattern = pattern.pattern || pattern;",
        "",
        "\t\t\t\t// Don\u2019t cache length as it changes during the loop",
        "\t\t\t\tfor (var i = index, pos = startPos; i < strarr.length; pos += strarr[i].length, ++i) {",
        "",
        "\t\t\t\t\tvar str = strarr[i];",
        "",
        "\t\t\t\t\tif (strarr.length > text.length) {",
        "\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!",
        "\t\t\t\t\t\treturn;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tif (str instanceof Token) {",
        "\t\t\t\t\t\tcontinue;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tif (greedy && i != strarr.length - 1) {",
        "\t\t\t\t\t\tpattern.lastIndex = pos;",
        "\t\t\t\t\t\tvar match = pattern.exec(text);",
        "\t\t\t\t\t\tif (!match) {",
        "\t\t\t\t\t\t\tbreak;",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\tvar from = match.index + (lookbehind ? match[1].length : 0),",
        "\t\t\t\t\t\t    to = match.index + match[0].length,",
        "\t\t\t\t\t\t    k = i,",
        "\t\t\t\t\t\t    p = pos;",
        "",
        "\t\t\t\t\t\tfor (var len = strarr.length; k < len && (p < to || (!strarr[k].type && !strarr[k - 1].greedy)); ++k) {",
        "\t\t\t\t\t\t\tp += strarr[k].length;",
        "\t\t\t\t\t\t\t// Move the index i to the element in strarr that is closest to from",
        "\t\t\t\t\t\t\tif (from >= p) {",
        "\t\t\t\t\t\t\t\t++i;",
        "\t\t\t\t\t\t\t\tpos = p;",
        "\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\t// If strarr[i] is a Token, then the match starts inside another Token, which is invalid",
        "\t\t\t\t\t\tif (strarr[i] instanceof Token) {",
        "\t\t\t\t\t\t\tcontinue;",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\t// Number of tokens to delete and replace with the new match",
        "\t\t\t\t\t\tdelNum = k - i;",
        "\t\t\t\t\t\tstr = text.slice(pos, p);",
        "\t\t\t\t\t\tmatch.index -= pos;",
        "\t\t\t\t\t} else {",
        "\t\t\t\t\t\tpattern.lastIndex = 0;",
        "",
        "\t\t\t\t\t\tvar match = pattern.exec(str),",
        "\t\t\t\t\t\t\tdelNum = 1;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tif (!match) {",
        "\t\t\t\t\t\tif (oneshot) {",
        "\t\t\t\t\t\t\tbreak;",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\tcontinue;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tif(lookbehind) {",
        "\t\t\t\t\t\tlookbehindLength = match[1] ? match[1].length : 0;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tvar from = match.index + lookbehindLength,",
        "\t\t\t\t\t    match = match[0].slice(lookbehindLength),",
        "\t\t\t\t\t    to = from + match.length,",
        "\t\t\t\t\t    before = str.slice(0, from),",
        "\t\t\t\t\t    after = str.slice(to);",
        "",
        "\t\t\t\t\tvar args = [i, delNum];",
        "",
        "\t\t\t\t\tif (before) {",
        "\t\t\t\t\t\t++i;",
        "\t\t\t\t\t\tpos += before.length;",
        "\t\t\t\t\t\targs.push(before);",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);",
        "",
        "\t\t\t\t\targs.push(wrapped);",
        "",
        "\t\t\t\t\tif (after) {",
        "\t\t\t\t\t\targs.push(after);",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tArray.prototype.splice.apply(strarr, args);",
        "",
        "\t\t\t\t\tif (delNum != 1)",
        "\t\t\t\t\t\t_.matchGrammar(text, strarr, grammar, i, pos, true, token);",
        "",
        "\t\t\t\t\tif (oneshot)",
        "\t\t\t\t\t\tbreak;",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t},",
        "",
        "\ttokenize: function(text, grammar, language) {",
        "\t\tvar strarr = [text];",
        "",
        "\t\tvar rest = grammar.rest;",
        "",
        "\t\tif (rest) {",
        "\t\t\tfor (var token in rest) {",
        "\t\t\t\tgrammar[token] = rest[token];",
        "\t\t\t}",
        "",
        "\t\t\tdelete grammar.rest;",
        "\t\t}",
        "",
        "\t\t_.matchGrammar(text, strarr, grammar, 0, 0, false);",
        "",
        "\t\treturn strarr;",
        "\t},",
        "",
        "\thooks: {",
        "\t\tall: {},",
        "",
        "\t\tadd: function (name, callback) {",
        "\t\t\tvar hooks = _.hooks.all;",
        "",
        "\t\t\thooks[name] = hooks[name] || [];",
        "",
        "\t\t\thooks[name].push(callback);",
        "\t\t},",
        "",
        "\t\trun: function (name, env) {",
        "\t\t\tvar callbacks = _.hooks.all[name];",
        "",
        "\t\t\tif (!callbacks || !callbacks.length) {",
        "\t\t\t\treturn;",
        "\t\t\t}",
        "",
        "\t\t\tfor (var i=0, callback; callback = callbacks[i++];) {",
        "\t\t\t\tcallback(env);",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "};",
        "",
        "var Token = _.Token = function(type, content, alias, matchedStr, greedy) {",
        "\tthis.type = type;",
        "\tthis.content = content;",
        "\tthis.alias = alias;",
        "\t// Copy of the full string this token was created from",
        "\tthis.length = (matchedStr || \"\").length|0;",
        "\tthis.greedy = !!greedy;",
        "};",
        "",
        "Token.stringify = function(o, language, parent) {",
        "\tif (typeof o == 'string') {",
        "\t\treturn o;",
        "\t}",
        "",
        "\tif (_.util.type(o) === 'Array') {",
        "\t\treturn o.map(function(element) {",
        "\t\t\treturn Token.stringify(element, language, o);",
        "\t\t}).join('');",
        "\t}",
        "",
        "\tvar env = {",
        "\t\ttype: o.type,",
        "\t\tcontent: Token.stringify(o.content, language, parent),",
        "\t\ttag: 'span',",
        "\t\tclasses: ['token', o.type],",
        "\t\tattributes: {},",
        "\t\tlanguage: language,",
        "\t\tparent: parent",
        "\t};",
        "",
        "\tif (o.alias) {",
        "\t\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];",
        "\t\tArray.prototype.push.apply(env.classes, aliases);",
        "\t}",
        "",
        "\t_.hooks.run('wrap', env);",
        "",
        "\tvar attributes = Object.keys(env.attributes).map(function(name) {",
        "\t\treturn name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';",
        "\t}).join(' ');",
        "",
        "..."
    ]
}