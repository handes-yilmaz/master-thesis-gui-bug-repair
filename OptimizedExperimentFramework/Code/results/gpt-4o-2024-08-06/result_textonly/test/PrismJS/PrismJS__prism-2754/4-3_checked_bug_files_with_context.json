{
    "components/prism-jsx.js": [
        "(function(Prism) {",
        "",
        "var javascript = Prism.util.clone(Prism.languages.javascript);",
        "",
        "Prism.languages.jsx = Prism.languages.extend('markup', javascript);",
        "Prism.languages.jsx.tag.pattern = RegExp(",
        "\t/<\\/?(?:[\\w.:-]+(?:<SP>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[^]|[^\\\\\"])*\"|'(?:\\\\[^]|[^\\\\'])*'|[^\\s{'\"/>=]+|\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\}))?|\\{<SP>*\\.{3}<SP>*[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*<SP>*\\}))*<SP>*\\/?)?>/.source",
        "\t\t.replace(/<SP>/g, function () { return /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source }),",
        "\t'i'",
        ");",
        "",
        "Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i;",
        "Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:\"(?:\\\\[^]|[^\\\\\"])*\"|'(?:\\\\[^]|[^\\\\'])*'|[^\\s'\">]+)/i;",
        "Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;",
        "Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];",
        "",
        "Prism.languages.insertBefore('inside', 'attr-name', {",
        "\t'spread': {",
        "\t\tpattern: /\\{\\s*\\.{3}\\s*[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\s*\\}/,",
        "\t\tinside: {",
        "\t\t\t'punctuation': /\\.{3}|[{}.]/,",
        "\t\t\t'attr-value': /\\w+/",
        "\t\t}",
        "\t}",
        "}, Prism.languages.jsx.tag);",
        "",
        "Prism.languages.insertBefore('inside', 'attr-value',{",
        "\t'script': {",
        "\t\t// Allow for two levels of nesting",
        "\t\tpattern: /=(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])+\\})/i,",
        "\t\tinside: {",
        "\t\t\t'script-punctuation': {",
        "\t\t\t\tpattern: /^=(?={)/,",
        "\t\t\t\talias: 'punctuation'",
        "\t\t\t},",
        "\t\t\trest: Prism.languages.jsx",
        "\t\t},",
        "\t\t'alias': 'language-javascript'",
        "\t}",
        "}, Prism.languages.jsx.tag);",
        "",
        "// The following will handle plain text inside tags",
        "var stringifyToken = function (token) {",
        "\tif (!token) {",
        "\t\treturn '';",
        "\t}",
        "\tif (typeof token === 'string') {",
        "\t\treturn token;",
        "\t}",
        "\tif (typeof token.content === 'string') {",
        "\t\treturn token.content;",
        "\t}",
        "\treturn token.content.map(stringifyToken).join('');",
        "};",
        "",
        "var walkTokens = function (tokens) {",
        "\tvar openedTags = [];",
        "\tfor (var i = 0; i < tokens.length; i++) {",
        "\t\tvar token = tokens[i];",
        "\t\tvar notTagNorBrace = false;",
        "",
        "\t\tif (typeof token !== 'string') {",
        "\t\t\tif (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {",
        "\t\t\t\t// We found a tag, now find its kind",
        "",
        "\t\t\t\tif (token.content[0].content[0].content === '</') {",
        "\t\t\t\t\t// Closing tag",
        "\t\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {",
        "\t\t\t\t\t\t// Pop matching opening tag",
        "\t\t\t\t\t\topenedTags.pop();",
        "\t\t\t\t\t}",
        "\t\t\t\t} else {",
        "\t\t\t\t\tif (token.content[token.content.length - 1].content === '/>') {",
        "\t\t\t\t\t\t// Autoclosed tag, ignore",
        "\t\t\t\t\t} else {",
        "\t\t\t\t\t\t// Opening tag",
        "\t\t\t\t\t\topenedTags.push({",
        "\t\t\t\t\t\t\ttagName: stringifyToken(token.content[0].content[1]),",
        "\t\t\t\t\t\t\topenedBraces: 0",
        "\t\t\t\t\t\t});",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t} else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {",
        "",
        "\t\t\t\t// Here we might have entered a JSX context inside a tag",
        "\t\t\t\topenedTags[openedTags.length - 1].openedBraces++;",
        "",
        "\t\t\t} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {",
        "",
        "\t\t\t\t// Here we might have left a JSX context inside a tag",
        "\t\t\t\topenedTags[openedTags.length - 1].openedBraces--;",
        "",
        "\t\t\t} else {",
        "\t\t\t\tnotTagNorBrace = true",
        "\t\t\t}",
        "\t\t}",
        "\t\tif (notTagNorBrace || typeof token === 'string') {",
        "\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {",
        "\t\t\t\t// Here we are inside a tag, and not inside a JSX context.",
        "\t\t\t\t// That's plain text: drop any tokens matched.",
        "\t\t\t\tvar plainText = stringifyToken(token);",
        "",
        "\t\t\t\t// And merge text with adjacent text",
        "\t\t\t\tif (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {",
        "\t\t\t\t\tplainText += stringifyToken(tokens[i + 1]);",
        "\t\t\t\t\ttokens.splice(i + 1, 1);",
        "\t\t\t\t}",
        "\t\t\t\tif (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {",
        "\t\t\t\t\tplainText = stringifyToken(tokens[i - 1]) + plainText;",
        "\t\t\t\t\ttokens.splice(i - 1, 1);",
        "\t\t\t\t\ti--;",
        "\t\t\t\t}",
        "",
        "\t\t\t\ttokens[i] = new Prism.Token('plain-text', plainText, null, plainText);",
        "\t\t\t}",
        "\t\t}",
        "",
        "\t\tif (token.content && typeof token.content !== 'string') {",
        "\t\t\twalkTokens(token.content);",
        "\t\t}",
        "\t}",
        "};",
        "",
        "Prism.hooks.add('after-tokenize', function (env) {",
        "\tif (env.language !== 'jsx' && env.language !== 'tsx') {",
        "\t\treturn;",
        "\t}",
        "\twalkTokens(env.tokens);",
        "});",
        "",
        "}(Prism));"
    ]
}