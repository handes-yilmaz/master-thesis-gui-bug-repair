{
    "1/1": {
        "src/language-markdown/parser-markdown.js": [
            {
                "SEARCH": [
                    "function parse(text /*, parsers, opts*/) {",
                    "const processor = unified()",
                    ".use(remarkParse, { footnotes: true, commonmark: true })",
                    ".use(remarkFrontmatter, [\"yaml\", \"toml\"])",
                    ".use(restoreUnescapedCharacter(text))",
                    ".use(mergeContinuousTexts)",
                    ".use(transformInlineCode)",
                    ".use(splitText);",
                    "return processor.runSync(processor.parse(text));",
                    "}"
                ],
                "REPLACE": [
                    "function parse(text /*, parsers, opts*/) {",
                    "  const processor = unified()",
                    "    .use(remarkParse, { footnotes: true, commonmark: true })",
                    "    .use(remarkFrontmatter, [\"yaml\", \"toml\"])",
                    "    .use(restoreUnescapedCharacter(text))",
                    "    .use(mergeContinuousTexts)",
                    "    .use(transformInlineCode)",
                    "    .use(splitText)",
                    "    .use(detectLanguageWithAttributes);",
                    "  return processor.runSync(processor.parse(text));",
                    "}",
                    "",
                    "function detectLanguageWithAttributes() {",
                    "  return ast => map(ast, node => {",
                    "    if (node.type === \"code\" && node.lang) {",
                    "      // Extract the language ignoring any attributes",
                    "      const [language] = node.lang.split(/\\s+/);",
                    "      return Object.assign({}, node, { lang: language });",
                    "    }",
                    "    return node;",
                    "  });",
                    "}"
                ]
            }
        ]
    }
}