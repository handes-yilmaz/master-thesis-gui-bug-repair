{
    "1": {
        "bug_file": "src/language-html/embed/angular-interpolation.js",
        "compressed": "NO",
        "line_numbers": 38,
        "compressed_line_numbers": 38,
        "compressed_bug_file_content": "import { group, indent, line } from \"../../document/builders.js\";\nimport { replaceEndOfLine } from \"../../document/utils.js\";\nimport { formatAttributeValue } from \"./utils.js\";\n\nconst interpolationRegex = /{{(.+?)}}/s;\n\nasync function printAngularInterpolation(text, textToDoc) {\n  const parts = [];\n  for (const [index, part] of text.split(interpolationRegex).entries()) {\n    if (index % 2 === 0) {\n      parts.push(replaceEndOfLine(part));\n    } else {\n      try {\n        parts.push(\n          group([\n            \"{{\",\n            indent([\n              line,\n              await formatAttributeValue(part, textToDoc, {\n                parser: \"__ng_interpolation\",\n                __isInHtmlInterpolation: true, // to avoid unexpected `}}`\n                trailingComma: \"none\",\n              }),\n            ]),\n            line,\n            \"}}\",\n          ])\n        );\n      } catch {\n        parts.push(\"{{\", replaceEndOfLine(part), \"}}\");\n      }\n    }\n  }\n\n  return parts;\n}\n\nexport { interpolationRegex, printAngularInterpolation };"
    },
    "2": {
        "bug_file": "src/language-js/print/angular.js",
        "compressed": "NO",
        "line_numbers": 115,
        "compressed_line_numbers": 115,
        "compressed_bug_file_content": "import { join, line, group } from \"../../document/builders.js\";\nimport UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";\nimport {\n  hasNode,\n  hasComment,\n  getComments,\n  createTypeCheckFunction,\n} from \"../utils/index.js\";\nimport { printBinaryishExpression } from \"./binaryish.js\";\n\n/** @typedef {import(\"../../common/ast-path.js\").default} AstPath */\n\nfunction printAngular(path, options, print) {\n  const { node } = path;\n\n  // Angular nodes always starts with `NG`\n  if (!node.type.startsWith(\"NG\")) {\n    return;\n  }\n\n  switch (node.type) {\n    case \"NGRoot\":\n      return [\n        print(\"node\"),\n        hasComment(node.node)\n          ? \" //\" + getComments(node.node)[0].value.trimEnd()\n          : \"\",\n      ];\n    case \"NGPipeExpression\":\n      return printBinaryishExpression(path, options, print);\n    case \"NGChainedExpression\":\n      return group(\n        join(\n          [\";\", line],\n          path.map(\n            () => (hasNgSideEffect(path) ? print() : [\"(\", print(), \")\"]),\n            \"expressions\"\n          )\n        )\n      );\n    case \"NGEmptyExpression\":\n      return \"\";\n    case \"NGMicrosyntax\":\n      return path.map(\n        () => [\n          path.isFirst ? \"\" : isNgForOf(path) ? \" \" : [\";\", line],\n          print(),\n        ],\n        \"body\"\n      );\n    case \"NGMicrosyntaxKey\":\n      return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(node.name)\n        ? node.name\n        : JSON.stringify(node.name);\n    case \"NGMicrosyntaxExpression\":\n      return [\n        print(\"expression\"),\n        node.alias === null ? \"\" : [\" as \", print(\"alias\")],\n      ];\n    case \"NGMicrosyntaxKeyedExpression\": {\n      const { index, parent } = path;\n      const shouldNotPrintColon =\n        isNgForOf(path) ||\n        (((index === 1 &&\n          (node.key.name === \"then\" || node.key.name === \"else\")) ||\n          (index === 2 &&\n            node.key.name === \"else\" &&\n            parent.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" &&\n            parent.body[index - 1].key.name === \"then\")) &&\n          parent.body[0].type === \"NGMicrosyntaxExpression\");\n      return [\n        print(\"key\"),\n        shouldNotPrintColon ? \" \" : \": \",\n        print(\"expression\"),\n      ];\n    }\n    case \"NGMicrosyntaxLet\":\n      return [\n        \"let \",\n        print(\"key\"),\n        node.value === null ? \"\" : [\" = \", print(\"value\")],\n      ];\n    case \"NGMicrosyntaxAs\":\n      return [print(\"key\"), \" as \", print(\"alias\")];\n    default:\n      /* c8 ignore next */\n      throw new UnexpectedNodeError(node, \"Angular\");\n  }\n}\n\nfunction isNgForOf({ node, index, parent }) {\n  return (\n    node.type === \"NGMicrosyntaxKeyedExpression\" &&\n    node.key.name === \"of\" &&\n    index === 1 &&\n    parent.body[0].type === \"NGMicrosyntaxLet\" &&\n    parent.body[0].value === null\n  );\n}\n\nconst hasSideEffect = createTypeCheckFunction([\n  \"CallExpression\",\n  \"OptionalCallExpression\",\n  \"AssignmentExpression\",\n]);\n/** identify if an angular expression seems to have side effects */\n/**\n * @param {AstPath} path\n * @returns {boolean}\n */\nfunction hasNgSideEffect({ node }) {\n  return hasNode(node, hasSideEffect);\n}\n\nexport { printAngular };"
    },
    "3": {
        "bug_file": "bin/prettier.js",
        "compressed": "NO",
        "line_numbers": 6,
        "compressed_line_numbers": 6,
        "compressed_bug_file_content": "#!/usr/bin/env node\n\n// Add this file so we can use `node bin/prettier` or `node bin/prettier.js`\n// instead of `node bin/prettier.cjs`.\n\nimport \"./prettier.cjs\";"
    },
    "4": {
        "bug_file": "src/index.js",
        "compressed": "NO",
        "line_numbers": 123,
        "compressed_line_numbers": 123,
        "compressed_bug_file_content": "import vnopts from \"vnopts\";\n// \"fast-glob\" is bundled here since the API uses `micromatch` too\nimport fastGlob from \"fast-glob\";\nimport * as core from \"./main/core.js\";\nimport {\n  getSupportInfo as getSupportInfoWithoutPlugins,\n  normalizeOptionSettings,\n} from \"./main/support.js\";\nimport getFileInfoWithoutPlugins from \"./common/get-file-info.js\";\nimport {\n  loadBuiltinPlugins,\n  loadPlugins,\n  clearCache as clearPluginCache,\n} from \"./main/plugins/index.js\";\nimport {\n  resolveConfig,\n  resolveConfigFile,\n  clearCache as clearConfigCache,\n} from \"./config/resolve-config.js\";\nimport * as errors from \"./common/errors.js\";\nimport * as optionCategories from \"./main/option-categories.js\";\nimport { createIsIgnoredFunction } from \"./utils/ignore.js\";\nimport { formatOptionsHiddenDefaults } from \"./main/normalize-format-options.js\";\nimport normalizeOptions from \"./main/normalize-options.js\";\nimport partition from \"./utils/partition.js\";\nimport isNonEmptyArray from \"./utils/is-non-empty-array.js\";\nimport omit from \"./utils/object-omit.js\";\n\n/**\n * @param {*} fn\n * @param {number} [optionsArgumentIndex]\n * @returns {*}\n */\nfunction withPlugins(\n  fn,\n  optionsArgumentIndex = 1 // Usually `options` is the 2nd argument\n) {\n  return async (...args) => {\n    const options = args[optionsArgumentIndex] ?? {};\n    const { plugins = [] } = options;\n\n    args[optionsArgumentIndex] = {\n      ...options,\n      plugins: (\n        await Promise.all([\n          loadBuiltinPlugins(),\n          // TODO: standalone version allow `plugins` to be `prettierPlugins` which is an object, should allow that too\n          loadPlugins(plugins),\n        ])\n      ).flat(),\n    };\n\n    return fn(...args);\n  };\n}\n\nconst formatWithCursor = withPlugins(core.formatWithCursor);\n\nasync function format(text, options) {\n  const { formatted } = await formatWithCursor(text, {\n    ...options,\n    cursorOffset: -1,\n  });\n  return formatted;\n}\n\nasync function check(text, options) {\n  return (await format(text, options)) === text;\n}\n\n// eslint-disable-next-line require-await\nasync function clearCache() {\n  clearConfigCache();\n  clearPluginCache();\n}\n\n/** @type {typeof getFileInfoWithoutPlugins} */\nconst getFileInfo = withPlugins(getFileInfoWithoutPlugins);\n\n/** @type {typeof getSupportInfoWithoutPlugins} */\nconst getSupportInfo = withPlugins(getSupportInfoWithoutPlugins, 0);\n\n// Internal shared with cli\nconst sharedWithCli = {\n  errors,\n  optionCategories,\n  createIsIgnoredFunction,\n  formatOptionsHiddenDefaults,\n  normalizeOptions,\n  getSupportInfoWithoutPlugins,\n  normalizeOptionSettings,\n  vnopts,\n  fastGlob,\n  utils: {\n    isNonEmptyArray,\n    partition,\n    omit,\n  },\n};\n\nconst debugApis = {\n  parse: withPlugins(core.parse),\n  formatAST: withPlugins(core.formatAst),\n  formatDoc: withPlugins(core.formatDoc),\n  printToDoc: withPlugins(core.printToDoc),\n  printDocToString: withPlugins(core.printDocToString),\n};\n\nexport {\n  formatWithCursor,\n  format,\n  check,\n  resolveConfig,\n  resolveConfigFile,\n  clearCache as clearConfigCache,\n  getFileInfo,\n  getSupportInfo,\n  sharedWithCli as __internal,\n  debugApis as __debug,\n};\nexport * as util from \"./utils/public.js\";\nexport * as doc from \"./document/public.js\";\nexport { default as version } from \"./main/version.evaluate.cjs\";"
    },
    "5": {
        "bug_file": "website/playground/Playground.js",
        "compressed": "YES",
        "line_numbers": 521,
        "compressed_line_numbers": 42,
        "compressed_bug_file_content": "import * as React from \"react\";\n\nimport { Button, ClipboardButton } from \"./buttons.js\";\nimport EditorState from \"./EditorState.js\";\nimport { DebugPanel, InputPanel, OutputPanel } from \"./panels.js\";\nimport PrettierFormat from \"./PrettierFormat.js\";\nimport { shallowEqual } from \"./helpers.js\";\nimport * as urlHash from \"./urlHash.js\";\nimport formatMarkdown from \"./markdown.js\";\nimport * as util from \"./util.js\";\nimport generateDummyId from \"./dummyId.js\";\nimport getCodeSample from \"./codeSamples.mjs\";\n\nimport { Sidebar, SidebarCategory } from \"./sidebar/components.js\";\nimport SidebarOptions from \"./sidebar/SidebarOptions.js\";\nimport Option from \"./sidebar/options.js\";\nimport { Checkbox } from \"./sidebar/inputs.js\";\n\n\n    // 0.0.0 ~ 0.0.10\n\n\n    // 0.0.0 ~ 0.0.10\n\n\n    // 1.8.2 ~ 1.9.0\n\n\n    // 0.0.0 ~ 1.9.0\n\n\n    // 0.17.0 ~ 2.4.0\n\n\n                          // Remove `parser` since people usually paste this\n                          // into their .prettierrc and specifying a top-level\n                          // parser there is an anti-pattern. Note:\n                          // `JSON.stringify` omits keys whose values are\n                          // `undefined`.\n\n\nexport default Playground;\n"
    },
    "6": {
        "bug_file": "src/language-html/printer-html.js",
        "compressed": "NO",
        "line_numbers": 124,
        "compressed_line_numbers": 124,
        "compressed_bug_file_content": "/**\n * @typedef {import(\"../document/builders.js\").Doc} Doc\n */\n\nimport { fill, group, hardline } from \"../document/builders.js\";\nimport { cleanDoc, replaceEndOfLine } from \"../document/utils.js\";\nimport UnexpectedNodeError from \"../utils/unexpected-node-error.js\";\nimport getPreferredQuote from \"../utils/get-preferred-quote.js\";\nimport clean from \"./clean.js\";\nimport { unescapeQuoteEntities, getTextValueParts } from \"./utils/index.js\";\nimport preprocess from \"./print-preprocess.js\";\nimport { insertPragma } from \"./pragma.js\";\nimport { locStart, locEnd } from \"./loc.js\";\nimport embed from \"./embed.js\";\nimport {\n  printClosingTagSuffix,\n  printClosingTagEnd,\n  printOpeningTagPrefix,\n  printOpeningTagStart,\n} from \"./print/tag.js\";\nimport { printElement } from \"./print/element.js\";\nimport { printChildren } from \"./print/children.js\";\nimport getVisitorKeys from \"./get-visitor-keys.js\";\n\nfunction genericPrint(path, options, print) {\n  const { node } = path;\n\n  switch (node.type) {\n    case \"front-matter\":\n      return replaceEndOfLine(node.raw);\n    case \"root\":\n      if (options.__onHtmlRoot) {\n        options.__onHtmlRoot(node);\n      }\n      return [group(printChildren(path, options, print)), hardline];\n    case \"element\":\n    case \"ieConditionalComment\":\n      return printElement(path, options, print);\n\n    case \"ieConditionalStartComment\":\n    case \"ieConditionalEndComment\":\n      return [printOpeningTagStart(node), printClosingTagEnd(node)];\n    case \"interpolation\":\n      return [\n        printOpeningTagStart(node, options),\n        ...path.map(print, \"children\"),\n        printClosingTagEnd(node, options),\n      ];\n    case \"text\": {\n      if (node.parent.type === \"interpolation\") {\n        // replace the trailing literalline with hardline for better readability\n        const trailingNewlineRegex = /\\n[^\\S\\n]*$/;\n        const hasTrailingNewline = trailingNewlineRegex.test(node.value);\n        const value = hasTrailingNewline\n          ? node.value.replace(trailingNewlineRegex, \"\")\n          : node.value;\n        return [replaceEndOfLine(value), hasTrailingNewline ? hardline : \"\"];\n      }\n\n      const printed = cleanDoc([\n        printOpeningTagPrefix(node, options),\n        ...getTextValueParts(node),\n        printClosingTagSuffix(node, options),\n      ]);\n\n      if (Array.isArray(printed)) {\n        return fill(printed);\n      }\n\n      return printed;\n    }\n    case \"docType\":\n      return [\n        group([\n          printOpeningTagStart(node, options),\n          \" \",\n          node.value.replace(/^html\\b/i, \"html\").replaceAll(/\\s+/g, \" \"),\n        ]),\n        printClosingTagEnd(node, options),\n      ];\n    case \"comment\":\n      return [\n        printOpeningTagPrefix(node, options),\n        replaceEndOfLine(\n          options.originalText.slice(locStart(node), locEnd(node))\n        ),\n        printClosingTagSuffix(node, options),\n      ];\n\n    case \"attribute\": {\n      if (node.value === null) {\n        return node.rawName;\n      }\n      const value = unescapeQuoteEntities(node.value);\n      const quote = getPreferredQuote(value, '\"');\n      return [\n        node.rawName,\n        \"=\",\n        quote,\n        replaceEndOfLine(\n          quote === '\"'\n            ? value.replaceAll('\"', \"&quot;\")\n            : value.replaceAll(\"'\", \"&apos;\")\n        ),\n        quote,\n      ];\n    }\n    case \"cdata\": // Transformed into `text`\n    default:\n      /* c8 ignore next */\n      throw new UnexpectedNodeError(node, \"HTML\");\n  }\n}\n\nconst printer = {\n  preprocess,\n  print: genericPrint,\n  insertPragma,\n  massageAstNode: clean,\n  embed,\n  getVisitorKeys,\n};\n\nexport default printer;"
    },
    "7": {
        "bug_file": "src/language-html/parser-html.js",
        "compressed": "NO",
        "line_numbers": 394,
        "compressed_line_numbers": 394,
        "compressed_bug_file_content": "import {\n  ParseSourceFile,\n  ParseLocation,\n  ParseSourceSpan,\n  parse as parseHtml,\n  RecursiveVisitor,\n  visitAll,\n  getHtmlTagDefinition,\n  TagContentType,\n} from \"angular-html-parser\";\nimport parseFrontMatter from \"../utils/front-matter/parse.js\";\nimport inferParser from \"../utils/infer-parser.js\";\nimport createError from \"../common/parser-create-error.js\";\nimport HTML_TAGS from \"./utils/html-tag-names.evaluate.js\";\nimport HTML_ELEMENT_ATTRIBUTES from \"./utils/html-elements-attributes.evaluate.js\";\nimport isUnknownNamespace from \"./utils/is-unknown-namespace.js\";\nimport { hasPragma } from \"./pragma.js\";\nimport { Node } from \"./ast.js\";\nimport { parseIeConditionalComment } from \"./conditional-comment.js\";\nimport { locStart, locEnd } from \"./loc.js\";\n\n/**\n * @typedef {import('angular-html-parser')} AngularHtmlParser\n * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Node} AstNode\n * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Attribute} Attribute\n * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Element} Element\n * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/parser.js').ParseTreeResult} ParserTreeResult\n * @typedef {import('angular-html-parser').ParseOptions & {\n *   name: 'html' | 'angular' | 'vue' | 'lwc';\n *   normalizeTagName?: boolean;\n *   normalizeAttributeName?: boolean;\n *   shouldParseAsRawText?: (tagName: string, prefix: string, hasParent: boolean, attrs: Array<{\n *      prefix: string;\n *      name: string;\n *      value?: string;\n *   }>) => boolean;\n * }} ParseOptions\n * @typedef {{filepath?: string}} Options\n */\n\n/**\n * @param {string} input\n * @param {ParseOptions} parseOptions\n * @param {Options} options\n */\nfunction ngHtmlParser(input, parseOptions, options) {\n  const {\n    name,\n    canSelfClose = true,\n    normalizeTagName = false,\n    normalizeAttributeName = false,\n    allowHtmComponentClosingTags = false,\n    isTagNameCaseSensitive = false,\n    shouldParseAsRawText,\n  } = parseOptions;\n\n  let { rootNodes, errors } = parseHtml(input, {\n    canSelfClose,\n    allowHtmComponentClosingTags,\n    isTagNameCaseSensitive,\n    getTagContentType: shouldParseAsRawText\n      ? (...args) =>\n          shouldParseAsRawText(...args) ? TagContentType.RAW_TEXT : undefined\n      : undefined,\n  });\n\n  if (name === \"vue\") {\n    const isHtml = rootNodes.some(\n      (node) =>\n        (node.type === \"docType\" && node.value === \"html\") ||\n        (node.type === \"element\" && node.name.toLowerCase() === \"html\")\n    );\n\n    // If not Vue SFC, treat as html\n    if (isHtml) {\n      return ngHtmlParser(input, HTML_PARSE_OPTIONS, options);\n    }\n\n    /** @type {ParserTreeResult | undefined} */\n    let secondParseResult;\n    const getHtmlParseResult = () =>\n      (secondParseResult ??= parseHtml(input, {\n        canSelfClose,\n        allowHtmComponentClosingTags,\n        isTagNameCaseSensitive,\n      }));\n\n    const getNodeWithSameLocation = (node) =>\n      getHtmlParseResult().rootNodes.find(\n        ({ startSourceSpan }) =>\n          startSourceSpan &&\n          startSourceSpan.start.offset === node.startSourceSpan.start.offset\n      ) ?? node;\n    for (const [index, node] of rootNodes.entries()) {\n      const { endSourceSpan, startSourceSpan } = node;\n      const isVoidElement = endSourceSpan === null;\n      if (isVoidElement) {\n        errors = getHtmlParseResult().errors;\n        rootNodes[index] = getNodeWithSameLocation(node);\n      } else if (shouldParseVueRootNodeAsHtml(node, options)) {\n        const error = getHtmlParseResult().errors.find(\n          (error) =>\n            error.span.start.offset > startSourceSpan.start.offset &&\n            error.span.start.offset < endSourceSpan.end.offset\n        );\n        if (error) {\n          throwParseError(error);\n        }\n        rootNodes[index] = getNodeWithSameLocation(node);\n      }\n    }\n  }\n\n  if (errors.length > 0) {\n    throwParseError(errors[0]);\n  }\n\n  /**\n   * @param {Attribute | Element} node\n   */\n  const restoreName = (node) => {\n    const namespace = node.name.startsWith(\":\")\n      ? node.name.slice(1).split(\":\")[0]\n      : null;\n    const rawName = node.nameSpan.toString();\n    const hasExplicitNamespace =\n      namespace !== null && rawName.startsWith(`${namespace}:`);\n    const name = hasExplicitNamespace\n      ? rawName.slice(namespace.length + 1)\n      : rawName;\n\n    node.name = name;\n    node.namespace = namespace;\n    node.hasExplicitNamespace = hasExplicitNamespace;\n  };\n\n  /**\n   * @param {AstNode} node\n   */\n  const restoreNameAndValue = (node) => {\n    switch (node.type) {\n      case \"element\":\n        restoreName(node);\n        for (const attr of node.attrs) {\n          restoreName(attr);\n          if (!attr.valueSpan) {\n            attr.value = null;\n          } else {\n            attr.value = attr.valueSpan.toString();\n            if (/[\"']/.test(attr.value[0])) {\n              attr.value = attr.value.slice(1, -1);\n            }\n          }\n        }\n        break;\n      case \"comment\":\n        node.value = node.sourceSpan\n          .toString()\n          .slice(\"<!--\".length, -\"-->\".length);\n        break;\n      case \"text\":\n        node.value = node.sourceSpan.toString();\n        break;\n      // No default\n    }\n  };\n\n  const lowerCaseIfFn = (text, fn) => {\n    const lowerCasedText = text.toLowerCase();\n    return fn(lowerCasedText) ? lowerCasedText : text;\n  };\n  const normalizeName = (node) => {\n    if (node.type === \"element\") {\n      if (\n        normalizeTagName &&\n        (!node.namespace ||\n          node.namespace === node.tagDefinition.implicitNamespacePrefix ||\n          isUnknownNamespace(node))\n      ) {\n        node.name = lowerCaseIfFn(node.name, (lowerCasedName) =>\n          HTML_TAGS.has(lowerCasedName)\n        );\n      }\n\n      if (normalizeAttributeName) {\n        for (const attr of node.attrs) {\n          if (!attr.namespace) {\n            attr.name = lowerCaseIfFn(\n              attr.name,\n              (lowerCasedAttrName) =>\n                HTML_ELEMENT_ATTRIBUTES.has(node.name) &&\n                (HTML_ELEMENT_ATTRIBUTES.get(\"*\").has(lowerCasedAttrName) ||\n                  HTML_ELEMENT_ATTRIBUTES.get(node.name).has(\n                    lowerCasedAttrName\n                  ))\n            );\n          }\n        }\n      }\n    }\n  };\n\n  const fixSourceSpan = (node) => {\n    if (node.sourceSpan && node.endSourceSpan) {\n      node.sourceSpan = new ParseSourceSpan(\n        node.sourceSpan.start,\n        node.endSourceSpan.end\n      );\n    }\n  };\n\n  /**\n   * @param {AstNode} node\n   */\n  const addTagDefinition = (node) => {\n    if (node.type === \"element\") {\n      const tagDefinition = getHtmlTagDefinition(\n        isTagNameCaseSensitive ? node.name : node.name.toLowerCase()\n      );\n      if (\n        !node.namespace ||\n        node.namespace === tagDefinition.implicitNamespacePrefix ||\n        isUnknownNamespace(node)\n      ) {\n        node.tagDefinition = tagDefinition;\n      } else {\n        node.tagDefinition = getHtmlTagDefinition(\"\"); // the default one\n      }\n    }\n  };\n\n  visitAll(\n    new (class extends RecursiveVisitor {\n      visit(node) {\n        restoreNameAndValue(node);\n        addTagDefinition(node);\n        normalizeName(node);\n        fixSourceSpan(node);\n      }\n    })(),\n    rootNodes\n  );\n\n  return rootNodes;\n}\n\nfunction shouldParseVueRootNodeAsHtml(node, options) {\n  if (node.type !== \"element\" || node.name !== \"template\") {\n    return false;\n  }\n  const language = node.attrs.find((attr) => attr.name === \"lang\")?.value;\n  return !language || inferParser(options, { language }) === \"html\";\n}\n\nfunction throwParseError(error) {\n  const {\n    msg,\n    span: { start, end },\n  } = error;\n  throw createError(msg, {\n    loc: {\n      start: { line: start.line + 1, column: start.col + 1 },\n      end: { line: end.line + 1, column: end.col + 1 },\n    },\n    cause: error,\n  });\n}\n\n/**\n * @param {string} text\n * @param {ParseOptions} parseOptions\n * @param {Options} options\n * @param {boolean} shouldParseFrontMatter\n */\nfunction parse(\n  text,\n  parseOptions,\n  options = {},\n  shouldParseFrontMatter = true\n) {\n  const { frontMatter, content } = shouldParseFrontMatter\n    ? parseFrontMatter(text)\n    : { frontMatter: null, content: text };\n\n  const file = new ParseSourceFile(text, options.filepath);\n  const start = new ParseLocation(file, 0, 0, 0);\n  const end = start.moveBy(text.length);\n  const rawAst = {\n    type: \"root\",\n    sourceSpan: new ParseSourceSpan(start, end),\n    children: ngHtmlParser(content, parseOptions, options),\n  };\n\n  if (frontMatter) {\n    const start = new ParseLocation(file, 0, 0, 0);\n    const end = start.moveBy(frontMatter.raw.length);\n    frontMatter.sourceSpan = new ParseSourceSpan(start, end);\n    rawAst.children.unshift(frontMatter);\n  }\n\n  const ast = new Node(rawAst);\n\n  const parseSubHtml = (subContent, startSpan) => {\n    const { offset } = startSpan;\n    const fakeContent = text.slice(0, offset).replaceAll(/[^\\n\\r]/g, \" \");\n    const realContent = subContent;\n    const subAst = parse(\n      fakeContent + realContent,\n      parseOptions,\n      options,\n      false\n    );\n    // @ts-expect-error\n    subAst.sourceSpan = new ParseSourceSpan(\n      startSpan,\n      // @ts-expect-error\n      subAst.children.at(-1).sourceSpan.end\n    );\n    // @ts-expect-error\n    const firstText = subAst.children[0];\n    if (firstText.length === offset) {\n      /* c8 ignore next */ // @ts-expect-error\n      subAst.children.shift();\n    } else {\n      firstText.sourceSpan = new ParseSourceSpan(\n        firstText.sourceSpan.start.moveBy(offset),\n        firstText.sourceSpan.end\n      );\n      firstText.value = firstText.value.slice(offset);\n    }\n    return subAst;\n  };\n\n  ast.walk((node) => {\n    if (node.type === \"comment\") {\n      const ieConditionalComment = parseIeConditionalComment(\n        node,\n        parseSubHtml\n      );\n      if (ieConditionalComment) {\n        node.parent.replaceChild(node, ieConditionalComment);\n      }\n    }\n  });\n\n  return ast;\n}\n\n/**\n * @param {ParseOptions} parseOptions\n */\nfunction createParser(parseOptions) {\n  return {\n    parse: (text, options) => parse(text, parseOptions, options),\n    hasPragma,\n    astFormat: \"html\",\n    locStart,\n    locEnd,\n  };\n}\n\n/** @type {ParseOptions} */\nconst HTML_PARSE_OPTIONS = {\n  name: \"html\",\n  normalizeTagName: true,\n  normalizeAttributeName: true,\n  allowHtmComponentClosingTags: true,\n};\n\n// HTML\nexport const html = createParser(HTML_PARSE_OPTIONS);\n// Angular\nexport const angular = createParser({ name: \"angular\" });\n// Vue\nexport const vue = createParser({\n  name: \"vue\",\n  isTagNameCaseSensitive: true,\n  shouldParseAsRawText(tagName, prefix, hasParent, attrs) {\n    return (\n      tagName.toLowerCase() !== \"html\" &&\n      !hasParent &&\n      (tagName !== \"template\" ||\n        attrs.some(\n          ({ name, value }) =>\n            name === \"lang\" &&\n            value !== \"html\" &&\n            value !== \"\" &&\n            value !== undefined\n        ))\n    );\n  },\n});\n// Lightning Web Components\nexport const lwc = createParser({ name: \"lwc\", canSelfClose: false });"
    }
}