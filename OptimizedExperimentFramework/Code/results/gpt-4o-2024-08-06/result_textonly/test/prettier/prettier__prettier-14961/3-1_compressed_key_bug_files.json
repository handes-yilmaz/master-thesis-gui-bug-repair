{
    "1": {
        "bug_file": "src/language-html/embed/angular-interpolation.js",
        "compressed": "NO",
        "line_numbers": 38,
        "compressed_line_numbers": 38,
        "compressed_bug_file_content": "import { group, indent, line } from \"../../document/builders.js\";\nimport { replaceEndOfLine } from \"../../document/utils.js\";\nimport { formatAttributeValue } from \"./utils.js\";\n\nconst interpolationRegex = /{{(.+?)}}/s;\n\nasync function printAngularInterpolation(text, textToDoc) {\n  const parts = [];\n  for (const [index, part] of text.split(interpolationRegex).entries()) {\n    if (index % 2 === 0) {\n      parts.push(replaceEndOfLine(part));\n    } else {\n      try {\n        parts.push(\n          group([\n            \"{{\",\n            indent([\n              line,\n              await formatAttributeValue(part, textToDoc, {\n                parser: \"__ng_interpolation\",\n                __isInHtmlInterpolation: true, // to avoid unexpected `}}`\n                trailingComma: \"none\",\n              }),\n            ]),\n            line,\n            \"}}\",\n          ])\n        );\n      } catch {\n        parts.push(\"{{\", replaceEndOfLine(part), \"}}\");\n      }\n    }\n  }\n\n  return parts;\n}\n\nexport { interpolationRegex, printAngularInterpolation };"
    },
    "2": {
        "bug_file": "src/language-js/print/angular.js",
        "compressed": "NO",
        "line_numbers": 115,
        "compressed_line_numbers": 115,
        "compressed_bug_file_content": "import { join, line, group } from \"../../document/builders.js\";\nimport UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";\nimport {\n  hasNode,\n  hasComment,\n  getComments,\n  createTypeCheckFunction,\n} from \"../utils/index.js\";\nimport { printBinaryishExpression } from \"./binaryish.js\";\n\n/** @typedef {import(\"../../common/ast-path.js\").default} AstPath */\n\nfunction printAngular(path, options, print) {\n  const { node } = path;\n\n  // Angular nodes always starts with `NG`\n  if (!node.type.startsWith(\"NG\")) {\n    return;\n  }\n\n  switch (node.type) {\n    case \"NGRoot\":\n      return [\n        print(\"node\"),\n        hasComment(node.node)\n          ? \" //\" + getComments(node.node)[0].value.trimEnd()\n          : \"\",\n      ];\n    case \"NGPipeExpression\":\n      return printBinaryishExpression(path, options, print);\n    case \"NGChainedExpression\":\n      return group(\n        join(\n          [\";\", line],\n          path.map(\n            () => (hasNgSideEffect(path) ? print() : [\"(\", print(), \")\"]),\n            \"expressions\"\n          )\n        )\n      );\n    case \"NGEmptyExpression\":\n      return \"\";\n    case \"NGMicrosyntax\":\n      return path.map(\n        () => [\n          path.isFirst ? \"\" : isNgForOf(path) ? \" \" : [\";\", line],\n          print(),\n        ],\n        \"body\"\n      );\n    case \"NGMicrosyntaxKey\":\n      return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(node.name)\n        ? node.name\n        : JSON.stringify(node.name);\n    case \"NGMicrosyntaxExpression\":\n      return [\n        print(\"expression\"),\n        node.alias === null ? \"\" : [\" as \", print(\"alias\")],\n      ];\n    case \"NGMicrosyntaxKeyedExpression\": {\n      const { index, parent } = path;\n      const shouldNotPrintColon =\n        isNgForOf(path) ||\n        (((index === 1 &&\n          (node.key.name === \"then\" || node.key.name === \"else\")) ||\n          (index === 2 &&\n            node.key.name === \"else\" &&\n            parent.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" &&\n            parent.body[index - 1].key.name === \"then\")) &&\n          parent.body[0].type === \"NGMicrosyntaxExpression\");\n      return [\n        print(\"key\"),\n        shouldNotPrintColon ? \" \" : \": \",\n        print(\"expression\"),\n      ];\n    }\n    case \"NGMicrosyntaxLet\":\n      return [\n        \"let \",\n        print(\"key\"),\n        node.value === null ? \"\" : [\" = \", print(\"value\")],\n      ];\n    case \"NGMicrosyntaxAs\":\n      return [print(\"key\"), \" as \", print(\"alias\")];\n    default:\n      /* c8 ignore next */\n      throw new UnexpectedNodeError(node, \"Angular\");\n  }\n}\n\nfunction isNgForOf({ node, index, parent }) {\n  return (\n    node.type === \"NGMicrosyntaxKeyedExpression\" &&\n    node.key.name === \"of\" &&\n    index === 1 &&\n    parent.body[0].type === \"NGMicrosyntaxLet\" &&\n    parent.body[0].value === null\n  );\n}\n\nconst hasSideEffect = createTypeCheckFunction([\n  \"CallExpression\",\n  \"OptionalCallExpression\",\n  \"AssignmentExpression\",\n]);\n/** identify if an angular expression seems to have side effects */\n/**\n * @param {AstPath} path\n * @returns {boolean}\n */\nfunction hasNgSideEffect({ node }) {\n  return hasNode(node, hasSideEffect);\n}\n\nexport { printAngular };"
    }
}