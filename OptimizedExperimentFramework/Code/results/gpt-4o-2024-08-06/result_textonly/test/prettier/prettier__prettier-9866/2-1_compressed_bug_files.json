{
    "1": {
        "bug_file": "src/language-js/print/jsx.js",
        "compressed": "YES",
        "line_numbers": 770,
        "compressed_line_numbers": 143,
        "compressed_bug_file_content": "\n\n// JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\n  // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  // Record any breaks. Should never go from true to false, only false to true.\n\n\n  // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n\n  // Trim trailing lines (or empty strings)\n\n\n  // Trim leading lines (or empty strings)\n\n\n  // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n\n\n          // Solitary whitespace\n\n\n        // Leading whitespace\n\n\n        // Trailing whitespace\n\n\n        // Whitespace after line break\n\n\n  // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n\n// JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\n      // Contains a non-whitespace character\n\n\n        // Starts with whitespace\n\n\n        // Ends with whitespace\n\n\n        // This was whitespace only without a new line.\n\n\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n\n\n  /* istanbul ignore next */\n\n\n      // Unescape all quotes so we get an accurate preferred quote\n\n\n  // Don't break self-closing elements with no attributes and no comments\n\n\n  // don't break up opening elements with a single long text attribute\n\n\n    // We should break for the following cases:\n    // <div\n    //   // comment\n    //   attr=\"value\"\n    // >\n    // <div\n    //   attr=\"value\"\n    //   // comment\n    // >\n\n\n    // Simple tags (no attributes and no comment in tag name) should be\n    // kept unbroken regardless of `jsxBracketSameLine`\n\n\n      // We should print the bracket in a new line for the following cases:\n      // <div\n      //   // comment\n      // >\n      // <div\n      //   attr // comment\n      // >\n\n\n  // We should print the opening element expanded if any prop value is a\n  // string literal with newlines\n\n\n// `JSXSpreadAttribute` and `JSXSpreadChild`\n\n\n      // Same as `printJsxSpreadAttribute`\n\n\n      /* istanbul ignore next */\n\n\n"
    },
    "2": {
        "bug_file": "src/main/core.js",
        "compressed": "NO",
        "line_numbers": 355,
        "compressed_line_numbers": 355,
        "compressed_bug_file_content": "\"use strict\";\n\nconst diff = require(\"diff\");\n\nconst {\n  printer: { printDocToString },\n  debug: { printDocToDebug },\n} = require(\"../document\");\nconst { getAlignmentSize } = require(\"../common/util\");\nconst {\n  guessEndOfLine,\n  convertEndOfLineToChars,\n  countEndOfLineChars,\n  normalizeEndOfLine,\n} = require(\"../common/end-of-line\");\nconst normalizeOptions = require(\"./options\").normalize;\nconst massageAST = require(\"./massage-ast\");\nconst comments = require(\"./comments\");\nconst parser = require(\"./parser\");\nconst printAstToDoc = require(\"./ast-to-doc\");\nconst rangeUtil = require(\"./range-util\");\n\nconst BOM = \"\\uFEFF\";\n\nconst CURSOR = Symbol(\"cursor\");\n\nfunction attachComments(text, ast, opts) {\n  const astComments = ast.comments;\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n  opts[Symbol.for(\"comments\")] = astComments || [];\n  opts[Symbol.for(\"tokens\")] = ast.tokens || [];\n  opts.originalText = text;\n  return astComments;\n}\n\nfunction coreFormat(originalText, opts, addAlignmentSize) {\n  if (!originalText || !originalText.trim().length) {\n    return { formatted: \"\", cursorOffset: -1 };\n  }\n\n  addAlignmentSize = addAlignmentSize || 0;\n\n  const { ast, text } = parser.parse(originalText, opts);\n\n  if (opts.cursorOffset >= 0) {\n    const nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n    if (nodeResult && nodeResult.node) {\n      opts.cursorNode = nodeResult.node;\n    }\n  }\n\n  const astComments = attachComments(text, ast, opts);\n  const doc = printAstToDoc(ast, opts, addAlignmentSize);\n\n  const result = printDocToString(doc, opts);\n\n  comments.ensureAllCommentsPrinted(astComments);\n  // Remove extra leading indentation as well as the added indentation after last newline\n  if (addAlignmentSize > 0) {\n    const trimmed = result.formatted.trim();\n\n    if (result.cursorNodeStart !== undefined) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n\n  if (opts.cursorOffset >= 0) {\n    let oldCursorNodeStart;\n    let oldCursorNodeText;\n\n    let cursorOffsetRelativeToOldCursorNode;\n\n    let newCursorNodeStart;\n    let newCursorNodeText;\n\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(\n        oldCursorNodeStart,\n        opts.locEnd(opts.cursorNode)\n      );\n\n      cursorOffsetRelativeToOldCursorNode =\n        opts.cursorOffset - oldCursorNodeStart;\n\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,\n      };\n    }\n\n    // diff old and new cursor node texts, with a special cursor\n    // symbol inserted to find out where it moves to\n\n    const oldCursorNodeCharArray = oldCursorNodeText.split(\"\");\n    oldCursorNodeCharArray.splice(\n      cursorOffsetRelativeToOldCursorNode,\n      0,\n      CURSOR\n    );\n\n    const newCursorNodeCharArray = newCursorNodeText.split(\"\");\n\n    const cursorNodeDiff = diff.diffArrays(\n      oldCursorNodeCharArray,\n      newCursorNodeCharArray\n    );\n\n    let cursorOffset = newCursorNodeStart;\n    for (const entry of cursorNodeDiff) {\n      if (entry.removed) {\n        if (entry.value.includes(CURSOR)) {\n          break;\n        }\n      } else {\n        cursorOffset += entry.count;\n      }\n    }\n\n    return { formatted: result.formatted, cursorOffset };\n  }\n\n  return { formatted: result.formatted, cursorOffset: -1 };\n}\n\nfunction formatRange(originalText, opts) {\n  const { ast, text } = parser.parse(originalText, opts);\n  const { rangeStart, rangeEnd } = rangeUtil.calculateRange(text, opts, ast);\n  const rangeString = text.slice(rangeStart, rangeEnd);\n\n  // Try to extend the range backwards to the beginning of the line.\n  // This is so we can detect indentation correctly and restore it.\n  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n  const rangeStart2 = Math.min(\n    rangeStart,\n    text.lastIndexOf(\"\\n\", rangeStart) + 1\n  );\n  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];\n\n  const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);\n\n  const rangeResult = coreFormat(\n    rangeString,\n    {\n      ...opts,\n      rangeStart: 0,\n      rangeEnd: Infinity,\n      // Track the cursor offset only if it's within our range\n      cursorOffset:\n        opts.cursorOffset > rangeStart && opts.cursorOffset < rangeEnd\n          ? opts.cursorOffset - rangeStart\n          : -1,\n      // Always use `lf` to format, we'll replace it later\n      endOfLine: \"lf\",\n    },\n    alignmentSize\n  );\n\n  // Since the range contracts to avoid trailing whitespace,\n  // we need to remove the newline that was inserted by the `format` call.\n  const rangeTrimmed = rangeResult.formatted.trimEnd();\n\n  let { cursorOffset } = opts;\n  if (cursorOffset >= rangeEnd) {\n    // handle the case where the cursor was past the end of the range\n    cursorOffset =\n      opts.cursorOffset + (rangeTrimmed.length - rangeString.length);\n  } else if (rangeResult.cursorOffset >= 0) {\n    // handle the case where the cursor was in the range\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  }\n  // keep the cursor as it was if it was before the start of the range\n\n  let formatted =\n    text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);\n  if (opts.endOfLine !== \"lf\") {\n    const eol = convertEndOfLineToChars(opts.endOfLine);\n    if (cursorOffset >= 0 && eol === \"\\r\\n\") {\n      cursorOffset += countEndOfLineChars(\n        formatted.slice(0, cursorOffset),\n        \"\\n\"\n      );\n    }\n\n    formatted = formatted.replace(/\\n/g, eol);\n  }\n\n  return { formatted, cursorOffset };\n}\n\nfunction ensureIndexInText(text, index, defaultValue) {\n  if (\n    typeof index !== \"number\" ||\n    isNaN(index) ||\n    index < 0 ||\n    index > text.length\n  ) {\n    return defaultValue;\n  }\n\n  return index;\n}\n\nfunction normalizeIndexes(text, options) {\n  let { cursorOffset, rangeStart, rangeEnd } = options;\n  cursorOffset = ensureIndexInText(text, cursorOffset, -1);\n  rangeStart = ensureIndexInText(text, rangeStart, 0);\n  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);\n\n  return { ...options, cursorOffset, rangeStart, rangeEnd };\n}\n\nfunction normalizeInputAndOptions(text, options) {\n  let { cursorOffset, rangeStart, rangeEnd, endOfLine } = normalizeIndexes(\n    text,\n    options\n  );\n\n  const hasBOM = text.charAt(0) === BOM;\n\n  if (hasBOM) {\n    text = text.slice(1);\n    cursorOffset--;\n    rangeStart--;\n    rangeEnd--;\n  }\n\n  if (endOfLine === \"auto\") {\n    endOfLine = guessEndOfLine(text);\n  }\n\n  // get rid of CR/CRLF parsing\n  if (text.includes(\"\\r\")) {\n    const countCrlfBefore = (index) =>\n      countEndOfLineChars(text.slice(0, Math.max(index, 0)), \"\\r\\n\");\n\n    cursorOffset -= countCrlfBefore(cursorOffset);\n    rangeStart -= countCrlfBefore(rangeStart);\n    rangeEnd -= countCrlfBefore(rangeEnd);\n\n    text = normalizeEndOfLine(text);\n  }\n\n  return {\n    hasBOM,\n    text,\n    options: normalizeIndexes(text, {\n      ...options,\n      cursorOffset,\n      rangeStart,\n      rangeEnd,\n      endOfLine,\n    }),\n  };\n}\n\nfunction format(originalText, originalOptions) {\n  let { hasBOM, text, options } = normalizeInputAndOptions(\n    originalText,\n    normalizeOptions(originalOptions)\n  );\n\n  if (options.rangeStart >= options.rangeEnd && text !== \"\") {\n    return {\n      formatted: originalText,\n      cursorOffset: originalOptions.cursorOffset,\n    };\n  }\n\n  const selectedParser = parser.resolveParser(options);\n  const hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);\n  if (options.requirePragma && !hasPragma) {\n    return {\n      formatted: originalText,\n      cursorOffset: originalOptions.cursorOffset,\n    };\n  }\n\n  let result;\n\n  if (options.rangeStart > 0 || options.rangeEnd < text.length) {\n    result = formatRange(text, options);\n  } else {\n    if (!hasPragma && options.insertPragma && options.printer.insertPragma) {\n      text = options.printer.insertPragma(text);\n    }\n    result = coreFormat(text, options);\n  }\n\n  if (hasBOM) {\n    result.formatted = BOM + result.formatted;\n\n    if (result.cursorOffset >= 0) {\n      result.cursorOffset++;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  formatWithCursor: format,\n  parse(originalText, originalOptions, massage) {\n    const { text, options } = normalizeInputAndOptions(\n      originalText,\n      normalizeOptions(originalOptions)\n    );\n    const parsed = parser.parse(text, options);\n    if (massage) {\n      parsed.ast = massageAST(parsed.ast, options);\n    }\n    return parsed;\n  },\n\n  formatAST(ast, options) {\n    options = normalizeOptions(options);\n    const doc = printAstToDoc(ast, options);\n    return printDocToString(doc, options);\n  },\n\n  // Doesn't handle shebang for now\n  formatDoc(doc, options) {\n    return format(printDocToDebug(doc), { ...options, parser: \"babel\" })\n      .formatted;\n  },\n\n  printToDoc(originalText, options) {\n    options = normalizeOptions(options);\n    const { ast, text } = parser.parse(originalText, options);\n    attachComments(text, ast, options);\n    return printAstToDoc(ast, options);\n  },\n\n  printDocToString(doc, options) {\n    return printDocToString(doc, normalizeOptions(options));\n  },\n};"
    },
    "3": {
        "bug_file": "src/language-js/parser-babel.js",
        "compressed": "NO",
        "line_numbers": 286,
        "compressed_line_numbers": 286,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst {\n  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n  getShebang,\n} = require(\"../common/util\");\nconst { hasPragma } = require(\"./pragma\");\nconst { locStart, locEnd } = require(\"./loc\");\nconst postprocess = require(\"./parse-postprocess\");\n\nfunction babelOptions({ sourceType, extraPlugins = [] }) {\n  return {\n    sourceType,\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowUndeclaredExports: true,\n    errorRecovery: true,\n    createParenthesizedExpressions: true,\n    plugins: [\n      // When adding a plugin, please add a test in `tests/js/babel-plugins`,\n      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify\n\n      \"doExpressions\",\n      \"classProperties\",\n      \"exportDefaultFrom\",\n      \"functionBind\",\n      \"functionSent\",\n      \"classPrivateProperties\",\n      \"throwExpressions\",\n      \"classPrivateMethods\",\n      \"v8intrinsic\",\n      \"partialApplication\",\n      [\"decorators\", { decoratorsBeforeExport: false }],\n      \"privateIn\",\n      \"importAssertions\",\n      [\"recordAndTuple\", { syntaxType: \"hash\" }],\n      \"decimal\",\n      \"moduleStringNames\",\n      \"classStaticBlock\",\n      ...extraPlugins,\n    ],\n    tokens: true,\n    ranges: true,\n  };\n}\n\nfunction resolvePluginsConflict(\n  condition,\n  pluginCombinations,\n  conflictPlugins\n) {\n  if (!condition) {\n    return pluginCombinations;\n  }\n  const combinations = [];\n  for (const combination of pluginCombinations) {\n    for (const plugin of conflictPlugins) {\n      combinations.push([...combination, plugin]);\n    }\n  }\n  return combinations;\n}\n\n// Similar to babel\n// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67\nconst FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;\nfunction isFlowFile(text, options) {\n  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {\n    return true;\n  }\n\n  const shebang = getShebang(text);\n  if (shebang) {\n    text = text.slice(shebang.length);\n  }\n\n  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(\n    text,\n    0\n  );\n\n  if (firstNonSpaceNonCommentCharacterIndex !== false) {\n    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);\n  }\n\n  return FLOW_PRAGMA_REGEX.test(text);\n}\n\nfunction createParse(parseMethod, ...pluginCombinations) {\n  return (text, parsers, opts = {}) => {\n    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {\n      opts.parser = \"babel-flow\";\n      return parseFlow(text, parsers, opts);\n    }\n\n    // Inline the require to avoid loading all the JS if we don't use it\n    const babel = require(\"@babel/parser\");\n\n    const sourceType =\n      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";\n\n    let ast;\n    try {\n      const combinations = resolvePluginsConflict(\n        text.includes(\"|>\"),\n        pluginCombinations,\n        [\n          [\"pipelineOperator\", { proposal: \"smart\" }],\n          [\"pipelineOperator\", { proposal: \"minimal\" }],\n          [\"pipelineOperator\", { proposal: \"fsharp\" }],\n        ]\n      );\n      ast = tryCombinations(\n        (options) => babel[parseMethod](text, options),\n        combinations.map((extraPlugins) =>\n          babelOptions({ sourceType, extraPlugins })\n        )\n      );\n    } catch (error) {\n      // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      const { message, loc } = error;\n\n      throw createError(message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: loc ? loc.line : 0,\n          column: loc ? loc.column + 1 : 0,\n        },\n      });\n    }\n\n    return postprocess(ast, { ...opts, originalText: text });\n  };\n}\n\nconst parse = createParse(\"parse\", [\"jsx\", \"flow\"]);\nconst parseFlow = createParse(\"parse\", [\n  \"jsx\",\n  [\"flow\", { all: true, enums: true }],\n]);\nconst parseTypeScript = createParse(\n  \"parse\",\n  [\"jsx\", \"typescript\"],\n  [\"typescript\"]\n);\nconst parseExpression = createParse(\"parseExpression\", [\"jsx\"]);\n\nfunction tryCombinations(fn, combinations) {\n  let error;\n  for (let i = 0; i < combinations.length; i++) {\n    try {\n      return rethrowSomeRecoveredErrors(fn(combinations[i]));\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n  throw error;\n}\n\nconst messagesShouldThrow = new Set([\n  // TSErrors.UnexpectedTypeAnnotation\n  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95\n  \"Did not expect a type annotation here.\",\n  // ErrorMessages.ModuleAttributeDifferentFromType\n  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92\n  \"The only accepted module attribute is `type`\",\n  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction\n  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118\n  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",\n]);\n\nfunction shouldRethrow(error) {\n  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);\n  // Only works for literal message\n  return messagesShouldThrow.has(message);\n}\n\nfunction rethrowSomeRecoveredErrors(ast) {\n  const error = ast.errors.find((error) => shouldRethrow(error));\n  if (error) {\n    throw error;\n  }\n\n  return ast;\n}\n\nfunction parseJson(text, parsers, opts) {\n  const ast = parseExpression(text, parsers, opts);\n\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n    case \"ObjectProperty\":\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      }\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n      return [node.key, node.value].forEach(assertJsonChildNode);\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        default:\n          throw createJsonError(\"operator\");\n      }\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n      throw createJsonError();\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  }\n\n  function createJsonError(attribute) {\n    const name = !attribute\n      ? node.type\n      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;\n    return createError(`${name} is not allowed in JSON.`, {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1,\n      },\n    });\n  }\n}\n\nconst babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };\nconst babelFlow = { ...babel, parse: parseFlow };\nconst babelTypeScript = { ...babel, parse: parseTypeScript };\nconst babelExpression = { ...babel, parse: parseExpression };\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    babel,\n    \"babel-flow\": babelFlow,\n    \"babel-ts\": babelTypeScript,\n    json: {\n      ...babelExpression,\n      hasPragma() {\n        return true;\n      },\n    },\n    json5: babelExpression,\n    \"json-stringify\": {\n      parse: parseJson,\n      astFormat: \"estree-json\",\n      locStart,\n      locEnd,\n    },\n    /** @internal */\n    __js_expression: babelExpression,\n    /** for vue filter */\n    __vue_expression: babelExpression,\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel,\n  },\n};"
    },
    "4": {
        "bug_file": "src/language-js/options.js",
        "compressed": "NO",
        "line_numbers": 100,
        "compressed_line_numbers": 100,
        "compressed_bug_file_content": "\"use strict\";\n\nconst commonOptions = require(\"../common/common-options\");\n\nconst CATEGORY_JAVASCRIPT = \"JavaScript\";\n\n// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\nmodule.exports = {\n  arrowParens: {\n    since: \"1.9.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: [\n      { since: \"1.9.0\", value: \"avoid\" },\n      { since: \"2.0.0\", value: \"always\" },\n    ],\n    description: \"Include parentheses around a sole arrow function parameter.\",\n    choices: [\n      {\n        value: \"always\",\n        description: \"Always include parens. Example: `(x) => x`\",\n      },\n      {\n        value: \"avoid\",\n        description: \"Omit parens when possible. Example: `x => x`\",\n      },\n    ],\n  },\n  bracketSpacing: commonOptions.bracketSpacing,\n  jsxBracketSameLine: {\n    since: \"0.17.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Put > on the last line instead of at a new line.\",\n  },\n  semi: {\n    since: \"1.0.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: true,\n    description: \"Print semicolons.\",\n    oppositeDescription:\n      \"Do not print semicolons, except at the beginning of lines which may need them.\",\n  },\n  singleQuote: commonOptions.singleQuote,\n  jsxSingleQuote: {\n    since: \"1.15.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Use single quotes in JSX.\",\n  },\n  quoteProps: {\n    since: \"1.17.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"as-needed\",\n    description: \"Change when properties in objects are quoted.\",\n    choices: [\n      {\n        value: \"as-needed\",\n        description: \"Only add quotes around object properties where required.\",\n      },\n      {\n        value: \"consistent\",\n        description:\n          \"If at least one property in an object requires quotes, quote all properties.\",\n      },\n      {\n        value: \"preserve\",\n        description: \"Respect the input use of quotes in object properties.\",\n      },\n    ],\n  },\n  trailingComma: {\n    since: \"0.0.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: [\n      { since: \"0.0.0\", value: false },\n      { since: \"0.19.0\", value: \"none\" },\n      { since: \"2.0.0\", value: \"es5\" },\n    ],\n    description: \"Print trailing commas wherever possible when multi-line.\",\n    choices: [\n      {\n        value: \"es5\",\n        description:\n          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",\n      },\n      { value: \"none\", description: \"No trailing commas.\" },\n      {\n        value: \"all\",\n        description:\n          \"Trailing commas wherever possible (including function arguments).\",\n      },\n    ],\n  },\n};"
    },
    "5": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 1304,
        "compressed_line_numbers": 117,
        "compressed_bug_file_content": "\n\n/** @typedef {import(\"../document\").Doc} Doc */\n\n/** @type {import(\"assert\")} */\n\n\n// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\n    // their decorators are handled themselves\n\n\n    // If the parent node is an export declaration and the decorator\n    // was written before the export, the export will be responsible\n    // for printing the decorators.\n\n\n    // Only print decorators here if they were written before the export,\n    // otherwise they are printed by the node.declaration\n\n\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n\n\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n\n\n  /** @type{Doc[]} */\n\n\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n\n\n      // Babel 6\n\n\n      // Only force a trailing newline if there were any contents.\n\n\n    // Babel extension.\n\n\n      // Detect Flow and TypeScript directives\n\n\n      // Do not append semicolon after the only JSX element in a program\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n    // Babel 6\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // babel: n.extra.raw, flow: n.bigint\n\n\n      // typescript\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n        /* sameLine */ true\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n\n      /* istanbul ignore next */\n\n\n                /* sameIndent */ true\n\n\n    // fall through\n\n\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n\n      // babel use `id`, meriyah use `name`\n\n\n      /* istanbul ignore next */\n\n\n    // TODO: Make this as default behavior\n\n\n"
    }
}