{
    "1": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 845,
        "compressed_line_numbers": 76,
        "compressed_bug_file_content": "\n\n/** @typedef {import(\"../document\").Doc} Doc */\n\n// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\n  // Their decorators are handled themselves, and they can't have parentheses\n\n\n  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons\n\n\n    // In member-chain print, it add `label` to the doc, if we return array here it will be broken\n\n\n  /** @type{Doc[]} */\n\n\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n\n\n    // Babel extension.\n\n\n        /** sameIndent */ true,\n\n\n      // Do not append semicolon after the only JSX element in a program\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n    // Babel 6\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n        /* sameLine */ true\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n    // For hack-style pipeline\n\n\n      /* istanbul ignore next */\n\n\n    // `babel-ts` don't have similar node for `class Foo { bar() /* bat */; }`\n\n\n    // TODO: Make this as default behavior\n\n\n"
    },
    "2": {
        "bug_file": "src/language-js/needs-parens.js",
        "compressed": "YES",
        "line_numbers": 1026,
        "compressed_line_numbers": 128,
        "compressed_bug_file_content": "\n\n  // to avoid unexpected `}}` in HTML interpolations\n\n\n  // Only statements don't need parentheses.\n\n\n    // Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n    // parser. The Flow parser turns Flow comments into type annotation nodes in its\n    // AST, which we handle separately.\n\n\n  // Identifiers never need parentheses.\n\n    // ...unless those identifiers are embed placeholders. They might be substituted by complex\n    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n    //     let tpl = html`<script> f((${expr}) / 2); </script>`;\n    // If the inner JS formatter removes the parens, the expression might change its meaning:\n    //     f((a + b) / 2)  vs  f(a + b / 2)\n\n\n    // `for ((async) of []);` and `for ((let) of []);`\n\n\n    // `for ((let.a) of []);`\n\n\n    // `(let)[a] = 1`\n\n\n      // Add parens around the extends clause of a class. It is needed for almost\n      // all expressions.\n\n\n        // `export default function` or `export default class` can't be followed by\n        // anything after. So an expression like `export default (function(){}).toString()`\n        // needs to be followed by a parentheses\n\n        // `export default (foo, bar)` also needs parentheses\n\n\n                /** @(x().y) */ hasMemberExpression ||\n                /** @(x().y()) */ hasCallExpression\n\n\n              // babel-parser cannot parse\n              //   @foo`bar`\n\n\n    // else fallthrough\n\n\n      // We add parentheses to any `a in b` inside `ForStatement` initializer\n      // https://github.com/prettier/prettier/issues/907#issuecomment-284304321\n\n\n    // fallthrough\n\n\n          // example: foo as unknown as Bar\n\n\n        // else fallthrough\n\n\n          // Add parenthesis when working with bitwise operators\n          // It's not strictly needed but helps with code understanding\n\n\n          // Although parentheses wouldn't hurt around sequence\n          // expressions in the head of for loops, traditional style\n          // dictates that e.g. i++, j++ should not be wrapped with\n          // parentheses.\n\n\n          // We do need parentheses, but SequenceExpressions are handled\n          // specially when printing bodies of arrow functions.\n\n\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n\n\n    // else fallthrough\n\n\n    // fallthrough\n\n\n    // fallthrough\n\n\n    // fallthrough\n\n\n    // fallthrough\n\n\n        // We should check ancestor's parent to know whether the parentheses\n        // are really needed, but since ??T doesn't make sense this check\n        // will almost never be true.\n\n        // See #5283\n\n\n        // To avoid becoming a directive\n\n\n          // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n          // Is necessary if it is `expression` of `ExpressionStatement`.\n\n\n    // fallthrough\n\n\n            // tagged templates are basically member expressions from a grammar perspective\n            // see https://tc39.github.io/ecma262/#prod-MemberExpression\n\n\n          // Preserve parens for compatibility with AngularJS expressions\n\n\n      // in some cases the function is already wrapped\n      // (e.g. `export default (function() {})();`)\n      // in this case we don't need to add extra parens\n\n\n"
    },
    "3": {
        "bug_file": "src/main/core.js",
        "compressed": "NO",
        "line_numbers": 365,
        "compressed_line_numbers": 365,
        "compressed_bug_file_content": "\"use strict\";\n\nconst { diffArrays } = require(\"diff\");\n\nconst {\n  printer: { printDocToString },\n  debug: { printDocToDebug },\n} = require(\"../document/index.js\");\nconst { getAlignmentSize } = require(\"../common/util.js\");\nconst {\n  guessEndOfLine,\n  convertEndOfLineToChars,\n  countEndOfLineChars,\n  normalizeEndOfLine,\n} = require(\"../common/end-of-line.js\");\nconst normalizeOptions = require(\"./options.js\").normalize;\nconst massageAST = require(\"./massage-ast.js\");\nconst comments = require(\"./comments.js\");\nconst parser = require(\"./parser.js\");\nconst printAstToDoc = require(\"./ast-to-doc.js\");\nconst rangeUtil = require(\"./range-util.js\");\n\nconst BOM = \"\\uFEFF\";\n\nconst CURSOR = Symbol(\"cursor\");\n\nfunction attachComments(text, ast, opts) {\n  const astComments = ast.comments;\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n  opts[Symbol.for(\"comments\")] = astComments || [];\n  opts[Symbol.for(\"tokens\")] = ast.tokens || [];\n  opts.originalText = text;\n  return astComments;\n}\n\nfunction coreFormat(originalText, opts, addAlignmentSize = 0) {\n  if (!originalText || originalText.trim().length === 0) {\n    return { formatted: \"\", cursorOffset: -1, comments: [] };\n  }\n\n  const { ast, text } = parser.parse(originalText, opts);\n\n  if (opts.cursorOffset >= 0) {\n    const nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n    if (nodeResult && nodeResult.node) {\n      opts.cursorNode = nodeResult.node;\n    }\n  }\n\n  const astComments = attachComments(text, ast, opts);\n  const doc = printAstToDoc(ast, opts, addAlignmentSize);\n\n  const result = printDocToString(doc, opts);\n\n  comments.ensureAllCommentsPrinted(astComments);\n  // Remove extra leading indentation as well as the added indentation after last newline\n  if (addAlignmentSize > 0) {\n    const trimmed = result.formatted.trim();\n\n    if (result.cursorNodeStart !== undefined) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n\n  if (opts.cursorOffset >= 0) {\n    let oldCursorNodeStart;\n    let oldCursorNodeText;\n\n    let cursorOffsetRelativeToOldCursorNode;\n\n    let newCursorNodeStart;\n    let newCursorNodeText;\n\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(\n        oldCursorNodeStart,\n        opts.locEnd(opts.cursorNode)\n      );\n\n      cursorOffsetRelativeToOldCursorNode =\n        opts.cursorOffset - oldCursorNodeStart;\n\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,\n        comments: astComments,\n      };\n    }\n\n    // diff old and new cursor node texts, with a special cursor\n    // symbol inserted to find out where it moves to\n\n    const oldCursorNodeCharArray = [...oldCursorNodeText];\n    oldCursorNodeCharArray.splice(\n      cursorOffsetRelativeToOldCursorNode,\n      0,\n      CURSOR\n    );\n\n    const newCursorNodeCharArray = [...newCursorNodeText];\n\n    const cursorNodeDiff = diffArrays(\n      oldCursorNodeCharArray,\n      newCursorNodeCharArray\n    );\n\n    let cursorOffset = newCursorNodeStart;\n    for (const entry of cursorNodeDiff) {\n      if (entry.removed) {\n        if (entry.value.includes(CURSOR)) {\n          break;\n        }\n      } else {\n        cursorOffset += entry.count;\n      }\n    }\n\n    return { formatted: result.formatted, cursorOffset, comments: astComments };\n  }\n\n  return {\n    formatted: result.formatted,\n    cursorOffset: -1,\n    comments: astComments,\n  };\n}\n\nfunction formatRange(originalText, opts) {\n  const { ast, text } = parser.parse(originalText, opts);\n  const { rangeStart, rangeEnd } = rangeUtil.calculateRange(text, opts, ast);\n  const rangeString = text.slice(rangeStart, rangeEnd);\n\n  // Try to extend the range backwards to the beginning of the line.\n  // This is so we can detect indentation correctly and restore it.\n  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n  const rangeStart2 = Math.min(\n    rangeStart,\n    text.lastIndexOf(\"\\n\", rangeStart) + 1\n  );\n  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];\n\n  const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);\n\n  const rangeResult = coreFormat(\n    rangeString,\n    {\n      ...opts,\n      rangeStart: 0,\n      rangeEnd: Number.POSITIVE_INFINITY,\n      // Track the cursor offset only if it's within our range\n      cursorOffset:\n        opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd\n          ? opts.cursorOffset - rangeStart\n          : -1,\n      // Always use `lf` to format, we'll replace it later\n      endOfLine: \"lf\",\n    },\n    alignmentSize\n  );\n\n  // Since the range contracts to avoid trailing whitespace,\n  // we need to remove the newline that was inserted by the `format` call.\n  const rangeTrimmed = rangeResult.formatted.trimEnd();\n\n  let { cursorOffset } = opts;\n  if (cursorOffset > rangeEnd) {\n    // handle the case where the cursor was past the end of the range\n    cursorOffset += rangeTrimmed.length - rangeString.length;\n  } else if (rangeResult.cursorOffset >= 0) {\n    // handle the case where the cursor was in the range\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  }\n  // keep the cursor as it was if it was before the start of the range\n\n  let formatted =\n    text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);\n  if (opts.endOfLine !== \"lf\") {\n    const eol = convertEndOfLineToChars(opts.endOfLine);\n    if (cursorOffset >= 0 && eol === \"\\r\\n\") {\n      cursorOffset += countEndOfLineChars(\n        formatted.slice(0, cursorOffset),\n        \"\\n\"\n      );\n    }\n\n    formatted = formatted.replace(/\\n/g, eol);\n  }\n\n  return { formatted, cursorOffset, comments: rangeResult.comments };\n}\n\nfunction ensureIndexInText(text, index, defaultValue) {\n  if (\n    typeof index !== \"number\" ||\n    Number.isNaN(index) ||\n    index < 0 ||\n    index > text.length\n  ) {\n    return defaultValue;\n  }\n\n  return index;\n}\n\nfunction normalizeIndexes(text, options) {\n  let { cursorOffset, rangeStart, rangeEnd } = options;\n  cursorOffset = ensureIndexInText(text, cursorOffset, -1);\n  rangeStart = ensureIndexInText(text, rangeStart, 0);\n  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);\n\n  return { ...options, cursorOffset, rangeStart, rangeEnd };\n}\n\nfunction normalizeInputAndOptions(text, options) {\n  let { cursorOffset, rangeStart, rangeEnd, endOfLine } = normalizeIndexes(\n    text,\n    options\n  );\n\n  const hasBOM = text.charAt(0) === BOM;\n\n  if (hasBOM) {\n    text = text.slice(1);\n    cursorOffset--;\n    rangeStart--;\n    rangeEnd--;\n  }\n\n  if (endOfLine === \"auto\") {\n    endOfLine = guessEndOfLine(text);\n  }\n\n  // get rid of CR/CRLF parsing\n  if (text.includes(\"\\r\")) {\n    const countCrlfBefore = (index) =>\n      countEndOfLineChars(text.slice(0, Math.max(index, 0)), \"\\r\\n\");\n\n    cursorOffset -= countCrlfBefore(cursorOffset);\n    rangeStart -= countCrlfBefore(rangeStart);\n    rangeEnd -= countCrlfBefore(rangeEnd);\n\n    text = normalizeEndOfLine(text);\n  }\n\n  return {\n    hasBOM,\n    text,\n    options: normalizeIndexes(text, {\n      ...options,\n      cursorOffset,\n      rangeStart,\n      rangeEnd,\n      endOfLine,\n    }),\n  };\n}\n\nfunction hasPragma(text, options) {\n  const selectedParser = parser.resolveParser(options);\n  return !selectedParser.hasPragma || selectedParser.hasPragma(text);\n}\n\nfunction formatWithCursor(originalText, originalOptions) {\n  let { hasBOM, text, options } = normalizeInputAndOptions(\n    originalText,\n    normalizeOptions(originalOptions)\n  );\n\n  if (\n    (options.rangeStart >= options.rangeEnd && text !== \"\") ||\n    (options.requirePragma && !hasPragma(text, options))\n  ) {\n    return {\n      formatted: originalText,\n      cursorOffset: originalOptions.cursorOffset,\n      comments: [],\n    };\n  }\n\n  let result;\n\n  if (options.rangeStart > 0 || options.rangeEnd < text.length) {\n    result = formatRange(text, options);\n  } else {\n    if (\n      !options.requirePragma &&\n      options.insertPragma &&\n      options.printer.insertPragma &&\n      !hasPragma(text, options)\n    ) {\n      text = options.printer.insertPragma(text);\n    }\n    result = coreFormat(text, options);\n  }\n\n  if (hasBOM) {\n    result.formatted = BOM + result.formatted;\n\n    if (result.cursorOffset >= 0) {\n      result.cursorOffset++;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  formatWithCursor,\n\n  parse(originalText, originalOptions, massage) {\n    const { text, options } = normalizeInputAndOptions(\n      originalText,\n      normalizeOptions(originalOptions)\n    );\n    const parsed = parser.parse(text, options);\n    if (massage) {\n      parsed.ast = massageAST(parsed.ast, options);\n    }\n    return parsed;\n  },\n\n  formatAST(ast, options) {\n    options = normalizeOptions(options);\n    const doc = printAstToDoc(ast, options);\n    return printDocToString(doc, options);\n  },\n\n  // Doesn't handle shebang for now\n  formatDoc(doc, options) {\n    return formatWithCursor(printDocToDebug(doc), {\n      ...options,\n      parser: \"__js_expression\",\n    }).formatted;\n  },\n\n  printToDoc(originalText, options) {\n    options = normalizeOptions(options);\n    const { ast, text } = parser.parse(originalText, options);\n    attachComments(text, ast, options);\n    return printAstToDoc(ast, options);\n  },\n\n  printDocToString(doc, options) {\n    return printDocToString(doc, normalizeOptions(options));\n  },\n};"
    },
    "4": {
        "bug_file": "src/language-js/index.js",
        "compressed": "NO",
        "line_numbers": 121,
        "compressed_line_numbers": 121,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createLanguage = require(\"../utils/create-language.js\");\nconst estreePrinter = require(\"./printer-estree.js\");\nconst estreeJsonPrinter = require(\"./printer-estree-json.js\");\nconst options = require(\"./options.js\");\nconst parsers = require(\"./parse/parsers.js\");\n\nconst languages = [\n  createLanguage(\n    require(\"linguist-languages/data/JavaScript.json\"),\n    (data) => ({\n      since: \"0.0.0\",\n      parsers: [\n        \"babel\",\n        \"acorn\",\n        \"espree\",\n        \"meriyah\",\n        \"babel-flow\",\n        \"babel-ts\",\n        \"flow\",\n        \"typescript\",\n      ],\n      vscodeLanguageIds: [\"javascript\", \"mongo\"],\n      interpreters: [\n        ...data.interpreters,\n        // https://github.com/google/zx\n        \"zx\",\n      ],\n      extensions: [\n        ...data.extensions.filter((extension) => extension !== \".jsx\"),\n        // WeiXin Script (Weixin Mini Programs)\n        // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/\n        \".wxs\",\n      ],\n    })\n  ),\n  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({\n    name: \"Flow\",\n    since: \"0.0.0\",\n    parsers: [\"flow\", \"babel-flow\"],\n    vscodeLanguageIds: [\"javascript\"],\n    aliases: [],\n    filenames: [],\n    extensions: [\".js.flow\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({\n    name: \"JSX\",\n    since: \"0.0.0\",\n    parsers: [\n      \"babel\",\n      \"babel-flow\",\n      \"babel-ts\",\n      \"flow\",\n      \"typescript\",\n      \"espree\",\n      \"meriyah\",\n    ],\n    vscodeLanguageIds: [\"javascriptreact\"],\n    aliases: undefined,\n    filenames: undefined,\n    extensions: [\".jsx\"],\n    group: \"JavaScript\",\n    interpreters: undefined,\n    tmScope: \"source.js.jsx\",\n    aceMode: \"javascript\",\n    codemirrorMode: \"jsx\",\n    codemirrorMimeType: \"text/jsx\",\n    color: undefined,\n  })),\n  createLanguage(require(\"linguist-languages/data/TypeScript.json\"), () => ({\n    since: \"1.4.0\",\n    parsers: [\"typescript\", \"babel-ts\"],\n    vscodeLanguageIds: [\"typescript\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/TSX.json\"), () => ({\n    since: \"1.4.0\",\n    parsers: [\"typescript\", \"babel-ts\"],\n    vscodeLanguageIds: [\"typescriptreact\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JSON.json\"), () => ({\n    name: \"JSON.stringify\",\n    since: \"1.13.0\",\n    parsers: [\"json-stringify\"],\n    vscodeLanguageIds: [\"json\"],\n    extensions: [\".importmap\"], // .json file defaults to json instead of json-stringify\n    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JSON.json\"), (data) => ({\n    since: \"1.5.0\",\n    parsers: [\"json\"],\n    vscodeLanguageIds: [\"json\"],\n    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),\n  })),\n  createLanguage(\n    require(\"linguist-languages/data/JSON with Comments.json\"),\n    (data) => ({\n      since: \"1.5.0\",\n      parsers: [\"json\"],\n      vscodeLanguageIds: [\"jsonc\"],\n      filenames: [...data.filenames, \".eslintrc\", \".swcrc\"],\n    })\n  ),\n  createLanguage(require(\"linguist-languages/data/JSON5.json\"), () => ({\n    since: \"1.13.0\",\n    parsers: [\"json5\"],\n    vscodeLanguageIds: [\"json5\"],\n  })),\n];\n\nconst printers = {\n  estree: estreePrinter,\n  \"estree-json\": estreeJsonPrinter,\n};\n\nmodule.exports = {\n  languages,\n  options,\n  printers,\n  parsers,\n};"
    },
    "5": {
        "bug_file": "src/language-js/print/object.js",
        "compressed": "NO",
        "line_numbers": 246,
        "compressed_line_numbers": 246,
        "compressed_bug_file_content": "\"use strict\";\n\nconst { printDanglingComments } = require(\"../../main/comments.js\");\nconst {\n  builders: { line, softline, group, indent, ifBreak, hardline },\n} = require(\"../../document/index.js\");\nconst {\n  getLast,\n  hasNewlineInRange,\n  hasNewline,\n  isNonEmptyArray,\n} = require(\"../../common/util.js\");\nconst {\n  shouldPrintComma,\n  hasComment,\n  getComments,\n  CommentCheckFlags,\n  isNextLineEmpty,\n} = require(\"../utils/index.js\");\nconst { locStart, locEnd } = require(\"../loc.js\");\n\nconst { printOptionalToken, printTypeAnnotation } = require(\"./misc.js\");\nconst { shouldHugFunctionParameters } = require(\"./function-parameters.js\");\nconst { shouldHugType } = require(\"./type-annotation.js\");\nconst { printHardlineAfterHeritage } = require(\"./class.js\");\n\n/** @typedef {import(\"../../document\").Doc} Doc */\n\nfunction printObject(path, options, print) {\n  const semi = options.semi ? \";\" : \"\";\n  const node = path.getValue();\n\n  let propertiesField;\n\n  if (node.type === \"TSTypeLiteral\") {\n    propertiesField = \"members\";\n  } else if (node.type === \"TSInterfaceBody\") {\n    propertiesField = \"body\";\n  } else {\n    propertiesField = \"properties\";\n  }\n\n  const isTypeAnnotation = node.type === \"ObjectTypeAnnotation\";\n  const fields = [propertiesField];\n  if (isTypeAnnotation) {\n    fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n  }\n\n  const firstProperty = fields\n    .map((field) => node[field][0])\n    .sort((a, b) => locStart(a) - locStart(b))[0];\n\n  const parent = path.getParentNode(0);\n  const isFlowInterfaceLikeBody =\n    isTypeAnnotation &&\n    parent &&\n    (parent.type === \"InterfaceDeclaration\" ||\n      parent.type === \"DeclareInterface\" ||\n      parent.type === \"DeclareClass\") &&\n    path.getName() === \"body\";\n  const shouldBreak =\n    node.type === \"TSInterfaceBody\" ||\n    isFlowInterfaceLikeBody ||\n    (node.type === \"ObjectPattern\" &&\n      parent.type !== \"FunctionDeclaration\" &&\n      parent.type !== \"FunctionExpression\" &&\n      parent.type !== \"ArrowFunctionExpression\" &&\n      parent.type !== \"ObjectMethod\" &&\n      parent.type !== \"ClassMethod\" &&\n      parent.type !== \"ClassPrivateMethod\" &&\n      parent.type !== \"AssignmentPattern\" &&\n      parent.type !== \"CatchClause\" &&\n      node.properties.some(\n        (property) =>\n          property.value &&\n          (property.value.type === \"ObjectPattern\" ||\n            property.value.type === \"ArrayPattern\")\n      )) ||\n    (node.type !== \"ObjectPattern\" &&\n      firstProperty &&\n      hasNewlineInRange(\n        options.originalText,\n        locStart(node),\n        locStart(firstProperty)\n      ));\n\n  const separator = isFlowInterfaceLikeBody\n    ? \";\"\n    : node.type === \"TSInterfaceBody\" || node.type === \"TSTypeLiteral\"\n    ? ifBreak(semi, \";\")\n    : \",\";\n  const leftBrace =\n    node.type === \"RecordExpression\" ? \"#{\" : node.exact ? \"{|\" : \"{\";\n  const rightBrace = node.exact ? \"|}\" : \"}\";\n\n  // Unfortunately, things are grouped together in the ast can be\n  // interleaved in the source code. So we need to reorder them before\n  // printing them.\n  const propsAndLoc = [];\n  for (const field of fields) {\n    path.each((childPath) => {\n      const node = childPath.getValue();\n      propsAndLoc.push({\n        node,\n        printed: print(),\n        loc: locStart(node),\n      });\n    }, field);\n  }\n\n  if (fields.length > 1) {\n    propsAndLoc.sort((a, b) => a.loc - b.loc);\n  }\n\n  /** @type {Doc[]} */\n  let separatorParts = [];\n  const props = propsAndLoc.map((prop) => {\n    const result = [...separatorParts, group(prop.printed)];\n    separatorParts = [separator, line];\n    if (\n      (prop.node.type === \"TSPropertySignature\" ||\n        prop.node.type === \"TSMethodSignature\" ||\n        prop.node.type === \"TSConstructSignatureDeclaration\") &&\n      hasComment(prop.node, CommentCheckFlags.PrettierIgnore)\n    ) {\n      separatorParts.shift();\n    }\n    if (isNextLineEmpty(prop.node, options)) {\n      separatorParts.push(hardline);\n    }\n    return result;\n  });\n\n  if (node.inexact) {\n    let printed;\n    if (hasComment(node, CommentCheckFlags.Dangling)) {\n      const hasLineComments = hasComment(node, CommentCheckFlags.Line);\n      const printedDanglingComments = printDanglingComments(\n        path,\n        options,\n        /* sameIndent */ true\n      );\n      printed = [\n        printedDanglingComments,\n        hasLineComments ||\n        hasNewline(options.originalText, locEnd(getLast(getComments(node))))\n          ? hardline\n          : line,\n        \"...\",\n      ];\n    } else {\n      printed = [\"...\"];\n    }\n    props.push([...separatorParts, ...printed]);\n  }\n\n  const lastElem = getLast(node[propertiesField]);\n\n  const canHaveTrailingSeparator = !(\n    node.inexact ||\n    (lastElem && lastElem.type === \"RestElement\") ||\n    (lastElem &&\n      (lastElem.type === \"TSPropertySignature\" ||\n        lastElem.type === \"TSCallSignatureDeclaration\" ||\n        lastElem.type === \"TSMethodSignature\" ||\n        lastElem.type === \"TSConstructSignatureDeclaration\") &&\n      hasComment(lastElem, CommentCheckFlags.PrettierIgnore))\n  );\n\n  let content;\n  if (props.length === 0) {\n    if (!hasComment(node, CommentCheckFlags.Dangling)) {\n      return [leftBrace, rightBrace, printTypeAnnotation(path, options, print)];\n    }\n\n    content = group([\n      leftBrace,\n      printDanglingComments(path, options),\n      softline,\n      rightBrace,\n      printOptionalToken(path),\n      printTypeAnnotation(path, options, print),\n    ]);\n  } else {\n    content = [\n      isFlowInterfaceLikeBody && isNonEmptyArray(node.properties)\n        ? printHardlineAfterHeritage(parent)\n        : \"\",\n      leftBrace,\n      indent([options.bracketSpacing ? line : softline, ...props]),\n      ifBreak(\n        canHaveTrailingSeparator &&\n          (separator !== \",\" || shouldPrintComma(options))\n          ? separator\n          : \"\"\n      ),\n      options.bracketSpacing ? line : softline,\n      rightBrace,\n      printOptionalToken(path),\n      printTypeAnnotation(path, options, print),\n    ];\n  }\n\n  // If we inline the object as first argument of the parent, we don't want\n  // to create another group so that the object breaks before the return\n  // type\n  if (\n    path.match(\n      (node) => node.type === \"ObjectPattern\" && !node.decorators,\n      (node, name, number) =>\n        shouldHugFunctionParameters(node) &&\n        (name === \"params\" ||\n          name === \"parameters\" ||\n          name === \"this\" ||\n          name === \"rest\") &&\n        number === 0\n    ) ||\n    path.match(\n      shouldHugType,\n      (node, name) => name === \"typeAnnotation\",\n      (node, name) => name === \"typeAnnotation\",\n      (node, name, number) =>\n        shouldHugFunctionParameters(node) &&\n        (name === \"params\" ||\n          name === \"parameters\" ||\n          name === \"this\" ||\n          name === \"rest\") &&\n        number === 0\n    ) ||\n    // Assignment printing logic (printAssignment) is responsible\n    // for adding a group if needed\n    (!shouldBreak &&\n      path.match(\n        (node) => node.type === \"ObjectPattern\",\n        (node) =>\n          node.type === \"AssignmentExpression\" ||\n          node.type === \"VariableDeclarator\"\n      ))\n  ) {\n    return content;\n  }\n\n  return group(content, { shouldBreak });\n}\n\nmodule.exports = { printObject };"
    },
    "6": {
        "bug_file": "src/main/options.js",
        "compressed": "NO",
        "line_numbers": 156,
        "compressed_line_numbers": 156,
        "compressed_bug_file_content": "\"use strict\";\n\nconst path = require(\"path\");\nconst { UndefinedParserError } = require(\"../common/errors.js\");\nconst { getSupportInfo } = require(\"../main/support.js\");\nconst normalizer = require(\"./options-normalizer.js\");\nconst { resolveParser } = require(\"./parser.js\");\n\nconst hiddenDefaults = {\n  astFormat: \"estree\",\n  printer: {},\n  originalText: undefined,\n  locStart: null,\n  locEnd: null,\n};\n\n// Copy options and fill in default values.\nfunction normalize(options, opts = {}) {\n  const rawOptions = { ...options };\n\n  const supportOptions = getSupportInfo({\n    plugins: options.plugins,\n    showUnreleased: true,\n    showDeprecated: true,\n  }).options;\n\n  const defaults = {\n    ...hiddenDefaults,\n    ...Object.fromEntries(\n      supportOptions\n        .filter((optionInfo) => optionInfo.default !== undefined)\n        .map((option) => [option.name, option.default])\n    ),\n  };\n  if (!rawOptions.parser) {\n    if (!rawOptions.filepath) {\n      const logger = opts.logger || console;\n      logger.warn(\n        \"No parser and no filepath given, using 'babel' the parser now \" +\n          \"but this will throw an error in the future. \" +\n          \"Please specify a parser or a filepath so one can be inferred.\"\n      );\n      rawOptions.parser = \"babel\";\n    } else {\n      rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);\n      if (!rawOptions.parser) {\n        throw new UndefinedParserError(\n          `No parser could be inferred for file: ${rawOptions.filepath}`\n        );\n      }\n    }\n  }\n\n  const parser = resolveParser(\n    normalizer.normalizeApiOptions(\n      rawOptions,\n      [supportOptions.find((x) => x.name === \"parser\")],\n      { passThrough: true, logger: false }\n    )\n  );\n  rawOptions.astFormat = parser.astFormat;\n  rawOptions.locEnd = parser.locEnd;\n  rawOptions.locStart = parser.locStart;\n\n  const plugin = getPlugin(rawOptions);\n  rawOptions.printer = plugin.printers[rawOptions.astFormat];\n\n  const pluginDefaults = Object.fromEntries(\n    supportOptions\n      .filter(\n        (optionInfo) =>\n          optionInfo.pluginDefaults &&\n          optionInfo.pluginDefaults[plugin.name] !== undefined\n      )\n      .map((optionInfo) => [\n        optionInfo.name,\n        optionInfo.pluginDefaults[plugin.name],\n      ])\n  );\n\n  const mixedDefaults = { ...defaults, ...pluginDefaults };\n\n  for (const [k, value] of Object.entries(mixedDefaults)) {\n    if (rawOptions[k] === null || rawOptions[k] === undefined) {\n      rawOptions[k] = value;\n    }\n  }\n\n  if (rawOptions.parser === \"json\") {\n    rawOptions.trailingComma = \"none\";\n  }\n\n  return normalizer.normalizeApiOptions(rawOptions, supportOptions, {\n    passThrough: Object.keys(hiddenDefaults),\n    ...opts,\n  });\n}\n\nfunction getPlugin(options) {\n  const { astFormat } = options;\n\n  // TODO: test this with plugins\n  /* istanbul ignore next */\n  if (!astFormat) {\n    throw new Error(\"getPlugin() requires astFormat to be set\");\n  }\n  const printerPlugin = options.plugins.find(\n    (plugin) => plugin.printers && plugin.printers[astFormat]\n  );\n  // TODO: test this with plugins\n  /* istanbul ignore next */\n  if (!printerPlugin) {\n    throw new Error(`Couldn't find plugin for AST format \"${astFormat}\"`);\n  }\n\n  return printerPlugin;\n}\n\nfunction inferParser(filepath, plugins) {\n  const filename = path.basename(filepath).toLowerCase();\n  const languages = getSupportInfo({ plugins }).languages.filter(\n    (language) => language.since !== null\n  );\n\n  // If the file has no extension, we can try to infer the language from the\n  // interpreter in the shebang line, if any; but since this requires FS access,\n  // do it last.\n  let language = languages.find(\n    (language) =>\n      (language.extensions &&\n        language.extensions.some((extension) =>\n          filename.endsWith(extension)\n        )) ||\n      (language.filenames &&\n        language.filenames.some((name) => name.toLowerCase() === filename))\n  );\n\n  if (\n    process.env.PRETTIER_TARGET !== \"universal\" &&\n    !language &&\n    !filename.includes(\".\")\n  ) {\n    // `getInterpreter` requires file access, put `require()` in the `if` block,\n    // So we can easily remove this part during build\n    const getInterpreter = require(\"../utils/get-interpreter.js\");\n    const interpreter = getInterpreter(filepath);\n    language = languages.find(\n      (language) =>\n        language.interpreters && language.interpreters.includes(interpreter)\n    );\n  }\n\n  return language && language.parsers[0];\n}\n\nmodule.exports = { normalize, hiddenDefaults, inferParser };"
    }
}