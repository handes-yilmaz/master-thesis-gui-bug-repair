{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/language-js/needs-parens.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const getLast = require(\"../utils/get-last.js\");",
                "const isNonEmptyArray = require(\"../utils/is-non-empty-array.js\");",
                "const {",
                "  getFunctionParameters,",
                "  getLeftSidePathName,",
                "  hasFlowShorthandAnnotationComment,",
                "  hasNakedLeftSide,",
                "  hasNode,",
                "  isBitwiseOperator,",
                "  startsWithNoLookaheadToken,",
                "  shouldFlatten,",
                "  getPrecedence,",
                "  isCallExpression,",
                "  isMemberExpression,",
                "  isObjectProperty,",
                "  isTSTypeExpression,",
                "} = require(\"./utils/index.js\");",
                "",
                "function needsParens(path, options) {",
                "  const parent = path.getParentNode();",
                "  if (!parent) {",
                "    return false;",
                "  }",
                "",
                "  const name = path.getName();",
                "  const node = path.getNode();",
                "",
                "  // to avoid unexpected `}}` in HTML interpolations",
                "  if (",
                "    options.__isInHtmlInterpolation &&",
                "    !options.bracketSpacing &&",
                "    endsWithRightBracket(node) &&",
                "    isFollowedByRightBracket(path)",
                "  ) {",
                "    return true;",
                "  }",
                "",
                "  // Only statements don't need parentheses.",
                "  if (isStatement(node)) {",
                "    return false;",
                "  }",
                "",
                "  if (",
                "    // Preserve parens if we have a Flow annotation comment, unless we're using the Flow",
                "    // parser. The Flow parser turns Flow comments into type annotation nodes in its",
                "    // AST, which we handle separately.",
                "    options.parser !== \"flow\" &&",
                "    hasFlowShorthandAnnotationComment(path.getValue())",
                "  ) {",
                "    return true;",
                "  }",
                "",
                "  // Identifiers never need parentheses.",
                "  if (node.type === \"Identifier\") {",
                "    // ...unless those identifiers are embed placeholders. They might be substituted by complex",
                "    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):",
                "    //     let tpl = html`<script> f((${expr}) / 2); </script>`;",
                "    // If the inner JS formatter removes the parens, the expression might change its meaning:",
                "    //     f((a + b) / 2)  vs  f(a + b / 2)",
                "    if (",
                "      node.extra &&",
                "      node.extra.parenthesized &&",
                "      /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)",
                "    ) {",
                "      return true;",
                "    }",
                "",
                "    // `for ((async) of []);` and `for ((let) of []);`",
                "    if (",
                "      name === \"left\" &&",
                "      ((node.name === \"async\" && !parent.await) || node.name === \"let\") &&",
                "      parent.type === \"ForOfStatement\"",
                "    ) {",
                "      return true;",
                "    }",
                "",
                "    // `for ((let.a) of []);`",
                "    if (node.name === \"let\") {",
                "      const expression = path.findAncestor(",
                "        (node) => node.type === \"ForOfStatement\"",
                "      )?.left;",
                "      if (",
                "        expression &&",
                "        startsWithNoLookaheadToken(",
                "          expression,",
                "          (leftmostNode) => leftmostNode === node",
                "        )",
                "      ) {",
                "        return true;",
                "      }",
                "    }",
                "",
                "    // `(let)[a] = 1`",
                "    if (",
                "      name === \"object\" &&",
                "      node.name === \"let\" &&",
                "      parent.type === \"MemberExpression\" &&",
                "      parent.computed &&",
                "      !parent.optional",
                "    ) {",
                "      const statement = path.findAncestor(",
                "        (node) =>",
                "          node.type === \"ExpressionStatement\" ||",
                "          node.type === \"ForStatement\" ||",
                "          node.type === \"ForInStatement\"",
                "      );",
                "      const expression = !statement",
                "        ? undefined",
                "        : statement.type === \"ExpressionStatement\"",
                "        ? statement.expression",
                "        : statement.type === \"ForStatement\"",
                "        ? statement.init",
                "        : statement.left;",
                "      if (",
                "        expression &&",
                "        startsWithNoLookaheadToken(",
                "          expression,",
                "          (leftmostNode) => leftmostNode === node",
                "        )",
                "      ) {",
                "        return true;",
                "      }",
                "    }",
                "",
                "    return false;",
                "  }",
                "",
                "  if (",
                "    node.type === \"ObjectExpression\" ||",
                "    node.type === \"FunctionExpression\" ||",
                "    node.type === \"ClassExpression\" ||",
                "    node.type === \"DoExpression\"",
                "  ) {",
                "    const expression = path.findAncestor(",
                "      (node) => node.type === \"ExpressionStatement\"",
                "    )?.expression;",
                "    if (",
                "      expression &&",
                "      startsWithNoLookaheadToken(",
                "        expression,",
                "        (leftmostNode) => leftmostNode === node",
                "      )",
                "    ) {",
                "      return true;",
                "    }",
                "  }",
                "",
                "  switch (parent.type) {",
                "    case \"ParenthesizedExpression\":",
                "      return false;",
                "    case \"ClassDeclaration\":",
                "    case \"ClassExpression\": {",
                "      // Add parens around the extends clause of a class. It is needed for almost",
                "      // all expressions.",
                "      if (",
                "        name === \"superClass\" &&",
                "        (node.type === \"ArrowFunctionExpression\" ||",
                "          node.type === \"AssignmentExpression\" ||",
                "          node.type === \"AwaitExpression\" ||",
                "          node.type === \"BinaryExpression\" ||",
                "          node.type === \"ConditionalExpression\" ||",
                "          node.type === \"LogicalExpression\" ||",
                "          node.type === \"NewExpression\" ||",
                "          node.type === \"ObjectExpression\" ||",
                "          node.type === \"SequenceExpression\" ||",
                "          node.type === \"TaggedTemplateExpression\" ||",
                "          node.type === \"UnaryExpression\" ||",
                "          node.type === \"UpdateExpression\" ||",
                "          node.type === \"YieldExpression\" ||",
                "          node.type === \"TSNonNullExpression\")",
                "      ) {",
                "        return true;",
                "      }",
                "      break;",
                "    }",
                "    case \"ExportDefaultDeclaration\": {",
                "      return (",
                "        // `export default function` or `export default class` can't be followed by",
                "        // anything after. So an expression like `export default (function(){}).toString()`",
                "        // needs to be followed by a parentheses",
                "        shouldWrapFunctionForExportDefault(path, options) ||",
                "        // `export default (foo, bar)` also needs parentheses",
                "        node.type === \"SequenceExpression\"",
                "      );",
                "    }",
                "    case \"Decorator\": {",
                "      if (name === \"expression\") {",
                "        let hasCallExpression = false;",
                "        let hasMemberExpression = false;",
                "        let current = node;",
                "        while (current) {",
                "          switch (current.type) {",
                "            case \"MemberExpression\":",
                "              hasMemberExpression = true;",
                "              current = current.object;",
                "              break;",
                "            case \"CallExpression\":",
                "              if (",
                "                /** @(x().y) */ hasMemberExpression ||",
                "                /** @(x().y()) */ hasCallExpression",
                "              ) {",
                "                return options.parser !== \"typescript\";",
                "              }",
                "              hasCallExpression = true;",
                "              current = current.callee;",
                "              break;",
                "            case \"Identifier\":",
                "              return false;",
                "            case \"TaggedTemplateExpression\":",
                "              // babel-parser cannot parse",
                "              //   @foo`bar`",
                "              return options.parser !== \"typescript\";",
                "            default:",
                "              return true;",
                "          }",
                "        }",
                "        return true;",
                "      }",
                "      break;",
                "    }",
                "    case \"ArrowFunctionExpression\": {",
                "      if (",
                "        name === \"body\" &&",
                "        node.type !== \"SequenceExpression\" && // these have parens added anyway",
                "        startsWithNoLookaheadToken(",
                "          node,",
                "          (node) => node.type === \"ObjectExpression\"",
                "        )",
                "      ) {",
                "        return true;",
                "      }",
                "      break;",
                "    }",
                "  }",
                "",
                "  switch (node.type) {",
                "    case \"UpdateExpression\":",
                "      if (parent.type === \"UnaryExpression\") {",
                "        return (",
                "          node.prefix &&",
                "          ((node.operator === \"++\" && parent.operator === \"+\") ||",
                "            (node.operator === \"--\" && parent.operator === \"-\"))",
                "        );",
                "      }",
                "    // else fallthrough",
                "    case \"UnaryExpression\":",
                "      switch (parent.type) {",
                "        case \"UnaryExpression\":",
                "          return (",
                "            node.operator === parent.operator &&",
                "            (node.operator === \"+\" || node.operator === \"-\")",
                "          );",
                "",
                "        case \"BindExpression\":",
                "          return true;",
                "",
                "        case \"MemberExpression\":",
                "        case \"OptionalMemberExpression\":",
                "          return name === \"object\";",
                "",
                "        case \"TaggedTemplateExpression\":",
                "          return true;",
                "",
                "        case \"NewExpression\":",
                "        case \"CallExpression\":",
                "        case \"OptionalCallExpression\":",
                "          return name === \"callee\";",
                "",
                "        case \"BinaryExpression\":",
                "          return name === \"left\" && parent.operator === \"**\";",
                "",
                "        case \"TSNonNullExpression\":",
                "          return true;",
                "",
                "        default:",
                "          return false;",
                "      }",
                "",
                "    case \"BinaryExpression\": {",
                "      if (parent.type === \"UpdateExpression\") {",
                "        return true;",
                "      }",
                "",
                "      // We add parentheses to any `a in b` inside `ForStatement` initializer",
                "      // https://github.com/prettier/prettier/issues/907#issuecomment-284304321",
                "      if (node.operator === \"in\" && isPathInForStatementInitializer(path)) {",
                "        return true;",
                "      }",
                "      if (node.operator === \"|>\" && node.extra && node.extra.parenthesized) {",
                "        const grandParent = path.getParentNode(1);",
                "        if (",
                "          grandParent.type === \"BinaryExpression\" &&",
                "          grandParent.operator === \"|>\"",
                "        ) {",
                "          return true;",
                "        }",
                "      }",
                "    }",
                "    // fallthrough",
                "    case \"TSTypeAssertion\":",
                "    case \"TSAsExpression\":",
                "    case \"TSSatisfiesExpression\":",
                "    case \"LogicalExpression\":",
                "      switch (parent.type) {",
                "        case \"TSSatisfiesExpression\":",
                "        case \"TSAsExpression\":",
                "          // example: foo as unknown as Bar",
                "          return !isTSTypeExpression(node);",
                "",
                "        case \"ConditionalExpression\":",
                "          return isTSTypeExpression(node);",
                "",
                "        case \"CallExpression\":",
                "        case \"NewExpression\":",
                "        case \"OptionalCallExpression\":",
                "          return name === \"callee\";",
                "",
                "        case \"ClassExpression\":",
                "        case \"ClassDeclaration\":",
                "          return name === \"superClass\";",
                "",
                "        case \"TSTypeAssertion\":",
                "        case \"TaggedTemplateExpression\":",
                "        case \"UnaryExpression\":",
                "        case \"JSXSpreadAttribute\":",
                "        case \"SpreadElement\":",
                "        case \"SpreadProperty\":",
                "        case \"BindExpression\":",
                "        case \"AwaitExpression\":",
                "        case \"TSNonNullExpression\":",
                "        case \"UpdateExpression\":",
                "          return true;",
                "",
                "        case \"MemberExpression\":",
                "        case \"OptionalMemberExpression\":",
                "          return name === \"object\";",
                "",
                "        case \"AssignmentExpression\":",
                "        case \"AssignmentPattern\":",
                "          return (",
                "            name === \"left\" &&",
                "            (node.type === \"TSTypeAssertion\" || isTSTypeExpression(node))",
                "          );",
                "",
                "        case \"LogicalExpression\":",
                "          if (node.type === \"LogicalExpression\") {",
                "            return parent.operator !== node.operator;",
                "          }",
                "        // else fallthrough",
                "",
                "        case \"BinaryExpression\": {",
                "          const { operator, type } = node;",
                "          if (!operator && type !== \"TSTypeAssertion\") {",
                "            return true;",
                "          }",
                "",
                "          const precedence = getPrecedence(operator);",
                "          const parentOperator = parent.operator;",
                "          const parentPrecedence = getPrecedence(parentOperator);",
                "",
                "          if (parentPrecedence > precedence) {",
                "            return true;",
                "          }",
                "",
                "          if (name === \"right\" && parentPrecedence === precedence) {",
                "            return true;",
                "          }",
                "",
                "          if (",
                "            parentPrecedence === precedence &&",
                "            !shouldFlatten(parentOperator, operator)",
                "          ) {",
                "            return true;",
                "          }",
                "",
                "          if (parentPrecedence < precedence && operator === \"%\") {",
                "            return parentOperator === \"+\" || parentOperator === \"-\";",
                "          }",
                "",
                "          // Add parenthesis when working with bitwise operators",
                "          // It's not strictly needed but helps with code understanding",
                "          if (isBitwiseOperator(parentOperator)) {",
                "            return true;",
                "          }",
                "",
                "          return false;",
                "        }",
                "",
                "        default:",
                "          return false;",
                "      }",
                "",
                "    case \"SequenceExpression\":",
                "      switch (parent.type) {",
                "        case \"ReturnStatement\":",
                "          return false;",
                "",
                "        case \"ForStatement\":",
                "          // Although parentheses wouldn't hurt around sequence",
                "          // expressions in the head of for loops, traditional style",
                "          // dictates that e.g. i++, j++ should not be wrapped with",
                "          // parentheses.",
                "          return false;",
                "",
                "        case \"ExpressionStatement\":",
                "          return name !== \"expression\";",
                "",
                "        case \"ArrowFunctionExpression\":",
                "          // We do need parentheses, but SequenceExpressions are handled",
                "          // specially when printing bodies of arrow functions.",
                "          return name !== \"body\";",
                "",
                "        default:",
                "          // Otherwise err on the side of overparenthesization, adding",
                "          // explicit exceptions above if this proves overzealous.",
                "          return true;",
                "      }",
                "",
                "    case \"YieldExpression\":",
                "      if (",
                "        parent.type === \"UnaryExpression\" ||",
                "        parent.type === \"AwaitExpression\" ||",
                "        isTSTypeExpression(parent) ||",
                "        parent.type === \"TSNonNullExpression\"",
                "      ) {",
                "        return true;",
                "      }",
                "    // else fallthrough",
                "    case \"AwaitExpression\":",
                "      switch (parent.type) {",
                "        case \"TaggedTemplateExpression\":",
                "        case \"UnaryExpression\":",
                "        case \"LogicalExpression\":",
                "        case \"SpreadElement\":",
                "        case \"SpreadProperty\":",
                "        case \"TSAsExpression\":",
                "        case \"TSSatisfiesExpression\":",
                "        case \"TSNonNullExpression\":",
                "        case \"BindExpression\":",
                "          return true;",
                "",
                "        case \"MemberExpression\":",
                "        case \"OptionalMemberExpression\":",
                "          return name === \"object\";",
                "",
                "        case \"NewExpression\":",
                "        case \"CallExpression\":",
                "        case \"OptionalCallExpression\":",
                "          return name === \"callee\";",
                "",
                "        case \"ConditionalExpression\":",
                "          return name === \"test\";",
                "",
                "        case \"BinaryExpression\": {",
                "          if (!node.argument && parent.operator === \"|>\") {",
                "            return false;",
                "          }",
                "",
                "          return true;",
                "        }",
                "",
                "        default:",
                "          return false;",
                "      }",
                "",
                "    case \"TSConditionalType\":",
                "      if (name === \"extendsType\" && parent.type === \"TSConditionalType\") {",
                "        return true;",
                "      }",
                "    // fallthrough",
                "    case \"TSFunctionType\":",
                "    case \"TSConstructorType\":",
                "      if (name === \"extendsType\" && parent.type === \"TSConditionalType\") {",
                "        const returnTypeAnnotation = (node.returnType || node.typeAnnotation)",
                "          .typeAnnotation;",
                "        if (",
                "          returnTypeAnnotation.type === \"TSInferType\" &&",
                "          returnTypeAnnotation.typeParameter.constraint",
                "        ) {",
                "          return true;",
                "        }",
                "      }",
                "      if (name === \"checkType\" && parent.type === \"TSConditionalType\") {",
                "        return true;",
                "      }",
                "    // fallthrough",
                "    case \"TSUnionType\":",
                "    case \"TSIntersectionType\":",
                "      if (",
                "        (parent.type === \"TSUnionType\" ||",
                "          parent.type === \"TSIntersectionType\") &&",
                "        parent.types.length > 1 &&",
                "        (!node.types || node.types.length > 1)",
                "      ) {",
                "        return true;",
                "      }",
                "    // fallthrough",
                "    case \"TSInferType\":",
                "      if (node.type === \"TSInferType\" && parent.type === \"TSRestType\") {"
            ]
        },
        "2": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/language-js/printer-estree.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "/** @typedef {import(\"../document\").Doc} Doc */",
                "",
                "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
                "const { printDanglingComments } = require(\"../main/comments.js\");",
                "const { hasNewline } = require(\"../common/util.js\");",
                "const {",
                "  builders: { join, line, hardline, softline, group, indent },",
                "  utils: { replaceTextEndOfLine },",
                "} = require(\"../document/index.js\");",
                "const embed = require(\"./embed.js\");",
                "const clean = require(\"./clean.js\");",
                "const { insertPragma } = require(\"./pragma.js\");",
                "const handleComments = require(\"./comments.js\");",
                "const pathNeedsParens = require(\"./needs-parens.js\");",
                "const preprocess = require(\"./print-preprocess.js\");",
                "const {",
                "  hasFlowShorthandAnnotationComment,",
                "  hasComment,",
                "  CommentCheckFlags,",
                "  isTheOnlyJsxElementInMarkdown,",
                "  isLineComment,",
                "  isNextLineEmpty,",
                "  needsHardlineAfterDanglingComment,",
                "  hasIgnoreComment,",
                "  isCallExpression,",
                "  isMemberExpression,",
                "  markerForIfWithoutBlockAndSameLineComment,",
                "} = require(\"./utils/index.js\");",
                "const { locStart, locEnd } = require(\"./loc.js\");",
                "const isBlockComment = require(\"./utils/is-block-comment.js\");",
                "",
                "const {",
                "  printHtmlBinding,",
                "  isVueEventBindingExpression,",
                "} = require(\"./print/html-binding.js\");",
                "const { printAngular } = require(\"./print/angular.js\");",
                "const { printJsx, hasJsxIgnoreComment } = require(\"./print/jsx.js\");",
                "const { printFlow } = require(\"./print/flow.js\");",
                "const { printTypescript } = require(\"./print/typescript.js\");",
                "const {",
                "  printOptionalToken,",
                "  printBindExpressionCallee,",
                "  printTypeAnnotation,",
                "  adjustClause,",
                "  printRestSpread,",
                "  printDefiniteToken,",
                "  printDirective,",
                "} = require(\"./print/misc.js\");",
                "const {",
                "  printImportDeclaration,",
                "  printExportDeclaration,",
                "  printExportAllDeclaration,",
                "  printModuleSpecifier,",
                "} = require(\"./print/module.js\");",
                "const { printTernary } = require(\"./print/ternary.js\");",
                "const { printTemplateLiteral } = require(\"./print/template-literal.js\");",
                "const { printArray } = require(\"./print/array.js\");",
                "const { printObject } = require(\"./print/object.js\");",
                "const {",
                "  printClass,",
                "  printClassMethod,",
                "  printClassProperty,",
                "} = require(\"./print/class.js\");",
                "const { printProperty } = require(\"./print/property.js\");",
                "const {",
                "  printFunction,",
                "  printArrowFunction,",
                "  printMethod,",
                "  printReturnStatement,",
                "  printThrowStatement,",
                "} = require(\"./print/function.js\");",
                "const { printCallExpression } = require(\"./print/call-expression.js\");",
                "const {",
                "  printVariableDeclarator,",
                "  printAssignmentExpression,",
                "} = require(\"./print/assignment.js\");",
                "const { printBinaryishExpression } = require(\"./print/binaryish.js\");",
                "const { printSwitchCaseConsequent } = require(\"./print/statement.js\");",
                "const { printMemberExpression } = require(\"./print/member.js\");",
                "const { printBlock, printBlockBody } = require(\"./print/block.js\");",
                "const { printComment } = require(\"./print/comment.js\");",
                "const { printLiteral } = require(\"./print/literal.js\");",
                "const { printDecorators } = require(\"./print/decorators.js\");",
                "",
                "function genericPrint(path, options, print, args) {",
                "  const printed = printPathNoParens(path, options, print, args);",
                "  if (!printed) {",
                "    return \"\";",
                "  }",
                "",
                "  const node = path.getValue();",
                "  const { type } = node;",
                "  // Their decorators are handled themselves, and they can't have parentheses",
                "  if (",
                "    type === \"ClassMethod\" ||",
                "    type === \"ClassPrivateMethod\" ||",
                "    type === \"ClassProperty\" ||",
                "    type === \"ClassAccessorProperty\" ||",
                "    type === \"AccessorProperty\" ||",
                "    type === \"TSAbstractAccessorProperty\" ||",
                "    type === \"PropertyDefinition\" ||",
                "    type === \"TSAbstractPropertyDefinition\" ||",
                "    type === \"ClassPrivateProperty\" ||",
                "    type === \"MethodDefinition\" ||",
                "    type === \"TSAbstractMethodDefinition\" ||",
                "    type === \"TSDeclareMethod\"",
                "  ) {",
                "    return printed;",
                "  }",
                "",
                "  let parts = [printed];",
                "",
                "  const printedDecorators = printDecorators(path, options, print);",
                "  const isClassExpressionWithDecorators =",
                "    node.type === \"ClassExpression\" && printedDecorators;",
                "  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons",
                "  if (printedDecorators) {",
                "    parts = [...printedDecorators, printed];",
                "",
                "    if (!isClassExpressionWithDecorators) {",
                "      return group(parts);",
                "    }",
                "  }",
                "",
                "  const needsParens = pathNeedsParens(path, options);",
                "",
                "  if (!needsParens) {",
                "    if (args && args.needsSemi) {",
                "      parts.unshift(\";\");",
                "    }",
                "",
                "    // In member-chain print, it add `label` to the doc, if we return array here it will be broken",
                "    if (parts.length === 1 && parts[0] === printed) {",
                "      return printed;",
                "    }",
                "",
                "    return parts;",
                "  }",
                "",
                "  if (isClassExpressionWithDecorators) {",
                "    parts = [indent([line, ...parts])];",
                "  }",
                "",
                "  parts.unshift(\"(\");",
                "",
                "  if (args && args.needsSemi) {",
                "    parts.unshift(\";\");",
                "  }",
                "",
                "  if (hasFlowShorthandAnnotationComment(node)) {",
                "    const [comment] = node.trailingComments;",
                "    parts.push(\" /*\", comment.value.trimStart(), \"*/\");",
                "    comment.printed = true;",
                "  }",
                "",
                "  if (isClassExpressionWithDecorators) {",
                "    parts.push(line);",
                "  }",
                "",
                "  parts.push(\")\");",
                "",
                "  return parts;",
                "}",
                "",
                "function printPathNoParens(path, options, print, args) {",
                "  const node = path.getValue();",
                "  const semi = options.semi ? \";\" : \"\";",
                "",
                "  if (!node) {",
                "    return \"\";",
                "  }",
                "",
                "  if (typeof node === \"string\") {",
                "    return node;",
                "  }",
                "",
                "  for (const printer of [",
                "    printLiteral,",
                "    printHtmlBinding,",
                "    printAngular,",
                "    printJsx,",
                "    printFlow,",
                "    printTypescript,",
                "  ]) {",
                "    const printed = printer(path, options, print);",
                "    if (typeof printed !== \"undefined\") {",
                "      return printed;",
                "    }",
                "  }",
                "",
                "  /** @type{Doc[]} */",
                "  let parts = [];",
                "",
                "  switch (node.type) {",
                "    case \"JsExpressionRoot\":",
                "      return print(\"node\");",
                "    case \"JsonRoot\":",
                "      return [print(\"node\"), hardline];",
                "    case \"File\":",
                "      // Print @babel/parser's InterpreterDirective here so that",
                "      // leading comments on the `Program` node get printed after the hashbang.",
                "      if (node.program && node.program.interpreter) {",
                "        parts.push(print([\"program\", \"interpreter\"]));",
                "      }",
                "",
                "      parts.push(print(\"program\"));",
                "",
                "      return parts;",
                "",
                "    case \"Program\":",
                "      return printBlockBody(path, options, print);",
                "    // Babel extension.",
                "    case \"EmptyStatement\":",
                "      return \"\";",
                "    case \"ExpressionStatement\": {",
                "      if (",
                "        options.parser === \"__vue_event_binding\" ||",
                "        options.parser === \"__vue_ts_event_binding\"",
                "      ) {",
                "        const parent = path.getParentNode();",
                "        if (",
                "          parent.type === \"Program\" &&",
                "          parent.body.length === 1 &&",
                "          parent.body[0] === node",
                "        ) {",
                "          return [",
                "            print(\"expression\"),",
                "            isVueEventBindingExpression(node.expression) ? \";\" : \"\",",
                "          ];",
                "        }",
                "      }",
                "",
                "      const danglingComment = printDanglingComments(",
                "        path,",
                "        options,",
                "        /** sameIndent */ true,",
                "        ({ marker }) => marker === markerForIfWithoutBlockAndSameLineComment",
                "      );",
                "",
                "      // Do not append semicolon after the only JSX element in a program",
                "      return [",
                "        print(\"expression\"),",
                "        isTheOnlyJsxElementInMarkdown(options, path) ? \"\" : semi,",
                "        danglingComment ? [\" \", danglingComment] : \"\",",
                "      ];",
                "    }",
                "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
                "    case \"ParenthesizedExpression\": {",
                "      const shouldHug =",
                "        !hasComment(node.expression) &&",
                "        (node.expression.type === \"ObjectExpression\" ||",
                "          node.expression.type === \"ArrayExpression\");",
                "      if (shouldHug) {",
                "        return [\"(\", print(\"expression\"), \")\"];",
                "      }",
                "      return group([",
                "        \"(\",",
                "        indent([softline, print(\"expression\")]),",
                "        softline,",
                "        \")\",",
                "      ]);",
                "    }",
                "    case \"AssignmentExpression\":",
                "      return printAssignmentExpression(path, options, print);",
                "    case \"VariableDeclarator\":",
                "      return printVariableDeclarator(path, options, print);",
                "    case \"BinaryExpression\":",
                "    case \"LogicalExpression\":",
                "      return printBinaryishExpression(path, options, print);",
                "    case \"AssignmentPattern\":",
                "      return [print(\"left\"), \" = \", print(\"right\")];",
                "    case \"OptionalMemberExpression\":",
                "    case \"MemberExpression\": {",
                "      return printMemberExpression(path, options, print);",
                "    }",
                "    case \"MetaProperty\":",
                "      return [print(\"meta\"), \".\", print(\"property\")];",
                "    case \"BindExpression\":",
                "      if (node.object) {",
                "        parts.push(print(\"object\"));",
                "      }",
                "",
                "      parts.push(",
                "        group(",
                "          indent([softline, printBindExpressionCallee(path, options, print)])",
                "        )",
                "      );",
                "",
                "      return parts;",
                "    case \"Identifier\": {",
                "      return [",
                "        node.name,",
                "        printOptionalToken(path),",
                "        printDefiniteToken(path),",
                "        printTypeAnnotation(path, options, print),",
                "      ];",
                "    }",
                "    case \"V8IntrinsicIdentifier\":",
                "      return [\"%\", node.name];",
                "    case \"SpreadElement\":",
                "    case \"SpreadElementPattern\":",
                "    case \"SpreadProperty\":",
                "    case \"SpreadPropertyPattern\":",
                "    case \"RestElement\":",
                "      return printRestSpread(path, options, print);",
                "    case \"FunctionDeclaration\":",
                "    case \"FunctionExpression\":",
                "      return printFunction(path, print, options, args);",
                "    case \"ArrowFunctionExpression\":",
                "      return printArrowFunction(path, options, print, args);",
                "    case \"YieldExpression\":",
                "      parts.push(\"yield\");",
                "",
                "      if (node.delegate) {",
                "        parts.push(\"*\");",
                "      }",
                "      if (node.argument) {",
                "        parts.push(\" \", print(\"argument\"));",
                "      }",
                "",
                "      return parts;",
                "    case \"AwaitExpression\": {",
                "      parts.push(\"await\");",
                "      if (node.argument) {",
                "        parts.push(\" \", print(\"argument\"));",
                "        const parent = path.getParentNode();",
                "        if (",
                "          (isCallExpression(parent) && parent.callee === node) ||",
                "          (isMemberExpression(parent) && parent.object === node)",
                "        ) {",
                "          parts = [indent([softline, ...parts]), softline];",
                "          const parentAwaitOrBlock = path.findAncestor(",
                "            (node) =>",
                "              node.type === \"AwaitExpression\" || node.type === \"BlockStatement\"",
                "          );",
                "          if (",
                "            !parentAwaitOrBlock ||",
                "            parentAwaitOrBlock.type !== \"AwaitExpression\"",
                "          ) {",
                "            return group(parts);",
                "          }",
                "        }",
                "      }",
                "      return parts;",
                "    }",
                "    case \"ExportDefaultDeclaration\":",
                "    case \"ExportNamedDeclaration\":",
                "      return printExportDeclaration(path, options, print);",
                "    case \"ExportAllDeclaration\":",
                "      return printExportAllDeclaration(path, options, print);",
                "    case \"ImportDeclaration\":",
                "      return printImportDeclaration(path, options, print);",
                "    case \"ImportSpecifier\":",
                "    case \"ExportSpecifier\":",
                "    case \"ImportNamespaceSpecifier\":",
                "    case \"ExportNamespaceSpecifier\":",
                "    case \"ImportDefaultSpecifier\":",
                "    case \"ExportDefaultSpecifier\":",
                "      return printModuleSpecifier(path, options, print);",
                "    case \"ImportAttribute\":",
                "      return [print(\"key\"), \": \", print(\"value\")];",
                "    case \"Import\":",
                "      return \"import\";",
                "    case \"BlockStatement\":",
                "    case \"StaticBlock\":",
                "    case \"ClassBody\":",
                "      return printBlock(path, options, print);",
                "    case \"ThrowStatement\":",
                "      return printThrowStatement(path, options, print);",
                "    case \"ReturnStatement\":",
                "      return printReturnStatement(path, options, print);",
                "    case \"NewExpression\":",
                "    case \"ImportExpression\":",
                "    case \"OptionalCallExpression\":",
                "    case \"CallExpression\":",
                "      return printCallExpression(path, options, print);",
                "",
                "    case \"ObjectExpression\":",
                "    case \"ObjectPattern\":",
                "    case \"RecordExpression\":",
                "      return printObject(path, options, print);",
                "    // Babel 6",
                "    case \"ObjectProperty\": // Non-standard AST node type.",
                "    case \"Property\":",
                "      if (node.method || node.kind === \"get\" || node.kind === \"set\") {",
                "        return printMethod(path, options, print);",
                "      }",
                "      return printProperty(path, options, print);",
                "    case \"ObjectMethod\":",
                "      return printMethod(path, options, print);",
                "    case \"Decorator\":",
                "      return [\"@\", print(\"expression\")];",
                "    case \"ArrayExpression\":",
                "    case \"ArrayPattern\":",
                "    case \"TupleExpression\":",
                "      return printArray(path, options, print);",
                "    case \"SequenceExpression\": {",
                "      const parent = path.getParentNode(0);",
                "      if (",
                "        parent.type === \"ExpressionStatement\" ||",
                "        parent.type === \"ForStatement\"",
                "      ) {",
                "        // For ExpressionStatements and for-loop heads, which are among",
                "        // the few places a SequenceExpression appears unparenthesized, we want",
                "        // to indent expressions after the first.",
                "        const parts = [];",
                "        path.each((expressionPath, index) => {",
                "          if (index === 0) {",
                "            parts.push(print());",
                "          } else {",
                "            parts.push(\",\", indent([line, print()]));",
                "          }",
                "        }, \"expressions\");",
                "        return group(parts);",
                "      }",
                "      return group(join([\",\", line], path.map(print, \"expressions\")));",
                "    }",
                "    case \"ThisExpression\":",
                "      return \"this\";",
                "    case \"Super\":",
                "      return \"super\";",
                "    case \"Directive\":",
                "      return [print(\"value\"), semi]; // Babel 6",
                "    case \"DirectiveLiteral\":",
                "      return printDirective(node.extra.raw, options);",
                "    case \"UnaryExpression\":",
                "      parts.push(node.operator);",
                "",
                "      if (/[a-z]$/.test(node.operator)) {",
                "        parts.push(\" \");",
                "      }",
                "",
                "      if (hasComment(node.argument)) {",
                "        parts.push(",
                "          group([\"(\", indent([softline, print(\"argument\")]), softline, \")\"])",
                "        );",
                "      } else {",
                "        parts.push(print(\"argument\"));",
                "      }",
                "",
                "      return parts;",
                "    case \"UpdateExpression\":",
                "      parts.push(print(\"argument\"), node.operator);",
                "",
                "      if (node.prefix) {",
                "        parts.reverse();",
                "      }",
                "",
                "      return parts;",
                "    case \"ConditionalExpression\":",
                "      return printTernary(path, options, print);",
                "    case \"VariableDeclaration\": {",
                "      const printed = path.map(print, \"declarations\");",
                "",
                "      // We generally want to terminate all variable declarations with a",
                "      // semicolon, except when they in the () part of for loops.",
                "      const parentNode = path.getParentNode();",
                "",
                "      const isParentForLoop =",
                "        parentNode.type === \"ForStatement\" ||",
                "        parentNode.type === \"ForInStatement\" ||",
                "        parentNode.type === \"ForOfStatement\";",
                "",
                "      const hasValue = node.declarations.some((decl) => decl.init);",
                "",
                "      let firstVariable;",
                "      if (printed.length === 1 && !hasComment(node.declarations[0])) {",
                "        firstVariable = printed[0];",
                "      } else if (printed.length > 0) {",
                "        // Indent first var to comply with eslint one-var rule",
                "        firstVariable = indent(printed[0]);",
                "      }",
                "",
                "      parts = [",
                "        node.declare ? \"declare \" : \"\",",
                "        node.kind,",
                "        firstVariable ? [\" \", firstVariable] : \"\",",
                "        indent(",
                "          printed",
                "            .slice(1)",
                "            .map((p) => [",
                "              \",\",",
                "              hasValue && !isParentForLoop ? hardline : line,",
                "              p,",
                "            ])",
                "        ),",
                "      ];",
                "",
                "      if (!(isParentForLoop && parentNode.body !== node)) {",
                "        parts.push(semi);",
                "      }",
                "",
                "      return group(parts);",
                "    }",
                "    case \"WithStatement\":",
                "      return group([",
                "        \"with (\",",
                "        print(\"object\"),",
                "        \")\","
            ]
        }
    },
    "bug_functions": {}
}