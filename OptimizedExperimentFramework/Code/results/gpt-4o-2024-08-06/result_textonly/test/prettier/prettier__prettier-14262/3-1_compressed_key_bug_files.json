{
    "1": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 845,
        "compressed_line_numbers": 76,
        "compressed_bug_file_content": "\n\n/** @typedef {import(\"../document\").Doc} Doc */\n\n// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\n  // Their decorators are handled themselves, and they can't have parentheses\n\n\n  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons\n\n\n    // In member-chain print, it add `label` to the doc, if we return array here it will be broken\n\n\n  /** @type{Doc[]} */\n\n\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n\n\n    // Babel extension.\n\n\n        /** sameIndent */ true,\n\n\n      // Do not append semicolon after the only JSX element in a program\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n    // Babel 6\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n        /* sameLine */ true\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n    // For hack-style pipeline\n\n\n      /* istanbul ignore next */\n\n\n    // `babel-ts` don't have similar node for `class Foo { bar() /* bat */; }`\n\n\n    // TODO: Make this as default behavior\n\n\n"
    },
    "2": {
        "bug_file": "src/language-js/needs-parens.js",
        "compressed": "YES",
        "line_numbers": 1026,
        "compressed_line_numbers": 128,
        "compressed_bug_file_content": "\n\n  // to avoid unexpected `}}` in HTML interpolations\n\n\n  // Only statements don't need parentheses.\n\n\n    // Preserve parens if we have a Flow annotation comment, unless we're using the Flow\n    // parser. The Flow parser turns Flow comments into type annotation nodes in its\n    // AST, which we handle separately.\n\n\n  // Identifiers never need parentheses.\n\n    // ...unless those identifiers are embed placeholders. They might be substituted by complex\n    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):\n    //     let tpl = html`<script> f((${expr}) / 2); </script>`;\n    // If the inner JS formatter removes the parens, the expression might change its meaning:\n    //     f((a + b) / 2)  vs  f(a + b / 2)\n\n\n    // `for ((async) of []);` and `for ((let) of []);`\n\n\n    // `for ((let.a) of []);`\n\n\n    // `(let)[a] = 1`\n\n\n      // Add parens around the extends clause of a class. It is needed for almost\n      // all expressions.\n\n\n        // `export default function` or `export default class` can't be followed by\n        // anything after. So an expression like `export default (function(){}).toString()`\n        // needs to be followed by a parentheses\n\n        // `export default (foo, bar)` also needs parentheses\n\n\n                /** @(x().y) */ hasMemberExpression ||\n                /** @(x().y()) */ hasCallExpression\n\n\n              // babel-parser cannot parse\n              //   @foo`bar`\n\n\n    // else fallthrough\n\n\n      // We add parentheses to any `a in b` inside `ForStatement` initializer\n      // https://github.com/prettier/prettier/issues/907#issuecomment-284304321\n\n\n    // fallthrough\n\n\n          // example: foo as unknown as Bar\n\n\n        // else fallthrough\n\n\n          // Add parenthesis when working with bitwise operators\n          // It's not strictly needed but helps with code understanding\n\n\n          // Although parentheses wouldn't hurt around sequence\n          // expressions in the head of for loops, traditional style\n          // dictates that e.g. i++, j++ should not be wrapped with\n          // parentheses.\n\n\n          // We do need parentheses, but SequenceExpressions are handled\n          // specially when printing bodies of arrow functions.\n\n\n          // Otherwise err on the side of overparenthesization, adding\n          // explicit exceptions above if this proves overzealous.\n\n\n    // else fallthrough\n\n\n    // fallthrough\n\n\n    // fallthrough\n\n\n    // fallthrough\n\n\n    // fallthrough\n\n\n        // We should check ancestor's parent to know whether the parentheses\n        // are really needed, but since ??T doesn't make sense this check\n        // will almost never be true.\n\n        // See #5283\n\n\n        // To avoid becoming a directive\n\n\n          // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.\n          // Is necessary if it is `expression` of `ExpressionStatement`.\n\n\n    // fallthrough\n\n\n            // tagged templates are basically member expressions from a grammar perspective\n            // see https://tc39.github.io/ecma262/#prod-MemberExpression\n\n\n          // Preserve parens for compatibility with AngularJS expressions\n\n\n      // in some cases the function is already wrapped\n      // (e.g. `export default (function() {})();`)\n      // in this case we don't need to add extra parens\n\n\n"
    }
}