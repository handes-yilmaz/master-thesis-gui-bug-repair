{
    "1": {
        "bug_file": "src/language-markdown/printer-markdown.js",
        "compressed": "YES",
        "line_numbers": 739,
        "compressed_line_numbers": 28,
        "compressed_bug_file_content": "\n\n        // leading char that may cause different syntax\n\n\n        // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it\n\n\n        // indented code block\n\n\n      // fenced code block\n\n\n            // do not print trailing spaces for empty list item since it might be treated as `break` node\n            // by [doc-printer](https://github.com/prettier/prettier/blob/1.10.2/src/doc/doc-printer.js#L395-L405),\n            // we don't want to preserve unnecessary trailing spaces.\n\n\n  // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split\n\n\n  // for markdown codeblock\n\n\n  // for markdown whitespace: \"\\n\" and \" \" are considered the same\n\n\n"
    },
    "2": {
        "bug_file": "src/doc/doc-printer.js",
        "compressed": "YES",
        "line_numbers": 508,
        "compressed_line_numbers": 71,
        "compressed_bug_file_content": "\n\n      /* istanbul ignore next */\n\n\n            // fallthrough\n\n\n  // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n\n            // fallthrough\n\n\n                // Expanded states are a rare case where a document\n                // can manually provide multiple representations of\n                // itself. It provides an array of documents\n                // going from the least expanded (most flattened)\n                // representation first to the most expanded. If a\n                // group has these, we need to manually go through\n                // these states and find the first one that fits.\n\n\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n\n          // At this point we've handled the first pair (context, separator)\n          // and will create a new fill doc for the rest of the content.\n          // Ideally we wouldn't mutate the array here but coping all the\n          // elements to a new array would make this algorithm quadratic,\n          // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n\n\n            // fallthrough\n\n\n                  // Trim whitespace at the end of line\n\n\n                      // preserve markdown's `break` node (two trailing spaces)\n\n\n"
    }
}