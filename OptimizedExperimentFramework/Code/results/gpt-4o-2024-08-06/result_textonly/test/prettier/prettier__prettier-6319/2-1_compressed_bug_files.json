{
    "1": {
        "bug_file": "src/language-js/parser-babel.js",
        "compressed": "NO",
        "line_numbers": 199,
        "compressed_line_numbers": 199,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst { hasPragma } = require(\"./pragma\");\nconst locFns = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction babelOptions(extraPlugins = []) {\n  return {\n    sourceType: \"module\",\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowUndeclaredExports: true,\n    errorRecovery: true,\n    createParenthesizedExpressions: true,\n    plugins: [\n      \"doExpressions\",\n      \"objectRestSpread\",\n      \"classProperties\",\n      \"exportDefaultFrom\",\n      \"exportNamespaceFrom\",\n      \"asyncGenerators\",\n      \"functionBind\",\n      \"functionSent\",\n      \"dynamicImport\",\n      \"numericSeparator\",\n      \"importMeta\",\n      \"optionalCatchBinding\",\n      \"optionalChaining\",\n      \"classPrivateProperties\",\n      [\"pipelineOperator\", { proposal: \"minimal\" }],\n      \"nullishCoalescingOperator\",\n      \"bigInt\",\n      \"throwExpressions\",\n      \"logicalAssignment\",\n      \"classPrivateMethods\",\n      \"v8intrinsic\",\n      \"partialApplication\",\n      [\"decorators\", { decoratorsBeforeExport: false }],\n      ...extraPlugins,\n    ],\n  };\n}\n\nfunction createParse(parseMethod, ...pluginCombinations) {\n  return (text, parsers, opts) => {\n    // Inline the require to avoid loading all the JS if we don't use it\n    const babel = require(\"@babel/parser\");\n\n    let ast;\n    try {\n      ast = tryCombinations(\n        (options) => babel[parseMethod](text, options),\n        pluginCombinations.map(babelOptions)\n      );\n    } catch (error) {\n      throw createError(\n        // babel error prints (l:c) with cols that are zero indexed\n        // so we need our custom error\n        error.message.replace(/ \\(.*\\)/, \"\"),\n        {\n          start: {\n            line: error.loc.line,\n            column: error.loc.column + 1,\n          },\n        }\n      );\n    }\n    delete ast.tokens;\n    return postprocess(ast, { ...opts, originalText: text });\n  };\n}\n\nconst parse = createParse(\"parse\", [\"jsx\", \"flow\"]);\nconst parseFlow = createParse(\"parse\", [\n  \"jsx\",\n  [\"flow\", { all: true, enums: true }],\n]);\nconst parseTypeScript = createParse(\n  \"parse\",\n  [\"jsx\", \"typescript\"],\n  [\"typescript\"]\n);\nconst parseExpression = createParse(\"parseExpression\", [\"jsx\"]);\n\nfunction tryCombinations(fn, combinations) {\n  let error;\n  for (let i = 0; i < combinations.length; i++) {\n    try {\n      return fn(combinations[i]);\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n  throw error;\n}\n\nfunction parseJson(text, parsers, opts) {\n  const ast = parseExpression(text, parsers, opts);\n\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n    case \"ObjectProperty\":\n      // istanbul ignore if\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      }\n      // istanbul ignore if\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n      return [node.key, node.value].forEach(assertJsonChildNode);\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        // istanbul ignore next\n        default:\n          throw createJsonError(\"operator\");\n      }\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n      throw createJsonError();\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    // istanbul ignore next\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  }\n\n  // istanbul ignore next\n  function createJsonError(attribute) {\n    const name = !attribute\n      ? node.type\n      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;\n    return createError(`${name} is not allowed in JSON.`, {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1,\n      },\n    });\n  }\n}\n\nconst babel = { parse, astFormat: \"estree\", hasPragma, ...locFns };\nconst babelFlow = { ...babel, parse: parseFlow };\nconst babelTypeScript = { ...babel, parse: parseTypeScript };\nconst babelExpression = { ...babel, parse: parseExpression };\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    babel,\n    \"babel-flow\": babelFlow,\n    \"babel-ts\": babelTypeScript,\n    json: {\n      ...babelExpression,\n      hasPragma() {\n        return true;\n      },\n    },\n    json5: babelExpression,\n    \"json-stringify\": {\n      parse: parseJson,\n      astFormat: \"estree-json\",\n      ...locFns,\n    },\n    /** @internal */\n    __js_expression: babelExpression,\n    /** for vue filter */\n    __vue_expression: babelExpression,\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel,\n  },\n};"
    },
    "2": {
        "bug_file": "src/language-js/utils.js",
        "compressed": "YES",
        "line_numbers": 1062,
        "compressed_line_numbers": 210,
        "compressed_bug_file_content": "\n\n// We match any whitespace except line terminators because\n// Flow annotation comments cannot be split across lines. For example:\n//\n// (this /*\n// : any */).foo = 5;\n//\n// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so\n// removing the newline would create a type annotation that the user did not intend\n// to create.\n\n\n  // https://flow.org/en/docs/types/comments/\n  // Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");\n\n\n// `inject` is used in AngularJS 1.x, `async` in Angular 2+\n// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n\n\n// Detect an expression node representing `{\" \"}`\n\n\n// TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\n\n\n// Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\n\n\n// Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\n\n\n// eg; `describe(\"some string\", (done) => {})`\n\n\n      // it(\"name\", () => { ... }, 2500)\n\n\n/** identify if an angular expression seems to have side effects */\n\n\n/** @param node {import(\"estree\").TemplateLiteral} */\n\n\n    // Disallow comments since printDocToString can't print them here\n\n\n    // Allow `x` and `this`\n\n\n    // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n  // Babel 7.0 currently uses variance node type, and flow should\n  // follow suit soon:\n  // https://github.com/babel/babel/issues/4722\n\n\n      /* istanbul ignore next */\n\n\n  // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n\n\n      // Babel\n\n\n      /* istanbul ignore next */\n\n\n// Only space, newline, carriage return, and tab are treated as whitespace\n// inside JSX.\n\n\n// Meaningful if it contains non-whitespace characters,\n// or it contains whitespace without a new line.\n\n\n  // Lookup the previous sibling, ignoring any empty JSXText elements\n\n\n  // if there is one text child and does not contain any meaningful text\n  // we can treat the element as empty.\n\n\n// This recurses the return argument, looking for the first token\n// (the leftmost leaf node) and, if it (or its parents) has any\n// leadingComments, returns true (so it can be wrapped in parens).\n\n\n    // With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.\n    // See https://github.com/microsoft/TypeScript/pull/20075\n\n\n  /**\n   * describe.each`table`(name, fn)\n   * describe.only.each`table`(name, fn)\n   * describe.skip.each`table`(name, fn)\n   * test.each`table`(name, fn)\n   * test.only.each`table`(name, fn)\n   * test.skip.each`table`(name, fn)\n   *\n   * Ref: https://github.com/facebook/jest/pull/6102\n   */\n\n\n// If we have nested conditional expressions, we want to print them in JSX mode\n// if there's at least one JSXElement somewhere in the tree.\n//\n// A conditional expression chain like this should be printed in normal mode,\n// because there aren't JSXElements anywhere in it:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";\n//\n// But a conditional expression chain like this should be printed in JSX mode,\n// because there is a JSXElement in the last ConditionalExpression:\n//\n// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;\n//\n// This type of ConditionalExpression chain is structured like this in the AST:\n//\n// ConditionalExpression {\n//   test: ...,\n//   consequent: ...,\n//   alternate: ConditionalExpression {\n//     test: ...,\n//     consequent: ...,\n//     alternate: ConditionalExpression {\n//       test: ...,\n//       consequent: ...,\n//       alternate: ...,\n//     }\n//   }\n// }\n//\n// We want to traverse over that shape and convert it into a flat structure so\n// that we can find if there's a JSXElement somewhere inside.\n\n  // Given this code:\n  //\n  // // Using a ConditionalExpression as the consequent is uncommon, but should\n  // // be handled.\n  // A ? B : C ? D : E ? F ? G : H : I\n  //\n  // which has this AST:\n  //\n  // ConditionalExpression {\n  //   test: Identifier(A),\n  //   consequent: Identifier(B),\n  //   alternate: ConditionalExpression {\n  //     test: Identifier(C),\n  //     consequent: Identifier(D),\n  //     alternate: ConditionalExpression {\n  //       test: Identifier(E),\n  //       consequent: ConditionalExpression {\n  //         test: Identifier(F),\n  //         consequent: Identifier(G),\n  //         alternate: Identifier(H),\n  //       },\n  //       alternate: Identifier(I),\n  //     }\n  //   }\n  // }\n  //\n  // we should return this Array:\n  //\n  // [\n  //   Identifier(A),\n  //   Identifier(B),\n  //   Identifier(C),\n  //   Identifier(D),\n  //   Identifier(E),\n  //   Identifier(F),\n  //   Identifier(G),\n  //   Identifier(H),\n  //   Identifier(I)\n  // ];\n  //\n  // This loses the information about whether each node was the test,\n  // consequent, or alternate, but we don't care about that here- we are only\n  // flattening this structure to find if there's any JSXElements inside.\n\n\n// Logic to check for args with multiple anonymous functions. For instance,\n// the following call should be split on multiple lines for readability:\n// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))\n\n\n// Logic to determine if a call is a \u201clong curried function call\u201d.\n// See https://github.com/prettier/prettier/issues/1420.\n//\n// `connect(a, b, c)(d)`\n// In the above call expression, the second call is the parent node and the\n// first call is the current node.\n\n\n/**\n * @param {import('estree').Node} node\n * @param {number} depth\n * @returns {boolean}\n */\n\n\n"
    },
    "3": {
        "bug_file": "src/common/errors.js",
        "compressed": "NO",
        "line_numbers": 11,
        "compressed_line_numbers": 11,
        "compressed_bug_file_content": "\"use strict\";\n\nclass ConfigError extends Error {}\nclass DebugError extends Error {}\nclass UndefinedParserError extends Error {}\n\nmodule.exports = {\n  ConfigError,\n  DebugError,\n  UndefinedParserError,\n};"
    },
    "4": {
        "bug_file": "src/language-js/options.js",
        "compressed": "NO",
        "line_numbers": 100,
        "compressed_line_numbers": 100,
        "compressed_bug_file_content": "\"use strict\";\n\nconst commonOptions = require(\"../common/common-options\");\n\nconst CATEGORY_JAVASCRIPT = \"JavaScript\";\n\n// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\nmodule.exports = {\n  arrowParens: {\n    since: \"1.9.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: [\n      { since: \"1.9.0\", value: \"avoid\" },\n      { since: \"2.0.0\", value: \"always\" },\n    ],\n    description: \"Include parentheses around a sole arrow function parameter.\",\n    choices: [\n      {\n        value: \"always\",\n        description: \"Always include parens. Example: `(x) => x`\",\n      },\n      {\n        value: \"avoid\",\n        description: \"Omit parens when possible. Example: `x => x`\",\n      },\n    ],\n  },\n  bracketSpacing: commonOptions.bracketSpacing,\n  jsxBracketSameLine: {\n    since: \"0.17.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Put > on the last line instead of at a new line.\",\n  },\n  semi: {\n    since: \"1.0.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: true,\n    description: \"Print semicolons.\",\n    oppositeDescription:\n      \"Do not print semicolons, except at the beginning of lines which may need them.\",\n  },\n  singleQuote: commonOptions.singleQuote,\n  jsxSingleQuote: {\n    since: \"1.15.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Use single quotes in JSX.\",\n  },\n  quoteProps: {\n    since: \"1.17.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"as-needed\",\n    description: \"Change when properties in objects are quoted.\",\n    choices: [\n      {\n        value: \"as-needed\",\n        description: \"Only add quotes around object properties where required.\",\n      },\n      {\n        value: \"consistent\",\n        description:\n          \"If at least one property in an object requires quotes, quote all properties.\",\n      },\n      {\n        value: \"preserve\",\n        description: \"Respect the input use of quotes in object properties.\",\n      },\n    ],\n  },\n  trailingComma: {\n    since: \"0.0.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: [\n      { since: \"0.0.0\", value: false },\n      { since: \"0.19.0\", value: \"none\" },\n      { since: \"2.0.0\", value: \"es5\" },\n    ],\n    description: \"Print trailing commas wherever possible when multi-line.\",\n    choices: [\n      {\n        value: \"es5\",\n        description:\n          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",\n      },\n      { value: \"none\", description: \"No trailing commas.\" },\n      {\n        value: \"all\",\n        description:\n          \"Trailing commas wherever possible (including function arguments).\",\n      },\n    ],\n  },\n};"
    },
    "5": {
        "bug_file": "src/language-js/parser-flow.js",
        "compressed": "NO",
        "line_numbers": 40,
        "compressed_line_numbers": 40,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst includeShebang = require(\"../common/parser-include-shebang\");\nconst { hasPragma } = require(\"./pragma\");\nconst locFns = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction parse(text, parsers, opts) {\n  // Inline the require to avoid loading all the JS if we don't use it\n  const flowParser = require(\"flow-parser\");\n\n  const ast = flowParser.parse(text, {\n    enums: true,\n    esproposal_decorators: true,\n    esproposal_class_instance_fields: true,\n    esproposal_class_static_fields: true,\n    esproposal_export_star_as: true,\n    esproposal_optional_chaining: true,\n    esproposal_nullish_coalescing: true,\n  });\n\n  if (ast.errors.length > 0) {\n    const { loc } = ast.errors[0];\n    throw createError(ast.errors[0].message, {\n      start: { line: loc.start.line, column: loc.start.column + 1 },\n      end: { line: loc.end.line, column: loc.end.column + 1 },\n    });\n  }\n\n  includeShebang(text, ast);\n  return postprocess(ast, { ...opts, originalText: text });\n}\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    flow: { parse, astFormat: \"estree\", hasPragma, ...locFns },\n  },\n};"
    },
    "6": {
        "bug_file": "src/language-js/parser-typescript.js",
        "compressed": "NO",
        "line_numbers": 69,
        "compressed_line_numbers": 69,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst includeShebang = require(\"../common/parser-include-shebang\");\nconst { hasPragma } = require(\"./pragma\");\nconst locFns = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction parse(text, parsers, opts) {\n  const jsx = isProbablyJsx(text);\n  let ast;\n  try {\n    // Try passing with our best guess first.\n    ast = tryParseTypeScript(text, jsx);\n  } catch (firstError) {\n    try {\n      // But if we get it wrong, try the opposite.\n      ast = tryParseTypeScript(text, !jsx);\n    } catch (secondError) {\n      // suppose our guess is correct\n      const e = firstError;\n\n      if (typeof e.lineNumber === \"undefined\") {\n        throw e;\n      }\n\n      throw createError(e.message, {\n        start: { line: e.lineNumber, column: e.column + 1 },\n      });\n    }\n  }\n\n  includeShebang(text, ast);\n  return postprocess(ast, { ...opts, originalText: text });\n}\n\nfunction tryParseTypeScript(text, jsx) {\n  const parser = require(\"@typescript-eslint/typescript-estree\");\n  return parser.parse(text, {\n    loc: true,\n    range: true,\n    comment: true,\n    useJSXTextNode: true,\n    jsx,\n  });\n}\n\n/**\n * Use a naive regular expression to detect JSX\n */\nfunction isProbablyJsx(text) {\n  return new RegExp(\n    [\n      \"(^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string\n      \"|\",\n      \"(^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"\n    ].join(\"\"),\n    \"m\"\n  ).test(text);\n}\n\nconst parser = { parse, astFormat: \"estree\", hasPragma, ...locFns };\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    typescript: parser,\n  },\n};"
    }
}