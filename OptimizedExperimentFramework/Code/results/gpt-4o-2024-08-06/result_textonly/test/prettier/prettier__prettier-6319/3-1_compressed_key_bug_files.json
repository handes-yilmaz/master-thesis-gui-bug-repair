{
    "1": {
        "bug_file": "src/language-js/parser-babel.js",
        "compressed": "NO",
        "line_numbers": 199,
        "compressed_line_numbers": 199,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst { hasPragma } = require(\"./pragma\");\nconst locFns = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction babelOptions(extraPlugins = []) {\n  return {\n    sourceType: \"module\",\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowUndeclaredExports: true,\n    errorRecovery: true,\n    createParenthesizedExpressions: true,\n    plugins: [\n      \"doExpressions\",\n      \"objectRestSpread\",\n      \"classProperties\",\n      \"exportDefaultFrom\",\n      \"exportNamespaceFrom\",\n      \"asyncGenerators\",\n      \"functionBind\",\n      \"functionSent\",\n      \"dynamicImport\",\n      \"numericSeparator\",\n      \"importMeta\",\n      \"optionalCatchBinding\",\n      \"optionalChaining\",\n      \"classPrivateProperties\",\n      [\"pipelineOperator\", { proposal: \"minimal\" }],\n      \"nullishCoalescingOperator\",\n      \"bigInt\",\n      \"throwExpressions\",\n      \"logicalAssignment\",\n      \"classPrivateMethods\",\n      \"v8intrinsic\",\n      \"partialApplication\",\n      [\"decorators\", { decoratorsBeforeExport: false }],\n      ...extraPlugins,\n    ],\n  };\n}\n\nfunction createParse(parseMethod, ...pluginCombinations) {\n  return (text, parsers, opts) => {\n    // Inline the require to avoid loading all the JS if we don't use it\n    const babel = require(\"@babel/parser\");\n\n    let ast;\n    try {\n      ast = tryCombinations(\n        (options) => babel[parseMethod](text, options),\n        pluginCombinations.map(babelOptions)\n      );\n    } catch (error) {\n      throw createError(\n        // babel error prints (l:c) with cols that are zero indexed\n        // so we need our custom error\n        error.message.replace(/ \\(.*\\)/, \"\"),\n        {\n          start: {\n            line: error.loc.line,\n            column: error.loc.column + 1,\n          },\n        }\n      );\n    }\n    delete ast.tokens;\n    return postprocess(ast, { ...opts, originalText: text });\n  };\n}\n\nconst parse = createParse(\"parse\", [\"jsx\", \"flow\"]);\nconst parseFlow = createParse(\"parse\", [\n  \"jsx\",\n  [\"flow\", { all: true, enums: true }],\n]);\nconst parseTypeScript = createParse(\n  \"parse\",\n  [\"jsx\", \"typescript\"],\n  [\"typescript\"]\n);\nconst parseExpression = createParse(\"parseExpression\", [\"jsx\"]);\n\nfunction tryCombinations(fn, combinations) {\n  let error;\n  for (let i = 0; i < combinations.length; i++) {\n    try {\n      return fn(combinations[i]);\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n  throw error;\n}\n\nfunction parseJson(text, parsers, opts) {\n  const ast = parseExpression(text, parsers, opts);\n\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n    case \"ObjectProperty\":\n      // istanbul ignore if\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      }\n      // istanbul ignore if\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n      return [node.key, node.value].forEach(assertJsonChildNode);\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        // istanbul ignore next\n        default:\n          throw createJsonError(\"operator\");\n      }\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n      throw createJsonError();\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    // istanbul ignore next\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  }\n\n  // istanbul ignore next\n  function createJsonError(attribute) {\n    const name = !attribute\n      ? node.type\n      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;\n    return createError(`${name} is not allowed in JSON.`, {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1,\n      },\n    });\n  }\n}\n\nconst babel = { parse, astFormat: \"estree\", hasPragma, ...locFns };\nconst babelFlow = { ...babel, parse: parseFlow };\nconst babelTypeScript = { ...babel, parse: parseTypeScript };\nconst babelExpression = { ...babel, parse: parseExpression };\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    babel,\n    \"babel-flow\": babelFlow,\n    \"babel-ts\": babelTypeScript,\n    json: {\n      ...babelExpression,\n      hasPragma() {\n        return true;\n      },\n    },\n    json5: babelExpression,\n    \"json-stringify\": {\n      parse: parseJson,\n      astFormat: \"estree-json\",\n      ...locFns,\n    },\n    /** @internal */\n    __js_expression: babelExpression,\n    /** for vue filter */\n    __vue_expression: babelExpression,\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel,\n  },\n};"
    }
}