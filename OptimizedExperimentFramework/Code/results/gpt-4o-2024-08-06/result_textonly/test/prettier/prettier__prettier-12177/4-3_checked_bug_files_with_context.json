{
    "src/language-js/printer-estree.js": [
        "\"use strict\";",
        "",
        "/** @typedef {import(\"../document\").Doc} Doc */",
        "",
        "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
        "const { printDanglingComments } = require(\"../main/comments.js\");",
        "const { hasNewline } = require(\"../common/util.js\");",
        "const {",
        "  builders: { join, line, hardline, softline, group, indent },",
        "  utils: { replaceTextEndOfLine },",
        "} = require(\"../document/index.js\");",
        "const embed = require(\"./embed.js\");",
        "const clean = require(\"./clean.js\");",
        "const { insertPragma } = require(\"./pragma.js\");",
        "const handleComments = require(\"./comments.js\");",
        "const pathNeedsParens = require(\"./needs-parens.js\");",
        "const preprocess = require(\"./print-preprocess.js\");",
        "const {",
        "  hasFlowShorthandAnnotationComment,",
        "  hasComment,",
        "  CommentCheckFlags,",
        "  isTheOnlyJsxElementInMarkdown,",
        "  isLineComment,",
        "  isNextLineEmpty,",
        "  needsHardlineAfterDanglingComment,",
        "  rawText,",
        "  hasIgnoreComment,",
        "  isCallExpression,",
        "  isMemberExpression,",
        "  markerForIfWithoutBlockAndSameLineComment,",
        "} = require(\"./utils/index.js\");",
        "const { locStart, locEnd } = require(\"./loc.js\");",
        "const isBlockComment = require(\"./utils/is-block-comment.js\");",
        "",
        "const {",
        "  printHtmlBinding,",
        "  isVueEventBindingExpression,",
        "} = require(\"./print/html-binding.js\");",
        "const { printAngular } = require(\"./print/angular.js\");",
        "const { printJsx, hasJsxIgnoreComment } = require(\"./print/jsx.js\");",
        "const { printFlow } = require(\"./print/flow.js\");",
        "const { printTypescript } = require(\"./print/typescript.js\");",
        "const {",
        "  printOptionalToken,",
        "  printBindExpressionCallee,",
        "  printTypeAnnotation,",
        "  adjustClause,",
        "  printRestSpread,",
        "} = require(\"./print/misc.js\");",
        "const {",
        "  printImportDeclaration,",
        "  printExportDeclaration,",
        "  printExportAllDeclaration,",
        "  printModuleSpecifier,",
        "} = require(\"./print/module.js\");",
        "const { printTernary } = require(\"./print/ternary.js\");",
        "const { printTemplateLiteral } = require(\"./print/template-literal.js\");",
        "const { printArray } = require(\"./print/array.js\");",
        "const { printObject } = require(\"./print/object.js\");",
        "const {",
        "  printClass,",
        "  printClassMethod,",
        "  printClassProperty,",
        "} = require(\"./print/class.js\");",
        "const { printProperty } = require(\"./print/property.js\");",
        "const {",
        "  printFunction,",
        "  printArrowFunction,",
        "  printMethod,",
        "  printReturnStatement,",
        "  printThrowStatement,",
        "} = require(\"./print/function.js\");",
        "const { printCallExpression } = require(\"./print/call-expression.js\");",
        "const {",
        "  printVariableDeclarator,",
        "  printAssignmentExpression,",
        "} = require(\"./print/assignment.js\");",
        "const { printBinaryishExpression } = require(\"./print/binaryish.js\");",
        "const { printSwitchCaseConsequent } = require(\"./print/statement.js\");",
        "const { printMemberExpression } = require(\"./print/member.js\");",
        "const { printBlock, printBlockBody } = require(\"./print/block.js\");",
        "const { printComment } = require(\"./print/comment.js\");",
        "const { printLiteral } = require(\"./print/literal.js\");",
        "const { printDecorators } = require(\"./print/decorators.js\");",
        "",
        "function genericPrint(path, options, print, args) {",
        "  const printed = printPathNoParens(path, options, print, args);",
        "  if (!printed) {",
        "    return \"\";",
        "  }",
        "",
        "  const node = path.getValue();",
        "  const { type } = node;",
        "  // Their decorators are handled themselves, and they can't have parentheses",
        "  if (",
        "    type === \"ClassMethod\" ||",
        "    type === \"ClassPrivateMethod\" ||",
        "    type === \"ClassProperty\" ||",
        "    type === \"PropertyDefinition\" ||",
        "    type === \"TSAbstractPropertyDefinition\" ||",
        "    type === \"ClassPrivateProperty\" ||",
        "    type === \"MethodDefinition\" ||",
        "    type === \"TSAbstractMethodDefinition\" ||",
        "    type === \"TSDeclareMethod\"",
        "  ) {",
        "    return printed;",
        "  }",
        "",
        "  const printedDecorators = printDecorators(path, options, print);",
        "  // Nodes with decorators can't have parentheses and don't need leading semicolons",
        "  if (printedDecorators) {",
        "    return group([...printedDecorators, printed]);",
        "  }",
        "",
        "  const needsParens = pathNeedsParens(path, options);",
        "",
        "  if (!needsParens) {",
        "    return args && args.needsSemi ? [\";\", printed] : printed;",
        "  }",
        "",
        "  const parts = [args && args.needsSemi ? \";(\" : \"(\", printed];",
        "",
        "  if (hasFlowShorthandAnnotationComment(node)) {",
        "    const [comment] = node.trailingComments;",
        "    parts.push(\" /*\", comment.value.trimStart(), \"*/\");",
        "    comment.printed = true;",
        "  }",
        "",
        "  parts.push(\")\");",
        "",
        "  return parts;",
        "}",
        "",
        "function printPathNoParens(path, options, print, args) {",
        "  const node = path.getValue();",
        "  const semi = options.semi ? \";\" : \"\";",
        "",
        "  if (!node) {",
        "    return \"\";",
        "  }",
        "",
        "  if (typeof node === \"string\") {",
        "    return node;",
        "  }",
        "",
        "  for (const printer of [",
        "    printLiteral,",
        "    printHtmlBinding,",
        "    printAngular,",
        "    printJsx,",
        "    printFlow,",
        "    printTypescript,",
        "  ]) {",
        "    const printed = printer(path, options, print);",
        "    if (typeof printed !== \"undefined\") {",
        "      return printed;",
        "    }",
        "  }",
        "",
        "  /** @type{Doc[]} */",
        "  let parts = [];",
        "",
        "  switch (node.type) {",
        "    case \"JsExpressionRoot\":",
        "      return print(\"node\");",
        "    case \"JsonRoot\":",
        "      return [print(\"node\"), hardline];",
        "    case \"File\":",
        "      // Print @babel/parser's InterpreterDirective here so that",
        "      // leading comments on the `Program` node get printed after the hashbang.",
        "      if (node.program && node.program.interpreter) {",
        "        parts.push(print([\"program\", \"interpreter\"]));",
        "      }",
        "",
        "      parts.push(print(\"program\"));",
        "",
        "      return parts;",
        "",
        "    case \"Program\":",
        "      return printBlockBody(path, options, print);",
        "    // Babel extension.",
        "    case \"EmptyStatement\":",
        "      return \"\";",
        "    case \"ExpressionStatement\": {",
        "      // Detect Flow and TypeScript directives",
        "      if (node.directive) {",
        "        return [printDirective(node.expression, options), semi];",
        "      }",
        "",
        "      if (options.parser === \"__vue_event_binding\") {",
        "        const parent = path.getParentNode();",
        "        if (",
        "          parent.type === \"Program\" &&",
        "          parent.body.length === 1 &&",
        "          parent.body[0] === node",
        "        ) {",
        "          return [",
        "            print(\"expression\"),",
        "            isVueEventBindingExpression(node.expression) ? \";\" : \"\",",
        "          ];",
        "        }",
        "      }",
        "",
        "      const danglingComment = printDanglingComments(",
        "        path,",
        "        options,",
        "        /** sameIndent */ true,",
        "        ({ marker }) => marker === markerForIfWithoutBlockAndSameLineComment",
        "      );",
        "",
        "      // Do not append semicolon after the only JSX element in a program",
        "      return [",
        "        print(\"expression\"),",
        "        isTheOnlyJsxElementInMarkdown(options, path) ? \"\" : semi,",
        "        danglingComment ? [\" \", danglingComment] : \"\",",
        "      ];",
        "    }",
        "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
        "    case \"ParenthesizedExpression\": {",
        "      const shouldHug =",
        "        !hasComment(node.expression) &&",
        "        (node.expression.type === \"ObjectExpression\" ||",
        "          node.expression.type === \"ArrayExpression\");",
        "      if (shouldHug) {",
        "        return [\"(\", print(\"expression\"), \")\"];",
        "      }",
        "      return group([",
        "        \"(\",",
        "        indent([softline, print(\"expression\")]),",
        "        softline,",
        "        \")\",",
        "      ]);",
        "    }",
        "    case \"AssignmentExpression\":",
        "      return printAssignmentExpression(path, options, print);",
        "    case \"VariableDeclarator\":",
        "      return printVariableDeclarator(path, options, print);",
        "    case \"BinaryExpression\":",
        "    case \"LogicalExpression\":",
        "      return printBinaryishExpression(path, options, print);",
        "    case \"AssignmentPattern\":",
        "      return [print(\"left\"), \" = \", print(\"right\")];",
        "    case \"OptionalMemberExpression\":",
        "    case \"MemberExpression\": {",
        "      return printMemberExpression(path, options, print);",
        "    }",
        "    case \"MetaProperty\":",
        "      return [print(\"meta\"), \".\", print(\"property\")];",
        "    case \"BindExpression\":",
        "      if (node.object) {",
        "        parts.push(print(\"object\"));",
        "      }",
        "",
        "      parts.push(",
        "        group(",
        "          indent([softline, printBindExpressionCallee(path, options, print)])",
        "        )",
        "      );",
        "",
        "      return parts;",
        "    case \"Identifier\": {",
        "      return [",
        "        node.name,",
        "        printOptionalToken(path),",
        "        printTypeAnnotation(path, options, print),",
        "      ];",
        "    }",
        "    case \"V8IntrinsicIdentifier\":",
        "      return [\"%\", node.name];",
        "    case \"SpreadElement\":",
        "    case \"SpreadElementPattern\":",
        "    case \"SpreadProperty\":",
        "    case \"SpreadPropertyPattern\":",
        "    case \"RestElement\":",
        "      return printRestSpread(path, options, print);",
        "    case \"FunctionDeclaration\":",
        "    case \"FunctionExpression\":",
        "      return printFunction(path, print, options, args);",
        "    case \"ArrowFunctionExpression\":",
        "      return printArrowFunction(path, options, print, args);",
        "    case \"YieldExpression\":",
        "      parts.push(\"yield\");",
        "",
        "      if (node.delegate) {",
        "        parts.push(\"*\");",
        "      }",
        "      if (node.argument) {",
        "        parts.push(\" \", print(\"argument\"));",
        "      }",
        "",
        "      return parts;",
        "    case \"AwaitExpression\": {",
        "      parts.push(\"await\");",
        "      if (node.argument) {",
        "        parts.push(\" \", print(\"argument\"));",
        "        const parent = path.getParentNode();",
        "        if (",
        "          (isCallExpression(parent) && parent.callee === node) ||",
        "          (isMemberExpression(parent) && parent.object === node)",
        "        ) {",
        "          parts = [indent([softline, ...parts]), softline];",
        "          const parentAwaitOrBlock = path.findAncestor(",
        "            (node) =>",
        "              node.type === \"AwaitExpression\" || node.type === \"BlockStatement\"",
        "          );",
        "          if (",
        "            !parentAwaitOrBlock ||",
        "            parentAwaitOrBlock.type !== \"AwaitExpression\"",
        "          ) {",
        "            return group(parts);",
        "          }",
        "        }",
        "      }",
        "      return parts;",
        "    }",
        "    case \"ExportDefaultDeclaration\":",
        "    case \"ExportNamedDeclaration\":",
        "      return printExportDeclaration(path, options, print);",
        "    case \"ExportAllDeclaration\":",
        "      return printExportAllDeclaration(path, options, print);",
        "    case \"ImportDeclaration\":",
        "      return printImportDeclaration(path, options, print);",
        "    case \"ImportSpecifier\":",
        "    case \"ExportSpecifier\":",
        "    case \"ImportNamespaceSpecifier\":",
        "    case \"ExportNamespaceSpecifier\":",
        "    case \"ImportDefaultSpecifier\":",
        "    case \"ExportDefaultSpecifier\":",
        "      return printModuleSpecifier(path, options, print);",
        "    case \"ImportAttribute\":",
        "      return [print(\"key\"), \": \", print(\"value\")];",
        "    case \"Import\":",
        "      return \"import\";",
        "    case \"BlockStatement\":",
        "    case \"StaticBlock\":",
        "    case \"ClassBody\":",
        "      return printBlock(path, options, print);",
        "    case \"ThrowStatement\":",
        "      return printThrowStatement(path, options, print);",
        "    case \"ReturnStatement\":",
        "      return printReturnStatement(path, options, print);",
        "    case \"NewExpression\":",
        "    case \"ImportExpression\":",
        "    case \"OptionalCallExpression\":",
        "    case \"CallExpression\":",
        "      return printCallExpression(path, options, print);",
        "",
        "    case \"ObjectExpression\":",
        "    case \"ObjectPattern\":",
        "    case \"RecordExpression\":",
        "      return printObject(path, options, print);",
        "    // Babel 6",
        "    case \"ObjectProperty\": // Non-standard AST node type.",
        "    case \"Property\":",
        "      if (node.method || node.kind === \"get\" || node.kind === \"set\") {",
        "        return printMethod(path, options, print);",
        "      }",
        "      return printProperty(path, options, print);",
        "    case \"ObjectMethod\":",
        "      return printMethod(path, options, print);",
        "    case \"Decorator\":",
        "      return [\"@\", print(\"expression\")];",
        "    case \"ArrayExpression\":",
        "    case \"ArrayPattern\":",
        "    case \"TupleExpression\":",
        "      return printArray(path, options, print);",
        "    case \"SequenceExpression\": {",
        "      const parent = path.getParentNode(0);",
        "      if (",
        "        parent.type === \"ExpressionStatement\" ||",
        "        parent.type === \"ForStatement\"",
        "      ) {",
        "        // For ExpressionStatements and for-loop heads, which are among",
        "        // the few places a SequenceExpression appears unparenthesized, we want",
        "        // to indent expressions after the first.",
        "        const parts = [];",
        "        path.each((expressionPath, index) => {",
        "          if (index === 0) {",
        "            parts.push(print());",
        "          } else {",
        "            parts.push(\",\", indent([line, print()]));",
        "          }",
        "        }, \"expressions\");",
        "        return group(parts);",
        "      }",
        "      return group(join([\",\", line], path.map(print, \"expressions\")));",
        "    }",
        "    case \"ThisExpression\":",
        "      return \"this\";",
        "    case \"Super\":",
        "      return \"super\";",
        "    case \"Directive\":",
        "      return [print(\"value\"), semi]; // Babel 6",
        "    case \"DirectiveLiteral\":",
        "      return printDirective(node, options);",
        "    case \"UnaryExpression\":",
        "      parts.push(node.operator);",
        "",
        "      if (/[a-z]$/.test(node.operator)) {",
        "        parts.push(\" \");",
        "      }",
        "",
        "      if (hasComment(node.argument)) {",
        "        parts.push(",
        "          group([\"(\", indent([softline, print(\"argument\")]), softline, \")\"])",
        "        );",
        "      } else {",
        "        parts.push(print(\"argument\"));",
        "      }",
        "",
        "      return parts;",
        "    case \"UpdateExpression\":",
        "      parts.push(print(\"argument\"), node.operator);",
        "",
        "      if (node.prefix) {",
        "        parts.reverse();",
        "      }",
        "",
        "      return parts;",
        "    case \"ConditionalExpression\":",
        "      return printTernary(path, options, print);",
        "    case \"VariableDeclaration\": {",
        "      const printed = path.map(print, \"declarations\");",
        "",
        "      // We generally want to terminate all variable declarations with a",
        "      // semicolon, except when they in the () part of for loops.",
        "      const parentNode = path.getParentNode();",
        "",
        "      const isParentForLoop =",
        "        parentNode.type === \"ForStatement\" ||",
        "        parentNode.type === \"ForInStatement\" ||",
        "        parentNode.type === \"ForOfStatement\";",
        "",
        "      const hasValue = node.declarations.some((decl) => decl.init);",
        "",
        "      let firstVariable;",
        "      if (printed.length === 1 && !hasComment(node.declarations[0])) {",
        "        firstVariable = printed[0];",
        "      } else if (printed.length > 0) {",
        "        // Indent first var to comply with eslint one-var rule",
        "        firstVariable = indent(printed[0]);",
        "      }",
        "",
        "      parts = [",
        "        node.declare ? \"declare \" : \"\",",
        "        node.kind,",
        "        firstVariable ? [\" \", firstVariable] : \"\",",
        "        indent(",
        "          printed",
        "            .slice(1)",
        "            .map((p) => [",
        "              \",\",",
        "              hasValue && !isParentForLoop ? hardline : line,",
        "              p,",
        "            ])",
        "        ),",
        "      ];",
        "",
        "      if (!(isParentForLoop && parentNode.body !== node)) {",
        "        parts.push(semi);",
        "      }",
        "",
        "      return group(parts);",
        "    }",
        "    case \"WithStatement\":",
        "      return group([",
        "        \"with (\",",
        "        print(\"object\"),",
        "        \")\",",
        "        adjustClause(node.body, print(\"body\")),",
        "      ]);",
        "    case \"IfStatement\": {",
        "      const con = adjustClause(node.consequent, print(\"consequent\"));",
        "      const opening = group([",
        "        \"if (\",",
        "        group([indent([softline, print(\"test\")]), softline]),",
        "        \")\",",
        "        con,",
        "      ]);",
        "",
        "      parts.push(opening);",
        "",
        "      if (node.alternate) {",
        "        const commentOnOwnLine =",
        "          hasComment(",
        "            node.consequent,",
        "            CommentCheckFlags.Trailing | CommentCheckFlags.Line",
        "          ) || needsHardlineAfterDanglingComment(node);",
        "        const elseOnSameLine =",
        "          node.consequent.type === \"BlockStatement\" && !commentOnOwnLine;",
        "        parts.push(elseOnSameLine ? \" \" : hardline);",
        "",
        "        if (hasComment(node, CommentCheckFlags.Dangling)) {",
        "          parts.push(",
        "            printDanglingComments(path, options, true),",
        "            commentOnOwnLine ? hardline : \" \"",
        "          );",
        "        }",
        "",
        "        parts.push(",
        "          \"else\",",
        "..."
    ],
    "src/language-js/print/statement.js": [
        "\"use strict\";",
        "",
        "const {",
        "  builders: { hardline },",
        "} = require(\"../../document/index.js\");",
        "const pathNeedsParens = require(\"../needs-parens.js\");",
        "const {",
        "  getLeftSidePathName,",
        "  hasNakedLeftSide,",
        "  isJsxNode,",
        "  isTheOnlyJsxElementInMarkdown,",
        "  hasComment,",
        "  CommentCheckFlags,",
        "  isNextLineEmpty,",
        "} = require(\"../utils/index.js\");",
        "const { shouldPrintParamsWithoutParens } = require(\"./function.js\");",
        "",
        "/**",
        " * @typedef {import(\"../../document\").Doc} Doc",
        " * @typedef {import(\"../../common/ast-path\")} AstPath",
        " */",
        "",
        "function printStatementSequence(path, options, print, property) {",
        "  const node = path.getValue();",
        "  const parts = [];",
        "  const isClassBody = node.type === \"ClassBody\";",
        "  const lastStatement = getLastStatement(node[property]);",
        "",
        "  path.each((path, index, statements) => {",
        "    const node = path.getValue();",
        "",
        "    // Skip printing EmptyStatement nodes to avoid leaving stray",
        "    // semicolons lying around.",
        "    if (node.type === \"EmptyStatement\") {",
        "      return;",
        "    }",
        "",
        "    const printed = print();",
        "",
        "    // in no-semi mode, prepend statement with semicolon if it might break ASI",
        "    // don't prepend the only JSX element in a program with semicolon",
        "    if (",
        "      !options.semi &&",
        "      !isClassBody &&",
        "      !isTheOnlyJsxElementInMarkdown(options, path) &&",
        "      statementNeedsASIProtection(path, options)",
        "    ) {",
        "      if (hasComment(node, CommentCheckFlags.Leading)) {",
        "        parts.push(print([], { needsSemi: true }));",
        "      } else {",
        "        parts.push(\";\", printed);",
        "      }",
        "    } else {",
        "      parts.push(printed);",
        "    }",
        "",
        "    if (",
        "      !options.semi &&",
        "      isClassBody &&",
        "      isClassProperty(node) &&",
        "      // `ClassBody` don't allow `EmptyStatement`,",
        "      // so we can use `statements` to get next node",
        "      shouldPrintSemicolonAfterClassProperty(node, statements[index + 1])",
        "    ) {",
        "      parts.push(\";\");",
        "    }",
        "",
        "    if (node !== lastStatement) {",
        "      parts.push(hardline);",
        "",
        "      if (isNextLineEmpty(node, options)) {",
        "        parts.push(hardline);",
        "      }",
        "    }",
        "  }, property);",
        "",
        "  return parts;",
        "}",
        "",
        "function getLastStatement(statements) {",
        "  for (let i = statements.length - 1; i >= 0; i--) {",
        "    const statement = statements[i];",
        "    if (statement.type !== \"EmptyStatement\") {",
        "      return statement;",
        "    }",
        "  }",
        "}",
        "",
        "function statementNeedsASIProtection(path, options) {",
        "  const node = path.getNode();",
        "",
        "  if (node.type !== \"ExpressionStatement\") {",
        "    return false;",
        "  }",
        "",
        "  return path.call(",
        "    (childPath) => expressionNeedsASIProtection(childPath, options),",
        "    \"expression\"",
        "  );",
        "}",
        "",
        "function expressionNeedsASIProtection(path, options) {",
        "  const node = path.getValue();",
        "  switch (node.type) {",
        "    case \"ParenthesizedExpression\":",
        "    case \"TypeCastExpression\":",
        "    case \"ArrayExpression\":",
        "    case \"ArrayPattern\":",
        "    case \"TemplateLiteral\":",
        "    case \"TemplateElement\":",
        "    case \"RegExpLiteral\":",
        "      return true;",
        "    case \"ArrowFunctionExpression\": {",
        "      if (!shouldPrintParamsWithoutParens(path, options)) {",
        "        return true;",
        "      }",
        "      break;",
        "    }",
        "    case \"UnaryExpression\": {",
        "      const { prefix, operator } = node;",
        "      if (prefix && (operator === \"+\" || operator === \"-\")) {",
        "        return true;",
        "      }",
        "      break;",
        "    }",
        "    case \"BindExpression\": {",
        "      if (!node.object) {",
        "        return true;",
        "      }",
        "      break;",
        "    }",
        "    case \"Literal\": {",
        "      if (node.regex) {",
        "        return true;",
        "      }",
        "      break;",
        "    }",
        "    default: {",
        "      if (isJsxNode(node)) {",
        "        return true;",
        "      }",
        "    }",
        "  }",
        "",
        "  if (pathNeedsParens(path, options)) {",
        "    return true;",
        "  }",
        "",
        "  if (!hasNakedLeftSide(node)) {",
        "    return false;",
        "  }",
        "",
        "  return path.call(",
        "    (childPath) => expressionNeedsASIProtection(childPath, options),",
        "    ...getLeftSidePathName(path, node)",
        "  );",
        "}",
        "",
        "function printBody(path, options, print) {",
        "  return printStatementSequence(path, options, print, \"body\");",
        "}",
        "",
        "function printSwitchCaseConsequent(path, options, print) {",
        "  return printStatementSequence(path, options, print, \"consequent\");",
        "}",
        "",
        "const isClassProperty = ({ type }) =>",
        "  type === \"ClassProperty\" ||",
        "  type === \"PropertyDefinition\" ||",
        "  type === \"ClassPrivateProperty\";",
        "/**",
        " * @returns {boolean}",
        " */",
        "function shouldPrintSemicolonAfterClassProperty(node, nextNode) {",
        "  const name = node.key && node.key.name;",
        "  // this isn't actually possible yet with most parsers available today",
        "  // so isn't properly tested yet.",
        "  if (",
        "    (name === \"static\" || name === \"get\" || name === \"set\") &&",
        "    !node.value &&",
        "    !node.typeAnnotation",
        "  ) {",
        "    return true;",
        "  }",
        "",
        "  if (!nextNode) {",
        "    return false;",
        "  }",
        "",
        "  if (",
        "    nextNode.static ||",
        "    nextNode.accessibility // TypeScript",
        "  ) {",
        "    return false;",
        "  }",
        "",
        "  if (!nextNode.computed) {",
        "    const name = nextNode.key && nextNode.key.name;",
        "    if (name === \"in\" || name === \"instanceof\") {",
        "      return true;",
        "    }",
        "  }",
        "",
        "  // Flow variance sigil +/- requires semi if there's no",
        "  // \"declare\" or \"static\" keyword before it.",
        "  if (",
        "    isClassProperty(nextNode) &&",
        "    nextNode.variance &&",
        "    !nextNode.static &&",
        "    !nextNode.declare",
        "  ) {",
        "    return true;",
        "  }",
        "",
        "  switch (nextNode.type) {",
        "    case \"ClassProperty\":",
        "    case \"PropertyDefinition\":",
        "    case \"TSAbstractPropertyDefinition\":",
        "      return nextNode.computed;",
        "    case \"MethodDefinition\": // Flow",
        "    case \"TSAbstractMethodDefinition\": // TypeScript",
        "    case \"ClassMethod\":",
        "    case \"ClassPrivateMethod\": {",
        "      // Babel",
        "      const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;",
        "      if (isAsync || nextNode.kind === \"get\" || nextNode.kind === \"set\") {",
        "        return false;",
        "      }",
        "",
        "      const isGenerator = nextNode.value",
        "        ? nextNode.value.generator",
        "        : nextNode.generator;",
        "      if (nextNode.computed || isGenerator) {",
        "        return true;",
        "      }",
        "",
        "      return false;",
        "    }",
        "",
        "    case \"TSIndexSignature\":",
        "      return true;",
        "  }",
        "",
        "  /* istanbul ignore next */",
        "  return false;",
        "}",
        "",
        "module.exports = {",
        "  printBody,",
        "  printSwitchCaseConsequent,",
        "};"
    ]
}