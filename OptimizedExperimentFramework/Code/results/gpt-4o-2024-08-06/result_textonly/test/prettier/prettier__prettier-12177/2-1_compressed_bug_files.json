{
    "1": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 826,
        "compressed_line_numbers": 86,
        "compressed_bug_file_content": "\n\n/** @typedef {import(\"../document\").Doc} Doc */\n\n// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\n  // Their decorators are handled themselves, and they can't have parentheses\n\n\n  // Nodes with decorators can't have parentheses and don't need leading semicolons\n\n\n  /** @type{Doc[]} */\n\n\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n\n\n    // Babel extension.\n\n\n      // Detect Flow and TypeScript directives\n\n\n        /** sameIndent */ true,\n\n\n      // Do not append semicolon after the only JSX element in a program\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n    // Babel 6\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n        /* sameLine */ true\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n    // For hack-style pipeline\n\n\n      /* istanbul ignore next */\n\n\n  // Check for the alternate quote, to determine if we're allowed to swap\n  // the quotes on a DirectiveLiteral.\n\n\n  // Directives are exact code unit sequences, which means that you can't\n  // change the escape sequences they use.\n  // See https://github.com/prettier/prettier/issues/1555\n  // and https://tc39.github.io/ecma262/#directive-prologue\n\n\n    // `babel-ts` don't have similar node for `class Foo { bar() /* bat */; }`\n\n\n    // TODO: Make this as default behavior\n\n\n"
    },
    "2": {
        "bug_file": "src/language-js/utils/index.js",
        "compressed": "YES",
        "line_numbers": 1377,
        "compressed_line_numbers": 462,
        "compressed_bug_file_content": "\n\n/**\n * @typedef {import(\"../types/estree\").Node} Node\n * @typedef {import(\"../types/estree\").TemplateLiteral} TemplateLiteral\n * @typedef {import(\"../types/estree\").Comment} Comment\n * @typedef {import(\"../types/estree\").MemberExpression} MemberExpression\n * @typedef {import(\"../types/estree\").OptionalMemberExpression} OptionalMemberExpression\n * @typedef {import(\"../types/estree\").CallExpression} CallExpression\n * @typedef {import(\"../types/estree\").OptionalCallExpression} OptionalCallExpression\n * @typedef {import(\"../types/estree\").Expression} Expression\n * @typedef {import(\"../types/estree\").Property} Property\n * @typedef {import(\"../types/estree\").ObjectTypeProperty} ObjectTypeProperty\n * @typedef {import(\"../types/estree\").TaggedTemplateExpression} TaggedTemplateExpression\n * @typedef {import(\"../types/estree\").Literal} Literal\n *\n * @typedef {import(\"../../common/ast-path\")} AstPath\n */\n\n// We match any whitespace except line terminators because\n// Flow annotation comments cannot be split across lines. For example:\n//\n// (this /*\n// : any */).foo = 5;\n//\n// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so\n// removing the newline would create a type annotation that the user did not intend\n// to create.\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n  // https://flow.org/en/docs/types/comments/\n  // Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");\n\n\n/**\n * @param {Comment[]} comments\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @param {(Node) => boolean} fn\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Comment} comment\n * @returns {boolean}\n */\n\n\n    // `meriyah` has `SingleLine`, `HashbangComment`, `HTMLOpen`, and `HTMLClose`\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {AstPath} path\n * @returns {Node | null}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * Note: `inject` is used in AngularJS 1.x, `async` and `fakeAsync` in\n * Angular 2+, although `async` is deprecated and replaced by `waitForAsync`\n * since Angular 12.\n *\n * example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-\n *\n * @param {CallExpression} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n// TODO: This is a bad hack and we need a better way to distinguish between\n// arrow functions and otherwise\n\n\n// Hack to differentiate between the following two which have the same ast\n// type T = { method: () => void };\n// type T = { method(): void };\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n// Hack to differentiate between the following two which have the same ast\n// declare function f(a): void;\n// var f: (a) => void;\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n  // `any`\n\n\n  // `null`\n\n\n  // `this`\n\n\n  // `number`\n\n\n  // `void`\n\n\n  // `boolean`\n\n\n  // `bigint`\n\n\n  // `symbol`\n\n\n  // `string`\n\n\n  // literals\n\n\n  // flow only, `empty`, `mixed`\n\n\n  // typescript only, `never`, `object`, `undefined`, `unknown`\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {{callee: MemberExpression | OptionalMemberExpression}} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {CallExpression} node\n * @returns {boolean}\n */\n\n\n// eg; `describe(\"some string\", (done) => {})`\n\n\n      // it(\"name\", () => { ... }, 2500)\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n *\n * @param {any} node\n * @returns {boolean}\n */\n\n\n    // Disallow comments since printDocToString can't print them here\n\n\n    // Allow `x` and `this`\n\n\n    // Allow `a.b.c`, `a.b[c]`, and `this.x.y`\n\n\n/**\n * @param {string} tokenNode\n * @param {string} keyword\n * @returns {string}\n */\n\n\n/**\n * @param {string} text\n * @param {Node} typeAnnotation\n * @returns {boolean}\n */\n\n\n/**\n * @param {string} text\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n// Note: Quoting/unquoting numbers in TypeScript is not safe.\n//\n// let a = { 1: 1, 2: 2 }\n// let b = { '1': 1, '2': 2 }\n//\n// declare let aa: keyof typeof a;\n// declare let bb: keyof typeof b;\n//\n// aa = bb;\n// ^^\n// Type '\"1\" | \"2\"' is not assignable to type '1 | 2'.\n//   Type '\"1\"' is not assignable to type '1 | 2'.(2322)\n//\n// And in Flow, you get:\n//\n// const x = {\n//   0: 1\n//   ^ Non-string literal property keys not supported. [unsupported-syntax]\n// }\n//\n// Angular does not support unquoted numbers in expressions.\n//\n// So we play it safe and only unquote numbers for the JavaScript parsers.\n// (Vue supports unquoted numbers in expressions, but let\u2019s keep it simple.)\n//\n// Identifiers can be unquoted in more circumstances, though.\n\n\n      // With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.\n      // See https://github.com/microsoft/TypeScript/pull/20075\n\n\n// Matches \u201csimple\u201d numbers like `123` and `2.5` but not `1_000`, `1e+100` or `0b10`.\n\n\n/**\n * @param {Node} node\n * @param {Node} parentNode\n * @returns {boolean}\n */\n\n  /**\n   * describe.each`table`(name, fn)\n   * describe.only.each`table`(name, fn)\n   * describe.skip.each`table`(name, fn)\n   * test.each`table`(name, fn)\n   * test.only.each`table`(name, fn)\n   * test.skip.each`table`(name, fn)\n   *\n   * Ref: https://github.com/facebook/jest/pull/6102\n   */\n\n\n/**\n * @param {TemplateLiteral} template\n * @returns {boolean}\n */\n\n\n/**\n * @param {TemplateLiteral | TaggedTemplateExpression} node\n * @param {string} text\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n// Logic to check for args with multiple anonymous functions. For instance,\n// the following call should be split on multiple lines for readability:\n// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))\n\n\n// Logic to determine if a call is a \u201clong curried function call\u201d.\n// See https://github.com/prettier/prettier/issues/1420.\n//\n// `connect(a, b, c)(d)`\n// In the above call expression, the second call is the parent node and the\n// first call is the current node.\n/**\n * @param {AstPath} path\n * @returns {boolean}\n */\n\n\n/**\n * @param {any} node\n * @param {number} depth\n * @returns {boolean}\n */\n\n\n/**\n * @param {any} options\n * @param {(\"es5\" | \"all\")} [level]\n * @returns {boolean}\n */\n\n\n/**\n * Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr\n * holds) `function`, `class`, or `do {}`. Will be overzealous if there's\n * already necessary grouping parentheses.\n *\n * @param {Node} node\n * @param {boolean} forbidFunctionClassAndDoExpr\n * @returns {boolean}\n */\n\n\n        // IIFEs are always already parenthesized\n\n\n        // IIFEs are always already parenthesized\n\n\n  // ** is right-associative\n  // x ** y ** z --> x ** (y ** z)\n\n\n  // x == y == z --> (x == y) == z\n\n\n  // x * y % z --> (x * y) % z\n\n\n  // x * y / z --> (x * y) / z\n  // x / y * z --> (x / y) * z\n\n\n  // x << y << z --> (x << y) << z\n\n\n  // `params` vs `parameters` - see https://github.com/babel/babel/issues/9231\n\n\n  /** Check comment is a leading comment */\n\n  /** Check comment is a trailing comment */\n\n  /** Check comment is a dangling comment */\n\n  /** Check comment is a block comment */\n\n  /** Check comment is a line comment */\n\n  /** Check comment is a `prettier-ignore` comment */\n\n  /** Check comment is the first attached comment */\n\n  /** Check comment is the last attached comment */\n\n\n/**\n * @param {Node} node\n * @param {number | function} [flags]\n * @param {function} [fn]\n * @returns {boolean}\n */\n\n\n/**\n * @param {Node} node\n * @param {number | function} [flags]\n * @param {function} [fn]\n * @returns {Comment[]}\n */\n\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\n\n\n/**\n * This is used as a marker for dangling comments.\n */\n\n\n"
    },
    "3": {
        "bug_file": "src/language-js/print/statement.js",
        "compressed": "NO",
        "line_numbers": 251,
        "compressed_line_numbers": 251,
        "compressed_bug_file_content": "\"use strict\";\n\nconst {\n  builders: { hardline },\n} = require(\"../../document/index.js\");\nconst pathNeedsParens = require(\"../needs-parens.js\");\nconst {\n  getLeftSidePathName,\n  hasNakedLeftSide,\n  isJsxNode,\n  isTheOnlyJsxElementInMarkdown,\n  hasComment,\n  CommentCheckFlags,\n  isNextLineEmpty,\n} = require(\"../utils/index.js\");\nconst { shouldPrintParamsWithoutParens } = require(\"./function.js\");\n\n/**\n * @typedef {import(\"../../document\").Doc} Doc\n * @typedef {import(\"../../common/ast-path\")} AstPath\n */\n\nfunction printStatementSequence(path, options, print, property) {\n  const node = path.getValue();\n  const parts = [];\n  const isClassBody = node.type === \"ClassBody\";\n  const lastStatement = getLastStatement(node[property]);\n\n  path.each((path, index, statements) => {\n    const node = path.getValue();\n\n    // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n    if (node.type === \"EmptyStatement\") {\n      return;\n    }\n\n    const printed = print();\n\n    // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n    if (\n      !options.semi &&\n      !isClassBody &&\n      !isTheOnlyJsxElementInMarkdown(options, path) &&\n      statementNeedsASIProtection(path, options)\n    ) {\n      if (hasComment(node, CommentCheckFlags.Leading)) {\n        parts.push(print([], { needsSemi: true }));\n      } else {\n        parts.push(\";\", printed);\n      }\n    } else {\n      parts.push(printed);\n    }\n\n    if (\n      !options.semi &&\n      isClassBody &&\n      isClassProperty(node) &&\n      // `ClassBody` don't allow `EmptyStatement`,\n      // so we can use `statements` to get next node\n      shouldPrintSemicolonAfterClassProperty(node, statements[index + 1])\n    ) {\n      parts.push(\";\");\n    }\n\n    if (node !== lastStatement) {\n      parts.push(hardline);\n\n      if (isNextLineEmpty(node, options)) {\n        parts.push(hardline);\n      }\n    }\n  }, property);\n\n  return parts;\n}\n\nfunction getLastStatement(statements) {\n  for (let i = statements.length - 1; i >= 0; i--) {\n    const statement = statements[i];\n    if (statement.type !== \"EmptyStatement\") {\n      return statement;\n    }\n  }\n}\n\nfunction statementNeedsASIProtection(path, options) {\n  const node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return path.call(\n    (childPath) => expressionNeedsASIProtection(childPath, options),\n    \"expression\"\n  );\n}\n\nfunction expressionNeedsASIProtection(path, options) {\n  const node = path.getValue();\n  switch (node.type) {\n    case \"ParenthesizedExpression\":\n    case \"TypeCastExpression\":\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n    case \"TemplateLiteral\":\n    case \"TemplateElement\":\n    case \"RegExpLiteral\":\n      return true;\n    case \"ArrowFunctionExpression\": {\n      if (!shouldPrintParamsWithoutParens(path, options)) {\n        return true;\n      }\n      break;\n    }\n    case \"UnaryExpression\": {\n      const { prefix, operator } = node;\n      if (prefix && (operator === \"+\" || operator === \"-\")) {\n        return true;\n      }\n      break;\n    }\n    case \"BindExpression\": {\n      if (!node.object) {\n        return true;\n      }\n      break;\n    }\n    case \"Literal\": {\n      if (node.regex) {\n        return true;\n      }\n      break;\n    }\n    default: {\n      if (isJsxNode(node)) {\n        return true;\n      }\n    }\n  }\n\n  if (pathNeedsParens(path, options)) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return path.call(\n    (childPath) => expressionNeedsASIProtection(childPath, options),\n    ...getLeftSidePathName(path, node)\n  );\n}\n\nfunction printBody(path, options, print) {\n  return printStatementSequence(path, options, print, \"body\");\n}\n\nfunction printSwitchCaseConsequent(path, options, print) {\n  return printStatementSequence(path, options, print, \"consequent\");\n}\n\nconst isClassProperty = ({ type }) =>\n  type === \"ClassProperty\" ||\n  type === \"PropertyDefinition\" ||\n  type === \"ClassPrivateProperty\";\n/**\n * @returns {boolean}\n */\nfunction shouldPrintSemicolonAfterClassProperty(node, nextNode) {\n  const name = node.key && node.key.name;\n  // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n  if (\n    (name === \"static\" || name === \"get\" || name === \"set\") &&\n    !node.value &&\n    !node.typeAnnotation\n  ) {\n    return true;\n  }\n\n  if (!nextNode) {\n    return false;\n  }\n\n  if (\n    nextNode.static ||\n    nextNode.accessibility // TypeScript\n  ) {\n    return false;\n  }\n\n  if (!nextNode.computed) {\n    const name = nextNode.key && nextNode.key.name;\n    if (name === \"in\" || name === \"instanceof\") {\n      return true;\n    }\n  }\n\n  // Flow variance sigil +/- requires semi if there's no\n  // \"declare\" or \"static\" keyword before it.\n  if (\n    isClassProperty(nextNode) &&\n    nextNode.variance &&\n    !nextNode.static &&\n    !nextNode.declare\n  ) {\n    return true;\n  }\n\n  switch (nextNode.type) {\n    case \"ClassProperty\":\n    case \"PropertyDefinition\":\n    case \"TSAbstractPropertyDefinition\":\n      return nextNode.computed;\n    case \"MethodDefinition\": // Flow\n    case \"TSAbstractMethodDefinition\": // TypeScript\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\": {\n      // Babel\n      const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;\n      if (isAsync || nextNode.kind === \"get\" || nextNode.kind === \"set\") {\n        return false;\n      }\n\n      const isGenerator = nextNode.value\n        ? nextNode.value.generator\n        : nextNode.generator;\n      if (nextNode.computed || isGenerator) {\n        return true;\n      }\n\n      return false;\n    }\n\n    case \"TSIndexSignature\":\n      return true;\n  }\n\n  /* istanbul ignore next */\n  return false;\n}\n\nmodule.exports = {\n  printBody,\n  printSwitchCaseConsequent,\n};"
    }
}