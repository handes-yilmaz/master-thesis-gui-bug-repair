{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) ",
            "file_path": "src/language-js/parser-babel.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 286
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const createError = require(\"../common/parser-create-error\");",
                "const {",
                "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                "  getShebang,",
                "} = require(\"../common/util\");",
                "const { hasPragma } = require(\"./pragma\");",
                "const { locStart, locEnd } = require(\"./loc\");",
                "const postprocess = require(\"./postprocess\");",
                "",
                "function babelOptions({ sourceType, extraPlugins = [] }) {",
                "  return {",
                "    sourceType,",
                "    allowAwaitOutsideFunction: true,",
                "    allowImportExportEverywhere: true,",
                "    allowReturnOutsideFunction: true,",
                "    allowSuperOutsideMethod: true,",
                "    allowUndeclaredExports: true,",
                "    errorRecovery: true,",
                "    createParenthesizedExpressions: true,",
                "    plugins: [",
                "      // When adding a plugin, please add a test in `tests/js/babel-plugins`,",
                "      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify",
                "",
                "      \"doExpressions\",",
                "      \"classProperties\",",
                "      \"exportDefaultFrom\",",
                "      \"functionBind\",",
                "      \"functionSent\",",
                "      \"classPrivateProperties\",",
                "      \"throwExpressions\",",
                "      \"classPrivateMethods\",",
                "      \"v8intrinsic\",",
                "      \"partialApplication\",",
                "      [\"decorators\", { decoratorsBeforeExport: false }],",
                "      \"privateIn\",",
                "      \"importAssertions\",",
                "      [\"recordAndTuple\", { syntaxType: \"hash\" }],",
                "      \"decimal\",",
                "      \"moduleStringNames\",",
                "      \"classStaticBlock\",",
                "      ...extraPlugins,",
                "    ],",
                "    tokens: true,",
                "    ranges: true,",
                "  };",
                "}",
                "",
                "function resolvePluginsConflict(",
                "  condition,",
                "  pluginCombinations,",
                "  conflictPlugins",
                ") {",
                "  if (!condition) {",
                "    return pluginCombinations;",
                "  }",
                "  const combinations = [];",
                "  for (const combination of pluginCombinations) {",
                "    for (const plugin of conflictPlugins) {",
                "      combinations.push([...combination, plugin]);",
                "    }",
                "  }",
                "  return combinations;",
                "}",
                "",
                "// Similar to babel",
                "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                "function isFlowFile(text, options) {",
                "  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {",
                "    return true;",
                "  }",
                "",
                "  const shebang = getShebang(text);",
                "  if (shebang) {",
                "    text = text.slice(shebang.length);",
                "  }",
                "",
                "  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                "    text,",
                "    0",
                "  );",
                "",
                "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                "  }",
                "",
                "  return FLOW_PRAGMA_REGEX.test(text);",
                "}",
                "",
                "function createParse(parseMethod, ...pluginCombinations) {",
                "  return (text, parsers, opts = {}) => {",
                "    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {",
                "      opts.parser = \"babel-flow\";",
                "      return parseFlow(text, parsers, opts);",
                "    }",
                "",
                "    // Inline the require to avoid loading all the JS if we don't use it",
                "    const babel = require(\"@babel/parser\");",
                "",
                "    const sourceType =",
                "      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";",
                "",
                "    let ast;",
                "    try {",
                "      const combinations = resolvePluginsConflict(",
                "        text.includes(\"|>\"),",
                "        pluginCombinations,",
                "        [",
                "          [\"pipelineOperator\", { proposal: \"smart\" }],",
                "          [\"pipelineOperator\", { proposal: \"minimal\" }],",
                "          [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                "        ]",
                "      );",
                "      ast = tryCombinations(",
                "        (options) => babel[parseMethod](text, options),",
                "        combinations.map((extraPlugins) =>",
                "          babelOptions({ sourceType, extraPlugins })",
                "        )",
                "      );",
                "    } catch (error) {",
                "      // babel error prints (l:c) with cols that are zero indexed",
                "      // so we need our custom error",
                "      const { message, loc } = error;",
                "",
                "      throw createError(message.replace(/ \\(.*\\)/, \"\"), {",
                "        start: {",
                "          line: loc ? loc.line : 0,",
                "          column: loc ? loc.column + 1 : 0,",
                "        },",
                "      });",
                "    }",
                "",
                "    return postprocess(ast, { ...opts, originalText: text });",
                "  };",
                "}",
                "",
                "const parse = createParse(\"parse\", [\"jsx\", \"flow\"]);",
                "const parseFlow = createParse(\"parse\", [",
                "  \"jsx\",",
                "  [\"flow\", { all: true, enums: true }],",
                "]);",
                "const parseTypeScript = createParse(",
                "  \"parse\",",
                "  [\"jsx\", \"typescript\"],",
                "  [\"typescript\"]",
                ");",
                "const parseExpression = createParse(\"parseExpression\", [\"jsx\"]);",
                "",
                "function tryCombinations(fn, combinations) {",
                "  let error;",
                "  for (let i = 0; i < combinations.length; i++) {",
                "    try {",
                "      return rethrowSomeRecoveredErrors(fn(combinations[i]));",
                "    } catch (_error) {",
                "      if (!error) {",
                "        error = _error;",
                "      }",
                "    }",
                "  }",
                "  throw error;",
                "}",
                "",
                "const messagesShouldThrow = new Set([",
                "  // TSErrors.UnexpectedTypeAnnotation",
                "  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95",
                "  \"Did not expect a type annotation here.\",",
                "  // ErrorMessages.ModuleAttributeDifferentFromType",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92",
                "  \"The only accepted module attribute is `type`\",",
                "  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118",
                "  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",",
                "]);",
                "",
                "function shouldRethrow(error) {",
                "  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);",
                "  // Only works for literal message",
                "  return messagesShouldThrow.has(message);",
                "}",
                "",
                "function rethrowSomeRecoveredErrors(ast) {",
                "  const error = ast.errors.find((error) => shouldRethrow(error));",
                "  if (error) {",
                "    throw error;",
                "  }",
                "",
                "  return ast;",
                "}",
                "",
                "function parseJson(text, parsers, opts) {",
                "  const ast = parseExpression(text, parsers, opts);",
                "",
                "  ast.comments.forEach(assertJsonNode);",
                "  assertJsonNode(ast);",
                "",
                "  return ast;",
                "}",
                "",
                "function assertJsonNode(node, parent) {",
                "  switch (node.type) {",
                "    case \"ArrayExpression\":",
                "      return node.elements.forEach(assertJsonChildNode);",
                "    case \"ObjectExpression\":",
                "      return node.properties.forEach(assertJsonChildNode);",
                "    case \"ObjectProperty\":",
                "      if (node.computed) {",
                "        throw createJsonError(\"computed\");",
                "      }",
                "",
                "      if (node.shorthand) {",
                "        throw createJsonError(\"shorthand\");",
                "      }",
                "      return [node.key, node.value].forEach(assertJsonChildNode);",
                "    case \"UnaryExpression\":",
                "      switch (node.operator) {",
                "        case \"+\":",
                "        case \"-\":",
                "          return assertJsonChildNode(node.argument);",
                "        default:",
                "          throw createJsonError(\"operator\");",
                "      }",
                "    case \"Identifier\":",
                "      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {",
                "        return;",
                "      }",
                "      throw createJsonError();",
                "    case \"NullLiteral\":",
                "    case \"BooleanLiteral\":",
                "    case \"NumericLiteral\":",
                "    case \"StringLiteral\":",
                "      return;",
                "    default:",
                "      throw createJsonError();",
                "  }",
                "",
                "  function assertJsonChildNode(child) {",
                "    return assertJsonNode(child, node);",
                "  }",
                "",
                "  function createJsonError(attribute) {",
                "    const name = !attribute",
                "      ? node.type",
                "      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;",
                "    return createError(`${name} is not allowed in JSON.`, {",
                "      start: {",
                "        line: node.loc.start.line,",
                "        column: node.loc.start.column + 1,",
                "      },",
                "    });",
                "  }",
                "}",
                "",
                "const babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };",
                "const babelFlow = { ...babel, parse: parseFlow };",
                "const babelTypeScript = { ...babel, parse: parseTypeScript };",
                "const babelExpression = { ...babel, parse: parseExpression };",
                "",
                "// Export as a plugin so we can reuse the same bundle for UMD loading",
                "module.exports = {",
                "  parsers: {",
                "    babel,",
                "    \"babel-flow\": babelFlow,",
                "    \"babel-ts\": babelTypeScript,",
                "    json: {",
                "      ...babelExpression,",
                "      hasPragma() {",
                "        return true;",
                "      },",
                "    },",
                "    json5: babelExpression,",
                "    \"json-stringify\": {",
                "      parse: parseJson,",
                "      astFormat: \"estree-json\",",
                "      locStart,",
                "      locEnd,",
                "    },",
                "    /** @internal */",
                "    __js_expression: babelExpression,",
                "    /** for vue filter */",
                "    __vue_expression: babelExpression,",
                "    /** for vue event binding to handle semicolon */",
                "    __vue_event_binding: babel,",
                "  },",
                "};"
            ]
        },
        "2": {
            "class_name": "  (not found) ",
            "file_path": "src/language-js/parser-flow.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 44
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const createError = require(\"../common/parser-create-error\");",
                "const { hasPragma } = require(\"./pragma\");",
                "const { locStart, locEnd } = require(\"./loc\");",
                "const postprocess = require(\"./postprocess\");",
                "",
                "function parse(text, parsers, opts) {",
                "  // Inline the require to avoid loading all the JS if we don't use it",
                "  const flowParser = require(\"flow-parser\");",
                "",
                "  const ast = flowParser.parse(text, {",
                "    enums: true,",
                "    esproposal_decorators: true,",
                "    esproposal_class_instance_fields: true,",
                "    esproposal_class_static_fields: true,",
                "    esproposal_export_star_as: true,",
                "    esproposal_optional_chaining: true,",
                "    esproposal_nullish_coalescing: true,",
                "    tokens: true,",
                "  });",
                "",
                "  const [error] = ast.errors;",
                "  if (error) {",
                "    const {",
                "      message,",
                "      loc: { start, end },",
                "    } = error;",
                "",
                "    throw createError(message, {",
                "      start: { line: start.line, column: start.column + 1 },",
                "      end: { line: end.line, column: end.column + 1 },",
                "    });",
                "  }",
                "",
                "  return postprocess(ast, { ...opts, originalText: text });",
                "}",
                "",
                "// Export as a plugin so we can reuse the same bundle for UMD loading",
                "module.exports = {",
                "  parsers: {",
                "    flow: { parse, astFormat: \"estree\", hasPragma, locStart, locEnd },",
                "  },",
                "};"
            ]
        },
        "3": {
            "class_name": "  (not found) ",
            "file_path": "src/language-js/index.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 161
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const createLanguage = require(\"../utils/create-language\");",
                "const estreePrinter = require(\"./printer-estree\");",
                "const estreeJsonPrinter = require(\"./printer-estree-json\");",
                "const options = require(\"./options\");",
                "",
                "const languages = [",
                "  createLanguage(",
                "    require(\"linguist-languages/data/JavaScript.json\"),",
                "    (data) => ({",
                "      since: \"0.0.0\",",
                "      parsers: [",
                "        \"babel\",",
                "        \"espree\",",
                "        \"babel-flow\",",
                "        \"babel-ts\",",
                "        \"flow\",",
                "        \"typescript\",",
                "      ],",
                "      vscodeLanguageIds: [\"javascript\", \"mongo\"],",
                "      extensions: [",
                "        ...data.extensions,",
                "        // WeiXin Script (Weixin Mini Programs)",
                "        // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                "        \".wxs\",",
                "      ],",
                "    })",
                "  ),",
                "  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({",
                "    name: \"Flow\",",
                "    since: \"0.0.0\",",
                "    parsers: [\"flow\", \"babel-flow\"],",
                "    vscodeLanguageIds: [\"javascript\"],",
                "    aliases: [],",
                "    filenames: [],",
                "    extensions: [\".js.flow\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/JSX.json\"), () => ({",
                "    since: \"0.0.0\",",
                "    parsers: [",
                "      \"babel\",",
                "      \"babel-flow\",",
                "      \"babel-ts\",",
                "      \"flow\",",
                "      \"typescript\",",
                "      \"espree\",",
                "    ],",
                "    vscodeLanguageIds: [\"javascriptreact\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/TypeScript.json\"), () => ({",
                "    since: \"1.4.0\",",
                "    parsers: [\"typescript\", \"babel-ts\"],",
                "    vscodeLanguageIds: [\"typescript\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/TSX.json\"), () => ({",
                "    since: \"1.4.0\",",
                "    parsers: [\"typescript\", \"babel-ts\"],",
                "    vscodeLanguageIds: [\"typescriptreact\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/JSON.json\"), () => ({",
                "    name: \"JSON.stringify\",",
                "    since: \"1.13.0\",",
                "    parsers: [\"json-stringify\"],",
                "    vscodeLanguageIds: [\"json\"],",
                "    extensions: [], // .json file defaults to json instead of json-stringify",
                "    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/JSON.json\"), (data) => ({",
                "    since: \"1.5.0\",",
                "    parsers: [\"json\"],",
                "    vscodeLanguageIds: [\"json\"],",
                "    filenames: [...data.filenames, \".prettierrc\"],",
                "    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),",
                "  })),",
                "  createLanguage(",
                "    require(\"linguist-languages/data/JSON with Comments.json\"),",
                "    (data) => ({",
                "      since: \"1.5.0\",",
                "      parsers: [\"json\"],",
                "      vscodeLanguageIds: [\"jsonc\"],",
                "      filenames: [...data.filenames, \".eslintrc\"],",
                "    })",
                "  ),",
                "  createLanguage(require(\"linguist-languages/data/JSON5.json\"), () => ({",
                "    since: \"1.13.0\",",
                "    parsers: [\"json5\"],",
                "    vscodeLanguageIds: [\"json5\"],",
                "  })),",
                "];",
                "",
                "const printers = {",
                "  estree: estreePrinter,",
                "  \"estree-json\": estreeJsonPrinter,",
                "};",
                "",
                "const parsers = {",
                "  // JS - Babel",
                "  get babel() {",
                "    return require(\"./parser-babel\").parsers.babel;",
                "  },",
                "  get \"babel-flow\"() {",
                "    return require(\"./parser-babel\").parsers[\"babel-flow\"];",
                "  },",
                "  get \"babel-ts\"() {",
                "    return require(\"./parser-babel\").parsers[\"babel-ts\"];",
                "  },",
                "  get json() {",
                "    return require(\"./parser-babel\").parsers.json;",
                "  },",
                "  get json5() {",
                "    return require(\"./parser-babel\").parsers.json5;",
                "  },",
                "  get \"json-stringify\"() {",
                "    return require(\"./parser-babel\").parsers[\"json-stringify\"];",
                "  },",
                "  get __js_expression() {",
                "    return require(\"./parser-babel\").parsers.__js_expression;",
                "  },",
                "  get __vue_expression() {",
                "    return require(\"./parser-babel\").parsers.__vue_expression;",
                "  },",
                "  get __vue_event_binding() {",
                "    return require(\"./parser-babel\").parsers.__vue_event_binding;",
                "  },",
                "  // JS - Flow",
                "  get flow() {",
                "    return require(\"./parser-flow\").parsers.flow;",
                "  },",
                "  // JS - TypeScript",
                "  get typescript() {",
                "    return require(\"./parser-typescript\").parsers.typescript;",
                "  },",
                "  // JS - Angular Action",
                "  get __ng_action() {",
                "    return require(\"./parser-angular\").parsers.__ng_action;",
                "  },",
                "  // JS - Angular Binding",
                "  get __ng_binding() {",
                "    return require(\"./parser-angular\").parsers.__ng_binding;",
                "  },",
                "  // JS - Angular Interpolation",
                "  get __ng_interpolation() {",
                "    return require(\"./parser-angular\").parsers.__ng_interpolation;",
                "  },",
                "  // JS - Angular Directive",
                "  get __ng_directive() {",
                "    return require(\"./parser-angular\").parsers.__ng_directive;",
                "  },",
                "  // JS - espree",
                "  get espree() {",
                "    return require(\"./parser-espree\").parsers.espree;",
                "  },",
                "};",
                "",
                "module.exports = {",
                "  languages,",
                "  options,",
                "  printers,",
                "  parsers,",
                "};"
            ]
        }
    },
    "bug_functions": {
        "4": {
            "function_name": "babelOptions (not found) ",
            "file_path": "src/language-js/parser-babel.js",
            "function_details": [
                {
                    "name": "babelOptions",
                    "start_line": 1,
                    "end_line": 286
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const createError = require(\"../common/parser-create-error\");",
                "const {",
                "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                "  getShebang,",
                "} = require(\"../common/util\");",
                "const { hasPragma } = require(\"./pragma\");",
                "const { locStart, locEnd } = require(\"./loc\");",
                "const postprocess = require(\"./postprocess\");",
                "",
                "function babelOptions({ sourceType, extraPlugins = [] }) {",
                "  return {",
                "    sourceType,",
                "    allowAwaitOutsideFunction: true,",
                "    allowImportExportEverywhere: true,",
                "    allowReturnOutsideFunction: true,",
                "    allowSuperOutsideMethod: true,",
                "    allowUndeclaredExports: true,",
                "    errorRecovery: true,",
                "    createParenthesizedExpressions: true,",
                "    plugins: [",
                "      // When adding a plugin, please add a test in `tests/js/babel-plugins`,",
                "      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify",
                "",
                "      \"doExpressions\",",
                "      \"classProperties\",",
                "      \"exportDefaultFrom\",",
                "      \"functionBind\",",
                "      \"functionSent\",",
                "      \"classPrivateProperties\",",
                "      \"throwExpressions\",",
                "      \"classPrivateMethods\",",
                "      \"v8intrinsic\",",
                "      \"partialApplication\",",
                "      [\"decorators\", { decoratorsBeforeExport: false }],",
                "      \"privateIn\",",
                "      \"importAssertions\",",
                "      [\"recordAndTuple\", { syntaxType: \"hash\" }],",
                "      \"decimal\",",
                "      \"moduleStringNames\",",
                "      \"classStaticBlock\",",
                "      ...extraPlugins,",
                "    ],",
                "    tokens: true,",
                "    ranges: true,",
                "  };",
                "}",
                "",
                "function resolvePluginsConflict(",
                "  condition,",
                "  pluginCombinations,",
                "  conflictPlugins",
                ") {",
                "  if (!condition) {",
                "    return pluginCombinations;",
                "  }",
                "  const combinations = [];",
                "  for (const combination of pluginCombinations) {",
                "    for (const plugin of conflictPlugins) {",
                "      combinations.push([...combination, plugin]);",
                "    }",
                "  }",
                "  return combinations;",
                "}",
                "",
                "// Similar to babel",
                "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                "function isFlowFile(text, options) {",
                "  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {",
                "    return true;",
                "  }",
                "",
                "  const shebang = getShebang(text);",
                "  if (shebang) {",
                "    text = text.slice(shebang.length);",
                "  }",
                "",
                "  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                "    text,",
                "    0",
                "  );",
                "",
                "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                "  }",
                "",
                "  return FLOW_PRAGMA_REGEX.test(text);",
                "}",
                "",
                "function createParse(parseMethod, ...pluginCombinations) {",
                "  return (text, parsers, opts = {}) => {",
                "    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {",
                "      opts.parser = \"babel-flow\";",
                "      return parseFlow(text, parsers, opts);",
                "    }",
                "",
                "    // Inline the require to avoid loading all the JS if we don't use it",
                "    const babel = require(\"@babel/parser\");",
                "",
                "    const sourceType =",
                "      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";",
                "",
                "    let ast;",
                "    try {",
                "      const combinations = resolvePluginsConflict(",
                "        text.includes(\"|>\"),",
                "        pluginCombinations,",
                "        [",
                "          [\"pipelineOperator\", { proposal: \"smart\" }],",
                "          [\"pipelineOperator\", { proposal: \"minimal\" }],",
                "          [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                "        ]",
                "      );",
                "      ast = tryCombinations(",
                "        (options) => babel[parseMethod](text, options),",
                "        combinations.map((extraPlugins) =>",
                "          babelOptions({ sourceType, extraPlugins })",
                "        )",
                "      );",
                "    } catch (error) {",
                "      // babel error prints (l:c) with cols that are zero indexed",
                "      // so we need our custom error",
                "      const { message, loc } = error;",
                "",
                "      throw createError(message.replace(/ \\(.*\\)/, \"\"), {",
                "        start: {",
                "          line: loc ? loc.line : 0,",
                "          column: loc ? loc.column + 1 : 0,",
                "        },",
                "      });",
                "    }",
                "",
                "    return postprocess(ast, { ...opts, originalText: text });",
                "  };",
                "}",
                "",
                "const parse = createParse(\"parse\", [\"jsx\", \"flow\"]);",
                "const parseFlow = createParse(\"parse\", [",
                "  \"jsx\",",
                "  [\"flow\", { all: true, enums: true }],",
                "]);",
                "const parseTypeScript = createParse(",
                "  \"parse\",",
                "  [\"jsx\", \"typescript\"],",
                "  [\"typescript\"]",
                ");",
                "const parseExpression = createParse(\"parseExpression\", [\"jsx\"]);",
                "",
                "function tryCombinations(fn, combinations) {",
                "  let error;",
                "  for (let i = 0; i < combinations.length; i++) {",
                "    try {",
                "      return rethrowSomeRecoveredErrors(fn(combinations[i]));",
                "    } catch (_error) {",
                "      if (!error) {",
                "        error = _error;",
                "      }",
                "    }",
                "  }",
                "  throw error;",
                "}",
                "",
                "const messagesShouldThrow = new Set([",
                "  // TSErrors.UnexpectedTypeAnnotation",
                "  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95",
                "  \"Did not expect a type annotation here.\",",
                "  // ErrorMessages.ModuleAttributeDifferentFromType",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92",
                "  \"The only accepted module attribute is `type`\",",
                "  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118",
                "  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",",
                "]);",
                "",
                "function shouldRethrow(error) {",
                "  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);",
                "  // Only works for literal message",
                "  return messagesShouldThrow.has(message);",
                "}",
                "",
                "function rethrowSomeRecoveredErrors(ast) {",
                "  const error = ast.errors.find((error) => shouldRethrow(error));",
                "  if (error) {",
                "    throw error;",
                "  }",
                "",
                "  return ast;",
                "}",
                "",
                "function parseJson(text, parsers, opts) {",
                "  const ast = parseExpression(text, parsers, opts);",
                "",
                "  ast.comments.forEach(assertJsonNode);",
                "  assertJsonNode(ast);",
                "",
                "  return ast;",
                "}",
                "",
                "function assertJsonNode(node, parent) {",
                "  switch (node.type) {",
                "    case \"ArrayExpression\":",
                "      return node.elements.forEach(assertJsonChildNode);",
                "    case \"ObjectExpression\":",
                "      return node.properties.forEach(assertJsonChildNode);",
                "    case \"ObjectProperty\":",
                "      if (node.computed) {",
                "        throw createJsonError(\"computed\");",
                "      }",
                "",
                "      if (node.shorthand) {",
                "        throw createJsonError(\"shorthand\");",
                "      }",
                "      return [node.key, node.value].forEach(assertJsonChildNode);",
                "    case \"UnaryExpression\":",
                "      switch (node.operator) {",
                "        case \"+\":",
                "        case \"-\":",
                "          return assertJsonChildNode(node.argument);",
                "        default:",
                "          throw createJsonError(\"operator\");",
                "      }",
                "    case \"Identifier\":",
                "      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {",
                "        return;",
                "      }",
                "      throw createJsonError();",
                "    case \"NullLiteral\":",
                "    case \"BooleanLiteral\":",
                "    case \"NumericLiteral\":",
                "    case \"StringLiteral\":",
                "      return;",
                "    default:",
                "      throw createJsonError();",
                "  }",
                "",
                "  function assertJsonChildNode(child) {",
                "    return assertJsonNode(child, node);",
                "  }",
                "",
                "  function createJsonError(attribute) {",
                "    const name = !attribute",
                "      ? node.type",
                "      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;",
                "    return createError(`${name} is not allowed in JSON.`, {",
                "      start: {",
                "        line: node.loc.start.line,",
                "        column: node.loc.start.column + 1,",
                "      },",
                "    });",
                "  }",
                "}",
                "",
                "const babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };",
                "const babelFlow = { ...babel, parse: parseFlow };",
                "const babelTypeScript = { ...babel, parse: parseTypeScript };",
                "const babelExpression = { ...babel, parse: parseExpression };",
                "",
                "// Export as a plugin so we can reuse the same bundle for UMD loading",
                "module.exports = {",
                "  parsers: {",
                "    babel,",
                "    \"babel-flow\": babelFlow,",
                "    \"babel-ts\": babelTypeScript,",
                "    json: {",
                "      ...babelExpression,",
                "      hasPragma() {",
                "        return true;",
                "      },",
                "    },",
                "    json5: babelExpression,",
                "    \"json-stringify\": {",
                "      parse: parseJson,",
                "      astFormat: \"estree-json\",",
                "      locStart,",
                "      locEnd,",
                "    },",
                "    /** @internal */",
                "    __js_expression: babelExpression,",
                "    /** for vue filter */",
                "    __vue_expression: babelExpression,",
                "    /** for vue event binding to handle semicolon */",
                "    __vue_event_binding: babel,",
                "  },",
                "};"
            ]
        },
        "5": {
            "function_name": "createParse (not found) ",
            "file_path": "src/language-js/parser-babel.js",
            "function_details": [
                {
                    "name": "createParse",
                    "start_line": 1,
                    "end_line": 286
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const createError = require(\"../common/parser-create-error\");",
                "const {",
                "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                "  getShebang,",
                "} = require(\"../common/util\");",
                "const { hasPragma } = require(\"./pragma\");",
                "const { locStart, locEnd } = require(\"./loc\");",
                "const postprocess = require(\"./postprocess\");",
                "",
                "function babelOptions({ sourceType, extraPlugins = [] }) {",
                "  return {",
                "    sourceType,",
                "    allowAwaitOutsideFunction: true,",
                "    allowImportExportEverywhere: true,",
                "    allowReturnOutsideFunction: true,",
                "    allowSuperOutsideMethod: true,",
                "    allowUndeclaredExports: true,",
                "    errorRecovery: true,",
                "    createParenthesizedExpressions: true,",
                "    plugins: [",
                "      // When adding a plugin, please add a test in `tests/js/babel-plugins`,",
                "      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify",
                "",
                "      \"doExpressions\",",
                "      \"classProperties\",",
                "      \"exportDefaultFrom\",",
                "      \"functionBind\",",
                "      \"functionSent\",",
                "      \"classPrivateProperties\",",
                "      \"throwExpressions\",",
                "      \"classPrivateMethods\",",
                "      \"v8intrinsic\",",
                "      \"partialApplication\",",
                "      [\"decorators\", { decoratorsBeforeExport: false }],",
                "      \"privateIn\",",
                "      \"importAssertions\",",
                "      [\"recordAndTuple\", { syntaxType: \"hash\" }],",
                "      \"decimal\",",
                "      \"moduleStringNames\",",
                "      \"classStaticBlock\",",
                "      ...extraPlugins,",
                "    ],",
                "    tokens: true,",
                "    ranges: true,",
                "  };",
                "}",
                "",
                "function resolvePluginsConflict(",
                "  condition,",
                "  pluginCombinations,",
                "  conflictPlugins",
                ") {",
                "  if (!condition) {",
                "    return pluginCombinations;",
                "  }",
                "  const combinations = [];",
                "  for (const combination of pluginCombinations) {",
                "    for (const plugin of conflictPlugins) {",
                "      combinations.push([...combination, plugin]);",
                "    }",
                "  }",
                "  return combinations;",
                "}",
                "",
                "// Similar to babel",
                "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                "function isFlowFile(text, options) {",
                "  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {",
                "    return true;",
                "  }",
                "",
                "  const shebang = getShebang(text);",
                "  if (shebang) {",
                "    text = text.slice(shebang.length);",
                "  }",
                "",
                "  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                "    text,",
                "    0",
                "  );",
                "",
                "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                "  }",
                "",
                "  return FLOW_PRAGMA_REGEX.test(text);",
                "}",
                "",
                "function createParse(parseMethod, ...pluginCombinations) {",
                "  return (text, parsers, opts = {}) => {",
                "    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {",
                "      opts.parser = \"babel-flow\";",
                "      return parseFlow(text, parsers, opts);",
                "    }",
                "",
                "    // Inline the require to avoid loading all the JS if we don't use it",
                "    const babel = require(\"@babel/parser\");",
                "",
                "    const sourceType =",
                "      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";",
                "",
                "    let ast;",
                "    try {",
                "      const combinations = resolvePluginsConflict(",
                "        text.includes(\"|>\"),",
                "        pluginCombinations,",
                "        [",
                "          [\"pipelineOperator\", { proposal: \"smart\" }],",
                "          [\"pipelineOperator\", { proposal: \"minimal\" }],",
                "          [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                "        ]",
                "      );",
                "      ast = tryCombinations(",
                "        (options) => babel[parseMethod](text, options),",
                "        combinations.map((extraPlugins) =>",
                "          babelOptions({ sourceType, extraPlugins })",
                "        )",
                "      );",
                "    } catch (error) {",
                "      // babel error prints (l:c) with cols that are zero indexed",
                "      // so we need our custom error",
                "      const { message, loc } = error;",
                "",
                "      throw createError(message.replace(/ \\(.*\\)/, \"\"), {",
                "        start: {",
                "          line: loc ? loc.line : 0,",
                "          column: loc ? loc.column + 1 : 0,",
                "        },",
                "      });",
                "    }",
                "",
                "    return postprocess(ast, { ...opts, originalText: text });",
                "  };",
                "}",
                "",
                "const parse = createParse(\"parse\", [\"jsx\", \"flow\"]);",
                "const parseFlow = createParse(\"parse\", [",
                "  \"jsx\",",
                "  [\"flow\", { all: true, enums: true }],",
                "]);",
                "const parseTypeScript = createParse(",
                "  \"parse\",",
                "  [\"jsx\", \"typescript\"],",
                "  [\"typescript\"]",
                ");",
                "const parseExpression = createParse(\"parseExpression\", [\"jsx\"]);",
                "",
                "function tryCombinations(fn, combinations) {",
                "  let error;",
                "  for (let i = 0; i < combinations.length; i++) {",
                "    try {",
                "      return rethrowSomeRecoveredErrors(fn(combinations[i]));",
                "    } catch (_error) {",
                "      if (!error) {",
                "        error = _error;",
                "      }",
                "    }",
                "  }",
                "  throw error;",
                "}",
                "",
                "const messagesShouldThrow = new Set([",
                "  // TSErrors.UnexpectedTypeAnnotation",
                "  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95",
                "  \"Did not expect a type annotation here.\",",
                "  // ErrorMessages.ModuleAttributeDifferentFromType",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92",
                "  \"The only accepted module attribute is `type`\",",
                "  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118",
                "  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",",
                "]);",
                "",
                "function shouldRethrow(error) {",
                "  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);",
                "  // Only works for literal message",
                "  return messagesShouldThrow.has(message);",
                "}",
                "",
                "function rethrowSomeRecoveredErrors(ast) {",
                "  const error = ast.errors.find((error) => shouldRethrow(error));",
                "  if (error) {",
                "    throw error;",
                "  }",
                "",
                "  return ast;",
                "}",
                "",
                "function parseJson(text, parsers, opts) {",
                "  const ast = parseExpression(text, parsers, opts);",
                "",
                "  ast.comments.forEach(assertJsonNode);",
                "  assertJsonNode(ast);",
                "",
                "  return ast;",
                "}",
                "",
                "function assertJsonNode(node, parent) {",
                "  switch (node.type) {",
                "    case \"ArrayExpression\":",
                "      return node.elements.forEach(assertJsonChildNode);",
                "    case \"ObjectExpression\":",
                "      return node.properties.forEach(assertJsonChildNode);",
                "    case \"ObjectProperty\":",
                "      if (node.computed) {",
                "        throw createJsonError(\"computed\");",
                "      }",
                "",
                "      if (node.shorthand) {",
                "        throw createJsonError(\"shorthand\");",
                "      }",
                "      return [node.key, node.value].forEach(assertJsonChildNode);",
                "    case \"UnaryExpression\":",
                "      switch (node.operator) {",
                "        case \"+\":",
                "        case \"-\":",
                "          return assertJsonChildNode(node.argument);",
                "        default:",
                "          throw createJsonError(\"operator\");",
                "      }",
                "    case \"Identifier\":",
                "      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {",
                "        return;",
                "      }",
                "      throw createJsonError();",
                "    case \"NullLiteral\":",
                "    case \"BooleanLiteral\":",
                "    case \"NumericLiteral\":",
                "    case \"StringLiteral\":",
                "      return;",
                "    default:",
                "      throw createJsonError();",
                "  }",
                "",
                "  function assertJsonChildNode(child) {",
                "    return assertJsonNode(child, node);",
                "  }",
                "",
                "  function createJsonError(attribute) {",
                "    const name = !attribute",
                "      ? node.type",
                "      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;",
                "    return createError(`${name} is not allowed in JSON.`, {",
                "      start: {",
                "        line: node.loc.start.line,",
                "        column: node.loc.start.column + 1,",
                "      },",
                "    });",
                "  }",
                "}",
                "",
                "const babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };",
                "const babelFlow = { ...babel, parse: parseFlow };",
                "const babelTypeScript = { ...babel, parse: parseTypeScript };",
                "const babelExpression = { ...babel, parse: parseExpression };",
                "",
                "// Export as a plugin so we can reuse the same bundle for UMD loading",
                "module.exports = {",
                "  parsers: {",
                "    babel,",
                "    \"babel-flow\": babelFlow,",
                "    \"babel-ts\": babelTypeScript,",
                "    json: {",
                "      ...babelExpression,",
                "      hasPragma() {",
                "        return true;",
                "      },",
                "    },",
                "    json5: babelExpression,",
                "    \"json-stringify\": {",
                "      parse: parseJson,",
                "      astFormat: \"estree-json\",",
                "      locStart,",
                "      locEnd,",
                "    },",
                "    /** @internal */",
                "    __js_expression: babelExpression,",
                "    /** for vue filter */",
                "    __vue_expression: babelExpression,",
                "    /** for vue event binding to handle semicolon */",
                "    __vue_event_binding: babel,",
                "  },",
                "};"
            ]
        },
        "6": {
            "function_name": "isFlowFile (not found) ",
            "file_path": "src/language-js/parser-babel.js",
            "function_details": [
                {
                    "name": "isFlowFile",
                    "start_line": 1,
                    "end_line": 286
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const createError = require(\"../common/parser-create-error\");",
                "const {",
                "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                "  getShebang,",
                "} = require(\"../common/util\");",
                "const { hasPragma } = require(\"./pragma\");",
                "const { locStart, locEnd } = require(\"./loc\");",
                "const postprocess = require(\"./postprocess\");",
                "",
                "function babelOptions({ sourceType, extraPlugins = [] }) {",
                "  return {",
                "    sourceType,",
                "    allowAwaitOutsideFunction: true,",
                "    allowImportExportEverywhere: true,",
                "    allowReturnOutsideFunction: true,",
                "    allowSuperOutsideMethod: true,",
                "    allowUndeclaredExports: true,",
                "    errorRecovery: true,",
                "    createParenthesizedExpressions: true,",
                "    plugins: [",
                "      // When adding a plugin, please add a test in `tests/js/babel-plugins`,",
                "      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify",
                "",
                "      \"doExpressions\",",
                "      \"classProperties\",",
                "      \"exportDefaultFrom\",",
                "      \"functionBind\",",
                "      \"functionSent\",",
                "      \"classPrivateProperties\",",
                "      \"throwExpressions\",",
                "      \"classPrivateMethods\",",
                "      \"v8intrinsic\",",
                "      \"partialApplication\",",
                "      [\"decorators\", { decoratorsBeforeExport: false }],",
                "      \"privateIn\",",
                "      \"importAssertions\",",
                "      [\"recordAndTuple\", { syntaxType: \"hash\" }],",
                "      \"decimal\",",
                "      \"moduleStringNames\",",
                "      \"classStaticBlock\",",
                "      ...extraPlugins,",
                "    ],",
                "    tokens: true,",
                "    ranges: true,",
                "  };",
                "}",
                "",
                "function resolvePluginsConflict(",
                "  condition,",
                "  pluginCombinations,",
                "  conflictPlugins",
                ") {",
                "  if (!condition) {",
                "    return pluginCombinations;",
                "  }",
                "  const combinations = [];",
                "  for (const combination of pluginCombinations) {",
                "    for (const plugin of conflictPlugins) {",
                "      combinations.push([...combination, plugin]);",
                "    }",
                "  }",
                "  return combinations;",
                "}",
                "",
                "// Similar to babel",
                "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                "function isFlowFile(text, options) {",
                "  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {",
                "    return true;",
                "  }",
                "",
                "  const shebang = getShebang(text);",
                "  if (shebang) {",
                "    text = text.slice(shebang.length);",
                "  }",
                "",
                "  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                "    text,",
                "    0",
                "  );",
                "",
                "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                "  }",
                "",
                "  return FLOW_PRAGMA_REGEX.test(text);",
                "}",
                "",
                "function createParse(parseMethod, ...pluginCombinations) {",
                "  return (text, parsers, opts = {}) => {",
                "    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {",
                "      opts.parser = \"babel-flow\";",
                "      return parseFlow(text, parsers, opts);",
                "    }",
                "",
                "    // Inline the require to avoid loading all the JS if we don't use it",
                "    const babel = require(\"@babel/parser\");",
                "",
                "    const sourceType =",
                "      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";",
                "",
                "    let ast;",
                "    try {",
                "      const combinations = resolvePluginsConflict(",
                "        text.includes(\"|>\"),",
                "        pluginCombinations,",
                "        [",
                "          [\"pipelineOperator\", { proposal: \"smart\" }],",
                "          [\"pipelineOperator\", { proposal: \"minimal\" }],",
                "          [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                "        ]",
                "      );",
                "      ast = tryCombinations(",
                "        (options) => babel[parseMethod](text, options),",
                "        combinations.map((extraPlugins) =>",
                "          babelOptions({ sourceType, extraPlugins })",
                "        )",
                "      );",
                "    } catch (error) {",
                "      // babel error prints (l:c) with cols that are zero indexed",
                "      // so we need our custom error",
                "      const { message, loc } = error;",
                "",
                "      throw createError(message.replace(/ \\(.*\\)/, \"\"), {",
                "        start: {",
                "          line: loc ? loc.line : 0,",
                "          column: loc ? loc.column + 1 : 0,",
                "        },",
                "      });",
                "    }",
                "",
                "    return postprocess(ast, { ...opts, originalText: text });",
                "  };",
                "}",
                "",
                "const parse = createParse(\"parse\", [\"jsx\", \"flow\"]);",
                "const parseFlow = createParse(\"parse\", [",
                "  \"jsx\",",
                "  [\"flow\", { all: true, enums: true }],",
                "]);",
                "const parseTypeScript = createParse(",
                "  \"parse\",",
                "  [\"jsx\", \"typescript\"],",
                "  [\"typescript\"]",
                ");",
                "const parseExpression = createParse(\"parseExpression\", [\"jsx\"]);",
                "",
                "function tryCombinations(fn, combinations) {",
                "  let error;",
                "  for (let i = 0; i < combinations.length; i++) {",
                "    try {",
                "      return rethrowSomeRecoveredErrors(fn(combinations[i]));",
                "    } catch (_error) {",
                "      if (!error) {",
                "        error = _error;",
                "      }",
                "    }",
                "  }",
                "  throw error;",
                "}",
                "",
                "const messagesShouldThrow = new Set([",
                "  // TSErrors.UnexpectedTypeAnnotation",
                "  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95",
                "  \"Did not expect a type annotation here.\",",
                "  // ErrorMessages.ModuleAttributeDifferentFromType",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92",
                "  \"The only accepted module attribute is `type`\",",
                "  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118",
                "  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",",
                "]);",
                "",
                "function shouldRethrow(error) {",
                "  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);",
                "  // Only works for literal message",
                "  return messagesShouldThrow.has(message);",
                "}",
                "",
                "function rethrowSomeRecoveredErrors(ast) {",
                "  const error = ast.errors.find((error) => shouldRethrow(error));",
                "  if (error) {",
                "    throw error;",
                "  }",
                "",
                "  return ast;",
                "}",
                "",
                "function parseJson(text, parsers, opts) {",
                "  const ast = parseExpression(text, parsers, opts);",
                "",
                "  ast.comments.forEach(assertJsonNode);",
                "  assertJsonNode(ast);",
                "",
                "  return ast;",
                "}",
                "",
                "function assertJsonNode(node, parent) {",
                "  switch (node.type) {",
                "    case \"ArrayExpression\":",
                "      return node.elements.forEach(assertJsonChildNode);",
                "    case \"ObjectExpression\":",
                "      return node.properties.forEach(assertJsonChildNode);",
                "    case \"ObjectProperty\":",
                "      if (node.computed) {",
                "        throw createJsonError(\"computed\");",
                "      }",
                "",
                "      if (node.shorthand) {",
                "        throw createJsonError(\"shorthand\");",
                "      }",
                "      return [node.key, node.value].forEach(assertJsonChildNode);",
                "    case \"UnaryExpression\":",
                "      switch (node.operator) {",
                "        case \"+\":",
                "        case \"-\":",
                "          return assertJsonChildNode(node.argument);",
                "        default:",
                "          throw createJsonError(\"operator\");",
                "      }",
                "    case \"Identifier\":",
                "      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {",
                "        return;",
                "      }",
                "      throw createJsonError();",
                "    case \"NullLiteral\":",
                "    case \"BooleanLiteral\":",
                "    case \"NumericLiteral\":",
                "    case \"StringLiteral\":",
                "      return;",
                "    default:",
                "      throw createJsonError();",
                "  }",
                "",
                "  function assertJsonChildNode(child) {",
                "    return assertJsonNode(child, node);",
                "  }",
                "",
                "  function createJsonError(attribute) {",
                "    const name = !attribute",
                "      ? node.type",
                "      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;",
                "    return createError(`${name} is not allowed in JSON.`, {",
                "      start: {",
                "        line: node.loc.start.line,",
                "        column: node.loc.start.column + 1,",
                "      },",
                "    });",
                "  }",
                "}",
                "",
                "const babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };",
                "const babelFlow = { ...babel, parse: parseFlow };",
                "const babelTypeScript = { ...babel, parse: parseTypeScript };",
                "const babelExpression = { ...babel, parse: parseExpression };",
                "",
                "// Export as a plugin so we can reuse the same bundle for UMD loading",
                "module.exports = {",
                "  parsers: {",
                "    babel,",
                "    \"babel-flow\": babelFlow,",
                "    \"babel-ts\": babelTypeScript,",
                "    json: {",
                "      ...babelExpression,",
                "      hasPragma() {",
                "        return true;",
                "      },",
                "    },",
                "    json5: babelExpression,",
                "    \"json-stringify\": {",
                "      parse: parseJson,",
                "      astFormat: \"estree-json\",",
                "      locStart,",
                "      locEnd,",
                "    },",
                "    /** @internal */",
                "    __js_expression: babelExpression,",
                "    /** for vue filter */",
                "    __vue_expression: babelExpression,",
                "    /** for vue event binding to handle semicolon */",
                "    __vue_event_binding: babel,",
                "  },",
                "};"
            ]
        },
        "7": {
            "function_name": "tryCombinations (not found) ",
            "file_path": "src/language-js/parser-babel.js",
            "function_details": [
                {
                    "name": "tryCombinations",
                    "start_line": 1,
                    "end_line": 286
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const createError = require(\"../common/parser-create-error\");",
                "const {",
                "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                "  getShebang,",
                "} = require(\"../common/util\");",
                "const { hasPragma } = require(\"./pragma\");",
                "const { locStart, locEnd } = require(\"./loc\");",
                "const postprocess = require(\"./postprocess\");",
                "",
                "function babelOptions({ sourceType, extraPlugins = [] }) {",
                "  return {",
                "    sourceType,",
                "    allowAwaitOutsideFunction: true,",
                "    allowImportExportEverywhere: true,",
                "    allowReturnOutsideFunction: true,",
                "    allowSuperOutsideMethod: true,",
                "    allowUndeclaredExports: true,",
                "    errorRecovery: true,",
                "    createParenthesizedExpressions: true,",
                "    plugins: [",
                "      // When adding a plugin, please add a test in `tests/js/babel-plugins`,",
                "      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify",
                "",
                "      \"doExpressions\",",
                "      \"classProperties\",",
                "      \"exportDefaultFrom\",",
                "      \"functionBind\",",
                "      \"functionSent\",",
                "      \"classPrivateProperties\",",
                "      \"throwExpressions\",",
                "      \"classPrivateMethods\",",
                "      \"v8intrinsic\",",
                "      \"partialApplication\",",
                "      [\"decorators\", { decoratorsBeforeExport: false }],",
                "      \"privateIn\",",
                "      \"importAssertions\",",
                "      [\"recordAndTuple\", { syntaxType: \"hash\" }],",
                "      \"decimal\",",
                "      \"moduleStringNames\",",
                "      \"classStaticBlock\",",
                "      ...extraPlugins,",
                "    ],",
                "    tokens: true,",
                "    ranges: true,",
                "  };",
                "}",
                "",
                "function resolvePluginsConflict(",
                "  condition,",
                "  pluginCombinations,",
                "  conflictPlugins",
                ") {",
                "  if (!condition) {",
                "    return pluginCombinations;",
                "  }",
                "  const combinations = [];",
                "  for (const combination of pluginCombinations) {",
                "    for (const plugin of conflictPlugins) {",
                "      combinations.push([...combination, plugin]);",
                "    }",
                "  }",
                "  return combinations;",
                "}",
                "",
                "// Similar to babel",
                "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                "function isFlowFile(text, options) {",
                "  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {",
                "    return true;",
                "  }",
                "",
                "  const shebang = getShebang(text);",
                "  if (shebang) {",
                "    text = text.slice(shebang.length);",
                "  }",
                "",
                "  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                "    text,",
                "    0",
                "  );",
                "",
                "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                "  }",
                "",
                "  return FLOW_PRAGMA_REGEX.test(text);",
                "}",
                "",
                "function createParse(parseMethod, ...pluginCombinations) {",
                "  return (text, parsers, opts = {}) => {",
                "    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {",
                "      opts.parser = \"babel-flow\";",
                "      return parseFlow(text, parsers, opts);",
                "    }",
                "",
                "    // Inline the require to avoid loading all the JS if we don't use it",
                "    const babel = require(\"@babel/parser\");",
                "",
                "    const sourceType =",
                "      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";",
                "",
                "    let ast;",
                "    try {",
                "      const combinations = resolvePluginsConflict(",
                "        text.includes(\"|>\"),",
                "        pluginCombinations,",
                "        [",
                "          [\"pipelineOperator\", { proposal: \"smart\" }],",
                "          [\"pipelineOperator\", { proposal: \"minimal\" }],",
                "          [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                "        ]",
                "      );",
                "      ast = tryCombinations(",
                "        (options) => babel[parseMethod](text, options),",
                "        combinations.map((extraPlugins) =>",
                "          babelOptions({ sourceType, extraPlugins })",
                "        )",
                "      );",
                "    } catch (error) {",
                "      // babel error prints (l:c) with cols that are zero indexed",
                "      // so we need our custom error",
                "      const { message, loc } = error;",
                "",
                "      throw createError(message.replace(/ \\(.*\\)/, \"\"), {",
                "        start: {",
                "          line: loc ? loc.line : 0,",
                "          column: loc ? loc.column + 1 : 0,",
                "        },",
                "      });",
                "    }",
                "",
                "    return postprocess(ast, { ...opts, originalText: text });",
                "  };",
                "}",
                "",
                "const parse = createParse(\"parse\", [\"jsx\", \"flow\"]);",
                "const parseFlow = createParse(\"parse\", [",
                "  \"jsx\",",
                "  [\"flow\", { all: true, enums: true }],",
                "]);",
                "const parseTypeScript = createParse(",
                "  \"parse\",",
                "  [\"jsx\", \"typescript\"],",
                "  [\"typescript\"]",
                ");",
                "const parseExpression = createParse(\"parseExpression\", [\"jsx\"]);",
                "",
                "function tryCombinations(fn, combinations) {",
                "  let error;",
                "  for (let i = 0; i < combinations.length; i++) {",
                "    try {",
                "      return rethrowSomeRecoveredErrors(fn(combinations[i]));",
                "    } catch (_error) {",
                "      if (!error) {",
                "        error = _error;",
                "      }",
                "    }",
                "  }",
                "  throw error;",
                "}",
                "",
                "const messagesShouldThrow = new Set([",
                "  // TSErrors.UnexpectedTypeAnnotation",
                "  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95",
                "  \"Did not expect a type annotation here.\",",
                "  // ErrorMessages.ModuleAttributeDifferentFromType",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92",
                "  \"The only accepted module attribute is `type`\",",
                "  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction",
                "  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118",
                "  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",",
                "]);",
                "",
                "function shouldRethrow(error) {",
                "  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);",
                "  // Only works for literal message",
                "  return messagesShouldThrow.has(message);",
                "}",
                "",
                "function rethrowSomeRecoveredErrors(ast) {",
                "  const error = ast.errors.find((error) => shouldRethrow(error));",
                "  if (error) {",
                "    throw error;",
                "  }",
                "",
                "  return ast;",
                "}",
                "",
                "function parseJson(text, parsers, opts) {",
                "  const ast = parseExpression(text, parsers, opts);",
                "",
                "  ast.comments.forEach(assertJsonNode);",
                "  assertJsonNode(ast);",
                "",
                "  return ast;",
                "}",
                "",
                "function assertJsonNode(node, parent) {",
                "  switch (node.type) {",
                "    case \"ArrayExpression\":",
                "      return node.elements.forEach(assertJsonChildNode);",
                "    case \"ObjectExpression\":",
                "      return node.properties.forEach(assertJsonChildNode);",
                "    case \"ObjectProperty\":",
                "      if (node.computed) {",
                "        throw createJsonError(\"computed\");",
                "      }",
                "",
                "      if (node.shorthand) {",
                "        throw createJsonError(\"shorthand\");",
                "      }",
                "      return [node.key, node.value].forEach(assertJsonChildNode);",
                "    case \"UnaryExpression\":",
                "      switch (node.operator) {",
                "        case \"+\":",
                "        case \"-\":",
                "          return assertJsonChildNode(node.argument);",
                "        default:",
                "          throw createJsonError(\"operator\");",
                "      }",
                "    case \"Identifier\":",
                "      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {",
                "        return;",
                "      }",
                "      throw createJsonError();",
                "    case \"NullLiteral\":",
                "    case \"BooleanLiteral\":",
                "    case \"NumericLiteral\":",
                "    case \"StringLiteral\":",
                "      return;",
                "    default:",
                "      throw createJsonError();",
                "  }",
                "",
                "  function assertJsonChildNode(child) {",
                "    return assertJsonNode(child, node);",
                "  }",
                "",
                "  function createJsonError(attribute) {",
                "    const name = !attribute",
                "      ? node.type",
                "      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;",
                "    return createError(`${name} is not allowed in JSON.`, {",
                "      start: {",
                "        line: node.loc.start.line,",
                "        column: node.loc.start.column + 1,",
                "      },",
                "    });",
                "  }",
                "}",
                "",
                "const babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };",
                "const babelFlow = { ...babel, parse: parseFlow };",
                "const babelTypeScript = { ...babel, parse: parseTypeScript };",
                "const babelExpression = { ...babel, parse: parseExpression };",
                "",
                "// Export as a plugin so we can reuse the same bundle for UMD loading",
                "module.exports = {",
                "  parsers: {",
                "    babel,",
                "    \"babel-flow\": babelFlow,",
                "    \"babel-ts\": babelTypeScript,",
                "    json: {",
                "      ...babelExpression,",
                "      hasPragma() {",
                "        return true;",
                "      },",
                "    },",
                "    json5: babelExpression,",
                "    \"json-stringify\": {",
                "      parse: parseJson,",
                "      astFormat: \"estree-json\",",
                "      locStart,",
                "      locEnd,",
                "    },",
                "    /** @internal */",
                "    __js_expression: babelExpression,",
                "    /** for vue filter */",
                "    __vue_expression: babelExpression,",
                "    /** for vue event binding to handle semicolon */",
                "    __vue_event_binding: babel,",
                "  },",
                "};"
            ]
        },
        "8": {
            "function_name": "parse (not found) ",
            "file_path": "src/language-js/parser-flow.js",
            "function_details": [
                {
                    "name": "parse",
                    "start_line": 1,
                    "end_line": 44
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const createError = require(\"../common/parser-create-error\");",
                "const { hasPragma } = require(\"./pragma\");",
                "const { locStart, locEnd } = require(\"./loc\");",
                "const postprocess = require(\"./postprocess\");",
                "",
                "function parse(text, parsers, opts) {",
                "  // Inline the require to avoid loading all the JS if we don't use it",
                "  const flowParser = require(\"flow-parser\");",
                "",
                "  const ast = flowParser.parse(text, {",
                "    enums: true,",
                "    esproposal_decorators: true,",
                "    esproposal_class_instance_fields: true,",
                "    esproposal_class_static_fields: true,",
                "    esproposal_export_star_as: true,",
                "    esproposal_optional_chaining: true,",
                "    esproposal_nullish_coalescing: true,",
                "    tokens: true,",
                "  });",
                "",
                "  const [error] = ast.errors;",
                "  if (error) {",
                "    const {",
                "      message,",
                "      loc: { start, end },",
                "    } = error;",
                "",
                "    throw createError(message, {",
                "      start: { line: start.line, column: start.column + 1 },",
                "      end: { line: end.line, column: end.column + 1 },",
                "    });",
                "  }",
                "",
                "  return postprocess(ast, { ...opts, originalText: text });",
                "}",
                "",
                "// Export as a plugin so we can reuse the same bundle for UMD loading",
                "module.exports = {",
                "  parsers: {",
                "    flow: { parse, astFormat: \"estree\", hasPragma, locStart, locEnd },",
                "  },",
                "};"
            ]
        },
        "9": {
            "function_name": "parsers (not found) ",
            "file_path": "src/language-js/index.js",
            "function_details": [
                {
                    "name": "parsers",
                    "start_line": 1,
                    "end_line": 161
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const createLanguage = require(\"../utils/create-language\");",
                "const estreePrinter = require(\"./printer-estree\");",
                "const estreeJsonPrinter = require(\"./printer-estree-json\");",
                "const options = require(\"./options\");",
                "",
                "const languages = [",
                "  createLanguage(",
                "    require(\"linguist-languages/data/JavaScript.json\"),",
                "    (data) => ({",
                "      since: \"0.0.0\",",
                "      parsers: [",
                "        \"babel\",",
                "        \"espree\",",
                "        \"babel-flow\",",
                "        \"babel-ts\",",
                "        \"flow\",",
                "        \"typescript\",",
                "      ],",
                "      vscodeLanguageIds: [\"javascript\", \"mongo\"],",
                "      extensions: [",
                "        ...data.extensions,",
                "        // WeiXin Script (Weixin Mini Programs)",
                "        // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                "        \".wxs\",",
                "      ],",
                "    })",
                "  ),",
                "  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({",
                "    name: \"Flow\",",
                "    since: \"0.0.0\",",
                "    parsers: [\"flow\", \"babel-flow\"],",
                "    vscodeLanguageIds: [\"javascript\"],",
                "    aliases: [],",
                "    filenames: [],",
                "    extensions: [\".js.flow\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/JSX.json\"), () => ({",
                "    since: \"0.0.0\",",
                "    parsers: [",
                "      \"babel\",",
                "      \"babel-flow\",",
                "      \"babel-ts\",",
                "      \"flow\",",
                "      \"typescript\",",
                "      \"espree\",",
                "    ],",
                "    vscodeLanguageIds: [\"javascriptreact\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/TypeScript.json\"), () => ({",
                "    since: \"1.4.0\",",
                "    parsers: [\"typescript\", \"babel-ts\"],",
                "    vscodeLanguageIds: [\"typescript\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/TSX.json\"), () => ({",
                "    since: \"1.4.0\",",
                "    parsers: [\"typescript\", \"babel-ts\"],",
                "    vscodeLanguageIds: [\"typescriptreact\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/JSON.json\"), () => ({",
                "    name: \"JSON.stringify\",",
                "    since: \"1.13.0\",",
                "    parsers: [\"json-stringify\"],",
                "    vscodeLanguageIds: [\"json\"],",
                "    extensions: [], // .json file defaults to json instead of json-stringify",
                "    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],",
                "  })),",
                "  createLanguage(require(\"linguist-languages/data/JSON.json\"), (data) => ({",
                "    since: \"1.5.0\",",
                "    parsers: [\"json\"],",
                "    vscodeLanguageIds: [\"json\"],",
                "    filenames: [...data.filenames, \".prettierrc\"],",
                "    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),",
                "  })),",
                "  createLanguage(",
                "    require(\"linguist-languages/data/JSON with Comments.json\"),",
                "    (data) => ({",
                "      since: \"1.5.0\",",
                "      parsers: [\"json\"],",
                "      vscodeLanguageIds: [\"jsonc\"],",
                "      filenames: [...data.filenames, \".eslintrc\"],",
                "    })",
                "  ),",
                "  createLanguage(require(\"linguist-languages/data/JSON5.json\"), () => ({",
                "    since: \"1.13.0\",",
                "    parsers: [\"json5\"],",
                "    vscodeLanguageIds: [\"json5\"],",
                "  })),",
                "];",
                "",
                "const printers = {",
                "  estree: estreePrinter,",
                "  \"estree-json\": estreeJsonPrinter,",
                "};",
                "",
                "const parsers = {",
                "  // JS - Babel",
                "  get babel() {",
                "    return require(\"./parser-babel\").parsers.babel;",
                "  },",
                "  get \"babel-flow\"() {",
                "    return require(\"./parser-babel\").parsers[\"babel-flow\"];",
                "  },",
                "  get \"babel-ts\"() {",
                "    return require(\"./parser-babel\").parsers[\"babel-ts\"];",
                "  },",
                "  get json() {",
                "    return require(\"./parser-babel\").parsers.json;",
                "  },",
                "  get json5() {",
                "    return require(\"./parser-babel\").parsers.json5;",
                "  },",
                "  get \"json-stringify\"() {",
                "    return require(\"./parser-babel\").parsers[\"json-stringify\"];",
                "  },",
                "  get __js_expression() {",
                "    return require(\"./parser-babel\").parsers.__js_expression;",
                "  },",
                "  get __vue_expression() {",
                "    return require(\"./parser-babel\").parsers.__vue_expression;",
                "  },",
                "  get __vue_event_binding() {",
                "    return require(\"./parser-babel\").parsers.__vue_event_binding;",
                "  },",
                "  // JS - Flow",
                "  get flow() {",
                "    return require(\"./parser-flow\").parsers.flow;",
                "  },",
                "  // JS - TypeScript",
                "  get typescript() {",
                "    return require(\"./parser-typescript\").parsers.typescript;",
                "  },",
                "  // JS - Angular Action",
                "  get __ng_action() {",
                "    return require(\"./parser-angular\").parsers.__ng_action;",
                "  },",
                "  // JS - Angular Binding",
                "  get __ng_binding() {",
                "    return require(\"./parser-angular\").parsers.__ng_binding;",
                "  },",
                "  // JS - Angular Interpolation",
                "  get __ng_interpolation() {",
                "    return require(\"./parser-angular\").parsers.__ng_interpolation;",
                "  },",
                "  // JS - Angular Directive",
                "  get __ng_directive() {",
                "    return require(\"./parser-angular\").parsers.__ng_directive;",
                "  },",
                "  // JS - espree",
                "  get espree() {",
                "    return require(\"./parser-espree\").parsers.espree;",
                "  },",
                "};",
                "",
                "module.exports = {",
                "  languages,",
                "  options,",
                "  printers,",
                "  parsers,",
                "};"
            ]
        }
    }
}