{
    "1": {
        "bug_file": "src/language-js/parse/typescript.js",
        "compressed": "NO",
        "line_numbers": 80,
        "compressed_line_numbers": 80,
        "compressed_bug_file_content": "import { parseWithNodeMaps } from \"@typescript-eslint/typescript-estree/dist/parser.js\";\nimport createError from \"../../common/parser-create-error.js\";\nimport tryCombinations from \"../../utils/try-combinations.js\";\nimport createParser from \"./utils/create-parser.js\";\nimport replaceHashbang from \"./utils/replace-hashbang.js\";\nimport postprocess from \"./postprocess/index.js\";\nimport { throwErrorForInvalidNodes } from \"./postprocess/typescript.js\";\n\n/** @type {import(\"@typescript-eslint/typescript-estree\").TSESTreeOptions} */\nconst parseOptions = {\n  // `jest@<=26.4.2` rely on `loc`\n  // https://github.com/facebook/jest/issues/10444\n  // Set `loc` and `range` to `true` also prevent AST traverse\n  // https://github.com/typescript-eslint/typescript-eslint/blob/733b3598c17d3a712cf6f043115587f724dbe3ef/packages/typescript-estree/src/ast-converter.ts#L38\n  loc: true,\n  range: true,\n  comment: true,\n  jsx: true,\n  tokens: true,\n  loggerFn: false,\n  project: [],\n};\n\nfunction createParseError(error) {\n  const { message, lineNumber, column } = error;\n\n  /* c8 ignore next 3 */\n  if (typeof lineNumber !== \"number\") {\n    return error;\n  }\n\n  return createError(message, {\n    loc: {\n      start: { line: lineNumber, column: column + 1 },\n    },\n    cause: error,\n  });\n}\n\nfunction parse(text) {\n  const textToParse = replaceHashbang(text);\n  const jsx = isProbablyJsx(text);\n\n  let result;\n  try {\n    result = tryCombinations([\n      // Try passing with our best guess first.\n      () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx }),\n      // But if we get it wrong, try the opposite.\n      () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx: !jsx }),\n    ]);\n  } catch ({\n    errors: [\n      // Suppose our guess is correct, throw the first error\n      error,\n    ],\n  }) {\n    throw createParseError(error);\n  }\n\n  throwErrorForInvalidNodes(result, text);\n\n  return postprocess(result.ast, { parser: \"typescript\", text });\n}\n\n/**\n * Use a naive regular expression to detect JSX\n */\nfunction isProbablyJsx(text) {\n  return new RegExp(\n    [\n      \"(?:^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string\n      \"|\",\n      \"(?:^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"\n    ].join(\"\"),\n    \"m\"\n  ).test(text);\n}\n\nexport const typescript = createParser(parse);"
    },
    "2": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 750,
        "compressed_line_numbers": 140,
        "compressed_bug_file_content": "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\nimport { printDanglingComments } from \"../main/comments/print.js\";\nimport printIgnored from \"../main/print-ignored.js\";\nimport hasNewline from \"../utils/has-newline.js\";\nimport {\n\n\nimport { replaceEndOfLine, inheritLabel } from \"../document/utils.js\";\nimport UnexpectedNodeError from \"../utils/unexpected-node-error.js\";\nimport isNonEmptyArray from \"../utils/is-non-empty-array.js\";\n\nimport pathNeedsParens from \"./needs-parens.js\";\nimport {\n\n\nimport { locStart, locEnd } from \"./loc.js\";\nimport isBlockComment from \"./utils/is-block-comment.js\";\nimport isIgnored from \"./utils/is-ignored.js\";\n\nimport { printHtmlBinding } from \"./print/html-binding.js\";\nimport { printAngular } from \"./print/angular.js\";\nimport { printJsx } from \"./print/jsx.js\";\nimport { printFlow } from \"./print/flow.js\";\nimport { printTypescript } from \"./print/typescript.js\";\nimport {\n\n\nimport {\n\n\nimport { printTernary } from \"./print/ternary.js\";\nimport {\n\n\nimport { printArray } from \"./print/array.js\";\nimport { printObject } from \"./print/object.js\";\nimport {\n\n\nimport { printProperty } from \"./print/property.js\";\nimport {\n\n\nimport { printCallExpression } from \"./print/call-expression.js\";\nimport {\n\n\nimport { printBinaryishExpression } from \"./print/binaryish.js\";\nimport { printStatementSequence } from \"./print/statement.js\";\nimport { printMemberExpression } from \"./print/member.js\";\nimport { printBlock, printBlockBody } from \"./print/block.js\";\nimport { printLiteral } from \"./print/literal.js\";\nimport { printDecorators } from \"./print/decorators.js\";\nimport { printTypeAnnotationProperty } from \"./print/type-annotation.js\";\nimport { shouldPrintLeadingSemicolon } from \"./print/semicolon.js\";\nimport { printExpressionStatement } from \"./print/expression-statement.js\";\n\n/**\n * @typedef {import(\"../common/ast-path.js\").default} AstPath\n * @typedef {import(\"../document/builders.js\").Doc} Doc\n */\n\n// Their decorators are handled themselves, and they don't need parentheses or leading semicolons\n\n\n/**\n * @param {AstPath} path\n * @param {*} options\n * @param {*} print\n * @param {*} [args]\n * @returns {Doc}\n */\n\n\n  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons\n\n\n/**\n * @param {AstPath} path\n * @param {*} options\n * @param {*} print\n * @param {*} [args]\n * @returns {Doc}\n */\n\n\n  /** @type{Doc[]} */\n\n\n    // Babel extension.\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n          // avoid printing `await (await` on one line\n\n\n    // Babel 6\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n    // For hack-style pipeline\n\n\n      /* c8 ignore next */\n\n\nexport const experimentalFeatures = {\n  // TODO: Make this default behavior\n\n\nexport { genericPrint as print };\nexport * from \"./comments/printer-methods.js\";\nexport { default as embed } from \"./embed/index.js\";\nexport { default as massageAstNode } from \"./clean.js\";\nexport { insertPragma } from \"./pragma.js\";\nexport { default as getVisitorKeys } from \"./traverse/get-visitor-keys.js\";\n"
    },
    "3": {
        "bug_file": "src/language-js/options.js",
        "compressed": "NO",
        "line_numbers": 89,
        "compressed_line_numbers": 89,
        "compressed_bug_file_content": "import commonOptions from \"../common/common-options.evaluate.js\";\n\nconst CATEGORY_JAVASCRIPT = \"JavaScript\";\n\n// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js\nconst options = {\n  arrowParens: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"always\",\n    description: \"Include parentheses around a sole arrow function parameter.\",\n    choices: [\n      {\n        value: \"always\",\n        description: \"Always include parens. Example: `(x) => x`\",\n      },\n      {\n        value: \"avoid\",\n        description: \"Omit parens when possible. Example: `x => x`\",\n      },\n    ],\n  },\n  bracketSameLine: commonOptions.bracketSameLine,\n  bracketSpacing: commonOptions.bracketSpacing,\n  jsxBracketSameLine: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    description: \"Put > on the last line instead of at a new line.\",\n    deprecated: \"2.4.0\",\n  },\n  semi: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: true,\n    description: \"Print semicolons.\",\n    oppositeDescription:\n      \"Do not print semicolons, except at the beginning of lines which may need them.\",\n  },\n  singleQuote: commonOptions.singleQuote,\n  jsxSingleQuote: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Use single quotes in JSX.\",\n  },\n  quoteProps: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"as-needed\",\n    description: \"Change when properties in objects are quoted.\",\n    choices: [\n      {\n        value: \"as-needed\",\n        description: \"Only add quotes around object properties where required.\",\n      },\n      {\n        value: \"consistent\",\n        description:\n          \"If at least one property in an object requires quotes, quote all properties.\",\n      },\n      {\n        value: \"preserve\",\n        description: \"Respect the input use of quotes in object properties.\",\n      },\n    ],\n  },\n  trailingComma: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"all\",\n    description: \"Print trailing commas wherever possible when multi-line.\",\n    choices: [\n      {\n        value: \"all\",\n        description:\n          \"Trailing commas wherever possible (including function arguments).\",\n      },\n      {\n        value: \"es5\",\n        description:\n          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",\n      },\n      { value: \"none\", description: \"No trailing commas.\" },\n    ],\n  },\n  singleAttributePerLine: commonOptions.singleAttributePerLine,\n};\n\nexport default options;"
    },
    "4": {
        "bug_file": "src/language-js/print/typescript.js",
        "compressed": "NO",
        "line_numbers": 389,
        "compressed_line_numbers": 389,
        "compressed_bug_file_content": "import {\n  join,\n  softline,\n  group,\n  indent,\n  conditionalGroup,\n  ifBreak,\n} from \"../../document/builders.js\";\nimport UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";\nimport {\n  isStringLiteral,\n  shouldPrintComma,\n  isCallExpression,\n  isMemberExpression,\n  isArrayOrTupleExpression,\n  isObjectOrRecordExpression,\n} from \"../utils/index.js\";\nimport isTsKeywordType from \"../utils/is-ts-keyword-type.js\";\nimport { locStart } from \"../loc.js\";\n\nimport {\n  printOptionalToken,\n  printDeclareToken,\n  printTypeScriptAccessibilityToken,\n} from \"./misc.js\";\nimport { printTernary } from \"./ternary.js\";\nimport {\n  printFunctionParameters,\n  shouldGroupFunctionParameters,\n} from \"./function-parameters.js\";\nimport { printTemplateLiteral } from \"./template-literal.js\";\nimport { printArray } from \"./array.js\";\nimport { printObject } from \"./object.js\";\nimport { printClassProperty, printClassMethod } from \"./class.js\";\nimport { printTypeParameter, printTypeParameters } from \"./type-parameters.js\";\nimport { printPropertyKey } from \"./property.js\";\nimport { printFunction, printMethodValue } from \"./function.js\";\nimport { printInterface } from \"./interface.js\";\nimport { printBlock } from \"./block.js\";\nimport {\n  printTypeAlias,\n  printIntersectionType,\n  printUnionType,\n  printFunctionType,\n  printIndexedAccessType,\n  printInferType,\n  printJSDocType,\n  printRestType,\n  printNamedTupleMember,\n  printTypeAnnotation,\n  printTypeAnnotationProperty,\n  printArrayType,\n  printTypeQuery,\n} from \"./type-annotation.js\";\nimport { printEnumDeclaration, printEnumMember } from \"./enum.js\";\nimport { printImportKind } from \"./module.js\";\nimport { printTypescriptMappedType } from \"./mapped-type.js\";\n\nfunction printTypescript(path, options, print) {\n  const { node } = path;\n\n  // TypeScript nodes always starts with `TS`\n  if (!node.type.startsWith(\"TS\")) {\n    return;\n  }\n\n  if (isTsKeywordType(node)) {\n    // TS keyword types stars with `TS`, ends with `Keyword`\n    return node.type.slice(2, -7).toLowerCase();\n  }\n\n  const semi = options.semi ? \";\" : \"\";\n  const parts = [];\n\n  switch (node.type) {\n    case \"TSThisType\":\n      return \"this\";\n    case \"TSTypeAssertion\": {\n      const shouldBreakAfterCast = !(\n        isArrayOrTupleExpression(node.expression) ||\n        isObjectOrRecordExpression(node.expression)\n      );\n\n      const castGroup = group([\n        \"<\",\n        indent([softline, print(\"typeAnnotation\")]),\n        softline,\n        \">\",\n      ]);\n\n      const exprContents = [\n        ifBreak(\"(\"),\n        indent([softline, print(\"expression\")]),\n        softline,\n        ifBreak(\")\"),\n      ];\n\n      if (shouldBreakAfterCast) {\n        return conditionalGroup([\n          [castGroup, print(\"expression\")],\n          [castGroup, group(exprContents, { shouldBreak: true })],\n          [castGroup, print(\"expression\")],\n        ]);\n      }\n      return group([castGroup, print(\"expression\")]);\n    }\n    case \"TSDeclareFunction\":\n      return printFunction(path, print, options);\n    case \"TSExportAssignment\":\n      return [\"export = \", print(\"expression\"), semi];\n    case \"TSModuleBlock\":\n      return printBlock(path, options, print);\n    case \"TSInterfaceBody\":\n    case \"TSTypeLiteral\":\n      return printObject(path, options, print);\n    case \"TSTypeAliasDeclaration\":\n      return printTypeAlias(path, options, print);\n    case \"TSQualifiedName\":\n      return [print(\"left\"), \".\", print(\"right\")];\n    case \"TSAbstractMethodDefinition\":\n    case \"TSDeclareMethod\":\n      return printClassMethod(path, options, print);\n    case \"TSAbstractAccessorProperty\":\n    case \"TSAbstractPropertyDefinition\":\n      return printClassProperty(path, options, print);\n    case \"TSInterfaceHeritage\":\n    case \"TSClassImplements\":\n    case \"TSExpressionWithTypeArguments\": // Babel AST\n    case \"TSInstantiationExpression\":\n      return [print(\"expression\"), print(\"typeParameters\")];\n    case \"TSTemplateLiteralType\":\n      return printTemplateLiteral(path, print, options);\n    case \"TSNamedTupleMember\":\n      return printNamedTupleMember(path, options, print);\n    case \"TSRestType\":\n      return printRestType(path, options, print);\n    case \"TSOptionalType\":\n      return [print(\"typeAnnotation\"), \"?\"];\n    case \"TSInterfaceDeclaration\":\n      return printInterface(path, options, print);\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return printTypeParameters(path, options, print, \"params\");\n    case \"TSTypeParameter\":\n      return printTypeParameter(path, options, print);\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\": {\n      const operator = node.type === \"TSAsExpression\" ? \"as\" : \"satisfies\";\n      parts.push(print(\"expression\"), ` ${operator} `, print(\"typeAnnotation\"));\n      const { parent } = path;\n      if (\n        (isCallExpression(parent) && parent.callee === node) ||\n        (isMemberExpression(parent) && parent.object === node)\n      ) {\n        return group([indent([softline, ...parts]), softline]);\n      }\n      return parts;\n    }\n    case \"TSArrayType\":\n      return printArrayType(print);\n    case \"TSPropertySignature\":\n      return [\n        node.readonly ? \"readonly \" : \"\",\n        printPropertyKey(path, options, print),\n        printOptionalToken(path),\n        printTypeAnnotationProperty(path, print),\n      ];\n\n    case \"TSParameterProperty\":\n      return [\n        printTypeScriptAccessibilityToken(node),\n        node.static ? \"static \" : \"\",\n        node.override ? \"override \" : \"\",\n        node.readonly ? \"readonly \" : \"\",\n        print(\"parameter\"),\n      ];\n\n    case \"TSTypeQuery\":\n      return printTypeQuery(path, print);\n    case \"TSIndexSignature\": {\n      // The typescript parser accepts multiple parameters here. If you're\n      // using them, it makes sense to have a trailing comma. But if you\n      // aren't, this is more like a computed property name than an array.\n      // So we leave off the trailing comma when there's just one parameter.\n      const trailingComma =\n        node.parameters.length > 1\n          ? ifBreak(shouldPrintComma(options) ? \",\" : \"\")\n          : \"\";\n\n      const parametersGroup = group([\n        indent([\n          softline,\n          join([\", \", softline], path.map(print, \"parameters\")),\n        ]),\n        trailingComma,\n        softline,\n      ]);\n\n      const isClassMember =\n        path.parent.type === \"ClassBody\" && path.key === \"body\";\n\n      return [\n        // `static` only allowed in class member\n        isClassMember && node.static ? \"static \" : \"\",\n        node.readonly ? \"readonly \" : \"\",\n        \"[\",\n        node.parameters ? parametersGroup : \"\",\n        \"]\",\n        printTypeAnnotationProperty(path, print),\n        isClassMember ? semi : \"\",\n      ];\n    }\n    case \"TSTypePredicate\":\n      return [\n        node.asserts ? \"asserts \" : \"\",\n        print(\"parameterName\"),\n        node.typeAnnotation\n          ? [\" is \", printTypeAnnotationProperty(path, print)]\n          : \"\",\n      ];\n    case \"TSNonNullExpression\":\n      return [print(\"expression\"), \"!\"];\n    case \"TSImportType\":\n      return [\n        !node.isTypeOf ? \"\" : \"typeof \",\n        \"import(\",\n        print(node.parameter ? \"parameter\" : \"argument\"),\n        \")\",\n        !node.qualifier ? \"\" : [\".\", print(\"qualifier\")],\n        printTypeParameters(path, options, print, \"typeParameters\"),\n      ];\n    case \"TSLiteralType\":\n      return print(\"literal\");\n    case \"TSIndexedAccessType\":\n      return printIndexedAccessType(path, options, print);\n\n    case \"TSTypeOperator\":\n      return [node.operator, \" \", print(\"typeAnnotation\")];\n\n    case \"TSMappedType\":\n      return printTypescriptMappedType(path, options, print);\n\n    case \"TSMethodSignature\": {\n      const kind = node.kind && node.kind !== \"method\" ? `${node.kind} ` : \"\";\n      parts.push(\n        printTypeScriptAccessibilityToken(node),\n        kind,\n        node.computed ? \"[\" : \"\",\n        print(\"key\"),\n        node.computed ? \"]\" : \"\",\n        printOptionalToken(path)\n      );\n\n      const parametersDoc = printFunctionParameters(\n        path,\n        print,\n        options,\n        /* expandArg */ false,\n        /* printTypeParams */ true\n      );\n\n      const returnTypePropertyName = node.returnType\n        ? \"returnType\"\n        : \"typeAnnotation\";\n      const returnTypeNode = node[returnTypePropertyName];\n      const returnTypeDoc = returnTypeNode\n        ? printTypeAnnotationProperty(path, print, returnTypePropertyName)\n        : \"\";\n      const shouldGroupParameters = shouldGroupFunctionParameters(\n        node,\n        returnTypeDoc\n      );\n\n      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);\n\n      if (returnTypeNode) {\n        parts.push(group(returnTypeDoc));\n      }\n\n      return group(parts);\n    }\n    case \"TSNamespaceExportDeclaration\":\n      return [\"export as namespace \", print(\"id\"), options.semi ? \";\" : \"\"];\n    case \"TSEnumDeclaration\":\n      return printEnumDeclaration(path, print, options);\n\n    case \"TSEnumMember\":\n      return printEnumMember(path, print);\n\n    case \"TSImportEqualsDeclaration\":\n      return [\n        node.isExport ? \"export \" : \"\",\n        \"import \",\n        printImportKind(node, /* spaceBeforeKind */ false),\n        print(\"id\"),\n        \" = \",\n        print(\"moduleReference\"),\n        options.semi ? \";\" : \"\",\n      ];\n    case \"TSExternalModuleReference\":\n      return [\"require(\", print(\"expression\"), \")\"];\n    case \"TSModuleDeclaration\": {\n      const { parent } = path;\n      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";\n      const bodyIsDeclaration = node.body?.type === \"TSModuleDeclaration\";\n\n      if (parentIsDeclaration) {\n        parts.push(\".\");\n      } else {\n        parts.push(printDeclareToken(path));\n\n        // Global declaration looks like this:\n        // (declare)? global { ... }\n        const isGlobal =\n          node.kind === \"global\" ||\n          // TODO: Use `node.kind` when babel update AST\n          // https://github.com/typescript-eslint/typescript-eslint/pull/6443\n          node.global;\n\n        if (!isGlobal) {\n          const kind =\n            node.kind ??\n            // TODO: Use `node.kind` when babel update AST\n            (isStringLiteral(node.id) ||\n            /(?:^|\\s)module(?:\\s|$)/.test(\n              options.originalText.slice(locStart(node), locStart(node.id))\n            )\n              ? \"module\"\n              : \"namespace\");\n          parts.push(kind, \" \");\n        }\n      }\n\n      parts.push(print(\"id\"));\n\n      if (bodyIsDeclaration) {\n        parts.push(print(\"body\"));\n      } else if (node.body) {\n        parts.push(\" \", group(print(\"body\")));\n      } else {\n        parts.push(semi);\n      }\n\n      return parts;\n    }\n\n    case \"TSConditionalType\":\n      return printTernary(path, options, print);\n\n    case \"TSInferType\":\n      return printInferType(path, options, print);\n    case \"TSIntersectionType\":\n      return printIntersectionType(path, options, print);\n    case \"TSUnionType\":\n      return printUnionType(path, options, print);\n    case \"TSFunctionType\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructorType\":\n    case \"TSConstructSignatureDeclaration\":\n      return printFunctionType(path, options, print);\n    case \"TSTupleType\":\n      return printArray(path, options, print);\n    case \"TSTypeReference\":\n      return [\n        print(\"typeName\"),\n        printTypeParameters(path, options, print, \"typeParameters\"),\n      ];\n    case \"TSTypeAnnotation\":\n      return printTypeAnnotation(path, options, print);\n    case \"TSEmptyBodyFunctionExpression\":\n      return printMethodValue(path, options, print);\n\n    // These are not valid TypeScript. Printing them just for the sake of error recovery.\n    case \"TSJSDocAllType\":\n      return \"*\";\n    case \"TSJSDocUnknownType\":\n      return \"?\";\n    case \"TSJSDocNullableType\":\n      return printJSDocType(path, print, /* token */ \"?\");\n    case \"TSJSDocNonNullableType\":\n      return printJSDocType(path, print, /* token */ \"!\");\n    case \"TSParenthesizedType\": // Removed in `../parse/postprocess.js`\n    default:\n      /* c8 ignore next */\n      throw new UnexpectedNodeError(node, \"TypeScript\");\n  }\n}\n\nexport { printTypescript };"
    }
}