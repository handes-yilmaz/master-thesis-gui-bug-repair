{
    "bug_classes": {
        "1": {
            "class_name": "function printTypescript (not found) ",
            "file_path": "src/language-js/print/typescript.js",
            "class_details": [
                {
                    "name": "function printTypescript",
                    "start_line": 1,
                    "end_line": 389
                }
            ],
            "class_code": [
                "import {",
                "  join,",
                "  softline,",
                "  group,",
                "  indent,",
                "  conditionalGroup,",
                "  ifBreak,",
                "} from \"../../document/builders.js\";",
                "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                "import {",
                "  isStringLiteral,",
                "  shouldPrintComma,",
                "  isCallExpression,",
                "  isMemberExpression,",
                "  isArrayOrTupleExpression,",
                "  isObjectOrRecordExpression,",
                "} from \"../utils/index.js\";",
                "import isTsKeywordType from \"../utils/is-ts-keyword-type.js\";",
                "import { locStart } from \"../loc.js\";",
                "",
                "import {",
                "  printOptionalToken,",
                "  printDeclareToken,",
                "  printTypeScriptAccessibilityToken,",
                "} from \"./misc.js\";",
                "import { printTernary } from \"./ternary.js\";",
                "import {",
                "  printFunctionParameters,",
                "  shouldGroupFunctionParameters,",
                "} from \"./function-parameters.js\";",
                "import { printTemplateLiteral } from \"./template-literal.js\";",
                "import { printArray } from \"./array.js\";",
                "import { printObject } from \"./object.js\";",
                "import { printClassProperty, printClassMethod } from \"./class.js\";",
                "import { printTypeParameter, printTypeParameters } from \"./type-parameters.js\";",
                "import { printPropertyKey } from \"./property.js\";",
                "import { printFunction, printMethodValue } from \"./function.js\";",
                "import { printInterface } from \"./interface.js\";",
                "import { printBlock } from \"./block.js\";",
                "import {",
                "  printTypeAlias,",
                "  printIntersectionType,",
                "  printUnionType,",
                "  printFunctionType,",
                "  printIndexedAccessType,",
                "  printInferType,",
                "  printJSDocType,",
                "  printRestType,",
                "  printNamedTupleMember,",
                "  printTypeAnnotation,",
                "  printTypeAnnotationProperty,",
                "  printArrayType,",
                "  printTypeQuery,",
                "} from \"./type-annotation.js\";",
                "import { printEnumDeclaration, printEnumMember } from \"./enum.js\";",
                "import { printImportKind } from \"./module.js\";",
                "import { printTypescriptMappedType } from \"./mapped-type.js\";",
                "",
                "function printTypescript(path, options, print) {",
                "  const { node } = path;",
                "",
                "  // TypeScript nodes always starts with `TS`",
                "  if (!node.type.startsWith(\"TS\")) {",
                "    return;",
                "  }",
                "",
                "  if (isTsKeywordType(node)) {",
                "    // TS keyword types stars with `TS`, ends with `Keyword`",
                "    return node.type.slice(2, -7).toLowerCase();",
                "  }",
                "",
                "  const semi = options.semi ? \";\" : \"\";",
                "  const parts = [];",
                "",
                "  switch (node.type) {",
                "    case \"TSThisType\":",
                "      return \"this\";",
                "    case \"TSTypeAssertion\": {",
                "      const shouldBreakAfterCast = !(",
                "        isArrayOrTupleExpression(node.expression) ||",
                "        isObjectOrRecordExpression(node.expression)",
                "      );",
                "",
                "      const castGroup = group([",
                "        \"<\",",
                "        indent([softline, print(\"typeAnnotation\")]),",
                "        softline,",
                "        \">\",",
                "      ]);",
                "",
                "      const exprContents = [",
                "        ifBreak(\"(\"),",
                "        indent([softline, print(\"expression\")]),",
                "        softline,",
                "        ifBreak(\")\"),",
                "      ];",
                "",
                "      if (shouldBreakAfterCast) {",
                "        return conditionalGroup([",
                "          [castGroup, print(\"expression\")],",
                "          [castGroup, group(exprContents, { shouldBreak: true })],",
                "          [castGroup, print(\"expression\")],",
                "        ]);",
                "      }",
                "      return group([castGroup, print(\"expression\")]);",
                "    }",
                "    case \"TSDeclareFunction\":",
                "      return printFunction(path, print, options);",
                "    case \"TSExportAssignment\":",
                "      return [\"export = \", print(\"expression\"), semi];",
                "    case \"TSModuleBlock\":",
                "      return printBlock(path, options, print);",
                "    case \"TSInterfaceBody\":",
                "    case \"TSTypeLiteral\":",
                "      return printObject(path, options, print);",
                "    case \"TSTypeAliasDeclaration\":",
                "      return printTypeAlias(path, options, print);",
                "    case \"TSQualifiedName\":",
                "      return [print(\"left\"), \".\", print(\"right\")];",
                "    case \"TSAbstractMethodDefinition\":",
                "    case \"TSDeclareMethod\":",
                "      return printClassMethod(path, options, print);",
                "    case \"TSAbstractAccessorProperty\":",
                "    case \"TSAbstractPropertyDefinition\":",
                "      return printClassProperty(path, options, print);",
                "    case \"TSInterfaceHeritage\":",
                "    case \"TSClassImplements\":",
                "    case \"TSExpressionWithTypeArguments\": // Babel AST",
                "    case \"TSInstantiationExpression\":",
                "      return [print(\"expression\"), print(\"typeParameters\")];",
                "    case \"TSTemplateLiteralType\":",
                "      return printTemplateLiteral(path, print, options);",
                "    case \"TSNamedTupleMember\":",
                "      return printNamedTupleMember(path, options, print);",
                "    case \"TSRestType\":",
                "      return printRestType(path, options, print);",
                "    case \"TSOptionalType\":",
                "      return [print(\"typeAnnotation\"), \"?\"];",
                "    case \"TSInterfaceDeclaration\":",
                "      return printInterface(path, options, print);",
                "    case \"TSTypeParameterDeclaration\":",
                "    case \"TSTypeParameterInstantiation\":",
                "      return printTypeParameters(path, options, print, \"params\");",
                "    case \"TSTypeParameter\":",
                "      return printTypeParameter(path, options, print);",
                "    case \"TSAsExpression\":",
                "    case \"TSSatisfiesExpression\": {",
                "      const operator = node.type === \"TSAsExpression\" ? \"as\" : \"satisfies\";",
                "      parts.push(print(\"expression\"), ` ${operator} `, print(\"typeAnnotation\"));",
                "      const { parent } = path;",
                "      if (",
                "        (isCallExpression(parent) && parent.callee === node) ||",
                "        (isMemberExpression(parent) && parent.object === node)",
                "      ) {",
                "        return group([indent([softline, ...parts]), softline]);",
                "      }",
                "      return parts;",
                "    }",
                "    case \"TSArrayType\":",
                "      return printArrayType(print);",
                "    case \"TSPropertySignature\":",
                "      return [",
                "        node.readonly ? \"readonly \" : \"\",",
                "        printPropertyKey(path, options, print),",
                "        printOptionalToken(path),",
                "        printTypeAnnotationProperty(path, print),",
                "      ];",
                "",
                "    case \"TSParameterProperty\":",
                "      return [",
                "        printTypeScriptAccessibilityToken(node),",
                "        node.static ? \"static \" : \"\",",
                "        node.override ? \"override \" : \"\",",
                "        node.readonly ? \"readonly \" : \"\",",
                "        print(\"parameter\"),",
                "      ];",
                "",
                "    case \"TSTypeQuery\":",
                "      return printTypeQuery(path, print);",
                "    case \"TSIndexSignature\": {",
                "      // The typescript parser accepts multiple parameters here. If you're",
                "      // using them, it makes sense to have a trailing comma. But if you",
                "      // aren't, this is more like a computed property name than an array.",
                "      // So we leave off the trailing comma when there's just one parameter.",
                "      const trailingComma =",
                "        node.parameters.length > 1",
                "          ? ifBreak(shouldPrintComma(options) ? \",\" : \"\")",
                "          : \"\";",
                "",
                "      const parametersGroup = group([",
                "        indent([",
                "          softline,",
                "          join([\", \", softline], path.map(print, \"parameters\")),",
                "        ]),",
                "        trailingComma,",
                "        softline,",
                "      ]);",
                "",
                "      const isClassMember =",
                "        path.parent.type === \"ClassBody\" && path.key === \"body\";",
                "",
                "      return [",
                "        // `static` only allowed in class member",
                "        isClassMember && node.static ? \"static \" : \"\",",
                "        node.readonly ? \"readonly \" : \"\",",
                "        \"[\",",
                "        node.parameters ? parametersGroup : \"\",",
                "        \"]\",",
                "        printTypeAnnotationProperty(path, print),",
                "        isClassMember ? semi : \"\",",
                "      ];",
                "    }",
                "    case \"TSTypePredicate\":",
                "      return [",
                "        node.asserts ? \"asserts \" : \"\",",
                "        print(\"parameterName\"),",
                "        node.typeAnnotation",
                "          ? [\" is \", printTypeAnnotationProperty(path, print)]",
                "          : \"\",",
                "      ];",
                "    case \"TSNonNullExpression\":",
                "      return [print(\"expression\"), \"!\"];",
                "    case \"TSImportType\":",
                "      return [",
                "        !node.isTypeOf ? \"\" : \"typeof \",",
                "        \"import(\",",
                "        print(node.parameter ? \"parameter\" : \"argument\"),",
                "        \")\",",
                "        !node.qualifier ? \"\" : [\".\", print(\"qualifier\")],",
                "        printTypeParameters(path, options, print, \"typeParameters\"),",
                "      ];",
                "    case \"TSLiteralType\":",
                "      return print(\"literal\");",
                "    case \"TSIndexedAccessType\":",
                "      return printIndexedAccessType(path, options, print);",
                "",
                "    case \"TSTypeOperator\":",
                "      return [node.operator, \" \", print(\"typeAnnotation\")];",
                "",
                "    case \"TSMappedType\":",
                "      return printTypescriptMappedType(path, options, print);",
                "",
                "    case \"TSMethodSignature\": {",
                "      const kind = node.kind && node.kind !== \"method\" ? `${node.kind} ` : \"\";",
                "      parts.push(",
                "        printTypeScriptAccessibilityToken(node),",
                "        kind,",
                "        node.computed ? \"[\" : \"\",",
                "        print(\"key\"),",
                "        node.computed ? \"]\" : \"\",",
                "        printOptionalToken(path)",
                "      );",
                "",
                "      const parametersDoc = printFunctionParameters(",
                "        path,",
                "        print,",
                "        options,",
                "        /* expandArg */ false,",
                "        /* printTypeParams */ true",
                "      );",
                "",
                "      const returnTypePropertyName = node.returnType",
                "        ? \"returnType\"",
                "        : \"typeAnnotation\";",
                "      const returnTypeNode = node[returnTypePropertyName];",
                "      const returnTypeDoc = returnTypeNode",
                "        ? printTypeAnnotationProperty(path, print, returnTypePropertyName)",
                "        : \"\";",
                "      const shouldGroupParameters = shouldGroupFunctionParameters(",
                "        node,",
                "        returnTypeDoc",
                "      );",
                "",
                "      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);",
                "",
                "      if (returnTypeNode) {",
                "        parts.push(group(returnTypeDoc));",
                "      }",
                "",
                "      return group(parts);",
                "    }",
                "    case \"TSNamespaceExportDeclaration\":",
                "      return [\"export as namespace \", print(\"id\"), options.semi ? \";\" : \"\"];",
                "    case \"TSEnumDeclaration\":",
                "      return printEnumDeclaration(path, print, options);",
                "",
                "    case \"TSEnumMember\":",
                "      return printEnumMember(path, print);",
                "",
                "    case \"TSImportEqualsDeclaration\":",
                "      return [",
                "        node.isExport ? \"export \" : \"\",",
                "        \"import \",",
                "        printImportKind(node, /* spaceBeforeKind */ false),",
                "        print(\"id\"),",
                "        \" = \",",
                "        print(\"moduleReference\"),",
                "        options.semi ? \";\" : \"\",",
                "      ];",
                "    case \"TSExternalModuleReference\":",
                "      return [\"require(\", print(\"expression\"), \")\"];",
                "    case \"TSModuleDeclaration\": {",
                "      const { parent } = path;",
                "      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";",
                "      const bodyIsDeclaration = node.body?.type === \"TSModuleDeclaration\";",
                "",
                "      if (parentIsDeclaration) {",
                "        parts.push(\".\");",
                "      } else {",
                "        parts.push(printDeclareToken(path));",
                "",
                "        // Global declaration looks like this:",
                "        // (declare)? global { ... }",
                "        const isGlobal =",
                "          node.kind === \"global\" ||",
                "          // TODO: Use `node.kind` when babel update AST",
                "          // https://github.com/typescript-eslint/typescript-eslint/pull/6443",
                "          node.global;",
                "",
                "        if (!isGlobal) {",
                "          const kind =",
                "            node.kind ??",
                "            // TODO: Use `node.kind` when babel update AST",
                "            (isStringLiteral(node.id) ||",
                "            /(?:^|\\s)module(?:\\s|$)/.test(",
                "              options.originalText.slice(locStart(node), locStart(node.id))",
                "            )",
                "              ? \"module\"",
                "              : \"namespace\");",
                "          parts.push(kind, \" \");",
                "        }",
                "      }",
                "",
                "      parts.push(print(\"id\"));",
                "",
                "      if (bodyIsDeclaration) {",
                "        parts.push(print(\"body\"));",
                "      } else if (node.body) {",
                "        parts.push(\" \", group(print(\"body\")));",
                "      } else {",
                "        parts.push(semi);",
                "      }",
                "",
                "      return parts;",
                "    }",
                "",
                "    case \"TSConditionalType\":",
                "      return printTernary(path, options, print);",
                "",
                "    case \"TSInferType\":",
                "      return printInferType(path, options, print);",
                "    case \"TSIntersectionType\":",
                "      return printIntersectionType(path, options, print);",
                "    case \"TSUnionType\":",
                "      return printUnionType(path, options, print);",
                "    case \"TSFunctionType\":",
                "    case \"TSCallSignatureDeclaration\":",
                "    case \"TSConstructorType\":",
                "    case \"TSConstructSignatureDeclaration\":",
                "      return printFunctionType(path, options, print);",
                "    case \"TSTupleType\":",
                "      return printArray(path, options, print);",
                "    case \"TSTypeReference\":",
                "      return [",
                "        print(\"typeName\"),",
                "        printTypeParameters(path, options, print, \"typeParameters\"),",
                "      ];",
                "    case \"TSTypeAnnotation\":",
                "      return printTypeAnnotation(path, options, print);",
                "    case \"TSEmptyBodyFunctionExpression\":",
                "      return printMethodValue(path, options, print);",
                "",
                "    // These are not valid TypeScript. Printing them just for the sake of error recovery.",
                "    case \"TSJSDocAllType\":",
                "      return \"*\";",
                "    case \"TSJSDocUnknownType\":",
                "      return \"?\";",
                "    case \"TSJSDocNullableType\":",
                "      return printJSDocType(path, print, /* token */ \"?\");",
                "    case \"TSJSDocNonNullableType\":",
                "      return printJSDocType(path, print, /* token */ \"!\");",
                "    case \"TSParenthesizedType\": // Removed in `../parse/postprocess.js`",
                "    default:",
                "      /* c8 ignore next */",
                "      throw new UnexpectedNodeError(node, \"TypeScript\");",
                "  }",
                "}",
                "",
                "export { printTypescript };"
            ]
        },
        "2": {
            "class_name": "printTypescript (not found) 38-538",
            "file_path": "src/language-js/printer-estree.js",
            "class_details": [
                {
                    "name": "printTypescript",
                    "start_line": 38,
                    "end_line": 538
                }
            ],
            "class_code": [
                "import { printTypescript } from \"./print/typescript.js\";",
                "import {",
                "  printOptionalToken,",
                "  printBindExpressionCallee,",
                "  adjustClause,",
                "  printRestSpread,",
                "  printDefiniteToken,",
                "  printDeclareToken,",
                "} from \"./print/misc.js\";",
                "import {",
                "  printImportDeclaration,",
                "  printExportDeclaration,",
                "  printModuleSpecifier,",
                "} from \"./print/module.js\";",
                "import { printTernary } from \"./print/ternary.js\";",
                "import {",
                "  printTaggedTemplateLiteral,",
                "  printTemplateLiteral,",
                "} from \"./print/template-literal.js\";",
                "import { printArray } from \"./print/array.js\";",
                "import { printObject } from \"./print/object.js\";",
                "import {",
                "  printClass,",
                "  printClassMethod,",
                "  printClassProperty,",
                "  printClassBody,",
                "} from \"./print/class.js\";",
                "import { printProperty } from \"./print/property.js\";",
                "import {",
                "  printFunction,",
                "  printArrowFunction,",
                "  printMethod,",
                "  printReturnStatement,",
                "  printThrowStatement,",
                "} from \"./print/function.js\";",
                "import { printCallExpression } from \"./print/call-expression.js\";",
                "import {",
                "  printVariableDeclarator,",
                "  printAssignmentExpression,",
                "} from \"./print/assignment.js\";",
                "import { printBinaryishExpression } from \"./print/binaryish.js\";",
                "import { printStatementSequence } from \"./print/statement.js\";",
                "import { printMemberExpression } from \"./print/member.js\";",
                "import { printBlock, printBlockBody } from \"./print/block.js\";",
                "import { printLiteral } from \"./print/literal.js\";",
                "import { printDecorators } from \"./print/decorators.js\";",
                "import { printTypeAnnotationProperty } from \"./print/type-annotation.js\";",
                "import { shouldPrintLeadingSemicolon } from \"./print/semicolon.js\";",
                "import { printExpressionStatement } from \"./print/expression-statement.js\";",
                "",
                "/**",
                " * @typedef {import(\"../common/ast-path.js\").default} AstPath",
                " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                " */",
                "",
                "// Their decorators are handled themselves, and they don't need parentheses or leading semicolons",
                "const shouldPrintDirectly = createTypeCheckFunction([",
                "  \"ClassMethod\",",
                "  \"ClassPrivateMethod\",",
                "  \"ClassProperty\",",
                "  \"ClassAccessorProperty\",",
                "  \"AccessorProperty\",",
                "  \"TSAbstractAccessorProperty\",",
                "  \"PropertyDefinition\",",
                "  \"TSAbstractPropertyDefinition\",",
                "  \"ClassPrivateProperty\",",
                "  \"MethodDefinition\",",
                "  \"TSAbstractMethodDefinition\",",
                "  \"TSDeclareMethod\",",
                "]);",
                "",
                "/**",
                " * @param {AstPath} path",
                " * @param {*} options",
                " * @param {*} print",
                " * @param {*} [args]",
                " * @returns {Doc}",
                " */",
                "function genericPrint(path, options, print, args) {",
                "  const doc = printPathNoParens(path, options, print, args);",
                "  if (!doc) {",
                "    return \"\";",
                "  }",
                "",
                "  const { node } = path;",
                "  if (shouldPrintDirectly(node)) {",
                "    return doc;",
                "  }",
                "",
                "  const hasDecorators = isNonEmptyArray(node.decorators);",
                "  const decoratorsDoc = printDecorators(path, options, print);",
                "  const isClassExpression = node.type === \"ClassExpression\";",
                "  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons",
                "  if (hasDecorators && !isClassExpression) {",
                "    return inheritLabel(doc, (doc) => group([decoratorsDoc, doc]));",
                "  }",
                "",
                "  const needsParens = pathNeedsParens(path, options);",
                "  const needsSemi = shouldPrintLeadingSemicolon(path, options);",
                "",
                "  if (!decoratorsDoc && !needsParens && !needsSemi) {",
                "    return doc;",
                "  }",
                "",
                "  return inheritLabel(doc, (doc) => [",
                "    needsSemi ? \";\" : \"\",",
                "    needsParens ? \"(\" : \"\",",
                "    needsParens && isClassExpression && hasDecorators",
                "      ? [indent([line, decoratorsDoc, doc]), line]",
                "      : [decoratorsDoc, doc],",
                "    needsParens ? \")\" : \"\",",
                "  ]);",
                "}",
                "",
                "/**",
                " * @param {AstPath} path",
                " * @param {*} options",
                " * @param {*} print",
                " * @param {*} [args]",
                " * @returns {Doc}",
                " */",
                "function printPathNoParens(path, options, print, args) {",
                "  if (isIgnored(path)) {",
                "    return printIgnored(path, options);",
                "  }",
                "",
                "  for (const printer of [",
                "    printLiteral,",
                "    printHtmlBinding,",
                "    printAngular,",
                "    printJsx,",
                "    printFlow,",
                "    printTypescript,",
                "  ]) {",
                "    const printed = printer(path, options, print);",
                "    if (printed !== undefined) {",
                "      return printed;",
                "    }",
                "  }",
                "",
                "  const { node } = path;",
                "  const semi = options.semi ? \";\" : \"\";",
                "  /** @type{Doc[]} */",
                "  let parts = [];",
                "",
                "  switch (node.type) {",
                "    case \"JsExpressionRoot\":",
                "      return print(\"node\");",
                "    case \"JsonRoot\":",
                "      return [print(\"node\"), hardline];",
                "    case \"File\":",
                "      return print(\"program\");",
                "",
                "    case \"Program\":",
                "      return printBlockBody(path, options, print);",
                "    // Babel extension.",
                "    case \"EmptyStatement\":",
                "      return \"\";",
                "    case \"ExpressionStatement\":",
                "      return printExpressionStatement(path, options, print);",
                "",
                "    case \"ChainExpression\":",
                "      return print(\"expression\");",
                "",
                "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
                "    case \"ParenthesizedExpression\": {",
                "      const shouldHug =",
                "        !hasComment(node.expression) &&",
                "        (isObjectOrRecordExpression(node.expression) ||",
                "          isArrayOrTupleExpression(node.expression));",
                "      if (shouldHug) {",
                "        return [\"(\", print(\"expression\"), \")\"];",
                "      }",
                "      return group([",
                "        \"(\",",
                "        indent([softline, print(\"expression\")]),",
                "        softline,",
                "        \")\",",
                "      ]);",
                "    }",
                "    case \"AssignmentExpression\":",
                "      return printAssignmentExpression(path, options, print);",
                "    case \"VariableDeclarator\":",
                "      return printVariableDeclarator(path, options, print);",
                "    case \"BinaryExpression\":",
                "    case \"LogicalExpression\":",
                "      return printBinaryishExpression(path, options, print);",
                "    case \"AssignmentPattern\":",
                "      return [print(\"left\"), \" = \", print(\"right\")];",
                "    case \"OptionalMemberExpression\":",
                "    case \"MemberExpression\":",
                "      return printMemberExpression(path, options, print);",
                "",
                "    case \"MetaProperty\":",
                "      return [print(\"meta\"), \".\", print(\"property\")];",
                "    case \"BindExpression\":",
                "      if (node.object) {",
                "        parts.push(print(\"object\"));",
                "      }",
                "",
                "      parts.push(",
                "        group(",
                "          indent([softline, printBindExpressionCallee(path, options, print)])",
                "        )",
                "      );",
                "",
                "      return parts;",
                "    case \"Identifier\":",
                "      return [",
                "        node.name,",
                "        printOptionalToken(path),",
                "        printDefiniteToken(path),",
                "        printTypeAnnotationProperty(path, print),",
                "      ];",
                "",
                "    case \"V8IntrinsicIdentifier\":",
                "      return [\"%\", node.name];",
                "    case \"SpreadElement\":",
                "    case \"SpreadElementPattern\":",
                "    case \"SpreadPropertyPattern\":",
                "    case \"RestElement\":",
                "      return printRestSpread(path, print);",
                "    case \"FunctionDeclaration\":",
                "    case \"FunctionExpression\":",
                "      return printFunction(path, print, options, args);",
                "    case \"ArrowFunctionExpression\":",
                "      return printArrowFunction(path, options, print, args);",
                "    case \"YieldExpression\":",
                "      parts.push(\"yield\");",
                "",
                "      if (node.delegate) {",
                "        parts.push(\"*\");",
                "      }",
                "      if (node.argument) {",
                "        parts.push(\" \", print(\"argument\"));",
                "      }",
                "",
                "      return parts;",
                "    case \"AwaitExpression\":",
                "      parts.push(\"await\");",
                "      if (node.argument) {",
                "        parts.push(\" \", print(\"argument\"));",
                "        const { parent } = path;",
                "        if (",
                "          (isCallExpression(parent) && parent.callee === node) ||",
                "          (isMemberExpression(parent) && parent.object === node)",
                "        ) {",
                "          parts = [indent([softline, ...parts]), softline];",
                "          // avoid printing `await (await` on one line",
                "          const parentAwaitOrBlock = path.findAncestor(",
                "            (node) =>",
                "              node.type === \"AwaitExpression\" || node.type === \"BlockStatement\"",
                "          );",
                "          if (",
                "            parentAwaitOrBlock?.type !== \"AwaitExpression\" ||",
                "            !startsWithNoLookaheadToken(",
                "              parentAwaitOrBlock.argument,",
                "              (leftmostNode) => leftmostNode === node",
                "            )",
                "          ) {",
                "            return group(parts);",
                "          }",
                "        }",
                "      }",
                "      return parts;",
                "",
                "    case \"ExportDefaultDeclaration\":",
                "    case \"ExportNamedDeclaration\":",
                "    case \"ExportAllDeclaration\":",
                "      return printExportDeclaration(path, options, print);",
                "    case \"ImportDeclaration\":",
                "      return printImportDeclaration(path, options, print);",
                "    case \"ImportSpecifier\":",
                "    case \"ExportSpecifier\":",
                "    case \"ImportNamespaceSpecifier\":",
                "    case \"ExportNamespaceSpecifier\":",
                "    case \"ImportDefaultSpecifier\":",
                "    case \"ExportDefaultSpecifier\":",
                "      return printModuleSpecifier(path, options, print);",
                "    case \"ImportAttribute\":",
                "      return [print(\"key\"), \": \", print(\"value\")];",
                "    case \"Import\":",
                "      return \"import\";",
                "    case \"BlockStatement\":",
                "    case \"StaticBlock\":",
                "      return printBlock(path, options, print);",
                "    case \"ClassBody\":",
                "      return printClassBody(path, options, print);",
                "    case \"ThrowStatement\":",
                "      return printThrowStatement(path, options, print);",
                "    case \"ReturnStatement\":",
                "      return printReturnStatement(path, options, print);",
                "    case \"NewExpression\":",
                "    case \"ImportExpression\":",
                "    case \"OptionalCallExpression\":",
                "    case \"CallExpression\":",
                "      return printCallExpression(path, options, print);",
                "",
                "    case \"ObjectExpression\":",
                "    case \"ObjectPattern\":",
                "    case \"RecordExpression\":",
                "      return printObject(path, options, print);",
                "    // Babel 6",
                "    case \"ObjectProperty\": // Non-standard AST node type.",
                "    case \"Property\":",
                "      if (node.method || node.kind === \"get\" || node.kind === \"set\") {",
                "        return printMethod(path, options, print);",
                "      }",
                "      return printProperty(path, options, print);",
                "    case \"ObjectMethod\":",
                "      return printMethod(path, options, print);",
                "    case \"Decorator\":",
                "      return [\"@\", print(\"expression\")];",
                "    case \"ArrayExpression\":",
                "    case \"ArrayPattern\":",
                "    case \"TupleExpression\":",
                "      return printArray(path, options, print);",
                "    case \"SequenceExpression\": {",
                "      const { parent } = path;",
                "      if (",
                "        parent.type === \"ExpressionStatement\" ||",
                "        parent.type === \"ForStatement\"",
                "      ) {",
                "        // For ExpressionStatements and for-loop heads, which are among",
                "        // the few places a SequenceExpression appears unparenthesized, we want",
                "        // to indent expressions after the first.",
                "        const parts = [];",
                "        path.each(({ isFirst }) => {",
                "          if (isFirst) {",
                "            parts.push(print());",
                "          } else {",
                "            parts.push(\",\", indent([line, print()]));",
                "          }",
                "        }, \"expressions\");",
                "        return group(parts);",
                "      }",
                "      return group(join([\",\", line], path.map(print, \"expressions\")));",
                "    }",
                "    case \"ThisExpression\":",
                "      return \"this\";",
                "    case \"Super\":",
                "      return \"super\";",
                "    case \"Directive\":",
                "      return [print(\"value\"), semi]; // Babel 6",
                "    case \"UnaryExpression\":",
                "      parts.push(node.operator);",
                "",
                "      if (/[a-z]$/.test(node.operator)) {",
                "        parts.push(\" \");",
                "      }",
                "",
                "      if (hasComment(node.argument)) {",
                "        parts.push(",
                "          group([\"(\", indent([softline, print(\"argument\")]), softline, \")\"])",
                "        );",
                "      } else {",
                "        parts.push(print(\"argument\"));",
                "      }",
                "",
                "      return parts;",
                "    case \"UpdateExpression\":",
                "      parts.push(print(\"argument\"), node.operator);",
                "",
                "      if (node.prefix) {",
                "        parts.reverse();",
                "      }",
                "",
                "      return parts;",
                "    case \"ConditionalExpression\":",
                "      return printTernary(path, options, print);",
                "    case \"VariableDeclaration\": {",
                "      const printed = path.map(print, \"declarations\");",
                "",
                "      // We generally want to terminate all variable declarations with a",
                "      // semicolon, except when they in the () part of for loops.",
                "      const parentNode = path.parent;",
                "",
                "      const isParentForLoop =",
                "        parentNode.type === \"ForStatement\" ||",
                "        parentNode.type === \"ForInStatement\" ||",
                "        parentNode.type === \"ForOfStatement\";",
                "",
                "      const hasValue = node.declarations.some((decl) => decl.init);",
                "",
                "      let firstVariable;",
                "      if (printed.length === 1 && !hasComment(node.declarations[0])) {",
                "        firstVariable = printed[0];",
                "      } else if (printed.length > 0) {",
                "        // Indent first var to comply with eslint one-var rule",
                "        firstVariable = indent(printed[0]);",
                "      }",
                "",
                "      parts = [",
                "        printDeclareToken(path),",
                "        node.kind,",
                "        firstVariable ? [\" \", firstVariable] : \"\",",
                "        indent(",
                "          printed",
                "            .slice(1)",
                "            .map((p) => [",
                "              \",\",",
                "              hasValue && !isParentForLoop ? hardline : line,",
                "              p,",
                "            ])",
                "        ),",
                "      ];",
                "",
                "      if (!(isParentForLoop && parentNode.body !== node)) {",
                "        parts.push(semi);",
                "      }",
                "",
                "      return group(parts);",
                "    }",
                "    case \"WithStatement\":",
                "      return group([",
                "        \"with (\",",
                "        print(\"object\"),",
                "        \")\",",
                "        adjustClause(node.body, print(\"body\")),",
                "      ]);",
                "    case \"IfStatement\": {",
                "      const con = adjustClause(node.consequent, print(\"consequent\"));",
                "      const opening = group([",
                "        \"if (\",",
                "        group([indent([softline, print(\"test\")]), softline]),",
                "        \")\",",
                "        con,",
                "      ]);",
                "",
                "      parts.push(opening);",
                "",
                "      if (node.alternate) {",
                "        const commentOnOwnLine =",
                "          hasComment(",
                "            node.consequent,",
                "            CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                "          ) || needsHardlineAfterDanglingComment(node);",
                "        const elseOnSameLine =",
                "          node.consequent.type === \"BlockStatement\" && !commentOnOwnLine;",
                "        parts.push(elseOnSameLine ? \" \" : hardline);",
                "",
                "        if (hasComment(node, CommentCheckFlags.Dangling)) {",
                "          parts.push(",
                "            printDanglingComments(path, options),",
                "            commentOnOwnLine ? hardline : \" \"",
                "          );",
                "        }",
                "",
                "        parts.push(",
                "          \"else\",",
                "          group(",
                "            adjustClause(",
                "              node.alternate,",
                "              print(\"alternate\"),",
                "              node.alternate.type === \"IfStatement\"",
                "            )",
                "          )",
                "        );",
                "      }",
                "",
                "      return parts;",
                "    }",
                "    case \"ForStatement\": {",
                "      const body = adjustClause(node.body, print(\"body\"));",
                "",
                "      // We want to keep dangling comments above the loop to stay consistent.",
                "      // Any comment positioned between the for statement and the parentheses",
                "      // is going to be printed before the statement.",
                "      const dangling = printDanglingComments(path, options);",
                "      const printedComments = dangling ? [dangling, softline] : \"\";",
                "",
                "      if (!node.init && !node.test && !node.update) {",
                "        return [printedComments, group([\"for (;;)\", body])];",
                "      }",
                "",
                "      return [",
                "        printedComments,",
                "        group([",
                "          \"for (\",",
                "          group([",
                "            indent([",
                "              softline,",
                "              print(\"init\"),",
                "              \";\",",
                "              line,",
                "              print(\"test\"),",
                "              \";\",",
                "              line,",
                "              print(\"update\"),",
                "            ]),",
                "            softline,",
                "          ]),",
                "          \")\",",
                "          body,",
                "        ]),",
                "      ];",
                "    }",
                "    case \"WhileStatement\":",
                "      return group([",
                "        \"while (\",",
                "        group([indent([softline, print(\"test\")]), softline]),"
            ]
        }
    },
    "bug_functions": {
        "3": {
            "function_name": "printTypescript (not found) ",
            "file_path": "src/language-js/print/typescript.js",
            "function_details": [
                {
                    "name": "printTypescript",
                    "start_line": 1,
                    "end_line": 389
                }
            ],
            "function_code": [
                "import {",
                "  join,",
                "  softline,",
                "  group,",
                "  indent,",
                "  conditionalGroup,",
                "  ifBreak,",
                "} from \"../../document/builders.js\";",
                "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                "import {",
                "  isStringLiteral,",
                "  shouldPrintComma,",
                "  isCallExpression,",
                "  isMemberExpression,",
                "  isArrayOrTupleExpression,",
                "  isObjectOrRecordExpression,",
                "} from \"../utils/index.js\";",
                "import isTsKeywordType from \"../utils/is-ts-keyword-type.js\";",
                "import { locStart } from \"../loc.js\";",
                "",
                "import {",
                "  printOptionalToken,",
                "  printDeclareToken,",
                "  printTypeScriptAccessibilityToken,",
                "} from \"./misc.js\";",
                "import { printTernary } from \"./ternary.js\";",
                "import {",
                "  printFunctionParameters,",
                "  shouldGroupFunctionParameters,",
                "} from \"./function-parameters.js\";",
                "import { printTemplateLiteral } from \"./template-literal.js\";",
                "import { printArray } from \"./array.js\";",
                "import { printObject } from \"./object.js\";",
                "import { printClassProperty, printClassMethod } from \"./class.js\";",
                "import { printTypeParameter, printTypeParameters } from \"./type-parameters.js\";",
                "import { printPropertyKey } from \"./property.js\";",
                "import { printFunction, printMethodValue } from \"./function.js\";",
                "import { printInterface } from \"./interface.js\";",
                "import { printBlock } from \"./block.js\";",
                "import {",
                "  printTypeAlias,",
                "  printIntersectionType,",
                "  printUnionType,",
                "  printFunctionType,",
                "  printIndexedAccessType,",
                "  printInferType,",
                "  printJSDocType,",
                "  printRestType,",
                "  printNamedTupleMember,",
                "  printTypeAnnotation,",
                "  printTypeAnnotationProperty,",
                "  printArrayType,",
                "  printTypeQuery,",
                "} from \"./type-annotation.js\";",
                "import { printEnumDeclaration, printEnumMember } from \"./enum.js\";",
                "import { printImportKind } from \"./module.js\";",
                "import { printTypescriptMappedType } from \"./mapped-type.js\";",
                "",
                "function printTypescript(path, options, print) {",
                "  const { node } = path;",
                "",
                "  // TypeScript nodes always starts with `TS`",
                "  if (!node.type.startsWith(\"TS\")) {",
                "    return;",
                "  }",
                "",
                "  if (isTsKeywordType(node)) {",
                "    // TS keyword types stars with `TS`, ends with `Keyword`",
                "    return node.type.slice(2, -7).toLowerCase();",
                "  }",
                "",
                "  const semi = options.semi ? \";\" : \"\";",
                "  const parts = [];",
                "",
                "  switch (node.type) {",
                "    case \"TSThisType\":",
                "      return \"this\";",
                "    case \"TSTypeAssertion\": {",
                "      const shouldBreakAfterCast = !(",
                "        isArrayOrTupleExpression(node.expression) ||",
                "        isObjectOrRecordExpression(node.expression)",
                "      );",
                "",
                "      const castGroup = group([",
                "        \"<\",",
                "        indent([softline, print(\"typeAnnotation\")]),",
                "        softline,",
                "        \">\",",
                "      ]);",
                "",
                "      const exprContents = [",
                "        ifBreak(\"(\"),",
                "        indent([softline, print(\"expression\")]),",
                "        softline,",
                "        ifBreak(\")\"),",
                "      ];",
                "",
                "      if (shouldBreakAfterCast) {",
                "        return conditionalGroup([",
                "          [castGroup, print(\"expression\")],",
                "          [castGroup, group(exprContents, { shouldBreak: true })],",
                "          [castGroup, print(\"expression\")],",
                "        ]);",
                "      }",
                "      return group([castGroup, print(\"expression\")]);",
                "    }",
                "    case \"TSDeclareFunction\":",
                "      return printFunction(path, print, options);",
                "    case \"TSExportAssignment\":",
                "      return [\"export = \", print(\"expression\"), semi];",
                "    case \"TSModuleBlock\":",
                "      return printBlock(path, options, print);",
                "    case \"TSInterfaceBody\":",
                "    case \"TSTypeLiteral\":",
                "      return printObject(path, options, print);",
                "    case \"TSTypeAliasDeclaration\":",
                "      return printTypeAlias(path, options, print);",
                "    case \"TSQualifiedName\":",
                "      return [print(\"left\"), \".\", print(\"right\")];",
                "    case \"TSAbstractMethodDefinition\":",
                "    case \"TSDeclareMethod\":",
                "      return printClassMethod(path, options, print);",
                "    case \"TSAbstractAccessorProperty\":",
                "    case \"TSAbstractPropertyDefinition\":",
                "      return printClassProperty(path, options, print);",
                "    case \"TSInterfaceHeritage\":",
                "    case \"TSClassImplements\":",
                "    case \"TSExpressionWithTypeArguments\": // Babel AST",
                "    case \"TSInstantiationExpression\":",
                "      return [print(\"expression\"), print(\"typeParameters\")];",
                "    case \"TSTemplateLiteralType\":",
                "      return printTemplateLiteral(path, print, options);",
                "    case \"TSNamedTupleMember\":",
                "      return printNamedTupleMember(path, options, print);",
                "    case \"TSRestType\":",
                "      return printRestType(path, options, print);",
                "    case \"TSOptionalType\":",
                "      return [print(\"typeAnnotation\"), \"?\"];",
                "    case \"TSInterfaceDeclaration\":",
                "      return printInterface(path, options, print);",
                "    case \"TSTypeParameterDeclaration\":",
                "    case \"TSTypeParameterInstantiation\":",
                "      return printTypeParameters(path, options, print, \"params\");",
                "    case \"TSTypeParameter\":",
                "      return printTypeParameter(path, options, print);",
                "    case \"TSAsExpression\":",
                "    case \"TSSatisfiesExpression\": {",
                "      const operator = node.type === \"TSAsExpression\" ? \"as\" : \"satisfies\";",
                "      parts.push(print(\"expression\"), ` ${operator} `, print(\"typeAnnotation\"));",
                "      const { parent } = path;",
                "      if (",
                "        (isCallExpression(parent) && parent.callee === node) ||",
                "        (isMemberExpression(parent) && parent.object === node)",
                "      ) {",
                "        return group([indent([softline, ...parts]), softline]);",
                "      }",
                "      return parts;",
                "    }",
                "    case \"TSArrayType\":",
                "      return printArrayType(print);",
                "    case \"TSPropertySignature\":",
                "      return [",
                "        node.readonly ? \"readonly \" : \"\",",
                "        printPropertyKey(path, options, print),",
                "        printOptionalToken(path),",
                "        printTypeAnnotationProperty(path, print),",
                "      ];",
                "",
                "    case \"TSParameterProperty\":",
                "      return [",
                "        printTypeScriptAccessibilityToken(node),",
                "        node.static ? \"static \" : \"\",",
                "        node.override ? \"override \" : \"\",",
                "        node.readonly ? \"readonly \" : \"\",",
                "        print(\"parameter\"),",
                "      ];",
                "",
                "    case \"TSTypeQuery\":",
                "      return printTypeQuery(path, print);",
                "    case \"TSIndexSignature\": {",
                "      // The typescript parser accepts multiple parameters here. If you're",
                "      // using them, it makes sense to have a trailing comma. But if you",
                "      // aren't, this is more like a computed property name than an array.",
                "      // So we leave off the trailing comma when there's just one parameter.",
                "      const trailingComma =",
                "        node.parameters.length > 1",
                "          ? ifBreak(shouldPrintComma(options) ? \",\" : \"\")",
                "          : \"\";",
                "",
                "      const parametersGroup = group([",
                "        indent([",
                "          softline,",
                "          join([\", \", softline], path.map(print, \"parameters\")),",
                "        ]),",
                "        trailingComma,",
                "        softline,",
                "      ]);",
                "",
                "      const isClassMember =",
                "        path.parent.type === \"ClassBody\" && path.key === \"body\";",
                "",
                "      return [",
                "        // `static` only allowed in class member",
                "        isClassMember && node.static ? \"static \" : \"\",",
                "        node.readonly ? \"readonly \" : \"\",",
                "        \"[\",",
                "        node.parameters ? parametersGroup : \"\",",
                "        \"]\",",
                "        printTypeAnnotationProperty(path, print),",
                "        isClassMember ? semi : \"\",",
                "      ];",
                "    }",
                "    case \"TSTypePredicate\":",
                "      return [",
                "        node.asserts ? \"asserts \" : \"\",",
                "        print(\"parameterName\"),",
                "        node.typeAnnotation",
                "          ? [\" is \", printTypeAnnotationProperty(path, print)]",
                "          : \"\",",
                "      ];",
                "    case \"TSNonNullExpression\":",
                "      return [print(\"expression\"), \"!\"];",
                "    case \"TSImportType\":",
                "      return [",
                "        !node.isTypeOf ? \"\" : \"typeof \",",
                "        \"import(\",",
                "        print(node.parameter ? \"parameter\" : \"argument\"),",
                "        \")\",",
                "        !node.qualifier ? \"\" : [\".\", print(\"qualifier\")],",
                "        printTypeParameters(path, options, print, \"typeParameters\"),",
                "      ];",
                "    case \"TSLiteralType\":",
                "      return print(\"literal\");",
                "    case \"TSIndexedAccessType\":",
                "      return printIndexedAccessType(path, options, print);",
                "",
                "    case \"TSTypeOperator\":",
                "      return [node.operator, \" \", print(\"typeAnnotation\")];",
                "",
                "    case \"TSMappedType\":",
                "      return printTypescriptMappedType(path, options, print);",
                "",
                "    case \"TSMethodSignature\": {",
                "      const kind = node.kind && node.kind !== \"method\" ? `${node.kind} ` : \"\";",
                "      parts.push(",
                "        printTypeScriptAccessibilityToken(node),",
                "        kind,",
                "        node.computed ? \"[\" : \"\",",
                "        print(\"key\"),",
                "        node.computed ? \"]\" : \"\",",
                "        printOptionalToken(path)",
                "      );",
                "",
                "      const parametersDoc = printFunctionParameters(",
                "        path,",
                "        print,",
                "        options,",
                "        /* expandArg */ false,",
                "        /* printTypeParams */ true",
                "      );",
                "",
                "      const returnTypePropertyName = node.returnType",
                "        ? \"returnType\"",
                "        : \"typeAnnotation\";",
                "      const returnTypeNode = node[returnTypePropertyName];",
                "      const returnTypeDoc = returnTypeNode",
                "        ? printTypeAnnotationProperty(path, print, returnTypePropertyName)",
                "        : \"\";",
                "      const shouldGroupParameters = shouldGroupFunctionParameters(",
                "        node,",
                "        returnTypeDoc",
                "      );",
                "",
                "      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);",
                "",
                "      if (returnTypeNode) {",
                "        parts.push(group(returnTypeDoc));",
                "      }",
                "",
                "      return group(parts);",
                "    }",
                "    case \"TSNamespaceExportDeclaration\":",
                "      return [\"export as namespace \", print(\"id\"), options.semi ? \";\" : \"\"];",
                "    case \"TSEnumDeclaration\":",
                "      return printEnumDeclaration(path, print, options);",
                "",
                "    case \"TSEnumMember\":",
                "      return printEnumMember(path, print);",
                "",
                "    case \"TSImportEqualsDeclaration\":",
                "      return [",
                "        node.isExport ? \"export \" : \"\",",
                "        \"import \",",
                "        printImportKind(node, /* spaceBeforeKind */ false),",
                "        print(\"id\"),",
                "        \" = \",",
                "        print(\"moduleReference\"),",
                "        options.semi ? \";\" : \"\",",
                "      ];",
                "    case \"TSExternalModuleReference\":",
                "      return [\"require(\", print(\"expression\"), \")\"];",
                "    case \"TSModuleDeclaration\": {",
                "      const { parent } = path;",
                "      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";",
                "      const bodyIsDeclaration = node.body?.type === \"TSModuleDeclaration\";",
                "",
                "      if (parentIsDeclaration) {",
                "        parts.push(\".\");",
                "      } else {",
                "        parts.push(printDeclareToken(path));",
                "",
                "        // Global declaration looks like this:",
                "        // (declare)? global { ... }",
                "        const isGlobal =",
                "          node.kind === \"global\" ||",
                "          // TODO: Use `node.kind` when babel update AST",
                "          // https://github.com/typescript-eslint/typescript-eslint/pull/6443",
                "          node.global;",
                "",
                "        if (!isGlobal) {",
                "          const kind =",
                "            node.kind ??",
                "            // TODO: Use `node.kind` when babel update AST",
                "            (isStringLiteral(node.id) ||",
                "            /(?:^|\\s)module(?:\\s|$)/.test(",
                "              options.originalText.slice(locStart(node), locStart(node.id))",
                "            )",
                "              ? \"module\"",
                "              : \"namespace\");",
                "          parts.push(kind, \" \");",
                "        }",
                "      }",
                "",
                "      parts.push(print(\"id\"));",
                "",
                "      if (bodyIsDeclaration) {",
                "        parts.push(print(\"body\"));",
                "      } else if (node.body) {",
                "        parts.push(\" \", group(print(\"body\")));",
                "      } else {",
                "        parts.push(semi);",
                "      }",
                "",
                "      return parts;",
                "    }",
                "",
                "    case \"TSConditionalType\":",
                "      return printTernary(path, options, print);",
                "",
                "    case \"TSInferType\":",
                "      return printInferType(path, options, print);",
                "    case \"TSIntersectionType\":",
                "      return printIntersectionType(path, options, print);",
                "    case \"TSUnionType\":",
                "      return printUnionType(path, options, print);",
                "    case \"TSFunctionType\":",
                "    case \"TSCallSignatureDeclaration\":",
                "    case \"TSConstructorType\":",
                "    case \"TSConstructSignatureDeclaration\":",
                "      return printFunctionType(path, options, print);",
                "    case \"TSTupleType\":",
                "      return printArray(path, options, print);",
                "    case \"TSTypeReference\":",
                "      return [",
                "        print(\"typeName\"),",
                "        printTypeParameters(path, options, print, \"typeParameters\"),",
                "      ];",
                "    case \"TSTypeAnnotation\":",
                "      return printTypeAnnotation(path, options, print);",
                "    case \"TSEmptyBodyFunctionExpression\":",
                "      return printMethodValue(path, options, print);",
                "",
                "    // These are not valid TypeScript. Printing them just for the sake of error recovery.",
                "    case \"TSJSDocAllType\":",
                "      return \"*\";",
                "    case \"TSJSDocUnknownType\":",
                "      return \"?\";",
                "    case \"TSJSDocNullableType\":",
                "      return printJSDocType(path, print, /* token */ \"?\");",
                "    case \"TSJSDocNonNullableType\":",
                "      return printJSDocType(path, print, /* token */ \"!\");",
                "    case \"TSParenthesizedType\": // Removed in `../parse/postprocess.js`",
                "    default:",
                "      /* c8 ignore next */",
                "      throw new UnexpectedNodeError(node, \"TypeScript\");",
                "  }",
                "}",
                "",
                "export { printTypescript };"
            ]
        }
    }
}