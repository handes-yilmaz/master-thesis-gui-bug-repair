{
    "1": {
        "bug_file": "src/language-markdown/printer-markdown.js",
        "compressed": "YES",
        "line_numbers": 779,
        "compressed_line_numbers": 106,
        "compressed_bug_file_content": "import collapseWhiteSpace from \"collapse-white-space\";\n\nimport {\n\n\nimport { DOC_TYPE_STRING } from \"../document/constants.js\";\nimport { getDocType, replaceEndOfLine } from \"../document/utils.js\";\nimport getMaxContinuousCount from \"../utils/get-max-continuous-count.js\";\nimport getMinNotPresentContinuousCount from \"../utils/get-min-not-present-continuous-count.js\";\nimport getPreferredQuote from \"../utils/get-preferred-quote.js\";\nimport UnexpectedNodeError from \"../utils/unexpected-node-error.js\";\nimport clean from \"./clean.js\";\nimport { PUNCTUATION_REGEXP } from \"./constants.evaluate.js\";\nimport embed from \"./embed.js\";\nimport getVisitorKeys from \"./get-visitor-keys.js\";\nimport { locEnd, locStart } from \"./loc.js\";\nimport { insertPragma } from \"./pragma.js\";\nimport { printTable } from \"./print/table.js\";\nimport { printParagraph } from \"./print-paragraph.js\";\nimport preprocess from \"./print-preprocess.js\";\nimport { printSentence } from \"./print-sentence.js\";\nimport { printWhitespace } from \"./print-whitespace.js\";\nimport {\n\n\n/**\n * @typedef {import(\"../document/builders.js\").Doc} Doc\n */\n\n\n    /** @type {Doc} */\n\n\n      /* c8 ignore next 3 */\n\n\n        // backslash is parsed as part of autolinks, so we need to remove it\n\n\n        // leading char that may cause different syntax\n\n\n            // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }\n\n\n        // indented code block\n\n\n      // fenced code block\n\n\n        // @ts-expect-error\n\n\n              /* workaround for https://github.com/remarkjs/remark/issues/315 */ node.hasIndentedCodeblock\n\n\n    // `footnote` requires `.use(footnotes, {inlineNotes: true})`, we are not using this option\n    // https://github.com/remarkjs/remark-footnotes#optionsinlinenotes\n    /* c8 ignore next 2 */\n\n\n    // MDX\n    // fallback to the original text if multiparser failed\n    // or `embeddedLanguageFormatting: \"off\"`\n\n\n      // remark-math trims content but we don't want to remove whitespaces\n      // since it's very possible that it's recognized as math accidentally\n\n\n      /* c8 ignore next */\n\n\n  /** @typedef {{ index: number, offset: number }} IgnorePosition */\n  /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */\n\n\n  /** @type {IgnorePosition | null} */\n\n\n        // do nothing\n\n\n/** @return {false | 'next' | 'start' | 'end'} */\n\n\n      // Check if `listItem` ends with `\\n`\n      // since it can't be empty, so we only need check the last character\n\n\n/**\n * @param {string} url\n * @param {string[] | string} [dangerousCharOrChars]\n * @returns {string}\n */\n\n\n  // title is escaped after `remark-parse` v7\n\n\n// `remark-parse` lowercase the `label` as `identifier`, we don't want do that\n// https://github.com/remarkjs/remark/blob/daddcb463af2d5b2115496c395d0571c0ff87d15/packages/remark-parse/lib/tokenize/reference.js\n\n\nexport default printer;\n"
    },
    "2": {
        "bug_file": "src/language-markdown/unified-plugins/front-matter.js",
        "compressed": "NO",
        "line_numbers": 21,
        "compressed_line_numbers": 21,
        "compressed_bug_file_content": "import parseFrontMatter from \"../../utils/front-matter/parse.js\";\n\n/**\n * @type {import('unified').Plugin<[], import('unified').Settings>}\n */\nconst frontMatter = function () {\n  const proto = this.Parser.prototype;\n  proto.blockMethods = [\"frontMatter\", ...proto.blockMethods];\n  proto.blockTokenizers.frontMatter = tokenizer;\n\n  function tokenizer(eat, value) {\n    const parsed = parseFrontMatter(value);\n\n    if (parsed.frontMatter) {\n      return eat(parsed.frontMatter.raw)(parsed.frontMatter);\n    }\n  }\n  tokenizer.onlyAtStart = true;\n};\n\nexport default frontMatter;"
    },
    "3": {
        "bug_file": "src/utils/front-matter/parse.js",
        "compressed": "NO",
        "line_numbers": 48,
        "compressed_line_numbers": 48,
        "compressed_bug_file_content": "const frontMatterRegex = new RegExp(\n  String.raw`^(?<startDelimiter>-{3}|\\+{3})` +\n    // trailing spaces after delimiters are allowed\n    String.raw`(?<language>[^\\n]*)` +\n    String.raw`\\n(?:|(?<value>.*?)\\n)` +\n    // In some markdown processors such as pandoc,\n    // \"...\" can be used as the end delimiter for YAML front-matter.\n    // Adding `\\.{3}` make the regex matches `+++\\n...`, but we'll exclude it later\n    String.raw`(?<endDelimiter>\\k<startDelimiter>|\\.{3})` +\n    String.raw`[^\\S\\n]*(?:\\n|$)`,\n  \"s\",\n);\n\nfunction parse(text) {\n  const match = text.match(frontMatterRegex);\n  if (!match) {\n    return { content: text };\n  }\n\n  const { startDelimiter, language, value = \"\", endDelimiter } = match.groups;\n\n  let lang = language.trim() || \"yaml\";\n  if (startDelimiter === \"+++\") {\n    lang = \"toml\";\n  }\n\n  // Only allow yaml to parse with a different end delimiter\n  if (lang !== \"yaml\" && startDelimiter !== endDelimiter) {\n    return { content: text };\n  }\n\n  const [raw] = match;\n  const frontMatter = {\n    type: \"front-matter\",\n    lang,\n    value,\n    startDelimiter,\n    endDelimiter,\n    raw: raw.replace(/\\n$/, \"\"),\n  };\n\n  return {\n    frontMatter,\n    content: raw.replaceAll(/[^\\n]/g, \" \") + text.slice(raw.length),\n  };\n}\n\nexport default parse;"
    }
}