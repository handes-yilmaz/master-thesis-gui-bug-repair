{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) ",
            "file_path": "src/utils/front-matter/parse.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 48
                }
            ],
            "class_code": [
                "const frontMatterRegex = new RegExp(",
                "  String.raw`^(?<startDelimiter>-{3}|\\+{3})` +",
                "    // trailing spaces after delimiters are allowed",
                "    String.raw`(?<language>[^\\n]*)` +",
                "    String.raw`\\n(?:|(?<value>.*?)\\n)` +",
                "    // In some markdown processors such as pandoc,",
                "    // \"...\" can be used as the end delimiter for YAML front-matter.",
                "    // Adding `\\.{3}` make the regex matches `+++\\n...`, but we'll exclude it later",
                "    String.raw`(?<endDelimiter>\\k<startDelimiter>|\\.{3})` +",
                "    String.raw`[^\\S\\n]*(?:\\n|$)`,",
                "  \"s\",",
                ");",
                "",
                "function parse(text) {",
                "  const match = text.match(frontMatterRegex);",
                "  if (!match) {",
                "    return { content: text };",
                "  }",
                "",
                "  const { startDelimiter, language, value = \"\", endDelimiter } = match.groups;",
                "",
                "  let lang = language.trim() || \"yaml\";",
                "  if (startDelimiter === \"+++\") {",
                "    lang = \"toml\";",
                "  }",
                "",
                "  // Only allow yaml to parse with a different end delimiter",
                "  if (lang !== \"yaml\" && startDelimiter !== endDelimiter) {",
                "    return { content: text };",
                "  }",
                "",
                "  const [raw] = match;",
                "  const frontMatter = {",
                "    type: \"front-matter\",",
                "    lang,",
                "    value,",
                "    startDelimiter,",
                "    endDelimiter,",
                "    raw: raw.replace(/\\n$/, \"\"),",
                "  };",
                "",
                "  return {",
                "    frontMatter,",
                "    content: raw.replaceAll(/[^\\n]/g, \" \") + text.slice(raw.length),",
                "  };",
                "}",
                "",
                "export default parse;"
            ]
        },
        "2": {
            "class_name": "frontMatter (not found) ",
            "file_path": "src/language-markdown/unified-plugins/front-matter.js",
            "class_details": [
                {
                    "name": "frontMatter",
                    "start_line": 1,
                    "end_line": 21
                }
            ],
            "class_code": [
                "import parseFrontMatter from \"../../utils/front-matter/parse.js\";",
                "",
                "/**",
                " * @type {import('unified').Plugin<[], import('unified').Settings>}",
                " */",
                "const frontMatter = function () {",
                "  const proto = this.Parser.prototype;",
                "  proto.blockMethods = [\"frontMatter\", ...proto.blockMethods];",
                "  proto.blockTokenizers.frontMatter = tokenizer;",
                "",
                "  function tokenizer(eat, value) {",
                "    const parsed = parseFrontMatter(value);",
                "",
                "    if (parsed.frontMatter) {",
                "      return eat(parsed.frontMatter.raw)(parsed.frontMatter);",
                "    }",
                "  }",
                "  tokenizer.onlyAtStart = true;",
                "};",
                "",
                "export default frontMatter;"
            ]
        },
        "3": {
            "class_name": "parse (not found) ",
            "file_path": "src/utils/front-matter/parse.js",
            "class_details": [
                {
                    "name": "parse",
                    "start_line": 1,
                    "end_line": 48
                }
            ],
            "class_code": [
                "const frontMatterRegex = new RegExp(",
                "  String.raw`^(?<startDelimiter>-{3}|\\+{3})` +",
                "    // trailing spaces after delimiters are allowed",
                "    String.raw`(?<language>[^\\n]*)` +",
                "    String.raw`\\n(?:|(?<value>.*?)\\n)` +",
                "    // In some markdown processors such as pandoc,",
                "    // \"...\" can be used as the end delimiter for YAML front-matter.",
                "    // Adding `\\.{3}` make the regex matches `+++\\n...`, but we'll exclude it later",
                "    String.raw`(?<endDelimiter>\\k<startDelimiter>|\\.{3})` +",
                "    String.raw`[^\\S\\n]*(?:\\n|$)`,",
                "  \"s\",",
                ");",
                "",
                "function parse(text) {",
                "  const match = text.match(frontMatterRegex);",
                "  if (!match) {",
                "    return { content: text };",
                "  }",
                "",
                "  const { startDelimiter, language, value = \"\", endDelimiter } = match.groups;",
                "",
                "  let lang = language.trim() || \"yaml\";",
                "  if (startDelimiter === \"+++\") {",
                "    lang = \"toml\";",
                "  }",
                "",
                "  // Only allow yaml to parse with a different end delimiter",
                "  if (lang !== \"yaml\" && startDelimiter !== endDelimiter) {",
                "    return { content: text };",
                "  }",
                "",
                "  const [raw] = match;",
                "  const frontMatter = {",
                "    type: \"front-matter\",",
                "    lang,",
                "    value,",
                "    startDelimiter,",
                "    endDelimiter,",
                "    raw: raw.replace(/\\n$/, \"\"),",
                "  };",
                "",
                "  return {",
                "    frontMatter,",
                "    content: raw.replaceAll(/[^\\n]/g, \" \") + text.slice(raw.length),",
                "  };",
                "}",
                "",
                "export default parse;"
            ]
        }
    },
    "bug_functions": {
        "4": {
            "function_name": "tokenizer (not found) ",
            "file_path": "src/language-markdown/unified-plugins/front-matter.js",
            "function_details": [
                {
                    "name": "tokenizer",
                    "start_line": 1,
                    "end_line": 21
                }
            ],
            "function_code": [
                "import parseFrontMatter from \"../../utils/front-matter/parse.js\";",
                "",
                "/**",
                " * @type {import('unified').Plugin<[], import('unified').Settings>}",
                " */",
                "const frontMatter = function () {",
                "  const proto = this.Parser.prototype;",
                "  proto.blockMethods = [\"frontMatter\", ...proto.blockMethods];",
                "  proto.blockTokenizers.frontMatter = tokenizer;",
                "",
                "  function tokenizer(eat, value) {",
                "    const parsed = parseFrontMatter(value);",
                "",
                "    if (parsed.frontMatter) {",
                "      return eat(parsed.frontMatter.raw)(parsed.frontMatter);",
                "    }",
                "  }",
                "  tokenizer.onlyAtStart = true;",
                "};",
                "",
                "export default frontMatter;"
            ]
        },
        "5": {
            "function_name": "parse (not found) ",
            "file_path": "src/utils/front-matter/parse.js",
            "function_details": [
                {
                    "name": "parse",
                    "start_line": 1,
                    "end_line": 48
                }
            ],
            "function_code": [
                "const frontMatterRegex = new RegExp(",
                "  String.raw`^(?<startDelimiter>-{3}|\\+{3})` +",
                "    // trailing spaces after delimiters are allowed",
                "    String.raw`(?<language>[^\\n]*)` +",
                "    String.raw`\\n(?:|(?<value>.*?)\\n)` +",
                "    // In some markdown processors such as pandoc,",
                "    // \"...\" can be used as the end delimiter for YAML front-matter.",
                "    // Adding `\\.{3}` make the regex matches `+++\\n...`, but we'll exclude it later",
                "    String.raw`(?<endDelimiter>\\k<startDelimiter>|\\.{3})` +",
                "    String.raw`[^\\S\\n]*(?:\\n|$)`,",
                "  \"s\",",
                ");",
                "",
                "function parse(text) {",
                "  const match = text.match(frontMatterRegex);",
                "  if (!match) {",
                "    return { content: text };",
                "  }",
                "",
                "  const { startDelimiter, language, value = \"\", endDelimiter } = match.groups;",
                "",
                "  let lang = language.trim() || \"yaml\";",
                "  if (startDelimiter === \"+++\") {",
                "    lang = \"toml\";",
                "  }",
                "",
                "  // Only allow yaml to parse with a different end delimiter",
                "  if (lang !== \"yaml\" && startDelimiter !== endDelimiter) {",
                "    return { content: text };",
                "  }",
                "",
                "  const [raw] = match;",
                "  const frontMatter = {",
                "    type: \"front-matter\",",
                "    lang,",
                "    value,",
                "    startDelimiter,",
                "    endDelimiter,",
                "    raw: raw.replace(/\\n$/, \"\"),",
                "  };",
                "",
                "  return {",
                "    frontMatter,",
                "    content: raw.replaceAll(/[^\\n]/g, \" \") + text.slice(raw.length),",
                "  };",
                "}",
                "",
                "export default parse;"
            ]
        }
    }
}