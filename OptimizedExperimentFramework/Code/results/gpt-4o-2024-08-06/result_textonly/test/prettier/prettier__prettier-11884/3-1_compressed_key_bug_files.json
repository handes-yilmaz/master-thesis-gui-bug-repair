{
    "1": {
        "bug_file": "src/language-js/print/type-parameters.js",
        "compressed": "NO",
        "line_numbers": 151,
        "compressed_line_numbers": 151,
        "compressed_bug_file_content": "\"use strict\";\n\nconst { printDanglingComments } = require(\"../../main/comments.js\");\nconst {\n  builders: { join, line, hardline, softline, group, indent, ifBreak },\n} = require(\"../../document/index.js\");\nconst {\n  isTestCall,\n  hasComment,\n  CommentCheckFlags,\n  isTSXFile,\n  shouldPrintComma,\n  getFunctionParameters,\n  isObjectType,\n} = require(\"../utils.js\");\nconst { createGroupIdMapper } = require(\"../../common/util.js\");\nconst { shouldHugType } = require(\"./type-annotation.js\");\nconst { isArrowFunctionVariableDeclarator } = require(\"./assignment.js\");\n\nconst getTypeParametersGroupId = createGroupIdMapper(\"typeParameters\");\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  const node = path.getValue();\n\n  if (!node[paramsKey]) {\n    return \"\";\n  }\n\n  // for TypeParameterDeclaration typeParameters is a single node\n  if (!Array.isArray(node[paramsKey])) {\n    return print(paramsKey);\n  }\n\n  const grandparent = path.getNode(2);\n  const isParameterInTestCall = grandparent && isTestCall(grandparent);\n\n  const isArrowFunctionVariable = path.match(\n    (node) =>\n      !(node[paramsKey].length === 1 && isObjectType(node[paramsKey][0])),\n    undefined,\n    (node, name) => name === \"typeAnnotation\",\n    (node) => node.type === \"Identifier\",\n    isArrowFunctionVariableDeclarator\n  );\n\n  const shouldInline =\n    !isArrowFunctionVariable &&\n    (isParameterInTestCall ||\n      node[paramsKey].length === 0 ||\n      (node[paramsKey].length === 1 &&\n        (node[paramsKey][0].type === \"NullableTypeAnnotation\" ||\n          shouldHugType(node[paramsKey][0]))));\n\n  if (shouldInline) {\n    return [\n      \"<\",\n      join(\", \", path.map(print, paramsKey)),\n      printDanglingCommentsForInline(path, options),\n      \">\",\n    ];\n  }\n\n  // Keep comma if the file extension is .tsx and\n  // has one type parameter that isn't extend with any types.\n  // Because, otherwise formatted result will be invalid as tsx.\n  const trailingComma =\n    node.type === \"TSTypeParameterInstantiation\" // https://github.com/microsoft/TypeScript/issues/21984\n      ? \"\"\n      : getFunctionParameters(node).length === 1 &&\n        isTSXFile(options) &&\n        !node[paramsKey][0].constraint &&\n        path.getParentNode().type === \"ArrowFunctionExpression\"\n      ? \",\"\n      : shouldPrintComma(options, \"all\")\n      ? ifBreak(\",\")\n      : \"\";\n\n  return group(\n    [\n      \"<\",\n      indent([softline, join([\",\", line], path.map(print, paramsKey))]),\n      trailingComma,\n      softline,\n      \">\",\n    ],\n    { id: getTypeParametersGroupId(node) }\n  );\n}\n\nfunction printDanglingCommentsForInline(path, options) {\n  const node = path.getValue();\n  if (!hasComment(node, CommentCheckFlags.Dangling)) {\n    return \"\";\n  }\n  const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);\n  const printed = printDanglingComments(\n    path,\n    options,\n    /* sameIndent */ hasOnlyBlockComments\n  );\n  if (hasOnlyBlockComments) {\n    return printed;\n  }\n  return [printed, hardline];\n}\n\nfunction printTypeParameter(path, options, print) {\n  const node = path.getValue();\n  const parts = [];\n  const parent = path.getParentNode();\n  if (parent.type === \"TSMappedType\") {\n    parts.push(\"[\", print(\"name\"));\n    if (node.constraint) {\n      parts.push(\" in \", print(\"constraint\"));\n    }\n    if (parent.nameType) {\n      parts.push(\n        \" as \",\n        path.callParent(() => print(\"nameType\"))\n      );\n    }\n    parts.push(\"]\");\n    return parts;\n  }\n\n  if (node.variance) {\n    parts.push(print(\"variance\"));\n  }\n\n  parts.push(print(\"name\"));\n\n  if (node.bound) {\n    parts.push(\": \", print(\"bound\"));\n  }\n\n  if (node.constraint) {\n    parts.push(\" extends \", print(\"constraint\"));\n  }\n\n  if (node.default) {\n    parts.push(\" = \", print(\"default\"));\n  }\n\n  return parts;\n}\n\nmodule.exports = {\n  printTypeParameter,\n  printTypeParameters,\n  getTypeParametersGroupId,\n};"
    },
    "2": {
        "bug_file": "src/language-js/print/typescript.js",
        "compressed": "YES",
        "line_numbers": 530,
        "compressed_line_numbers": 36,
        "compressed_bug_file_content": "\n\n  // TypeScript nodes always starts with `TS`\n\n\n      // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n      // The typescript parser accepts multiple parameters here. If you're\n      // using them, it makes sense to have a trailing comma. But if you\n      // aren't, this is more like a computed property name than an array.\n      // So we leave off the trailing comma when there's just one parameter.\n\n\n            /* expandArg */ false,\n            /* printTypeParams */ true\n\n\n        // \"abstract\" and \"declare\" are supported by only \"babel-ts\"\n        // https://github.com/prettier/prettier/issues/9760\n\n\n        /* expandArg */ false,\n        /* printTypeParams */ true\n\n\n        // Global declaration looks like this:\n        // (declare)? global { ... }\n\n\n    // These are not valid TypeScript. Printing them just for the sake of error recovery.\n\n\n      /* istanbul ignore next */\n\n\n"
    },
    "3": {
        "bug_file": "src/document/doc-printer.js",
        "compressed": "YES",
        "line_numbers": 605,
        "compressed_line_numbers": 82,
        "compressed_bug_file_content": "\n\n/** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */\n\n\n      /* istanbul ignore next */\n\n\n  // Trim whitespace at the end of line\n\n\n  // `out` is only used for width counting because `trim` requires to look\n  // backwards for space characters.\n\n\n            // The most expanded state takes up the least space on the current line.\n\n\n            // fallthrough\n\n\n  // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n\n            // fallthrough\n\n\n                // Expanded states are a rare case where a document\n                // can manually provide multiple representations of\n                // itself. It provides an array of documents\n                // going from the least expanded (most flattened)\n                // representation first to the most expanded. If a\n                // group has these, we need to manually go through\n                // these states and find the first one that fits.\n\n\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n\n          // At this point we've handled the first pair (context, separator)\n          // and will create a new fill doc for the rest of the content.\n          // Ideally we wouldn't mutate the array here but copying all the\n          // elements to a new array would make this algorithm quadratic,\n          // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n\n\n            // fallthrough\n\n\n    // Flush remaining line-suffix contents at the end of the document, in case\n    // there is no new line after the line-suffix.\n\n\n"
    },
    "4": {
        "bug_file": "src/main/options.js",
        "compressed": "NO",
        "line_numbers": 197,
        "compressed_line_numbers": 197,
        "compressed_bug_file_content": "\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst readlines = require(\"n-readlines\");\nconst { UndefinedParserError } = require(\"../common/errors.js\");\nconst { getSupportInfo } = require(\"../main/support.js\");\nconst normalizer = require(\"./options-normalizer.js\");\nconst { resolveParser } = require(\"./parser.js\");\n\nconst hiddenDefaults = {\n  astFormat: \"estree\",\n  printer: {},\n  originalText: undefined,\n  locStart: null,\n  locEnd: null,\n};\n\n// Copy options and fill in default values.\nfunction normalize(options, opts = {}) {\n  const rawOptions = { ...options };\n\n  const supportOptions = getSupportInfo({\n    plugins: options.plugins,\n    showUnreleased: true,\n    showDeprecated: true,\n  }).options;\n\n  const defaults = {\n    ...hiddenDefaults,\n    ...Object.fromEntries(\n      supportOptions\n        .filter((optionInfo) => optionInfo.default !== undefined)\n        .map((option) => [option.name, option.default])\n    ),\n  };\n  if (!rawOptions.parser) {\n    if (!rawOptions.filepath) {\n      const logger = opts.logger || console;\n      logger.warn(\n        \"No parser and no filepath given, using 'babel' the parser now \" +\n          \"but this will throw an error in the future. \" +\n          \"Please specify a parser or a filepath so one can be inferred.\"\n      );\n      rawOptions.parser = \"babel\";\n    } else {\n      rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);\n      if (!rawOptions.parser) {\n        throw new UndefinedParserError(\n          `No parser could be inferred for file: ${rawOptions.filepath}`\n        );\n      }\n    }\n  }\n\n  const parser = resolveParser(\n    normalizer.normalizeApiOptions(\n      rawOptions,\n      [supportOptions.find((x) => x.name === \"parser\")],\n      { passThrough: true, logger: false }\n    )\n  );\n  rawOptions.astFormat = parser.astFormat;\n  rawOptions.locEnd = parser.locEnd;\n  rawOptions.locStart = parser.locStart;\n\n  const plugin = getPlugin(rawOptions);\n  rawOptions.printer = plugin.printers[rawOptions.astFormat];\n\n  const pluginDefaults = Object.fromEntries(\n    supportOptions\n      .filter(\n        (optionInfo) =>\n          optionInfo.pluginDefaults &&\n          optionInfo.pluginDefaults[plugin.name] !== undefined\n      )\n      .map((optionInfo) => [\n        optionInfo.name,\n        optionInfo.pluginDefaults[plugin.name],\n      ])\n  );\n\n  const mixedDefaults = { ...defaults, ...pluginDefaults };\n\n  for (const [k, value] of Object.entries(mixedDefaults)) {\n    if (rawOptions[k] === null || rawOptions[k] === undefined) {\n      rawOptions[k] = value;\n    }\n  }\n\n  if (rawOptions.parser === \"json\") {\n    rawOptions.trailingComma = \"none\";\n  }\n\n  return normalizer.normalizeApiOptions(rawOptions, supportOptions, {\n    passThrough: Object.keys(hiddenDefaults),\n    ...opts,\n  });\n}\n\nfunction getPlugin(options) {\n  const { astFormat } = options;\n\n  // TODO: test this with plugins\n  /* istanbul ignore next */\n  if (!astFormat) {\n    throw new Error(\"getPlugin() requires astFormat to be set\");\n  }\n  const printerPlugin = options.plugins.find(\n    (plugin) => plugin.printers && plugin.printers[astFormat]\n  );\n  // TODO: test this with plugins\n  /* istanbul ignore next */\n  if (!printerPlugin) {\n    throw new Error(`Couldn't find plugin for AST format \"${astFormat}\"`);\n  }\n\n  return printerPlugin;\n}\n\nfunction getInterpreter(filepath) {\n  /* istanbul ignore next */\n  if (typeof filepath !== \"string\") {\n    return \"\";\n  }\n\n  let fd;\n  try {\n    fd = fs.openSync(filepath, \"r\");\n  } catch {\n    // istanbul ignore next\n    return \"\";\n  }\n\n  try {\n    const liner = new readlines(fd);\n    const firstLine = liner.next().toString(\"utf8\");\n\n    // #!/bin/env node, #!/usr/bin/env node\n    const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);\n    if (m1) {\n      return m1[1];\n    }\n\n    // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node\n    const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);\n    if (m2) {\n      return m2[1];\n    }\n    return \"\";\n  } catch {\n    // There are some weird cases where paths are missing, causing Jest\n    // failures. It's unclear what these correspond to in the real world.\n    /* istanbul ignore next */\n    return \"\";\n  } finally {\n    try {\n      // There are some weird cases where paths are missing, causing Jest\n      // failures. It's unclear what these correspond to in the real world.\n      fs.closeSync(fd);\n    } catch {\n      // nop\n    }\n  }\n}\n\nfunction inferParser(filepath, plugins) {\n  const filename = path.basename(filepath).toLowerCase();\n  const languages = getSupportInfo({ plugins }).languages.filter(\n    (language) => language.since !== null\n  );\n\n  // If the file has no extension, we can try to infer the language from the\n  // interpreter in the shebang line, if any; but since this requires FS access,\n  // do it last.\n  let language = languages.find(\n    (language) =>\n      (language.extensions &&\n        language.extensions.some((extension) =>\n          filename.endsWith(extension)\n        )) ||\n      (language.filenames &&\n        language.filenames.some((name) => name.toLowerCase() === filename))\n  );\n\n  if (!language && !filename.includes(\".\")) {\n    const interpreter = getInterpreter(filepath);\n    language = languages.find(\n      (language) =>\n        language.interpreters && language.interpreters.includes(interpreter)\n    );\n  }\n\n  return language && language.parsers[0];\n}\n\nmodule.exports = { normalize, hiddenDefaults, inferParser };"
    }
}