{
    "1": {
        "bug_file": "src/language-markdown/parser-markdown.js",
        "compressed": "NO",
        "line_numbers": 130,
        "compressed_line_numbers": 130,
        "compressed_bug_file_content": "\"use strict\";\n\nconst remarkFrontmatter = require(\"remark-frontmatter\");\nconst remarkParse = require(\"remark-parse\");\nconst unified = require(\"unified\");\nconst util = require(\"../common/util\");\n\n/**\n * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:\n *\n * 1. restore unescaped character (Text)\n * 2. merge continuous Texts\n * 3. replace whitespaces in InlineCode#value with one whitespace\n *    reference: http://spec.commonmark.org/0.25/#example-605\n * 4. split Text into Sentence\n *\n * interface Word { value: string }\n * interface Whitespace { value: string }\n * interface Sentence { children: Array<Word | Whitespace> }\n * interface InlineCode { children: Array<Sentence> }\n */\nfunction parse(text /*, parsers, opts*/) {\n  const processor = unified()\n    .use(remarkParse, { footnotes: true, commonmark: true })\n    .use(remarkFrontmatter, [\"yaml\", \"toml\"])\n    .use(restoreUnescapedCharacter(text))\n    .use(mergeContinuousTexts)\n    .use(transformInlineCode)\n    .use(splitText);\n  return processor.runSync(processor.parse(text));\n}\n\nfunction map(ast, handler) {\n  return (function preorder(node, index, parentNode) {\n    const newNode = Object.assign({}, handler(node, index, parentNode));\n    if (newNode.children) {\n      newNode.children = newNode.children.map((child, index) => {\n        return preorder(child, index, newNode);\n      });\n    }\n    return newNode;\n  })(ast, null, null);\n}\n\nfunction transformInlineCode() {\n  return ast =>\n    map(ast, node => {\n      if (node.type !== \"inlineCode\") {\n        return node;\n      }\n\n      return Object.assign({}, node, {\n        value: node.value.replace(/\\s+/g, \" \")\n      });\n    });\n}\n\nfunction restoreUnescapedCharacter(originalText) {\n  return () => ast =>\n    map(ast, node => {\n      return node.type !== \"text\"\n        ? node\n        : Object.assign({}, node, {\n            value:\n              node.value !== \"*\" &&\n              node.value !== \"_\" && // handle these two cases in printer\n              node.value.length === 1 &&\n              node.position.end.offset - node.position.start.offset > 1\n                ? originalText.slice(\n                    node.position.start.offset,\n                    node.position.end.offset\n                  )\n                : node.value\n          });\n    });\n}\n\nfunction mergeContinuousTexts() {\n  return ast =>\n    map(ast, node => {\n      if (!node.children) {\n        return node;\n      }\n      const children = node.children.reduce((current, child) => {\n        const lastChild = current[current.length - 1];\n        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {\n          current.splice(-1, 1, {\n            type: \"text\",\n            value: lastChild.value + child.value,\n            position: {\n              start: lastChild.position.start,\n              end: child.position.end\n            }\n          });\n        } else {\n          current.push(child);\n        }\n        return current;\n      }, []);\n      return Object.assign({}, node, { children });\n    });\n}\n\nfunction splitText() {\n  return ast =>\n    map(ast, (node, index, parentNode) => {\n      if (node.type !== \"text\") {\n        return node;\n      }\n\n      let value = node.value;\n\n      if (parentNode.type === \"paragraph\") {\n        if (index === 0) {\n          value = value.trimLeft();\n        }\n        if (index === parentNode.children.length - 1) {\n          value = value.trimRight();\n        }\n      }\n\n      return {\n        type: \"sentence\",\n        position: node.position,\n        children: util.splitText(value)\n      };\n    });\n}\n\nmodule.exports = parse;"
    },
    "2": {
        "bug_file": "src/language-markdown/printer-markdown.js",
        "compressed": "YES",
        "line_numbers": 733,
        "compressed_line_numbers": 28,
        "compressed_bug_file_content": "\n\n        // leading char that may cause different syntax\n\n\n        // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it\n\n\n        // indented code block\n\n\n      // fenced code block\n\n\n            // do not print trailing spaces for empty list item since it might be treated as `break` node\n            // by [doc-printer](https://github.com/prettier/prettier/blob/1.10.2/src/doc/doc-printer.js#L395-L405),\n            // we don't want to preserve unnecessary trailing spaces.\n\n\n  // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split\n\n\n  // for markdown codeblock\n\n\n  // for markdown whitespace: \"\\n\" and \" \" are considered the same\n\n\n"
    },
    "3": {
        "bug_file": "src/doc/doc-printer.js",
        "compressed": "YES",
        "line_numbers": 508,
        "compressed_line_numbers": 71,
        "compressed_bug_file_content": "\n\n      /* istanbul ignore next */\n\n\n            // fallthrough\n\n\n  // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n\n            // fallthrough\n\n\n                // Expanded states are a rare case where a document\n                // can manually provide multiple representations of\n                // itself. It provides an array of documents\n                // going from the least expanded (most flattened)\n                // representation first to the most expanded. If a\n                // group has these, we need to manually go through\n                // these states and find the first one that fits.\n\n\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n\n          // At this point we've handled the first pair (context, separator)\n          // and will create a new fill doc for the rest of the content.\n          // Ideally we wouldn't mutate the array here but coping all the\n          // elements to a new array would make this algorithm quadratic,\n          // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n\n\n            // fallthrough\n\n\n                  // Trim whitespace at the end of line\n\n\n                      // preserve markdown's `break` node (two trailing spaces)\n\n\n"
    }
}