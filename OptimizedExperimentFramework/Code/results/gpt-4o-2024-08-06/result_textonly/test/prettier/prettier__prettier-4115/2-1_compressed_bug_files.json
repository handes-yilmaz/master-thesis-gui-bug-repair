{
    "1": {
        "bug_file": "src/language-markdown/parser-markdown.js",
        "compressed": "NO",
        "line_numbers": 130,
        "compressed_line_numbers": 130,
        "compressed_bug_file_content": "\"use strict\";\n\nconst remarkFrontmatter = require(\"remark-frontmatter\");\nconst remarkParse = require(\"remark-parse\");\nconst unified = require(\"unified\");\nconst util = require(\"../common/util\");\n\n/**\n * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:\n *\n * 1. restore unescaped character (Text)\n * 2. merge continuous Texts\n * 3. replace whitespaces in InlineCode#value with one whitespace\n *    reference: http://spec.commonmark.org/0.25/#example-605\n * 4. split Text into Sentence\n *\n * interface Word { value: string }\n * interface Whitespace { value: string }\n * interface Sentence { children: Array<Word | Whitespace> }\n * interface InlineCode { children: Array<Sentence> }\n */\nfunction parse(text /*, parsers, opts*/) {\n  const processor = unified()\n    .use(remarkParse, { footnotes: true, commonmark: true })\n    .use(remarkFrontmatter, [\"yaml\", \"toml\"])\n    .use(restoreUnescapedCharacter(text))\n    .use(mergeContinuousTexts)\n    .use(transformInlineCode)\n    .use(splitText);\n  return processor.runSync(processor.parse(text));\n}\n\nfunction map(ast, handler) {\n  return (function preorder(node, index, parentNode) {\n    const newNode = Object.assign({}, handler(node, index, parentNode));\n    if (newNode.children) {\n      newNode.children = newNode.children.map((child, index) => {\n        return preorder(child, index, newNode);\n      });\n    }\n    return newNode;\n  })(ast, null, null);\n}\n\nfunction transformInlineCode() {\n  return ast =>\n    map(ast, node => {\n      if (node.type !== \"inlineCode\") {\n        return node;\n      }\n\n      return Object.assign({}, node, {\n        value: node.value.replace(/\\s+/g, \" \")\n      });\n    });\n}\n\nfunction restoreUnescapedCharacter(originalText) {\n  return () => ast =>\n    map(ast, node => {\n      return node.type !== \"text\"\n        ? node\n        : Object.assign({}, node, {\n            value:\n              node.value !== \"*\" &&\n              node.value !== \"_\" && // handle these two cases in printer\n              node.value.length === 1 &&\n              node.position.end.offset - node.position.start.offset > 1\n                ? originalText.slice(\n                    node.position.start.offset,\n                    node.position.end.offset\n                  )\n                : node.value\n          });\n    });\n}\n\nfunction mergeContinuousTexts() {\n  return ast =>\n    map(ast, node => {\n      if (!node.children) {\n        return node;\n      }\n      const children = node.children.reduce((current, child) => {\n        const lastChild = current[current.length - 1];\n        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {\n          current.splice(-1, 1, {\n            type: \"text\",\n            value: lastChild.value + child.value,\n            position: {\n              start: lastChild.position.start,\n              end: child.position.end\n            }\n          });\n        } else {\n          current.push(child);\n        }\n        return current;\n      }, []);\n      return Object.assign({}, node, { children });\n    });\n}\n\nfunction splitText() {\n  return ast =>\n    map(ast, (node, index, parentNode) => {\n      if (node.type !== \"text\") {\n        return node;\n      }\n\n      let value = node.value;\n\n      if (parentNode.type === \"paragraph\") {\n        if (index === 0) {\n          value = value.trimLeft();\n        }\n        if (index === parentNode.children.length - 1) {\n          value = value.trimRight();\n        }\n      }\n\n      return {\n        type: \"sentence\",\n        position: node.position,\n        children: util.splitText(value)\n      };\n    });\n}\n\nmodule.exports = parse;"
    },
    "2": {
        "bug_file": "src/language-markdown/printer-markdown.js",
        "compressed": "YES",
        "line_numbers": 733,
        "compressed_line_numbers": 28,
        "compressed_bug_file_content": "\n\n        // leading char that may cause different syntax\n\n\n        // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it\n\n\n        // indented code block\n\n\n      // fenced code block\n\n\n            // do not print trailing spaces for empty list item since it might be treated as `break` node\n            // by [doc-printer](https://github.com/prettier/prettier/blob/1.10.2/src/doc/doc-printer.js#L395-L405),\n            // we don't want to preserve unnecessary trailing spaces.\n\n\n  // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split\n\n\n  // for markdown codeblock\n\n\n  // for markdown whitespace: \"\\n\" and \" \" are considered the same\n\n\n"
    },
    "3": {
        "bug_file": "src/doc/doc-printer.js",
        "compressed": "YES",
        "line_numbers": 508,
        "compressed_line_numbers": 71,
        "compressed_bug_file_content": "\n\n      /* istanbul ignore next */\n\n\n            // fallthrough\n\n\n  // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n\n            // fallthrough\n\n\n                // Expanded states are a rare case where a document\n                // can manually provide multiple representations of\n                // itself. It provides an array of documents\n                // going from the least expanded (most flattened)\n                // representation first to the most expanded. If a\n                // group has these, we need to manually go through\n                // these states and find the first one that fits.\n\n\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n\n          // At this point we've handled the first pair (context, separator)\n          // and will create a new fill doc for the rest of the content.\n          // Ideally we wouldn't mutate the array here but coping all the\n          // elements to a new array would make this algorithm quadratic,\n          // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n\n\n            // fallthrough\n\n\n                  // Trim whitespace at the end of line\n\n\n                      // preserve markdown's `break` node (two trailing spaces)\n\n\n"
    },
    "4": {
        "bug_file": "src/main/parser.js",
        "compressed": "NO",
        "line_numbers": 94,
        "compressed_line_numbers": 94,
        "compressed_bug_file_content": "\"use strict\";\n\nconst path = require(\"path\");\nconst ConfigError = require(\"../common/errors\").ConfigError;\nconst js = require(\"../language-js/index.js\");\n\nconst locStart = js.locStart;\nconst locEnd = js.locEnd;\n\nfunction getParsers(options) {\n  return options.plugins.reduce(\n    (parsers, plugin) => Object.assign({}, parsers, plugin.parsers),\n    {}\n  );\n}\n\nfunction resolveParser(opts, parsers) {\n  parsers = parsers || getParsers(opts);\n\n  if (typeof opts.parser === \"function\") {\n    // Custom parser API always works with JavaScript.\n    return {\n      parse: opts.parser,\n      astFormat: \"estree\",\n      locStart,\n      locEnd\n    };\n  }\n\n  if (typeof opts.parser === \"string\") {\n    if (parsers.hasOwnProperty(opts.parser)) {\n      return parsers[opts.parser];\n    }\n    try {\n      return {\n        parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),\n        astFormat: \"estree\",\n        locStart,\n        locEnd\n      };\n    } catch (err) {\n      /* istanbul ignore next */\n      throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);\n    }\n  }\n  /* istanbul ignore next */\n  return parsers.babylon;\n}\n\nfunction parse(text, opts) {\n  const parsers = getParsers(opts);\n\n  // Copy the \"parse\" function from parser to a new object whose values are\n  // functions. Use defineProperty()/getOwnPropertyDescriptor() such that we\n  // don't invoke the parser.parse getters.\n  const parsersForCustomParserApi = Object.keys(parsers).reduce(\n    (object, parserName) =>\n      Object.defineProperty(\n        object,\n        parserName,\n        Object.getOwnPropertyDescriptor(parsers[parserName], \"parse\")\n      ),\n    {}\n  );\n\n  const parser = resolveParser(opts, parsers);\n\n  try {\n    if (parser.preprocess) {\n      text = parser.preprocess(text, opts);\n    }\n\n    return {\n      text,\n      ast: parser.parse(text, parsersForCustomParserApi, opts)\n    };\n  } catch (error) {\n    const loc = error.loc;\n\n    if (loc) {\n      const codeFrame = require(\"@babel/code-frame\");\n      error.codeFrame = codeFrame.codeFrameColumns(text, loc, {\n        highlightCode: true\n      });\n      error.message += \"\\n\" + error.codeFrame;\n      throw error;\n    }\n\n    /* istanbul ignore next */\n    throw error.stack;\n  }\n}\n\nmodule.exports = { parse, resolveParser };"
    },
    "5": {
        "bug_file": "src/main/multiparser.js",
        "compressed": "NO",
        "line_numbers": 39,
        "compressed_line_numbers": 39,
        "compressed_bug_file_content": "\"use strict\";\n\nconst normalize = require(\"./options\").normalize;\nconst comments = require(\"./comments\");\n\nfunction printSubtree(path, print, options) {\n  if (options.printer.embed) {\n    return options.printer.embed(\n      path,\n      print,\n      (text, partialNextOptions) =>\n        textToDoc(text, partialNextOptions, options),\n      options\n    );\n  }\n}\n\nfunction textToDoc(text, partialNextOptions, parentOptions) {\n  const nextOptions = normalize(\n    Object.assign({}, parentOptions, partialNextOptions, {\n      parentParser: parentOptions.parser,\n      originalText: text\n    }),\n    { passThrough: true, inferParser: false }\n  );\n\n  const result = require(\"./parser\").parse(text, nextOptions);\n  const ast = result.ast;\n  text = result.text;\n\n  const astComments = ast.comments;\n  delete ast.comments;\n  comments.attach(astComments, ast, text, nextOptions);\n  return require(\"./ast-to-doc\")(ast, nextOptions);\n}\n\nmodule.exports = {\n  printSubtree\n};"
    },
    "6": {
        "bug_file": "src/main/options.js",
        "compressed": "NO",
        "line_numbers": 120,
        "compressed_line_numbers": 120,
        "compressed_bug_file_content": "\"use strict\";\n\nconst path = require(\"path\");\nconst getSupportInfo = require(\"../common/support\").getSupportInfo;\nconst normalizer = require(\"./options-normalizer\");\nconst loadPlugins = require(\"../common/load-plugins\");\nconst resolveParser = require(\"./parser\").resolveParser;\nconst getPlugin = require(\"./get-plugin\");\n\nconst hiddenDefaults = {\n  astFormat: \"estree\",\n  printer: {},\n  locStart: null,\n  locEnd: null\n};\n\n// Copy options and fill in default values.\nfunction normalize(options, opts) {\n  opts = opts || {};\n\n  const rawOptions = Object.assign({}, options);\n\n  const plugins = loadPlugins(rawOptions.plugins);\n  rawOptions.plugins = plugins;\n\n  const supportOptions = getSupportInfo(null, {\n    plugins,\n    pluginsLoaded: true,\n    showUnreleased: true,\n    showDeprecated: true\n  }).options;\n  const defaults = supportOptions.reduce(\n    (reduced, optionInfo) =>\n      Object.assign(reduced, { [optionInfo.name]: optionInfo.default }),\n    Object.assign({}, hiddenDefaults)\n  );\n\n  if (opts.inferParser !== false) {\n    if (\n      rawOptions.filepath &&\n      (!rawOptions.parser || rawOptions.parser === defaults.parser)\n    ) {\n      const inferredParser = inferParser(\n        rawOptions.filepath,\n        rawOptions.plugins\n      );\n      if (inferredParser) {\n        rawOptions.parser = inferredParser;\n      }\n    }\n  }\n\n  const parser = resolveParser(\n    !rawOptions.parser\n      ? rawOptions\n      : // handle deprecated parsers\n        normalizer.normalizeApiOptions(\n          rawOptions,\n          [supportOptions.find(x => x.name === \"parser\")],\n          { passThrough: true, logger: false }\n        )\n  );\n  rawOptions.astFormat = parser.astFormat;\n  rawOptions.locEnd = parser.locEnd;\n  rawOptions.locStart = parser.locStart;\n\n  const plugin = getPlugin(rawOptions);\n  rawOptions.printer = plugin.printers[rawOptions.astFormat];\n\n  const pluginDefaults = supportOptions\n    .filter(\n      optionInfo =>\n        optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name]\n    )\n    .reduce(\n      (reduced, optionInfo) =>\n        Object.assign(reduced, {\n          [optionInfo.name]: optionInfo.pluginDefaults[plugin.name]\n        }),\n      {}\n    );\n\n  const mixedDefaults = Object.assign({}, defaults, pluginDefaults);\n\n  Object.keys(mixedDefaults).forEach(k => {\n    if (rawOptions[k] == null) {\n      rawOptions[k] = mixedDefaults[k];\n    }\n  });\n\n  if (rawOptions.parser === \"json\") {\n    rawOptions.trailingComma = \"none\";\n  }\n\n  return normalizer.normalizeApiOptions(\n    rawOptions,\n    supportOptions,\n    Object.assign({ passThrough: Object.keys(hiddenDefaults) }, opts)\n  );\n}\n\nfunction inferParser(filepath, plugins) {\n  const extension = path.extname(filepath);\n  const filename = path.basename(filepath).toLowerCase();\n\n  const language = getSupportInfo(null, {\n    plugins,\n    pluginsLoaded: true\n  }).languages.find(\n    language =>\n      language.since !== null &&\n      (language.extensions.indexOf(extension) > -1 ||\n        (language.filenames &&\n          language.filenames.find(name => name.toLowerCase() === filename)))\n  );\n\n  return language && language.parsers[0];\n}\n\nmodule.exports = { normalize, hiddenDefaults };"
    },
    "7": {
        "bug_file": "src/config/resolve-config.js",
        "compressed": "NO",
        "line_numbers": 129,
        "compressed_line_numbers": 129,
        "compressed_bug_file_content": "\"use strict\";\n\nconst thirdParty = require(\"../common/third-party\");\nconst minimatch = require(\"minimatch\");\nconst path = require(\"path\");\nconst mem = require(\"mem\");\n\nconst resolveEditorConfig = require(\"./resolve-config-editorconfig\");\n\nconst getExplorerMemoized = mem(opts =>\n  thirdParty.cosmiconfig(\"prettier\", {\n    sync: opts.sync,\n    cache: opts.cache,\n    rcExtensions: true,\n    transform: result => {\n      if (result && result.config) {\n        delete result.config.$schema;\n      }\n      return result;\n    }\n  })\n);\n\n/** @param {{ cache: boolean, sync: boolean }} opts */\nfunction getLoadFunction(opts) {\n  // Normalize opts before passing to a memoized function\n  opts = Object.assign({ sync: false, cache: false }, opts);\n  return getExplorerMemoized(opts).load;\n}\n\nfunction _resolveConfig(filePath, opts, sync) {\n  opts = Object.assign({ useCache: true }, opts);\n  const loadOpts = {\n    cache: !!opts.useCache,\n    sync: !!sync,\n    editorconfig: !!opts.editorconfig\n  };\n  const load = getLoadFunction(loadOpts);\n  const loadEditorConfig = resolveEditorConfig.getLoadFunction(loadOpts);\n  const arr = [load, loadEditorConfig].map(l => l(filePath, opts.config));\n\n  const unwrapAndMerge = arr => {\n    const result = arr[0];\n    const editorConfigured = arr[1];\n    const merged = Object.assign(\n      {},\n      editorConfigured,\n      mergeOverrides(Object.assign({}, result), filePath)\n    );\n\n    if (!result && !editorConfigured) {\n      return null;\n    }\n\n    return merged;\n  };\n\n  if (loadOpts.sync) {\n    return unwrapAndMerge(arr);\n  }\n\n  return Promise.all(arr).then(unwrapAndMerge);\n}\n\nconst resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);\n\nresolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);\n\nfunction clearCache() {\n  mem.clear(getExplorerMemoized);\n  resolveEditorConfig.clearCache();\n}\n\nfunction resolveConfigFile(filePath) {\n  const load = getLoadFunction({ sync: false });\n  return load(filePath).then(result => {\n    return result ? result.filepath : null;\n  });\n}\n\nresolveConfigFile.sync = filePath => {\n  const load = getLoadFunction({ sync: true });\n  const result = load(filePath);\n  return result ? result.filepath : null;\n};\n\nfunction mergeOverrides(configResult, filePath) {\n  const options = Object.assign({}, configResult.config);\n  if (filePath && options.overrides) {\n    const relativeFilePath = path.relative(\n      path.dirname(configResult.filepath),\n      filePath\n    );\n    for (const override of options.overrides) {\n      if (\n        pathMatchesGlobs(\n          relativeFilePath,\n          override.files,\n          override.excludeFiles\n        )\n      ) {\n        Object.assign(options, override.options);\n      }\n    }\n  }\n\n  delete options.overrides;\n  return options;\n}\n\n// Based on eslint: https://github.com/eslint/eslint/blob/master/lib/config/config-ops.js\nfunction pathMatchesGlobs(filePath, patterns, excludedPatterns) {\n  const patternList = [].concat(patterns);\n  const excludedPatternList = [].concat(excludedPatterns || []);\n  const opts = { matchBase: true };\n\n  return (\n    patternList.some(pattern => minimatch(filePath, pattern, opts)) &&\n    !excludedPatternList.some(excludedPattern =>\n      minimatch(filePath, excludedPattern, opts)\n    )\n  );\n}\n\nmodule.exports = {\n  resolveConfig,\n  resolveConfigFile,\n  clearCache\n};"
    }
}