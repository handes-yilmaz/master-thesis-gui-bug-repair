{
    ".codecov.yml": {},
    ".editorconfig": {},
    ".eslintignore": {},
    ".eslintrc.yml": {},
    ".flowconfig": {},
    ".gitattributes": {},
    ".gitignore": {},
    ".ignore": {},
    ".pre-commit-hooks.yaml": {},
    ".prettierignore": {},
    ".prettierrc": {},
    ".yarnrc": {},
    "CHANGELOG.md": {},
    "CODE_OF_CONDUCT.md": {},
    "CONTRIBUTING.md": {},
    "LICENSE": {},
    "README.md": {},
    "commands.md": {},
    "cspell.json": {},
    "index.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "module.exports = require(\"./src/index\");"
        ]
    },
    "jest.config.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "const installPrettier = require(\"./scripts/install-prettier\");",
            "",
            "const ENABLE_CODE_COVERAGE = !!process.env.ENABLE_CODE_COVERAGE;",
            "if (process.env.NODE_ENV === \"production\" || process.env.INSTALL_PACKAGE) {",
            "  process.env.PRETTIER_DIR = installPrettier();",
            "}",
            "",
            "module.exports = {",
            "  setupFiles: [\"<rootDir>/tests_config/run_spec.js\"],",
            "  snapshotSerializers: [",
            "    \"jest-snapshot-serializer-raw\",",
            "    \"jest-snapshot-serializer-ansi\",",
            "  ],",
            "  testRegex: \"jsfmt\\\\.spec\\\\.js$|__tests__/.*\\\\.js$\",",
            "  collectCoverage: ENABLE_CODE_COVERAGE,",
            "  collectCoverageFrom: [\"src/**/*.js\", \"index.js\", \"!<rootDir>/node_modules/\"],",
            "  coveragePathIgnorePatterns: [",
            "    \"<rootDir>/standalone.js\",",
            "    \"<rootDir>/src/document/doc-debug.js\",",
            "    \"<rootDir>/src/main/massage-ast.js\",",
            "  ],",
            "  coverageReporters: [\"text\", \"lcov\"],",
            "  moduleNameMapper: {",
            "    \"prettier/local\": \"<rootDir>/tests_config/require_prettier.js\",",
            "    \"prettier/standalone\": \"<rootDir>/tests_config/require_standalone.js\",",
            "  },",
            "  testEnvironment: \"node\",",
            "  transform: {},",
            "  watchPlugins: [",
            "    \"jest-watch-typeahead/filename\",",
            "    \"jest-watch-typeahead/testname\",",
            "  ],",
            "};"
        ]
    },
    "netlify.toml": {},
    "package.json": {},
    "standalone.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "module.exports = require(\"./src/standalone\");"
        ]
    },
    "tsconfig.json": {},
    "yarn.lock": {},
    "bin": {
        "prettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "#!/usr/bin/env node",
                "",
                "\"use strict\";",
                "",
                "require(\"../src/cli\").run(process.argv.slice(2));"
            ]
        }
    },
    "changelog_unreleased": {
        "TEMPLATE.md": {},
        "blog-post-intro.md": {},
        "angular": {
            ".gitkeep": {},
            "pr-8253.md": {},
            "pr-8254.md": {}
        },
        "api": {
            ".gitkeep": {},
            "pr-8390.md": {}
        },
        "cli": {
            ".gitkeep": {},
            "pr-8098.md": {}
        },
        "css": {
            ".gitkeep": {},
            "pr-7009.md": {},
            "pr-7592.md": {},
            "pr-7844.md": {}
        },
        "flow": {
            ".gitkeep": {},
            "pr-8365.md": {}
        },
        "graphql": {
            ".gitkeep": {},
            "pr-7721.md": {},
            "pr-8006.md": {},
            "pr-8007.md": {}
        },
        "handlebars": {
            ".gitkeep": {},
            "pr-8375.md": {}
        },
        "html": {
            ".gitkeep": {},
            "pr-8013.md": {},
            "pr-8137.md": {},
            "pr-8173.md": {},
            "pr-8275.md": {},
            "pr-8359.md": {},
            "pr-8371.md": {},
            "pr-8381.md": {}
        },
        "javascript": {
            ".gitkeep": {},
            "pr-6319.md": {},
            "pr-7875.md": {},
            "pr-7889.md": {},
            "pr-8069.md": {},
            "pr-8097.md": {},
            "pr-8111.md": {},
            "pr-8160.md": {},
            "pr-8255.md": {},
            "pr-8312.md": {},
            "pr-8376.md": {},
            "pr-8410.md": {},
            "pr-8419.md": {},
            "pr-8431.md": {},
            "pr-8436.md": {},
            "pr-8453.md": {},
            "pr-8461.md": {},
            "pr-8476.md": {},
            "pr-8491.md": {}
        },
        "json": {
            ".gitkeep": {}
        },
        "less": {
            ".gitkeep": {},
            "pr-8178.md": {},
            "pr-8360.md": {}
        },
        "lwc": {
            ".gitkeep": {}
        },
        "markdown": {
            ".gitkeep": {},
            "pr-8511.md": {}
        },
        "mdx": {
            ".gitkeep": {}
        },
        "scss": {
            ".gitkeep": {},
            "pr-8366.md": {}
        },
        "typescript": {
            ".gitkeep": {},
            "pr-8046.md": {},
            "pr-8422.md": {},
            "pr-8450.md": {}
        },
        "vue": {
            ".gitkeep": {},
            "pr-8023.md": {},
            "pr-8153.md": {},
            "pr-8280.md": {},
            "pr-8325.md": {},
            "pr-8326.md": {},
            "pr-8337.md": {}
        },
        "yaml": {
            ".gitkeep": {},
            "pr-8355.md": {},
            "pr-8356.md": {},
            "pr-8386.md": {}
        }
    },
    "src": {
        "index.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const { version } = require(\"../package.json\");",
                "",
                "const core = require(\"./main/core\");",
                "const { getSupportInfo } = require(\"./main/support\");",
                "const getFileInfo = require(\"./common/get-file-info\");",
                "const sharedUtil = require(\"./common/util-shared\");",
                "const plugins = require(\"./common/load-plugins\");",
                "const config = require(\"./config/resolve-config\");",
                "const doc = require(\"./document\");",
                "",
                "function _withPlugins(",
                "  fn,",
                "  optsArgIdx = 1 // Usually `opts` is the 2nd argument",
                ") {",
                "  return (...args) => {",
                "    const opts = args[optsArgIdx] || {};",
                "    args[optsArgIdx] = {",
                "      ...opts,",
                "      plugins: plugins.loadPlugins(opts.plugins, opts.pluginSearchDirs),",
                "    };",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "function withPlugins(fn, optsArgIdx) {",
                "  const resultingFn = _withPlugins(fn, optsArgIdx);",
                "  if (fn.sync) {",
                "    // @ts-ignore",
                "    resultingFn.sync = _withPlugins(fn.sync, optsArgIdx);",
                "  }",
                "  return resultingFn;",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "module.exports = {",
                "  formatWithCursor,",
                "",
                "  format(text, opts) {",
                "    return formatWithCursor(text, opts).formatted;",
                "  },",
                "",
                "  check(text, opts) {",
                "    const { formatted } = formatWithCursor(text, opts);",
                "    return formatted === text;",
                "  },",
                "",
                "  doc,",
                "",
                "  resolveConfig: config.resolveConfig,",
                "  resolveConfigFile: config.resolveConfigFile,",
                "  clearConfigCache() {",
                "    config.clearCache();",
                "    plugins.clearCache();",
                "  },",
                "",
                "  getFileInfo: /** @type {typeof getFileInfo} */ (withPlugins(getFileInfo)),",
                "  getSupportInfo: /** @type {typeof getSupportInfo} */ (withPlugins(",
                "    getSupportInfo,",
                "    0",
                "  )),",
                "",
                "  version,",
                "",
                "  util: sharedUtil,",
                "",
                "  // Internal shared",
                "  __internal: {",
                "    errors: require(\"./common/errors\"),",
                "    coreOptions: require(\"./main/core-options\"),",
                "    createIgnorer: require(\"./common/create-ignorer\"),",
                "    optionsModule: require(\"./main/options\"),",
                "    optionsNormalizer: require(\"./main/options-normalizer\"),",
                "    utils: {",
                "      arrayify: require(\"./utils/arrayify\"),",
                "    },",
                "  },",
                "",
                "  /* istanbul ignore next */",
                "  __debug: {",
                "    parse: withPlugins(core.parse),",
                "    formatAST: withPlugins(core.formatAST),",
                "    formatDoc: withPlugins(core.formatDoc),",
                "    printToDoc: withPlugins(core.printToDoc),",
                "    printDocToString: withPlugins(core.printDocToString),",
                "  },",
                "};"
            ]
        },
        "standalone.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const { version } = require(\"../package.json\");",
                "",
                "const core = require(\"./main/core\");",
                "const { getSupportInfo } = require(\"./main/support\");",
                "const sharedUtil = require(\"./common/util-shared\");",
                "",
                "const doc = require(\"./document\");",
                "",
                "const internalPlugins = [",
                "  require(\"./language-css\"),",
                "  require(\"./language-graphql\"),",
                "  require(\"./language-handlebars\"),",
                "  require(\"./language-html\"),",
                "  require(\"./language-js\"),",
                "  require(\"./language-markdown\"),",
                "  require(\"./language-yaml\"),",
                "];",
                "",
                "function withPlugins(",
                "  fn,",
                "  optsArgIdx = 1 // Usually `opts` is the 2nd argument",
                ") {",
                "  return (...args) => {",
                "    const opts = args[optsArgIdx] || {};",
                "    const plugins = opts.plugins || [];",
                "",
                "    args[optsArgIdx] = {",
                "      ...opts,",
                "      plugins: [",
                "        ...internalPlugins,",
                "        ...(Array.isArray(plugins) ? plugins : Object.values(plugins)),",
                "      ],",
                "    };",
                "",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "module.exports = {",
                "  formatWithCursor,",
                "",
                "  format(text, opts) {",
                "    return formatWithCursor(text, opts).formatted;",
                "  },",
                "",
                "  check(text, opts) {",
                "    const { formatted } = formatWithCursor(text, opts);",
                "    return formatted === text;",
                "  },",
                "",
                "  doc,",
                "",
                "  getSupportInfo: withPlugins(getSupportInfo, 0),",
                "",
                "  version,",
                "",
                "  util: sharedUtil,",
                "",
                "  __debug: {",
                "    parse: withPlugins(core.parse),",
                "    formatAST: withPlugins(core.formatAST),",
                "    formatDoc: withPlugins(core.formatDoc),",
                "    printToDoc: withPlugins(core.printToDoc),",
                "    printDocToString: withPlugins(core.printDocToString),",
                "  },",
                "};"
            ]
        },
        "cli": {
            "constant.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { outdent } = require(\"outdent\");",
                    "const { coreOptions } = require(\"./prettier-internal\");",
                    "",
                    "const categoryOrder = [",
                    "  coreOptions.CATEGORY_OUTPUT,",
                    "  coreOptions.CATEGORY_FORMAT,",
                    "  coreOptions.CATEGORY_CONFIG,",
                    "  coreOptions.CATEGORY_EDITOR,",
                    "  coreOptions.CATEGORY_OTHER,",
                    "];",
                    "",
                    "/**",
                    " * {",
                    " *   [optionName]: {",
                    " *     // The type of the option. For 'choice', see also `choices` below.",
                    " *     // When passing a type other than the ones listed below, the option is",
                    " *     // treated as taking any string as argument, and `--option <${type}>` will",
                    " *     // be displayed in --help.",
                    " *     type: \"boolean\" | \"choice\" | \"int\" | string;",
                    " *",
                    " *     // Default value to be passed to the minimist option `default`.",
                    " *     default?: any;",
                    " *",
                    " *     // Alias name to be passed to the minimist option `alias`.",
                    " *     alias?: string;",
                    " *",
                    " *     // For grouping options by category in --help.",
                    " *     category?: string;",
                    " *",
                    " *     // Description to be displayed in --help. If omitted, the option won't be",
                    " *     // shown at all in --help (but see also `oppositeDescription` below).",
                    " *     description?: string;",
                    " *",
                    " *     // Description for `--no-${name}` to be displayed in --help. If omitted,",
                    " *     // `--no-${name}` won't be shown.",
                    " *     oppositeDescription?: string;",
                    " *",
                    " *     // Indicate if this option is simply passed to the API.",
                    " *     // true: use camelified name as the API option name.",
                    " *     // string: use this value as the API option name.",
                    " *     forwardToApi?: boolean | string;",
                    " *",
                    " *     // Indicate that a CLI flag should be an array when forwarded to the API.",
                    " *     array?: boolean;",
                    " *",
                    " *     // Specify available choices for validation. They will also be displayed",
                    " *     // in --help as <a|b|c>.",
                    " *     // Use an object instead of a string if a choice is deprecated and should",
                    " *     // be treated as `redirect` instead, or if you'd like to add description for",
                    " *     // the choice.",
                    " *     choices?: Array<",
                    " *       | string",
                    " *       | { value: string, description?: string, deprecated?: boolean, redirect?: string }",
                    " *     >;",
                    " *",
                    " *     // If the option has a value that is an exception to the regular value",
                    " *     // constraints, indicate that value here (or use a function for more",
                    " *     // flexibility).",
                    " *     exception?: ((value: any) => boolean);",
                    " *",
                    " *     // Indicate that the option is deprecated. Use a string to add an extra",
                    " *     // message to --help for the option, for example to suggest a replacement",
                    " *     // option.",
                    " *     deprecated?: true | string;",
                    " *   }",
                    " * }",
                    " *",
                    " * Note: The options below are sorted alphabetically.",
                    " */",
                    "const options = {",
                    "  check: {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    alias: \"c\",",
                    "    description: outdent`",
                    "      Check if the given files are formatted, print a human-friendly summary",
                    "      message and paths to unformatted files (see also --list-different).",
                    "    `,",
                    "  },",
                    "  color: {",
                    "    // The supports-color package (a sub sub dependency) looks directly at",
                    "    // `process.argv` for `--no-color` and such-like options. The reason it is",
                    "    // listed here is to avoid \"Ignored unknown option: --no-color\" warnings.",
                    "    // See https://github.com/chalk/supports-color/#info for more information.",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Colorize error messages.\",",
                    "    oppositeDescription: \"Do not colorize error messages.\",",
                    "  },",
                    "  config: {",
                    "    type: \"path\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).\",",
                    "    oppositeDescription: \"Do not look for a configuration file.\",",
                    "    exception: (value) => value === false,",
                    "  },",
                    "  \"config-precedence\": {",
                    "    type: \"choice\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    default: \"cli-override\",",
                    "    choices: [",
                    "      {",
                    "        value: \"cli-override\",",
                    "        description: \"CLI options take precedence over config file\",",
                    "      },",
                    "      {",
                    "        value: \"file-override\",",
                    "        description: \"Config file take precedence over CLI options\",",
                    "      },",
                    "      {",
                    "        value: \"prefer-file\",",
                    "        description: outdent`",
                    "          If a config file is found will evaluate it and ignore other CLI options.",
                    "          If no config file is found CLI options will evaluate as normal.",
                    "        `,",
                    "      },",
                    "    ],",
                    "    description:",
                    "      \"Define in which order config files and CLI options should be evaluated.\",",
                    "  },",
                    "  \"debug-benchmark\": {",
                    "    // Run the formatting benchmarks. Requires 'benchmark' module to be installed.",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-check\": {",
                    "    // Run the formatting once again on the formatted output, throw if different.",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-print-doc\": {",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-repeat\": {",
                    "    // Repeat the formatting a few times and measure the average duration.",
                    "    type: \"int\",",
                    "    default: 0,",
                    "  },",
                    "  editorconfig: {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description: \"Take .editorconfig into account when parsing configuration.\",",
                    "    oppositeDescription:",
                    "      \"Don't take .editorconfig into account when parsing configuration.\",",
                    "    default: true,",
                    "  },",
                    "  \"find-config-path\": {",
                    "    type: \"path\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Find and print the path to a configuration file for the given input file.\",",
                    "  },",
                    "  \"file-info\": {",
                    "    type: \"path\",",
                    "    description: outdent`",
                    "      Extract the following info (as JSON) for a given file path. Reported fields:",
                    "      * ignored (boolean) - true if file path is filtered by --ignore-path",
                    "      * inferredParser (string | null) - name of parser inferred from file path",
                    "    `,",
                    "  },",
                    "  help: {",
                    "    type: \"flag\",",
                    "    alias: \"h\",",
                    "    description: outdent`",
                    "      Show CLI usage, or details about the given flag.",
                    "      Example: --help write",
                    "    `,",
                    "    exception: (value) => value === \"\",",
                    "  },",
                    "  \"ignore-path\": {",
                    "    type: \"path\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    default: \".prettierignore\",",
                    "    description: \"Path to a file with patterns describing files to ignore.\",",
                    "  },",
                    "  \"list-different\": {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    alias: \"l\",",
                    "    description:",
                    "      \"Print the names of files that are different from Prettier's formatting (see also --check).\",",
                    "  },",
                    "  loglevel: {",
                    "    type: \"choice\",",
                    "    description: \"What level of logs to report.\",",
                    "    default: \"log\",",
                    "    choices: [\"silent\", \"error\", \"warn\", \"log\", \"debug\"],",
                    "  },",
                    "  \"support-info\": {",
                    "    type: \"boolean\",",
                    "    description: \"Print support information as JSON.\",",
                    "  },",
                    "  version: {",
                    "    type: \"boolean\",",
                    "    alias: \"v\",",
                    "    description: \"Print Prettier version.\",",
                    "  },",
                    "  \"with-node-modules\": {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description: \"Process files inside 'node_modules' directory.\",",
                    "  },",
                    "  write: {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    description: \"Edit files in-place. (Beware!)\",",
                    "  },",
                    "};",
                    "",
                    "const usageSummary = outdent`",
                    "  Usage: prettier [options] [file/dir/glob ...]",
                    "",
                    "  By default, output is written to stdout.",
                    "  Stdin is read if it is piped to Prettier and no files are given.",
                    "`;",
                    "",
                    "module.exports = {",
                    "  categoryOrder,",
                    "  options,",
                    "  usageSummary,",
                    "};"
                ]
            },
            "expand-patterns.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const fs = require(\"fs\");",
                    "const fastGlob = require(\"fast-glob\");",
                    "const flat = require(\"lodash/flatten\");",
                    "",
                    "/** @typedef {import('./util').Context} Context */",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "function* expandPatterns(context) {",
                    "  const cwd = process.cwd();",
                    "  const seen = new Set();",
                    "  let noResults = true;",
                    "",
                    "  for (const pathOrError of expandPatternsInternal(context)) {",
                    "    noResults = false;",
                    "    if (typeof pathOrError !== \"string\") {",
                    "      yield pathOrError;",
                    "      continue;",
                    "    }",
                    "",
                    "    const relativePath = path.relative(cwd, pathOrError);",
                    "",
                    "    // filter out duplicates",
                    "    if (seen.has(relativePath)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    seen.add(relativePath);",
                    "    yield relativePath;",
                    "  }",
                    "",
                    "  if (noResults) {",
                    "    // If there was no files and no other errors, let's yield a general error.",
                    "    yield {",
                    "      error: `No matching files. Patterns: ${context.filePatterns.join(\" \")}`,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "function* expandPatternsInternal(context) {",
                    "  // Ignores files in version control systems directories and `node_modules`",
                    "  const silentlyIgnoredDirs = {",
                    "    \".git\": true,",
                    "    \".svn\": true,",
                    "    \".hg\": true,",
                    "    node_modules: context.argv[\"with-node-modules\"] !== true,",
                    "  };",
                    "",
                    "  const globOptions = {",
                    "    dot: true,",
                    "    ignore: Object.keys(silentlyIgnoredDirs)",
                    "      .filter((dir) => silentlyIgnoredDirs[dir])",
                    "      .map((dir) => \"**/\" + dir),",
                    "  };",
                    "",
                    "  let supportedFilesGlob;",
                    "  const cwd = process.cwd();",
                    "",
                    "  /** @type {Array<{ type: 'file' | 'dir' | 'glob'; glob: string; input: string; }>} */",
                    "  const entries = [];",
                    "",
                    "  for (const pattern of context.filePatterns) {",
                    "    const absolutePath = path.resolve(cwd, pattern);",
                    "",
                    "    if (containsIgnoredPathSegment(absolutePath, cwd, silentlyIgnoredDirs)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const stat = statSafeSync(absolutePath);",
                    "    if (stat) {",
                    "      if (stat.isFile()) {",
                    "        entries.push({",
                    "          type: \"file\",",
                    "          glob: escapePathForGlob(fixWindowsSlashes(pattern)),",
                    "          input: pattern,",
                    "        });",
                    "      } else if (stat.isDirectory()) {",
                    "        entries.push({",
                    "          type: \"dir\",",
                    "          glob:",
                    "            escapePathForGlob(fixWindowsSlashes(pattern)) +",
                    "            \"/\" +",
                    "            getSupportedFilesGlob(),",
                    "          input: pattern,",
                    "        });",
                    "      }",
                    "    } else if (pattern[0] === \"!\") {",
                    "      // convert negative patterns to `ignore` entries",
                    "      globOptions.ignore.push(fixWindowsSlashes(pattern.slice(1)));",
                    "    } else {",
                    "      entries.push({",
                    "        type: \"glob\",",
                    "        glob: fixWindowsSlashes(pattern),",
                    "        input: pattern,",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  for (const { type, glob, input } of entries) {",
                    "    let result;",
                    "",
                    "    try {",
                    "      result = fastGlob.sync(glob, globOptions);",
                    "    } catch ({ message }) {",
                    "      yield { error: `${errorMessages.globError[type]}: ${input}\\n${message}` };",
                    "      continue;",
                    "    }",
                    "",
                    "    if (result.length === 0) {",
                    "      yield { error: `${errorMessages.emptyResults[type]}: \"${input}\".` };",
                    "    } else {",
                    "      yield* sortPaths(result);",
                    "    }",
                    "  }",
                    "",
                    "  function getSupportedFilesGlob() {",
                    "    if (!supportedFilesGlob) {",
                    "      const extensions = flat(",
                    "        context.languages.map((lang) => lang.extensions || [])",
                    "      );",
                    "      const filenames = flat(",
                    "        context.languages.map((lang) => lang.filenames || [])",
                    "      );",
                    "      supportedFilesGlob = `**/{${extensions",
                    "        .map((ext) => \"*\" + (ext[0] === \".\" ? ext : \".\" + ext))",
                    "        .concat(filenames)}}`;",
                    "    }",
                    "    return supportedFilesGlob;",
                    "  }",
                    "}",
                    "",
                    "const errorMessages = {",
                    "  globError: {",
                    "    file: \"Unable to resolve file\",",
                    "    dir: \"Unable to expand directory\",",
                    "    glob: \"Unable to expand glob pattern\",",
                    "  },",
                    "  emptyResults: {",
                    "    file: \"Explicitly specified file was ignored due to negative glob patterns\",",
                    "    dir: \"No supported files were found in the directory\",",
                    "    glob: \"No files matching the pattern were found\",",
                    "  },",
                    "};",
                    "",
                    "/**",
                    " * @param {string} absolutePath",
                    " * @param {string} cwd",
                    " * @param {Record<string, boolean>} ignoredDirectories",
                    " */",
                    "function containsIgnoredPathSegment(absolutePath, cwd, ignoredDirectories) {",
                    "  return path",
                    "    .relative(cwd, absolutePath)",
                    "    .split(path.sep)",
                    "    .some((dir) => ignoredDirectories[dir]);",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} paths",
                    " */",
                    "function sortPaths(paths) {",
                    "  return paths.sort((a, b) => a.localeCompare(b));",
                    "}",
                    "",
                    "/**",
                    " * Get stats of a given path.",
                    " * @param {string} filePath The path to target file.",
                    " * @returns {fs.Stats | undefined} The stats.",
                    " */",
                    "function statSafeSync(filePath) {",
                    "  try {",
                    "    return fs.statSync(filePath);",
                    "  } catch (error) {",
                    "    /* istanbul ignore next */",
                    "    if (error.code !== \"ENOENT\") {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * This function should be replaced with `fastGlob.escapePath` when these issues are fixed:",
                    " * - https://github.com/mrmlnc/fast-glob/issues/261",
                    " * - https://github.com/mrmlnc/fast-glob/issues/262",
                    " * @param {string} path",
                    " */",
                    "function escapePathForGlob(path) {",
                    "  return fastGlob",
                    "    .escapePath(",
                    "      path.replace(/\\\\/g, \"\\0\") // Workaround for fast-glob#262 (part 1)",
                    "    )",
                    "    .replace(/\\\\!/g, \"@(!)\") // Workaround for fast-glob#261",
                    "    .replace(/\\0/g, \"@(\\\\\\\\)\"); // Workaround for fast-glob#262 (part 2)",
                    "}",
                    "",
                    "const isWindows = path.sep === \"\\\\\";",
                    "",
                    "/**",
                    " * Using backslashes in globs is probably not okay, but not accepting",
                    " * backslashes as path separators on Windows is even more not okay.",
                    " * https://github.com/prettier/prettier/pull/6776#discussion_r380723717",
                    " * https://github.com/mrmlnc/fast-glob#how-to-write-patterns-on-windows",
                    " * @param {string} pattern",
                    " */",
                    "function fixWindowsSlashes(pattern) {",
                    "  return isWindows ? pattern.replace(/\\\\/g, \"/\") : pattern;",
                    "}",
                    "",
                    "module.exports = {",
                    "  expandPatterns,",
                    "  fixWindowsSlashes,",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "require(\"please-upgrade-node\")(require(\"../../package.json\"));",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index\");",
                    "const stringify = require(\"json-stable-stringify\");",
                    "const util = require(\"./util\");",
                    "",
                    "function run(args) {",
                    "  const context = util.createContext(args);",
                    "",
                    "  try {",
                    "    util.initContext(context);",
                    "",
                    "    context.logger.debug(`normalized argv: ${JSON.stringify(context.argv)}`);",
                    "",
                    "    if (context.argv.check && context.argv[\"list-different\"]) {",
                    "      context.logger.error(\"Cannot use --check and --list-different together.\");",
                    "      process.exit(1);",
                    "    }",
                    "",
                    "    if (context.argv.write && context.argv[\"debug-check\"]) {",
                    "      context.logger.error(\"Cannot use --write and --debug-check together.\");",
                    "      process.exit(1);",
                    "    }",
                    "",
                    "    if (context.argv[\"find-config-path\"] && context.filePatterns.length) {",
                    "      context.logger.error(\"Cannot use --find-config-path with multiple files\");",
                    "      process.exit(1);",
                    "    }",
                    "",
                    "    if (context.argv[\"file-info\"] && context.filePatterns.length) {",
                    "      context.logger.error(\"Cannot use --file-info with multiple files\");",
                    "      process.exit(1);",
                    "    }",
                    "",
                    "    if (context.argv.version) {",
                    "      context.logger.log(prettier.version);",
                    "      process.exit(0);",
                    "    }",
                    "",
                    "    if (context.argv.help !== undefined) {",
                    "      context.logger.log(",
                    "        typeof context.argv.help === \"string\" && context.argv.help !== \"\"",
                    "          ? util.createDetailedUsage(context, context.argv.help)",
                    "          : util.createUsage(context)",
                    "      );",
                    "      process.exit(0);",
                    "    }",
                    "",
                    "    if (context.argv[\"support-info\"]) {",
                    "      context.logger.log(",
                    "        prettier.format(stringify(prettier.getSupportInfo()), {",
                    "          parser: \"json\",",
                    "        })",
                    "      );",
                    "      process.exit(0);",
                    "    }",
                    "",
                    "    const hasFilePatterns = context.filePatterns.length !== 0;",
                    "    const useStdin =",
                    "      !hasFilePatterns &&",
                    "      (!process.stdin.isTTY || context.args[\"stdin-filepath\"]);",
                    "",
                    "    if (context.argv[\"find-config-path\"]) {",
                    "      util.logResolvedConfigPathOrDie(context);",
                    "    } else if (context.argv[\"file-info\"]) {",
                    "      util.logFileInfoOrDie(context);",
                    "    } else if (useStdin) {",
                    "      util.formatStdin(context);",
                    "    } else if (hasFilePatterns) {",
                    "      util.formatFiles(context);",
                    "    } else {",
                    "      context.logger.log(util.createUsage(context));",
                    "      process.exit(1);",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.message);",
                    "    process.exit(1);",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  run,",
                    "};"
                ]
            },
            "is-tty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { isCI } = require(\"../common/third-party\");",
                    "",
                    "// Some CI pipelines incorrectly report process.stdout.isTTY status,",
                    "// which causes unwanted lines in the output. An additional check for isCI() helps.",
                    "// See https://github.com/prettier/prettier/issues/5801",
                    "module.exports = function isTTY() {",
                    "  return process.stdout.isTTY && !isCI();",
                    "};"
                ]
            },
            "minimist.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const minimist = require(\"minimist\");",
                    "const fromPairs = require(\"lodash/fromPairs\");",
                    "",
                    "const PLACEHOLDER = null;",
                    "",
                    "/**",
                    " * unspecified boolean flag without default value is parsed as `undefined` instead of `false`",
                    " */",
                    "module.exports = function (args, options) {",
                    "  const boolean = options.boolean || [];",
                    "  const defaults = options.default || {};",
                    "",
                    "  const booleanWithoutDefault = boolean.filter((key) => !(key in defaults));",
                    "  const newDefaults = {",
                    "    ...defaults,",
                    "    ...fromPairs(booleanWithoutDefault.map((key) => [key, PLACEHOLDER])),",
                    "  };",
                    "",
                    "  const parsed = minimist(args, { ...options, default: newDefaults });",
                    "",
                    "  return fromPairs(",
                    "    Object.entries(parsed).filter(([, value]) => value !== PLACEHOLDER)",
                    "  );",
                    "};"
                ]
            },
            "prettier-internal.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "module.exports = require(\"../index\").__internal;"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const camelCase = require(\"camelcase\");",
                    "const dashify = require(\"dashify\");",
                    "const fs = require(\"fs\");",
                    "",
                    "const chalk = require(\"chalk\");",
                    "const readline = require(\"readline\");",
                    "const stringify = require(\"json-stable-stringify\");",
                    "const fromPairs = require(\"lodash/fromPairs\");",
                    "const pick = require(\"lodash/pick\");",
                    "const groupBy = require(\"lodash/groupBy\");",
                    "const flat = require(\"lodash/flatten\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { getStream } = require(\"../common/third-party\");",
                    "const {",
                    "  createIgnorer,",
                    "  errors,",
                    "  coreOptions,",
                    "  optionsModule,",
                    "  optionsNormalizer,",
                    "  utils: { arrayify },",
                    "} = require(\"./prettier-internal\");",
                    "",
                    "const minimist = require(\"./minimist\");",
                    "const { expandPatterns, fixWindowsSlashes } = require(\"./expand-patterns\");",
                    "const constant = require(\"./constant\");",
                    "const isTTY = require(\"./is-tty\");",
                    "",
                    "const OPTION_USAGE_THRESHOLD = 25;",
                    "const CHOICE_USAGE_MARGIN = 3;",
                    "const CHOICE_USAGE_INDENTATION = 2;",
                    "",
                    "function getOptions(argv, detailedOptions) {",
                    "  return fromPairs(",
                    "    detailedOptions",
                    "      .filter(({ forwardToApi }) => forwardToApi)",
                    "      .map(({ forwardToApi, name }) => [forwardToApi, argv[name]])",
                    "  );",
                    "}",
                    "",
                    "function cliifyOptions(object, apiDetailedOptionMap) {",
                    "  return Object.keys(object || {}).reduce((output, key) => {",
                    "    const apiOption = apiDetailedOptionMap[key];",
                    "    const cliKey = apiOption ? apiOption.name : key;",
                    "",
                    "    output[dashify(cliKey)] = object[key];",
                    "    return output;",
                    "  }, {});",
                    "}",
                    "",
                    "function diff(a, b) {",
                    "  return require(\"diff\").createTwoFilesPatch(\"\", \"\", a, b, \"\", \"\", {",
                    "    context: 2,",
                    "  });",
                    "}",
                    "",
                    "function handleError(context, filename, error) {",
                    "  if (error instanceof errors.UndefinedParserError) {",
                    "    if (context.argv.write && isTTY()) {",
                    "      readline.clearLine(process.stdout, 0);",
                    "      readline.cursorTo(process.stdout, 0, null);",
                    "    }",
                    "    if (!context.argv.check && !context.argv[\"list-different\"]) {",
                    "      process.exitCode = 2;",
                    "    }",
                    "    context.logger.error(error.message);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.write) {",
                    "    // Add newline to split errors from filename line.",
                    "    process.stdout.write(\"\\n\");",
                    "  }",
                    "",
                    "  const isParseError = Boolean(error && error.loc);",
                    "  const isValidationError = /^Invalid \\S+ value\\./.test(error && error.message);",
                    "",
                    "  if (isParseError) {",
                    "    // `invalid.js: SyntaxError: Unexpected token (1:1)`.",
                    "    context.logger.error(`${filename}: ${String(error)}`);",
                    "  } else if (isValidationError || error instanceof errors.ConfigError) {",
                    "    // `Invalid printWidth value. Expected an integer, but received 0.5.`",
                    "    context.logger.error(error.message);",
                    "    // If validation fails for one file, it will fail for all of them.",
                    "    process.exit(1);",
                    "  } else if (error instanceof errors.DebugError) {",
                    "    // `invalid.js: Some debug error message`",
                    "    context.logger.error(`${filename}: ${error.message}`);",
                    "  } else {",
                    "    // `invalid.js: Error: Some unexpected error\\n[stack trace]`",
                    "    context.logger.error(filename + \": \" + (error.stack || error));",
                    "  }",
                    "",
                    "  // Don't exit the process if one file failed",
                    "  process.exitCode = 2;",
                    "}",
                    "",
                    "function logResolvedConfigPathOrDie(context) {",
                    "  const configFile = prettier.resolveConfigFile.sync(",
                    "    context.argv[\"find-config-path\"]",
                    "  );",
                    "  if (configFile) {",
                    "    context.logger.log(path.relative(process.cwd(), configFile));",
                    "  } else {",
                    "    process.exit(1);",
                    "  }",
                    "}",
                    "",
                    "function logFileInfoOrDie(context) {",
                    "  const options = {",
                    "    ignorePath: context.argv[\"ignore-path\"],",
                    "    withNodeModules: context.argv[\"with-node-modules\"],",
                    "    plugins: context.argv.plugin,",
                    "    pluginSearchDirs: context.argv[\"plugin-search-dir\"],",
                    "  };",
                    "  context.logger.log(",
                    "    prettier.format(",
                    "      stringify(prettier.getFileInfo.sync(context.argv[\"file-info\"], options)),",
                    "      { parser: \"json\" }",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function writeOutput(context, result, options) {",
                    "  // Don't use `console.log` here since it adds an extra newline at the end.",
                    "  process.stdout.write(",
                    "    context.argv[\"debug-check\"] ? result.filepath : result.formatted",
                    "  );",
                    "",
                    "  if (options && options.cursorOffset >= 0) {",
                    "    process.stderr.write(result.cursorOffset + \"\\n\");",
                    "  }",
                    "}",
                    "",
                    "function listDifferent(context, input, options, filename) {",
                    "  if (!context.argv.check && !context.argv[\"list-different\"]) {",
                    "    return;",
                    "  }",
                    "",
                    "  try {",
                    "    if (!options.filepath && !options.parser) {",
                    "      throw new errors.UndefinedParserError(",
                    "        \"No parser and no file path given, couldn't infer a parser.\"",
                    "      );",
                    "    }",
                    "    if (!prettier.check(input, options)) {",
                    "      if (!context.argv.write) {",
                    "        context.logger.log(filename);",
                    "        process.exitCode = 1;",
                    "      }",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.message);",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function format(context, input, opt) {",
                    "  if (!opt.parser && !opt.filepath) {",
                    "    throw new errors.UndefinedParserError(",
                    "      \"No parser and no file path given, couldn't infer a parser.\"",
                    "    );",
                    "  }",
                    "",
                    "  if (context.argv[\"debug-print-doc\"]) {",
                    "    const doc = prettier.__debug.printToDoc(input, opt);",
                    "    return { formatted: prettier.__debug.formatDoc(doc) };",
                    "  }",
                    "",
                    "  if (context.argv[\"debug-check\"]) {",
                    "    const pp = prettier.format(input, opt);",
                    "    const pppp = prettier.format(pp, opt);",
                    "    if (pp !== pppp) {",
                    "      throw new errors.DebugError(",
                    "        \"prettier(input) !== prettier(prettier(input))\\n\" + diff(pp, pppp)",
                    "      );",
                    "    } else {",
                    "      const stringify = (obj) => JSON.stringify(obj, null, 2);",
                    "      const ast = stringify(",
                    "        prettier.__debug.parse(input, opt, /* massage */ true).ast",
                    "      );",
                    "      const past = stringify(",
                    "        prettier.__debug.parse(pp, opt, /* massage */ true).ast",
                    "      );",
                    "",
                    "      /* istanbul ignore next */",
                    "      if (ast !== past) {",
                    "        const MAX_AST_SIZE = 2097152; // 2MB",
                    "        const astDiff =",
                    "          ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE",
                    "            ? \"AST diff too large to render\"",
                    "            : diff(ast, past);",
                    "        throw new errors.DebugError(",
                    "          \"ast(input) !== ast(prettier(input))\\n\" +",
                    "            astDiff +",
                    "            \"\\n\" +",
                    "            diff(input, pp)",
                    "        );",
                    "      }",
                    "    }",
                    "    return { formatted: pp, filepath: opt.filepath || \"(stdin)\\n\" };",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (context.argv[\"debug-benchmark\"]) {",
                    "    let benchmark;",
                    "    try {",
                    "      benchmark = eval(\"require\")(\"benchmark\");",
                    "    } catch (err) {",
                    "      context.logger.debug(",
                    "        \"'--debug-benchmark' requires the 'benchmark' package to be installed.\"",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "    context.logger.debug(",
                    "      \"'--debug-benchmark' option found, measuring formatWithCursor with 'benchmark' module.\"",
                    "    );",
                    "    const suite = new benchmark.Suite();",
                    "    suite",
                    "      .add(\"format\", () => {",
                    "        prettier.formatWithCursor(input, opt);",
                    "      })",
                    "      .on(\"cycle\", (event) => {",
                    "        const results = {",
                    "          benchmark: String(event.target),",
                    "          hz: event.target.hz,",
                    "          ms: event.target.times.cycle * 1000,",
                    "        };",
                    "        context.logger.debug(",
                    "          \"'--debug-benchmark' measurements for formatWithCursor: \" +",
                    "            JSON.stringify(results, null, 2)",
                    "        );",
                    "      })",
                    "      .run({ async: false });",
                    "  } else if (context.argv[\"debug-repeat\"] > 0) {",
                    "    const repeat = context.argv[\"debug-repeat\"];",
                    "    context.logger.debug(",
                    "      \"'--debug-repeat' option found, running formatWithCursor \" +",
                    "        repeat +",
                    "        \" times.\"",
                    "    );",
                    "    // should be using `performance.now()`, but only `Date` is cross-platform enough",
                    "    const now = Date.now ? () => Date.now() : () => +new Date();",
                    "    let totalMs = 0;",
                    "    for (let i = 0; i < repeat; ++i) {",
                    "      const startMs = now();",
                    "      prettier.formatWithCursor(input, opt);",
                    "      totalMs += now() - startMs;",
                    "    }",
                    "    const averageMs = totalMs / repeat;",
                    "    const results = {",
                    "      repeat,",
                    "      hz: 1000 / averageMs,",
                    "      ms: averageMs,",
                    "    };",
                    "    context.logger.debug(",
                    "      \"'--debug-repeat' measurements for formatWithCursor: \" +",
                    "        JSON.stringify(results, null, 2)",
                    "    );",
                    "  }",
                    "",
                    "  return prettier.formatWithCursor(input, opt);",
                    "}",
                    "",
                    "function getOptionsOrDie(context, filePath) {",
                    "  try {",
                    "    if (context.argv.config === false) {",
                    "      context.logger.debug(",
                    "        \"'--no-config' option found, skip loading config file.\"",
                    "      );",
                    "      return null;",
                    "    }",
                    "",
                    "    context.logger.debug(",
                    "      context.argv.config",
                    "        ? `load config file from '${context.argv.config}'`",
                    "        : `resolve config from '${filePath}'`",
                    "    );",
                    "",
                    "    const options = prettier.resolveConfig.sync(filePath, {",
                    "      editorconfig: context.argv.editorconfig,",
                    "      config: context.argv.config,",
                    "    });",
                    "",
                    "    context.logger.debug(\"loaded options `\" + JSON.stringify(options) + \"`\");",
                    "    return options;",
                    "  } catch (error) {",
                    "    context.logger.error(",
                    "      `Invalid configuration file \\`${filePath}\\`: ` + error.message",
                    "    );",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "function getOptionsForFile(context, filepath) {",
                    "  const options = getOptionsOrDie(context, filepath);",
                    "",
                    "  const hasPlugins = options && options.plugins;",
                    "  if (hasPlugins) {",
                    "    pushContextPlugins(context, options.plugins);",
                    "  }",
                    "",
                    "  const appliedOptions = {",
                    "    filepath,",
                    "    ...applyConfigPrecedence(",
                    "      context,",
                    "      options &&",
                    "        optionsNormalizer.normalizeApiOptions(options, context.supportOptions, {",
                    "          logger: context.logger,",
                    "        })",
                    "    ),",
                    "  };",
                    "",
                    "  context.logger.debug(",
                    "    `applied config-precedence (${context.argv[\"config-precedence\"]}): ` +",
                    "      `${JSON.stringify(appliedOptions)}`",
                    "  );",
                    "",
                    "  if (hasPlugins) {",
                    "    popContextPlugins(context);",
                    "  }",
                    "",
                    "  return appliedOptions;",
                    "}",
                    "",
                    "function parseArgsToOptions(context, overrideDefaults) {",
                    "  const minimistOptions = createMinimistOptions(context.detailedOptions);",
                    "  const apiDetailedOptionMap = createApiDetailedOptionMap(",
                    "    context.detailedOptions",
                    "  );",
                    "  return getOptions(",
                    "    optionsNormalizer.normalizeCliOptions(",
                    "      minimist(context.args, {",
                    "        string: minimistOptions.string,",
                    "        boolean: minimistOptions.boolean,",
                    "        default: cliifyOptions(overrideDefaults, apiDetailedOptionMap),",
                    "      }),",
                    "      context.detailedOptions,",
                    "      { logger: false }",
                    "    ),",
                    "    context.detailedOptions",
                    "  );",
                    "}",
                    "",
                    "function applyConfigPrecedence(context, options) {",
                    "  try {",
                    "    switch (context.argv[\"config-precedence\"]) {",
                    "      case \"cli-override\":",
                    "        return parseArgsToOptions(context, options);",
                    "      case \"file-override\":",
                    "        return { ...parseArgsToOptions(context), ...options };",
                    "      case \"prefer-file\":",
                    "        return options || parseArgsToOptions(context);",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.toString());",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "function formatStdin(context) {",
                    "  const filepath = context.argv[\"stdin-filepath\"]",
                    "    ? path.resolve(process.cwd(), context.argv[\"stdin-filepath\"])",
                    "    : process.cwd();",
                    "",
                    "  const ignorer = createIgnorerFromContextOrDie(context);",
                    "  // If there's an ignore-path set, the filename must be relative to the",
                    "  // ignore path, not the current working directory.",
                    "  const relativeFilepath = context.argv[\"ignore-path\"]",
                    "    ? path.relative(path.dirname(context.argv[\"ignore-path\"]), filepath)",
                    "    : path.relative(process.cwd(), filepath);",
                    "",
                    "  getStream(process.stdin)",
                    "    .then((input) => {",
                    "      if (",
                    "        relativeFilepath &&",
                    "        ignorer.ignores(fixWindowsSlashes(relativeFilepath))",
                    "      ) {",
                    "        writeOutput(context, { formatted: input });",
                    "        return;",
                    "      }",
                    "",
                    "      const options = getOptionsForFile(context, filepath);",
                    "",
                    "      if (listDifferent(context, input, options, \"(stdin)\")) {",
                    "        return;",
                    "      }",
                    "",
                    "      writeOutput(context, format(context, input, options), options);",
                    "    })",
                    "    .catch((error) => {",
                    "      handleError(context, relativeFilepath || \"stdin\", error);",
                    "    });",
                    "}",
                    "",
                    "function createIgnorerFromContextOrDie(context) {",
                    "  try {",
                    "    return createIgnorer.sync(",
                    "      context.argv[\"ignore-path\"],",
                    "      context.argv[\"with-node-modules\"]",
                    "    );",
                    "  } catch (e) {",
                    "    context.logger.error(e.message);",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "function formatFiles(context) {",
                    "  // The ignorer will be used to filter file paths after the glob is checked,",
                    "  // before any files are actually written",
                    "  const ignorer = createIgnorerFromContextOrDie(context);",
                    "",
                    "  let numberOfUnformattedFilesFound = 0;",
                    "",
                    "  if (context.argv.check) {",
                    "    context.logger.log(\"Checking formatting...\");",
                    "  }",
                    "",
                    "  for (const pathOrError of expandPatterns(context)) {",
                    "    if (typeof pathOrError === \"object\") {",
                    "      context.logger.error(pathOrError.error);",
                    "      // Don't exit, but set the exit code to 2",
                    "      process.exitCode = 2;",
                    "      continue;",
                    "    }",
                    "",
                    "    const filename = pathOrError;",
                    "    // If there's an ignore-path set, the filename must be relative to the",
                    "    // ignore path, not the current working directory.",
                    "    const ignoreFilename = context.argv[\"ignore-path\"]",
                    "      ? path.relative(path.dirname(context.argv[\"ignore-path\"]), filename)",
                    "      : filename;",
                    "",
                    "    const fileIgnored = ignorer.ignores(fixWindowsSlashes(ignoreFilename));",
                    "    if (",
                    "      fileIgnored &&",
                    "      (context.argv[\"debug-check\"] ||",
                    "        context.argv.write ||",
                    "        context.argv.check ||",
                    "        context.argv[\"list-different\"])",
                    "    ) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const options = {",
                    "      ...getOptionsForFile(context, filename),",
                    "      filepath: filename,",
                    "    };",
                    "",
                    "    if (isTTY()) {",
                    "      context.logger.log(filename, { newline: false });",
                    "    }",
                    "",
                    "    let input;",
                    "    try {",
                    "      input = fs.readFileSync(filename, \"utf8\");",
                    "    } catch (error) {",
                    "      // Add newline to split errors from filename line.",
                    "      context.logger.log(\"\");",
                    "",
                    "      context.logger.error(",
                    "        `Unable to read file: ${filename}\\n${error.message}`",
                    "      );",
                    "      // Don't exit the process if one file failed",
                    "      process.exitCode = 2;",
                    "      continue;",
                    "    }",
                    "",
                    "    if (fileIgnored) {",
                    "      writeOutput(context, { formatted: input }, options);",
                    "      continue;",
                    "    }",
                    "",
                    "    const start = Date.now();",
                    "",
                    "    let result;",
                    "    let output;",
                    "",
                    "    try {",
                    "      result = format(context, input, options);",
                    "      output = result.formatted;",
                    "    } catch (error) {",
                    "      handleError(context, filename, error);",
                    "      continue;",
                    "    }",
                    "",
                    "    const isDifferent = output !== input;",
                    "",
                    "    if (isTTY()) {",
                    "      // Remove previously printed filename to log it with duration.",
                    "      readline.clearLine(process.stdout, 0);",
                    "      readline.cursorTo(process.stdout, 0, null);",
                    "    }",
                    "",
                    "    if (context.argv.write) {",
                    "      // Don't write the file if it won't change in order not to invalidate",
                    "      // mtime based caches.",
                    "      if (isDifferent) {",
                    "        if (!context.argv.check && !context.argv[\"list-different\"]) {",
                    "          context.logger.log(`${filename} ${Date.now() - start}ms`);",
                    "        }",
                    "",
                    "        try {",
                    "          fs.writeFileSync(filename, output, \"utf8\");",
                    "        } catch (error) {",
                    "          context.logger.error(",
                    "            `Unable to write file: ${filename}\\n${error.message}`",
                    "          );",
                    "          // Don't exit the process if one file failed",
                    "          process.exitCode = 2;",
                    "        }",
                    "      } else if (!context.argv.check && !context.argv[\"list-different\"]) {",
                    "        context.logger.log(`${chalk.grey(filename)} ${Date.now() - start}ms`);",
                    "      }",
                    "    } else if (context.argv[\"debug-check\"]) {",
                    "      if (result.filepath) {",
                    "        context.logger.log(result.filepath);",
                    "      } else {",
                    "        process.exitCode = 2;",
                    "      }",
                    "    } else if (!context.argv.check && !context.argv[\"list-different\"]) {",
                    "      writeOutput(context, result, options);",
                    "    }",
                    "",
                    "    if ((context.argv.check || context.argv[\"list-different\"]) && isDifferent) {",
                    "      context.logger.log(filename);",
                    "      numberOfUnformattedFilesFound += 1;",
                    "    }",
                    "  }",
                    "",
                    "  // Print check summary based on expected exit code",
                    "  if (context.argv.check) {",
                    "    context.logger.log(",
                    "      numberOfUnformattedFilesFound === 0",
                    "        ? \"All matched files use Prettier code style!\"",
                    "        : context.argv.write",
                    "        ? \"Code style issues fixed in the above file(s).\"",
                    "        : \"Code style issues found in the above file(s). Forgot to run Prettier?\"",
                    "    );",
                    "  }",
                    "",
                    "  // Ensure non-zero exitCode when using --check/list-different is not combined with --write",
                    "  if (",
                    "    (context.argv.check || context.argv[\"list-different\"]) &&",
                    "    numberOfUnformattedFilesFound > 0 &&",
                    "    !process.exitCode &&",
                    "    !context.argv.write",
                    "  ) {",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "function getOptionsWithOpposites(options) {",
                    "  // Add --no-foo after --foo.",
                    "  const optionsWithOpposites = options.map((option) => [",
                    "    option.description ? option : null,",
                    "    option.oppositeDescription",
                    "      ? {",
                    "          ...option,",
                    "          name: `no-${option.name}`,",
                    "          type: \"boolean\",",
                    "          description: option.oppositeDescription,",
                    "        }",
                    "      : null,",
                    "  ]);",
                    "  return flat(optionsWithOpposites).filter(Boolean);",
                    "}",
                    "",
                    "function createUsage(context) {",
                    "  const options = getOptionsWithOpposites(context.detailedOptions).filter(",
                    "    // remove unnecessary option (e.g. `semi`, `color`, etc.), which is only used for --help <flag>",
                    "    (option) =>",
                    "      !(",
                    "        option.type === \"boolean\" &&",
                    "        option.oppositeDescription &&",
                    "        !option.name.startsWith(\"no-\")",
                    "      )",
                    "  );",
                    "",
                    "  const groupedOptions = groupBy(options, (option) => option.category);",
                    "",
                    "  const firstCategories = constant.categoryOrder.slice(0, -1);",
                    "  const lastCategories = constant.categoryOrder.slice(-1);",
                    "  const restCategories = Object.keys(groupedOptions).filter(",
                    "    (category) => !constant.categoryOrder.includes(category)",
                    "  );",
                    "  const allCategories = [",
                    "    ...firstCategories,",
                    "    ...restCategories,",
                    "    ...lastCategories,",
                    "  ];",
                    "",
                    "  const optionsUsage = allCategories.map((category) => {",
                    "    const categoryOptions = groupedOptions[category]",
                    "      .map((option) =>",
                    "        createOptionUsage(context, option, OPTION_USAGE_THRESHOLD)",
                    "      )",
                    "      .join(\"\\n\");",
                    "    return `${category} options:\\n\\n${indent(categoryOptions, 2)}`;",
                    "  });",
                    "",
                    "  return [constant.usageSummary].concat(optionsUsage, [\"\"]).join(\"\\n\\n\");",
                    "}",
                    "",
                    "function createOptionUsage(context, option, threshold) {",
                    "  const header = createOptionUsageHeader(option);",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  return createOptionUsageRow(",
                    "    header,",
                    "    `${option.description}${",
                    "      optionDefaultValue === undefined",
                    "        ? \"\"",
                    "        : `\\nDefaults to ${createDefaultValueDisplay(optionDefaultValue)}.`",
                    "    }`,",
                    "    threshold",
                    "  );",
                    "}",
                    "",
                    "function createDefaultValueDisplay(value) {",
                    "  return Array.isArray(value)",
                    "    ? `[${value.map(createDefaultValueDisplay).join(\", \")}]`",
                    "    : value;",
                    "}",
                    "",
                    "function createOptionUsageHeader(option) {",
                    "  const name = `--${option.name}`;",
                    "  const alias = option.alias ? `-${option.alias},` : null;",
                    "  const type = createOptionUsageType(option);",
                    "  return [alias, name, type].filter(Boolean).join(\" \");",
                    "}",
                    "",
                    "function createOptionUsageRow(header, content, threshold) {",
                    "  const separator =",
                    "    header.length >= threshold",
                    "      ? `\\n${\" \".repeat(threshold)}`",
                    "      : \" \".repeat(threshold - header.length);",
                    "",
                    "  const description = content.replace(/\\n/g, `\\n${\" \".repeat(threshold)}`);",
                    "",
                    "  return `${header}${separator}${description}`;",
                    "}",
                    "",
                    "function createOptionUsageType(option) {",
                    "  switch (option.type) {",
                    "    case \"boolean\":",
                    "      return null;",
                    "    case \"choice\":",
                    "      return `<${option.choices",
                    "        .filter((choice) => !choice.deprecated && choice.since !== null)",
                    "        .map((choice) => choice.value)",
                    "        .join(\"|\")}>`;",
                    "    default:",
                    "      return `<${option.type}>`;",
                    "  }",
                    "}",
                    "",
                    "function createChoiceUsages(choices, margin, indentation) {",
                    "  const activeChoices = choices.filter(",
                    "    (choice) => !choice.deprecated && choice.since !== null",
                    "  );",
                    "  const threshold =",
                    "    activeChoices",
                    "      .map((choice) => choice.value.length)",
                    "      .reduce((current, length) => Math.max(current, length), 0) + margin;",
                    "  return activeChoices.map((choice) =>",
                    "    indent(",
                    "      createOptionUsageRow(choice.value, choice.description, threshold),",
                    "      indentation",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function createDetailedUsage(context, flag) {",
                    "  const option = getOptionsWithOpposites(context.detailedOptions).find(",
                    "    (option) => option.name === flag || option.alias === flag",
                    "  );",
                    "",
                    "  const header = createOptionUsageHeader(option);",
                    "  const description = `\\n\\n${indent(option.description, 2)}`;",
                    "",
                    "  const choices =",
                    "    option.type !== \"choice\"",
                    "      ? \"\"",
                    "      : `\\n\\nValid options:\\n\\n${createChoiceUsages(",
                    "          option.choices,",
                    "          CHOICE_USAGE_MARGIN,",
                    "          CHOICE_USAGE_INDENTATION",
                    "        ).join(\"\\n\")}`;",
                    "",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  const defaults =",
                    "    optionDefaultValue !== undefined",
                    "      ? `\\n\\nDefault: ${createDefaultValueDisplay(optionDefaultValue)}`",
                    "      : \"\";",
                    "",
                    "  const pluginDefaults =",
                    "    option.pluginDefaults && Object.keys(option.pluginDefaults).length",
                    "      ? `\\nPlugin defaults:${Object.keys(option.pluginDefaults).map(",
                    "          (key) =>",
                    "            `\\n* ${key}: ${createDefaultValueDisplay(",
                    "              option.pluginDefaults[key]",
                    "            )}`",
                    "        )}`",
                    "      : \"\";",
                    "  return `${header}${description}${choices}${defaults}${pluginDefaults}`;",
                    "}",
                    "",
                    "function getOptionDefaultValue(context, optionName) {",
                    "  // --no-option",
                    "  if (!(optionName in context.detailedOptionMap)) {",
                    "    return;",
                    "  }",
                    "",
                    "  const option = context.detailedOptionMap[optionName];",
                    "",
                    "  if (option.default !== undefined) {",
                    "    return option.default;",
                    "  }",
                    "",
                    "  const optionCamelName = camelCase(optionName);",
                    "  if (optionCamelName in context.apiDefaultOptions) {",
                    "    return context.apiDefaultOptions[optionCamelName];",
                    "  }",
                    "}",
                    "",
                    "function indent(str, spaces) {",
                    "  return str.replace(/^/gm, \" \".repeat(spaces));",
                    "}",
                    "",
                    "function createLogger(logLevel) {",
                    "  return {",
                    "    warn: createLogFunc(\"warn\", \"yellow\"),",
                    "    error: createLogFunc(\"error\", \"red\"),",
                    "    debug: createLogFunc(\"debug\", \"blue\"),",
                    "    log: createLogFunc(\"log\"),",
                    "  };",
                    "",
                    "  function createLogFunc(loggerName, color) {",
                    "    if (!shouldLog(loggerName)) {",
                    "      return () => {};",
                    "    }",
                    "",
                    "    const prefix = color ? `[${chalk[color](loggerName)}] ` : \"\";",
                    "    return function (message, opts) {",
                    "      opts = { newline: true, ...opts };",
                    "      const stream = process[loggerName === \"log\" ? \"stdout\" : \"stderr\"];",
                    "      stream.write(message.replace(/^/gm, prefix) + (opts.newline ? \"\\n\" : \"\"));",
                    "    };",
                    "  }",
                    "",
                    "  function shouldLog(loggerName) {",
                    "    switch (logLevel) {",
                    "      case \"silent\":",
                    "        return false;",
                    "      default:",
                    "        return true;",
                    "      case \"debug\":",
                    "        if (loggerName === \"debug\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"log\":",
                    "        if (loggerName === \"log\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"warn\":",
                    "        if (loggerName === \"warn\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"error\":",
                    "        return loggerName === \"error\";",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function normalizeDetailedOption(name, option) {",
                    "  return {",
                    "    category: coreOptions.CATEGORY_OTHER,",
                    "    ...option,",
                    "    choices:",
                    "      option.choices &&",
                    "      option.choices.map((choice) => {",
                    "        const newChoice = {",
                    "          description: \"\",",
                    "          deprecated: false,",
                    "          ...(typeof choice === \"object\" ? choice : { value: choice }),",
                    "        };",
                    "        if (newChoice.value === true) {",
                    "          newChoice.value = \"\"; // backward compatibility for original boolean option",
                    "        }",
                    "        return newChoice;",
                    "      }),",
                    "  };",
                    "}",
                    "",
                    "function normalizeDetailedOptionMap(detailedOptionMap) {",
                    "  return fromPairs(",
                    "    Object.entries(detailedOptionMap)",
                    "      .sort(([leftName], [rightName]) => leftName.localeCompare(rightName))",
                    "      .map(([name, option]) => [name, normalizeDetailedOption(name, option)])",
                    "  );",
                    "}",
                    "",
                    "function createMinimistOptions(detailedOptions) {",
                    "  return {",
                    "    // we use vnopts' AliasSchema to handle aliases for better error messages",
                    "    alias: {},",
                    "    boolean: detailedOptions",
                    "      .filter((option) => option.type === \"boolean\")",
                    "      .map((option) => [option.name].concat(option.alias || []))",
                    "      .reduce((a, b) => a.concat(b)),",
                    "    string: detailedOptions",
                    "      .filter((option) => option.type !== \"boolean\")",
                    "      .map((option) => [option.name].concat(option.alias || []))",
                    "      .reduce((a, b) => a.concat(b)),",
                    "    default: detailedOptions",
                    "      .filter(",
                    "        (option) =>",
                    "          !option.deprecated &&",
                    "          (!option.forwardToApi ||",
                    "            option.name === \"plugin\" ||",
                    "            option.name === \"plugin-search-dir\") &&",
                    "          option.default !== undefined",
                    "      )",
                    "      .reduce(",
                    "        (current, option) => ({ [option.name]: option.default, ...current }),",
                    "        {}",
                    "      ),",
                    "  };",
                    "}",
                    "",
                    "function createApiDetailedOptionMap(detailedOptions) {",
                    "  return fromPairs(",
                    "    detailedOptions",
                    "      .filter(",
                    "        (option) => option.forwardToApi && option.forwardToApi !== option.name",
                    "      )",
                    "      .map((option) => [option.forwardToApi, option])",
                    "  );",
                    "}",
                    "",
                    "function createDetailedOptionMap(supportOptions) {",
                    "  return fromPairs(",
                    "    supportOptions.map((option) => {",
                    "      const newOption = {",
                    "        ...option,",
                    "        name: option.cliName || dashify(option.name),",
                    "        description: option.cliDescription || option.description,",
                    "        category: option.cliCategory || coreOptions.CATEGORY_FORMAT,",
                    "        forwardToApi: option.name,",
                    "      };",
                    "",
                    "      if (option.deprecated) {",
                    "        delete newOption.forwardToApi;",
                    "        delete newOption.description;",
                    "        delete newOption.oppositeDescription;",
                    "        newOption.deprecated = true;",
                    "      }",
                    "",
                    "      return [newOption.name, newOption];",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "//-----------------------------context-util-start-------------------------------",
                    "/**",
                    " * @typedef {Object} Context",
                    " * @property logger",
                    " * @property {string[]} args",
                    " * @property argv",
                    " * @property {string[]} filePatterns",
                    " * @property {any[]} supportOptions",
                    " * @property detailedOptions",
                    " * @property detailedOptionMap",
                    " * @property apiDefaultOptions",
                    " * @property languages",
                    " * @property {Partial<Context>[]} stack",
                    " */",
                    "",
                    "/** @returns {Context} */",
                    "function createContext(args) {",
                    "  const context = { args, stack: [] };",
                    "",
                    "  updateContextArgv(context);",
                    "  normalizeContextArgv(context, [\"loglevel\", \"plugin\", \"plugin-search-dir\"]);",
                    "",
                    "  context.logger = createLogger(context.argv.loglevel);",
                    "",
                    "  updateContextArgv(",
                    "    context,",
                    "    context.argv.plugin,",
                    "    context.argv[\"plugin-search-dir\"]",
                    "  );",
                    "",
                    "  return /** @type {Context} */ (context);",
                    "}",
                    "",
                    "function initContext(context) {",
                    "  // split into 2 step so that we could wrap this in a `try..catch` in cli/index.js",
                    "  normalizeContextArgv(context);",
                    "}",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " * @param {string[]} plugins",
                    " * @param {string[]=} pluginSearchDirs",
                    " */",
                    "function updateContextOptions(context, plugins, pluginSearchDirs) {",
                    "  const { options: supportOptions, languages } = prettier.getSupportInfo({",
                    "    showDeprecated: true,",
                    "    showUnreleased: true,",
                    "    showInternal: true,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "  });",
                    "",
                    "  const detailedOptionMap = normalizeDetailedOptionMap({",
                    "    ...createDetailedOptionMap(supportOptions),",
                    "    ...constant.options,",
                    "  });",
                    "",
                    "  const detailedOptions = arrayify(detailedOptionMap, \"name\");",
                    "",
                    "  const apiDefaultOptions = {",
                    "    ...optionsModule.hiddenDefaults,",
                    "    ...fromPairs(",
                    "      supportOptions",
                    "        .filter(({ deprecated }) => !deprecated)",
                    "        .map((option) => [option.name, option.default])",
                    "    ),",
                    "  };",
                    "",
                    "  Object.assign(context, {",
                    "    supportOptions,",
                    "    detailedOptions,",
                    "    detailedOptionMap,",
                    "    apiDefaultOptions,",
                    "    languages,",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " * @param {string[]} plugins",
                    " * @param {string[]=} pluginSearchDirs",
                    " */",
                    "function pushContextPlugins(context, plugins, pluginSearchDirs) {",
                    "  context.stack.push(",
                    "    pick(context, [",
                    "      \"supportOptions\",",
                    "      \"detailedOptions\",",
                    "      \"detailedOptionMap\",",
                    "      \"apiDefaultOptions\",",
                    "      \"languages\",",
                    "    ])",
                    "  );",
                    "  updateContextOptions(context, plugins, pluginSearchDirs);",
                    "}",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "function popContextPlugins(context) {",
                    "  Object.assign(context, context.stack.pop());",
                    "}",
                    "",
                    "function updateContextArgv(context, plugins, pluginSearchDirs) {",
                    "  pushContextPlugins(context, plugins, pluginSearchDirs);",
                    "",
                    "  const minimistOptions = createMinimistOptions(context.detailedOptions);",
                    "  const argv = minimist(context.args, minimistOptions);",
                    "",
                    "  context.argv = argv;",
                    "  context.filePatterns = argv._;",
                    "}",
                    "",
                    "function normalizeContextArgv(context, keys) {",
                    "  const detailedOptions = !keys",
                    "    ? context.detailedOptions",
                    "    : context.detailedOptions.filter((option) => keys.includes(option.name));",
                    "  const argv = !keys ? context.argv : pick(context.argv, keys);",
                    "",
                    "  context.argv = optionsNormalizer.normalizeCliOptions(argv, detailedOptions, {",
                    "    logger: context.logger,",
                    "  });",
                    "}",
                    "//------------------------------context-util-end--------------------------------",
                    "",
                    "module.exports = {",
                    "  createContext,",
                    "  createDetailedOptionMap,",
                    "  createDetailedUsage,",
                    "  createUsage,",
                    "  format,",
                    "  formatFiles,",
                    "  formatStdin,",
                    "  initContext,",
                    "  logResolvedConfigPathOrDie,",
                    "  logFileInfoOrDie,",
                    "  normalizeDetailedOptionMap,",
                    "};"
                ]
            }
        },
        "common": {
            "common-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const CATEGORY_COMMON = \"Common\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print spaces between brackets.\",",
                    "    oppositeDescription: \"Do not print spaces between brackets.\",",
                    "  },",
                    "  singleQuote: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes instead of double quotes.\",",
                    "  },",
                    "  proseWrap: {",
                    "    since: \"1.8.2\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.8.2\", value: true },",
                    "      { since: \"1.9.0\", value: \"preserve\" },",
                    "    ],",
                    "    description: \"How to wrap prose.\",",
                    "    choices: [",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"always\",",
                    "        description: \"Wrap prose if it exceeds the print width.\",",
                    "      },",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"never\",",
                    "        description: \"Do not wrap prose.\",",
                    "      },",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"preserve\",",
                    "        description: \"Wrap prose as-is.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "};"
                ]
            },
            "create-ignorer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const ignore = require(\"ignore\");",
                    "const path = require(\"path\");",
                    "const getFileContentOrNull = require(\"../utils/get-file-content-or-null\");",
                    "",
                    "/**",
                    " * @param {undefined | string} ignorePath",
                    " * @param {undefined | boolean} withNodeModules",
                    " */",
                    "async function createIgnorer(ignorePath, withNodeModules) {",
                    "  const ignoreContent = ignorePath",
                    "    ? await getFileContentOrNull(path.resolve(ignorePath))",
                    "    : null;",
                    "",
                    "  return _createIgnorer(ignoreContent, withNodeModules);",
                    "}",
                    "",
                    "/**",
                    " * @param {undefined | string} ignorePath",
                    " * @param {undefined | boolean} withNodeModules",
                    " */",
                    "createIgnorer.sync = function (ignorePath, withNodeModules) {",
                    "  const ignoreContent = !ignorePath",
                    "    ? null",
                    "    : getFileContentOrNull.sync(path.resolve(ignorePath));",
                    "  return _createIgnorer(ignoreContent, withNodeModules);",
                    "};",
                    "",
                    "/**",
                    " * @param {null | string} ignoreContent",
                    " * @param {undefined | boolean} withNodeModules",
                    " */",
                    "function _createIgnorer(ignoreContent, withNodeModules) {",
                    "  const ignorer = ignore().add(ignoreContent || \"\");",
                    "  if (!withNodeModules) {",
                    "    ignorer.add(\"node_modules\");",
                    "  }",
                    "  return ignorer;",
                    "}",
                    "",
                    "module.exports = createIgnorer;"
                ]
            },
            "end-of-line.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function guessEndOfLine(text) {",
                    "  const index = text.indexOf(\"\\r\");",
                    "  if (index >= 0) {",
                    "    return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";",
                    "  }",
                    "  return \"lf\";",
                    "}",
                    "",
                    "function convertEndOfLineToChars(value) {",
                    "  switch (value) {",
                    "    case \"cr\":",
                    "      return \"\\r\";",
                    "    case \"crlf\":",
                    "      return \"\\r\\n\";",
                    "    default:",
                    "      return \"\\n\";",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "};"
                ]
            },
            "errors.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "class ConfigError extends Error {}",
                    "class DebugError extends Error {}",
                    "class UndefinedParserError extends Error {}",
                    "",
                    "module.exports = {",
                    "  ConfigError,",
                    "  DebugError,",
                    "  UndefinedParserError,",
                    "};"
                ]
            },
            "fast-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const getLast = require(\"../utils/get-last\");",
                    "",
                    "function getNodeHelper(path, count) {",
                    "  const stackIndex = getNodeStackIndexHelper(path.stack, count);",
                    "  return stackIndex === -1 ? null : path.stack[stackIndex];",
                    "}",
                    "",
                    "function getNodeStackIndexHelper(stack, count) {",
                    "  for (let i = stack.length - 1; i >= 0; i -= 2) {",
                    "    const value = stack[i];",
                    "    if (value && !Array.isArray(value) && --count < 0) {",
                    "      return i;",
                    "    }",
                    "  }",
                    "  return -1;",
                    "}",
                    "",
                    "class FastPath {",
                    "  constructor(value) {",
                    "    this.stack = [value];",
                    "  }",
                    "",
                    "  // The name of the current property is always the penultimate element of",
                    "  // this.stack, and always a String.",
                    "  getName() {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    if (length > 1) {",
                    "      return stack[length - 2];",
                    "    }",
                    "    // Since the name is always a string, null is a safe sentinel value to",
                    "    // return if we do not know the name of the (root) value.",
                    "    /* istanbul ignore next */",
                    "    return null;",
                    "  }",
                    "",
                    "  // The value of the current property is always the final element of",
                    "  // this.stack.",
                    "  getValue() {",
                    "    return getLast(this.stack);",
                    "  }",
                    "",
                    "  getNode(count = 0) {",
                    "    return getNodeHelper(this, count);",
                    "  }",
                    "",
                    "  getParentNode(count = 0) {",
                    "    return getNodeHelper(this, count + 1);",
                    "  }",
                    "",
                    "  // Temporarily push properties named by string arguments given after the",
                    "  // callback function onto this.stack, then call the callback with a",
                    "  // reference to this (modified) FastPath object. Note that the stack will",
                    "  // be restored to its original state after the callback is finished, so it",
                    "  // is probably a mistake to retain a reference to the path.",
                    "  call(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = getLast(stack);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "    const result = callback(this);",
                    "    stack.length = length;",
                    "    return result;",
                    "  }",
                    "",
                    "  callParent(callback, count = 0) {",
                    "    const stackIndex = getNodeStackIndexHelper(this.stack, count + 1);",
                    "    const parentValues = this.stack.splice(stackIndex + 1);",
                    "    const result = callback(this);",
                    "    this.stack.push(...parentValues);",
                    "    return result;",
                    "  }",
                    "",
                    "  // Similar to FastPath.prototype.call, except that the value obtained by",
                    "  // accessing this.getValue()[name1][name2]... should be array-like. The",
                    "  // callback will be called with a reference to this path object for each",
                    "  // element of the array.",
                    "  each(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = getLast(stack);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "",
                    "    for (let i = 0; i < value.length; ++i) {",
                    "      if (i in value) {",
                    "        stack.push(i, value[i]);",
                    "        // If the callback needs to know the value of i, call",
                    "        // path.getName(), assuming path is the parameter name.",
                    "        callback(this);",
                    "        stack.length -= 2;",
                    "      }",
                    "    }",
                    "",
                    "    stack.length = length;",
                    "  }",
                    "",
                    "  // Similar to FastPath.prototype.each, except that the results of the",
                    "  // callback function invocations are stored in an array and returned at",
                    "  // the end of the iteration.",
                    "  map(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = getLast(stack);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "",
                    "    const result = new Array(value.length);",
                    "",
                    "    for (let i = 0; i < value.length; ++i) {",
                    "      if (i in value) {",
                    "        stack.push(i, value[i]);",
                    "        result[i] = callback(this, i);",
                    "        stack.length -= 2;",
                    "      }",
                    "    }",
                    "",
                    "    stack.length = length;",
                    "",
                    "    return result;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {...(",
                    "   *   | ((node: any, name: string | null, number: number | null) => boolean)",
                    "   *   | undefined",
                    "   * )} predicates",
                    "   */",
                    "  match(...predicates) {",
                    "    let stackPointer = this.stack.length - 1;",
                    "",
                    "    let name = null;",
                    "    let node = this.stack[stackPointer--];",
                    "",
                    "    for (const predicate of predicates) {",
                    "      if (node === undefined) {",
                    "        return false;",
                    "      }",
                    "",
                    "      // skip index/array",
                    "      let number = null;",
                    "      if (typeof name === \"number\") {",
                    "        number = name;",
                    "        name = this.stack[stackPointer--];",
                    "        node = this.stack[stackPointer--];",
                    "      }",
                    "",
                    "      if (predicate && !predicate(node, name, number)) {",
                    "        return false;",
                    "      }",
                    "",
                    "      name = this.stack[stackPointer--];",
                    "      node = this.stack[stackPointer--];",
                    "    }",
                    "",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "module.exports = FastPath;"
                ]
            },
            "get-file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createIgnorer = require(\"./create-ignorer\");",
                    "const options = require(\"../main/options\");",
                    "const config = require(\"../config/resolve-config\");",
                    "const path = require(\"path\");",
                    "",
                    "/**",
                    " * @typedef {{ ignorePath?: string, withNodeModules?: boolean, plugins: object }} FileInfoOptions",
                    " * @typedef {{ ignored: boolean, inferredParser: string | null }} FileInfoResult",
                    " */",
                    "",
                    "/**",
                    " * @param {string} filePath",
                    " * @param {FileInfoOptions} opts",
                    " * @returns {Promise<FileInfoResult>}",
                    " *",
                    " * Please note that prettier.getFileInfo() expects opts.plugins to be an array of paths,",
                    " * not an object. A transformation from this array to an object is automatically done",
                    " * internally by the method wrapper. See withPlugins() in index.js.",
                    " */",
                    "async function getFileInfo(filePath, opts) {",
                    "  if (typeof filePath !== \"string\") {",
                    "    throw new TypeError(",
                    "      `expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``",
                    "    );",
                    "  }",
                    "",
                    "  const ignorer = await createIgnorer(opts.ignorePath, opts.withNodeModules);",
                    "  return _getFileInfo({",
                    "    ignorer,",
                    "    filePath: normalizeFilePath(filePath, opts.ignorePath),",
                    "    plugins: opts.plugins,",
                    "    resolveConfig: opts.resolveConfig,",
                    "    sync: false,",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {string} filePath",
                    " * @param {FileInfoOptions} opts",
                    " * @returns {FileInfoResult}",
                    " */",
                    "getFileInfo.sync = function (filePath, opts) {",
                    "  if (typeof filePath !== \"string\") {",
                    "    throw new TypeError(",
                    "      `expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``",
                    "    );",
                    "  }",
                    "",
                    "  const ignorer = createIgnorer.sync(opts.ignorePath, opts.withNodeModules);",
                    "  return _getFileInfo({",
                    "    ignorer,",
                    "    filePath: normalizeFilePath(filePath, opts.ignorePath),",
                    "    plugins: opts.plugins,",
                    "    resolveConfig: opts.resolveConfig,",
                    "    sync: true,",
                    "  });",
                    "};",
                    "",
                    "function _getFileInfo({",
                    "  ignorer,",
                    "  filePath,",
                    "  plugins,",
                    "  resolveConfig = false,",
                    "  sync = false,",
                    "}) {",
                    "  const fileInfo = {",
                    "    ignored: ignorer.ignores(filePath),",
                    "    inferredParser: options.inferParser(filePath, plugins) || null,",
                    "  };",
                    "",
                    "  if (!fileInfo.inferredParser && resolveConfig) {",
                    "    if (!sync) {",
                    "      return config.resolveConfig(filePath).then((resolvedConfig) => {",
                    "        if (resolvedConfig && resolvedConfig.parser) {",
                    "          fileInfo.inferredParser = resolvedConfig.parser;",
                    "        }",
                    "",
                    "        return fileInfo;",
                    "      });",
                    "    }",
                    "",
                    "    const resolvedConfig = config.resolveConfig.sync(filePath);",
                    "    if (resolvedConfig && resolvedConfig.parser) {",
                    "      fileInfo.inferredParser = resolvedConfig.parser;",
                    "    }",
                    "  }",
                    "",
                    "  return fileInfo;",
                    "}",
                    "",
                    "function normalizeFilePath(filePath, ignorePath) {",
                    "  return ignorePath",
                    "    ? path.relative(path.dirname(ignorePath), filePath)",
                    "    : filePath;",
                    "}",
                    "",
                    "module.exports = getFileInfo;"
                ]
            },
            "internal-plugins.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// We need to use `eval(\"require\")()` to prevent rollup from hoisting the requires. A babel",
                    "// plugin will look for `eval(\"require\")()` and transform to `require()` in the bundle,",
                    "// and rewrite the paths to require from the top-level.",
                    "",
                    "// We need to list the parsers and getters so we can load them only when necessary.",
                    "module.exports = [",
                    "  // JS",
                    "  require(\"../language-js\"),",
                    "  {",
                    "    parsers: {",
                    "      // JS - Babel",
                    "      get babel() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers.babel;",
                    "      },",
                    "      get \"babel-flow\"() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers[",
                    "          \"babel-flow\"",
                    "        ];",
                    "      },",
                    "      get \"babel-ts\"() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers[",
                    "          \"babel-ts\"",
                    "        ];",
                    "      },",
                    "      get json() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers.json;",
                    "      },",
                    "      get json5() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers.json5;",
                    "      },",
                    "      get \"json-stringify\"() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers[",
                    "          \"json-stringify\"",
                    "        ];",
                    "      },",
                    "      get __js_expression() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers",
                    "          .__js_expression;",
                    "      },",
                    "      get __vue_expression() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers",
                    "          .__vue_expression;",
                    "      },",
                    "      get __vue_event_binding() {",
                    "        return eval(\"require\")(\"../language-js/parser-babel\").parsers",
                    "          .__vue_event_binding;",
                    "      },",
                    "      // JS - Flow",
                    "      get flow() {",
                    "        return eval(\"require\")(\"../language-js/parser-flow\").parsers.flow;",
                    "      },",
                    "      // JS - TypeScript",
                    "      get typescript() {",
                    "        return eval(\"require\")(\"../language-js/parser-typescript\").parsers",
                    "          .typescript;",
                    "      },",
                    "      // JS - Angular Action",
                    "      get __ng_action() {",
                    "        return eval(\"require\")(\"../language-js/parser-angular\").parsers",
                    "          .__ng_action;",
                    "      },",
                    "      // JS - Angular Binding",
                    "      get __ng_binding() {",
                    "        return eval(\"require\")(\"../language-js/parser-angular\").parsers",
                    "          .__ng_binding;",
                    "      },",
                    "      // JS - Angular Interpolation",
                    "      get __ng_interpolation() {",
                    "        return eval(\"require\")(\"../language-js/parser-angular\").parsers",
                    "          .__ng_interpolation;",
                    "      },",
                    "      // JS - Angular Directive",
                    "      get __ng_directive() {",
                    "        return eval(\"require\")(\"../language-js/parser-angular\").parsers",
                    "          .__ng_directive;",
                    "      },",
                    "    },",
                    "  },",
                    "",
                    "  // CSS",
                    "  require(\"../language-css\"),",
                    "  {",
                    "    parsers: {",
                    "      // TODO: switch these to just `postcss` and use `language` instead.",
                    "      get css() {",
                    "        return eval(\"require\")(\"../language-css/parser-postcss\").parsers.css;",
                    "      },",
                    "      get less() {",
                    "        return eval(\"require\")(\"../language-css/parser-postcss\").parsers.less;",
                    "      },",
                    "      get scss() {",
                    "        return eval(\"require\")(\"../language-css/parser-postcss\").parsers.scss;",
                    "      },",
                    "    },",
                    "  },",
                    "",
                    "  // Handlebars",
                    "  require(\"../language-handlebars\"),",
                    "  {",
                    "    parsers: {",
                    "      get glimmer() {",
                    "        return eval(\"require\")(\"../language-handlebars/parser-glimmer\").parsers",
                    "          .glimmer;",
                    "      },",
                    "    },",
                    "  },",
                    "",
                    "  // GraphQL",
                    "  require(\"../language-graphql\"),",
                    "  {",
                    "    parsers: {",
                    "      get graphql() {",
                    "        return eval(\"require\")(\"../language-graphql/parser-graphql\").parsers",
                    "          .graphql;",
                    "      },",
                    "    },",
                    "  },",
                    "",
                    "  // Markdown",
                    "  require(\"../language-markdown\"),",
                    "  {",
                    "    parsers: {",
                    "      get remark() {",
                    "        return eval(\"require\")(\"../language-markdown/parser-markdown\").parsers",
                    "          .remark;",
                    "      },",
                    "      get markdown() {",
                    "        return eval(\"require\")(\"../language-markdown/parser-markdown\").parsers",
                    "          .remark;",
                    "      },",
                    "      get mdx() {",
                    "        return eval(\"require\")(\"../language-markdown/parser-markdown\").parsers",
                    "          .mdx;",
                    "      },",
                    "    },",
                    "  },",
                    "",
                    "  require(\"../language-html\"),",
                    "  {",
                    "    parsers: {",
                    "      // HTML",
                    "      get html() {",
                    "        return eval(\"require\")(\"../language-html/parser-html\").parsers.html;",
                    "      },",
                    "      // Vue",
                    "      get vue() {",
                    "        return eval(\"require\")(\"../language-html/parser-html\").parsers.vue;",
                    "      },",
                    "      // Angular",
                    "      get angular() {",
                    "        return eval(\"require\")(\"../language-html/parser-html\").parsers.angular;",
                    "      },",
                    "      // Lightning Web Components",
                    "      get lwc() {",
                    "        return eval(\"require\")(\"../language-html/parser-html\").parsers.lwc;",
                    "      },",
                    "    },",
                    "  },",
                    "",
                    "  // YAML",
                    "  require(\"../language-yaml\"),",
                    "  {",
                    "    parsers: {",
                    "      get yaml() {",
                    "        return eval(\"require\")(\"../language-yaml/parser-yaml\").parsers.yaml;",
                    "      },",
                    "    },",
                    "  },",
                    "];"
                ]
            },
            "load-plugins.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const uniqBy = require(\"lodash/uniqBy\");",
                    "const partition = require(\"lodash/partition\");",
                    "const fs = require(\"fs\");",
                    "const globby = require(\"globby\");",
                    "const path = require(\"path\");",
                    "const thirdParty = require(\"./third-party\");",
                    "const internalPlugins = require(\"./internal-plugins\");",
                    "const mem = require(\"mem\");",
                    "const resolve = require(\"./resolve\");",
                    "",
                    "const memoizedLoad = mem(load, { cacheKey: JSON.stringify });",
                    "const memoizedSearch = mem(findPluginsInNodeModules);",
                    "const clearCache = () => {",
                    "  mem.clear(memoizedLoad);",
                    "  mem.clear(memoizedSearch);",
                    "};",
                    "",
                    "function load(plugins, pluginSearchDirs) {",
                    "  if (!plugins) {",
                    "    plugins = [];",
                    "  }",
                    "",
                    "  if (!pluginSearchDirs) {",
                    "    pluginSearchDirs = [];",
                    "  }",
                    "  // unless pluginSearchDirs are provided, auto-load plugins from node_modules that are parent to Prettier",
                    "  if (!pluginSearchDirs.length) {",
                    "    const autoLoadDir = thirdParty.findParentDir(__dirname, \"node_modules\");",
                    "    if (autoLoadDir) {",
                    "      pluginSearchDirs = [autoLoadDir];",
                    "    }",
                    "  }",
                    "",
                    "  const [externalPluginNames, externalPluginInstances] = partition(",
                    "    plugins,",
                    "    (plugin) => typeof plugin === \"string\"",
                    "  );",
                    "",
                    "  const externalManualLoadPluginInfos = externalPluginNames.map(",
                    "    (pluginName) => {",
                    "      let requirePath;",
                    "      try {",
                    "        // try local files",
                    "        requirePath = resolve(path.resolve(process.cwd(), pluginName));",
                    "      } catch (_) {",
                    "        // try node modules",
                    "        requirePath = resolve(pluginName, { paths: [process.cwd()] });",
                    "      }",
                    "",
                    "      return {",
                    "        name: pluginName,",
                    "        requirePath,",
                    "      };",
                    "    }",
                    "  );",
                    "",
                    "  const externalAutoLoadPluginInfos = pluginSearchDirs",
                    "    .map((pluginSearchDir) => {",
                    "      const resolvedPluginSearchDir = path.resolve(",
                    "        process.cwd(),",
                    "        pluginSearchDir",
                    "      );",
                    "",
                    "      const nodeModulesDir = path.resolve(",
                    "        resolvedPluginSearchDir,",
                    "        \"node_modules\"",
                    "      );",
                    "",
                    "      // In some fringe cases (ex: files \"mounted\" as virtual directories), the",
                    "      // isDirectory(resolvedPluginSearchDir) check might be false even though",
                    "      // the node_modules actually exists.",
                    "      if (",
                    "        !isDirectory(nodeModulesDir) &&",
                    "        !isDirectory(resolvedPluginSearchDir)",
                    "      ) {",
                    "        throw new Error(",
                    "          `${pluginSearchDir} does not exist or is not a directory`",
                    "        );",
                    "      }",
                    "",
                    "      return memoizedSearch(nodeModulesDir).map((pluginName) => ({",
                    "        name: pluginName,",
                    "        requirePath: resolve(pluginName, { paths: [resolvedPluginSearchDir] }),",
                    "      }));",
                    "    })",
                    "    .reduce((a, b) => a.concat(b), []);",
                    "",
                    "  const externalPlugins = uniqBy(",
                    "    externalManualLoadPluginInfos.concat(externalAutoLoadPluginInfos),",
                    "    \"requirePath\"",
                    "  )",
                    "    .map((externalPluginInfo) => ({",
                    "      name: externalPluginInfo.name,",
                    "      ...eval(\"require\")(externalPluginInfo.requirePath),",
                    "    }))",
                    "    .concat(externalPluginInstances);",
                    "",
                    "  return internalPlugins.concat(externalPlugins);",
                    "}",
                    "",
                    "function findPluginsInNodeModules(nodeModulesDir) {",
                    "  const pluginPackageJsonPaths = globby.sync(",
                    "    [",
                    "      \"prettier-plugin-*/package.json\",",
                    "      \"@*/prettier-plugin-*/package.json\",",
                    "      \"@prettier/plugin-*/package.json\",",
                    "    ],",
                    "    {",
                    "      cwd: nodeModulesDir,",
                    "      expandDirectories: false,",
                    "    }",
                    "  );",
                    "  return pluginPackageJsonPaths.map(path.dirname);",
                    "}",
                    "",
                    "function isDirectory(dir) {",
                    "  try {",
                    "    return fs.statSync(dir).isDirectory();",
                    "  } catch (e) {",
                    "    return false;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  loadPlugins: memoizedLoad,",
                    "  clearCache,",
                    "};"
                ]
            },
            "parser-create-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function createError(message, loc) {",
                    "  // Construct an error similar to the ones thrown by Babel.",
                    "  const error = new SyntaxError(",
                    "    message + \" (\" + loc.start.line + \":\" + loc.start.column + \")\"",
                    "  );",
                    "  error.loc = loc;",
                    "  return error;",
                    "}",
                    "",
                    "module.exports = createError;"
                ]
            },
            "parser-include-shebang.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { getShebang } = require(\"./util\");",
                    "",
                    "function includeShebang(text, ast) {",
                    "  const shebang = getShebang(text);",
                    "",
                    "  if (!shebang) {",
                    "    return;",
                    "  }",
                    "  const index = shebang.length;",
                    "",
                    "  const comment = {",
                    "    type: \"Line\",",
                    "    value: shebang.slice(2),",
                    "    range: [0, index],",
                    "    loc: {",
                    "      start: {",
                    "        line: 1,",
                    "        column: 0,",
                    "      },",
                    "      end: {",
                    "        line: 1,",
                    "        column: index,",
                    "      },",
                    "    },",
                    "  };",
                    "",
                    "  ast.comments = [comment].concat(ast.comments);",
                    "}",
                    "",
                    "module.exports = includeShebang;"
                ]
            },
            "resolve.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// `/scripts/build/babel-plugins/transform-custom-require.js` doesn't support destructuring.",
                    "// eslint-disable-next-line prefer-destructuring",
                    "let resolve = eval(\"require\").resolve;",
                    "",
                    "// In the VS Code and Atom extensions `require` is overridden and `require.resolve` doesn't support the 2nd argument.",
                    "if (resolve.length === 1 || process.env.PRETTIER_FALLBACK_RESOLVE) {",
                    "  resolve = (id, options) => {",
                    "    let basedir;",
                    "    if (options && options.paths && options.paths.length === 1) {",
                    "      basedir = options.paths[0];",
                    "    }",
                    "",
                    "    return require(\"resolve\").sync(id, { basedir });",
                    "  };",
                    "}",
                    "",
                    "module.exports = resolve;"
                ]
            },
            "third-party.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  cosmiconfig: require(\"cosmiconfig\").cosmiconfig,",
                    "  cosmiconfigSync: require(\"cosmiconfig\").cosmiconfigSync,",
                    "  findParentDir: require(\"find-parent-dir\").sync,",
                    "  getStream: require(\"get-stream\"),",
                    "  isCI: () => require(\"ci-info\").isCI,",
                    "};"
                ]
            },
            "util-shared.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getMaxContinuousCount,",
                    "  getStringWidth,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipNewline,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  isNextLineEmpty,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isPreviousLineEmpty,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "} = require(\"./util\");",
                    "",
                    "module.exports = {",
                    "  getMaxContinuousCount,",
                    "  getStringWidth,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipNewline,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  isNextLineEmpty,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isPreviousLineEmpty,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "};"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const stringWidth = require(\"string-width\");",
                    "const escapeStringRegexp = require(\"escape-string-regexp\");",
                    "const getLast = require(\"../utils/get-last\");",
                    "const support = require(\"../main/support\");",
                    "",
                    "// eslint-disable-next-line no-control-regex",
                    "const notAsciiRegex = /[^\\x20-\\x7F]/;",
                    "",
                    "function getPenultimate(arr) {",
                    "  if (arr.length > 1) {",
                    "    return arr[arr.length - 2];",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "/**",
                    " * @typedef {{backwards?: boolean}} SkipOptions",
                    " */",
                    "",
                    "/**",
                    " * @param {string | RegExp} chars",
                    " * @returns {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "function skip(chars) {",
                    "  return (text, index, opts) => {",
                    "    const backwards = opts && opts.backwards;",
                    "",
                    "    // Allow `skip` functions to be threaded together without having",
                    "    // to check for failures (did someone say monads?).",
                    "    if (index === false) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const { length } = text;",
                    "    let cursor = index;",
                    "    while (cursor >= 0 && cursor < length) {",
                    "      const c = text.charAt(cursor);",
                    "      if (chars instanceof RegExp) {",
                    "        if (!chars.test(c)) {",
                    "          return cursor;",
                    "        }",
                    "      } else if (!chars.includes(c)) {",
                    "        return cursor;",
                    "      }",
                    "",
                    "      backwards ? cursor-- : cursor++;",
                    "    }",
                    "",
                    "    if (cursor === -1 || cursor === length) {",
                    "      // If we reached the beginning or end of the file, return the",
                    "      // out-of-bounds cursor. It's up to the caller to handle this",
                    "      // correctly. We don't want to indicate `false` though if it",
                    "      // actually skipped valid characters.",
                    "      return cursor;",
                    "    }",
                    "    return false;",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "const skipWhitespace = skip(/\\s/);",
                    "/**",
                    " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "const skipSpaces = skip(\" \\t\");",
                    "/**",
                    " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "const skipToLineEnd = skip(\",; \\t\");",
                    "/**",
                    " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "const skipEverythingButNewLine = skip(/[^\\n\\r]/);",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} index",
                    " * @returns {number | false}",
                    " */",
                    "function skipInlineComment(text, index) {",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {",
                    "    for (let i = index + 2; i < text.length; ++i) {",
                    "      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {",
                    "        return i + 2;",
                    "      }",
                    "    }",
                    "  }",
                    "  return index;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} index",
                    " * @returns {number | false}",
                    " */",
                    "function skipTrailingComment(text, index) {",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {",
                    "    return skipEverythingButNewLine(text, index);",
                    "  }",
                    "  return index;",
                    "}",
                    "",
                    "// This one doesn't use the above helper function because it wants to",
                    "// test \\r\\n in order and `skip` doesn't support ordering and we only",
                    "// want to skip one newline. It's simple to implement.",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} index",
                    " * @param {SkipOptions=} opts",
                    " * @returns {number | false}",
                    " */",
                    "function skipNewline(text, index, opts) {",
                    "  const backwards = opts && opts.backwards;",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const atIndex = text.charAt(index);",
                    "  if (backwards) {",
                    "    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {",
                    "      return index - 2;",
                    "    }",
                    "    if (",
                    "      atIndex === \"\\n\" ||",
                    "      atIndex === \"\\r\" ||",
                    "      atIndex === \"\\u2028\" ||",
                    "      atIndex === \"\\u2029\"",
                    "    ) {",
                    "      return index - 1;",
                    "    }",
                    "  } else {",
                    "    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {",
                    "      return index + 2;",
                    "    }",
                    "    if (",
                    "      atIndex === \"\\n\" ||",
                    "      atIndex === \"\\r\" ||",
                    "      atIndex === \"\\u2028\" ||",
                    "      atIndex === \"\\u2029\"",
                    "    ) {",
                    "      return index + 1;",
                    "    }",
                    "  }",
                    "",
                    "  return index;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @param {SkipOptions=} opts",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewline(text, index, opts) {",
                    "  opts = opts || {};",
                    "  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);",
                    "  const idx2 = skipNewline(text, idx, opts);",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} start",
                    " * @param {number} end",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewlineInRange(text, start, end) {",
                    "  for (let i = start; i < end; ++i) {",
                    "    if (text.charAt(i) === \"\\n\") {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "// Note: this function doesn't ignore leading comments unlike isNextLineEmpty",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locStart",
                    " */",
                    "function isPreviousLineEmpty(text, node, locStart) {",
                    "  /** @type {number | false} */",
                    "  let idx = locStart(node) - 1;",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  idx = skipNewline(text, idx, { backwards: true });",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  const idx2 = skipNewline(text, idx, { backwards: true });",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @returns {boolean}",
                    " */",
                    "function isNextLineEmptyAfterIndex(text, index) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let idx = index;",
                    "  while (idx !== oldIdx) {",
                    "    // We need to skip all the potential trailing inline comments",
                    "    oldIdx = idx;",
                    "    idx = skipToLineEnd(text, idx);",
                    "    idx = skipInlineComment(text, idx);",
                    "    idx = skipSpaces(text, idx);",
                    "  }",
                    "  idx = skipTrailingComment(text, idx);",
                    "  idx = skipNewline(text, idx);",
                    "  return idx !== false && hasNewline(text, idx);",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {boolean}",
                    " */",
                    "function isNextLineEmpty(text, node, locEnd) {",
                    "  return isNextLineEmptyAfterIndex(text, locEnd(node));",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} idx",
                    " * @returns {number | false}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let nextIdx = idx;",
                    "  while (nextIdx !== oldIdx) {",
                    "    oldIdx = nextIdx;",
                    "    nextIdx = skipSpaces(text, nextIdx);",
                    "    nextIdx = skipInlineComment(text, nextIdx);",
                    "    nextIdx = skipTrailingComment(text, nextIdx);",
                    "    nextIdx = skipNewline(text, nextIdx);",
                    "  }",
                    "  return nextIdx;",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {number | false}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {",
                    "  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "    text,",
                    "    locEnd(node)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {string}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {",
                    "  return text.charAt(",
                    "    // @ts-ignore => TBD: can return false, should we define a fallback?",
                    "    getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @param {SkipOptions=} opts",
                    " * @returns {boolean}",
                    " */",
                    "function hasSpaces(text, index, opts) {",
                    "  opts = opts || {};",
                    "  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);",
                    "  return idx !== index;",
                    "}",
                    "",
                    "/**",
                    " * @param {{range?: [number, number], start?: number}} node",
                    " * @param {number} index",
                    " */",
                    "function setLocStart(node, index) {",
                    "  if (node.range) {",
                    "    node.range[0] = index;",
                    "  } else {",
                    "    node.start = index;",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {{range?: [number, number], end?: number}} node",
                    " * @param {number} index",
                    " */",
                    "function setLocEnd(node, index) {",
                    "  if (node.range) {",
                    "    node.range[1] = index;",
                    "  } else {",
                    "    node.end = index;",
                    "  }",
                    "}",
                    "",
                    "const PRECEDENCE = {};",
                    "[",
                    "  [\"|>\"],",
                    "  [\"??\"],",
                    "  [\"||\"],",
                    "  [\"&&\"],",
                    "  [\"|\"],",
                    "  [\"^\"],",
                    "  [\"&\"],",
                    "  [\"==\", \"===\", \"!=\", \"!==\"],",
                    "  [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],",
                    "  [\">>\", \"<<\", \">>>\"],",
                    "  [\"+\", \"-\"],",
                    "  [\"*\", \"/\", \"%\"],",
                    "  [\"**\"],",
                    "].forEach((tier, i) => {",
                    "  tier.forEach((op) => {",
                    "    PRECEDENCE[op] = i;",
                    "  });",
                    "});",
                    "",
                    "function getPrecedence(op) {",
                    "  return PRECEDENCE[op];",
                    "}",
                    "",
                    "const equalityOperators = {",
                    "  \"==\": true,",
                    "  \"!=\": true,",
                    "  \"===\": true,",
                    "  \"!==\": true,",
                    "};",
                    "const multiplicativeOperators = {",
                    "  \"*\": true,",
                    "  \"/\": true,",
                    "  \"%\": true,",
                    "};",
                    "const bitshiftOperators = {",
                    "  \">>\": true,",
                    "  \">>>\": true,",
                    "  \"<<\": true,",
                    "};",
                    "",
                    "function shouldFlatten(parentOp, nodeOp) {",
                    "  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // ** is right-associative",
                    "  // x ** y ** z --> x ** (y ** z)",
                    "  if (parentOp === \"**\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  // x == y == z --> (x == y) == z",
                    "  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // x * y % z --> (x * y) % z",
                    "  if (",
                    "    (nodeOp === \"%\" && multiplicativeOperators[parentOp]) ||",
                    "    (parentOp === \"%\" && multiplicativeOperators[nodeOp])",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // x * y / z --> (x * y) / z",
                    "  // x / y * z --> (x / y) * z",
                    "  if (",
                    "    nodeOp !== parentOp &&",
                    "    multiplicativeOperators[nodeOp] &&",
                    "    multiplicativeOperators[parentOp]",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // x << y << z --> (x << y) << z",
                    "  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function isBitwiseOperator(operator) {",
                    "  return (",
                    "    !!bitshiftOperators[operator] ||",
                    "    operator === \"|\" ||",
                    "    operator === \"^\" ||",
                    "    operator === \"&\"",
                    "  );",
                    "}",
                    "",
                    "// Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr",
                    "// holds) `function`, `class`, or `do {}`. Will be overzealous if there's",
                    "// already necessary grouping parentheses.",
                    "function startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {",
                    "  node = getLeftMost(node);",
                    "  switch (node.type) {",
                    "    case \"FunctionExpression\":",
                    "    case \"ClassExpression\":",
                    "    case \"DoExpression\":",
                    "      return forbidFunctionClassAndDoExpr;",
                    "    case \"ObjectExpression\":",
                    "      return true;",
                    "    case \"MemberExpression\":",
                    "    case \"OptionalMemberExpression\":",
                    "      return startsWithNoLookaheadToken(",
                    "        node.object,",
                    "        forbidFunctionClassAndDoExpr",
                    "      );",
                    "    case \"TaggedTemplateExpression\":",
                    "      if (node.tag.type === \"FunctionExpression\") {",
                    "        // IIFEs are always already parenthesized",
                    "        return false;",
                    "      }",
                    "      return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);",
                    "    case \"CallExpression\":",
                    "    case \"OptionalCallExpression\":",
                    "      if (node.callee.type === \"FunctionExpression\") {",
                    "        // IIFEs are always already parenthesized",
                    "        return false;",
                    "      }",
                    "      return startsWithNoLookaheadToken(",
                    "        node.callee,",
                    "        forbidFunctionClassAndDoExpr",
                    "      );",
                    "    case \"ConditionalExpression\":",
                    "      return startsWithNoLookaheadToken(",
                    "        node.test,",
                    "        forbidFunctionClassAndDoExpr",
                    "      );",
                    "    case \"UpdateExpression\":",
                    "      return (",
                    "        !node.prefix &&",
                    "        startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr)",
                    "      );",
                    "    case \"BindExpression\":",
                    "      return (",
                    "        node.object &&",
                    "        startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr)",
                    "      );",
                    "    case \"SequenceExpression\":",
                    "      return startsWithNoLookaheadToken(",
                    "        node.expressions[0],",
                    "        forbidFunctionClassAndDoExpr",
                    "      );",
                    "    case \"TSAsExpression\":",
                    "      return startsWithNoLookaheadToken(",
                    "        node.expression,",
                    "        forbidFunctionClassAndDoExpr",
                    "      );",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function getLeftMost(node) {",
                    "  if (node.left) {",
                    "    return getLeftMost(node.left);",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @param {number} tabWidth",
                    " * @param {number=} startIndex",
                    " * @returns {number}",
                    " */",
                    "function getAlignmentSize(value, tabWidth, startIndex) {",
                    "  startIndex = startIndex || 0;",
                    "",
                    "  let size = 0;",
                    "  for (let i = startIndex; i < value.length; ++i) {",
                    "    if (value[i] === \"\\t\") {",
                    "      // Tabs behave in a way that they are aligned to the nearest",
                    "      // multiple of tabWidth:",
                    "      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4",
                    "      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...",
                    "      size = size + tabWidth - (size % tabWidth);",
                    "    } else {",
                    "      size++;",
                    "    }",
                    "  }",
                    "",
                    "  return size;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @param {number} tabWidth",
                    " * @returns {number}",
                    " */",
                    "function getIndentSize(value, tabWidth) {",
                    "  const lastNewlineIndex = value.lastIndexOf(\"\\n\");",
                    "  if (lastNewlineIndex === -1) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return getAlignmentSize(",
                    "    // All the leading whitespaces",
                    "    value.slice(lastNewlineIndex + 1).match(/^[\\t ]*/)[0],",
                    "    tabWidth",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @typedef {'\"' | \"'\"} Quote",
                    " */",
                    "",
                    "/**",
                    " *",
                    " * @param {string} raw",
                    " * @param {Quote} preferredQuote",
                    " * @returns {Quote}",
                    " */",
                    "function getPreferredQuote(raw, preferredQuote) {",
                    "  // `rawContent` is the string exactly like it appeared in the input source",
                    "  // code, without its enclosing quotes.",
                    "  const rawContent = raw.slice(1, -1);",
                    "",
                    "  /** @type {{ quote: '\"', regex: RegExp }} */",
                    "  const double = { quote: '\"', regex: /\"/g };",
                    "  /** @type {{ quote: \"'\", regex: RegExp }} */",
                    "  const single = { quote: \"'\", regex: /'/g };",
                    "",
                    "  const preferred = preferredQuote === \"'\" ? single : double;",
                    "  const alternate = preferred === single ? double : single;",
                    "",
                    "  let result = preferred.quote;",
                    "",
                    "  // If `rawContent` contains at least one of the quote preferred for enclosing",
                    "  // the string, we might want to enclose with the alternate quote instead, to",
                    "  // minimize the number of escaped quotes.",
                    "  if (",
                    "    rawContent.includes(preferred.quote) ||",
                    "    rawContent.includes(alternate.quote)",
                    "  ) {",
                    "    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;",
                    "    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;",
                    "",
                    "    result =",
                    "      numPreferredQuotes > numAlternateQuotes",
                    "        ? alternate.quote",
                    "        : preferred.quote;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function printString(raw, options, isDirectiveLiteral) {",
                    "  // `rawContent` is the string exactly like it appeared in the input source",
                    "  // code, without its enclosing quotes.",
                    "  const rawContent = raw.slice(1, -1);",
                    "",
                    "  // Check for the alternate quote, to determine if we're allowed to swap",
                    "  // the quotes on a DirectiveLiteral.",
                    "  const canChangeDirectiveQuotes =",
                    "    !rawContent.includes('\"') && !rawContent.includes(\"'\");",
                    "",
                    "  /** @type {Quote} */",
                    "  const enclosingQuote =",
                    "    options.parser === \"json\"",
                    "      ? '\"'",
                    "      : options.__isInHtmlAttribute",
                    "      ? \"'\"",
                    "      : getPreferredQuote(raw, options.singleQuote ? \"'\" : '\"');",
                    "",
                    "  // Directives are exact code unit sequences, which means that you can't",
                    "  // change the escape sequences they use.",
                    "  // See https://github.com/prettier/prettier/issues/1555",
                    "  // and https://tc39.github.io/ecma262/#directive-prologue",
                    "  if (isDirectiveLiteral) {",
                    "    if (canChangeDirectiveQuotes) {",
                    "      return enclosingQuote + rawContent + enclosingQuote;",
                    "    }",
                    "    return raw;",
                    "  }",
                    "",
                    "  // It might sound unnecessary to use `makeString` even if the string already",
                    "  // is enclosed with `enclosingQuote`, but it isn't. The string could contain",
                    "  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes",
                    "  // sure that we consistently output the minimum amount of escaped quotes.",
                    "  return makeString(",
                    "    rawContent,",
                    "    enclosingQuote,",
                    "    !(",
                    "      options.parser === \"css\" ||",
                    "      options.parser === \"less\" ||",
                    "      options.parser === \"scss\" ||",
                    "      options.embeddedInHtml",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} rawContent",
                    " * @param {Quote} enclosingQuote",
                    " * @param {boolean=} unescapeUnnecessaryEscapes",
                    " * @returns {string}",
                    " */",
                    "function makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {",
                    "  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';",
                    "",
                    "  // Matches _any_ escape and unescaped quotes (both single and double).",
                    "  const regex = /\\\\([\\S\\s])|([\"'])/g;",
                    "",
                    "  // Escape and unescape single and double quotes as needed to be able to",
                    "  // enclose `rawContent` with `enclosingQuote`.",
                    "  const newContent = rawContent.replace(regex, (match, escaped, quote) => {",
                    "    // If we matched an escape, and the escaped character is a quote of the",
                    "    // other type than we intend to enclose the string with, there's no need for",
                    "    // it to be escaped, so return it _without_ the backslash.",
                    "    if (escaped === otherQuote) {",
                    "      return escaped;",
                    "    }",
                    "",
                    "    // If we matched an unescaped quote and it is of the _same_ type as we",
                    "    // intend to enclose the string with, it must be escaped, so return it with",
                    "    // a backslash.",
                    "    if (quote === enclosingQuote) {",
                    "      return \"\\\\\" + quote;",
                    "    }",
                    "",
                    "    if (quote) {",
                    "      return quote;",
                    "    }",
                    "",
                    "    // Unescape any unnecessarily escaped character.",
                    "    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27",
                    "    return unescapeUnnecessaryEscapes &&",
                    "      /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(escaped)",
                    "      ? escaped",
                    "      : \"\\\\\" + escaped;",
                    "  });",
                    "",
                    "  return enclosingQuote + newContent + enclosingQuote;",
                    "}",
                    "",
                    "function printNumber(rawNumber) {",
                    "  return (",
                    "    rawNumber",
                    "      .toLowerCase()",
                    "      // Remove unnecessary plus and zeroes from scientific notation.",
                    "      .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\")",
                    "      // Remove unnecessary scientific notation (1e0).",
                    "      .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\")",
                    "      // Make sure numbers always start with a digit.",
                    "      .replace(/^([+-])?\\./, \"$10.\")",
                    "      // Remove extraneous trailing decimal zeroes.",
                    "      .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\")",
                    "      // Remove trailing dot.",
                    "      .replace(/\\.(?=e|$)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} str",
                    " * @param {string} target",
                    " * @returns {number}",
                    " */",
                    "function getMaxContinuousCount(str, target) {",
                    "  const results = str.match(",
                    "    new RegExp(`(${escapeStringRegexp(target)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (results === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return results.reduce(",
                    "    (maxCount, result) => Math.max(maxCount, result.length / target.length),",
                    "    0",
                    "  );",
                    "}",
                    "",
                    "function getMinNotPresentContinuousCount(str, target) {",
                    "  const matches = str.match(",
                    "    new RegExp(`(${escapeStringRegexp(target)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (matches === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  const countPresent = new Map();",
                    "  let max = 0;",
                    "",
                    "  for (const match of matches) {",
                    "    const count = match.length / target.length;",
                    "    countPresent.set(count, true);",
                    "    if (count > max) {",
                    "      max = count;",
                    "    }",
                    "  }",
                    "",
                    "  for (let i = 1; i < max; i++) {",
                    "    if (!countPresent.get(i)) {",
                    "      return i;",
                    "    }",
                    "  }",
                    "",
                    "  return max + 1;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @returns {number}",
                    " */",
                    "function getStringWidth(text) {",
                    "  if (!text) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`",
                    "  if (!notAsciiRegex.test(text)) {",
                    "    return text.length;",
                    "  }",
                    "",
                    "  return stringWidth(text);",
                    "}",
                    "",
                    "function hasIgnoreComment(path) {",
                    "  const node = path.getValue();",
                    "  return hasNodeIgnoreComment(node);",
                    "}",
                    "",
                    "function hasNodeIgnoreComment(node) {",
                    "  return (",
                    "    node &&",
                    "    ((node.comments &&",
                    "      node.comments.length > 0 &&",
                    "      node.comments.some(",
                    "        (comment) => isNodeIgnoreComment(comment) && !comment.unignore",
                    "      )) ||",
                    "      node.prettierIgnore)",
                    "  );",
                    "}",
                    "",
                    "function isNodeIgnoreComment(comment) {",
                    "  return comment.value.trim() === \"prettier-ignore\";",
                    "}",
                    "",
                    "function addCommentHelper(node, comment) {",
                    "  const comments = node.comments || (node.comments = []);",
                    "  comments.push(comment);",
                    "  comment.printed = false;",
                    "",
                    "  // For some reason, TypeScript parses `// x` inside of JSXText as a comment",
                    "  // We already \"print\" it via the raw text, we don't need to re-print it as a",
                    "  // comment",
                    "  if (node.type === \"JSXText\") {",
                    "    comment.printed = true;",
                    "  }",
                    "}",
                    "",
                    "function addLeadingComment(node, comment) {",
                    "  comment.leading = true;",
                    "  comment.trailing = false;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function addDanglingComment(node, comment, marker) {",
                    "  comment.leading = false;",
                    "  comment.trailing = false;",
                    "  if (marker) {",
                    "    comment.marker = marker;",
                    "  }",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function addTrailingComment(node, comment) {",
                    "  comment.leading = false;",
                    "  comment.trailing = true;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function isWithinParentArrayProperty(path, propertyName) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  if (parent == null) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (!Array.isArray(parent[propertyName])) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const key = path.getName();",
                    "  return parent[propertyName][key] === node;",
                    "}",
                    "",
                    "function replaceEndOfLineWith(text, replacement) {",
                    "  const parts = [];",
                    "  for (const part of text.split(\"\\n\")) {",
                    "    if (parts.length !== 0) {",
                    "      parts.push(replacement);",
                    "    }",
                    "    parts.push(part);",
                    "  }",
                    "  return parts;",
                    "}",
                    "",
                    "function getParserName(lang, options) {",
                    "  const supportInfo = support.getSupportInfo({ plugins: options.plugins });",
                    "  const language = supportInfo.languages.find(",
                    "    (language) =>",
                    "      language.name.toLowerCase() === lang ||",
                    "      (language.aliases && language.aliases.includes(lang)) ||",
                    "      (language.extensions &&",
                    "        language.extensions.find((ext) => ext === `.${lang}`))",
                    "  );",
                    "  if (language) {",
                    "    return language.parsers[0];",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function isFrontMatterNode(node) {",
                    "  return node && node.type === \"front-matter\";",
                    "}",
                    "",
                    "function getShebang(text) {",
                    "  if (!text.startsWith(\"#!\")) {",
                    "    return \"\";",
                    "  }",
                    "  const index = text.indexOf(\"\\n\");",
                    "  if (index === -1) {",
                    "    return text;",
                    "  }",
                    "  return text.slice(0, index);",
                    "}",
                    "",
                    "module.exports = {",
                    "  replaceEndOfLineWith,",
                    "  getStringWidth,",
                    "  getMaxContinuousCount,",
                    "  getMinNotPresentContinuousCount,",
                    "  getPrecedence,",
                    "  shouldFlatten,",
                    "  isBitwiseOperator,",
                    "  getParserName,",
                    "  getPenultimate,",
                    "  getLast,",
                    "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  getNextNonSpaceNonCommentCharacter,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  skipNewline,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isNextLineEmpty,",
                    "  isPreviousLineEmpty,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  setLocStart,",
                    "  setLocEnd,",
                    "  startsWithNoLookaheadToken,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  getPreferredQuote,",
                    "  printString,",
                    "  printNumber,",
                    "  hasIgnoreComment,",
                    "  hasNodeIgnoreComment,",
                    "  isNodeIgnoreComment,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "  isWithinParentArrayProperty,",
                    "  isFrontMatterNode,",
                    "  getShebang,",
                    "};"
                ]
            }
        },
        "config": {
            "resolve-config-editorconfig.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "const path = require(\"path\");",
                    "",
                    "const editorconfig = require(\"editorconfig\");",
                    "const mem = require(\"mem\");",
                    "const editorConfigToPrettier = require(\"editorconfig-to-prettier\");",
                    "const findProjectRoot = require(\"find-project-root\");",
                    "",
                    "const jsonStringifyMem = (fn) => mem(fn, { cacheKey: JSON.stringify });",
                    "",
                    "const maybeParse = (filePath, parse) => {",
                    "  // findProjectRoot will throw an error if we pass a nonexistent directory to",
                    "  // it, which is possible, for example, when the path is given via",
                    "  // --stdin-filepath. So, first, traverse up until we find an existing",
                    "  // directory.",
                    "  let dirPath = path.dirname(path.resolve(filePath));",
                    "  const fsRoot = path.parse(dirPath).root;",
                    "  while (dirPath !== fsRoot && !fs.existsSync(dirPath)) {",
                    "    dirPath = path.dirname(dirPath);",
                    "  }",
                    "  const root = findProjectRoot(dirPath);",
                    "  return filePath && parse(filePath, { root });",
                    "};",
                    "",
                    "const editorconfigAsyncNoCache = async (filePath) => {",
                    "  const editorConfig = await maybeParse(filePath, editorconfig.parse);",
                    "  return editorConfigToPrettier(editorConfig);",
                    "};",
                    "const editorconfigAsyncWithCache = jsonStringifyMem(editorconfigAsyncNoCache);",
                    "",
                    "const editorconfigSyncNoCache = (filePath) => {",
                    "  return editorConfigToPrettier(maybeParse(filePath, editorconfig.parseSync));",
                    "};",
                    "const editorconfigSyncWithCache = jsonStringifyMem(editorconfigSyncNoCache);",
                    "",
                    "function getLoadFunction(opts) {",
                    "  if (!opts.editorconfig) {",
                    "    return () => null;",
                    "  }",
                    "",
                    "  if (opts.sync) {",
                    "    return opts.cache ? editorconfigSyncWithCache : editorconfigSyncNoCache;",
                    "  }",
                    "",
                    "  return opts.cache ? editorconfigAsyncWithCache : editorconfigAsyncNoCache;",
                    "}",
                    "",
                    "function clearCache() {",
                    "  mem.clear(editorconfigSyncWithCache);",
                    "  mem.clear(editorconfigAsyncWithCache);",
                    "}",
                    "",
                    "module.exports = {",
                    "  getLoadFunction,",
                    "  clearCache,",
                    "};"
                ]
            },
            "resolve-config.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const thirdParty = require(\"../common/third-party\");",
                    "const minimatch = require(\"minimatch\");",
                    "const path = require(\"path\");",
                    "const mem = require(\"mem\");",
                    "",
                    "const resolveEditorConfig = require(\"./resolve-config-editorconfig\");",
                    "const loadToml = require(\"../utils/load-toml\");",
                    "const resolve = require(\"../common/resolve\");",
                    "",
                    "const getExplorerMemoized = mem(",
                    "  (opts) => {",
                    "    const cosmiconfig = thirdParty[\"cosmiconfig\" + (opts.sync ? \"Sync\" : \"\")];",
                    "    const explorer = cosmiconfig(\"prettier\", {",
                    "      cache: opts.cache,",
                    "      transform: (result) => {",
                    "        if (result && result.config) {",
                    "          if (typeof result.config === \"string\") {",
                    "            const dir = path.dirname(result.filepath);",
                    "            const modulePath = resolve(result.config, { paths: [dir] });",
                    "            result.config = eval(\"require\")(modulePath);",
                    "          }",
                    "",
                    "          if (typeof result.config !== \"object\") {",
                    "            throw new Error(",
                    "              \"Config is only allowed to be an object, \" +",
                    "                `but received ${typeof result.config} in \"${result.filepath}\"`",
                    "            );",
                    "          }",
                    "",
                    "          delete result.config.$schema;",
                    "        }",
                    "        return result;",
                    "      },",
                    "      searchPlaces: [",
                    "        \"package.json\",",
                    "        \".prettierrc\",",
                    "        \".prettierrc.json\",",
                    "        \".prettierrc.yaml\",",
                    "        \".prettierrc.yml\",",
                    "        \".prettierrc.js\",",
                    "        \"prettier.config.js\",",
                    "        \".prettierrc.toml\",",
                    "      ],",
                    "      loaders: {",
                    "        \".toml\": loadToml,",
                    "      },",
                    "    });",
                    "",
                    "    return explorer;",
                    "  },",
                    "  { cacheKey: JSON.stringify }",
                    ");",
                    "",
                    "/** @param {{ cache: boolean, sync: boolean }} opts */",
                    "function getExplorer(opts) {",
                    "  // Normalize opts before passing to a memoized function",
                    "  opts = { sync: false, cache: false, ...opts };",
                    "  return getExplorerMemoized(opts);",
                    "}",
                    "",
                    "function _resolveConfig(filePath, opts, sync) {",
                    "  opts = { useCache: true, ...opts };",
                    "  const loadOpts = {",
                    "    cache: !!opts.useCache,",
                    "    sync: !!sync,",
                    "    editorconfig: !!opts.editorconfig,",
                    "  };",
                    "  const { load, search } = getExplorer(loadOpts);",
                    "  const loadEditorConfig = resolveEditorConfig.getLoadFunction(loadOpts);",
                    "  const arr = [",
                    "    opts.config ? load(opts.config) : search(filePath),",
                    "    loadEditorConfig(filePath),",
                    "  ];",
                    "",
                    "  const unwrapAndMerge = ([result, editorConfigured]) => {",
                    "    const merged = {",
                    "      ...editorConfigured,",
                    "      ...mergeOverrides(result, filePath),",
                    "    };",
                    "",
                    "    [\"plugins\", \"pluginSearchDirs\"].forEach((optionName) => {",
                    "      if (Array.isArray(merged[optionName])) {",
                    "        merged[optionName] = merged[optionName].map((value) =>",
                    "          typeof value === \"string\" && value.startsWith(\".\") // relative path",
                    "            ? path.resolve(path.dirname(result.filepath), value)",
                    "            : value",
                    "        );",
                    "      }",
                    "    });",
                    "",
                    "    if (!result && !editorConfigured) {",
                    "      return null;",
                    "    }",
                    "",
                    "    return merged;",
                    "  };",
                    "",
                    "  if (loadOpts.sync) {",
                    "    return unwrapAndMerge(arr);",
                    "  }",
                    "",
                    "  return Promise.all(arr).then(unwrapAndMerge);",
                    "}",
                    "",
                    "const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);",
                    "",
                    "resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);",
                    "",
                    "function clearCache() {",
                    "  mem.clear(getExplorerMemoized);",
                    "  resolveEditorConfig.clearCache();",
                    "}",
                    "",
                    "async function resolveConfigFile(filePath) {",
                    "  const { search } = getExplorer({ sync: false });",
                    "  const result = await search(filePath);",
                    "  return result ? result.filepath : null;",
                    "}",
                    "",
                    "resolveConfigFile.sync = (filePath) => {",
                    "  const { search } = getExplorer({ sync: true });",
                    "  const result = search(filePath);",
                    "  return result ? result.filepath : null;",
                    "};",
                    "",
                    "function mergeOverrides(configResult, filePath) {",
                    "  const { config, filepath: configPath } = configResult || {};",
                    "  const { overrides, ...options } = config || {};",
                    "  if (filePath && overrides) {",
                    "    const relativeFilePath = path.relative(path.dirname(configPath), filePath);",
                    "    for (const override of overrides) {",
                    "      if (",
                    "        pathMatchesGlobs(",
                    "          relativeFilePath,",
                    "          override.files,",
                    "          override.excludeFiles",
                    "        )",
                    "      ) {",
                    "        Object.assign(options, override.options);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  return options;",
                    "}",
                    "",
                    "// Based on eslint: https://github.com/eslint/eslint/blob/master/lib/config/config-ops.js",
                    "function pathMatchesGlobs(filePath, patterns, excludedPatterns) {",
                    "  const patternList = [].concat(patterns);",
                    "  const excludedPatternList = [].concat(excludedPatterns || []);",
                    "  const opts = { matchBase: true, dot: true };",
                    "",
                    "  return (",
                    "    patternList.some((pattern) => minimatch(filePath, pattern, opts)) &&",
                    "    !excludedPatternList.some((excludedPattern) =>",
                    "      minimatch(filePath, excludedPattern, opts)",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  resolveConfig,",
                    "  resolveConfigFile,",
                    "  clearCache,",
                    "};"
                ]
            }
        },
        "document": {
            "doc-builders.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * TBD properly tagged union for Doc object type is needed here.",
                    " *",
                    " * @typedef {object} DocObject",
                    " * @property {string} type",
                    " * @property {boolean} [hard]",
                    " * @property {boolean} [literal]",
                    " *",
                    " * @typedef {string | DocObject} Doc",
                    " */",
                    "",
                    "/**",
                    " * @param {Doc} val",
                    " */",
                    "function assertDoc(val) {",
                    "  /* istanbul ignore if */",
                    "  if (",
                    "    !(typeof val === \"string\" || (val != null && typeof val.type === \"string\"))",
                    "  ) {",
                    "    throw new Error(",
                    "      \"Value \" + JSON.stringify(val) + \" is not a valid document\"",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} parts",
                    " * @returns Doc",
                    " */",
                    "function concat(parts) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    parts.forEach(assertDoc);",
                    "  }",
                    "",
                    "  // We cannot do this until we change `printJSXElement` to not",
                    "  // access the internals of a document directly.",
                    "  // if(parts.length === 1) {",
                    "  //   // If it's a single document, no need to concat it.",
                    "  //   return parts[0];",
                    "  // }",
                    "  return { type: \"concat\", parts };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function indent(contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return { type: \"indent\", contents };",
                    "}",
                    "",
                    "/**",
                    " * @param {number} n",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function align(n, contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return { type: \"align\", contents, n };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function group(contents, opts) {",
                    "  opts = opts || {};",
                    "",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return {",
                    "    type: \"group\",",
                    "    id: opts.id,",
                    "    contents,",
                    "    break: !!opts.shouldBreak,",
                    "    expandedStates: opts.expandedStates,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedentToRoot(contents) {",
                    "  return align(-Infinity, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function markAsRoot(contents) {",
                    "  // @ts-ignore - TBD ???:",
                    "  return align({ type: \"root\" }, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedent(contents) {",
                    "  return align(-1, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} states",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function conditionalGroup(states, opts) {",
                    "  return group(states[0], { ...opts, expandedStates: states });",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} parts",
                    " * @returns Doc",
                    " */",
                    "function fill(parts) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    parts.forEach(assertDoc);",
                    "  }",
                    "",
                    "  return { type: \"fill\", parts };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} [breakContents]",
                    " * @param {Doc} [flatContents]",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function ifBreak(breakContents, flatContents, opts) {",
                    "  opts = opts || {};",
                    "",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    if (breakContents) {",
                    "      assertDoc(breakContents);",
                    "    }",
                    "    if (flatContents) {",
                    "      assertDoc(flatContents);",
                    "    }",
                    "  }",
                    "",
                    "  return {",
                    "    type: \"if-break\",",
                    "    breakContents,",
                    "    flatContents,",
                    "    groupId: opts.groupId,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function lineSuffix(contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "  return { type: \"line-suffix\", contents };",
                    "}",
                    "",
                    "const lineSuffixBoundary = { type: \"line-suffix-boundary\" };",
                    "const breakParent = { type: \"break-parent\" };",
                    "const trim = { type: \"trim\" };",
                    "const line = { type: \"line\" };",
                    "const softline = { type: \"line\", soft: true };",
                    "const hardline = concat([{ type: \"line\", hard: true }, breakParent]);",
                    "const literalline = concat([",
                    "  { type: \"line\", hard: true, literal: true },",
                    "  breakParent,",
                    "]);",
                    "const cursor = { type: \"cursor\", placeholder: Symbol(\"cursor\") };",
                    "",
                    "/**",
                    " * @param {Doc} sep",
                    " * @param {Doc[]} arr",
                    " * @returns Doc",
                    " */",
                    "function join(sep, arr) {",
                    "  const res = [];",
                    "",
                    "  for (let i = 0; i < arr.length; i++) {",
                    "    if (i !== 0) {",
                    "      res.push(sep);",
                    "    }",
                    "",
                    "    res.push(arr[i]);",
                    "  }",
                    "",
                    "  return concat(res);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} doc",
                    " * @param {number} size",
                    " * @param {number} tabWidth",
                    " */",
                    "function addAlignmentToDoc(doc, size, tabWidth) {",
                    "  let aligned = doc;",
                    "  if (size > 0) {",
                    "    // Use indent to add tabs for all the levels of tabs we need",
                    "    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {",
                    "      aligned = indent(aligned);",
                    "    }",
                    "    // Use align for all the spaces that are needed",
                    "    aligned = align(size % tabWidth, aligned);",
                    "    // size is absolute from 0 and not relative to the current",
                    "    // indentation, so we use -Infinity to reset the indentation to 0",
                    "    aligned = align(-Infinity, aligned);",
                    "  }",
                    "  return aligned;",
                    "}",
                    "",
                    "module.exports = {",
                    "  concat,",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "};"
                ]
            },
            "doc-debug.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function flattenDoc(doc) {",
                    "  if (doc.type === \"concat\") {",
                    "    const res = [];",
                    "",
                    "    for (let i = 0; i < doc.parts.length; ++i) {",
                    "      const doc2 = doc.parts[i];",
                    "      if (typeof doc2 !== \"string\" && doc2.type === \"concat\") {",
                    "        res.push(...flattenDoc(doc2).parts);",
                    "      } else {",
                    "        const flattened = flattenDoc(doc2);",
                    "        if (flattened !== \"\") {",
                    "          res.push(flattened);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return { ...doc, parts: res };",
                    "  } else if (doc.type === \"if-break\") {",
                    "    return {",
                    "      ...doc,",
                    "      breakContents:",
                    "        doc.breakContents != null ? flattenDoc(doc.breakContents) : null,",
                    "      flatContents:",
                    "        doc.flatContents != null ? flattenDoc(doc.flatContents) : null,",
                    "    };",
                    "  } else if (doc.type === \"group\") {",
                    "    return {",
                    "      ...doc,",
                    "      contents: flattenDoc(doc.contents),",
                    "      expandedStates: doc.expandedStates",
                    "        ? doc.expandedStates.map(flattenDoc)",
                    "        : doc.expandedStates,",
                    "    };",
                    "  } else if (doc.contents) {",
                    "    return { ...doc, contents: flattenDoc(doc.contents) };",
                    "  }",
                    "  return doc;",
                    "}",
                    "",
                    "function printDoc(doc) {",
                    "  if (typeof doc === \"string\") {",
                    "    return JSON.stringify(doc);",
                    "  }",
                    "",
                    "  if (doc.type === \"line\") {",
                    "    if (doc.literal) {",
                    "      return \"literalline\";",
                    "    }",
                    "    if (doc.hard) {",
                    "      return \"hardline\";",
                    "    }",
                    "    if (doc.soft) {",
                    "      return \"softline\";",
                    "    }",
                    "    return \"line\";",
                    "  }",
                    "",
                    "  if (doc.type === \"break-parent\") {",
                    "    return \"breakParent\";",
                    "  }",
                    "",
                    "  if (doc.type === \"trim\") {",
                    "    return \"trim\";",
                    "  }",
                    "",
                    "  if (doc.type === \"concat\") {",
                    "    return \"[\" + doc.parts.map(printDoc).join(\", \") + \"]\";",
                    "  }",
                    "",
                    "  if (doc.type === \"indent\") {",
                    "    return \"indent(\" + printDoc(doc.contents) + \")\";",
                    "  }",
                    "",
                    "  if (doc.type === \"align\") {",
                    "    return doc.n === -Infinity",
                    "      ? \"dedentToRoot(\" + printDoc(doc.contents) + \")\"",
                    "      : doc.n < 0",
                    "      ? \"dedent(\" + printDoc(doc.contents) + \")\"",
                    "      : doc.n.type === \"root\"",
                    "      ? \"markAsRoot(\" + printDoc(doc.contents) + \")\"",
                    "      : \"align(\" + JSON.stringify(doc.n) + \", \" + printDoc(doc.contents) + \")\";",
                    "  }",
                    "",
                    "  if (doc.type === \"if-break\") {",
                    "    return (",
                    "      \"ifBreak(\" +",
                    "      printDoc(doc.breakContents) +",
                    "      (doc.flatContents ? \", \" + printDoc(doc.flatContents) : \"\") +",
                    "      \")\"",
                    "    );",
                    "  }",
                    "",
                    "  if (doc.type === \"group\") {",
                    "    if (doc.expandedStates) {",
                    "      return (",
                    "        \"conditionalGroup(\" +",
                    "        \"[\" +",
                    "        doc.expandedStates.map(printDoc).join(\",\") +",
                    "        \"])\"",
                    "      );",
                    "    }",
                    "",
                    "    return (",
                    "      (doc.break ? \"wrappedGroup\" : \"group\") +",
                    "      \"(\" +",
                    "      printDoc(doc.contents) +",
                    "      \")\"",
                    "    );",
                    "  }",
                    "",
                    "  if (doc.type === \"fill\") {",
                    "    return \"fill\" + \"(\" + doc.parts.map(printDoc).join(\", \") + \")\";",
                    "  }",
                    "",
                    "  if (doc.type === \"line-suffix\") {",
                    "    return \"lineSuffix(\" + printDoc(doc.contents) + \")\";",
                    "  }",
                    "",
                    "  if (doc.type === \"line-suffix-boundary\") {",
                    "    return \"lineSuffixBoundary\";",
                    "  }",
                    "",
                    "  throw new Error(\"Unknown doc type \" + doc.type);",
                    "}",
                    "",
                    "module.exports = {",
                    "  printDocToDebug(doc) {",
                    "    return printDoc(flattenDoc(doc));",
                    "  },",
                    "};"
                ]
            },
            "doc-printer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { getStringWidth } = require(\"../common/util\");",
                    "const { convertEndOfLineToChars } = require(\"../common/end-of-line\");",
                    "const { concat, fill, cursor } = require(\"./doc-builders\");",
                    "",
                    "/** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */",
                    "let groupModeMap;",
                    "",
                    "const MODE_BREAK = 1;",
                    "const MODE_FLAT = 2;",
                    "",
                    "function rootIndent() {",
                    "  return { value: \"\", length: 0, queue: [] };",
                    "}",
                    "",
                    "function makeIndent(ind, options) {",
                    "  return generateInd(ind, { type: \"indent\" }, options);",
                    "}",
                    "",
                    "function makeAlign(ind, n, options) {",
                    "  return n === -Infinity",
                    "    ? ind.root || rootIndent()",
                    "    : n < 0",
                    "    ? generateInd(ind, { type: \"dedent\" }, options)",
                    "    : !n",
                    "    ? ind",
                    "    : n.type === \"root\"",
                    "    ? { ...ind, root: ind }",
                    "    : typeof n === \"string\"",
                    "    ? generateInd(ind, { type: \"stringAlign\", n }, options)",
                    "    : generateInd(ind, { type: \"numberAlign\", n }, options);",
                    "}",
                    "",
                    "function generateInd(ind, newPart, options) {",
                    "  const queue =",
                    "    newPart.type === \"dedent\"",
                    "      ? ind.queue.slice(0, -1)",
                    "      : ind.queue.concat(newPart);",
                    "",
                    "  let value = \"\";",
                    "  let length = 0;",
                    "  let lastTabs = 0;",
                    "  let lastSpaces = 0;",
                    "",
                    "  for (const part of queue) {",
                    "    switch (part.type) {",
                    "      case \"indent\":",
                    "        flush();",
                    "        if (options.useTabs) {",
                    "          addTabs(1);",
                    "        } else {",
                    "          addSpaces(options.tabWidth);",
                    "        }",
                    "        break;",
                    "      case \"stringAlign\":",
                    "        flush();",
                    "        value += part.n;",
                    "        length += part.n.length;",
                    "        break;",
                    "      case \"numberAlign\":",
                    "        lastTabs += 1;",
                    "        lastSpaces += part.n;",
                    "        break;",
                    "      /* istanbul ignore next */",
                    "      default:",
                    "        throw new Error(`Unexpected type '${part.type}'`);",
                    "    }",
                    "  }",
                    "",
                    "  flushSpaces();",
                    "",
                    "  return { ...ind, value, length, queue };",
                    "",
                    "  function addTabs(count) {",
                    "    value += \"\\t\".repeat(count);",
                    "    length += options.tabWidth * count;",
                    "  }",
                    "",
                    "  function addSpaces(count) {",
                    "    value += \" \".repeat(count);",
                    "    length += count;",
                    "  }",
                    "",
                    "  function flush() {",
                    "    if (options.useTabs) {",
                    "      flushTabs();",
                    "    } else {",
                    "      flushSpaces();",
                    "    }",
                    "  }",
                    "",
                    "  function flushTabs() {",
                    "    if (lastTabs > 0) {",
                    "      addTabs(lastTabs);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function flushSpaces() {",
                    "    if (lastSpaces > 0) {",
                    "      addSpaces(lastSpaces);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function resetLast() {",
                    "    lastTabs = 0;",
                    "    lastSpaces = 0;",
                    "  }",
                    "}",
                    "",
                    "function trim(out) {",
                    "  if (out.length === 0) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  let trimCount = 0;",
                    "",
                    "  // Trim whitespace at the end of line",
                    "  while (",
                    "    out.length > 0 &&",
                    "    typeof out[out.length - 1] === \"string\" &&",
                    "    out[out.length - 1].match(/^[\\t ]*$/)",
                    "  ) {",
                    "    trimCount += out.pop().length;",
                    "  }",
                    "",
                    "  if (out.length && typeof out[out.length - 1] === \"string\") {",
                    "    const trimmed = out[out.length - 1].replace(/[\\t ]*$/, \"\");",
                    "    trimCount += out[out.length - 1].length - trimmed.length;",
                    "    out[out.length - 1] = trimmed;",
                    "  }",
                    "",
                    "  return trimCount;",
                    "}",
                    "",
                    "function fits(next, restCommands, width, options, mustBeFlat) {",
                    "  let restIdx = restCommands.length;",
                    "  const cmds = [next];",
                    "  // `out` is only used for width counting because `trim` requires to look",
                    "  // backwards for space characters.",
                    "  const out = [];",
                    "  while (width >= 0) {",
                    "    if (cmds.length === 0) {",
                    "      if (restIdx === 0) {",
                    "        return true;",
                    "      }",
                    "      cmds.push(restCommands[restIdx - 1]);",
                    "",
                    "      restIdx--;",
                    "",
                    "      continue;",
                    "    }",
                    "",
                    "    const [ind, mode, doc] = cmds.pop();",
                    "",
                    "    if (typeof doc === \"string\") {",
                    "      out.push(doc);",
                    "",
                    "      width -= getStringWidth(doc);",
                    "    } else {",
                    "      switch (doc.type) {",
                    "        case \"concat\":",
                    "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                    "            cmds.push([ind, mode, doc.parts[i]]);",
                    "          }",
                    "",
                    "          break;",
                    "        case \"indent\":",
                    "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"align\":",
                    "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"trim\":",
                    "          width += trim(out);",
                    "",
                    "          break;",
                    "        case \"group\":",
                    "          if (mustBeFlat && doc.break) {",
                    "            return false;",
                    "          }",
                    "          cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);",
                    "",
                    "          if (doc.id) {",
                    "            groupModeMap[doc.id] = cmds[cmds.length - 1][1];",
                    "          }",
                    "          break;",
                    "        case \"fill\":",
                    "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                    "            cmds.push([ind, mode, doc.parts[i]]);",
                    "          }",
                    "",
                    "          break;",
                    "        case \"if-break\": {",
                    "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                    "          if (groupMode === MODE_BREAK) {",
                    "            if (doc.breakContents) {",
                    "              cmds.push([ind, mode, doc.breakContents]);",
                    "            }",
                    "          }",
                    "          if (groupMode === MODE_FLAT) {",
                    "            if (doc.flatContents) {",
                    "              cmds.push([ind, mode, doc.flatContents]);",
                    "            }",
                    "          }",
                    "",
                    "          break;",
                    "        }",
                    "        case \"line\":",
                    "          switch (mode) {",
                    "            // fallthrough",
                    "            case MODE_FLAT:",
                    "              if (!doc.hard) {",
                    "                if (!doc.soft) {",
                    "                  out.push(\" \");",
                    "",
                    "                  width -= 1;",
                    "                }",
                    "",
                    "                break;",
                    "              }",
                    "              return true;",
                    "",
                    "            case MODE_BREAK:",
                    "              return true;",
                    "          }",
                    "          break;",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function printDocToString(doc, options) {",
                    "  groupModeMap = {};",
                    "",
                    "  const width = options.printWidth;",
                    "  const newLine = convertEndOfLineToChars(options.endOfLine);",
                    "  let pos = 0;",
                    "  // cmds is basically a stack. We've turned a recursive call into a",
                    "  // while loop which is much faster. The while loop below adds new",
                    "  // cmds to the array instead of recursively calling `print`.",
                    "  const cmds = [[rootIndent(), MODE_BREAK, doc]];",
                    "  const out = [];",
                    "  let shouldRemeasure = false;",
                    "  let lineSuffix = [];",
                    "",
                    "  while (cmds.length !== 0) {",
                    "    const [ind, mode, doc] = cmds.pop();",
                    "",
                    "    if (typeof doc === \"string\") {",
                    "      const formatted =",
                    "        newLine !== \"\\n\" && doc.includes(\"\\n\")",
                    "          ? doc.replace(/\\n/g, newLine)",
                    "          : doc;",
                    "      out.push(formatted);",
                    "      pos += getStringWidth(formatted);",
                    "    } else {",
                    "      switch (doc.type) {",
                    "        case \"cursor\":",
                    "          out.push(cursor.placeholder);",
                    "",
                    "          break;",
                    "        case \"concat\":",
                    "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                    "            cmds.push([ind, mode, doc.parts[i]]);",
                    "          }",
                    "",
                    "          break;",
                    "        case \"indent\":",
                    "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"align\":",
                    "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"trim\":",
                    "          pos -= trim(out);",
                    "",
                    "          break;",
                    "        case \"group\":",
                    "          switch (mode) {",
                    "            case MODE_FLAT:",
                    "              if (!shouldRemeasure) {",
                    "                cmds.push([",
                    "                  ind,",
                    "                  doc.break ? MODE_BREAK : MODE_FLAT,",
                    "                  doc.contents,",
                    "                ]);",
                    "",
                    "                break;",
                    "              }",
                    "            // fallthrough",
                    "",
                    "            case MODE_BREAK: {",
                    "              shouldRemeasure = false;",
                    "",
                    "              const next = [ind, MODE_FLAT, doc.contents];",
                    "              const rem = width - pos;",
                    "",
                    "              if (!doc.break && fits(next, cmds, rem, options)) {",
                    "                cmds.push(next);",
                    "              } else {",
                    "                // Expanded states are a rare case where a document",
                    "                // can manually provide multiple representations of",
                    "                // itself. It provides an array of documents",
                    "                // going from the least expanded (most flattened)",
                    "                // representation first to the most expanded. If a",
                    "                // group has these, we need to manually go through",
                    "                // these states and find the first one that fits.",
                    "                if (doc.expandedStates) {",
                    "                  const mostExpanded =",
                    "                    doc.expandedStates[doc.expandedStates.length - 1];",
                    "",
                    "                  if (doc.break) {",
                    "                    cmds.push([ind, MODE_BREAK, mostExpanded]);",
                    "",
                    "                    break;",
                    "                  } else {",
                    "                    for (let i = 1; i < doc.expandedStates.length + 1; i++) {",
                    "                      if (i >= doc.expandedStates.length) {",
                    "                        cmds.push([ind, MODE_BREAK, mostExpanded]);",
                    "",
                    "                        break;",
                    "                      } else {",
                    "                        const state = doc.expandedStates[i];",
                    "                        const cmd = [ind, MODE_FLAT, state];",
                    "",
                    "                        if (fits(cmd, cmds, rem, options)) {",
                    "                          cmds.push(cmd);",
                    "",
                    "                          break;",
                    "                        }",
                    "                      }",
                    "                    }",
                    "                  }",
                    "                } else {",
                    "                  cmds.push([ind, MODE_BREAK, doc.contents]);",
                    "                }",
                    "              }",
                    "",
                    "              break;",
                    "            }",
                    "          }",
                    "",
                    "          if (doc.id) {",
                    "            groupModeMap[doc.id] = cmds[cmds.length - 1][1];",
                    "          }",
                    "          break;",
                    "        // Fills each line with as much code as possible before moving to a new",
                    "        // line with the same indentation.",
                    "        //",
                    "        // Expects doc.parts to be an array of alternating content and",
                    "        // whitespace. The whitespace contains the linebreaks.",
                    "        //",
                    "        // For example:",
                    "        //   [\"I\", line, \"love\", line, \"monkeys\"]",
                    "        // or",
                    "        //   [{ type: group, ... }, softline, { type: group, ... }]",
                    "        //",
                    "        // It uses this parts structure to handle three main layout cases:",
                    "        // * The first two content items fit on the same line without",
                    "        //   breaking",
                    "        //   -> output the first content item and the whitespace \"flat\".",
                    "        // * Only the first content item fits on the line without breaking",
                    "        //   -> output the first content item \"flat\" and the whitespace with",
                    "        //   \"break\".",
                    "        // * Neither content item fits on the line without breaking",
                    "        //   -> output the first content item and the whitespace with \"break\".",
                    "        case \"fill\": {",
                    "          const rem = width - pos;",
                    "",
                    "          const { parts } = doc;",
                    "          if (parts.length === 0) {",
                    "            break;",
                    "          }",
                    "",
                    "          const [content, whitespace] = parts;",
                    "          const contentFlatCmd = [ind, MODE_FLAT, content];",
                    "          const contentBreakCmd = [ind, MODE_BREAK, content];",
                    "          const contentFits = fits(contentFlatCmd, [], rem, options, true);",
                    "",
                    "          if (parts.length === 1) {",
                    "            if (contentFits) {",
                    "              cmds.push(contentFlatCmd);",
                    "            } else {",
                    "              cmds.push(contentBreakCmd);",
                    "            }",
                    "            break;",
                    "          }",
                    "",
                    "          const whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];",
                    "          const whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];",
                    "",
                    "          if (parts.length === 2) {",
                    "            if (contentFits) {",
                    "              cmds.push(whitespaceFlatCmd);",
                    "              cmds.push(contentFlatCmd);",
                    "            } else {",
                    "              cmds.push(whitespaceBreakCmd);",
                    "              cmds.push(contentBreakCmd);",
                    "            }",
                    "            break;",
                    "          }",
                    "",
                    "          // At this point we've handled the first pair (context, separator)",
                    "          // and will create a new fill doc for the rest of the content.",
                    "          // Ideally we wouldn't mutate the array here but copying all the",
                    "          // elements to a new array would make this algorithm quadratic,",
                    "          // which is unusable for large arrays (e.g. large texts in JSX).",
                    "          parts.splice(0, 2);",
                    "          const remainingCmd = [ind, mode, fill(parts)];",
                    "",
                    "          const secondContent = parts[0];",
                    "",
                    "          const firstAndSecondContentFlatCmd = [",
                    "            ind,",
                    "            MODE_FLAT,",
                    "            concat([content, whitespace, secondContent]),",
                    "          ];",
                    "          const firstAndSecondContentFits = fits(",
                    "            firstAndSecondContentFlatCmd,",
                    "            [],",
                    "            rem,",
                    "            options,",
                    "            true",
                    "          );",
                    "",
                    "          if (firstAndSecondContentFits) {",
                    "            cmds.push(remainingCmd);",
                    "            cmds.push(whitespaceFlatCmd);",
                    "            cmds.push(contentFlatCmd);",
                    "          } else if (contentFits) {",
                    "            cmds.push(remainingCmd);",
                    "            cmds.push(whitespaceBreakCmd);",
                    "            cmds.push(contentFlatCmd);",
                    "          } else {",
                    "            cmds.push(remainingCmd);",
                    "            cmds.push(whitespaceBreakCmd);",
                    "            cmds.push(contentBreakCmd);",
                    "          }",
                    "          break;",
                    "        }",
                    "        case \"if-break\": {",
                    "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                    "          if (groupMode === MODE_BREAK) {",
                    "            if (doc.breakContents) {",
                    "              cmds.push([ind, mode, doc.breakContents]);",
                    "            }",
                    "          }",
                    "          if (groupMode === MODE_FLAT) {",
                    "            if (doc.flatContents) {",
                    "              cmds.push([ind, mode, doc.flatContents]);",
                    "            }",
                    "          }",
                    "",
                    "          break;",
                    "        }",
                    "        case \"line-suffix\":",
                    "          lineSuffix.push([ind, mode, doc.contents]);",
                    "          break;",
                    "        case \"line-suffix-boundary\":",
                    "          if (lineSuffix.length > 0) {",
                    "            cmds.push([ind, mode, { type: \"line\", hard: true }]);",
                    "          }",
                    "          break;",
                    "        case \"line\":",
                    "          switch (mode) {",
                    "            case MODE_FLAT:",
                    "              if (!doc.hard) {",
                    "                if (!doc.soft) {",
                    "                  out.push(\" \");",
                    "",
                    "                  pos += 1;",
                    "                }",
                    "",
                    "                break;",
                    "              } else {",
                    "                // This line was forced into the output even if we",
                    "                // were in flattened mode, so we need to tell the next",
                    "                // group that no matter what, it needs to remeasure",
                    "                // because the previous measurement didn't accurately",
                    "                // capture the entire expression (this is necessary",
                    "                // for nested groups)",
                    "                shouldRemeasure = true;",
                    "              }",
                    "            // fallthrough",
                    "",
                    "            case MODE_BREAK:",
                    "              if (lineSuffix.length) {",
                    "                cmds.push([ind, mode, doc]);",
                    "                cmds.push(...lineSuffix.reverse());",
                    "                lineSuffix = [];",
                    "                break;",
                    "              }",
                    "",
                    "              if (doc.literal) {",
                    "                if (ind.root) {",
                    "                  out.push(newLine, ind.root.value);",
                    "                  pos = ind.root.length;",
                    "                } else {",
                    "                  out.push(newLine);",
                    "                  pos = 0;",
                    "                }",
                    "              } else {",
                    "                pos -= trim(out);",
                    "                out.push(newLine + ind.value);",
                    "                pos = ind.length;",
                    "              }",
                    "              break;",
                    "          }",
                    "          break;",
                    "        default:",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);",
                    "  if (cursorPlaceholderIndex !== -1) {",
                    "    const otherCursorPlaceholderIndex = out.indexOf(",
                    "      cursor.placeholder,",
                    "      cursorPlaceholderIndex + 1",
                    "    );",
                    "    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");",
                    "    const aroundCursor = out",
                    "      .slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex)",
                    "      .join(\"\");",
                    "    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");",
                    "",
                    "    return {",
                    "      formatted: beforeCursor + aroundCursor + afterCursor,",
                    "      cursorNodeStart: beforeCursor.length,",
                    "      cursorNodeText: aroundCursor,",
                    "    };",
                    "  }",
                    "",
                    "  return { formatted: out.join(\"\") };",
                    "}",
                    "",
                    "module.exports = { printDocToString };"
                ]
            },
            "doc-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// Using a unique object to compare by reference.",
                    "const traverseDocOnExitStackMarker = {};",
                    "",
                    "function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {",
                    "  const docsStack = [doc];",
                    "",
                    "  while (docsStack.length !== 0) {",
                    "    const doc = docsStack.pop();",
                    "",
                    "    if (doc === traverseDocOnExitStackMarker) {",
                    "      onExit(docsStack.pop());",
                    "      continue;",
                    "    }",
                    "",
                    "    if (onExit) {",
                    "      docsStack.push(doc, traverseDocOnExitStackMarker);",
                    "    }",
                    "",
                    "    if (",
                    "      // Should Recurse",
                    "      !onEnter ||",
                    "      onEnter(doc) !== false",
                    "    ) {",
                    "      // When there are multiple parts to process,",
                    "      // the parts need to be pushed onto the stack in reverse order,",
                    "      // so that they are processed in the original order",
                    "      // when the stack is popped.",
                    "      if (doc.type === \"concat\" || doc.type === \"fill\") {",
                    "        for (let ic = doc.parts.length, i = ic - 1; i >= 0; --i) {",
                    "          docsStack.push(doc.parts[i]);",
                    "        }",
                    "      } else if (doc.type === \"if-break\") {",
                    "        if (doc.flatContents) {",
                    "          docsStack.push(doc.flatContents);",
                    "        }",
                    "        if (doc.breakContents) {",
                    "          docsStack.push(doc.breakContents);",
                    "        }",
                    "      } else if (doc.type === \"group\" && doc.expandedStates) {",
                    "        if (shouldTraverseConditionalGroups) {",
                    "          for (let ic = doc.expandedStates.length, i = ic - 1; i >= 0; --i) {",
                    "            docsStack.push(doc.expandedStates[i]);",
                    "          }",
                    "        } else {",
                    "          docsStack.push(doc.contents);",
                    "        }",
                    "      } else if (doc.contents) {",
                    "        docsStack.push(doc.contents);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function mapDoc(doc, cb) {",
                    "  if (doc.type === \"concat\" || doc.type === \"fill\") {",
                    "    const parts = doc.parts.map((part) => mapDoc(part, cb));",
                    "    return cb({ ...doc, parts });",
                    "  } else if (doc.type === \"if-break\") {",
                    "    const breakContents = doc.breakContents && mapDoc(doc.breakContents, cb);",
                    "    const flatContents = doc.flatContents && mapDoc(doc.flatContents, cb);",
                    "    return cb({ ...doc, breakContents, flatContents });",
                    "  } else if (doc.contents) {",
                    "    const contents = mapDoc(doc.contents, cb);",
                    "    return cb({ ...doc, contents });",
                    "  }",
                    "  return cb(doc);",
                    "}",
                    "",
                    "function findInDoc(doc, fn, defaultValue) {",
                    "  let result = defaultValue;",
                    "  let hasStopped = false;",
                    "  function findInDocOnEnterFn(doc) {",
                    "    const maybeResult = fn(doc);",
                    "    if (maybeResult !== undefined) {",
                    "      hasStopped = true;",
                    "      result = maybeResult;",
                    "    }",
                    "    if (hasStopped) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "  traverseDoc(doc, findInDocOnEnterFn);",
                    "  return result;",
                    "}",
                    "",
                    "function isEmpty(n) {",
                    "  return typeof n === \"string\" && n.length === 0;",
                    "}",
                    "",
                    "function isLineNextFn(doc) {",
                    "  if (typeof doc === \"string\") {",
                    "    return false;",
                    "  }",
                    "  if (doc.type === \"line\") {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function isLineNext(doc) {",
                    "  return findInDoc(doc, isLineNextFn, false);",
                    "}",
                    "",
                    "function willBreakFn(doc) {",
                    "  if (doc.type === \"group\" && doc.break) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === \"line\" && doc.hard) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === \"break-parent\") {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function willBreak(doc) {",
                    "  return findInDoc(doc, willBreakFn, false);",
                    "}",
                    "",
                    "function breakParentGroup(groupStack) {",
                    "  if (groupStack.length > 0) {",
                    "    const parentGroup = groupStack[groupStack.length - 1];",
                    "    // Breaks are not propagated through conditional groups because",
                    "    // the user is expected to manually handle what breaks.",
                    "    if (!parentGroup.expandedStates) {",
                    "      parentGroup.break = true;",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function propagateBreaks(doc) {",
                    "  const alreadyVisitedSet = new Set();",
                    "  const groupStack = [];",
                    "  function propagateBreaksOnEnterFn(doc) {",
                    "    if (doc.type === \"break-parent\") {",
                    "      breakParentGroup(groupStack);",
                    "    }",
                    "    if (doc.type === \"group\") {",
                    "      groupStack.push(doc);",
                    "      if (alreadyVisitedSet.has(doc)) {",
                    "        return false;",
                    "      }",
                    "      alreadyVisitedSet.add(doc);",
                    "    }",
                    "  }",
                    "  function propagateBreaksOnExitFn(doc) {",
                    "    if (doc.type === \"group\") {",
                    "      const group = groupStack.pop();",
                    "      if (group.break) {",
                    "        breakParentGroup(groupStack);",
                    "      }",
                    "    }",
                    "  }",
                    "  traverseDoc(",
                    "    doc,",
                    "    propagateBreaksOnEnterFn,",
                    "    propagateBreaksOnExitFn,",
                    "    /* shouldTraverseConditionalGroups */ true",
                    "  );",
                    "}",
                    "",
                    "function removeLinesFn(doc) {",
                    "  // Force this doc into flat mode by statically converting all",
                    "  // lines into spaces (or soft lines into nothing). Hard lines",
                    "  // should still output because there's too great of a chance",
                    "  // of breaking existing assumptions otherwise.",
                    "  if (doc.type === \"line\" && !doc.hard) {",
                    "    return doc.soft ? \"\" : \" \";",
                    "  } else if (doc.type === \"if-break\") {",
                    "    return doc.flatContents || \"\";",
                    "  }",
                    "  return doc;",
                    "}",
                    "",
                    "function removeLines(doc) {",
                    "  return mapDoc(doc, removeLinesFn);",
                    "}",
                    "",
                    "function getInnerParts(doc) {",
                    "  let { parts } = doc;",
                    "  let lastPart;",
                    "  // Avoid a falsy element like \"\"",
                    "  for (let i = doc.parts.length; i > 0 && !lastPart; i--) {",
                    "    lastPart = parts[i - 1];",
                    "  }",
                    "  if (lastPart.type === \"group\") {",
                    "    parts = lastPart.contents.parts;",
                    "  }",
                    "  return parts;",
                    "}",
                    "",
                    "function stripTrailingHardline(doc, withInnerParts = false) {",
                    "  // HACK remove ending hardline, original PR: #1984",
                    "  if (doc.type === \"concat\" && doc.parts.length !== 0) {",
                    "    const parts = withInnerParts ? getInnerParts(doc) : doc.parts;",
                    "    const lastPart = parts[parts.length - 1];",
                    "    if (lastPart.type === \"concat\") {",
                    "      if (",
                    "        lastPart.parts.length === 2 &&",
                    "        lastPart.parts[0].hard &&",
                    "        lastPart.parts[1].type === \"break-parent\"",
                    "      ) {",
                    "        return { type: \"concat\", parts: parts.slice(0, -1) };",
                    "      }",
                    "",
                    "      return {",
                    "        type: \"concat\",",
                    "        parts: doc.parts.slice(0, -1).concat(stripTrailingHardline(lastPart)),",
                    "      };",
                    "    }",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function normalizeParts(parts) {",
                    "  const newParts = [];",
                    "",
                    "  const restParts = parts.filter(Boolean);",
                    "  while (restParts.length !== 0) {",
                    "    const part = restParts.shift();",
                    "",
                    "    if (!part) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (part.type === \"concat\") {",
                    "      restParts.unshift(...part.parts);",
                    "      continue;",
                    "    }",
                    "",
                    "    if (",
                    "      newParts.length !== 0 &&",
                    "      typeof newParts[newParts.length - 1] === \"string\" &&",
                    "      typeof part === \"string\"",
                    "    ) {",
                    "      newParts[newParts.length - 1] += part;",
                    "      continue;",
                    "    }",
                    "",
                    "    newParts.push(part);",
                    "  }",
                    "",
                    "  return newParts;",
                    "}",
                    "",
                    "function normalizeDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => {",
                    "    if (!currentDoc.parts) {",
                    "      return currentDoc;",
                    "    }",
                    "    return {",
                    "      ...currentDoc,",
                    "      parts: normalizeParts(currentDoc.parts),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "module.exports = {",
                    "  isEmpty,",
                    "  willBreak,",
                    "  isLineNext,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  propagateBreaks,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  normalizeParts,",
                    "  normalizeDoc,",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  builders: require(\"./doc-builders\"),",
                    "  printer: require(\"./doc-printer\"),",
                    "  utils: require(\"./doc-utils\"),",
                    "  debug: require(\"./doc-debug\"),",
                    "};"
                ]
            }
        },
        "language-css": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isFrontMatterNode } = require(\"../common/util\");",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  [",
                    "    \"raw\", // front-matter",
                    "    \"raws\",",
                    "    \"sourceIndex\",",
                    "    \"source\",",
                    "    \"before\",",
                    "    \"after\",",
                    "    \"trailingComma\",",
                    "  ].forEach((name) => {",
                    "    delete newObj[name];",
                    "  });",
                    "",
                    "  if (isFrontMatterNode(ast) && ast.lang === \"yaml\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // --insert-pragma",
                    "  if (",
                    "    ast.type === \"css-comment\" &&",
                    "    parent.type === \"css-root\" &&",
                    "    parent.nodes.length !== 0 &&",
                    "    // first non-front-matter comment",
                    "    (parent.nodes[0] === ast ||",
                    "      (isFrontMatterNode(parent.nodes[0]) && parent.nodes[1] === ast))",
                    "  ) {",
                    "    /**",
                    "     * something",
                    "     *",
                    "     * @format",
                    "     */",
                    "    delete newObj.text;",
                    "",
                    "    // standalone pragma",
                    "    if (/^\\*\\s*@(format|prettier)\\s*$/.test(ast.text)) {",
                    "      return null;",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"value-root\") {",
                    "    delete newObj.text;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"media-query\" ||",
                    "    ast.type === \"media-query-list\" ||",
                    "    ast.type === \"media-feature-expression\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"css-rule\") {",
                    "    delete newObj.params;",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-combinator\") {",
                    "    newObj.value = newObj.value.replace(/\\s+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"media-feature\") {",
                    "    newObj.value = newObj.value.replace(/ /g, \"\");",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"value-word\" &&",
                    "      ((ast.isColor && ast.isHex) ||",
                    "        [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(",
                    "          newObj.value.replace().toLowerCase()",
                    "        ))) ||",
                    "    ast.type === \"media-feature\" ||",
                    "    ast.type === \"selector-root-invalid\" ||",
                    "    ast.type === \"selector-pseudo\"",
                    "  ) {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-decl\") {",
                    "    newObj.prop = newObj.prop.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-atrule\" || ast.type === \"css-import\") {",
                    "    newObj.name = newObj.name.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"value-number\") {",
                    "    newObj.unit = newObj.unit.toLowerCase();",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-feature\" ||",
                    "      ast.type === \"media-keyword\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"media-unknown\" ||",
                    "      ast.type === \"media-url\" ||",
                    "      ast.type === \"media-value\" ||",
                    "      ast.type === \"selector-attribute\" ||",
                    "      ast.type === \"selector-string\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"value-string\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = cleanCSSStrings(newObj.value);",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-attribute\") {",
                    "    newObj.attribute = newObj.attribute.trim();",
                    "",
                    "    if (newObj.namespace) {",
                    "      if (typeof newObj.namespace === \"string\") {",
                    "        newObj.namespace = newObj.namespace.trim();",
                    "",
                    "        if (newObj.namespace.length === 0) {",
                    "          newObj.namespace = true;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newObj.value) {",
                    "      newObj.value = newObj.value.trim().replace(/^[\"']|[\"']$/g, \"\");",
                    "      delete newObj.quoted;",
                    "    }",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-value\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"value-number\" ||",
                    "      ast.type === \"selector-root-invalid\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"selector-tag\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = newObj.value.replace(",
                    "      /([\\d+.Ee-]+)([A-Za-z]*)/g,",
                    "      (match, numStr, unit) => {",
                    "        const num = Number(numStr);",
                    "        return isNaN(num) ? match : num + unit.toLowerCase();",
                    "      }",
                    "    );",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-tag\") {",
                    "    const lowercasedValue = ast.value.toLowerCase();",
                    "",
                    "    if ([\"from\", \"to\"].includes(lowercasedValue)) {",
                    "      newObj.value = lowercasedValue;",
                    "    }",
                    "  }",
                    "",
                    "  // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`",
                    "  if (ast.type === \"css-atrule\" && ast.name.toLowerCase() === \"supports\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS nested properties",
                    "  if (ast.type === \"selector-unknown\") {",
                    "    delete newObj.value;",
                    "  }",
                    "}",
                    "",
                    "function cleanCSSStrings(value) {",
                    "  return value.replace(/'/g, '\"').replace(/\\\\([^\\dA-Fa-f])/g, \"$1\");",
                    "}",
                    "",
                    "module.exports = clean;"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { hardline, literalline, concat, markAsRoot },",
                    "  utils: { mapDoc },",
                    "} = require(\"../document\");",
                    "const { isFrontMatterNode } = require(\"../common/util\");",
                    "",
                    "function embed(path, print, textToDoc /*, options */) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (isFrontMatterNode(node) && node.lang === \"yaml\") {",
                    "    return markAsRoot(",
                    "      concat([",
                    "        \"---\",",
                    "        hardline,",
                    "        node.value.trim()",
                    "          ? replaceNewlinesWithLiterallines(",
                    "              textToDoc(node.value, { parser: \"yaml\" })",
                    "            )",
                    "          : \"\",",
                    "        \"---\",",
                    "        hardline,",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  return null;",
                    "",
                    "  function replaceNewlinesWithLiterallines(doc) {",
                    "    return mapDoc(doc, (currentDoc) =>",
                    "      typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\")",
                    "        ? concat(",
                    "            currentDoc",
                    "              .split(/(\\n)/g)",
                    "              .map((v, i) => (i % 2 === 0 ? v : literalline))",
                    "          )",
                    "        : currentDoc",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-postcss\");",
                    "const options = require(\"./options\");",
                    "const createLanguage = require(\"../utils/create-language\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/CSS\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"css\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/PostCSS\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"postcss\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Less\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"less\"],",
                    "    vscodeLanguageIds: [\"less\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/SCSS\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"scss\"],",
                    "    vscodeLanguageIds: [\"scss\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  postcss: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const lineColumnToIndex = require(\"../utils/line-column-to-index\");",
                    "const { getLast, skipEverythingButNewLine } = require(\"../common/util\");",
                    "",
                    "function calculateLocStart(node, text) {",
                    "  if (node.source) {",
                    "    if (typeof node.source.sourceIndex === \"number\") {",
                    "      return node.source.sourceIndex; // value-* nodes have this",
                    "    }",
                    "    return lineColumnToIndex(node.source.start, text) - 1;",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function calculateLocEnd(node, text) {",
                    "  if (node.type === \"css-comment\" && node.inline) {",
                    "    return skipEverythingButNewLine(text, node.source.startOffset);",
                    "  }",
                    "  const endNode = node.nodes && getLast(node.nodes);",
                    "  if (endNode && node.source && !node.source.end) {",
                    "    node = endNode;",
                    "  }",
                    "  if (node.source && node.source.end) {",
                    "    return lineColumnToIndex(node.source.end, text);",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function calculateLoc(node, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text);",
                    "    node.source.endOffset = calculateLocEnd(node, text);",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (child.type === \"value-root\" || child.type === \"value-unknown\") {",
                    "      calculateValueNodeLoc(",
                    "        child,",
                    "        getValueRootOffset(node),",
                    "        child.text || child.value",
                    "      );",
                    "    } else {",
                    "      calculateLoc(child, text);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function calculateValueNodeLoc(node, rootOffset, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text) + rootOffset;",
                    "    node.source.endOffset = calculateLocEnd(node, text) + rootOffset;",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    calculateValueNodeLoc(child, rootOffset, text);",
                    "  }",
                    "}",
                    "",
                    "function getValueRootOffset(node) {",
                    "  return (",
                    "    node.source.startOffset +",
                    "    (typeof node.prop === \"string\" ? node.prop.length : 0) +",
                    "    (node.type === \"css-atrule\" && typeof node.name === \"string\"",
                    "      ? 1 + node.name.length + getLeadingWhitespaceLength(node.raws.afterName)",
                    "      : 0) +",
                    "    (node.type !== \"css-atrule\" &&",
                    "    node.raws &&",
                    "    typeof node.raws.between === \"string\"",
                    "      ? node.raws.between.length",
                    "      : 0)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * Workaround for a bug: quotes and asterisks in inline comments corrupt loc data of subsequent nodes.",
                    " * This function replaces the quotes and asterisks with spaces. Later, when the comments are printed,",
                    " * their content is extracted from the original text.",
                    " * - https://github.com/prettier/prettier/issues/7780",
                    " * - https://github.com/shellscape/postcss-less/issues/145",
                    " * - https://github.com/prettier/prettier/issues/8130",
                    " * @param text {string}",
                    " */",
                    "function replaceQuotesInInlineComments(text) {",
                    "  /** @typedef { 'initial' | 'single-quotes' | 'double-quotes' | 'url' | 'comment-block' | 'comment-inline' } State */",
                    "  /** @type {State} */",
                    "  let state = \"initial\";",
                    "  /** @type {State} */",
                    "  let stateToReturnFromQuotes = \"initial\";",
                    "  let inlineCommentStartIndex;",
                    "  let inlineCommentContainsQuotes = false;",
                    "  const inlineCommentsToReplace = [];",
                    "",
                    "  for (let i = 0; i < text.length; i++) {",
                    "    const c = text[i];",
                    "",
                    "    switch (state) {",
                    "      case \"initial\":",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          (c === \"u\" || c === \"U\") &&",
                    "          text.slice(i, i + 4).toLowerCase() === \"url(\"",
                    "        ) {",
                    "          state = \"url\";",
                    "          i += 3;",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"*\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-block\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"/\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-inline\";",
                    "          inlineCommentStartIndex = i - 1;",
                    "          continue;",
                    "        }",
                    "",
                    "        continue;",
                    "",
                    "      case \"single-quotes\":",
                    "        if (c === \"'\" && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"double-quotes\":",
                    "        if (c === '\"' && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"url\":",
                    "        if (c === \")\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-block\":",
                    "        if (c === \"/\" && text[i - 1] === \"*\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-inline\":",
                    "        if (c === '\"' || c === \"'\" || c === \"*\") {",
                    "          inlineCommentContainsQuotes = true;",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          if (inlineCommentContainsQuotes) {",
                    "            inlineCommentsToReplace.push([inlineCommentStartIndex, i]);",
                    "          }",
                    "          state = \"initial\";",
                    "          inlineCommentContainsQuotes = false;",
                    "        }",
                    "        continue;",
                    "    }",
                    "  }",
                    "",
                    "  for (const [start, end] of inlineCommentsToReplace) {",
                    "    text =",
                    "      text.slice(0, start) +",
                    "      text.slice(start, end).replace(/[\"'*]/g, \" \") +",
                    "      text.slice(end);",
                    "  }",
                    "",
                    "  return text;",
                    "}",
                    "",
                    "function getLeadingWhitespaceLength(string) {",
                    "  const m = string.match(/^\\s*/);",
                    "  return m ? m[0].length : 0;",
                    "}",
                    "",
                    "module.exports = {",
                    "  calculateLoc,",
                    "  replaceQuotesInInlineComments,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js",
                    "module.exports = {",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};"
                ]
            },
            "parser-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const parseFrontMatter = require(\"../utils/front-matter\");",
                    "const { hasPragma } = require(\"./pragma\");",
                    "const {",
                    "  hasSCSSInterpolation,",
                    "  hasStringOrFunction,",
                    "  isLessParser,",
                    "  isSCSS,",
                    "  isSCSSNestedPropertyNode,",
                    "  isSCSSVariable,",
                    "  stringifyNode,",
                    "} = require(\"./utils\");",
                    "const { calculateLoc, replaceQuotesInInlineComments } = require(\"./loc\");",
                    "",
                    "function parseValueNodes(nodes) {",
                    "  let parenGroup = {",
                    "    open: null,",
                    "    close: null,",
                    "    groups: [],",
                    "    type: \"paren_group\",",
                    "  };",
                    "  const parenGroupStack = [parenGroup];",
                    "  const rootParenGroup = parenGroup;",
                    "  let commaGroup = {",
                    "    groups: [],",
                    "    type: \"comma_group\",",
                    "  };",
                    "  const commaGroupStack = [commaGroup];",
                    "",
                    "  for (let i = 0; i < nodes.length; ++i) {",
                    "    const node = nodes[i];",
                    "",
                    "    if (node.type === \"func\" && node.value === \"url\") {",
                    "      const groups = (node.group && node.group.groups) || [];",
                    "",
                    "      // Create a view with any top-level comma groups flattened.",
                    "      let groupList = [];",
                    "      for (let i = 0; i < groups.length; i++) {",
                    "        const group = groups[i];",
                    "        if (group.type === \"comma_group\") {",
                    "          groupList = groupList.concat(group.groups);",
                    "        } else {",
                    "          groupList.push(group);",
                    "        }",
                    "      }",
                    "",
                    "      // Stringify if the value parser can't handle the content.",
                    "      if (",
                    "        hasSCSSInterpolation(groupList) ||",
                    "        (!hasStringOrFunction(groupList) && !isSCSSVariable(groupList[0]))",
                    "      ) {",
                    "        const stringifiedContent = stringifyNode({",
                    "          groups: node.group.groups,",
                    "        });",
                    "        node.group.groups = [stringifiedContent.trim()];",
                    "      }",
                    "    }",
                    "    if (node.type === \"paren\" && node.value === \"(\") {",
                    "      parenGroup = {",
                    "        open: node,",
                    "        close: null,",
                    "        groups: [],",
                    "        type: \"paren_group\",",
                    "      };",
                    "      parenGroupStack.push(parenGroup);",
                    "",
                    "      commaGroup = {",
                    "        groups: [],",
                    "        type: \"comma_group\",",
                    "      };",
                    "      commaGroupStack.push(commaGroup);",
                    "    } else if (node.type === \"paren\" && node.value === \")\") {",
                    "      if (commaGroup.groups.length) {",
                    "        parenGroup.groups.push(commaGroup);",
                    "      }",
                    "      parenGroup.close = node;",
                    "",
                    "      if (commaGroupStack.length === 1) {",
                    "        throw new Error(\"Unbalanced parenthesis\");",
                    "      }",
                    "",
                    "      commaGroupStack.pop();",
                    "      commaGroup = commaGroupStack[commaGroupStack.length - 1];",
                    "      commaGroup.groups.push(parenGroup);",
                    "",
                    "      parenGroupStack.pop();",
                    "      parenGroup = parenGroupStack[parenGroupStack.length - 1];",
                    "    } else if (node.type === \"comma\") {",
                    "      parenGroup.groups.push(commaGroup);",
                    "      commaGroup = {",
                    "        groups: [],",
                    "        type: \"comma_group\",",
                    "      };",
                    "      commaGroupStack[commaGroupStack.length - 1] = commaGroup;",
                    "    } else {",
                    "      commaGroup.groups.push(node);",
                    "    }",
                    "  }",
                    "  if (commaGroup.groups.length > 0) {",
                    "    parenGroup.groups.push(commaGroup);",
                    "  }",
                    "  return rootParenGroup;",
                    "}",
                    "",
                    "function flattenGroups(node) {",
                    "  if (",
                    "    node.type === \"paren_group\" &&",
                    "    !node.open &&",
                    "    !node.close &&",
                    "    node.groups.length === 1",
                    "  ) {",
                    "    return flattenGroups(node.groups[0]);",
                    "  }",
                    "",
                    "  if (node.type === \"comma_group\" && node.groups.length === 1) {",
                    "    return flattenGroups(node.groups[0]);",
                    "  }",
                    "",
                    "  if (node.type === \"paren_group\" || node.type === \"comma_group\") {",
                    "    return { ...node, groups: node.groups.map(flattenGroups) };",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function addTypePrefix(node, prefix) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      addTypePrefix(node[key], prefix);",
                    "      if (key === \"type\" && typeof node[key] === \"string\") {",
                    "        if (!node[key].startsWith(prefix)) {",
                    "          node[key] = prefix + node[key];",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function addMissingType(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      addMissingType(node[key]);",
                    "    }",
                    "    if (!Array.isArray(node) && node.value && !node.type) {",
                    "      node.type = \"unknown\";",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parseNestedValue(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      parseNestedValue(node[key]);",
                    "      if (key === \"nodes\") {",
                    "        node.group = flattenGroups(parseValueNodes(node[key]));",
                    "        delete node[key];",
                    "      }",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parseValue(value) {",
                    "  const valueParser = require(\"postcss-values-parser\");",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    result = valueParser(value, { loose: true }).parse();",
                    "  } catch (e) {",
                    "    return {",
                    "      type: \"value-unknown\",",
                    "      value,",
                    "    };",
                    "  }",
                    "",
                    "  result.text = value;",
                    "",
                    "  const parsedResult = parseNestedValue(result);",
                    "",
                    "  return addTypePrefix(parsedResult, \"value-\");",
                    "}",
                    "",
                    "function parseSelector(selector) {",
                    "  // If there's a comment inside of a selector, the parser tries to parse",
                    "  // the content of the comment as selectors which turns it into complete",
                    "  // garbage. Better to print the whole selector as-is and not try to parse",
                    "  // and reformat it.",
                    "  if (/\\/\\/|\\/\\*/.test(selector)) {",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: selector.trim(),",
                    "    };",
                    "  }",
                    "",
                    "  const selectorParser = require(\"postcss-selector-parser\");",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    selectorParser((result_) => {",
                    "      result = result_;",
                    "    }).process(selector);",
                    "  } catch (e) {",
                    "    // Fail silently. It's better to print it as is than to try and parse it",
                    "    // Note: A common failure is for SCSS nested properties. `background:",
                    "    // none { color: red; }` is parsed as a NestedDeclaration by",
                    "    // postcss-scss, while `background: { color: red; }` is parsed as a Rule",
                    "    // with a selector ending with a colon. See:",
                    "    // https://github.com/postcss/postcss-scss/issues/39",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: selector,",
                    "    };",
                    "  }",
                    "",
                    "  return addTypePrefix(result, \"selector-\");",
                    "}",
                    "",
                    "function parseMediaQuery(params) {",
                    "  const mediaParser = require(\"postcss-media-query-parser\").default;",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    result = mediaParser(params);",
                    "  } catch (e) {",
                    "    // Ignore bad media queries",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: params,",
                    "    };",
                    "  }",
                    "",
                    "  return addTypePrefix(addMissingType(result), \"media-\");",
                    "}",
                    "",
                    "const DEFAULT_SCSS_DIRECTIVE = /(\\s*?)(!default).*$/;",
                    "const GLOBAL_SCSS_DIRECTIVE = /(\\s*?)(!global).*$/;",
                    "",
                    "function parseNestedCSS(node, options) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "",
                    "    for (const key in node) {",
                    "      parseNestedCSS(node[key], options);",
                    "    }",
                    "",
                    "    if (!node.type) {",
                    "      return node;",
                    "    }",
                    "",
                    "    if (!node.raws) {",
                    "      node.raws = {};",
                    "    }",
                    "",
                    "    let selector = \"\";",
                    "",
                    "    if (typeof node.selector === \"string\") {",
                    "      selector = node.raws.selector",
                    "        ? node.raws.selector.scss",
                    "          ? node.raws.selector.scss",
                    "          : node.raws.selector.raw",
                    "        : node.selector;",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        selector += node.raws.between;",
                    "      }",
                    "",
                    "      node.raws.selector = selector;",
                    "    }",
                    "",
                    "    let value = \"\";",
                    "",
                    "    if (typeof node.value === \"string\") {",
                    "      value = node.raws.value",
                    "        ? node.raws.value.scss",
                    "          ? node.raws.value.scss",
                    "          : node.raws.value.raw",
                    "        : node.value;",
                    "",
                    "      value = value.trim();",
                    "",
                    "      node.raws.value = value;",
                    "    }",
                    "",
                    "    let params = \"\";",
                    "",
                    "    if (typeof node.params === \"string\") {",
                    "      params = node.raws.params",
                    "        ? node.raws.params.scss",
                    "          ? node.raws.params.scss",
                    "          : node.raws.params.raw",
                    "        : node.params;",
                    "",
                    "      if (node.raws.afterName && node.raws.afterName.trim().length > 0) {",
                    "        params = node.raws.afterName + params;",
                    "      }",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        params = params + node.raws.between;",
                    "      }",
                    "",
                    "      params = params.trim();",
                    "",
                    "      node.raws.params = params;",
                    "    }",
                    "",
                    "    // Ignore LESS mixin declaration",
                    "    if (selector.trim().length > 0) {",
                    "      if (selector.startsWith(\"@\") && selector.endsWith(\":\")) {",
                    "        return node;",
                    "      }",
                    "",
                    "      // Ignore LESS mixins",
                    "      if (node.mixin) {",
                    "        node.selector = parseValue(selector);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      // Check on SCSS nested property",
                    "      if (isSCSSNestedPropertyNode(node)) {",
                    "        node.isSCSSNesterProperty = true;",
                    "      }",
                    "",
                    "      node.selector = parseSelector(selector);",
                    "",
                    "      return node;",
                    "    }",
                    "",
                    "    if (value.length > 0) {",
                    "      const defaultSCSSDirectiveIndex = value.match(DEFAULT_SCSS_DIRECTIVE);",
                    "",
                    "      if (defaultSCSSDirectiveIndex) {",
                    "        value = value.slice(0, defaultSCSSDirectiveIndex.index);",
                    "        node.scssDefault = true;",
                    "",
                    "        if (defaultSCSSDirectiveIndex[0].trim() !== \"!default\") {",
                    "          node.raws.scssDefault = defaultSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      const globalSCSSDirectiveIndex = value.match(GLOBAL_SCSS_DIRECTIVE);",
                    "",
                    "      if (globalSCSSDirectiveIndex) {",
                    "        value = value.slice(0, globalSCSSDirectiveIndex.index);",
                    "        node.scssGlobal = true;",
                    "",
                    "        if (globalSCSSDirectiveIndex[0].trim() !== \"!global\") {",
                    "          node.raws.scssGlobal = globalSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      if (value.startsWith(\"progid:\")) {",
                    "        return {",
                    "          type: \"value-unknown\",",
                    "          value,",
                    "        };",
                    "      }",
                    "",
                    "      node.value = parseValue(value);",
                    "    }",
                    "",
                    "    if (",
                    "      isLessParser(options) &&",
                    "      node.type === \"css-decl\" &&",
                    "      value.startsWith(\"extend(\")",
                    "    ) {",
                    "      // extend is missing",
                    "      if (!node.extend) {",
                    "        node.extend = node.raws.between === \":\";",
                    "      }",
                    "",
                    "      // `:extend()` is parsed as value",
                    "      if (node.extend && !node.selector) {",
                    "        delete node.value;",
                    "        node.selector = parseSelector(value.slice(\"extend(\".length, -1));",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\") {",
                    "      if (isLessParser(options)) {",
                    "        // mixin",
                    "        if (node.mixin) {",
                    "          const source =",
                    "            node.raws.identifier +",
                    "            node.name +",
                    "            node.raws.afterName +",
                    "            node.raws.params;",
                    "          node.selector = parseSelector(source);",
                    "          delete node.params;",
                    "          return node;",
                    "        }",
                    "",
                    "        // function",
                    "        if (node.function) {",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      // only css support custom-selector",
                    "      if (options.parser === \"css\" && node.name === \"custom-selector\") {",
                    "        const customSelector = node.params.match(/:--\\S+?\\s+/)[0].trim();",
                    "        node.customSelector = customSelector;",
                    "        node.selector = parseSelector(",
                    "          node.params.slice(customSelector.length).trim()",
                    "        );",
                    "        delete node.params;",
                    "        return node;",
                    "      }",
                    "",
                    "      if (isLessParser(options)) {",
                    "        // Whitespace between variable and colon",
                    "        if (node.name.includes(\":\") && !node.params) {",
                    "          node.variable = true;",
                    "          const parts = node.name.split(\":\");",
                    "          node.name = parts[0];",
                    "          node.value = parseValue(parts.slice(1).join(\":\"));",
                    "        }",
                    "",
                    "        // Missing whitespace between variable and colon",
                    "        if (",
                    "          ![\"page\", \"nest\"].includes(node.name) &&",
                    "          node.params &&",
                    "          node.params[0] === \":\"",
                    "        ) {",
                    "          node.variable = true;",
                    "          node.value = parseValue(node.params.slice(1));",
                    "        }",
                    "",
                    "        // Less variable",
                    "        if (node.variable) {",
                    "          delete node.params;",
                    "          return node;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\" && params.length > 0) {",
                    "      const { name } = node;",
                    "      const lowercasedName = node.name.toLowerCase();",
                    "",
                    "      if (name === \"warn\" || name === \"error\") {",
                    "        node.params = {",
                    "          type: \"media-unknown\",",
                    "          value: params,",
                    "        };",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"extend\" || name === \"nest\") {",
                    "        node.selector = parseSelector(params);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"at-root\") {",
                    "        if (/^\\(\\s*(without|with)\\s*:[\\S\\s]+\\)$/.test(params)) {",
                    "          node.params = parseValue(params);",
                    "        } else {",
                    "          node.selector = parseSelector(params);",
                    "          delete node.params;",
                    "        }",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (lowercasedName === \"import\") {",
                    "        node.import = true;",
                    "        delete node.filename;",
                    "        node.params = parseValue(params);",
                    "        return node;",
                    "      }",
                    "",
                    "      if (",
                    "        [",
                    "          \"namespace\",",
                    "          \"supports\",",
                    "          \"if\",",
                    "          \"else\",",
                    "          \"for\",",
                    "          \"each\",",
                    "          \"while\",",
                    "          \"debug\",",
                    "          \"mixin\",",
                    "          \"include\",",
                    "          \"function\",",
                    "          \"return\",",
                    "          \"define-mixin\",",
                    "          \"add-mixin\",",
                    "        ].includes(name)",
                    "      ) {",
                    "        // Remove unnecessary spaces in SCSS variable arguments",
                    "        params = params.replace(/(\\$\\S+?)\\s+?\\.{3}/, \"$1...\");",
                    "        // Remove unnecessary spaces before SCSS control, mixin and function directives",
                    "        params = params.replace(/^(?!if)(\\S+)\\s+\\(/, \"$1(\");",
                    "",
                    "        node.value = parseValue(params);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if ([\"media\", \"custom-media\"].includes(lowercasedName)) {",
                    "        if (params.includes(\"#{\")) {",
                    "          // Workaround for media at rule with scss interpolation",
                    "          return {",
                    "            type: \"media-unknown\",",
                    "            value: params,",
                    "          };",
                    "        }",
                    "",
                    "        node.params = parseMediaQuery(params);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      node.params = params;",
                    "",
                    "      return node;",
                    "    }",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function parseWithParser(parse, text, options) {",
                    "  const parsed = parseFrontMatter(text);",
                    "  const { frontMatter } = parsed;",
                    "  text = parsed.content;",
                    "",
                    "  let result;",
                    "",
                    "  try {",
                    "    result = parse(text);",
                    "  } catch (e) {",
                    "    if (typeof e.line !== \"number\") {",
                    "      throw e;",
                    "    }",
                    "    throw createError(\"(postcss) \" + e.name + \" \" + e.reason, { start: e });",
                    "  }",
                    "",
                    "  result = parseNestedCSS(addTypePrefix(result, \"css-\"), options);",
                    "",
                    "  calculateLoc(result, text);",
                    "",
                    "  if (frontMatter) {",
                    "    result.nodes.unshift(frontMatter);",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "// TODO: make this only work on css",
                    "function parseCss(text, parsers, options) {",
                    "  const isSCSSParser = isSCSS(options.parser, text);",
                    "  const parseFunctions = isSCSSParser",
                    "    ? [parseScss, parseLess]",
                    "    : [parseLess, parseScss];",
                    "",
                    "  let error;",
                    "  for (const parse of parseFunctions) {",
                    "    try {",
                    "      return parse(text, parsers, options);",
                    "    } catch (parseError) {",
                    "      error = error || parseError;",
                    "    }",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (error) {",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "function parseLess(text, parsers, options) {",
                    "  const lessParser = require(\"postcss-less\");",
                    "  return parseWithParser(",
                    "    // Workaround for https://github.com/shellscape/postcss-less/issues/145",
                    "    // See comments for `replaceQuotesInInlineComments` in `loc.js`.",
                    "    (text) => lessParser.parse(replaceQuotesInInlineComments(text)),",
                    "    text,",
                    "    options",
                    "  );",
                    "}",
                    "",
                    "function parseScss(text, parsers, options) {",
                    "  const { parse } = require(\"postcss-scss\");",
                    "  return parseWithParser(parse, text, options);",
                    "}",
                    "",
                    "const postCssParser = {",
                    "  astFormat: \"postcss\",",
                    "  hasPragma,",
                    "  locStart(node) {",
                    "    if (node.source) {",
                    "      return node.source.startOffset;",
                    "    }",
                    "    /* istanbul ignore next */",
                    "    return null;",
                    "  },",
                    "  locEnd(node) {",
                    "    if (node.source) {",
                    "      return node.source.endOffset;",
                    "    }",
                    "    return null;",
                    "  },",
                    "};",
                    "",
                    "// Export as a plugin so we can reuse the same bundle for UMD loading",
                    "module.exports = {",
                    "  parsers: {",
                    "    css: {",
                    "      ...postCssParser,",
                    "      parse: parseCss,",
                    "    },",
                    "    less: {",
                    "      ...postCssParser,",
                    "      parse: parseLess,",
                    "    },",
                    "    scss: {",
                    "      ...postCssParser,",
                    "      parse: parseScss,",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const jsPragma = require(\"../language-js/pragma\");",
                    "const parseFrontMatter = require(\"../utils/front-matter\");",
                    "",
                    "function hasPragma(text) {",
                    "  return jsPragma.hasPragma(parseFrontMatter(text).content);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  const { frontMatter, content } = parseFrontMatter(text);",
                    "  return (",
                    "    (frontMatter ? frontMatter.raw + \"\\n\\n\" : \"\") +",
                    "    jsPragma.insertPragma(content)",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "printer-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const clean = require(\"./clean\");",
                    "const embed = require(\"./embed\");",
                    "const { insertPragma } = require(\"./pragma\");",
                    "const {",
                    "  printNumber,",
                    "  printString,",
                    "  hasIgnoreComment,",
                    "  hasNewline,",
                    "  isFrontMatterNode,",
                    "} = require(\"../common/util\");",
                    "const { isNextLineEmpty } = require(\"../common/util-shared\");",
                    "",
                    "const {",
                    "  builders: {",
                    "    concat,",
                    "    join,",
                    "    line,",
                    "    hardline,",
                    "    softline,",
                    "    group,",
                    "    fill,",
                    "    indent,",
                    "    dedent,",
                    "    ifBreak,",
                    "  },",
                    "  utils: { removeLines },",
                    "} = require(\"../document\");",
                    "",
                    "const {",
                    "  getAncestorNode,",
                    "  getPropOfDeclNode,",
                    "  maybeToLowerCase,",
                    "  insideValueFunctionNode,",
                    "  insideICSSRuleNode,",
                    "  insideAtRuleNode,",
                    "  insideURLFunctionInImportAtRuleNode,",
                    "  isKeyframeAtRuleKeywords,",
                    "  isWideKeywords,",
                    "  isSCSS,",
                    "  isLastNode,",
                    "  isLessParser,",
                    "  isSCSSControlDirectiveNode,",
                    "  isDetachedRulesetDeclarationNode,",
                    "  isRelationalOperatorNode,",
                    "  isEqualityOperatorNode,",
                    "  isMultiplicationNode,",
                    "  isDivisionNode,",
                    "  isAdditionNode,",
                    "  isSubtractionNode,",
                    "  isMathOperatorNode,",
                    "  isEachKeywordNode,",
                    "  isForKeywordNode,",
                    "  isURLFunctionNode,",
                    "  isIfElseKeywordNode,",
                    "  hasComposesNode,",
                    "  hasParensAroundNode,",
                    "  hasEmptyRawBefore,",
                    "  isKeyValuePairNode,",
                    "  isDetachedRulesetCallNode,",
                    "  isTemplatePlaceholderNode,",
                    "  isTemplatePropNode,",
                    "  isPostcssSimpleVarNode,",
                    "  isSCSSMapItemNode,",
                    "  isInlineValueCommentNode,",
                    "  isHashNode,",
                    "  isLeftCurlyBraceNode,",
                    "  isRightCurlyBraceNode,",
                    "  isWordNode,",
                    "  isColonNode,",
                    "  isMediaAndSupportsKeywords,",
                    "  isColorAdjusterFuncNode,",
                    "  lastLineHasInlineComment,",
                    "} = require(\"./utils\");",
                    "",
                    "function shouldPrintComma(options) {",
                    "  switch (options.trailingComma) {",
                    "    case \"all\":",
                    "    case \"es5\":",
                    "      return true;",
                    "    case \"none\":",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  /* istanbul ignore if */",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof node === \"string\") {",
                    "    return node;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return concat([node.raw, hardline]);",
                    "    case \"css-root\": {",
                    "      const nodes = printNodeSequence(path, options, print);",
                    "",
                    "      if (nodes.parts.length) {",
                    "        return concat([nodes, options.__isHTMLStyleAttribute ? \"\" : hardline]);",
                    "      }",
                    "",
                    "      return nodes;",
                    "    }",
                    "    case \"css-comment\": {",
                    "      const isInlineComment = node.inline || node.raws.inline;",
                    "      const text = options.originalText.slice(",
                    "        options.locStart(node),",
                    "        options.locEnd(node)",
                    "      );",
                    "",
                    "      return isInlineComment ? text.trimEnd() : text;",
                    "    }",
                    "    case \"css-rule\": {",
                    "      return concat([",
                    "        path.call(print, \"selector\"),",
                    "        node.important ? \" !important\" : \"\",",
                    "        node.nodes",
                    "          ? concat([",
                    "              node.selector &&",
                    "              node.selector.type === \"selector-unknown\" &&",
                    "              lastLineHasInlineComment(node.selector.value)",
                    "                ? line",
                    "                : \" \",",
                    "              \"{\",",
                    "              node.nodes.length > 0",
                    "                ? indent(",
                    "                    concat([hardline, printNodeSequence(path, options, print)])",
                    "                  )",
                    "                : \"\",",
                    "              hardline,",
                    "              \"}\",",
                    "              isDetachedRulesetDeclarationNode(node) ? \";\" : \"\",",
                    "            ])",
                    "          : \";\",",
                    "      ]);",
                    "    }",
                    "    case \"css-decl\": {",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      const { between: rawBetween } = node.raws;",
                    "      const trimmedBetween = rawBetween.trim();",
                    "      const isColon = trimmedBetween === \":\";",
                    "",
                    "      let value = hasComposesNode(node)",
                    "        ? removeLines(path.call(print, \"value\"))",
                    "        : path.call(print, \"value\");",
                    "",
                    "      if (!isColon && lastLineHasInlineComment(trimmedBetween)) {",
                    "        value = indent(concat([hardline, dedent(value)]));",
                    "      }",
                    "",
                    "      return concat([",
                    "        node.raws.before.replace(/[\\s;]/g, \"\"),",
                    "        insideICSSRuleNode(path) ? node.prop : maybeToLowerCase(node.prop),",
                    "        trimmedBetween.startsWith(\"//\") ? \" \" : \"\",",
                    "        trimmedBetween,",
                    "        node.extend ? \"\" : \" \",",
                    "        isLessParser(options) && node.extend && node.selector",
                    "          ? concat([\"extend(\", path.call(print, \"selector\"), \")\"])",
                    "          : \"\",",
                    "        value,",
                    "        node.raws.important",
                    "          ? node.raws.important.replace(/\\s*!\\s*important/i, \" !important\")",
                    "          : node.important",
                    "          ? \" !important\"",
                    "          : \"\",",
                    "        node.raws.scssDefault",
                    "          ? node.raws.scssDefault.replace(/\\s*!default/i, \" !default\")",
                    "          : node.scssDefault",
                    "          ? \" !default\"",
                    "          : \"\",",
                    "        node.raws.scssGlobal",
                    "          ? node.raws.scssGlobal.replace(/\\s*!global/i, \" !global\")",
                    "          : node.scssGlobal",
                    "          ? \" !global\"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([softline, printNodeSequence(path, options, print)])",
                    "              ),",
                    "              softline,",
                    "              \"}\",",
                    "            ])",
                    "          : isTemplatePropNode(node) &&",
                    "            !parentNode.raws.semicolon &&",
                    "            options.originalText[options.locEnd(node) - 1] !== \";\"",
                    "          ? \"\"",
                    "          : options.__isHTMLStyleAttribute && isLastNode(path, node)",
                    "          ? ifBreak(\";\", \"\")",
                    "          : \";\",",
                    "      ]);",
                    "    }",
                    "    case \"css-atrule\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const isTemplatePlaceholderNodeWithoutSemiColon =",
                    "        isTemplatePlaceholderNode(node) &&",
                    "        !parentNode.raws.semicolon &&",
                    "        options.originalText[options.locEnd(node) - 1] !== \";\";",
                    "",
                    "      if (isLessParser(options)) {",
                    "        if (node.mixin) {",
                    "          return concat([",
                    "            path.call(print, \"selector\"),",
                    "            node.important ? \" !important\" : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ]);",
                    "        }",
                    "",
                    "        if (node.function) {",
                    "          return concat([",
                    "            node.name,",
                    "            concat([path.call(print, \"params\")]),",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ]);",
                    "        }",
                    "",
                    "        if (node.variable) {",
                    "          return concat([",
                    "            \"@\",",
                    "            node.name,",
                    "            \": \",",
                    "            node.value ? concat([path.call(print, \"value\")]) : \"\",",
                    "            node.raws.between.trim() ? node.raws.between.trim() + \" \" : \"\",",
                    "            node.nodes",
                    "              ? concat([",
                    "                  \"{\",",
                    "                  indent(",
                    "                    concat([",
                    "                      node.nodes.length > 0 ? softline : \"\",",
                    "                      printNodeSequence(path, options, print),",
                    "                    ])",
                    "                  ),",
                    "                  softline,",
                    "                  \"}\",",
                    "                ])",
                    "              : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ]);",
                    "        }",
                    "      }",
                    "",
                    "      return concat([",
                    "        \"@\",",
                    "        // If a Less file ends up being parsed with the SCSS parser, Less",
                    "        // variable declarations will be parsed as at-rules with names ending",
                    "        // with a colon, so keep the original case then.",
                    "        isDetachedRulesetCallNode(node) || node.name.endsWith(\":\")",
                    "          ? node.name",
                    "          : maybeToLowerCase(node.name),",
                    "        node.params",
                    "          ? concat([",
                    "              isDetachedRulesetCallNode(node)",
                    "                ? \"\"",
                    "                : isTemplatePlaceholderNode(node)",
                    "                ? node.raws.afterName === \"\"",
                    "                  ? \"\"",
                    "                  : node.name.endsWith(\":\")",
                    "                  ? \" \"",
                    "                  : /^\\s*\\n\\s*\\n/.test(node.raws.afterName)",
                    "                  ? concat([hardline, hardline])",
                    "                  : /^\\s*\\n/.test(node.raws.afterName)",
                    "                  ? hardline",
                    "                  : \" \"",
                    "                : \" \",",
                    "              path.call(print, \"params\"),",
                    "            ])",
                    "          : \"\",",
                    "        node.selector",
                    "          ? indent(concat([\" \", path.call(print, \"selector\")]))",
                    "          : \"\",",
                    "        node.value",
                    "          ? group(",
                    "              concat([",
                    "                \" \",",
                    "                path.call(print, \"value\"),",
                    "                isSCSSControlDirectiveNode(node)",
                    "                  ? hasParensAroundNode(node)",
                    "                    ? \" \"",
                    "                    : line",
                    "                  : \"\",",
                    "              ])",
                    "            )",
                    "          : node.name === \"else\"",
                    "          ? \" \"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? concat([",
                    "              isSCSSControlDirectiveNode(node)",
                    "                ? \"\"",
                    "                : (node.selector &&",
                    "                    !node.selector.nodes &&",
                    "                    typeof node.selector.value === \"string\" &&",
                    "                    lastLineHasInlineComment(node.selector.value)) ||",
                    "                  (!node.selector &&",
                    "                    typeof node.params === \"string\" &&",
                    "                    lastLineHasInlineComment(node.params))",
                    "                ? line",
                    "                : \" \",",
                    "              \"{\",",
                    "              indent(",
                    "                concat([",
                    "                  node.nodes.length > 0 ? softline : \"\",",
                    "                  printNodeSequence(path, options, print),",
                    "                ])",
                    "              ),",
                    "              softline,",
                    "              \"}\",",
                    "            ])",
                    "          : isTemplatePlaceholderNodeWithoutSemiColon",
                    "          ? \"\"",
                    "          : \";\",",
                    "      ]);",
                    "    }",
                    "    // postcss-media-query-parser",
                    "    case \"media-query-list\": {",
                    "      const parts = [];",
                    "      path.each((childPath) => {",
                    "        const node = childPath.getValue();",
                    "        if (node.type === \"media-query\" && node.value === \"\") {",
                    "          return;",
                    "        }",
                    "        parts.push(childPath.call(print));",
                    "      }, \"nodes\");",
                    "",
                    "      return group(indent(join(line, parts)));",
                    "    }",
                    "    case \"media-query\": {",
                    "      return concat([",
                    "        join(\" \", path.map(print, \"nodes\")),",
                    "        isLastNode(path, node) ? \"\" : \",\",",
                    "      ]);",
                    "    }",
                    "    case \"media-type\": {",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "    }",
                    "    case \"media-feature-expression\": {",
                    "      if (!node.nodes) {",
                    "        return node.value;",
                    "      }",
                    "      return concat([\"(\", concat(path.map(print, \"nodes\")), \")\"]);",
                    "    }",
                    "    case \"media-feature\": {",
                    "      return maybeToLowerCase(",
                    "        adjustStrings(node.value.replace(/ +/g, \" \"), options)",
                    "      );",
                    "    }",
                    "    case \"media-colon\": {",
                    "      return concat([node.value, \" \"]);",
                    "    }",
                    "    case \"media-value\": {",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "    }",
                    "    case \"media-keyword\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    case \"media-url\": {",
                    "      return adjustStrings(",
                    "        node.value.replace(/^url\\(\\s+/gi, \"url(\").replace(/\\s+\\)$/gi, \")\"),",
                    "        options",
                    "      );",
                    "    }",
                    "    case \"media-unknown\": {",
                    "      return node.value;",
                    "    }",
                    "    // postcss-selector-parser",
                    "    case \"selector-root\": {",
                    "      return group(",
                    "        concat([",
                    "          insideAtRuleNode(path, \"custom-selector\")",
                    "            ? concat([getAncestorNode(path, \"css-atrule\").customSelector, line])",
                    "            : \"\",",
                    "          join(",
                    "            concat([",
                    "              \",\",",
                    "              insideAtRuleNode(path, [\"extend\", \"custom-selector\", \"nest\"])",
                    "                ? line",
                    "                : hardline,",
                    "            ]),",
                    "            path.map(print, \"nodes\")",
                    "          ),",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"selector-selector\": {",
                    "      return group(indent(concat(path.map(print, \"nodes\"))));",
                    "    }",
                    "    case \"selector-comment\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"selector-string\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    case \"selector-tag\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode && parentNode.nodes.indexOf(node);",
                    "      const prevNode = index && parentNode.nodes[index - 1];",
                    "",
                    "      return concat([",
                    "        node.namespace",
                    "          ? concat([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"])",
                    "          : \"\",",
                    "        prevNode.type === \"selector-nesting\"",
                    "          ? node.value",
                    "          : adjustNumbers(",
                    "              isKeyframeAtRuleKeywords(path, node.value)",
                    "                ? node.value.toLowerCase()",
                    "                : node.value",
                    "            ),",
                    "      ]);",
                    "    }",
                    "    case \"selector-id\": {",
                    "      return concat([\"#\", node.value]);",
                    "    }",
                    "    case \"selector-class\": {",
                    "      return concat([\".\", adjustNumbers(adjustStrings(node.value, options))]);",
                    "    }",
                    "    case \"selector-attribute\": {",
                    "      return concat([",
                    "        \"[\",",
                    "        node.namespace",
                    "          ? concat([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"])",
                    "          : \"\",",
                    "        node.attribute.trim(),",
                    "        node.operator ? node.operator : \"\",",
                    "        node.value",
                    "          ? quoteAttributeValue(",
                    "              adjustStrings(node.value.trim(), options),",
                    "              options",
                    "            )",
                    "          : \"\",",
                    "        node.insensitive ? \" i\" : \"\",",
                    "        \"]\",",
                    "      ]);",
                    "    }",
                    "    case \"selector-combinator\": {",
                    "      if (",
                    "        node.value === \"+\" ||",
                    "        node.value === \">\" ||",
                    "        node.value === \"~\" ||",
                    "        node.value === \">>>\"",
                    "      ) {",
                    "        const parentNode = path.getParentNode();",
                    "        const leading =",
                    "          parentNode.type === \"selector-selector\" &&",
                    "          parentNode.nodes[0] === node",
                    "            ? \"\"",
                    "            : line;",
                    "",
                    "        return concat([leading, node.value, isLastNode(path, node) ? \"\" : \" \"]);",
                    "      }",
                    "",
                    "      const leading = node.value.trim().startsWith(\"(\") ? line : \"\";",
                    "      const value =",
                    "        adjustNumbers(adjustStrings(node.value.trim(), options)) || line;",
                    "",
                    "      return concat([leading, value]);",
                    "    }",
                    "    case \"selector-universal\": {",
                    "      return concat([",
                    "        node.namespace",
                    "          ? concat([node.namespace === true ? \"\" : node.namespace.trim(), \"|\"])",
                    "          : \"\",",
                    "        node.value,",
                    "      ]);",
                    "    }",
                    "    case \"selector-pseudo\": {",
                    "      return concat([",
                    "        maybeToLowerCase(node.value),",
                    "        node.nodes && node.nodes.length > 0",
                    "          ? concat([\"(\", join(\", \", path.map(print, \"nodes\")), \")\"])",
                    "          : \"\",",
                    "      ]);",
                    "    }",
                    "    case \"selector-nesting\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"selector-unknown\": {",
                    "      const ruleAncestorNode = getAncestorNode(path, \"css-rule\");",
                    "",
                    "      // Nested SCSS property",
                    "      if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {",
                    "        return adjustNumbers(",
                    "          adjustStrings(maybeToLowerCase(node.value), options)",
                    "        );",
                    "      }",
                    "",
                    "      // originalText has to be used for Less, see replaceQuotesInInlineComments in loc.js",
                    "      const parentNode = path.getParentNode();",
                    "      if (parentNode.raws && parentNode.raws.selector) {",
                    "        const start = options.locStart(parentNode);",
                    "        const end = start + parentNode.raws.selector.length;",
                    "        return options.originalText.slice(start, end).trim();",
                    "      }",
                    "",
                    "      return node.value;",
                    "    }",
                    "    // postcss-values-parser",
                    "    case \"value-value\":",
                    "    case \"value-root\": {",
                    "      return path.call(print, \"group\");",
                    "    }",
                    "    case \"value-comment\": {",
                    "      return options.originalText.slice(",
                    "        options.locStart(node),",
                    "        options.locEnd(node)",
                    "      );",
                    "    }",
                    "    case \"value-comma_group\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const parentParentNode = path.getParentNode(1);",
                    "      const declAncestorProp = getPropOfDeclNode(path);",
                    "      const isGridValue =",
                    "        declAncestorProp &&",
                    "        parentNode.type === \"value-value\" &&",
                    "        (declAncestorProp === \"grid\" ||",
                    "          declAncestorProp.startsWith(\"grid-template\"));",
                    "      const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "      const isControlDirective =",
                    "        atRuleAncestorNode && isSCSSControlDirectiveNode(atRuleAncestorNode);",
                    "",
                    "      const printed = path.map(print, \"groups\");",
                    "      const parts = [];",
                    "      const insideURLFunction = insideValueFunctionNode(path, \"url\");",
                    "",
                    "      let insideSCSSInterpolationInString = false;",
                    "      let didBreak = false;",
                    "      for (let i = 0; i < node.groups.length; ++i) {",
                    "        parts.push(printed[i]);",
                    "",
                    "        const iPrevNode = node.groups[i - 1];",
                    "        const iNode = node.groups[i];",
                    "        const iNextNode = node.groups[i + 1];",
                    "        const iNextNextNode = node.groups[i + 2];",
                    "",
                    "        if (insideURLFunction) {",
                    "          if (",
                    "            (iNextNode && isAdditionNode(iNextNode)) ||",
                    "            isAdditionNode(iNode)",
                    "          ) {",
                    "            parts.push(\" \");",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore after latest node (i.e. before semicolon)",
                    "        if (!iNextNode) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // styled.div` background: var(--${one}); `",
                    "        if (",
                    "          iNode.type === \"value-word\" &&",
                    "          iNode.value.endsWith(\"-\") &&",
                    "          iNextNode.type === \"value-atword\" &&",
                    "          iNextNode.value.startsWith(\"prettier-placeholder-\")",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore spaces before/after string interpolation (i.e. `\"#{my-fn(\"_\")}\"`)",
                    "        const isStartSCSSInterpolationInString =",
                    "          iNode.type === \"value-string\" && iNode.value.startsWith(\"#{\");",
                    "        const isEndingSCSSInterpolationInString =",
                    "          insideSCSSInterpolationInString &&",
                    "          iNextNode.type === \"value-string\" &&",
                    "          iNextNode.value.endsWith(\"}\");",
                    "",
                    "        if (",
                    "          isStartSCSSInterpolationInString ||",
                    "          isEndingSCSSInterpolationInString",
                    "        ) {",
                    "          insideSCSSInterpolationInString = !insideSCSSInterpolationInString;",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        if (insideSCSSInterpolationInString) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore colon (i.e. `:`)",
                    "        if (isColonNode(iNode) || isColonNode(iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `@` in Less (i.e. `@@var;`)",
                    "        if (iNode.type === \"value-atword\" && iNode.value === \"\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `~` in Less (i.e. `content: ~\"^//* some horrible but needed css hack\";`)",
                    "        if (iNode.value === \"~\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore escape `\\`",
                    "        if (",
                    "          iNode.value &&",
                    "          iNode.value.includes(\"\\\\\") &&",
                    "          iNextNode &&",
                    "          iNextNode.type !== \"value-comment\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore escaped `/`",
                    "        if (",
                    "          iPrevNode &&",
                    "          iPrevNode.value &&",
                    "          iPrevNode.value.indexOf(\"\\\\\") === iPrevNode.value.length - 1 &&",
                    "          iNode.type === \"value-operator\" &&",
                    "          iNode.value === \"/\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `\\` (i.e. `$variable: \\@small;`)",
                    "        if (iNode.value === \"\\\\\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `$$` (i.e. `background-color: $$(style)Color;`)",
                    "        if (isPostcssSimpleVarNode(iNode, iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)",
                    "        if (",
                    "          isHashNode(iNode) ||",
                    "          isLeftCurlyBraceNode(iNode) ||",
                    "          isRightCurlyBraceNode(iNextNode) ||",
                    "          (isLeftCurlyBraceNode(iNextNode) && hasEmptyRawBefore(iNextNode)) ||",
                    "          (isRightCurlyBraceNode(iNode) && hasEmptyRawBefore(iNextNode))",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)",
                    "        if (iNode.value === \"--\" && isHashNode(iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Formatting math operations",
                    "        const isMathOperator = isMathOperatorNode(iNode);",
                    "        const isNextMathOperator = isMathOperatorNode(iNextNode);",
                    "",
                    "        // Print spaces before and after math operators beside SCSS interpolation as is",
                    "        // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)",
                    "        // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)",
                    "        if (",
                    "          ((isMathOperator && isHashNode(iNextNode)) ||",
                    "            (isNextMathOperator && isRightCurlyBraceNode(iNode))) &&",
                    "          hasEmptyRawBefore(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Print spaces before and after addition and subtraction math operators as is in `calc` function",
                    "        // due to the fact that it is not valid syntax",
                    "        // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)",
                    "        if (",
                    "          insideValueFunctionNode(path, \"calc\") &&",
                    "          (isAdditionNode(iNode) ||",
                    "            isAdditionNode(iNextNode) ||",
                    "            isSubtractionNode(iNode) ||",
                    "            isSubtractionNode(iNextNode)) &&",
                    "          hasEmptyRawBefore(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)",
                    "        // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.",
                    "        const isColorAdjusterNode =",
                    "          (isAdditionNode(iNode) || isSubtractionNode(iNode)) &&",
                    "          i === 0 &&",
                    "          (iNextNode.type === \"value-number\" || iNextNode.isHex) &&",
                    "          parentParentNode &&",
                    "          isColorAdjusterFuncNode(parentParentNode) &&",
                    "          !hasEmptyRawBefore(iNextNode);",
                    "",
                    "        const requireSpaceBeforeOperator =",
                    "          (iNextNextNode && iNextNextNode.type === \"value-func\") ||",
                    "          (iNextNextNode && isWordNode(iNextNextNode)) ||",
                    "          iNode.type === \"value-func\" ||",
                    "          isWordNode(iNode);",
                    "        const requireSpaceAfterOperator =",
                    "          iNextNode.type === \"value-func\" ||",
                    "          isWordNode(iNextNode) ||",
                    "          (iPrevNode && iPrevNode.type === \"value-func\") ||",
                    "          (iPrevNode && isWordNode(iPrevNode));",
                    "",
                    "        // Formatting `/`, `+`, `-` sign",
                    "        if (",
                    "          !(isMultiplicationNode(iNextNode) || isMultiplicationNode(iNode)) &&",
                    "          !insideValueFunctionNode(path, \"calc\") &&",
                    "          !isColorAdjusterNode &&",
                    "          ((isDivisionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                    "            (isDivisionNode(iNode) && !requireSpaceAfterOperator) ||",
                    "            (isAdditionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                    "            (isAdditionNode(iNode) && !requireSpaceAfterOperator) ||",
                    "            isSubtractionNode(iNextNode) ||",
                    "            isSubtractionNode(iNode)) &&",
                    "          (hasEmptyRawBefore(iNextNode) ||",
                    "            (isMathOperator &&",
                    "              (!iPrevNode || (iPrevNode && isMathOperatorNode(iPrevNode)))))",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Add `hardline` after inline comment (i.e. `// comment\\n foo: bar;`)",
                    "        if (isInlineValueCommentNode(iNode)) {",
                    "          if (parentNode.type === \"value-paren_group\") {",
                    "            parts.push(dedent(hardline));",
                    "            continue;",
                    "          }",
                    "          parts.push(hardline);",
                    "          continue;",
                    "        }",
                    "",
                    "        // Handle keywords in SCSS control directive",
                    "        if (",
                    "          isControlDirective &&",
                    "          (isEqualityOperatorNode(iNextNode) ||",
                    "            isRelationalOperatorNode(iNextNode) ||",
                    "            isIfElseKeywordNode(iNextNode) ||",
                    "            isEachKeywordNode(iNode) ||",
                    "            isForKeywordNode(iNode))",
                    "        ) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // At-rule `namespace` should be in one line",
                    "        if (",
                    "          atRuleAncestorNode &&",
                    "          atRuleAncestorNode.name.toLowerCase() === \"namespace\"",
                    "        ) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // Formatting `grid` property",
                    "        if (isGridValue) {",
                    "          if (",
                    "            iNode.source &&",
                    "            iNextNode.source &&",
                    "            iNode.source.start.line !== iNextNode.source.start.line",
                    "          ) {",
                    "            parts.push(hardline);",
                    "",
                    "            didBreak = true;",
                    "          } else {",
                    "            parts.push(\" \");",
                    "          }",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // Add `space` before next math operation",
                    "        // Note: `grip` property have `/` delimiter and it is not math operation, so",
                    "        // `grid` property handles above",
                    "        if (isNextMathOperator) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // Be default all values go through `line`",
                    "        parts.push(line);",
                    "      }",
                    "",
                    "      if (didBreak) {",
                    "        parts.unshift(hardline);",
                    "      }",
                    "",
                    "      if (isControlDirective) {",
                    "        return group(indent(concat(parts)));",
                    "      }",
                    "",
                    "      // Indent is not needed for import url when url is very long",
                    "      // and node has two groups",
                    "      // when type is value-comma_group",
                    "      // example @import url(\"verylongurl\") projection,tv",
                    "      if (insideURLFunctionInImportAtRuleNode(path)) {",
                    "        return group(fill(parts));",
                    "      }",
                    "",
                    "      return group(indent(fill(parts)));",
                    "    }",
                    "    case \"value-paren_group\": {",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      if (",
                    "        parentNode &&",
                    "        isURLFunctionNode(parentNode) &&",
                    "        (node.groups.length === 1 ||",
                    "          (node.groups.length > 0 &&",
                    "            node.groups[0].type === \"value-comma_group\" &&",
                    "            node.groups[0].groups.length > 0 &&",
                    "            node.groups[0].groups[0].type === \"value-word\" &&",
                    "            node.groups[0].groups[0].value.startsWith(\"data:\")))",
                    "      ) {",
                    "        return concat([",
                    "          node.open ? path.call(print, \"open\") : \"\",",
                    "          join(\",\", path.map(print, \"groups\")),",
                    "          node.close ? path.call(print, \"close\") : \"\",",
                    "        ]);",
                    "      }",
                    "",
                    "      if (!node.open) {",
                    "        const printed = path.map(print, \"groups\");",
                    "        const res = [];",
                    "",
                    "        for (let i = 0; i < printed.length; i++) {",
                    "          if (i !== 0) {",
                    "            res.push(concat([\",\", line]));",
                    "          }",
                    "          res.push(printed[i]);",
                    "        }",
                    "",
                    "        return group(indent(fill(res)));",
                    "      }",
                    "",
                    "      const isSCSSMapItem = isSCSSMapItemNode(path);",
                    "",
                    "      const lastItem = node.groups[node.groups.length - 1];",
                    "      const isLastItemComment = lastItem && lastItem.type === \"value-comment\";",
                    "",
                    "      return group(",
                    "        concat([",
                    "          node.open ? path.call(print, \"open\") : \"\",",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              join(",
                    "                concat([\",\", line]),",
                    "                path.map((childPath) => {",
                    "                  const node = childPath.getValue();",
                    "                  const printed = print(childPath);",
                    "",
                    "                  // Key/Value pair in open paren already indented",
                    "                  if (",
                    "                    isKeyValuePairNode(node) &&",
                    "                    node.type === \"value-comma_group\" &&",
                    "                    node.groups &&",
                    "                    node.groups[2] &&",
                    "                    node.groups[2].type === \"value-paren_group\"",
                    "                  ) {",
                    "                    printed.contents.contents.parts[1] = group(",
                    "                      printed.contents.contents.parts[1]",
                    "                    );",
                    "",
                    "                    return group(dedent(printed));",
                    "                  }",
                    "",
                    "                  return printed;",
                    "                }, \"groups\")",
                    "              ),",
                    "            ])",
                    "          ),",
                    "          ifBreak(",
                    "            !isLastItemComment &&",
                    "              isSCSS(options.parser, options.originalText) &&",
                    "              isSCSSMapItem &&",
                    "              shouldPrintComma(options)",
                    "              ? \",\"",
                    "              : \"\"",
                    "          ),",
                    "          softline,",
                    "          node.close ? path.call(print, \"close\") : \"\",",
                    "        ]),",
                    "        {",
                    "          shouldBreak: isSCSSMapItem,",
                    "        }",
                    "      );",
                    "    }",
                    "    case \"value-func\": {",
                    "      return concat([",
                    "        node.value,",
                    "        insideAtRuleNode(path, \"supports\") && isMediaAndSupportsKeywords(node)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        path.call(print, \"group\"),",
                    "      ]);",
                    "    }",
                    "    case \"value-paren\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-number\": {",
                    "      return concat([printCssNumber(node.value), maybeToLowerCase(node.unit)]);",
                    "    }",
                    "    case \"value-operator\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-word\": {",
                    "      if ((node.isColor && node.isHex) || isWideKeywords(node.value)) {",
                    "        return node.value.toLowerCase();",
                    "      }",
                    "",
                    "      return node.value;",
                    "    }",
                    "    case \"value-colon\": {",
                    "      return concat([",
                    "        node.value,",
                    "        // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)",
                    "        insideValueFunctionNode(path, \"url\") ? \"\" : line,",
                    "      ]);",
                    "    }",
                    "    case \"value-comma\": {",
                    "      return concat([node.value, \" \"]);",
                    "    }",
                    "    case \"value-string\": {",
                    "      return printString(",
                    "        node.raws.quote + node.value + node.raws.quote,",
                    "        options",
                    "      );",
                    "    }",
                    "    case \"value-atword\": {",
                    "      return concat([\"@\", node.value]);",
                    "    }",
                    "    case \"value-unicode-range\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-unknown\": {",
                    "      return node.value;",
                    "    }",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unknown postcss type ${JSON.stringify(node.type)}`);",
                    "  }",
                    "}",
                    "",
                    "function printNodeSequence(path, options, print) {",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "  let i = 0;",
                    "  path.map((pathChild) => {",
                    "    const prevNode = node.nodes[i - 1];",
                    "    if (",
                    "      prevNode &&",
                    "      prevNode.type === \"css-comment\" &&",
                    "      prevNode.text.trim() === \"prettier-ignore\"",
                    "    ) {",
                    "      const childNode = pathChild.getValue();",
                    "      parts.push(",
                    "        options.originalText.slice(",
                    "          options.locStart(childNode),",
                    "          options.locEnd(childNode)",
                    "        )",
                    "      );",
                    "    } else {",
                    "      parts.push(pathChild.call(print));",
                    "    }",
                    "",
                    "    if (i !== node.nodes.length - 1) {",
                    "      if (",
                    "        (node.nodes[i + 1].type === \"css-comment\" &&",
                    "          !hasNewline(",
                    "            options.originalText,",
                    "            options.locStart(node.nodes[i + 1]),",
                    "            { backwards: true }",
                    "          ) &&",
                    "          !isFrontMatterNode(node.nodes[i])) ||",
                    "        (node.nodes[i + 1].type === \"css-atrule\" &&",
                    "          node.nodes[i + 1].name === \"else\" &&",
                    "          node.nodes[i].type !== \"css-comment\")",
                    "      ) {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(options.__isHTMLStyleAttribute ? line : hardline);",
                    "        if (",
                    "          isNextLineEmpty(",
                    "            options.originalText,",
                    "            pathChild.getValue(),",
                    "            options.locEnd",
                    "          ) &&",
                    "          !isFrontMatterNode(node.nodes[i])",
                    "        ) {",
                    "          parts.push(hardline);",
                    "        }",
                    "      }",
                    "    }",
                    "    i++;",
                    "  }, \"nodes\");",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "const STRING_REGEX = /([\"'])(?:(?!\\1)[^\\\\]|\\\\[\\S\\s])*\\1/g;",
                    "const NUMBER_REGEX = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g;",
                    "const STANDARD_UNIT_REGEX = /[A-Za-z]+/g;",
                    "const WORD_PART_REGEX = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g;",
                    "const ADJUST_NUMBERS_REGEX = new RegExp(",
                    "  STRING_REGEX.source +",
                    "    \"|\" +",
                    "    `(${WORD_PART_REGEX.source})?` +",
                    "    `(${NUMBER_REGEX.source})` +",
                    "    `(${STANDARD_UNIT_REGEX.source})?`,",
                    "  \"g\"",
                    ");",
                    "",
                    "function adjustStrings(value, options) {",
                    "  return value.replace(STRING_REGEX, (match) => printString(match, options));",
                    "}",
                    "",
                    "function quoteAttributeValue(value, options) {",
                    "  const quote = options.singleQuote ? \"'\" : '\"';",
                    "  return value.includes('\"') || value.includes(\"'\")",
                    "    ? value",
                    "    : quote + value + quote;",
                    "}",
                    "",
                    "function adjustNumbers(value) {",
                    "  return value.replace(",
                    "    ADJUST_NUMBERS_REGEX,",
                    "    (match, quote, wordPart, number, unit) =>",
                    "      !wordPart && number",
                    "        ? printCssNumber(number) + maybeToLowerCase(unit || \"\")",
                    "        : match",
                    "  );",
                    "}",
                    "",
                    "function printCssNumber(rawNumber) {",
                    "  return (",
                    "    printNumber(rawNumber)",
                    "      // Remove trailing `.0`.",
                    "      .replace(/\\.0(?=$|e)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  hasPrettierIgnore: hasIgnoreComment,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const colorAdjusterFunctions = new Set([",
                    "  \"red\",",
                    "  \"green\",",
                    "  \"blue\",",
                    "  \"alpha\",",
                    "  \"a\",",
                    "  \"rgb\",",
                    "  \"hue\",",
                    "  \"h\",",
                    "  \"saturation\",",
                    "  \"s\",",
                    "  \"lightness\",",
                    "  \"l\",",
                    "  \"whiteness\",",
                    "  \"w\",",
                    "  \"blackness\",",
                    "  \"b\",",
                    "  \"tint\",",
                    "  \"shade\",",
                    "  \"blend\",",
                    "  \"blenda\",",
                    "  \"contrast\",",
                    "  \"hsl\",",
                    "  \"hsla\",",
                    "  \"hwb\",",
                    "  \"hwba\",",
                    "]);",
                    "",
                    "function getAncestorCounter(path, typeOrTypes) {",
                    "  const types = [].concat(typeOrTypes);",
                    "",
                    "  let counter = -1;",
                    "  let ancestorNode;",
                    "",
                    "  while ((ancestorNode = path.getParentNode(++counter))) {",
                    "    if (types.includes(ancestorNode.type)) {",
                    "      return counter;",
                    "    }",
                    "  }",
                    "",
                    "  return -1;",
                    "}",
                    "",
                    "function getAncestorNode(path, typeOrTypes) {",
                    "  const counter = getAncestorCounter(path, typeOrTypes);",
                    "  return counter === -1 ? null : path.getParentNode(counter);",
                    "}",
                    "",
                    "function getPropOfDeclNode(path) {",
                    "  const declAncestorNode = getAncestorNode(path, \"css-decl\");",
                    "",
                    "  return (",
                    "    declAncestorNode &&",
                    "    declAncestorNode.prop &&",
                    "    declAncestorNode.prop.toLowerCase()",
                    "  );",
                    "}",
                    "",
                    "function hasSCSSInterpolation(groupList) {",
                    "  if (groupList && groupList.length) {",
                    "    for (let i = groupList.length - 1; i > 0; i--) {",
                    "      // If we find `#{`, return true.",
                    "      if (",
                    "        groupList[i].type === \"word\" &&",
                    "        groupList[i].value === \"{\" &&",
                    "        groupList[i - 1].type === \"word\" &&",
                    "        groupList[i - 1].value.endsWith(\"#\")",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function hasStringOrFunction(groupList) {",
                    "  if (groupList && groupList.length) {",
                    "    for (let i = 0; i < groupList.length; i++) {",
                    "      if (groupList[i].type === \"string\" || groupList[i].type === \"func\") {",
                    "        return true;",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function isSCSS(parser, text) {",
                    "  const hasExplicitParserChoice = parser === \"less\" || parser === \"scss\";",
                    "  const IS_POSSIBLY_SCSS = /(\\w\\s*:\\s*[^:}]+|#){|@import[^\\n]+(?:url|,)/;",
                    "  return hasExplicitParserChoice",
                    "    ? parser === \"scss\"",
                    "    : IS_POSSIBLY_SCSS.test(text);",
                    "}",
                    "",
                    "function isSCSSVariable(node) {",
                    "  return !!(node && node.type === \"word\" && node.value.startsWith(\"$\"));",
                    "}",
                    "",
                    "function isWideKeywords(value) {",
                    "  return [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(",
                    "    value.toLowerCase()",
                    "  );",
                    "}",
                    "",
                    "function isKeyframeAtRuleKeywords(path, value) {",
                    "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "  return (",
                    "    atRuleAncestorNode &&",
                    "    atRuleAncestorNode.name &&",
                    "    atRuleAncestorNode.name.toLowerCase().endsWith(\"keyframes\") &&",
                    "    [\"from\", \"to\"].includes(value.toLowerCase())",
                    "  );",
                    "}",
                    "",
                    "function maybeToLowerCase(value) {",
                    "  return value.includes(\"$\") ||",
                    "    value.includes(\"@\") ||",
                    "    value.includes(\"#\") ||",
                    "    value.startsWith(\"%\") ||",
                    "    value.startsWith(\"--\") ||",
                    "    value.startsWith(\":--\") ||",
                    "    (value.includes(\"(\") && value.includes(\")\"))",
                    "    ? value",
                    "    : value.toLowerCase();",
                    "}",
                    "",
                    "function insideValueFunctionNode(path, functionName) {",
                    "  const funcAncestorNode = getAncestorNode(path, \"value-func\");",
                    "  return (",
                    "    funcAncestorNode &&",
                    "    funcAncestorNode.value &&",
                    "    funcAncestorNode.value.toLowerCase() === functionName",
                    "  );",
                    "}",
                    "",
                    "function insideICSSRuleNode(path) {",
                    "  const ruleAncestorNode = getAncestorNode(path, \"css-rule\");",
                    "",
                    "  return (",
                    "    ruleAncestorNode &&",
                    "    ruleAncestorNode.raws &&",
                    "    ruleAncestorNode.raws.selector &&",
                    "    (ruleAncestorNode.raws.selector.startsWith(\":import\") ||",
                    "      ruleAncestorNode.raws.selector.startsWith(\":export\"))",
                    "  );",
                    "}",
                    "",
                    "function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {",
                    "  const atRuleNames = [].concat(atRuleNameOrAtRuleNames);",
                    "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "",
                    "  return (",
                    "    atRuleAncestorNode &&",
                    "    atRuleNames.includes(atRuleAncestorNode.name.toLowerCase())",
                    "  );",
                    "}",
                    "",
                    "function insideURLFunctionInImportAtRuleNode(path) {",
                    "  const node = path.getValue();",
                    "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "",
                    "  return (",
                    "    atRuleAncestorNode &&",
                    "    atRuleAncestorNode.name === \"import\" &&",
                    "    node.groups[0].value === \"url\" &&",
                    "    node.groups.length === 2",
                    "  );",
                    "}",
                    "",
                    "function isURLFunctionNode(node) {",
                    "  return node.type === \"value-func\" && node.value.toLowerCase() === \"url\";",
                    "}",
                    "",
                    "function isLastNode(path, node) {",
                    "  const parentNode = path.getParentNode();",
                    "  if (!parentNode) {",
                    "    return false;",
                    "  }",
                    "  const { nodes } = parentNode;",
                    "  return nodes && nodes.indexOf(node) === nodes.length - 1;",
                    "}",
                    "",
                    "function isDetachedRulesetDeclarationNode(node) {",
                    "  // If a Less file ends up being parsed with the SCSS parser, Less",
                    "  // variable declarations will be parsed as atrules with names ending",
                    "  // with a colon, so keep the original case then.",
                    "  if (!node.selector) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return (",
                    "    (typeof node.selector === \"string\" && /^@.+:.*$/.test(node.selector)) ||",
                    "    (node.selector.value && /^@.+:.*$/.test(node.selector.value))",
                    "  );",
                    "}",
                    "",
                    "function isForKeywordNode(node) {",
                    "  return (",
                    "    node.type === \"value-word\" &&",
                    "    [\"from\", \"through\", \"end\"].includes(node.value)",
                    "  );",
                    "}",
                    "",
                    "function isIfElseKeywordNode(node) {",
                    "  return (",
                    "    node.type === \"value-word\" && [\"and\", \"or\", \"not\"].includes(node.value)",
                    "  );",
                    "}",
                    "",
                    "function isEachKeywordNode(node) {",
                    "  return node.type === \"value-word\" && node.value === \"in\";",
                    "}",
                    "",
                    "function isMultiplicationNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"*\";",
                    "}",
                    "",
                    "function isDivisionNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"/\";",
                    "}",
                    "",
                    "function isAdditionNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"+\";",
                    "}",
                    "",
                    "function isSubtractionNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"-\";",
                    "}",
                    "",
                    "function isModuloNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"%\";",
                    "}",
                    "",
                    "function isMathOperatorNode(node) {",
                    "  return (",
                    "    isMultiplicationNode(node) ||",
                    "    isDivisionNode(node) ||",
                    "    isAdditionNode(node) ||",
                    "    isSubtractionNode(node) ||",
                    "    isModuloNode(node)",
                    "  );",
                    "}",
                    "",
                    "function isEqualityOperatorNode(node) {",
                    "  return node.type === \"value-word\" && [\"==\", \"!=\"].includes(node.value);",
                    "}",
                    "",
                    "function isRelationalOperatorNode(node) {",
                    "  return (",
                    "    node.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].includes(node.value)",
                    "  );",
                    "}",
                    "",
                    "function isSCSSControlDirectiveNode(node) {",
                    "  return (",
                    "    node.type === \"css-atrule\" &&",
                    "    [\"if\", \"else\", \"for\", \"each\", \"while\"].includes(node.name)",
                    "  );",
                    "}",
                    "",
                    "function isSCSSNestedPropertyNode(node) {",
                    "  if (!node.selector) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return node.selector",
                    "    .replace(/\\/\\*.*?\\*\\//, \"\")",
                    "    .replace(/\\/\\/.*?\\n/, \"\")",
                    "    .trim()",
                    "    .endsWith(\":\");",
                    "}",
                    "",
                    "function isDetachedRulesetCallNode(node) {",
                    "  return node.raws && node.raws.params && /^\\(\\s*\\)$/.test(node.raws.params);",
                    "}",
                    "",
                    "function isTemplatePlaceholderNode(node) {",
                    "  return node.name.startsWith(\"prettier-placeholder\");",
                    "}",
                    "",
                    "function isTemplatePropNode(node) {",
                    "  return node.prop.startsWith(\"@prettier-placeholder\");",
                    "}",
                    "",
                    "function isPostcssSimpleVarNode(currentNode, nextNode) {",
                    "  return (",
                    "    currentNode.value === \"$$\" &&",
                    "    currentNode.type === \"value-func\" &&",
                    "    nextNode &&",
                    "    nextNode.type === \"value-word\" &&",
                    "    !nextNode.raws.before",
                    "  );",
                    "}",
                    "",
                    "function hasComposesNode(node) {",
                    "  return (",
                    "    node.value &&",
                    "    node.value.type === \"value-root\" &&",
                    "    node.value.group &&",
                    "    node.value.group.type === \"value-value\" &&",
                    "    node.prop.toLowerCase() === \"composes\"",
                    "  );",
                    "}",
                    "",
                    "function hasParensAroundNode(node) {",
                    "  return (",
                    "    node.value &&",
                    "    node.value.group &&",
                    "    node.value.group.group &&",
                    "    node.value.group.group.type === \"value-paren_group\" &&",
                    "    node.value.group.group.open !== null &&",
                    "    node.value.group.group.close !== null",
                    "  );",
                    "}",
                    "",
                    "function hasEmptyRawBefore(node) {",
                    "  return node.raws && node.raws.before === \"\";",
                    "}",
                    "",
                    "function isKeyValuePairNode(node) {",
                    "  return (",
                    "    node.type === \"value-comma_group\" &&",
                    "    node.groups &&",
                    "    node.groups[1] &&",
                    "    node.groups[1].type === \"value-colon\"",
                    "  );",
                    "}",
                    "",
                    "function isKeyValuePairInParenGroupNode(node) {",
                    "  return (",
                    "    node.type === \"value-paren_group\" &&",
                    "    node.groups &&",
                    "    node.groups[0] &&",
                    "    isKeyValuePairNode(node.groups[0])",
                    "  );",
                    "}",
                    "",
                    "function isSCSSMapItemNode(path) {",
                    "  const node = path.getValue();",
                    "",
                    "  // Ignore empty item (i.e. `$key: ()`)",
                    "  if (node.groups.length === 0) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const parentParentNode = path.getParentNode(1);",
                    "",
                    "  // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)",
                    "  if (",
                    "    !isKeyValuePairInParenGroupNode(node) &&",
                    "    !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const declNode = getAncestorNode(path, \"css-decl\");",
                    "",
                    "  // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)",
                    "  if (declNode && declNode.prop && declNode.prop.startsWith(\"$\")) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)",
                    "  if (isKeyValuePairInParenGroupNode(parentParentNode)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)",
                    "  if (parentParentNode.type === \"value-func\") {",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isInlineValueCommentNode(node) {",
                    "  return node.type === \"value-comment\" && node.inline;",
                    "}",
                    "",
                    "function isHashNode(node) {",
                    "  return node.type === \"value-word\" && node.value === \"#\";",
                    "}",
                    "",
                    "function isLeftCurlyBraceNode(node) {",
                    "  return node.type === \"value-word\" && node.value === \"{\";",
                    "}",
                    "",
                    "function isRightCurlyBraceNode(node) {",
                    "  return node.type === \"value-word\" && node.value === \"}\";",
                    "}",
                    "",
                    "function isWordNode(node) {",
                    "  return [\"value-word\", \"value-atword\"].includes(node.type);",
                    "}",
                    "",
                    "function isColonNode(node) {",
                    "  return node.type === \"value-colon\";",
                    "}",
                    "",
                    "function isMediaAndSupportsKeywords(node) {",
                    "  return node.value && [\"not\", \"and\", \"or\"].includes(node.value.toLowerCase());",
                    "}",
                    "",
                    "function isColorAdjusterFuncNode(node) {",
                    "  if (node.type !== \"value-func\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  return colorAdjusterFunctions.has(node.value.toLowerCase());",
                    "}",
                    "",
                    "// TODO: only check `less` when we don't use `less` to parse `css`",
                    "function isLessParser(options) {",
                    "  return options.parser === \"css\" || options.parser === \"less\";",
                    "}",
                    "",
                    "function lastLineHasInlineComment(text) {",
                    "  return /\\/\\//.test(text.split(/[\\n\\r]/).pop());",
                    "}",
                    "",
                    "function stringifyNode(node) {",
                    "  if (node.groups) {",
                    "    const open = node.open && node.open.value ? node.open.value : \"\";",
                    "    const groups = node.groups.reduce((previousValue, currentValue, index) => {",
                    "      return (",
                    "        previousValue +",
                    "        stringifyNode(currentValue) +",
                    "        (node.groups[0].type === \"comma_group\" &&",
                    "        index !== node.groups.length - 1",
                    "          ? \",\"",
                    "          : \"\")",
                    "      );",
                    "    }, \"\");",
                    "    const close = node.close && node.close.value ? node.close.value : \"\";",
                    "",
                    "    return open + groups + close;",
                    "  }",
                    "",
                    "  const before = node.raws && node.raws.before ? node.raws.before : \"\";",
                    "  const quote = node.raws && node.raws.quote ? node.raws.quote : \"\";",
                    "  const atword = node.type === \"atword\" ? \"@\" : \"\";",
                    "  const value = node.value ? node.value : \"\";",
                    "  const unit = node.unit ? node.unit : \"\";",
                    "  const group = node.group ? stringifyNode(node.group) : \"\";",
                    "  const after = node.raws && node.raws.after ? node.raws.after : \"\";",
                    "",
                    "  return before + quote + atword + value + quote + unit + group + after;",
                    "}",
                    "",
                    "module.exports = {",
                    "  getAncestorCounter,",
                    "  getAncestorNode,",
                    "  getPropOfDeclNode,",
                    "  hasSCSSInterpolation,",
                    "  hasStringOrFunction,",
                    "  maybeToLowerCase,",
                    "  insideValueFunctionNode,",
                    "  insideICSSRuleNode,",
                    "  insideAtRuleNode,",
                    "  insideURLFunctionInImportAtRuleNode,",
                    "  isKeyframeAtRuleKeywords,",
                    "  isWideKeywords,",
                    "  isSCSS,",
                    "  isSCSSVariable,",
                    "  isLastNode,",
                    "  isLessParser,",
                    "  isSCSSControlDirectiveNode,",
                    "  isDetachedRulesetDeclarationNode,",
                    "  isRelationalOperatorNode,",
                    "  isEqualityOperatorNode,",
                    "  isMultiplicationNode,",
                    "  isDivisionNode,",
                    "  isAdditionNode,",
                    "  isSubtractionNode,",
                    "  isModuloNode,",
                    "  isMathOperatorNode,",
                    "  isEachKeywordNode,",
                    "  isForKeywordNode,",
                    "  isURLFunctionNode,",
                    "  isIfElseKeywordNode,",
                    "  hasComposesNode,",
                    "  hasParensAroundNode,",
                    "  hasEmptyRawBefore,",
                    "  isSCSSNestedPropertyNode,",
                    "  isDetachedRulesetCallNode,",
                    "  isTemplatePlaceholderNode,",
                    "  isTemplatePropNode,",
                    "  isPostcssSimpleVarNode,",
                    "  isKeyValuePairNode,",
                    "  isKeyValuePairInParenGroupNode,",
                    "  isSCSSMapItemNode,",
                    "  isInlineValueCommentNode,",
                    "  isHashNode,",
                    "  isLeftCurlyBraceNode,",
                    "  isRightCurlyBraceNode,",
                    "  isWordNode,",
                    "  isColonNode,",
                    "  isMediaAndSupportsKeywords,",
                    "  isColorAdjusterFuncNode,",
                    "  lastLineHasInlineComment,",
                    "  stringifyNode,",
                    "};"
                ]
            }
        },
        "language-graphql": {
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-graphql\");",
                    "const options = require(\"./options\");",
                    "const createLanguage = require(\"../utils/create-language\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/GraphQL\"), () => ({",
                    "    since: \"1.5.0\",",
                    "    parsers: [\"graphql\"],",
                    "    vscodeLanguageIds: [\"graphql\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  graphql: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "};"
                ]
            },
            "parser-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const { hasPragma } = require(\"./pragma\");",
                    "",
                    "function parseComments(ast) {",
                    "  const comments = [];",
                    "  const { startToken } = ast.loc;",
                    "  let { next } = startToken;",
                    "  while (next.kind !== \"<EOF>\") {",
                    "    if (next.kind === \"Comment\") {",
                    "      Object.assign(next, {",
                    "        // The Comment token's column starts _after_ the `#`,",
                    "        // but we need to make sure the node captures the `#`",
                    "        column: next.column - 1,",
                    "      });",
                    "      comments.push(next);",
                    "    }",
                    "    next = next.next;",
                    "  }",
                    "",
                    "  return comments;",
                    "}",
                    "",
                    "function removeTokens(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.startToken;",
                    "    delete node.endToken;",
                    "    delete node.prev;",
                    "    delete node.next;",
                    "    for (const key in node) {",
                    "      removeTokens(node[key]);",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function fallbackParser(parse, source) {",
                    "  const parserOptions = {",
                    "    allowLegacySDLImplementsInterfaces: false,",
                    "    experimentalFragmentVariables: true,",
                    "  };",
                    "  try {",
                    "    return parse(source, parserOptions);",
                    "  } catch (_) {",
                    "    parserOptions.allowLegacySDLImplementsInterfaces = true;",
                    "    return parse(source, parserOptions);",
                    "  }",
                    "}",
                    "",
                    "function parse(text /*, parsers, opts*/) {",
                    "  // Inline the require to avoid loading all the JS if we don't use it",
                    "  const parser = require(\"graphql/language\");",
                    "  try {",
                    "    const ast = fallbackParser(parser.parse, text);",
                    "    ast.comments = parseComments(ast);",
                    "    removeTokens(ast);",
                    "    return ast;",
                    "  } catch (error) {",
                    "    const { GraphQLError } = require(\"graphql/error\");",
                    "    if (error instanceof GraphQLError) {",
                    "      throw createError(error.message, {",
                    "        start: {",
                    "          line: error.locations[0].line,",
                    "          column: error.locations[0].column,",
                    "        },",
                    "      });",
                    "    } else {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    graphql: {",
                    "      parse,",
                    "      astFormat: \"graphql\",",
                    "      hasPragma,",
                    "      locStart(node) {",
                    "        if (typeof node.start === \"number\") {",
                    "          return node.start;",
                    "        }",
                    "        return node.loc && node.loc.start;",
                    "      },",
                    "      locEnd(node) {",
                    "        if (typeof node.end === \"number\") {",
                    "          return node.end;",
                    "        }",
                    "        return node.loc && node.loc.end;",
                    "      },",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(format|prettier)\\s*(\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"# @format\\n\\n\" + text;",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "printer-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  concat,",
                    "  join,",
                    "  hardline,",
                    "  line,",
                    "  softline,",
                    "  group,",
                    "  indent,",
                    "  ifBreak,",
                    "} = require(\"../document\").builders;",
                    "const { hasIgnoreComment } = require(\"../common/util\");",
                    "const { isNextLineEmpty } = require(\"../common/util-shared\");",
                    "const { insertPragma } = require(\"./pragma\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const n = path.getValue();",
                    "  if (!n) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof n === \"string\") {",
                    "    return n;",
                    "  }",
                    "",
                    "  switch (n.kind) {",
                    "    case \"Document\": {",
                    "      const parts = [];",
                    "      path.map((pathChild, index) => {",
                    "        parts.push(concat([pathChild.call(print)]));",
                    "        if (index !== n.definitions.length - 1) {",
                    "          parts.push(hardline);",
                    "          if (",
                    "            isNextLineEmpty(",
                    "              options.originalText,",
                    "              pathChild.getValue(),",
                    "              options.locEnd",
                    "            )",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }",
                    "      }, \"definitions\");",
                    "      return concat([concat(parts), hardline]);",
                    "    }",
                    "    case \"OperationDefinition\": {",
                    "      const hasOperation = options.originalText[options.locStart(n)] !== \"{\";",
                    "      const hasName = !!n.name;",
                    "      return concat([",
                    "        hasOperation ? n.operation : \"\",",
                    "        hasOperation && hasName ? concat([\" \", path.call(print, \"name\")]) : \"\",",
                    "        n.variableDefinitions && n.variableDefinitions.length",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.map(print, \"variableDefinitions\")",
                    "                    ),",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\",",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        printDirectives(path, print, n),",
                    "        n.selectionSet ? (!hasOperation && !hasName ? \"\" : \" \") : \"\",",
                    "        path.call(print, \"selectionSet\"),",
                    "      ]);",
                    "    }",
                    "    case \"FragmentDefinition\": {",
                    "      return concat([",
                    "        \"fragment \",",
                    "        path.call(print, \"name\"),",
                    "        n.variableDefinitions && n.variableDefinitions.length",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.map(print, \"variableDefinitions\")",
                    "                    ),",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\",",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        \" on \",",
                    "        path.call(print, \"typeCondition\"),",
                    "        printDirectives(path, print, n),",
                    "        \" \",",
                    "        path.call(print, \"selectionSet\"),",
                    "      ]);",
                    "    }",
                    "    case \"SelectionSet\": {",
                    "      return concat([",
                    "        \"{\",",
                    "        indent(",
                    "          concat([",
                    "            hardline,",
                    "            join(",
                    "              hardline,",
                    "              path.call(",
                    "                (selectionsPath) =>",
                    "                  printSequence(selectionsPath, options, print),",
                    "                \"selections\"",
                    "              )",
                    "            ),",
                    "          ])",
                    "        ),",
                    "        hardline,",
                    "        \"}\",",
                    "      ]);",
                    "    }",
                    "    case \"Field\": {",
                    "      return group(",
                    "        concat([",
                    "          n.alias ? concat([path.call(print, \"alias\"), \": \"]) : \"\",",
                    "          path.call(print, \"name\"),",
                    "          n.arguments.length > 0",
                    "            ? group(",
                    "                concat([",
                    "                  \"(\",",
                    "                  indent(",
                    "                    concat([",
                    "                      softline,",
                    "                      join(",
                    "                        concat([ifBreak(\"\", \", \"), softline]),",
                    "                        path.call(",
                    "                          (argsPath) => printSequence(argsPath, options, print),",
                    "                          \"arguments\"",
                    "                        )",
                    "                      ),",
                    "                    ])",
                    "                  ),",
                    "                  softline,",
                    "                  \")\",",
                    "                ])",
                    "              )",
                    "            : \"\",",
                    "          printDirectives(path, print, n),",
                    "          n.selectionSet ? \" \" : \"\",",
                    "          path.call(print, \"selectionSet\"),",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"Name\": {",
                    "      return n.value;",
                    "    }",
                    "    case \"StringValue\": {",
                    "      if (n.block) {",
                    "        return concat([",
                    "          '\"\"\"',",
                    "          hardline,",
                    "          join(hardline, n.value.replace(/\"\"\"/g, \"\\\\$&\").split(\"\\n\")),",
                    "          hardline,",
                    "          '\"\"\"',",
                    "        ]);",
                    "      }",
                    "      return concat([",
                    "        '\"',",
                    "        n.value.replace(/[\"\\\\]/g, \"\\\\$&\").replace(/\\n/g, \"\\\\n\"),",
                    "        '\"',",
                    "      ]);",
                    "    }",
                    "    case \"IntValue\":",
                    "    case \"FloatValue\":",
                    "    case \"EnumValue\": {",
                    "      return n.value;",
                    "    }",
                    "    case \"BooleanValue\": {",
                    "      return n.value ? \"true\" : \"false\";",
                    "    }",
                    "    case \"NullValue\": {",
                    "      return \"null\";",
                    "    }",
                    "    case \"Variable\": {",
                    "      return concat([\"$\", path.call(print, \"name\")]);",
                    "    }",
                    "    case \"ListValue\": {",
                    "      return group(",
                    "        concat([",
                    "          \"[\",",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              join(",
                    "                concat([ifBreak(\"\", \", \"), softline]),",
                    "                path.map(print, \"values\")",
                    "              ),",
                    "            ])",
                    "          ),",
                    "          softline,",
                    "          \"]\",",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"ObjectValue\": {",
                    "      return group(",
                    "        concat([",
                    "          \"{\",",
                    "          options.bracketSpacing && n.fields.length > 0 ? \" \" : \"\",",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              join(",
                    "                concat([ifBreak(\"\", \", \"), softline]),",
                    "                path.map(print, \"fields\")",
                    "              ),",
                    "            ])",
                    "          ),",
                    "          softline,",
                    "          ifBreak(\"\", options.bracketSpacing && n.fields.length > 0 ? \" \" : \"\"),",
                    "          \"}\",",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"ObjectField\":",
                    "    case \"Argument\": {",
                    "      return concat([",
                    "        path.call(print, \"name\"),",
                    "        \": \",",
                    "        path.call(print, \"value\"),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"Directive\": {",
                    "      return concat([",
                    "        \"@\",",
                    "        path.call(print, \"name\"),",
                    "        n.arguments.length > 0",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.call(",
                    "                        (argsPath) => printSequence(argsPath, options, print),",
                    "                        \"arguments\"",
                    "                      )",
                    "                    ),",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\",",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"NamedType\": {",
                    "      return path.call(print, \"name\");",
                    "    }",
                    "",
                    "    case \"VariableDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"variable\"),",
                    "        \": \",",
                    "        path.call(print, \"type\"),",
                    "        n.defaultValue ? concat([\" = \", path.call(print, \"defaultValue\")]) : \"\",",
                    "        printDirectives(path, print, n),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"TypeExtensionDefinition\": {",
                    "      return concat([\"extend \", path.call(print, \"definition\")]);",
                    "    }",
                    "",
                    "    case \"ObjectTypeExtension\":",
                    "    case \"ObjectTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"ObjectTypeExtension\" ? \"extend \" : \"\",",
                    "        \"type \",",
                    "        path.call(print, \"name\"),",
                    "        n.interfaces.length > 0",
                    "          ? concat([",
                    "              \" implements \",",
                    "              concat(printInterfaces(path, options, print)),",
                    "            ])",
                    "          : \"\",",
                    "        printDirectives(path, print, n),",
                    "        n.fields.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  join(",
                    "                    hardline,",
                    "                    path.call(",
                    "                      (fieldsPath) => printSequence(fieldsPath, options, print),",
                    "                      \"fields\"",
                    "                    )",
                    "                  ),",
                    "                ])",
                    "              ),",
                    "              hardline,",
                    "              \"}\",",
                    "            ])",
                    "          : \"\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"FieldDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        path.call(print, \"name\"),",
                    "        n.arguments.length > 0",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.call(",
                    "                        (argsPath) => printSequence(argsPath, options, print),",
                    "                        \"arguments\"",
                    "                      )",
                    "                    ),",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\",",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        \": \",",
                    "        path.call(print, \"type\"),",
                    "        printDirectives(path, print, n),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"DirectiveDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        \"directive \",",
                    "        \"@\",",
                    "        path.call(print, \"name\"),",
                    "        n.arguments.length > 0",
                    "          ? group(",
                    "              concat([",
                    "                \"(\",",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    join(",
                    "                      concat([ifBreak(\"\", \", \"), softline]),",
                    "                      path.call(",
                    "                        (argsPath) => printSequence(argsPath, options, print),",
                    "                        \"arguments\"",
                    "                      )",
                    "                    ),",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "                \")\",",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        n.repeatable ? \" repeatable\" : \"\",",
                    "        concat([\" on \", join(\" | \", path.map(print, \"locations\"))]),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"EnumTypeExtension\":",
                    "    case \"EnumTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"EnumTypeExtension\" ? \"extend \" : \"\",",
                    "        \"enum \",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n),",
                    "",
                    "        n.values.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  join(",
                    "                    hardline,",
                    "                    path.call(",
                    "                      (valuesPath) => printSequence(valuesPath, options, print),",
                    "                      \"values\"",
                    "                    )",
                    "                  ),",
                    "                ])",
                    "              ),",
                    "              hardline,",
                    "              \"}\",",
                    "            ])",
                    "          : \"\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"EnumValueDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"InputValueDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? (n.description.block ? hardline : line) : \"\",",
                    "        path.call(print, \"name\"),",
                    "        \": \",",
                    "        path.call(print, \"type\"),",
                    "        n.defaultValue ? concat([\" = \", path.call(print, \"defaultValue\")]) : \"\",",
                    "        printDirectives(path, print, n),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"InputObjectTypeExtension\":",
                    "    case \"InputObjectTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"InputObjectTypeExtension\" ? \"extend \" : \"\",",
                    "        \"input \",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n),",
                    "        n.fields.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  join(",
                    "                    hardline,",
                    "                    path.call(",
                    "                      (fieldsPath) => printSequence(fieldsPath, options, print),",
                    "                      \"fields\"",
                    "                    )",
                    "                  ),",
                    "                ])",
                    "              ),",
                    "              hardline,",
                    "              \"}\",",
                    "            ])",
                    "          : \"\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"SchemaDefinition\": {",
                    "      return concat([",
                    "        \"schema\",",
                    "        printDirectives(path, print, n),",
                    "        \" {\",",
                    "        n.operationTypes.length > 0",
                    "          ? indent(",
                    "              concat([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  path.call(",
                    "                    (opsPath) => printSequence(opsPath, options, print),",
                    "                    \"operationTypes\"",
                    "                  )",
                    "                ),",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"OperationTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"operation\"),",
                    "        \": \",",
                    "        path.call(print, \"type\"),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"InterfaceTypeExtension\":",
                    "    case \"InterfaceTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"InterfaceTypeExtension\" ? \"extend \" : \"\",",
                    "        \"interface \",",
                    "        path.call(print, \"name\"),",
                    "        n.interfaces.length > 0",
                    "          ? concat([",
                    "              \" implements \",",
                    "              concat(printInterfaces(path, options, print)),",
                    "            ])",
                    "          : \"\",",
                    "        printDirectives(path, print, n),",
                    "        n.fields.length > 0",
                    "          ? concat([",
                    "              \" {\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  join(",
                    "                    hardline,",
                    "                    path.call(",
                    "                      (fieldsPath) => printSequence(fieldsPath, options, print),",
                    "                      \"fields\"",
                    "                    )",
                    "                  ),",
                    "                ])",
                    "              ),",
                    "              hardline,",
                    "              \"}\",",
                    "            ])",
                    "          : \"\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"FragmentSpread\": {",
                    "      return concat([",
                    "        \"...\",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"InlineFragment\": {",
                    "      return concat([",
                    "        \"...\",",
                    "        n.typeCondition",
                    "          ? concat([\" on \", path.call(print, \"typeCondition\")])",
                    "          : \"\",",
                    "        printDirectives(path, print, n),",
                    "        \" \",",
                    "        path.call(print, \"selectionSet\"),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"UnionTypeExtension\":",
                    "    case \"UnionTypeDefinition\": {",
                    "      return group(",
                    "        concat([",
                    "          path.call(print, \"description\"),",
                    "          n.description ? hardline : \"\",",
                    "          group(",
                    "            concat([",
                    "              n.kind === \"UnionTypeExtension\" ? \"extend \" : \"\",",
                    "              \"union \",",
                    "              path.call(print, \"name\"),",
                    "              printDirectives(path, print, n),",
                    "              n.types.length > 0",
                    "                ? concat([",
                    "                    \" =\",",
                    "                    ifBreak(\"\", \" \"),",
                    "                    indent(",
                    "                      concat([",
                    "                        ifBreak(concat([line, \"  \"])),",
                    "                        join(concat([line, \"| \"]), path.map(print, \"types\")),",
                    "                      ])",
                    "                    ),",
                    "                  ])",
                    "                : \"\",",
                    "            ])",
                    "          ),",
                    "        ])",
                    "      );",
                    "    }",
                    "",
                    "    case \"ScalarTypeExtension\":",
                    "    case \"ScalarTypeDefinition\": {",
                    "      return concat([",
                    "        path.call(print, \"description\"),",
                    "        n.description ? hardline : \"\",",
                    "        n.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\",",
                    "        \"scalar \",",
                    "        path.call(print, \"name\"),",
                    "        printDirectives(path, print, n),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"NonNullType\": {",
                    "      return concat([path.call(print, \"type\"), \"!\"]);",
                    "    }",
                    "",
                    "    case \"ListType\": {",
                    "      return concat([\"[\", path.call(print, \"type\"), \"]\"]);",
                    "    }",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown graphql type: \" + JSON.stringify(n.kind));",
                    "  }",
                    "}",
                    "",
                    "function printDirectives(path, print, n) {",
                    "  if (n.directives.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return group(concat([line, join(line, path.map(print, \"directives\"))]));",
                    "}",
                    "",
                    "function printSequence(sequencePath, options, print) {",
                    "  const count = sequencePath.getValue().length;",
                    "",
                    "  return sequencePath.map((path, i) => {",
                    "    const printed = print(path);",
                    "",
                    "    if (",
                    "      isNextLineEmpty(options.originalText, path.getValue(), options.locEnd) &&",
                    "      i < count - 1",
                    "    ) {",
                    "      return concat([printed, hardline]);",
                    "    }",
                    "",
                    "    return printed;",
                    "  });",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return node.kind && node.kind !== \"Comment\";",
                    "}",
                    "",
                    "function printComment(commentPath) {",
                    "  const comment = commentPath.getValue();",
                    "  if (comment.kind === \"Comment\") {",
                    "    return \"#\" + comment.value.trimEnd();",
                    "  }",
                    "",
                    "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                    "}",
                    "",
                    "function printInterfaces(path, options, print) {",
                    "  const node = path.getNode();",
                    "  const parts = [];",
                    "  const { interfaces } = node;",
                    "  const printed = path.map((node) => print(node), \"interfaces\");",
                    "",
                    "  for (let index = 0; index < interfaces.length; index++) {",
                    "    const interfaceNode = interfaces[index];",
                    "    parts.push(printed[index]);",
                    "    const nextInterfaceNode = interfaces[index + 1];",
                    "    if (nextInterfaceNode) {",
                    "      const textBetween = options.originalText.slice(",
                    "        interfaceNode.loc.end,",
                    "        nextInterfaceNode.loc.start",
                    "      );",
                    "      const hasComment = textBetween.includes(\"#\");",
                    "      const separator = textBetween.replace(/#.*/g, \"\").trim();",
                    "",
                    "      parts.push(separator === \",\" ? \",\" : \" &\");",
                    "      parts.push(hasComment ? line : \" \");",
                    "    }",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function clean(node, newNode /*, parent*/) {",
                    "  delete newNode.loc;",
                    "  delete newNode.comments;",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore: hasIgnoreComment,",
                    "  insertPragma,",
                    "  printComment,",
                    "  canAttachComment,",
                    "};"
                ]
            }
        },
        "language-handlebars": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = function (ast, newNode) {",
                    "  delete newNode.loc;",
                    "  delete newNode.selfClosing;",
                    "",
                    "  // (Glimmer/HTML) ignore TextNode whitespace",
                    "  if (ast.type === \"TextNode\") {",
                    "    const trimmed = ast.chars.trim();",
                    "    if (!trimmed) {",
                    "      return null;",
                    "    }",
                    "    newNode.chars = trimmed;",
                    "  }",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-glimmer\");",
                    "const createLanguage = require(\"../utils/create-language\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/Handlebars\"), () => ({",
                    "    since: null, // unreleased",
                    "    parsers: [\"glimmer\"],",
                    "    vscodeLanguageIds: [\"handlebars\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  glimmer: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers,",
                    "};"
                ]
            },
            "parser-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "",
                    "function parse(text) {",
                    "  try {",
                    "    const glimmer = require(\"@glimmer/syntax\").preprocess;",
                    "    return glimmer(text, { mode: \"codemod\" });",
                    "    /* istanbul ignore next */",
                    "  } catch (error) {",
                    "    const matches = error.message.match(/on line (\\d+)/);",
                    "    if (matches) {",
                    "      throw createError(error.message, {",
                    "        start: { line: Number(matches[1]), column: 0 },",
                    "      });",
                    "    } else {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    glimmer: {",
                    "      parse,",
                    "      astFormat: \"glimmer\",",
                    "      // TODO: `locStart` and `locEnd` should return a number offset",
                    "      // https://prettier.io/docs/en/plugins.html#parsers",
                    "      // but we need access to the original text to use",
                    "      // `loc.start` and `loc.end` objects to calculate the offset",
                    "      locStart(node) {",
                    "        return node.loc && node.loc.start;",
                    "      },",
                    "      locEnd(node) {",
                    "        return node.loc && node.loc.end;",
                    "      },",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "printer-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const clean = require(\"./clean\");",
                    "",
                    "const {",
                    "  concat,",
                    "  group,",
                    "  hardline,",
                    "  ifBreak,",
                    "  indent,",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "} = require(\"../document\").builders;",
                    "",
                    "const {",
                    "  getNextNode,",
                    "  getPreviousNode,",
                    "  hasPrettierIgnore,",
                    "  isNextNodeOfSomeType,",
                    "  isNodeOfSomeType,",
                    "  isParentOfSomeType,",
                    "  isPreviousNodeOfSomeType,",
                    "  isVoid,",
                    "  isWhitespaceNode,",
                    "} = require(\"./utils\");",
                    "",
                    "// Formatter based on @glimmerjs/syntax's built-in test formatter:",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts",
                    "",
                    "function print(path, options, print) {",
                    "  const n = path.getValue();",
                    "",
                    "  /* istanbul ignore if*/",
                    "  if (!n) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (hasPrettierIgnore(path)) {",
                    "    const startOffset = locationToOffset(",
                    "      options.originalText,",
                    "      n.loc.start.line - 1,",
                    "      n.loc.start.column",
                    "    );",
                    "    const endOffset = locationToOffset(",
                    "      options.originalText,",
                    "      n.loc.end.line - 1,",
                    "      n.loc.end.column",
                    "    );",
                    "",
                    "    const ignoredText = options.originalText.slice(startOffset, endOffset);",
                    "    return ignoredText;",
                    "  }",
                    "",
                    "  switch (n.type) {",
                    "    case \"Block\":",
                    "    case \"Program\":",
                    "    case \"Template\": {",
                    "      return group(concat(path.map(print, \"body\")));",
                    "    }",
                    "    case \"ElementNode\": {",
                    "      // TODO: make it whitespace sensitive",
                    "      const bim = isNextNodeOfSomeType(path, [\"ElementNode\"]) ? hardline : \"\";",
                    "",
                    "      if (isVoid(n)) {",
                    "        return concat([group(printStartingTag(path, print)), bim]);",
                    "      }",
                    "",
                    "      const isWhitespaceOnly = n.children.every((n) => isWhitespaceNode(n));",
                    "",
                    "      return concat([",
                    "        group(printStartingTag(path, print)),",
                    "        group(",
                    "          concat([",
                    "            isWhitespaceOnly ? \"\" : indent(printChildren(path, options, print)),",
                    "            n.children.length ? hardline : \"\",",
                    "            concat([\"</\", n.tag, \">\"]),",
                    "          ])",
                    "        ),",
                    "        bim,",
                    "      ]);",
                    "    }",
                    "    case \"BlockStatement\": {",
                    "      const pp = path.getParentNode(1);",
                    "",
                    "      const isElseIf =",
                    "        pp &&",
                    "        pp.inverse &&",
                    "        pp.inverse.body.length === 1 &&",
                    "        pp.inverse.body[0] === n &&",
                    "        pp.inverse.body[0].path.parts[0] === \"if\";",
                    "",
                    "      if (isElseIf) {",
                    "        return concat([",
                    "          printElseIfBlock(path, print),",
                    "          printProgram(path, print),",
                    "          printInverse(path, print),",
                    "        ]);",
                    "      }",
                    "",
                    "      return concat([",
                    "        printOpenBlock(path, print),",
                    "        group(",
                    "          concat([",
                    "            printProgram(path, print),",
                    "            printInverse(path, print),",
                    "            printCloseBlock(path, print),",
                    "          ])",
                    "        ),",
                    "      ]);",
                    "    }",
                    "    case \"ElementModifierStatement\": {",
                    "      return group(",
                    "        concat([\"{{\", printPathAndParams(path, print), softline, \"}}\"])",
                    "      );",
                    "    }",
                    "    case \"MustacheStatement\": {",
                    "      const shouldBreakOpeningMustache = isParentOfSomeType(path, [",
                    "        \"AttrNode\",",
                    "        \"ConcatStatement\",",
                    "        \"ElementNode\",",
                    "      ]);",
                    "",
                    "      return group(",
                    "        concat([",
                    "          printOpeningMustache(n),",
                    "          shouldBreakOpeningMustache ? indent(softline) : \"\",",
                    "          printPathAndParams(path, print),",
                    "          softline,",
                    "          printClosingMustache(n),",
                    "        ])",
                    "      );",
                    "    }",
                    "",
                    "    case \"SubExpression\": {",
                    "      return group(",
                    "        concat([",
                    "          \"(\",",
                    "          printSubExpressionPathAndParams(path, print),",
                    "          softline,",
                    "          \")\",",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"AttrNode\": {",
                    "      const isText = n.value.type === \"TextNode\";",
                    "      const isEmptyText = isText && n.value.chars === \"\";",
                    "",
                    "      // If the text is empty and the value's loc start and end columns are the",
                    "      // same, there is no value for this AttrNode and it should be printed",
                    "      // without the `=\"\"`. Example: `<img data-test>` -> `<img data-test>`",
                    "      const isEmptyValue =",
                    "        isEmptyText && n.value.loc.start.column === n.value.loc.end.column;",
                    "      if (isEmptyValue) {",
                    "        return concat([n.name]);",
                    "      }",
                    "      const value = path.call(print, \"value\");",
                    "      const quotedValue = isText",
                    "        ? printStringLiteral(value.parts.join(), options)",
                    "        : value;",
                    "      return concat([n.name, \"=\", quotedValue]);",
                    "    }",
                    "",
                    "    case \"ConcatStatement\": {",
                    "      const quote = options.singleQuote ? \"'\" : '\"';",
                    "      return concat([",
                    "        quote,",
                    "        ...path.map((partPath) => print(partPath), \"parts\"),",
                    "        quote,",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"Hash\": {",
                    "      return concat([join(line, path.map(print, \"pairs\"))]);",
                    "    }",
                    "    case \"HashPair\": {",
                    "      return concat([n.key, \"=\", path.call(print, \"value\")]);",
                    "    }",
                    "    case \"TextNode\": {",
                    "      const maxLineBreaksToPreserve = 2;",
                    "      const isFirstElement = !getPreviousNode(path);",
                    "      const isLastElement = !getNextNode(path);",
                    "      const isWhitespaceOnly = !/\\S/.test(n.chars);",
                    "      const lineBreaksCount = countNewLines(n.chars);",
                    "",
                    "      let leadingLineBreaksCount = countLeadingNewLines(n.chars);",
                    "      let trailingLineBreaksCount = countTrailingNewLines(n.chars);",
                    "",
                    "      if (",
                    "        (isFirstElement || isLastElement) &&",
                    "        isWhitespaceOnly &&",
                    "        isParentOfSomeType(path, [\"Block\", \"ElementNode\", \"Template\"])",
                    "      ) {",
                    "        return \"\";",
                    "      }",
                    "",
                    "      if (isWhitespaceOnly && lineBreaksCount) {",
                    "        leadingLineBreaksCount = Math.min(",
                    "          lineBreaksCount,",
                    "          maxLineBreaksToPreserve",
                    "        );",
                    "        trailingLineBreaksCount = 0;",
                    "      } else {",
                    "        if (isNextNodeOfSomeType(path, [\"BlockStatement\", \"ElementNode\"])) {",
                    "          trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);",
                    "        }",
                    "",
                    "        if (isPreviousNodeOfSomeType(path, [\"BlockStatement\", \"ElementNode\"])) {",
                    "          leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);",
                    "        }",
                    "      }",
                    "",
                    "      let leadingSpace = \"\";",
                    "      let trailingSpace = \"\";",
                    "",
                    "      // preserve a space inside of an attribute node where whitespace present,",
                    "      // when next to mustache statement.",
                    "      const inAttrNode = path.stack.includes(\"attributes\");",
                    "      if (inAttrNode) {",
                    "        if (isParentOfSomeType(path, [\"ConcatStatement\"])) {",
                    "          if (isPreviousNodeOfSomeType(path, [\"MustacheStatement\"])) {",
                    "            leadingSpace = \" \";",
                    "          }",
                    "          if (isNextNodeOfSomeType(path, [\"MustacheStatement\"])) {",
                    "            trailingSpace = \" \";",
                    "          }",
                    "        }",
                    "      } else {",
                    "        if (",
                    "          trailingLineBreaksCount === 0 &&",
                    "          isNextNodeOfSomeType(path, [\"MustacheStatement\"])",
                    "        ) {",
                    "          trailingSpace = \" \";",
                    "        }",
                    "",
                    "        if (",
                    "          leadingLineBreaksCount === 0 &&",
                    "          isPreviousNodeOfSomeType(path, [\"MustacheStatement\"])",
                    "        ) {",
                    "          leadingSpace = \" \";",
                    "        }",
                    "",
                    "        if (isFirstElement) {",
                    "          leadingLineBreaksCount = 0;",
                    "          leadingSpace = \"\";",
                    "        }",
                    "",
                    "        if (isLastElement) {",
                    "          trailingLineBreaksCount = 0;",
                    "          trailingSpace = \"\";",
                    "        }",
                    "      }",
                    "",
                    "      return concat([",
                    "        ...generateHardlines(leadingLineBreaksCount, maxLineBreaksToPreserve),",
                    "        n.chars.replace(/^\\s+/g, leadingSpace).replace(/\\s+$/, trailingSpace),",
                    "        ...generateHardlines(trailingLineBreaksCount, maxLineBreaksToPreserve),",
                    "      ]);",
                    "    }",
                    "    case \"MustacheCommentStatement\": {",
                    "      const dashes = n.value.includes(\"}}\") ? \"--\" : \"\";",
                    "      return concat([\"{{!\", dashes, n.value, dashes, \"}}\"]);",
                    "    }",
                    "    case \"PathExpression\": {",
                    "      return n.original;",
                    "    }",
                    "    case \"BooleanLiteral\": {",
                    "      return String(n.value);",
                    "    }",
                    "    case \"CommentStatement\": {",
                    "      return concat([\"<!--\", n.value, \"-->\"]);",
                    "    }",
                    "    case \"StringLiteral\": {",
                    "      return printStringLiteral(n.value, options);",
                    "    }",
                    "    case \"NumberLiteral\": {",
                    "      return String(n.value);",
                    "    }",
                    "    case \"UndefinedLiteral\": {",
                    "      return \"undefined\";",
                    "    }",
                    "    case \"NullLiteral\": {",
                    "      return \"null\";",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    default:",
                    "      throw new Error(\"unknown glimmer type: \" + JSON.stringify(n.type));",
                    "  }",
                    "}",
                    "",
                    "/* ElementNode print helpers */",
                    "",
                    "function printStartingTag(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  return concat([",
                    "    \"<\",",
                    "    node.tag,",
                    "    printAttributesLike(path, print),",
                    "    printBlockParams(node),",
                    "    printStartingTagEndMarker(node),",
                    "  ]);",
                    "}",
                    "",
                    "function printAttributesLike(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  return indent(",
                    "    concat([",
                    "      node.attributes.length ? line : \"\",",
                    "      join(line, path.map(print, \"attributes\")),",
                    "",
                    "      node.modifiers.length ? line : \"\",",
                    "      join(line, path.map(print, \"modifiers\")),",
                    "",
                    "      node.comments.length ? line : \"\",",
                    "      join(line, path.map(print, \"comments\")),",
                    "    ])",
                    "  );",
                    "}",
                    "",
                    "function printChildren(path, options, print) {",
                    "  return concat(",
                    "    path.map((childPath, childIndex) => {",
                    "      if (childIndex === 0) {",
                    "        return concat([softline, print(childPath, options, print)]);",
                    "      }",
                    "",
                    "      return print(childPath, options, print);",
                    "    }, \"children\")",
                    "  );",
                    "}",
                    "",
                    "function printStartingTagEndMarker(node) {",
                    "  if (isVoid(node)) {",
                    "    return ifBreak(concat([softline, \"/>\"]), concat([\" />\", softline]));",
                    "  }",
                    "",
                    "  return ifBreak(concat([softline, \">\"]), \">\");",
                    "}",
                    "",
                    "/* MustacheStatement print helpers */",
                    "",
                    "function printOpeningMustache(node) {",
                    "  const mustache = node.escaped === false ? \"{{{\" : \"{{\";",
                    "  const strip = node.strip && node.strip.open ? \"~\" : \"\";",
                    "  return concat([mustache, strip]);",
                    "}",
                    "",
                    "function printClosingMustache(node) {",
                    "  const mustache = node.escaped === false ? \"}}}\" : \"}}\";",
                    "  const strip = node.strip && node.strip.close ? \"~\" : \"\";",
                    "  return concat([strip, mustache]);",
                    "}",
                    "",
                    "/* BlockStatement print helpers */",
                    "",
                    "function printOpeningBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.openStrip.open ? \"~\" : \"\";",
                    "  return concat([opening, strip, \"#\"]);",
                    "}",
                    "",
                    "function printOpeningBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.openStrip.close ? \"~\" : \"\";",
                    "  return concat([strip, closing]);",
                    "}",
                    "",
                    "function printClosingBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.closeStrip.open ? \"~\" : \"\";",
                    "  return concat([opening, strip, \"/\"]);",
                    "}",
                    "",
                    "function printClosingBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.closeStrip.close ? \"~\" : \"\";",
                    "  return concat([strip, closing]);",
                    "}",
                    "",
                    "function printInverseBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.inverseStrip.open ? \"~\" : \"\";",
                    "  return concat([opening, strip]);",
                    "}",
                    "",
                    "function printInverseBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.inverseStrip.close ? \"~\" : \"\";",
                    "  return concat([strip, closing]);",
                    "}",
                    "",
                    "function printOpenBlock(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  return group(",
                    "    concat([",
                    "      printOpeningBlockOpeningMustache(node),",
                    "      printPathAndParams(path, print),",
                    "      printBlockParams(node.program),",
                    "      softline,",
                    "      printOpeningBlockClosingMustache(node),",
                    "    ])",
                    "  );",
                    "}",
                    "",
                    "function printElseBlock(node) {",
                    "  return concat([",
                    "    hardline,",
                    "    printInverseBlockOpeningMustache(node),",
                    "    \"else\",",
                    "    printInverseBlockClosingMustache(node),",
                    "  ]);",
                    "}",
                    "",
                    "function printElseIfBlock(path, print) {",
                    "  const parentNode = path.getParentNode(1);",
                    "",
                    "  return concat([",
                    "    printInverseBlockOpeningMustache(parentNode),",
                    "    \"else \",",
                    "    printPathAndParams(path, print),",
                    "    printInverseBlockClosingMustache(parentNode),",
                    "  ]);",
                    "}",
                    "",
                    "function printCloseBlock(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  return concat([",
                    "    blockStatementHasOnlyWhitespaceInProgram(node) ? softline : hardline,",
                    "    printClosingBlockOpeningMustache(node),",
                    "    path.call(print, \"path\"),",
                    "    printClosingBlockClosingMustache(node),",
                    "  ]);",
                    "}",
                    "",
                    "function blockStatementHasOnlyWhitespaceInProgram(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"BlockStatement\"]) &&",
                    "    node.program.body.every((n) => isWhitespaceNode(n))",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElseIf(node) {",
                    "  return (",
                    "    blockStatementHasElse(node) &&",
                    "    node.inverse.body.length === 1 &&",
                    "    isNodeOfSomeType(node.inverse.body[0], [\"BlockStatement\"]) &&",
                    "    node.inverse.body[0].path.parts[0] === \"if\"",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElse(node) {",
                    "  return isNodeOfSomeType(node, [\"BlockStatement\"]) && node.inverse;",
                    "}",
                    "",
                    "function printProgram(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (blockStatementHasOnlyWhitespaceInProgram(node)) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const program = path.call(print, \"program\");",
                    "  return indent(concat([hardline, program]));",
                    "}",
                    "",
                    "function printInverse(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  const inverse = path.call(print, \"inverse\");",
                    "  const parts = concat([hardline, inverse]);",
                    "",
                    "  if (blockStatementHasElseIf(node)) {",
                    "    return parts;",
                    "  }",
                    "",
                    "  if (blockStatementHasElse(node)) {",
                    "    return concat([printElseBlock(node), indent(parts)]);",
                    "  }",
                    "",
                    "  return \"\";",
                    "}",
                    "",
                    "/* TextNode print helpers */",
                    "",
                    "function countNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  return string.split(\"\\n\").length - 1;",
                    "}",
                    "",
                    "function countLeadingNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function countTrailingNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function generateHardlines(number = 0, max = 0) {",
                    "  return new Array(Math.min(number, max)).fill(hardline);",
                    "}",
                    "",
                    "/* StringLiteral print helpers */",
                    "",
                    "/**",
                    " * Prints a string literal with the correct surrounding quotes based on",
                    " * `options.singleQuote` and the number of escaped quotes contained in",
                    " * the string literal. This function is the glimmer equivalent of `printString`",
                    " * in `common/util`, but has differences because of the way escaped characters",
                    " * are treated in hbs string literals.",
                    " * @param {string} stringLiteral - the string literal value",
                    " * @param {object} options - the prettier options object",
                    " */",
                    "function printStringLiteral(stringLiteral, options) {",
                    "  const double = { quote: '\"', regex: /\"/g };",
                    "  const single = { quote: \"'\", regex: /'/g };",
                    "",
                    "  const preferred = options.singleQuote ? single : double;",
                    "  const alternate = preferred === single ? double : single;",
                    "",
                    "  let shouldUseAlternateQuote = false;",
                    "",
                    "  // If `stringLiteral` contains at least one of the quote preferred for",
                    "  // enclosing the string, we might want to enclose with the alternate quote",
                    "  // instead, to minimize the number of escaped quotes.",
                    "  if (",
                    "    stringLiteral.includes(preferred.quote) ||",
                    "    stringLiteral.includes(alternate.quote)",
                    "  ) {",
                    "    const numPreferredQuotes = (stringLiteral.match(preferred.regex) || [])",
                    "      .length;",
                    "    const numAlternateQuotes = (stringLiteral.match(alternate.regex) || [])",
                    "      .length;",
                    "",
                    "    shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;",
                    "  }",
                    "",
                    "  const enclosingQuote = shouldUseAlternateQuote ? alternate : preferred;",
                    "  const escapedStringLiteral = stringLiteral.replace(",
                    "    enclosingQuote.regex,",
                    "    `\\\\${enclosingQuote.quote}`",
                    "  );",
                    "",
                    "  return concat([",
                    "    enclosingQuote.quote,",
                    "    escapedStringLiteral,",
                    "    enclosingQuote.quote,",
                    "  ]);",
                    "}",
                    "",
                    "/* SubExpression print helpers */",
                    "",
                    "function printSubExpressionPathAndParams(path, print) {",
                    "  const p = printPath(path, print);",
                    "  const params = printParams(path, print);",
                    "",
                    "  if (!params) {",
                    "    return p;",
                    "  }",
                    "",
                    "  return indent(concat([p, line, group(params)]));",
                    "}",
                    "",
                    "/* misc. print helpers */",
                    "",
                    "function printPathAndParams(path, print) {",
                    "  const p = printPath(path, print);",
                    "  const params = printParams(path, print);",
                    "",
                    "  if (!params) {",
                    "    return p;",
                    "  }",
                    "",
                    "  return indent(group(concat([p, line, params])));",
                    "}",
                    "",
                    "function printPath(path, print) {",
                    "  return path.call(print, \"path\");",
                    "}",
                    "",
                    "function printParams(path, print) {",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  if (node.params.length) {",
                    "    const params = path.map(print, \"params\");",
                    "    parts.push(...params);",
                    "  }",
                    "",
                    "  if (node.hash && node.hash.pairs.length > 0) {",
                    "    const hash = path.call(print, \"hash\");",
                    "    parts.push(hash);",
                    "  }",
                    "",
                    "  if (!parts.length) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return join(line, parts);",
                    "}",
                    "",
                    "function printBlockParams(node) {",
                    "  if (!node || !node.blockParams.length) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return concat([\" as |\", node.blockParams.join(\" \"), \"|\"]);",
                    "}",
                    "",
                    "/* istanbul ignore next",
                    "   https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/compiler/lib/location.ts#L5-L29",
                    "*/",
                    "function locationToOffset(source, line, column) {",
                    "  let seenLines = 0;",
                    "  let seenChars = 0;",
                    "",
                    "  // eslint-disable-next-line no-constant-condition",
                    "  while (true) {",
                    "    if (seenChars === source.length) {",
                    "      return null;",
                    "    }",
                    "",
                    "    let nextLine = source.indexOf(\"\\n\", seenChars);",
                    "    if (nextLine === -1) {",
                    "      nextLine = source.length;",
                    "    }",
                    "",
                    "    if (seenLines === line) {",
                    "      if (seenChars + column > nextLine) {",
                    "        return null;",
                    "      }",
                    "      return seenChars + column;",
                    "    } else if (nextLine === -1) {",
                    "      return null;",
                    "    }",
                    "    seenLines += 1;",
                    "    seenChars = nextLine + 1;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  print,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// http://w3c.github.io/html/single-page.html#void-elements",
                    "const voidTags = new Set([",
                    "  \"area\",",
                    "  \"base\",",
                    "  \"br\",",
                    "  \"col\",",
                    "  \"embed\",",
                    "  \"hr\",",
                    "  \"img\",",
                    "  \"input\",",
                    "  \"link\",",
                    "  \"meta\",",
                    "  \"param\",",
                    "  \"source\",",
                    "  \"track\",",
                    "  \"wbr\",",
                    "]);",
                    "",
                    "function isUppercase(string) {",
                    "  return string.toUpperCase() === string;",
                    "}",
                    "",
                    "function isGlimmerComponent(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"ElementNode\"]) &&",
                    "    typeof node.tag === \"string\" &&",
                    "    (isUppercase(node.tag[0]) || node.tag.includes(\".\"))",
                    "  );",
                    "}",
                    "",
                    "function isVoid(node) {",
                    "  return (",
                    "    (isGlimmerComponent(node) &&",
                    "      (node.children === 0 ||",
                    "        node.children.every((n) => isWhitespaceNode(n)))) ||",
                    "    voidTags.has(node.tag)",
                    "  );",
                    "}",
                    "",
                    "function isWhitespaceNode(node) {",
                    "  return isNodeOfSomeType(node, [\"TextNode\"]) && !/\\S/.test(node.chars);",
                    "}",
                    "",
                    "function isNodeOfSomeType(node, types) {",
                    "  return node && types.some((type) => node.type === type);",
                    "}",
                    "",
                    "function isParentOfSomeType(path, types) {",
                    "  const parentNode = path.getParentNode(0);",
                    "  return isNodeOfSomeType(parentNode, types);",
                    "}",
                    "",
                    "function isPreviousNodeOfSomeType(path, types) {",
                    "  const previousNode = getPreviousNode(path);",
                    "  return isNodeOfSomeType(previousNode, types);",
                    "}",
                    "",
                    "function isNextNodeOfSomeType(path, types) {",
                    "  const nextNode = getNextNode(path);",
                    "  return isNodeOfSomeType(nextNode, types);",
                    "}",
                    "",
                    "function getSiblingNode(path, offset) {",
                    "  const node = path.getValue();",
                    "  const parentNode = path.getParentNode(0) || {};",
                    "  const children =",
                    "    parentNode.children || parentNode.body || parentNode.parts || [];",
                    "  const index = children.indexOf(node);",
                    "  return index !== -1 && children[index + offset];",
                    "}",
                    "",
                    "function getPreviousNode(path, lookBack = 1) {",
                    "  return getSiblingNode(path, -lookBack);",
                    "}",
                    "",
                    "function getNextNode(path) {",
                    "  return getSiblingNode(path, 1);",
                    "}",
                    "",
                    "function isPrettierIgnoreNode(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"MustacheCommentStatement\"]) &&",
                    "    typeof node.value === \"string\" &&",
                    "    node.value.trim() === \"prettier-ignore\"",
                    "  );",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const node = path.getValue();",
                    "  const previousPreviousNode = getPreviousNode(path, 2);",
                    "  return (",
                    "    isPrettierIgnoreNode(node) || isPrettierIgnoreNode(previousPreviousNode)",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  getNextNode,",
                    "  getPreviousNode,",
                    "  hasPrettierIgnore,",
                    "  isNextNodeOfSomeType,",
                    "  isNodeOfSomeType,",
                    "  isParentOfSomeType,",
                    "  isPreviousNodeOfSomeType,",
                    "  isVoid,",
                    "  isWhitespaceNode,",
                    "};"
                ]
            }
        },
        "language-html": {
            "ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const NODES_KEYS = {",
                    "  attrs: true,",
                    "  children: true,",
                    "};",
                    "",
                    "class Node {",
                    "  constructor(props = {}) {",
                    "    for (const key of Object.keys(props)) {",
                    "      const value = props[key];",
                    "      if (key in NODES_KEYS) {",
                    "        this._setNodes(key, value);",
                    "      } else {",
                    "        this[key] = value;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  _setNodes(key, nodes) {",
                    "    if (nodes !== this[key]) {",
                    "      this[key] = cloneAndUpdateNodes(nodes, this);",
                    "      if (key === \"attrs\") {",
                    "        setNonEnumerableProperties(this, {",
                    "          attrMap: this[key].reduce((reduced, attr) => {",
                    "            reduced[attr.fullName] = attr.value;",
                    "            return reduced;",
                    "          }, Object.create(null)),",
                    "        });",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  map(fn) {",
                    "    let newNode = null;",
                    "",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        const mappedNodes = mapNodesIfChanged(nodes, (node) => node.map(fn));",
                    "        if (newNode !== nodes) {",
                    "          if (!newNode) {",
                    "            newNode = new Node();",
                    "          }",
                    "          newNode._setNodes(NODES_KEY, mappedNodes);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newNode) {",
                    "      for (const key in this) {",
                    "        if (!(key in NODES_KEYS)) {",
                    "          newNode[key] = this[key];",
                    "        }",
                    "      }",
                    "      const { index, siblings, prev, next, parent } = this;",
                    "      setNonEnumerableProperties(newNode, {",
                    "        index,",
                    "        siblings,",
                    "        prev,",
                    "        next,",
                    "        parent,",
                    "      });",
                    "    }",
                    "",
                    "    return fn(newNode || this);",
                    "  }",
                    "",
                    "  clone(overrides) {",
                    "    return new Node(overrides ? { ...this, ...overrides } : this);",
                    "  }",
                    "",
                    "  get firstChild() {",
                    "    return this.children && this.children.length !== 0",
                    "      ? this.children[0]",
                    "      : null;",
                    "  }",
                    "",
                    "  get lastChild() {",
                    "    return this.children && this.children.length !== 0",
                    "      ? this.children[this.children.length - 1]",
                    "      : null;",
                    "  }",
                    "",
                    "  // for element and attribute",
                    "  get rawName() {",
                    "    return this.hasExplicitNamespace ? this.fullName : this.name;",
                    "  }",
                    "  get fullName() {",
                    "    return this.namespace ? this.namespace + \":\" + this.name : this.name;",
                    "  }",
                    "}",
                    "",
                    "function mapNodesIfChanged(nodes, fn) {",
                    "  const newNodes = nodes.map(fn);",
                    "  return newNodes.some((newNode, index) => newNode !== nodes[index])",
                    "    ? newNodes",
                    "    : nodes;",
                    "}",
                    "",
                    "function cloneAndUpdateNodes(nodes, parent) {",
                    "  const siblings = nodes.map((node) =>",
                    "    node instanceof Node ? node.clone() : new Node(node)",
                    "  );",
                    "",
                    "  let prev = null;",
                    "  let current = siblings[0];",
                    "  let next = siblings[1] || null;",
                    "",
                    "  for (let index = 0; index < siblings.length; index++) {",
                    "    setNonEnumerableProperties(current, {",
                    "      index,",
                    "      siblings,",
                    "      prev,",
                    "      next,",
                    "      parent,",
                    "    });",
                    "    prev = current;",
                    "    current = next;",
                    "    next = siblings[index + 2] || null;",
                    "  }",
                    "",
                    "  return siblings;",
                    "}",
                    "",
                    "function setNonEnumerableProperties(obj, props) {",
                    "  const descriptors = Object.keys(props).reduce((reduced, key) => {",
                    "    reduced[key] = { value: props[key], enumerable: false };",
                    "    return reduced;",
                    "  }, {});",
                    "  Object.defineProperties(obj, descriptors);",
                    "}",
                    "",
                    "module.exports = {",
                    "  Node,",
                    "};"
                ]
            },
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isFrontMatterNode } = require(\"../common/util\");",
                    "",
                    "module.exports = function (ast, newNode) {",
                    "  delete newNode.sourceSpan;",
                    "  delete newNode.startSourceSpan;",
                    "  delete newNode.endSourceSpan;",
                    "  delete newNode.nameSpan;",
                    "  delete newNode.valueSpan;",
                    "",
                    "  if (ast.type === \"text\" || ast.type === \"comment\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // may be formatted by multiparser",
                    "  if (isFrontMatterNode(ast) || ast.type === \"yaml\" || ast.type === \"toml\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"attribute\") {",
                    "    delete newNode.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"docType\") {",
                    "    delete newNode.value;",
                    "  }",
                    "};"
                ]
            },
            "conditional-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// https://css-tricks.com/how-to-create-an-ie-only-stylesheet",
                    "",
                    "// <!--[if ... ]> ... <![endif]-->",
                    "const IE_CONDITIONAL_START_END_COMMENT_REGEX = /^(\\[if([^\\]]*?)]>)([\\S\\s]*?)<!\\s*\\[endif]$/;",
                    "// <!--[if ... ]><!-->",
                    "const IE_CONDITIONAL_START_COMMENT_REGEX = /^\\[if([^\\]]*?)]><!$/;",
                    "// <!--<![endif]-->",
                    "const IE_CONDITIONAL_END_COMMENT_REGEX = /^<!\\s*\\[endif]$/;",
                    "",
                    "const REGEX_PARSE_TUPLES = [",
                    "  [IE_CONDITIONAL_START_END_COMMENT_REGEX, parseIeConditionalStartEndComment],",
                    "  [IE_CONDITIONAL_START_COMMENT_REGEX, parseIeConditionalStartComment],",
                    "  [IE_CONDITIONAL_END_COMMENT_REGEX, parseIeConditionalEndComment],",
                    "];",
                    "",
                    "function parseIeConditionalComment(node, parseHtml) {",
                    "  if (node.value) {",
                    "    let match;",
                    "    for (const [regex, parse] of REGEX_PARSE_TUPLES) {",
                    "      if ((match = node.value.match(regex))) {",
                    "        return parse(node, parseHtml, match);",
                    "      }",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function parseIeConditionalStartEndComment(node, parseHtml, match) {",
                    "  const [, openingTagSuffix, condition, data] = match;",
                    "  const offset = \"<!--\".length + openingTagSuffix.length;",
                    "  const contentStartSpan = node.sourceSpan.start.moveBy(offset);",
                    "  const contentEndSpan = contentStartSpan.moveBy(data.length);",
                    "  const ParseSourceSpan = node.sourceSpan.constructor;",
                    "  const [complete, children] = (() => {",
                    "    try {",
                    "      return [true, parseHtml(data, contentStartSpan).children];",
                    "    } catch (e) {",
                    "      const text = {",
                    "        type: \"text\",",
                    "        value: data,",
                    "        sourceSpan: new ParseSourceSpan(contentStartSpan, contentEndSpan),",
                    "      };",
                    "      return [false, [text]];",
                    "    }",
                    "  })();",
                    "  return {",
                    "    type: \"ieConditionalComment\",",
                    "    complete,",
                    "    children,",
                    "    condition: condition.trim().replace(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "    startSourceSpan: new ParseSourceSpan(",
                    "      node.sourceSpan.start,",
                    "      contentStartSpan",
                    "    ),",
                    "    endSourceSpan: new ParseSourceSpan(contentEndSpan, node.sourceSpan.end),",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalStartComment(node, parseHtml, match) {",
                    "  const [, condition] = match;",
                    "  return {",
                    "    type: \"ieConditionalStartComment\",",
                    "    condition: condition.trim().replace(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalEndComment(node /*, parseHtml, match */) {",
                    "  return {",
                    "    type: \"ieConditionalEndComment\",",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  parseIeConditionalComment,",
                    "};"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const htmlStyles = require(\"html-styles\");",
                    "const fromPairs = require(\"lodash/fromPairs\");",
                    "const flat = require(\"lodash/flatten\");",
                    "",
                    "const getCssStyleTags = (property) =>",
                    "  fromPairs(",
                    "    flat(",
                    "      htmlStyles",
                    "        .filter((htmlStyle) => htmlStyle.style[property])",
                    "        .map((htmlStyle) =>",
                    "          htmlStyle.selectorText",
                    "            .split(\",\")",
                    "            .map((selector) => selector.trim())",
                    "            .filter((selector) => /^[\\dA-Za-z]+$/.test(selector))",
                    "            .map((tagName) => [tagName, htmlStyle.style[property]])",
                    "        )",
                    "    )",
                    "  );",
                    "",
                    "const CSS_DISPLAY_TAGS = {",
                    "  ...getCssStyleTags(\"display\"),",
                    "",
                    "  // TODO: send PR to upstream",
                    "",
                    "  button: \"inline-block\",",
                    "",
                    "  // special cases for some css display=none elements",
                    "  template: \"inline\",",
                    "  source: \"block\",",
                    "  track: \"block\",",
                    "  script: \"block\",",
                    "",
                    "  // there's no css display for these elements but they behave these ways",
                    "  video: \"inline-block\",",
                    "  audio: \"inline-block\",",
                    "  select: \"inline-block\",",
                    "  optgroup: \"inline-block\",",
                    "};",
                    "const CSS_DISPLAY_DEFAULT = \"inline\";",
                    "const CSS_WHITE_SPACE_TAGS = getCssStyleTags(\"white-space\");",
                    "const CSS_WHITE_SPACE_DEFAULT = \"normal\";",
                    "",
                    "module.exports = {",
                    "  CSS_DISPLAY_TAGS,",
                    "  CSS_DISPLAY_DEFAULT,",
                    "  CSS_WHITE_SPACE_TAGS,",
                    "  CSS_WHITE_SPACE_DEFAULT,",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-html\");",
                    "const createLanguage = require(\"../utils/create-language\");",
                    "const options = require(\"./options\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/HTML\"), () => ({",
                    "    name: \"Angular\",",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"angular\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [\".component.html\"],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/HTML\"), (data) => ({",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"html\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: data.extensions.concat([",
                    "      \".mjml\", // MJML is considered XML in Linguist but it should be formatted as HTML",
                    "    ]),",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/HTML\"), () => ({",
                    "    name: \"Lightning Web Components\",",
                    "    since: \"1.17.0\",",
                    "    parsers: [\"lwc\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Vue\"), () => ({",
                    "    since: \"1.10.0\",",
                    "    parsers: [\"vue\"],",
                    "    vscodeLanguageIds: [\"vue\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  html: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers,",
                    "  options,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const CATEGORY_HTML = \"HTML\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js",
                    "module.exports = {",
                    "  htmlWhitespaceSensitivity: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_HTML,",
                    "    type: \"choice\",",
                    "    default: \"css\",",
                    "    description: \"How to handle whitespaces in HTML.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"css\",",
                    "        description: \"Respect the default value of CSS display property.\",",
                    "      },",
                    "      {",
                    "        value: \"strict\",",
                    "        description: \"Whitespaces are considered sensitive.\",",
                    "      },",
                    "      {",
                    "        value: \"ignore\",",
                    "        description: \"Whitespaces are considered insensitive.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  vueIndentScriptAndStyle: {",
                    "    since: \"1.19.0\",",
                    "    category: CATEGORY_HTML,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent script and style tags in Vue files.\",",
                    "  },",
                    "};"
                ]
            },
            "parser-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parseFrontMatter = require(\"../utils/front-matter\");",
                    "const {",
                    "  HTML_ELEMENT_ATTRIBUTES,",
                    "  HTML_TAGS,",
                    "  isUnknownNamespace,",
                    "} = require(\"./utils\");",
                    "const { hasPragma } = require(\"./pragma\");",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const { Node } = require(\"./ast\");",
                    "const { parseIeConditionalComment } = require(\"./conditional-comment\");",
                    "const { getParserName } = require(\"../common/util\");",
                    "",
                    "function ngHtmlParser(",
                    "  input,",
                    "  {",
                    "    recognizeSelfClosing,",
                    "    normalizeTagName,",
                    "    normalizeAttributeName,",
                    "    allowHtmComponentClosingTags,",
                    "    isTagNameCaseSensitive,",
                    "    getTagContentType,",
                    "  },",
                    "  options",
                    ") {",
                    "  const parser = require(\"angular-html-parser\");",
                    "  const {",
                    "    RecursiveVisitor,",
                    "    visitAll,",
                    "    Attribute,",
                    "    CDATA,",
                    "    Comment,",
                    "    DocType,",
                    "    Element,",
                    "    Text,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/ml_parser/ast\");",
                    "  const {",
                    "    ParseSourceSpan,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "  const {",
                    "    getHtmlTagDefinition,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/ml_parser/html_tags\");",
                    "",
                    "  let { rootNodes, errors } = parser.parse(input, {",
                    "    canSelfClose: recognizeSelfClosing,",
                    "    allowHtmComponentClosingTags,",
                    "    isTagNameCaseSensitive,",
                    "    getTagContentType,",
                    "  });",
                    "",
                    "  const isVueHtml =",
                    "    options.parser === \"vue\" &&",
                    "    rootNodes.some(",
                    "      (node) =>",
                    "        (node instanceof DocType && node.value === \"html\") ||",
                    "        (node instanceof Element && node.name.toLowerCase() === \"html\")",
                    "    );",
                    "",
                    "  if (options.parser === \"vue\" && !isVueHtml) {",
                    "    const shouldParseAsHTML = (node) => {",
                    "      if (!node) {",
                    "        return false;",
                    "      }",
                    "      if (node.name !== \"template\") {",
                    "        return false;",
                    "      }",
                    "      const langAttr = node.attrs.find((attr) => attr.name === \"lang\");",
                    "      const langValue = langAttr && langAttr.value;",
                    "      return langValue == null || getParserName(langValue, options) === \"html\";",
                    "    };",
                    "    if (rootNodes.some(shouldParseAsHTML)) {",
                    "      let secondParseResult;",
                    "      const doSecondParse = () =>",
                    "        parser.parse(input, {",
                    "          canSelfClose: recognizeSelfClosing,",
                    "          allowHtmComponentClosingTags,",
                    "          isTagNameCaseSensitive,",
                    "        });",
                    "      const getSecondParse = () =>",
                    "        secondParseResult || (secondParseResult = doSecondParse());",
                    "      const getSameLocationNode = (node) =>",
                    "        getSecondParse().rootNodes.find(",
                    "          ({ startSourceSpan }) =>",
                    "            startSourceSpan &&",
                    "            startSourceSpan.start.offset === node.startSourceSpan.start.offset",
                    "        );",
                    "      for (let i = 0; i < rootNodes.length; i++) {",
                    "        const node = rootNodes[i];",
                    "        const { endSourceSpan, startSourceSpan } = node;",
                    "        const isUnclosedNode = endSourceSpan === null;",
                    "        if (isUnclosedNode) {",
                    "          const result = getSecondParse();",
                    "          errors = result.errors;",
                    "          rootNodes[i] = getSameLocationNode(node) || node;",
                    "        } else if (shouldParseAsHTML(node)) {",
                    "          const result = getSecondParse();",
                    "          const startOffset = startSourceSpan.end.offset;",
                    "          const endOffset = endSourceSpan.start.offset;",
                    "          for (const error of result.errors) {",
                    "            const { offset } = error.span.start;",
                    "            if (startOffset < offset && offset < endOffset) {",
                    "              errors = [error];",
                    "              break;",
                    "            }",
                    "          }",
                    "          rootNodes[i] = getSameLocationNode(node) || node;",
                    "        }",
                    "      }",
                    "    }",
                    "  } else if (isVueHtml) {",
                    "    // If not Vue SFC, treat as html",
                    "    recognizeSelfClosing = true;",
                    "    normalizeTagName = true;",
                    "    normalizeAttributeName = true;",
                    "    allowHtmComponentClosingTags = true;",
                    "    isTagNameCaseSensitive = false;",
                    "    const htmlParseResult = parser.parse(input, {",
                    "      canSelfClose: recognizeSelfClosing,",
                    "      allowHtmComponentClosingTags,",
                    "      isTagNameCaseSensitive,",
                    "    });",
                    "",
                    "    rootNodes = htmlParseResult.rootNodes;",
                    "    errors = htmlParseResult.errors;",
                    "  }",
                    "",
                    "  if (errors.length !== 0) {",
                    "    const { msg, span } = errors[0];",
                    "    const { line, col } = span.start;",
                    "    throw createError(msg, { start: { line: line + 1, column: col + 1 } });",
                    "  }",
                    "",
                    "  const addType = (node) => {",
                    "    if (node instanceof Attribute) {",
                    "      node.type = \"attribute\";",
                    "    } else if (node instanceof CDATA) {",
                    "      node.type = \"cdata\";",
                    "    } else if (node instanceof Comment) {",
                    "      node.type = \"comment\";",
                    "    } else if (node instanceof DocType) {",
                    "      node.type = \"docType\";",
                    "    } else if (node instanceof Element) {",
                    "      node.type = \"element\";",
                    "    } else if (node instanceof Text) {",
                    "      node.type = \"text\";",
                    "    } else {",
                    "      throw new Error(`Unexpected node ${JSON.stringify(node)}`);",
                    "    }",
                    "  };",
                    "",
                    "  const restoreName = (node) => {",
                    "    const namespace = node.name.startsWith(\":\")",
                    "      ? node.name.slice(1).split(\":\")[0]",
                    "      : null;",
                    "    const rawName = node.nameSpan.toString();",
                    "    const hasExplicitNamespace = rawName.startsWith(`${namespace}:`);",
                    "    const name = hasExplicitNamespace",
                    "      ? rawName.slice(namespace.length + 1)",
                    "      : rawName;",
                    "",
                    "    node.name = name;",
                    "    node.namespace = namespace;",
                    "    node.hasExplicitNamespace = hasExplicitNamespace;",
                    "  };",
                    "",
                    "  const restoreNameAndValue = (node) => {",
                    "    if (node instanceof Element) {",
                    "      restoreName(node);",
                    "      node.attrs.forEach((attr) => {",
                    "        restoreName(attr);",
                    "        if (!attr.valueSpan) {",
                    "          attr.value = null;",
                    "        } else {",
                    "          attr.value = attr.valueSpan.toString();",
                    "          if (/[\"']/.test(attr.value[0])) {",
                    "            attr.value = attr.value.slice(1, -1);",
                    "          }",
                    "        }",
                    "      });",
                    "    } else if (node instanceof Comment) {",
                    "      node.value = node.sourceSpan",
                    "        .toString()",
                    "        .slice(\"<!--\".length, -\"-->\".length);",
                    "    } else if (node instanceof Text) {",
                    "      node.value = node.sourceSpan.toString();",
                    "    }",
                    "  };",
                    "",
                    "  const lowerCaseIfFn = (text, fn) => {",
                    "    const lowerCasedText = text.toLowerCase();",
                    "    return fn(lowerCasedText) ? lowerCasedText : text;",
                    "  };",
                    "  const normalizeName = (node) => {",
                    "    if (node instanceof Element) {",
                    "      if (",
                    "        normalizeTagName &&",
                    "        (!node.namespace ||",
                    "          node.namespace === node.tagDefinition.implicitNamespacePrefix ||",
                    "          isUnknownNamespace(node))",
                    "      ) {",
                    "        node.name = lowerCaseIfFn(",
                    "          node.name,",
                    "          (lowerCasedName) => lowerCasedName in HTML_TAGS",
                    "        );",
                    "      }",
                    "",
                    "      if (normalizeAttributeName) {",
                    "        const CURRENT_HTML_ELEMENT_ATTRIBUTES =",
                    "          HTML_ELEMENT_ATTRIBUTES[node.name] || Object.create(null);",
                    "        node.attrs.forEach((attr) => {",
                    "          if (!attr.namespace) {",
                    "            attr.name = lowerCaseIfFn(",
                    "              attr.name,",
                    "              (lowerCasedAttrName) =>",
                    "                node.name in HTML_ELEMENT_ATTRIBUTES &&",
                    "                (lowerCasedAttrName in HTML_ELEMENT_ATTRIBUTES[\"*\"] ||",
                    "                  lowerCasedAttrName in CURRENT_HTML_ELEMENT_ATTRIBUTES)",
                    "            );",
                    "          }",
                    "        });",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  const fixSourceSpan = (node) => {",
                    "    if (node.sourceSpan && node.endSourceSpan) {",
                    "      node.sourceSpan = new ParseSourceSpan(",
                    "        node.sourceSpan.start,",
                    "        node.endSourceSpan.end",
                    "      );",
                    "    }",
                    "  };",
                    "",
                    "  const addTagDefinition = (node) => {",
                    "    if (node instanceof Element) {",
                    "      const tagDefinition = getHtmlTagDefinition(",
                    "        isTagNameCaseSensitive ? node.name : node.name.toLowerCase()",
                    "      );",
                    "      if (",
                    "        !node.namespace ||",
                    "        node.namespace === tagDefinition.implicitNamespacePrefix ||",
                    "        isUnknownNamespace(node)",
                    "      ) {",
                    "        node.tagDefinition = tagDefinition;",
                    "      } else {",
                    "        node.tagDefinition = getHtmlTagDefinition(\"\"); // the default one",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  visitAll(",
                    "    new (class extends RecursiveVisitor {",
                    "      visit(node) {",
                    "        addType(node);",
                    "        restoreNameAndValue(node);",
                    "        addTagDefinition(node);",
                    "        normalizeName(node);",
                    "        fixSourceSpan(node);",
                    "      }",
                    "    })(),",
                    "    rootNodes",
                    "  );",
                    "",
                    "  return rootNodes;",
                    "}",
                    "",
                    "function _parse(text, options, parserOptions, shouldParseFrontMatter = true) {",
                    "  const { frontMatter, content } = shouldParseFrontMatter",
                    "    ? parseFrontMatter(text)",
                    "    : { frontMatter: null, content: text };",
                    "",
                    "  const rawAst = {",
                    "    type: \"root\",",
                    "    sourceSpan: { start: { offset: 0 }, end: { offset: text.length } },",
                    "    children: ngHtmlParser(content, parserOptions, options),",
                    "  };",
                    "",
                    "  if (frontMatter) {",
                    "    rawAst.children.unshift(frontMatter);",
                    "  }",
                    "",
                    "  const ast = new Node(rawAst);",
                    "",
                    "  const parseSubHtml = (subContent, startSpan) => {",
                    "    const { offset } = startSpan;",
                    "    const fakeContent = text.slice(0, offset).replace(/[^\\n\\r]/g, \" \");",
                    "    const realContent = subContent;",
                    "    const subAst = _parse(",
                    "      fakeContent + realContent,",
                    "      options,",
                    "      parserOptions,",
                    "      false",
                    "    );",
                    "    const ParseSourceSpan = subAst.children[0].sourceSpan.constructor;",
                    "    subAst.sourceSpan = new ParseSourceSpan(",
                    "      startSpan,",
                    "      subAst.children[subAst.children.length - 1].sourceSpan.end",
                    "    );",
                    "    const firstText = subAst.children[0];",
                    "    if (firstText.length === offset) {",
                    "      subAst.children.shift();",
                    "    } else {",
                    "      firstText.sourceSpan = new ParseSourceSpan(",
                    "        firstText.sourceSpan.start.moveBy(offset),",
                    "        firstText.sourceSpan.end",
                    "      );",
                    "      firstText.value = firstText.value.slice(offset);",
                    "    }",
                    "    return subAst;",
                    "  };",
                    "",
                    "  return ast.map((node) => {",
                    "    if (node.type === \"comment\") {",
                    "      const ieConditionalComment = parseIeConditionalComment(",
                    "        node,",
                    "        parseSubHtml",
                    "      );",
                    "      if (ieConditionalComment) {",
                    "        return ieConditionalComment;",
                    "      }",
                    "    }",
                    "",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function locStart(node) {",
                    "  return node.sourceSpan.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.sourceSpan.end.offset;",
                    "}",
                    "",
                    "function createParser({",
                    "  recognizeSelfClosing = false,",
                    "  normalizeTagName = false,",
                    "  normalizeAttributeName = false,",
                    "  allowHtmComponentClosingTags = false,",
                    "  isTagNameCaseSensitive = false,",
                    "  getTagContentType,",
                    "} = {}) {",
                    "  return {",
                    "    parse: (text, parsers, options) =>",
                    "      _parse(text, options, {",
                    "        recognizeSelfClosing,",
                    "        normalizeTagName,",
                    "        normalizeAttributeName,",
                    "        allowHtmComponentClosingTags,",
                    "        isTagNameCaseSensitive,",
                    "        getTagContentType,",
                    "      }),",
                    "    hasPragma,",
                    "    astFormat: \"html\",",
                    "    locStart,",
                    "    locEnd,",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    html: createParser({",
                    "      recognizeSelfClosing: true,",
                    "      normalizeTagName: true,",
                    "      normalizeAttributeName: true,",
                    "      allowHtmComponentClosingTags: true,",
                    "    }),",
                    "    angular: createParser(),",
                    "    vue: createParser({",
                    "      recognizeSelfClosing: true,",
                    "      isTagNameCaseSensitive: true,",
                    "      getTagContentType: (tagName, prefix, hasParent, attrs) => {",
                    "        if (",
                    "          tagName.toLowerCase() !== \"html\" &&",
                    "          !hasParent &&",
                    "          (tagName !== \"template\" ||",
                    "            attrs.some(",
                    "              ({ name, value }) => name === \"lang\" && value !== \"html\"",
                    "            ))",
                    "        ) {",
                    "          return require(\"angular-html-parser\").TagContentType.RAW_TEXT;",
                    "        }",
                    "      },",
                    "    }),",
                    "    lwc: createParser(),",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*<!--\\s*@(format|prettier)\\s*-->/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"<!-- @format -->\\n\\n\" + text.replace(/^\\s*\\n/, \"\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  htmlTrim,",
                    "  getLeadingAndTrailingHtmlWhitespace,",
                    "  hasHtmlWhitespace,",
                    "  canHaveInterpolation,",
                    "  getNodeCssStyleDisplay,",
                    "  isDanglingSpaceSensitiveNode,",
                    "  isIndentationSensitiveNode,",
                    "  isLeadingSpaceSensitiveNode,",
                    "  isTrailingSpaceSensitiveNode,",
                    "  isWhitespaceSensitiveNode,",
                    "} = require(\"./utils\");",
                    "",
                    "const PREPROCESS_PIPELINE = [",
                    "  removeIgnorableFirstLf,",
                    "  mergeIeConditonalStartEndCommentIntoElementOpeningTag,",
                    "  mergeCdataIntoText,",
                    "  extractInterpolation,",
                    "  extractWhitespaces,",
                    "  addCssDisplay,",
                    "  addIsSelfClosing,",
                    "  addHasHtmComponentClosingTag,",
                    "  addIsSpaceSensitive,",
                    "  mergeSimpleElementIntoText,",
                    "];",
                    "",
                    "function preprocess(ast, options) {",
                    "  for (const fn of PREPROCESS_PIPELINE) {",
                    "    ast = fn(ast, options);",
                    "  }",
                    "  return ast;",
                    "}",
                    "",
                    "function removeIgnorableFirstLf(ast /*, options */) {",
                    "  return ast.map((node) => {",
                    "    if (",
                    "      node.type === \"element\" &&",
                    "      node.tagDefinition.ignoreFirstLf &&",
                    "      node.children.length !== 0 &&",
                    "      node.children[0].type === \"text\" &&",
                    "      node.children[0].value[0] === \"\\n\"",
                    "    ) {",
                    "      const [text, ...rest] = node.children;",
                    "      return node.clone({",
                    "        children:",
                    "          text.value.length === 1",
                    "            ? rest",
                    "            : [text.clone({ value: text.value.slice(1) }), ...rest],",
                    "      });",
                    "    }",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function mergeIeConditonalStartEndCommentIntoElementOpeningTag(",
                    "  ast /*, options */",
                    ") {",
                    "  /**",
                    "   *     <!--[if ...]><!--><target><!--<![endif]-->",
                    "   */",
                    "  const isTarget = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.prev &&",
                    "    node.prev.type === \"ieConditionalStartComment\" &&",
                    "    node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset &&",
                    "    node.firstChild &&",
                    "    node.firstChild.type === \"ieConditionalEndComment\" &&",
                    "    node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;",
                    "  return ast.map((node) => {",
                    "    if (node.children) {",
                    "      const isTargetResults = node.children.map(isTarget);",
                    "      if (isTargetResults.some(Boolean)) {",
                    "        const newChildren = [];",
                    "",
                    "        for (let i = 0; i < node.children.length; i++) {",
                    "          const child = node.children[i];",
                    "",
                    "          if (isTargetResults[i + 1]) {",
                    "            // ieConditionalStartComment",
                    "            continue;",
                    "          }",
                    "",
                    "          if (isTargetResults[i]) {",
                    "            const ieConditionalStartComment = child.prev;",
                    "            const ieConditionalEndComment = child.firstChild;",
                    "",
                    "            const ParseSourceSpan = child.sourceSpan.constructor;",
                    "            const startSourceSpan = new ParseSourceSpan(",
                    "              ieConditionalStartComment.sourceSpan.start,",
                    "              ieConditionalEndComment.sourceSpan.end",
                    "            );",
                    "            const sourceSpan = new ParseSourceSpan(",
                    "              startSourceSpan.start,",
                    "              child.sourceSpan.end",
                    "            );",
                    "",
                    "            newChildren.push(",
                    "              child.clone({",
                    "                condition: ieConditionalStartComment.condition,",
                    "                sourceSpan,",
                    "                startSourceSpan,",
                    "                children: child.children.slice(1),",
                    "              })",
                    "            );",
                    "",
                    "            continue;",
                    "          }",
                    "",
                    "          newChildren.push(child);",
                    "        }",
                    "",
                    "        return node.clone({ children: newChildren });",
                    "      }",
                    "    }",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function mergeNodeIntoText(ast, shouldMerge, getValue) {",
                    "  return ast.map((node) => {",
                    "    if (node.children) {",
                    "      const shouldMergeResults = node.children.map(shouldMerge);",
                    "      if (shouldMergeResults.some(Boolean)) {",
                    "        const newChildren = [];",
                    "        for (let i = 0; i < node.children.length; i++) {",
                    "          const child = node.children[i];",
                    "",
                    "          if (child.type !== \"text\" && !shouldMergeResults[i]) {",
                    "            newChildren.push(child);",
                    "            continue;",
                    "          }",
                    "",
                    "          const newChild =",
                    "            child.type === \"text\"",
                    "              ? child",
                    "              : child.clone({ type: \"text\", value: getValue(child) });",
                    "",
                    "          if (",
                    "            newChildren.length === 0 ||",
                    "            newChildren[newChildren.length - 1].type !== \"text\"",
                    "          ) {",
                    "            newChildren.push(newChild);",
                    "            continue;",
                    "          }",
                    "",
                    "          const lastChild = newChildren.pop();",
                    "          const ParseSourceSpan = lastChild.sourceSpan.constructor;",
                    "          newChildren.push(",
                    "            lastChild.clone({",
                    "              value: lastChild.value + newChild.value,",
                    "              sourceSpan: new ParseSourceSpan(",
                    "                lastChild.sourceSpan.start,",
                    "                newChild.sourceSpan.end",
                    "              ),",
                    "            })",
                    "          );",
                    "        }",
                    "        return node.clone({ children: newChildren });",
                    "      }",
                    "    }",
                    "",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function mergeCdataIntoText(ast /*, options */) {",
                    "  return mergeNodeIntoText(",
                    "    ast,",
                    "    (node) => node.type === \"cdata\",",
                    "    (node) => `<![CDATA[${node.value}]]>`",
                    "  );",
                    "}",
                    "",
                    "function mergeSimpleElementIntoText(ast /*, options */) {",
                    "  const isSimpleElement = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.attrs.length === 0 &&",
                    "    node.children.length === 1 &&",
                    "    node.firstChild.type === \"text\" &&",
                    "    !hasHtmlWhitespace(node.children[0].value) &&",
                    "    !node.firstChild.hasLeadingSpaces &&",
                    "    !node.firstChild.hasTrailingSpaces &&",
                    "    node.isLeadingSpaceSensitive &&",
                    "    !node.hasLeadingSpaces &&",
                    "    node.isTrailingSpaceSensitive &&",
                    "    !node.hasTrailingSpaces &&",
                    "    node.prev &&",
                    "    node.prev.type === \"text\" &&",
                    "    node.next &&",
                    "    node.next.type === \"text\";",
                    "  return ast.map((node) => {",
                    "    if (node.children) {",
                    "      const isSimpleElementResults = node.children.map(isSimpleElement);",
                    "      if (isSimpleElementResults.some(Boolean)) {",
                    "        const newChildren = [];",
                    "        for (let i = 0; i < node.children.length; i++) {",
                    "          const child = node.children[i];",
                    "          if (isSimpleElementResults[i]) {",
                    "            const lastChild = newChildren.pop();",
                    "            const nextChild = node.children[++i];",
                    "            const ParseSourceSpan = node.sourceSpan.constructor;",
                    "            const { isTrailingSpaceSensitive, hasTrailingSpaces } = nextChild;",
                    "            newChildren.push(",
                    "              lastChild.clone({",
                    "                value:",
                    "                  lastChild.value +",
                    "                  `<${child.rawName}>` +",
                    "                  child.firstChild.value +",
                    "                  `</${child.rawName}>` +",
                    "                  nextChild.value,",
                    "                sourceSpan: new ParseSourceSpan(",
                    "                  lastChild.sourceSpan.start,",
                    "                  nextChild.sourceSpan.end",
                    "                ),",
                    "                isTrailingSpaceSensitive,",
                    "                hasTrailingSpaces,",
                    "              })",
                    "            );",
                    "          } else {",
                    "            newChildren.push(child);",
                    "          }",
                    "        }",
                    "        return node.clone({ children: newChildren });",
                    "      }",
                    "    }",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function extractInterpolation(ast, options) {",
                    "  if (options.parser === \"html\") {",
                    "    return ast;",
                    "  }",
                    "",
                    "  const interpolationRegex = /{{([\\S\\s]+?)}}/g;",
                    "  return ast.map((node) => {",
                    "    if (!canHaveInterpolation(node)) {",
                    "      return node;",
                    "    }",
                    "",
                    "    const newChildren = [];",
                    "",
                    "    for (const child of node.children) {",
                    "      if (child.type !== \"text\") {",
                    "        newChildren.push(child);",
                    "        continue;",
                    "      }",
                    "",
                    "      const ParseSourceSpan = child.sourceSpan.constructor;",
                    "",
                    "      let startSourceSpan = child.sourceSpan.start;",
                    "      let endSourceSpan = null;",
                    "      const components = child.value.split(interpolationRegex);",
                    "      for (",
                    "        let i = 0;",
                    "        i < components.length;",
                    "        i++, startSourceSpan = endSourceSpan",
                    "      ) {",
                    "        const value = components[i];",
                    "",
                    "        if (i % 2 === 0) {",
                    "          endSourceSpan = startSourceSpan.moveBy(value.length);",
                    "          if (value.length !== 0) {",
                    "            newChildren.push({",
                    "              type: \"text\",",
                    "              value,",
                    "              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "            });",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`",
                    "        newChildren.push({",
                    "          type: \"interpolation\",",
                    "          sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "          children:",
                    "            value.length === 0",
                    "              ? []",
                    "              : [",
                    "                  {",
                    "                    type: \"text\",",
                    "                    value,",
                    "                    sourceSpan: new ParseSourceSpan(",
                    "                      startSourceSpan.moveBy(2),",
                    "                      endSourceSpan.moveBy(-2)",
                    "                    ),",
                    "                  },",
                    "                ],",
                    "        });",
                    "      }",
                    "    }",
                    "",
                    "    return node.clone({ children: newChildren });",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `hasLeadingSpaces` field",
                    " * - add `hasTrailingSpaces` field",
                    " * - add `hasDanglingSpaces` field for parent nodes",
                    " * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes",
                    " * - remove insensitive whitespaces",
                    " */",
                    "function extractWhitespaces(ast /*, options*/) {",
                    "  const TYPE_WHITESPACE = \"whitespace\";",
                    "  return ast.map((node) => {",
                    "    if (!node.children) {",
                    "      return node;",
                    "    }",
                    "",
                    "    if (",
                    "      node.children.length === 0 ||",
                    "      (node.children.length === 1 &&",
                    "        node.children[0].type === \"text\" &&",
                    "        htmlTrim(node.children[0].value).length === 0)",
                    "    ) {",
                    "      return node.clone({",
                    "        children: [],",
                    "        hasDanglingSpaces: node.children.length !== 0,",
                    "      });",
                    "    }",
                    "",
                    "    const isWhitespaceSensitive = isWhitespaceSensitiveNode(node);",
                    "    const isIndentationSensitive = isIndentationSensitiveNode(node);",
                    "",
                    "    return node.clone({",
                    "      isWhitespaceSensitive,",
                    "      isIndentationSensitive,",
                    "      children: node.children",
                    "        // extract whitespace nodes",
                    "        .reduce((newChildren, child) => {",
                    "          if (child.type !== \"text\" || isWhitespaceSensitive) {",
                    "            return newChildren.concat(child);",
                    "          }",
                    "",
                    "          const localChildren = [];",
                    "",
                    "          const {",
                    "            leadingWhitespace,",
                    "            text,",
                    "            trailingWhitespace,",
                    "          } = getLeadingAndTrailingHtmlWhitespace(child.value);",
                    "",
                    "          if (leadingWhitespace) {",
                    "            localChildren.push({ type: TYPE_WHITESPACE });",
                    "          }",
                    "",
                    "          const ParseSourceSpan = child.sourceSpan.constructor;",
                    "",
                    "          if (text) {",
                    "            localChildren.push({",
                    "              type: \"text\",",
                    "              value: text,",
                    "              sourceSpan: new ParseSourceSpan(",
                    "                child.sourceSpan.start.moveBy(leadingWhitespace.length),",
                    "                child.sourceSpan.end.moveBy(-trailingWhitespace.length)",
                    "              ),",
                    "            });",
                    "          }",
                    "",
                    "          if (trailingWhitespace) {",
                    "            localChildren.push({ type: TYPE_WHITESPACE });",
                    "          }",
                    "",
                    "          return newChildren.concat(localChildren);",
                    "        }, [])",
                    "        // set hasLeadingSpaces/hasTrailingSpaces and filter whitespace nodes",
                    "        .reduce((newChildren, child, i, children) => {",
                    "          if (child.type === TYPE_WHITESPACE) {",
                    "            return newChildren;",
                    "          }",
                    "",
                    "          const hasLeadingSpaces =",
                    "            i !== 0 && children[i - 1].type === TYPE_WHITESPACE;",
                    "          const hasTrailingSpaces =",
                    "            i !== children.length - 1 &&",
                    "            children[i + 1].type === TYPE_WHITESPACE;",
                    "",
                    "          return newChildren.concat({",
                    "            ...child,",
                    "            hasLeadingSpaces,",
                    "            hasTrailingSpaces,",
                    "          });",
                    "        }, []),",
                    "    });",
                    "  });",
                    "}",
                    "",
                    "function addIsSelfClosing(ast /*, options */) {",
                    "  return ast.map((node) =>",
                    "    Object.assign(node, {",
                    "      isSelfClosing:",
                    "        !node.children ||",
                    "        (node.type === \"element\" &&",
                    "          (node.tagDefinition.isVoid ||",
                    "            // self-closing",
                    "            node.startSourceSpan === node.endSourceSpan)),",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function addHasHtmComponentClosingTag(ast, options) {",
                    "  return ast.map((node) =>",
                    "    node.type !== \"element\"",
                    "      ? node",
                    "      : Object.assign(node, {",
                    "          hasHtmComponentClosingTag:",
                    "            node.endSourceSpan &&",
                    "            /^<\\s*\\/\\s*\\/\\s*>$/.test(",
                    "              options.originalText.slice(",
                    "                node.endSourceSpan.start.offset,",
                    "                node.endSourceSpan.end.offset",
                    "              )",
                    "            ),",
                    "        })",
                    "  );",
                    "}",
                    "",
                    "function addCssDisplay(ast, options) {",
                    "  return ast.map((node) =>",
                    "    Object.assign(node, { cssDisplay: getNodeCssStyleDisplay(node, options) })",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * - add `isLeadingSpaceSensitive` field",
                    " * - add `isTrailingSpaceSensitive` field",
                    " * - add `isDanglingSpaceSensitive` field for parent nodes",
                    " */",
                    "function addIsSpaceSensitive(ast, options) {",
                    "  return ast.map((node) => {",
                    "    if (!node.children) {",
                    "      return node;",
                    "    }",
                    "",
                    "    if (node.children.length === 0) {",
                    "      return node.clone({",
                    "        isDanglingSpaceSensitive: isDanglingSpaceSensitiveNode(node),",
                    "      });",
                    "    }",
                    "",
                    "    return node.clone({",
                    "      children: node.children",
                    "        .map((child) => {",
                    "          return {",
                    "            ...child,",
                    "            isLeadingSpaceSensitive: isLeadingSpaceSensitiveNode(",
                    "              child,",
                    "              options",
                    "            ),",
                    "            isTrailingSpaceSensitive: isTrailingSpaceSensitiveNode(",
                    "              child,",
                    "              options",
                    "            ),",
                    "          };",
                    "        })",
                    "        .map((child, index, children) => ({",
                    "          ...child,",
                    "          isLeadingSpaceSensitive:",
                    "            index === 0",
                    "              ? child.isLeadingSpaceSensitive",
                    "              : children[index - 1].isTrailingSpaceSensitive &&",
                    "                child.isLeadingSpaceSensitive,",
                    "          isTrailingSpaceSensitive:",
                    "            index === children.length - 1",
                    "              ? child.isTrailingSpaceSensitive",
                    "              : children[index + 1].isLeadingSpaceSensitive &&",
                    "                child.isTrailingSpaceSensitive,",
                    "        })),",
                    "    });",
                    "  });",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const clean = require(\"./clean\");",
                    "const {",
                    "  builders,",
                    "  utils: { stripTrailingHardline, mapDoc, normalizeParts },",
                    "} = require(\"../document\");",
                    "const {",
                    "  breakParent,",
                    "  dedentToRoot,",
                    "  fill,",
                    "  group,",
                    "  hardline,",
                    "  ifBreak,",
                    "  indent,",
                    "  join,",
                    "  line,",
                    "  literalline,",
                    "  markAsRoot,",
                    "  softline,",
                    "} = builders;",
                    "const {",
                    "  htmlTrimPreserveIndentation,",
                    "  splitByHtmlWhitespace,",
                    "  countChars,",
                    "  countParents,",
                    "  dedentString,",
                    "  forceBreakChildren,",
                    "  forceBreakContent,",
                    "  forceNextEmptyLine,",
                    "  getLastDescendant,",
                    "  getPrettierIgnoreAttributeCommentData,",
                    "  hasPrettierIgnore,",
                    "  inferScriptParser,",
                    "  isVueCustomBlock,",
                    "  isScriptLikeTag,",
                    "  isTextLikeNode,",
                    "  preferHardlineAsLeadingSpaces,",
                    "  shouldNotPrintClosingTag,",
                    "  shouldPreserveContent,",
                    "  unescapeQuoteEntities,",
                    "} = require(\"./utils\");",
                    "const { replaceEndOfLineWith } = require(\"../common/util\");",
                    "const preprocess = require(\"./preprocess\");",
                    "const assert = require(\"assert\");",
                    "const { insertPragma } = require(\"./pragma\");",
                    "const {",
                    "  printVueFor,",
                    "  printVueSlotScope,",
                    "  isVueEventBindingExpression,",
                    "} = require(\"./syntax-vue\");",
                    "const { printImgSrcset, printClassNames } = require(\"./syntax-attribute\");",
                    "",
                    "function concat(parts) {",
                    "  const newParts = normalizeParts(parts);",
                    "  return newParts.length === 0",
                    "    ? \"\"",
                    "    : newParts.length === 1",
                    "    ? newParts[0]",
                    "    : builders.concat(newParts);",
                    "}",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "  switch (node.type) {",
                    "    case \"text\": {",
                    "      if (isScriptLikeTag(node.parent)) {",
                    "        const parser = inferScriptParser(node.parent);",
                    "        if (parser) {",
                    "          const value =",
                    "            parser === \"markdown\"",
                    "              ? dedentString(node.value.replace(/^[^\\S\\n]*?\\n/, \"\"))",
                    "              : node.value;",
                    "          const textToDocOptions = { parser };",
                    "          if (options.parser === \"html\" && parser === \"babel\") {",
                    "            let sourceType = \"script\";",
                    "            const { attrMap } = node.parent;",
                    "            if (",
                    "              attrMap &&",
                    "              (attrMap.type === \"module\" ||",
                    "                (attrMap.type === \"text/babel\" &&",
                    "                  attrMap[\"data-type\"] === \"module\"))",
                    "            ) {",
                    "              sourceType = \"module\";",
                    "            }",
                    "            textToDocOptions.__babelSourceType = sourceType;",
                    "          }",
                    "          return builders.concat([",
                    "            concat([",
                    "              breakParent,",
                    "              printOpeningTagPrefix(node, options),",
                    "              stripTrailingHardline(textToDoc(value, textToDocOptions)),",
                    "              printClosingTagSuffix(node, options),",
                    "            ]),",
                    "          ]);",
                    "        }",
                    "      } else if (node.parent.type === \"interpolation\") {",
                    "        return concat([",
                    "          indent(",
                    "            concat([",
                    "              line,",
                    "              textToDoc(node.value, {",
                    "                __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                    "                ...(options.parser === \"angular\"",
                    "                  ? { parser: \"__ng_interpolation\", trailingComma: \"none\" }",
                    "                  : options.parser === \"vue\"",
                    "                  ? { parser: \"__vue_expression\" }",
                    "                  : { parser: \"__js_expression\" }),",
                    "              }),",
                    "            ])",
                    "          ),",
                    "          node.parent.next &&",
                    "          needsToBorrowPrevClosingTagEndMarker(node.parent.next)",
                    "            ? \" \"",
                    "            : line,",
                    "        ]);",
                    "      } else if (isVueCustomBlock(node.parent, options)) {",
                    "        const parser = inferScriptParser(node.parent, options);",
                    "        let printed;",
                    "        if (parser) {",
                    "          try {",
                    "            printed = textToDoc(node.value, { parser });",
                    "          } catch (error) {",
                    "            // Do nothing",
                    "          }",
                    "        }",
                    "        if (printed == null) {",
                    "          printed = node.value;",
                    "        }",
                    "        return concat([",
                    "          parser ? breakParent : \"\",",
                    "          printOpeningTagPrefix(node),",
                    "          stripTrailingHardline(printed, true),",
                    "          printClosingTagSuffix(node),",
                    "        ]);",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"attribute\": {",
                    "      if (!node.value) {",
                    "        break;",
                    "      }",
                    "",
                    "      // lit-html: html`<my-element obj=${obj}></my-element>`",
                    "      if (",
                    "        /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(",
                    "          options.originalText.slice(",
                    "            node.valueSpan.start.offset,",
                    "            node.valueSpan.end.offset",
                    "          )",
                    "        )",
                    "      ) {",
                    "        return concat([node.rawName, \"=\", node.value]);",
                    "      }",
                    "",
                    "      // lwc: html`<my-element data-for={value}></my-element>`",
                    "      if (options.parser === \"lwc\") {",
                    "        const interpolationRegex = /^{[\\S\\s]*}$/;",
                    "        if (",
                    "          interpolationRegex.test(",
                    "            options.originalText.slice(",
                    "              node.valueSpan.start.offset,",
                    "              node.valueSpan.end.offset",
                    "            )",
                    "          )",
                    "        ) {",
                    "          return concat([node.rawName, \"=\", node.value]);",
                    "        }",
                    "      }",
                    "",
                    "      const embeddedAttributeValueDoc = printEmbeddedAttributeValue(",
                    "        node,",
                    "        (code, opts) =>",
                    "          // strictly prefer single quote to avoid unnecessary html entity escape",
                    "          textToDoc(code, { __isInHtmlAttribute: true, ...opts }),",
                    "        options",
                    "      );",
                    "      if (embeddedAttributeValueDoc) {",
                    "        return concat([",
                    "          node.rawName,",
                    "          '=\"',",
                    "          group(",
                    "            mapDoc(embeddedAttributeValueDoc, (doc) =>",
                    "              typeof doc === \"string\" ? doc.replace(/\"/g, \"&quot;\") : doc",
                    "            )",
                    "          ),",
                    "          '\"',",
                    "        ]);",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"front-matter\":",
                    "      if (node.lang === \"yaml\") {",
                    "        return markAsRoot(",
                    "          concat([",
                    "            \"---\",",
                    "            hardline,",
                    "            node.value.trim().length === 0",
                    "              ? \"\"",
                    "              : textToDoc(node.value, { parser: \"yaml\" }),",
                    "            \"---\",",
                    "          ])",
                    "        );",
                    "      }",
                    "  }",
                    "}",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return concat(replaceEndOfLineWith(node.raw, literalline));",
                    "    case \"root\":",
                    "      if (options.__onHtmlRoot) {",
                    "        options.__onHtmlRoot(node);",
                    "      }",
                    "      // use original concat to not break stripTrailingHardline",
                    "      return builders.concat([",
                    "        group(printChildren(path, options, print)),",
                    "        hardline,",
                    "      ]);",
                    "    case \"element\":",
                    "    case \"ieConditionalComment\": {",
                    "      /**",
                    "       * do not break:",
                    "       *",
                    "       *     <div>{{",
                    "       *         ~",
                    "       *       interpolation",
                    "       *     }}</div>",
                    "       *            ~",
                    "       *",
                    "       * exception: break if the opening tag breaks",
                    "       *",
                    "       *     <div",
                    "       *       long",
                    "       *           ~",
                    "       *       >{{",
                    "       *         interpolation",
                    "       *       }}</div",
                    "       *              ~",
                    "       *     >",
                    "       */",
                    "      const shouldHugContent =",
                    "        node.children.length === 1 &&",
                    "        node.firstChild.type === \"interpolation\" &&",
                    "        node.firstChild.isLeadingSpaceSensitive &&",
                    "        !node.firstChild.hasLeadingSpaces &&",
                    "        node.lastChild.isTrailingSpaceSensitive &&",
                    "        !node.lastChild.hasTrailingSpaces;",
                    "      const attrGroupId = Symbol(\"element-attr-group-id\");",
                    "      return concat([",
                    "        group(",
                    "          concat([",
                    "            group(printOpeningTag(path, options, print), { id: attrGroupId }),",
                    "            node.children.length === 0",
                    "              ? node.hasDanglingSpaces && node.isDanglingSpaceSensitive",
                    "                ? line",
                    "                : \"\"",
                    "              : concat([",
                    "                  forceBreakContent(node) ? breakParent : \"\",",
                    "                  ((childrenDoc) =>",
                    "                    shouldHugContent",
                    "                      ? ifBreak(indent(childrenDoc), childrenDoc, {",
                    "                          groupId: attrGroupId,",
                    "                        })",
                    "                      : (isScriptLikeTag(node) ||",
                    "                          isVueCustomBlock(node, options)) &&",
                    "                        node.parent.type === \"root\" &&",
                    "                        options.parser === \"vue\" &&",
                    "                        !options.vueIndentScriptAndStyle",
                    "                      ? childrenDoc",
                    "                      : indent(childrenDoc))(",
                    "                    concat([",
                    "                      shouldHugContent",
                    "                        ? ifBreak(softline, \"\", { groupId: attrGroupId })",
                    "                        : node.firstChild.hasLeadingSpaces &&",
                    "                          node.firstChild.isLeadingSpaceSensitive",
                    "                        ? line",
                    "                        : node.firstChild.type === \"text\" &&",
                    "                          node.isWhitespaceSensitive &&",
                    "                          node.isIndentationSensitive",
                    "                        ? dedentToRoot(softline)",
                    "                        : softline,",
                    "                      printChildren(path, options, print),",
                    "                    ])",
                    "                  ),",
                    "                  (",
                    "                    node.next",
                    "                      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                    "                      : needsToBorrowLastChildClosingTagEndMarker(node.parent)",
                    "                  )",
                    "                    ? node.lastChild.hasTrailingSpaces &&",
                    "                      node.lastChild.isTrailingSpaceSensitive",
                    "                      ? \" \"",
                    "                      : \"\"",
                    "                    : shouldHugContent",
                    "                    ? ifBreak(softline, \"\", { groupId: attrGroupId })",
                    "                    : node.lastChild.hasTrailingSpaces &&",
                    "                      node.lastChild.isTrailingSpaceSensitive",
                    "                    ? line",
                    "                    : (node.lastChild.type === \"comment\" ||",
                    "                        (node.lastChild.type === \"text\" &&",
                    "                          node.isWhitespaceSensitive &&",
                    "                          node.isIndentationSensitive)) &&",
                    "                      new RegExp(",
                    "                        `\\\\n[\\\\t ]{${",
                    "                          options.tabWidth *",
                    "                          countParents(",
                    "                            path,",
                    "                            (n) => n.parent && n.parent.type !== \"root\"",
                    "                          )",
                    "                        }}$`",
                    "                      ).test(node.lastChild.value)",
                    "                    ? /**",
                    "                       *     <div>",
                    "                       *       <pre>",
                    "                       *         something",
                    "                       *       </pre>",
                    "                       *            ~",
                    "                       *     </div>",
                    "                       */",
                    "                      \"\"",
                    "                    : softline,",
                    "                ]),",
                    "          ])",
                    "        ),",
                    "        printClosingTag(node, options),",
                    "      ]);",
                    "    }",
                    "    case \"ieConditionalStartComment\":",
                    "    case \"ieConditionalEndComment\":",
                    "      return concat([printOpeningTagStart(node), printClosingTagEnd(node)]);",
                    "    case \"interpolation\":",
                    "      return concat([",
                    "        printOpeningTagStart(node, options),",
                    "        concat(path.map(print, \"children\")),",
                    "        printClosingTagEnd(node, options),",
                    "      ]);",
                    "    case \"text\": {",
                    "      if (node.parent.type === \"interpolation\") {",
                    "        // replace the trailing literalline with hardline for better readability",
                    "        const trailingNewlineRegex = /\\n[^\\S\\n]*?$/;",
                    "        const hasTrailingNewline = trailingNewlineRegex.test(node.value);",
                    "        const value = hasTrailingNewline",
                    "          ? node.value.replace(trailingNewlineRegex, \"\")",
                    "          : node.value;",
                    "        return concat([",
                    "          concat(replaceEndOfLineWith(value, literalline)),",
                    "          hasTrailingNewline ? hardline : \"\",",
                    "        ]);",
                    "      }",
                    "      return fill(",
                    "        normalizeParts(",
                    "          [].concat(",
                    "            printOpeningTagPrefix(node, options),",
                    "            getTextValueParts(node),",
                    "            printClosingTagSuffix(node, options)",
                    "          )",
                    "        )",
                    "      );",
                    "    }",
                    "    case \"docType\":",
                    "      return concat([",
                    "        group(",
                    "          concat([",
                    "            printOpeningTagStart(node, options),",
                    "            \" \",",
                    "            node.value.replace(/^html\\b/i, \"html\").replace(/\\s+/g, \" \"),",
                    "          ])",
                    "        ),",
                    "        printClosingTagEnd(node, options),",
                    "      ]);",
                    "    case \"comment\": {",
                    "      return concat([",
                    "        printOpeningTagPrefix(node, options),",
                    "        concat(",
                    "          replaceEndOfLineWith(",
                    "            options.originalText.slice(",
                    "              options.locStart(node),",
                    "              options.locEnd(node)",
                    "            ),",
                    "            literalline",
                    "          )",
                    "        ),",
                    "        printClosingTagSuffix(node, options),",
                    "      ]);",
                    "    }",
                    "    case \"attribute\": {",
                    "      if (node.value === null) {",
                    "        return node.rawName;",
                    "      }",
                    "      const value = unescapeQuoteEntities(node.value);",
                    "      const singleQuoteCount = countChars(value, \"'\");",
                    "      const doubleQuoteCount = countChars(value, '\"');",
                    "      const quote = singleQuoteCount < doubleQuoteCount ? \"'\" : '\"';",
                    "      return concat([",
                    "        node.rawName,",
                    "        concat([",
                    "          \"=\",",
                    "          quote,",
                    "          concat(",
                    "            replaceEndOfLineWith(",
                    "              quote === '\"'",
                    "                ? value.replace(/\"/g, \"&quot;\")",
                    "                : value.replace(/'/g, \"&apos;\"),",
                    "              literalline",
                    "            )",
                    "          ),",
                    "          quote,",
                    "        ]),",
                    "      ]);",
                    "    }",
                    "    case \"yaml\":",
                    "    case \"toml\":",
                    "      return concat(replaceEndOfLineWith(node.raw, literalline));",
                    "    default:",
                    "      throw new Error(`Unexpected node type ${node.type}`);",
                    "  }",
                    "}",
                    "",
                    "function printChildren(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (forceBreakChildren(node)) {",
                    "    return concat([",
                    "      breakParent,",
                    "      concat(",
                    "        path.map((childPath) => {",
                    "          const childNode = childPath.getValue();",
                    "          const prevBetweenLine = !childNode.prev",
                    "            ? \"\"",
                    "            : printBetweenLine(childNode.prev, childNode);",
                    "          return concat([",
                    "            !prevBetweenLine",
                    "              ? \"\"",
                    "              : concat([",
                    "                  prevBetweenLine,",
                    "                  forceNextEmptyLine(childNode.prev) ? hardline : \"\",",
                    "                ]),",
                    "            printChild(childPath),",
                    "          ]);",
                    "        }, \"children\")",
                    "      ),",
                    "    ]);",
                    "  }",
                    "",
                    "  const groupIds = node.children.map(() => Symbol(\"\"));",
                    "  return concat(",
                    "    path.map((childPath, childIndex) => {",
                    "      const childNode = childPath.getValue();",
                    "",
                    "      if (isTextLikeNode(childNode)) {",
                    "        if (childNode.prev && isTextLikeNode(childNode.prev)) {",
                    "          const prevBetweenLine = printBetweenLine(childNode.prev, childNode);",
                    "          if (prevBetweenLine) {",
                    "            if (forceNextEmptyLine(childNode.prev)) {",
                    "              return concat([hardline, hardline, printChild(childPath)]);",
                    "            }",
                    "            return concat([prevBetweenLine, printChild(childPath)]);",
                    "          }",
                    "        }",
                    "        return printChild(childPath);",
                    "      }",
                    "",
                    "      const prevParts = [];",
                    "      const leadingParts = [];",
                    "      const trailingParts = [];",
                    "      const nextParts = [];",
                    "",
                    "      const prevBetweenLine = childNode.prev",
                    "        ? printBetweenLine(childNode.prev, childNode)",
                    "        : \"\";",
                    "",
                    "      const nextBetweenLine = childNode.next",
                    "        ? printBetweenLine(childNode, childNode.next)",
                    "        : \"\";",
                    "",
                    "      if (prevBetweenLine) {",
                    "        if (forceNextEmptyLine(childNode.prev)) {",
                    "          prevParts.push(hardline, hardline);",
                    "        } else if (prevBetweenLine === hardline) {",
                    "          prevParts.push(hardline);",
                    "        } else {",
                    "          if (isTextLikeNode(childNode.prev)) {",
                    "            leadingParts.push(prevBetweenLine);",
                    "          } else {",
                    "            leadingParts.push(",
                    "              ifBreak(\"\", softline, {",
                    "                groupId: groupIds[childIndex - 1],",
                    "              })",
                    "            );",
                    "          }",
                    "        }",
                    "      }",
                    "",
                    "      if (nextBetweenLine) {",
                    "        if (forceNextEmptyLine(childNode)) {",
                    "          if (isTextLikeNode(childNode.next)) {",
                    "            nextParts.push(hardline, hardline);",
                    "          }",
                    "        } else if (nextBetweenLine === hardline) {",
                    "          if (isTextLikeNode(childNode.next)) {",
                    "            nextParts.push(hardline);",
                    "          }",
                    "        } else {",
                    "          trailingParts.push(nextBetweenLine);",
                    "        }",
                    "      }",
                    "",
                    "      return concat(",
                    "        [].concat(",
                    "          prevParts,",
                    "          group(",
                    "            concat([",
                    "              concat(leadingParts),",
                    "              group(concat([printChild(childPath), concat(trailingParts)]), {",
                    "                id: groupIds[childIndex],",
                    "              }),",
                    "            ])",
                    "          ),",
                    "          nextParts",
                    "        )",
                    "      );",
                    "    }, \"children\")",
                    "  );",
                    "",
                    "  function printChild(childPath) {",
                    "    const child = childPath.getValue();",
                    "",
                    "    if (hasPrettierIgnore(child)) {",
                    "      return concat(",
                    "        [].concat(",
                    "          printOpeningTagPrefix(child, options),",
                    "          replaceEndOfLineWith(",
                    "            options.originalText.slice(",
                    "              options.locStart(child) +",
                    "                (child.prev &&",
                    "                needsToBorrowNextOpeningTagStartMarker(child.prev)",
                    "                  ? printOpeningTagStartMarker(child).length",
                    "                  : 0),",
                    "              options.locEnd(child) -",
                    "                (child.next && needsToBorrowPrevClosingTagEndMarker(child.next)",
                    "                  ? printClosingTagEndMarker(child, options).length",
                    "                  : 0)",
                    "            ),",
                    "            literalline",
                    "          ),",
                    "          printClosingTagSuffix(child, options)",
                    "        )",
                    "      );",
                    "    }",
                    "",
                    "    if (shouldPreserveContent(child, options)) {",
                    "      return concat(",
                    "        [].concat(",
                    "          printOpeningTagPrefix(child, options),",
                    "          group(printOpeningTag(childPath, options, print)),",
                    "          replaceEndOfLineWith(",
                    "            options.originalText.slice(",
                    "              child.startSourceSpan.end.offset +",
                    "                (child.firstChild &&",
                    "                needsToBorrowParentOpeningTagEndMarker(child.firstChild)",
                    "                  ? -printOpeningTagEndMarker(child).length",
                    "                  : 0),",
                    "              child.endSourceSpan.start.offset +",
                    "                (child.lastChild &&",
                    "                needsToBorrowParentClosingTagStartMarker(child.lastChild)",
                    "                  ? printClosingTagStartMarker(child, options).length",
                    "                  : needsToBorrowLastChildClosingTagEndMarker(child)",
                    "                  ? -printClosingTagEndMarker(child.lastChild, options).length",
                    "                  : 0)",
                    "            ),",
                    "            literalline",
                    "          ),",
                    "          printClosingTag(child, options),",
                    "          printClosingTagSuffix(child, options)",
                    "        )",
                    "      );",
                    "    }",
                    "",
                    "    return print(childPath);",
                    "  }",
                    "",
                    "  function printBetweenLine(prevNode, nextNode) {",
                    "    return isTextLikeNode(prevNode) && isTextLikeNode(nextNode)",
                    "      ? prevNode.isTrailingSpaceSensitive",
                    "        ? prevNode.hasTrailingSpaces",
                    "          ? preferHardlineAsLeadingSpaces(nextNode)",
                    "            ? hardline",
                    "            : line",
                    "          : \"\"",
                    "        : preferHardlineAsLeadingSpaces(nextNode)",
                    "        ? hardline",
                    "        : softline",
                    "      : (needsToBorrowNextOpeningTagStartMarker(prevNode) &&",
                    "          (hasPrettierIgnore(nextNode) ||",
                    "            /**",
                    "             *     123<a",
                    "             *          ~",
                    "             *       ><b>",
                    "             */",
                    "            nextNode.firstChild ||",
                    "            /**",
                    "             *     123<!--",
                    "             *            ~",
                    "             *     -->",
                    "             */",
                    "            nextNode.isSelfClosing ||",
                    "            /**",
                    "             *     123<span",
                    "             *             ~",
                    "             *       attr",
                    "             */",
                    "            (nextNode.type === \"element\" && nextNode.attrs.length !== 0))) ||",
                    "        /**",
                    "         *     <img",
                    "         *       src=\"long\"",
                    "         *                 ~",
                    "         *     />123",
                    "         */",
                    "        (prevNode.type === \"element\" &&",
                    "          prevNode.isSelfClosing &&",
                    "          needsToBorrowPrevClosingTagEndMarker(nextNode))",
                    "      ? \"\"",
                    "      : !nextNode.isLeadingSpaceSensitive ||",
                    "        preferHardlineAsLeadingSpaces(nextNode) ||",
                    "        /**",
                    "         *       Want to write us a letter? Use our<a",
                    "         *         ><b><a>mailing address</a></b></a",
                    "         *                                          ~",
                    "         *       >.",
                    "         */",
                    "        (needsToBorrowPrevClosingTagEndMarker(nextNode) &&",
                    "          prevNode.lastChild &&",
                    "          needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) &&",
                    "          prevNode.lastChild.lastChild &&",
                    "          needsToBorrowParentClosingTagStartMarker(",
                    "            prevNode.lastChild.lastChild",
                    "          ))",
                    "      ? hardline",
                    "      : nextNode.hasLeadingSpaces",
                    "      ? line",
                    "      : softline;",
                    "  }",
                    "}",
                    "",
                    "function printOpeningTag(path, options, print) {",
                    "  const node = path.getValue();",
                    "  const forceNotToBreakAttrContent =",
                    "    node.type === \"element\" &&",
                    "    node.fullName === \"script\" &&",
                    "    node.attrs.length === 1 &&",
                    "    node.attrs[0].fullName === \"src\" &&",
                    "    node.children.length === 0;",
                    "  return concat([",
                    "    printOpeningTagStart(node, options),",
                    "    !node.attrs || node.attrs.length === 0",
                    "      ? node.isSelfClosing",
                    "        ? /**",
                    "           *     <br />",
                    "           *        ^",
                    "           */",
                    "          \" \"",
                    "        : \"\"",
                    "      : concat([",
                    "          indent(",
                    "            concat([",
                    "              forceNotToBreakAttrContent ? \" \" : line,",
                    "              join(",
                    "                line,",
                    "                ((ignoreAttributeData) => {",
                    "                  const hasPrettierIgnoreAttribute =",
                    "                    typeof ignoreAttributeData === \"boolean\"",
                    "                      ? () => ignoreAttributeData",
                    "                      : Array.isArray(ignoreAttributeData)",
                    "                      ? (attr) => ignoreAttributeData.includes(attr.rawName)",
                    "                      : () => false;",
                    "                  return path.map((attrPath) => {",
                    "                    const attr = attrPath.getValue();",
                    "                    return hasPrettierIgnoreAttribute(attr)",
                    "                      ? concat(",
                    "                          replaceEndOfLineWith(",
                    "                            options.originalText.slice(",
                    "                              options.locStart(attr),",
                    "                              options.locEnd(attr)",
                    "                            ),",
                    "                            literalline",
                    "                          )",
                    "                        )",
                    "                      : print(attrPath);",
                    "                  }, \"attrs\");",
                    "                })(",
                    "                  node.prev &&",
                    "                    node.prev.type === \"comment\" &&",
                    "                    getPrettierIgnoreAttributeCommentData(node.prev.value)",
                    "                )",
                    "              ),",
                    "            ])",
                    "          ),",
                    "          /**",
                    "           *     123<a",
                    "           *       attr",
                    "           *           ~",
                    "           *       >456",
                    "           */",
                    "          (node.firstChild &&",
                    "            needsToBorrowParentOpeningTagEndMarker(node.firstChild)) ||",
                    "          /**",
                    "           *     <span",
                    "           *       >123<meta",
                    "           *                ~",
                    "           *     /></span>",
                    "           */",
                    "          (node.isSelfClosing &&",
                    "            needsToBorrowLastChildClosingTagEndMarker(node.parent))",
                    "            ? node.isSelfClosing",
                    "              ? \" \"",
                    "              : \"\"",
                    "            : node.isSelfClosing",
                    "            ? forceNotToBreakAttrContent",
                    "              ? \" \"",
                    "              : line",
                    "            : forceNotToBreakAttrContent",
                    "            ? \"\"",
                    "            : softline,",
                    "        ]),",
                    "    node.isSelfClosing ? \"\" : printOpeningTagEnd(node),",
                    "  ]);",
                    "}",
                    "",
                    "function printOpeningTagStart(node, options) {",
                    "  return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev)",
                    "    ? \"\"",
                    "    : concat([",
                    "        printOpeningTagPrefix(node, options),",
                    "        printOpeningTagStartMarker(node),",
                    "      ]);",
                    "}",
                    "",
                    "function printOpeningTagEnd(node) {",
                    "  return node.firstChild &&",
                    "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                    "    ? \"\"",
                    "    : printOpeningTagEndMarker(node);",
                    "}",
                    "",
                    "function printClosingTag(node, options) {",
                    "  return concat([",
                    "    node.isSelfClosing ? \"\" : printClosingTagStart(node, options),",
                    "    printClosingTagEnd(node, options),",
                    "  ]);",
                    "}",
                    "",
                    "function printClosingTagStart(node, options) {",
                    "  return node.lastChild &&",
                    "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                    "    ? \"\"",
                    "    : concat([",
                    "        printClosingTagPrefix(node, options),",
                    "        printClosingTagStartMarker(node, options),",
                    "      ]);",
                    "}",
                    "",
                    "function printClosingTagEnd(node, options) {",
                    "  return (",
                    "    node.next",
                    "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                    "      : needsToBorrowLastChildClosingTagEndMarker(node.parent)",
                    "  )",
                    "    ? \"\"",
                    "    : concat([",
                    "        printClosingTagEndMarker(node, options),",
                    "        printClosingTagSuffix(node, options),",
                    "      ]);",
                    "}",
                    "",
                    "function needsToBorrowNextOpeningTagStartMarker(node) {",
                    "  /**",
                    "   *     123<p",
                    "   *        ^^",
                    "   *     >",
                    "   */",
                    "  return (",
                    "    node.next &&",
                    "    !isTextLikeNode(node.next) &&",
                    "    isTextLikeNode(node) &&",
                    "    node.isTrailingSpaceSensitive &&",
                    "    !node.hasTrailingSpaces",
                    "  );",
                    "}",
                    "",
                    "function needsToBorrowParentOpeningTagEndMarker(node) {",
                    "  /**",
                    "   *     <p",
                    "   *       >123",
                    "   *       ^",
                    "   *",
                    "   *     <p",
                    "   *       ><a",
                    "   *       ^",
                    "   */",
                    "  return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;",
                    "}",
                    "",
                    "function needsToBorrowPrevClosingTagEndMarker(node) {",
                    "  /**",
                    "   *     <p></p",
                    "   *     >123",
                    "   *     ^",
                    "   *",
                    "   *     <p></p",
                    "   *     ><a",
                    "   *     ^",
                    "   */",
                    "  return (",
                    "    node.prev &&",
                    "    node.prev.type !== \"docType\" &&",
                    "    !isTextLikeNode(node.prev) &&",
                    "    node.isLeadingSpaceSensitive &&",
                    "    !node.hasLeadingSpaces",
                    "  );",
                    "}",
                    "",
                    "function needsToBorrowLastChildClosingTagEndMarker(node) {",
                    "  /**",
                    "   *     <p",
                    "   *       ><a></a",
                    "   *       ></p",
                    "   *       ^",
                    "   *     >",
                    "   */",
                    "  return (",
                    "    node.lastChild &&",
                    "    node.lastChild.isTrailingSpaceSensitive &&",
                    "    !node.lastChild.hasTrailingSpaces &&",
                    "    !isTextLikeNode(getLastDescendant(node.lastChild))",
                    "  );",
                    "}",
                    "",
                    "function needsToBorrowParentClosingTagStartMarker(node) {",
                    "  /**",
                    "   *     <p>",
                    "   *       123</p",
                    "   *          ^^^",
                    "   *     >",
                    "   *",
                    "   *         123</b",
                    "   *       ></a",
                    "   *        ^^^",
                    "   *     >",
                    "   */",
                    "  return (",
                    "    !node.next &&",
                    "    !node.hasTrailingSpaces &&",
                    "    node.isTrailingSpaceSensitive &&",
                    "    isTextLikeNode(getLastDescendant(node))",
                    "  );",
                    "}",
                    "",
                    "function printOpeningTagPrefix(node, options) {",
                    "  return needsToBorrowParentOpeningTagEndMarker(node)",
                    "    ? printOpeningTagEndMarker(node.parent)",
                    "    : needsToBorrowPrevClosingTagEndMarker(node)",
                    "    ? printClosingTagEndMarker(node.prev, options)",
                    "    : \"\";",
                    "}",
                    "",
                    "function printClosingTagPrefix(node, options) {",
                    "  return needsToBorrowLastChildClosingTagEndMarker(node)",
                    "    ? printClosingTagEndMarker(node.lastChild, options)",
                    "    : \"\";",
                    "}",
                    "",
                    "function printClosingTagSuffix(node, options) {",
                    "  return needsToBorrowParentClosingTagStartMarker(node)",
                    "    ? printClosingTagStartMarker(node.parent, options)",
                    "    : needsToBorrowNextOpeningTagStartMarker(node)",
                    "    ? printOpeningTagStartMarker(node.next)",
                    "    : \"\";",
                    "}",
                    "",
                    "function printOpeningTagStartMarker(node) {",
                    "  switch (node.type) {",
                    "    case \"ieConditionalComment\":",
                    "    case \"ieConditionalStartComment\":",
                    "      return `<!--[if ${node.condition}`;",
                    "    case \"ieConditionalEndComment\":",
                    "      return \"<!--<!\";",
                    "    case \"interpolation\":",
                    "      return \"{{\";",
                    "    case \"docType\":",
                    "      return \"<!DOCTYPE\";",
                    "    case \"element\":",
                    "      if (node.condition) {",
                    "        return `<!--[if ${node.condition}]><!--><${node.rawName}`;",
                    "      }",
                    "    // fall through",
                    "    default:",
                    "      return `<${node.rawName}`;",
                    "  }",
                    "}",
                    "",
                    "function printOpeningTagEndMarker(node) {",
                    "  assert(!node.isSelfClosing);",
                    "  switch (node.type) {",
                    "    case \"ieConditionalComment\":",
                    "      return \"]>\";",
                    "    case \"element\":",
                    "      if (node.condition) {",
                    "        return \"><!--<![endif]-->\";",
                    "      }",
                    "    // fall through",
                    "    default:",
                    "      return \">\";",
                    "  }",
                    "}",
                    "",
                    "function printClosingTagStartMarker(node, options) {",
                    "  assert(!node.isSelfClosing);",
                    "  if (shouldNotPrintClosingTag(node, options)) {",
                    "    return \"\";",
                    "  }",
                    "  switch (node.type) {",
                    "    case \"ieConditionalComment\":",
                    "      return \"<!\";",
                    "    case \"element\":",
                    "      if (node.hasHtmComponentClosingTag) {",
                    "        return \"<//\";",
                    "      }",
                    "    // fall through",
                    "    default:",
                    "      return `</${node.rawName}`;",
                    "  }",
                    "}",
                    "",
                    "function printClosingTagEndMarker(node, options) {",
                    "  if (shouldNotPrintClosingTag(node, options)) {",
                    "    return \"\";",
                    "  }",
                    "  switch (node.type) {",
                    "    case \"ieConditionalComment\":",
                    "    case \"ieConditionalEndComment\":",
                    "      return \"[endif]-->\";",
                    "    case \"ieConditionalStartComment\":",
                    "      return \"]><!-->\";",
                    "    case \"interpolation\":",
                    "      return \"}}\";",
                    "    case \"element\":",
                    "      if (node.isSelfClosing) {",
                    "        return \"/>\";",
                    "      }",
                    "    // fall through",
                    "    default:",
                    "      return \">\";",
                    "  }",
                    "}",
                    "",
                    "function getTextValueParts(node, value = node.value) {",
                    "  return node.parent.isWhitespaceSensitive",
                    "    ? node.parent.isIndentationSensitive",
                    "      ? replaceEndOfLineWith(value, literalline)",
                    "      : replaceEndOfLineWith(",
                    "          dedentString(htmlTrimPreserveIndentation(value)),",
                    "          hardline",
                    "        )",
                    "    : join(line, splitByHtmlWhitespace(value)).parts;",
                    "}",
                    "",
                    "function printEmbeddedAttributeValue(node, originalTextToDoc, options) {",
                    "  const isKeyMatched = (patterns) =>",
                    "    new RegExp(patterns.join(\"|\")).test(node.fullName);",
                    "  const getValue = () => unescapeQuoteEntities(node.value);",
                    "",
                    "  let shouldHug = false;",
                    "",
                    "  const __onHtmlBindingRoot = (root, options) => {",
                    "    const rootNode =",
                    "      root.type === \"NGRoot\"",
                    "        ? root.node.type === \"NGMicrosyntax\" &&",
                    "          root.node.body.length === 1 &&",
                    "          root.node.body[0].type === \"NGMicrosyntaxExpression\"",
                    "          ? root.node.body[0].expression",
                    "          : root.node",
                    "        : root.type === \"JsExpressionRoot\"",
                    "        ? root.node",
                    "        : root;",
                    "    if (",
                    "      rootNode &&",
                    "      (rootNode.type === \"ObjectExpression\" ||",
                    "        rootNode.type === \"ArrayExpression\" ||",
                    "        (options.parser === \"__vue_expression\" &&",
                    "          (rootNode.type === \"TemplateLiteral\" ||",
                    "            rootNode.type === \"StringLiteral\")))",
                    "    ) {",
                    "      shouldHug = true;",
                    "    }",
                    "  };",
                    "",
                    "  const printHug = (doc) => group(doc);",
                    "  const printExpand = (doc, canHaveTrailingWhitespace = true) =>",
                    "    group(",
                    "      concat([",
                    "        indent(concat([softline, doc])),",
                    "        canHaveTrailingWhitespace ? softline : \"\",",
                    "      ])",
                    "    );",
                    "  const printMaybeHug = (doc) => (shouldHug ? printHug(doc) : printExpand(doc));",
                    "",
                    "  const textToDoc = (code, opts) =>",
                    "    originalTextToDoc(code, { __onHtmlBindingRoot, ...opts });",
                    "",
                    "  if (",
                    "    node.fullName === \"srcset\" &&",
                    "    (node.parent.fullName === \"img\" || node.parent.fullName === \"source\")",
                    "  ) {",
                    "    return printExpand(printImgSrcset(getValue()));",
                    "  }",
                    "",
                    "  if (node.fullName === \"class\" && !options.parentParser) {",
                    "    const value = getValue();",
                    "    if (!value.includes(\"{{\")) {",
                    "      return printClassNames(value);",
                    "    }",
                    "  }",
                    "",
                    "  if (node.fullName === \"style\" && !options.parentParser) {",
                    "    const value = getValue();",
                    "    if (!value.includes(\"{{\")) {",
                    "      return printExpand(",
                    "        textToDoc(value, {",
                    "          parser: \"css\",",
                    "          __isHTMLStyleAttribute: true,",
                    "        })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (options.parser === \"vue\") {",
                    "    if (node.fullName === \"v-for\") {",
                    "      return printVueFor(getValue(), textToDoc);",
                    "    }",
                    "",
                    "    if (node.fullName === \"slot-scope\") {",
                    "      return printVueSlotScope(getValue(), textToDoc);",
                    "    }",
                    "",
                    "    /**",
                    "     *     @click=\"jsStatement\"",
                    "     *     @click=\"jsExpression\"",
                    "     *     v-on:click=\"jsStatement\"",
                    "     *     v-on:click=\"jsExpression\"",
                    "     */",
                    "    const vueEventBindingPatterns = [\"^@\", \"^v-on:\"];",
                    "    /**",
                    "     *     :class=\"vueExpression\"",
                    "     *     v-bind:id=\"vueExpression\"",
                    "     */",
                    "    const vueExpressionBindingPatterns = [\"^:\", \"^v-bind:\"];",
                    "    /**",
                    "     *     v-if=\"jsExpression\"",
                    "     */",
                    "    const jsExpressionBindingPatterns = [\"^v-\"];",
                    "",
                    "    if (isKeyMatched(vueEventBindingPatterns)) {",
                    "      const value = getValue();",
                    "      return printMaybeHug(",
                    "        isVueEventBindingExpression(value)",
                    "          ? textToDoc(value, { parser: \"__js_expression\" })",
                    "          : stripTrailingHardline(",
                    "              textToDoc(value, { parser: \"__vue_event_binding\" })",
                    "            )",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(vueExpressionBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        textToDoc(getValue(), { parser: \"__vue_expression\" })",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(jsExpressionBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        textToDoc(getValue(), { parser: \"__js_expression\" })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (options.parser === \"angular\") {",
                    "    const ngTextToDoc = (code, opts) =>",
                    "      // angular does not allow trailing comma",
                    "      textToDoc(code, { ...opts, trailingComma: \"none\" });",
                    "",
                    "    /**",
                    "     *     *directive=\"angularDirective\"",
                    "     */",
                    "    const ngDirectiveBindingPatterns = [\"^\\\\*\"];",
                    "    /**",
                    "     *     (click)=\"angularStatement\"",
                    "     *     on-click=\"angularStatement\"",
                    "     */",
                    "    const ngStatementBindingPatterns = [\"^\\\\(.+\\\\)$\", \"^on-\"];",
                    "    /**",
                    "     *     [target]=\"angularExpression\"",
                    "     *     bind-target=\"angularExpression\"",
                    "     *     [(target)]=\"angularExpression\"",
                    "     *     bindon-target=\"angularExpression\"",
                    "     */",
                    "    const ngExpressionBindingPatterns = [",
                    "      \"^\\\\[.+\\\\]$\",",
                    "      \"^bind(on)?-\",",
                    "      // Unofficial rudimentary support for some of the most used directives of AngularJS 1.x",
                    "      \"^ng-(if|show|hide|class|style)$\",",
                    "    ];",
                    "    /**",
                    "     *     i18n=\"longDescription\"",
                    "     *     i18n-attr=\"longDescription\"",
                    "     */",
                    "    const ngI18nPatterns = [\"^i18n(-.+)?$\"];",
                    "",
                    "    if (isKeyMatched(ngStatementBindingPatterns)) {",
                    "      return printMaybeHug(ngTextToDoc(getValue(), { parser: \"__ng_action\" }));",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngExpressionBindingPatterns)) {",
                    "      return printMaybeHug(ngTextToDoc(getValue(), { parser: \"__ng_binding\" }));",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngI18nPatterns)) {",
                    "      const value = getValue().trim();",
                    "      return printExpand(",
                    "        fill(getTextValueParts(node, value)),",
                    "        !value.includes(\"@@\")",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngDirectiveBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        ngTextToDoc(getValue(), { parser: \"__ng_directive\" })",
                    "      );",
                    "    }",
                    "",
                    "    const interpolationRegex = /{{([\\S\\s]+?)}}/g;",
                    "    const value = getValue();",
                    "    if (interpolationRegex.test(value)) {",
                    "      const parts = [];",
                    "      value.split(interpolationRegex).forEach((part, index) => {",
                    "        if (index % 2 === 0) {",
                    "          parts.push(concat(replaceEndOfLineWith(part, literalline)));",
                    "        } else {",
                    "          try {",
                    "            parts.push(",
                    "              group(",
                    "                concat([",
                    "                  \"{{\",",
                    "                  indent(",
                    "                    concat([",
                    "                      line,",
                    "                      ngTextToDoc(part, {",
                    "                        parser: \"__ng_interpolation\",",
                    "                        __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                    "                      }),",
                    "                    ])",
                    "                  ),",
                    "                  line,",
                    "                  \"}}\",",
                    "                ])",
                    "              )",
                    "            );",
                    "          } catch (e) {",
                    "            parts.push(",
                    "              \"{{\",",
                    "              concat(replaceEndOfLineWith(part, literalline)),",
                    "              \"}}\"",
                    "            );",
                    "          }",
                    "        }",
                    "      });",
                    "      return group(concat(parts));",
                    "    }",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  embed,",
                    "};"
                ]
            },
            "syntax-attribute.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { concat, ifBreak, join, line },",
                    "} = require(\"../document\");",
                    "const parseSrcset = require(\"parse-srcset\");",
                    "",
                    "function printImgSrcset(value) {",
                    "  const srcset = parseSrcset(value, {",
                    "    logger: {",
                    "      error(message) {",
                    "        throw new Error(message);",
                    "      },",
                    "    },",
                    "  });",
                    "",
                    "  const hasW = srcset.some(({ w }) => w);",
                    "  const hasH = srcset.some(({ h }) => h);",
                    "  const hasX = srcset.some(({ d }) => d);",
                    "",
                    "  if (hasW + hasH + hasX > 1) {",
                    "    throw new Error(\"Mixed descriptor in srcset is not supported\");",
                    "  }",
                    "",
                    "  const key = hasW ? \"w\" : hasH ? \"h\" : \"d\";",
                    "  const unit = hasW ? \"w\" : hasH ? \"h\" : \"x\";",
                    "",
                    "  const getMax = (values) => Math.max(...values);",
                    "",
                    "  const urls = srcset.map((src) => src.url);",
                    "  const maxUrlLength = getMax(urls.map((url) => url.length));",
                    "",
                    "  const descriptors = srcset",
                    "    .map((src) => src[key])",
                    "    .map((descriptor) => (descriptor ? descriptor.toString() : \"\"));",
                    "  const descriptorLeftLengths = descriptors.map((descriptor) => {",
                    "    const index = descriptor.indexOf(\".\");",
                    "    return index === -1 ? descriptor.length : index;",
                    "  });",
                    "  const maxDescriptorLeftLength = getMax(descriptorLeftLengths);",
                    "",
                    "  return join(",
                    "    concat([\",\", line]),",
                    "    urls.map((url, index) => {",
                    "      const parts = [url];",
                    "",
                    "      const descriptor = descriptors[index];",
                    "      if (descriptor) {",
                    "        const urlPadding = maxUrlLength - url.length + 1;",
                    "        const descriptorPadding =",
                    "          maxDescriptorLeftLength - descriptorLeftLengths[index];",
                    "",
                    "        const alignment = \" \".repeat(urlPadding + descriptorPadding);",
                    "        parts.push(ifBreak(alignment, \" \"), descriptor + unit);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function printClassNames(value) {",
                    "  return value.trim().split(/\\s+/).join(\" \");",
                    "}",
                    "",
                    "module.exports = {",
                    "  printImgSrcset,",
                    "  printClassNames,",
                    "};"
                ]
            },
            "syntax-vue.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { concat, group },",
                    "} = require(\"../document\");",
                    "",
                    "/**",
                    " *     v-for=\"... in ...\"",
                    " *     v-for=\"... of ...\"",
                    " *     v-for=\"(..., ...) in ...\"",
                    " *     v-for=\"(..., ...) of ...\"",
                    " */",
                    "function printVueFor(value, textToDoc) {",
                    "  const { left, operator, right } = parseVueFor(value);",
                    "  return concat([",
                    "    group(",
                    "      textToDoc(`function _(${left}) {}`, {",
                    "        parser: \"babel\",",
                    "        __isVueForBindingLeft: true,",
                    "      })",
                    "    ),",
                    "    \" \",",
                    "    operator,",
                    "    \" \",",
                    "    textToDoc(right, { parser: \"__js_expression\" }),",
                    "  ]);",
                    "}",
                    "",
                    "// modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387",
                    "function parseVueFor(value) {",
                    "  const forAliasRE = /([^]*?)\\s+(in|of)\\s+([^]*)/;",
                    "  const forIteratorRE = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/;",
                    "  const stripParensRE = /^\\(|\\)$/g;",
                    "",
                    "  const inMatch = value.match(forAliasRE);",
                    "  if (!inMatch) {",
                    "    return;",
                    "  }",
                    "  const res = {};",
                    "  res.for = inMatch[3].trim();",
                    "  const alias = inMatch[1].trim().replace(stripParensRE, \"\");",
                    "  const iteratorMatch = alias.match(forIteratorRE);",
                    "  if (iteratorMatch) {",
                    "    res.alias = alias.replace(forIteratorRE, \"\");",
                    "    res.iterator1 = iteratorMatch[1].trim();",
                    "    if (iteratorMatch[2]) {",
                    "      res.iterator2 = iteratorMatch[2].trim();",
                    "    }",
                    "  } else {",
                    "    res.alias = alias;",
                    "  }",
                    "",
                    "  return {",
                    "    left: `${[res.alias, res.iterator1, res.iterator2]",
                    "      .filter(Boolean)",
                    "      .join(\",\")}`,",
                    "    operator: inMatch[2],",
                    "    right: res.for,",
                    "  };",
                    "}",
                    "",
                    "function printVueSlotScope(value, textToDoc) {",
                    "  return textToDoc(`function _(${value}) {}`, {",
                    "    parser: \"babel\",",
                    "    __isVueSlotScope: true,",
                    "  });",
                    "}",
                    "",
                    "function isVueEventBindingExpression(eventBindingValue) {",
                    "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4",
                    "  // arrow function or anonymous function",
                    "  const fnExpRE = /^([\\w$]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;",
                    "  // simple member expression chain (a, a.b, a['b'], a[\"b\"], a[0], a[b])",
                    "  const simplePathRE = /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/;",
                    "",
                    "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104",
                    "  const value = eventBindingValue.trim();",
                    "",
                    "  return fnExpRE.test(value) || simplePathRE.test(value);",
                    "}",
                    "",
                    "module.exports = {",
                    "  isVueEventBindingExpression,",
                    "  printVueFor,",
                    "  printVueSlotScope,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  CSS_DISPLAY_TAGS,",
                    "  CSS_DISPLAY_DEFAULT,",
                    "  CSS_WHITE_SPACE_TAGS,",
                    "  CSS_WHITE_SPACE_DEFAULT,",
                    "} = require(\"./constants.evaluate\");",
                    "const { getParserName, isFrontMatterNode } = require(\"../common/util\");",
                    "",
                    "const htmlTagNames = require(\"html-tag-names\");",
                    "const htmlElementAttributes = require(\"html-element-attributes\");",
                    "",
                    "const HTML_TAGS = arrayToMap(htmlTagNames);",
                    "const HTML_ELEMENT_ATTRIBUTES = mapObject(htmlElementAttributes, arrayToMap);",
                    "",
                    "// https://infra.spec.whatwg.org/#ascii-whitespace",
                    "const HTML_WHITESPACE = new Set([\"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"]);",
                    "const htmlTrimStart = (string) => string.replace(/^[\\t\\n\\f\\r ]+/, \"\");",
                    "const htmlTrimEnd = (string) => string.replace(/[\\t\\n\\f\\r ]+$/, \"\");",
                    "const htmlTrim = (string) => htmlTrimStart(htmlTrimEnd(string));",
                    "const htmlTrimLeadingBlankLines = (string) =>",
                    "  string.replace(/^[\\t\\f\\r ]*?\\n/g, \"\");",
                    "const htmlTrimPreserveIndentation = (string) =>",
                    "  htmlTrimLeadingBlankLines(htmlTrimEnd(string));",
                    "const splitByHtmlWhitespace = (string) => string.split(/[\\t\\n\\f\\r ]+/);",
                    "const getLeadingHtmlWhitespace = (string) => string.match(/^[\\t\\n\\f\\r ]*/)[0];",
                    "const getLeadingAndTrailingHtmlWhitespace = (string) => {",
                    "  const [, leadingWhitespace, text, trailingWhitespace] = string.match(",
                    "    /^([\\t\\n\\f\\r ]*)([\\S\\s]*?)([\\t\\n\\f\\r ]*)$/",
                    "  );",
                    "  return {",
                    "    leadingWhitespace,",
                    "    trailingWhitespace,",
                    "    text,",
                    "  };",
                    "};",
                    "const hasHtmlWhitespace = (string) => /[\\t\\n\\f\\r ]/.test(string);",
                    "",
                    "function arrayToMap(array) {",
                    "  const map = Object.create(null);",
                    "  for (const value of array) {",
                    "    map[value] = true;",
                    "  }",
                    "  return map;",
                    "}",
                    "",
                    "function mapObject(object, fn) {",
                    "  const newObject = Object.create(null);",
                    "  for (const key of Object.keys(object)) {",
                    "    newObject[key] = fn(object[key], key);",
                    "  }",
                    "  return newObject;",
                    "}",
                    "",
                    "function shouldPreserveContent(node, options) {",
                    "  if (!node.endSourceSpan) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"element\" &&",
                    "    node.fullName === \"template\" &&",
                    "    node.attrMap.lang &&",
                    "    node.attrMap.lang !== \"html\"",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // unterminated node in ie conditional comment",
                    "  // e.g. <!--[if lt IE 9]><html><![endif]-->",
                    "  if (",
                    "    node.type === \"ieConditionalComment\" &&",
                    "    node.lastChild &&",
                    "    !node.lastChild.isSelfClosing &&",
                    "    !node.lastChild.endSourceSpan",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // incomplete html in ie conditional comment",
                    "  // e.g. <!--[if lt IE 9]></div><![endif]-->",
                    "  if (node.type === \"ieConditionalComment\" && !node.complete) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // TODO: handle non-text children in <pre>",
                    "  if (",
                    "    isPreLikeNode(node) &&",
                    "    node.children.some(",
                    "      (child) => child.type !== \"text\" && child.type !== \"interpolation\"",
                    "    )",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    isVueCustomBlock(node, options) &&",
                    "    (options.embeddedLanguageFormatting === \"off\" ||",
                    "      !inferScriptParser(node, options))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function hasPrettierIgnore(node) {",
                    "  if (node.type === \"attribute\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (!node.parent) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (typeof node.index !== \"number\" || node.index === 0) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const prevNode = node.parent.children[node.index - 1];",
                    "  return isPrettierIgnore(prevNode);",
                    "}",
                    "",
                    "function isPrettierIgnore(node) {",
                    "  return node.type === \"comment\" && node.value.trim() === \"prettier-ignore\";",
                    "}",
                    "",
                    "function getPrettierIgnoreAttributeCommentData(value) {",
                    "  const match = value.trim().match(/^prettier-ignore-attribute(?:\\s+([^]+))?$/);",
                    "",
                    "  if (!match) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (!match[1]) {",
                    "    return true;",
                    "  }",
                    "",
                    "  return match[1].split(/\\s+/);",
                    "}",
                    "",
                    "/** there's no opening/closing tag or it's considered not breakable */",
                    "function isTextLikeNode(node) {",
                    "  return node.type === \"text\" || node.type === \"comment\";",
                    "}",
                    "",
                    "function isScriptLikeTag(node) {",
                    "  return (",
                    "    node.type === \"element\" &&",
                    "    (node.fullName === \"script\" ||",
                    "      node.fullName === \"style\" ||",
                    "      node.fullName === \"svg:style\" ||",
                    "      (isUnknownNamespace(node) &&",
                    "        (node.name === \"script\" || node.name === \"style\")))",
                    "  );",
                    "}",
                    "",
                    "function canHaveInterpolation(node) {",
                    "  return node.children && !isScriptLikeTag(node);",
                    "}",
                    "",
                    "function isWhitespaceSensitiveNode(node) {",
                    "  return (",
                    "    isScriptLikeTag(node) ||",
                    "    node.type === \"interpolation\" ||",
                    "    isIndentationSensitiveNode(node)",
                    "  );",
                    "}",
                    "",
                    "function isIndentationSensitiveNode(node) {",
                    "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                    "}",
                    "",
                    "function isLeadingSpaceSensitiveNode(node, options) {",
                    "  const isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();",
                    "",
                    "  if (",
                    "    isLeadingSpaceSensitive &&",
                    "    !node.prev &&",
                    "    node.parent &&",
                    "    node.parent.tagDefinition &&",
                    "    node.parent.tagDefinition.ignoreFirstLf",
                    "  ) {",
                    "    return node.type === \"interpolation\";",
                    "  }",
                    "",
                    "  return isLeadingSpaceSensitive;",
                    "",
                    "  function _isLeadingSpaceSensitiveNode() {",
                    "    if (isFrontMatterNode(node)) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (",
                    "      (node.type === \"text\" || node.type === \"interpolation\") &&",
                    "      node.prev &&",
                    "      (node.prev.type === \"text\" || node.prev.type === \"interpolation\")",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    if (!node.parent || node.parent.cssDisplay === \"none\") {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (isPreLikeNode(node.parent)) {",
                    "      return true;",
                    "    }",
                    "",
                    "    if (",
                    "      !node.prev &&",
                    "      (node.parent.type === \"root\" ||",
                    "        (isPreLikeNode(node) && node.parent) ||",
                    "        isScriptLikeTag(node.parent) ||",
                    "        isVueCustomBlock(node.parent, options) ||",
                    "        !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (",
                    "      node.prev &&",
                    "      !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function isTrailingSpaceSensitiveNode(node, options) {",
                    "  if (isFrontMatterNode(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    (node.type === \"text\" || node.type === \"interpolation\") &&",
                    "    node.next &&",
                    "    (node.next.type === \"text\" || node.next.type === \"interpolation\")",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (!node.parent || node.parent.cssDisplay === \"none\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (isPreLikeNode(node.parent)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    !node.next &&",
                    "    (node.parent.type === \"root\" ||",
                    "      (isPreLikeNode(node) && node.parent) ||",
                    "      isScriptLikeTag(node.parent) ||",
                    "      isVueCustomBlock(node.parent, options) ||",
                    "      !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.next &&",
                    "    !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function isDanglingSpaceSensitiveNode(node) {",
                    "  return (",
                    "    isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) &&",
                    "    !isScriptLikeTag(node)",
                    "  );",
                    "}",
                    "",
                    "function forceNextEmptyLine(node) {",
                    "  return (",
                    "    isFrontMatterNode(node) ||",
                    "    (node.next &&",
                    "      node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line)",
                    "  );",
                    "}",
                    "",
                    "/** firstChild leadingSpaces and lastChild trailingSpaces */",
                    "function forceBreakContent(node) {",
                    "  return (",
                    "    forceBreakChildren(node) ||",
                    "    (node.type === \"element\" &&",
                    "      node.children.length !== 0 &&",
                    "      ([\"body\", \"script\", \"style\"].includes(node.name) ||",
                    "        node.children.some((child) => hasNonTextChild(child)))) ||",
                    "    (node.firstChild &&",
                    "      node.firstChild === node.lastChild &&",
                    "      hasLeadingLineBreak(node.firstChild) &&",
                    "      (!node.lastChild.isTrailingSpaceSensitive ||",
                    "        hasTrailingLineBreak(node.lastChild)))",
                    "  );",
                    "}",
                    "",
                    "/** spaces between children */",
                    "function forceBreakChildren(node) {",
                    "  return (",
                    "    node.type === \"element\" &&",
                    "    node.children.length !== 0 &&",
                    "    ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].includes(node.name) ||",
                    "      (node.cssDisplay.startsWith(\"table\") && node.cssDisplay !== \"table-cell\"))",
                    "  );",
                    "}",
                    "",
                    "function preferHardlineAsLeadingSpaces(node) {",
                    "  return (",
                    "    preferHardlineAsSurroundingSpaces(node) ||",
                    "    (node.prev && preferHardlineAsTrailingSpaces(node.prev)) ||",
                    "    hasSurroundingLineBreak(node)",
                    "  );",
                    "}",
                    "",
                    "function preferHardlineAsTrailingSpaces(node) {",
                    "  return (",
                    "    preferHardlineAsSurroundingSpaces(node) ||",
                    "    (node.type === \"element\" && node.fullName === \"br\") ||",
                    "    hasSurroundingLineBreak(node)",
                    "  );",
                    "}",
                    "",
                    "function hasSurroundingLineBreak(node) {",
                    "  return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);",
                    "}",
                    "",
                    "function hasLeadingLineBreak(node) {",
                    "  return (",
                    "    node.hasLeadingSpaces &&",
                    "    (node.prev",
                    "      ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line",
                    "      : node.parent.type === \"root\" ||",
                    "        node.parent.startSourceSpan.end.line < node.sourceSpan.start.line)",
                    "  );",
                    "}",
                    "",
                    "function hasTrailingLineBreak(node) {",
                    "  return (",
                    "    node.hasTrailingSpaces &&",
                    "    (node.next",
                    "      ? node.next.sourceSpan.start.line > node.sourceSpan.end.line",
                    "      : node.parent.type === \"root\" ||",
                    "        (node.parent.endSourceSpan &&",
                    "          node.parent.endSourceSpan.start.line > node.sourceSpan.end.line))",
                    "  );",
                    "}",
                    "",
                    "function preferHardlineAsSurroundingSpaces(node) {",
                    "  switch (node.type) {",
                    "    case \"ieConditionalComment\":",
                    "    case \"comment\":",
                    "    case \"directive\":",
                    "      return true;",
                    "    case \"element\":",
                    "      return [\"script\", \"select\"].includes(node.name);",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function getLastDescendant(node) {",
                    "  return node.lastChild ? getLastDescendant(node.lastChild) : node;",
                    "}",
                    "",
                    "function hasNonTextChild(node) {",
                    "  return node.children && node.children.some((child) => child.type !== \"text\");",
                    "}",
                    "",
                    "function _inferScriptParser(node) {",
                    "  const { type, lang } = node.attrMap;",
                    "  if (",
                    "    type === \"module\" ||",
                    "    type === \"text/javascript\" ||",
                    "    type === \"text/babel\" ||",
                    "    type === \"application/javascript\" ||",
                    "    lang === \"jsx\"",
                    "  ) {",
                    "    return \"babel\";",
                    "  }",
                    "",
                    "  if (type === \"application/x-typescript\" || lang === \"ts\" || lang === \"tsx\") {",
                    "    return \"typescript\";",
                    "  }",
                    "",
                    "  if (type === \"text/markdown\") {",
                    "    return \"markdown\";",
                    "  }",
                    "",
                    "  if (type === \"text/html\") {",
                    "    return \"html\";",
                    "  }",
                    "",
                    "  if (type && (type.endsWith(\"json\") || type.endsWith(\"importmap\"))) {",
                    "    return \"json\";",
                    "  }",
                    "",
                    "  if (type === \"text/x-handlebars-template\") {",
                    "    return \"glimmer\";",
                    "  }",
                    "}",
                    "",
                    "function inferStyleParser(node) {",
                    "  const { lang } = node.attrMap;",
                    "  if (lang === \"postcss\" || lang === \"css\") {",
                    "    return \"css\";",
                    "  }",
                    "",
                    "  if (lang === \"scss\") {",
                    "    return \"scss\";",
                    "  }",
                    "",
                    "  if (lang === \"less\") {",
                    "    return \"less\";",
                    "  }",
                    "}",
                    "",
                    "function inferScriptParser(node, options) {",
                    "  if (node.name === \"script\" && !node.attrMap.src) {",
                    "    if (!node.attrMap.lang && !node.attrMap.type) {",
                    "      return \"babel\";",
                    "    }",
                    "    return _inferScriptParser(node);",
                    "  }",
                    "",
                    "  if (node.name === \"style\") {",
                    "    return inferStyleParser(node) || \"css\";",
                    "  }",
                    "",
                    "  if (options && isVueCustomBlock(node, options)) {",
                    "    return (",
                    "      _inferScriptParser(node) ||",
                    "      inferStyleParser(node) ||",
                    "      getParserName(node.attrMap.lang, options)",
                    "    );",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function isBlockLikeCssDisplay(cssDisplay) {",
                    "  return (",
                    "    cssDisplay === \"block\" ||",
                    "    cssDisplay === \"list-item\" ||",
                    "    cssDisplay.startsWith(\"table\")",
                    "  );",
                    "}",
                    "",
                    "function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                    "}",
                    "",
                    "function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                    "}",
                    "",
                    "function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay);",
                    "}",
                    "",
                    "function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay);",
                    "}",
                    "",
                    "function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                    "}",
                    "",
                    "function isPreLikeNode(node) {",
                    "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                    "}",
                    "",
                    "function countParents(path, predicate = () => true) {",
                    "  let counter = 0;",
                    "  for (let i = path.stack.length - 1; i >= 0; i--) {",
                    "    const value = path.stack[i];",
                    "    if (",
                    "      value &&",
                    "      typeof value === \"object\" &&",
                    "      !Array.isArray(value) &&",
                    "      predicate(value)",
                    "    ) {",
                    "      counter++;",
                    "    }",
                    "  }",
                    "  return counter;",
                    "}",
                    "",
                    "function hasParent(node, fn) {",
                    "  let current = node;",
                    "",
                    "  while (current) {",
                    "    if (fn(current)) {",
                    "      return true;",
                    "    }",
                    "",
                    "    current = current.parent;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function getNodeCssStyleDisplay(node, options) {",
                    "  if (node.prev && node.prev.type === \"comment\") {",
                    "    // <!-- display: block -->",
                    "    const match = node.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);",
                    "    if (match) {",
                    "      return match[1];",
                    "    }",
                    "  }",
                    "",
                    "  let isInSvgForeignObject = false;",
                    "  if (node.type === \"element\" && node.namespace === \"svg\") {",
                    "    if (hasParent(node, (parent) => parent.fullName === \"svg:foreignObject\")) {",
                    "      isInSvgForeignObject = true;",
                    "    } else {",
                    "      return node.name === \"svg\" ? \"inline-block\" : \"block\";",
                    "    }",
                    "  }",
                    "",
                    "  switch (options.htmlWhitespaceSensitivity) {",
                    "    case \"strict\":",
                    "      return \"inline\";",
                    "    case \"ignore\":",
                    "      return \"block\";",
                    "    default: {",
                    "      // See https://github.com/prettier/prettier/issues/8151",
                    "      if (",
                    "        options.parser === \"vue\" &&",
                    "        node.parent &&",
                    "        node.parent.type === \"root\"",
                    "      ) {",
                    "        return \"block\";",
                    "      }",
                    "      return (",
                    "        (node.type === \"element\" &&",
                    "          (!node.namespace ||",
                    "            isInSvgForeignObject ||",
                    "            isUnknownNamespace(node)) &&",
                    "          CSS_DISPLAY_TAGS[node.name]) ||",
                    "        CSS_DISPLAY_DEFAULT",
                    "      );",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function isUnknownNamespace(node) {",
                    "  return (",
                    "    node.type === \"element\" &&",
                    "    !node.hasExplicitNamespace &&",
                    "    ![\"html\", \"svg\"].includes(node.namespace)",
                    "  );",
                    "}",
                    "",
                    "function getNodeCssStyleWhiteSpace(node) {",
                    "  return (",
                    "    (node.type === \"element\" &&",
                    "      (!node.namespace || isUnknownNamespace(node)) &&",
                    "      CSS_WHITE_SPACE_TAGS[node.name]) ||",
                    "    CSS_WHITE_SPACE_DEFAULT",
                    "  );",
                    "}",
                    "",
                    "function getMinIndentation(text) {",
                    "  let minIndentation = Infinity;",
                    "",
                    "  for (const lineText of text.split(\"\\n\")) {",
                    "    if (lineText.length === 0) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (!HTML_WHITESPACE.has(lineText[0])) {",
                    "      return 0;",
                    "    }",
                    "",
                    "    const indentation = getLeadingHtmlWhitespace(lineText).length;",
                    "",
                    "    if (lineText.length === indentation) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (indentation < minIndentation) {",
                    "      minIndentation = indentation;",
                    "    }",
                    "  }",
                    "",
                    "  return minIndentation === Infinity ? 0 : minIndentation;",
                    "}",
                    "",
                    "function dedentString(text, minIndent = getMinIndentation(text)) {",
                    "  return minIndent === 0",
                    "    ? text",
                    "    : text",
                    "        .split(\"\\n\")",
                    "        .map((lineText) => lineText.slice(minIndent))",
                    "        .join(\"\\n\");",
                    "}",
                    "",
                    "function identity(x) {",
                    "  return x;",
                    "}",
                    "",
                    "function shouldNotPrintClosingTag(node, options) {",
                    "  return (",
                    "    !node.isSelfClosing &&",
                    "    !node.endSourceSpan &&",
                    "    (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options))",
                    "  );",
                    "}",
                    "",
                    "function countChars(text, char) {",
                    "  let counter = 0;",
                    "  for (let i = 0; i < text.length; i++) {",
                    "    if (text[i] === char) {",
                    "      counter++;",
                    "    }",
                    "  }",
                    "  return counter;",
                    "}",
                    "",
                    "function unescapeQuoteEntities(text) {",
                    "  return text.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');",
                    "}",
                    "",
                    "// top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block",
                    "// See https://vue-loader.vuejs.org/spec.html for detail",
                    "const vueRootElementsSet = new Set([\"template\", \"style\", \"script\"]);",
                    "function isVueCustomBlock(node, options) {",
                    "  return (",
                    "    options.parser === \"vue\" &&",
                    "    node.type === \"element\" &&",
                    "    node.parent.type === \"root\" &&",
                    "    !vueRootElementsSet.has(node.fullName) &&",
                    "    node.fullName.toLowerCase() !== \"html\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  HTML_ELEMENT_ATTRIBUTES,",
                    "  HTML_TAGS,",
                    "  htmlTrim,",
                    "  htmlTrimPreserveIndentation,",
                    "  splitByHtmlWhitespace,",
                    "  hasHtmlWhitespace,",
                    "  getLeadingAndTrailingHtmlWhitespace,",
                    "  canHaveInterpolation,",
                    "  countChars,",
                    "  countParents,",
                    "  dedentString,",
                    "  forceBreakChildren,",
                    "  forceBreakContent,",
                    "  forceNextEmptyLine,",
                    "  getLastDescendant,",
                    "  getNodeCssStyleDisplay,",
                    "  getNodeCssStyleWhiteSpace,",
                    "  getPrettierIgnoreAttributeCommentData,",
                    "  hasPrettierIgnore,",
                    "  identity,",
                    "  inferScriptParser,",
                    "  isVueCustomBlock,",
                    "  isDanglingSpaceSensitiveNode,",
                    "  isIndentationSensitiveNode,",
                    "  isLeadingSpaceSensitiveNode,",
                    "  isPreLikeNode,",
                    "  isScriptLikeTag,",
                    "  isTextLikeNode,",
                    "  isTrailingSpaceSensitiveNode,",
                    "  isWhitespaceSensitiveNode,",
                    "  isUnknownNamespace,",
                    "  preferHardlineAsLeadingSpaces,",
                    "  preferHardlineAsTrailingSpaces,",
                    "  shouldNotPrintClosingTag,",
                    "  shouldPreserveContent,",
                    "  unescapeQuoteEntities,",
                    "};"
                ]
            }
        },
        "language-js": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  [",
                    "    \"range\",",
                    "    \"raw\",",
                    "    \"comments\",",
                    "    \"leadingComments\",",
                    "    \"trailingComments\",",
                    "    \"innerComments\",",
                    "    \"extra\",",
                    "    \"start\",",
                    "    \"end\",",
                    "    \"flags\",",
                    "    \"errors\",",
                    "  ].forEach((name) => {",
                    "    delete newObj[name];",
                    "  });",
                    "",
                    "  if (ast.loc && ast.loc.source === null) {",
                    "    delete newObj.loc.source;",
                    "  }",
                    "",
                    "  if (ast.type === \"Program\") {",
                    "    delete newObj.sourceType;",
                    "  }",
                    "",
                    "  if (ast.type === \"BigIntLiteral\") {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "",
                    "  // We remove extra `;` and add them when needed",
                    "  if (ast.type === \"EmptyStatement\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We move text around, including whitespaces and add {\" \"}",
                    "  if (ast.type === \"JSXText\") {",
                    "    return null;",
                    "  }",
                    "  if (",
                    "    ast.type === \"JSXExpressionContainer\" &&",
                    "    ast.expression.type === \"Literal\" &&",
                    "    ast.expression.value === \" \"",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "",
                    "  // (TypeScript) Ignore `static` in `constructor(static p) {}`",
                    "  // and `export` in `constructor(export p) {}`",
                    "  if (",
                    "    ast.type === \"TSParameterProperty\" &&",
                    "    ast.accessibility === null &&",
                    "    !ast.readonly",
                    "  ) {",
                    "    return {",
                    "      type: \"Identifier\",",
                    "      name: ast.parameter.name,",
                    "      typeAnnotation: newObj.parameter.typeAnnotation,",
                    "      decorators: newObj.decorators,",
                    "    };",
                    "  }",
                    "",
                    "  // (TypeScript) ignore empty `specifiers` array",
                    "  if (",
                    "    ast.type === \"TSNamespaceExportDeclaration\" &&",
                    "    ast.specifiers &&",
                    "    ast.specifiers.length === 0",
                    "  ) {",
                    "    delete newObj.specifiers;",
                    "  }",
                    "",
                    "  // We convert <div></div> to <div />",
                    "  if (ast.type === \"JSXOpeningElement\") {",
                    "    delete newObj.selfClosing;",
                    "  }",
                    "  if (ast.type === \"JSXElement\") {",
                    "    delete newObj.closingElement;",
                    "  }",
                    "",
                    "  // We change {'key': value} into {key: value}",
                    "  if (",
                    "    (ast.type === \"Property\" ||",
                    "      ast.type === \"ObjectProperty\" ||",
                    "      ast.type === \"MethodDefinition\" ||",
                    "      ast.type === \"ClassProperty\" ||",
                    "      ast.type === \"TSPropertySignature\" ||",
                    "      ast.type === \"ObjectTypeProperty\") &&",
                    "    typeof ast.key === \"object\" &&",
                    "    ast.key &&",
                    "    (ast.key.type === \"Literal\" ||",
                    "      ast.key.type === \"StringLiteral\" ||",
                    "      ast.key.type === \"Identifier\")",
                    "  ) {",
                    "    delete newObj.key;",
                    "  }",
                    "",
                    "  if (ast.type === \"OptionalMemberExpression\" && ast.optional === false) {",
                    "    newObj.type = \"MemberExpression\";",
                    "    delete newObj.optional;",
                    "  }",
                    "",
                    "  // Remove raw and cooked values from TemplateElement when it's CSS",
                    "  // styled-jsx",
                    "  if (",
                    "    ast.type === \"JSXElement\" &&",
                    "    ast.openingElement.name.name === \"style\" &&",
                    "    ast.openingElement.attributes.some((attr) => attr.name.name === \"jsx\")",
                    "  ) {",
                    "    const templateLiterals = newObj.children",
                    "      .filter(",
                    "        (child) =>",
                    "          child.type === \"JSXExpressionContainer\" &&",
                    "          child.expression.type === \"TemplateLiteral\"",
                    "      )",
                    "      .map((container) => container.expression);",
                    "",
                    "    const quasis = templateLiterals.reduce(",
                    "      (quasis, templateLiteral) => quasis.concat(templateLiteral.quasis),",
                    "      []",
                    "    );",
                    "",
                    "    quasis.forEach((q) => delete q.value);",
                    "  }",
                    "",
                    "  // CSS template literals in css prop",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.name.name === \"css\" &&",
                    "    ast.value.type === \"JSXExpressionContainer\" &&",
                    "    ast.value.expression.type === \"TemplateLiteral\"",
                    "  ) {",
                    "    newObj.value.expression.quasis.forEach((q) => delete q.value);",
                    "  }",
                    "",
                    "  // Angular Components: Inline HTML template and Inline CSS styles",
                    "  const expression = ast.expression || ast.callee;",
                    "  if (",
                    "    ast.type === \"Decorator\" &&",
                    "    expression.type === \"CallExpression\" &&",
                    "    expression.callee.name === \"Component\" &&",
                    "    expression.arguments.length === 1",
                    "  ) {",
                    "    const astProps = ast.expression.arguments[0].properties;",
                    "    newObj.expression.arguments[0].properties.forEach((prop, index) => {",
                    "      let templateLiteral = null;",
                    "",
                    "      switch (astProps[index].key.name) {",
                    "        case \"styles\":",
                    "          if (prop.value.type === \"ArrayExpression\") {",
                    "            templateLiteral = prop.value.elements[0];",
                    "          }",
                    "          break;",
                    "        case \"template\":",
                    "          if (prop.value.type === \"TemplateLiteral\") {",
                    "            templateLiteral = prop.value;",
                    "          }",
                    "          break;",
                    "      }",
                    "",
                    "      if (templateLiteral) {",
                    "        templateLiteral.quasis.forEach((q) => delete q.value);",
                    "      }",
                    "    });",
                    "  }",
                    "",
                    "  // styled-components, graphql, markdown",
                    "  if (",
                    "    ast.type === \"TaggedTemplateExpression\" &&",
                    "    (ast.tag.type === \"MemberExpression\" ||",
                    "      (ast.tag.type === \"Identifier\" &&",
                    "        (ast.tag.name === \"gql\" ||",
                    "          ast.tag.name === \"graphql\" ||",
                    "          ast.tag.name === \"css\" ||",
                    "          ast.tag.name === \"md\" ||",
                    "          ast.tag.name === \"markdown\" ||",
                    "          ast.tag.name === \"html\")) ||",
                    "      ast.tag.type === \"CallExpression\")",
                    "  ) {",
                    "    newObj.quasi.quasis.forEach((quasi) => delete quasi.value);",
                    "  }",
                    "  if (ast.type === \"TemplateLiteral\") {",
                    "    // This checks for a leading comment that is exactly `/* GraphQL */`",
                    "    // In order to be in line with other implementations of this comment tag",
                    "    // we will not trim the comment value and we will expect exactly one space on",
                    "    // either side of the GraphQL string",
                    "    // Also see ./embed.js",
                    "    const hasLanguageComment =",
                    "      ast.leadingComments &&",
                    "      ast.leadingComments.some(",
                    "        (comment) =>",
                    "          comment.type === \"CommentBlock\" &&",
                    "          [\"GraphQL\", \"HTML\"].some(",
                    "            (languageName) => comment.value === ` ${languageName} `",
                    "          )",
                    "      );",
                    "    if (",
                    "      hasLanguageComment ||",
                    "      (parent.type === \"CallExpression\" && parent.callee.name === \"graphql\")",
                    "    ) {",
                    "      newObj.quasis.forEach((quasi) => delete quasi.value);",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"InterpreterDirective\") {",
                    "    newObj.value = newObj.value.trimEnd();",
                    "  }",
                    "}",
                    "",
                    "module.exports = clean;"
                ]
            },
            "comments.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const privateUtil = require(\"../common/util\");",
                    "const {",
                    "  addLeadingComment,",
                    "  addTrailingComment,",
                    "  addDanglingComment,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "} = require(\"../common/util-shared\");",
                    "",
                    "function handleOwnLineComment(comment, text, options, ast, isLastComment) {",
                    "  const { precedingNode, enclosingNode, followingNode } = comment;",
                    "  return (",
                    "    handleLastFunctionArgComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleMemberExpressionComments(enclosingNode, followingNode, comment) ||",
                    "    handleIfStatementComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleWhileComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleTryStatementComments(",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      followingNode,",
                    "      comment",
                    "    ) ||",
                    "    handleClassComments(enclosingNode, precedingNode, followingNode, comment) ||",
                    "    handleImportSpecifierComments(enclosingNode, comment) ||",
                    "    handleForComments(enclosingNode, precedingNode, comment) ||",
                    "    handleUnionTypeComments(",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment",
                    "    ) ||",
                    "    handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||",
                    "    handleImportDeclarationComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleAssignmentPatternComments(enclosingNode, comment) ||",
                    "    handleMethodNameComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleLabeledStatementComments(enclosingNode, comment)",
                    "  );",
                    "}",
                    "",
                    "function handleEndOfLineComment(comment, text, options, ast, isLastComment) {",
                    "  const { precedingNode, enclosingNode, followingNode } = comment;",
                    "  return (",
                    "    handleClosureTypeCastComments(followingNode, comment) ||",
                    "    handleLastFunctionArgComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleConditionalExpressionComments(",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      text,",
                    "      options",
                    "    ) ||",
                    "    handleImportSpecifierComments(enclosingNode, comment) ||",
                    "    handleIfStatementComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleWhileComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleTryStatementComments(",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      followingNode,",
                    "      comment",
                    "    ) ||",
                    "    handleClassComments(enclosingNode, precedingNode, followingNode, comment) ||",
                    "    handleLabeledStatementComments(enclosingNode, comment) ||",
                    "    handleCallExpressionComments(precedingNode, enclosingNode, comment) ||",
                    "    handlePropertyComments(enclosingNode, comment) ||",
                    "    handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||",
                    "    handleTypeAliasComments(enclosingNode, followingNode, comment) ||",
                    "    handleVariableDeclaratorComments(enclosingNode, followingNode, comment)",
                    "  );",
                    "}",
                    "",
                    "function handleRemainingComment(comment, text, options, ast, isLastComment) {",
                    "  const { precedingNode, enclosingNode, followingNode } = comment;",
                    "",
                    "  if (",
                    "    handleIfStatementComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleWhileComments(",
                    "      text,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) ||",
                    "    handleCommentInEmptyParens(text, enclosingNode, comment, options) ||",
                    "    handleMethodNameComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||",
                    "    handleCommentAfterArrowParams(text, enclosingNode, comment, options) ||",
                    "    handleFunctionNameComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      comment,",
                    "      options",
                    "    ) ||",
                    "    handleTSMappedTypeComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      precedingNode,",
                    "      followingNode,",
                    "      comment",
                    "    ) ||",
                    "    handleBreakAndContinueStatementComments(enclosingNode, comment) ||",
                    "    handleTSFunctionTrailingComments(",
                    "      text,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      comment,",
                    "      options",
                    "    )",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function addBlockStatementFirstComment(node, comment) {",
                    "  const body = (node.body || node.properties).filter(",
                    "    (n) => n.type !== \"EmptyStatement\"",
                    "  );",
                    "  if (body.length === 0) {",
                    "    addDanglingComment(node, comment);",
                    "  } else {",
                    "    addLeadingComment(body[0], comment);",
                    "  }",
                    "}",
                    "",
                    "function addBlockOrNotComment(node, comment) {",
                    "  if (node.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(node, comment);",
                    "  } else {",
                    "    addLeadingComment(node, comment);",
                    "  }",
                    "}",
                    "",
                    "function handleClosureTypeCastComments(followingNode, comment) {",
                    "  if (followingNode && isTypeCastComment(comment)) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "// There are often comments before the else clause of if statements like",
                    "//",
                    "//   if (1) { ... }",
                    "//   // comment",
                    "//   else { ... }",
                    "//",
                    "// They are being attached as leading comments of the BlockExpression which",
                    "// is not well printed. What we want is to instead move the comment inside",
                    "// of the block and make it leadingComment of the first element of the block",
                    "// or dangling comment of the block if there is nothing inside",
                    "//",
                    "//   if (1) { ... }",
                    "//   else {",
                    "//     // comment",
                    "//     ...",
                    "//   }",
                    "function handleIfStatementComments(",
                    "  text,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    enclosingNode.type !== \"IfStatement\" ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // We unfortunately have no way using the AST or location of nodes to know",
                    "  // if the comment is positioned before the condition parenthesis:",
                    "  //   if (a /* comment */) {}",
                    "  // The only workaround I found is to look at the next character to see if",
                    "  // it is a ).",
                    "  const nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "    text,",
                    "    comment,",
                    "    options.locEnd",
                    "  );",
                    "  if (nextCharacter === \")\") {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Comments before `else`:",
                    "  // - treat as trailing comments of the consequent, if it's a BlockStatement",
                    "  // - treat as a dangling comment otherwise",
                    "  if (",
                    "    precedingNode === enclosingNode.consequent &&",
                    "    followingNode === enclosingNode.alternate",
                    "  ) {",
                    "    if (precedingNode.type === \"BlockStatement\") {",
                    "      addTrailingComment(precedingNode, comment);",
                    "    } else {",
                    "      addDanglingComment(enclosingNode, comment);",
                    "    }",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"IfStatement\") {",
                    "    addBlockOrNotComment(followingNode.consequent, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // For comments positioned after the condition parenthesis in an if statement",
                    "  // before the consequent without brackets on, such as",
                    "  // if (a) /* comment */ true,",
                    "  // we look at the next character to see if the following node",
                    "  // is the consequent for the if statement",
                    "  if (enclosingNode.consequent === followingNode) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleWhileComments(",
                    "  text,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    enclosingNode.type !== \"WhileStatement\" ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // We unfortunately have no way using the AST or location of nodes to know",
                    "  // if the comment is positioned before the condition parenthesis:",
                    "  //   while (a /* comment */) {}",
                    "  // The only workaround I found is to look at the next character to see if",
                    "  // it is a ).",
                    "  const nextCharacter = privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "    text,",
                    "    comment,",
                    "    options.locEnd",
                    "  );",
                    "  if (nextCharacter === \")\") {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "// Same as IfStatement but for TryStatement",
                    "function handleTryStatementComments(",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  followingNode,",
                    "  comment",
                    ") {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    (enclosingNode.type !== \"TryStatement\" &&",
                    "      enclosingNode.type !== \"CatchClause\") ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (enclosingNode.type === \"CatchClause\" && precedingNode) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"TryStatement\") {",
                    "    addBlockOrNotComment(followingNode.finalizer, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"CatchClause\") {",
                    "    addBlockOrNotComment(followingNode.body, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleMemberExpressionComments(enclosingNode, followingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"MemberExpression\" ||",
                    "      enclosingNode.type === \"OptionalMemberExpression\") &&",
                    "    followingNode &&",
                    "    followingNode.type === \"Identifier\"",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleConditionalExpressionComments(",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  followingNode,",
                    "  comment,",
                    "  text,",
                    "  options",
                    ") {",
                    "  const isSameLineAsPrecedingNode =",
                    "    precedingNode &&",
                    "    !privateUtil.hasNewlineInRange(",
                    "      text,",
                    "      options.locEnd(precedingNode),",
                    "      options.locStart(comment)",
                    "    );",
                    "",
                    "  if (",
                    "    (!precedingNode || !isSameLineAsPrecedingNode) &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"ConditionalExpression\" &&",
                    "    followingNode",
                    "  ) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ObjectProperty\" ||",
                    "      enclosingNode.type === \"Property\") &&",
                    "    enclosingNode.shorthand &&",
                    "    enclosingNode.key === precedingNode &&",
                    "    enclosingNode.value.type === \"AssignmentPattern\"",
                    "  ) {",
                    "    addTrailingComment(enclosingNode.value.left, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleClassComments(",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  followingNode,",
                    "  comment",
                    ") {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ClassDeclaration\" ||",
                    "      enclosingNode.type === \"ClassExpression\" ||",
                    "      enclosingNode.type === \"DeclareClass\" ||",
                    "      enclosingNode.type === \"DeclareInterface\" ||",
                    "      enclosingNode.type === \"InterfaceDeclaration\" ||",
                    "      enclosingNode.type === \"TSInterfaceDeclaration\")",
                    "  ) {",
                    "    if (",
                    "      enclosingNode.decorators &&",
                    "      enclosingNode.decorators.length > 0 &&",
                    "      !(followingNode && followingNode.type === \"Decorator\")",
                    "    ) {",
                    "      addTrailingComment(",
                    "        enclosingNode.decorators[enclosingNode.decorators.length - 1],",
                    "        comment",
                    "      );",
                    "      return true;",
                    "    }",
                    "",
                    "    if (enclosingNode.body && followingNode === enclosingNode.body) {",
                    "      addBlockStatementFirstComment(enclosingNode.body, comment);",
                    "      return true;",
                    "    }",
                    "",
                    "    // Don't add leading comments to `implements`, `extends`, `mixins` to",
                    "    // avoid printing the comment after the keyword.",
                    "    if (followingNode) {",
                    "      for (const prop of [\"implements\", \"extends\", \"mixins\"]) {",
                    "        if (enclosingNode[prop] && followingNode === enclosingNode[prop][0]) {",
                    "          if (",
                    "            precedingNode &&",
                    "            (precedingNode === enclosingNode.id ||",
                    "              precedingNode === enclosingNode.typeParameters ||",
                    "              precedingNode === enclosingNode.superClass)",
                    "          ) {",
                    "            addTrailingComment(precedingNode, comment);",
                    "          } else {",
                    "            addDanglingComment(enclosingNode, comment, prop);",
                    "          }",
                    "          return true;",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleMethodNameComments(",
                    "  text,",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  // This is only needed for estree parsers (flow, typescript) to attach",
                    "  // after a method name:",
                    "  // obj = { fn /*comment*/() {} };",
                    "  if (",
                    "    enclosingNode &&",
                    "    precedingNode &&",
                    "    // \"MethodDefinition\" is handled in getCommentChildNodes",
                    "    (enclosingNode.type === \"Property\" ||",
                    "      enclosingNode.type === \"TSDeclareMethod\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\") &&",
                    "    precedingNode.type === \"Identifier\" &&",
                    "    enclosingNode.key === precedingNode &&",
                    "    // special Property case: { key: /*comment*/(value) };",
                    "    // comment should be attached to value instead of key",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      precedingNode,",
                    "      options.locEnd",
                    "    ) !== \":\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Print comments between decorators and class methods as a trailing comment",
                    "  // on the decorator node instead of the method node",
                    "  if (",
                    "    precedingNode &&",
                    "    enclosingNode &&",
                    "    precedingNode.type === \"Decorator\" &&",
                    "    (enclosingNode.type === \"ClassMethod\" ||",
                    "      enclosingNode.type === \"ClassProperty\" ||",
                    "      enclosingNode.type === \"TSAbstractClassProperty\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\" ||",
                    "      enclosingNode.type === \"TSDeclareMethod\" ||",
                    "      enclosingNode.type === \"MethodDefinition\")",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleFunctionNameComments(",
                    "  text,",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  if (",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      comment,",
                    "      options.locEnd",
                    "    ) !== \"(\"",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    precedingNode &&",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"FunctionDeclaration\" ||",
                    "      enclosingNode.type === \"FunctionExpression\" ||",
                    "      enclosingNode.type === \"ClassMethod\" ||",
                    "      enclosingNode.type === \"MethodDefinition\" ||",
                    "      enclosingNode.type === \"ObjectMethod\")",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleCommentAfterArrowParams(text, enclosingNode, comment, options) {",
                    "  if (!(enclosingNode && enclosingNode.type === \"ArrowFunctionExpression\")) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const index = getNextNonSpaceNonCommentCharacterIndex(",
                    "    text,",
                    "    comment,",
                    "    options.locEnd",
                    "  );",
                    "  if (text.slice(index, index + 2) === \"=>\") {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleCommentInEmptyParens(text, enclosingNode, comment, options) {",
                    "  if (",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      comment,",
                    "      options.locEnd",
                    "    ) !== \")\"",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Only add dangling comments to fix the case when no params are present,",
                    "  // i.e. a function without any argument.",
                    "  if (",
                    "    enclosingNode &&",
                    "    ((isRealFunctionLikeNode(enclosingNode) &&",
                    "      // `params` vs `parameters` - see https://github.com/babel/babel/issues/9231",
                    "      (enclosingNode.params || enclosingNode.parameters).length === 0) ||",
                    "      ((enclosingNode.type === \"CallExpression\" ||",
                    "        enclosingNode.type === \"OptionalCallExpression\" ||",
                    "        enclosingNode.type === \"NewExpression\") &&",
                    "        enclosingNode.arguments.length === 0))",
                    "  ) {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"MethodDefinition\" &&",
                    "    enclosingNode.value.params.length === 0",
                    "  ) {",
                    "    addDanglingComment(enclosingNode.value, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleLastFunctionArgComments(",
                    "  text,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  // Flow function type definitions",
                    "  if (",
                    "    precedingNode &&",
                    "    precedingNode.type === \"FunctionTypeParam\" &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"FunctionTypeAnnotation\" &&",
                    "    followingNode &&",
                    "    followingNode.type !== \"FunctionTypeParam\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Real functions and TypeScript function type definitions",
                    "  if (",
                    "    precedingNode &&",
                    "    (precedingNode.type === \"Identifier\" ||",
                    "      precedingNode.type === \"AssignmentPattern\") &&",
                    "    enclosingNode &&",
                    "    isRealFunctionLikeNode(enclosingNode) &&",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      comment,",
                    "      options.locEnd",
                    "    ) === \")\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"FunctionDeclaration\" &&",
                    "    followingNode &&",
                    "    followingNode.type === \"BlockStatement\"",
                    "  ) {",
                    "    const functionParamRightParenIndex = (() => {",
                    "      if ((enclosingNode.params || enclosingNode.parameters).length !== 0) {",
                    "        return privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "          text,",
                    "          options.locEnd(",
                    "            privateUtil.getLast(",
                    "              enclosingNode.params || enclosingNode.parameters",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "      const functionParamLeftParenIndex = privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "        text,",
                    "        options.locEnd(enclosingNode.id)",
                    "      );",
                    "      return privateUtil.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "        text,",
                    "        functionParamLeftParenIndex + 1",
                    "      );",
                    "    })();",
                    "    if (options.locStart(comment) > functionParamRightParenIndex) {",
                    "      addBlockStatementFirstComment(followingNode, comment);",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleImportSpecifierComments(enclosingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"ImportSpecifier\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleLabeledStatementComments(enclosingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"LabeledStatement\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleBreakAndContinueStatementComments(enclosingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ContinueStatement\" ||",
                    "      enclosingNode.type === \"BreakStatement\") &&",
                    "    !enclosingNode.label",
                    "  ) {",
                    "    addTrailingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleCallExpressionComments(precedingNode, enclosingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"CallExpression\" ||",
                    "      enclosingNode.type === \"OptionalCallExpression\") &&",
                    "    precedingNode &&",
                    "    enclosingNode.callee === precedingNode &&",
                    "    enclosingNode.arguments.length > 0",
                    "  ) {",
                    "    addLeadingComment(enclosingNode.arguments[0], comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleUnionTypeComments(",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment",
                    ") {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"UnionTypeAnnotation\" ||",
                    "      enclosingNode.type === \"TSUnionType\")",
                    "  ) {",
                    "    if (privateUtil.isNodeIgnoreComment(comment)) {",
                    "      followingNode.prettierIgnore = true;",
                    "      comment.unignore = true;",
                    "    }",
                    "    if (precedingNode) {",
                    "      addTrailingComment(precedingNode, comment);",
                    "      return true;",
                    "    }",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    followingNode &&",
                    "    (followingNode.type === \"UnionTypeAnnotation\" ||",
                    "      followingNode.type === \"TSUnionType\") &&",
                    "    privateUtil.isNodeIgnoreComment(comment)",
                    "  ) {",
                    "    followingNode.types[0].prettierIgnore = true;",
                    "    comment.unignore = true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handlePropertyComments(enclosingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"Property\" ||",
                    "      enclosingNode.type === \"ObjectProperty\")",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleOnlyComments(enclosingNode, ast, comment, isLastComment) {",
                    "  // With Flow the enclosingNode is undefined so use the AST instead.",
                    "  if (ast && ast.body && ast.body.length === 0) {",
                    "    if (isLastComment) {",
                    "      addDanglingComment(ast, comment);",
                    "    } else {",
                    "      addLeadingComment(ast, comment);",
                    "    }",
                    "    return true;",
                    "  } else if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"Program\" &&",
                    "    enclosingNode.body.length === 0 &&",
                    "    enclosingNode.directives &&",
                    "    enclosingNode.directives.length === 0",
                    "  ) {",
                    "    if (isLastComment) {",
                    "      addDanglingComment(enclosingNode, comment);",
                    "    } else {",
                    "      addLeadingComment(enclosingNode, comment);",
                    "    }",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleForComments(enclosingNode, precedingNode, comment) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ForInStatement\" ||",
                    "      enclosingNode.type === \"ForOfStatement\")",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleImportDeclarationComments(",
                    "  text,",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  if (",
                    "    precedingNode &&",
                    "    precedingNode.type === \"ImportSpecifier\" &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"ImportDeclaration\" &&",
                    "    privateUtil.hasNewline(text, options.locEnd(comment))",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleAssignmentPatternComments(enclosingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"AssignmentPattern\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleTypeAliasComments(enclosingNode, followingNode, comment) {",
                    "  if (enclosingNode && enclosingNode.type === \"TypeAlias\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleVariableDeclaratorComments(",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment",
                    ") {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"VariableDeclarator\" ||",
                    "      enclosingNode.type === \"AssignmentExpression\") &&",
                    "    followingNode &&",
                    "    (followingNode.type === \"ObjectExpression\" ||",
                    "      followingNode.type === \"ArrayExpression\" ||",
                    "      followingNode.type === \"TemplateLiteral\" ||",
                    "      followingNode.type === \"TaggedTemplateExpression\" ||",
                    "      isBlockComment(comment))",
                    "  ) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleTSFunctionTrailingComments(",
                    "  text,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  comment,",
                    "  options",
                    ") {",
                    "  if (",
                    "    !followingNode &&",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"TSMethodSignature\" ||",
                    "      enclosingNode.type === \"TSDeclareFunction\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\") &&",
                    "    privateUtil.getNextNonSpaceNonCommentCharacter(",
                    "      text,",
                    "      comment,",
                    "      options.locEnd",
                    "    ) === \";\"",
                    "  ) {",
                    "    addTrailingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleTSMappedTypeComments(",
                    "  text,",
                    "  enclosingNode,",
                    "  precedingNode,",
                    "  followingNode,",
                    "  comment",
                    ") {",
                    "  if (!enclosingNode || enclosingNode.type !== \"TSMappedType\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    followingNode &&",
                    "    followingNode.type === \"TSTypeParameter\" &&",
                    "    followingNode.name",
                    "  ) {",
                    "    addLeadingComment(followingNode.name, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    precedingNode &&",
                    "    precedingNode.type === \"TSTypeParameter\" &&",
                    "    precedingNode.constraint",
                    "  ) {",
                    "    addTrailingComment(precedingNode.constraint, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isBlockComment(comment) {",
                    "  return comment.type === \"Block\" || comment.type === \"CommentBlock\";",
                    "}",
                    "",
                    "function hasLeadingComment(node, fn = () => true) {",
                    "  if (node.leadingComments) {",
                    "    return node.leadingComments.some(fn);",
                    "  }",
                    "  if (node.comments) {",
                    "    return node.comments.some((comment) => comment.leading && fn(comment));",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function isRealFunctionLikeNode(node) {",
                    "  return (",
                    "    node.type === \"ArrowFunctionExpression\" ||",
                    "    node.type === \"FunctionExpression\" ||",
                    "    node.type === \"FunctionDeclaration\" ||",
                    "    node.type === \"ObjectMethod\" ||",
                    "    node.type === \"ClassMethod\" ||",
                    "    node.type === \"TSDeclareFunction\" ||",
                    "    node.type === \"TSCallSignatureDeclaration\" ||",
                    "    node.type === \"TSConstructSignatureDeclaration\" ||",
                    "    node.type === \"TSConstructSignatureDeclaration\" ||",
                    "    node.type === \"TSMethodSignature\" ||",
                    "    node.type === \"TSConstructorType\" ||",
                    "    node.type === \"TSFunctionType\" ||",
                    "    node.type === \"TSDeclareMethod\"",
                    "  );",
                    "}",
                    "",
                    "function getGapRegex(enclosingNode) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type !== \"BinaryExpression\" &&",
                    "    enclosingNode.type !== \"LogicalExpression\"",
                    "  ) {",
                    "    // Support degenerate single-element unions and intersections.",
                    "    // E.g.: `type A = /* 1 */ & B`",
                    "    return /^[\\s&(|]*$/;",
                    "  }",
                    "}",
                    "",
                    "function getCommentChildNodes(node, options) {",
                    "  // Prevent attaching comments to FunctionExpression in this case:",
                    "  //     class Foo {",
                    "  //       bar() // comment",
                    "  //       {",
                    "  //         baz();",
                    "  //       }",
                    "  //     }",
                    "  if (",
                    "    (options.parser === \"typescript\" || options.parser === \"flow\") &&",
                    "    node.type === \"MethodDefinition\" &&",
                    "    node.value &&",
                    "    node.value.type === \"FunctionExpression\" &&",
                    "    node.value.params.length === 0 &&",
                    "    !node.value.returnType &&",
                    "    (!node.value.typeParameters || node.value.typeParameters.length === 0) &&",
                    "    node.value.body",
                    "  ) {",
                    "    return [...(node.decorators || []), node.key, node.value.body];",
                    "  }",
                    "}",
                    "",
                    "function isTypeCastComment(comment) {",
                    "  return (",
                    "    isBlockComment(comment) &&",
                    "    comment.value[0] === \"*\" &&",
                    "    // TypeScript expects the type to be enclosed in curly brackets, however",
                    "    // Closure Compiler accepts types in parens and even without any delimiters at all.",
                    "    // That's why we just search for \"@type\".",
                    "    /@type\\b/.test(comment.value)",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  handleOwnLineComment,",
                    "  handleEndOfLineComment,",
                    "  handleRemainingComment,",
                    "  hasLeadingComment,",
                    "  isBlockComment,",
                    "  isTypeCastComment,",
                    "  getGapRegex,",
                    "  getCommentChildNodes,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isBlockComment, hasLeadingComment } = require(\"./comments\");",
                    "",
                    "const {",
                    "  builders: {",
                    "    indent,",
                    "    join,",
                    "    line,",
                    "    hardline,",
                    "    softline,",
                    "    literalline,",
                    "    concat,",
                    "    group,",
                    "    dedentToRoot,",
                    "  },",
                    "  utils: { mapDoc, stripTrailingHardline },",
                    "} = require(\"../document\");",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "",
                    "  switch (node.type) {",
                    "    case \"TemplateLiteral\": {",
                    "      const isCss = [",
                    "        isStyledJsx,",
                    "        isStyledComponents,",
                    "        isCssProp,",
                    "        isAngularComponentStyles,",
                    "      ].some((isIt) => isIt(path));",
                    "",
                    "      if (isCss) {",
                    "        // Get full template literal with expressions replaced by placeholders",
                    "        const rawQuasis = node.quasis.map((q) => q.value.raw);",
                    "        let placeholderID = 0;",
                    "        const text = rawQuasis.reduce((prevVal, currVal, idx) => {",
                    "          return idx === 0",
                    "            ? currVal",
                    "            : prevVal +",
                    "                \"@prettier-placeholder-\" +",
                    "                placeholderID++ +",
                    "                \"-id\" +",
                    "                currVal;",
                    "        }, \"\");",
                    "        const doc = textToDoc(text, { parser: \"scss\" });",
                    "        return transformCssDoc(doc, path, print);",
                    "      }",
                    "",
                    "      /*",
                    "       * react-relay and graphql-tag",
                    "       * graphql`...`",
                    "       * graphql.experimental`...`",
                    "       * gql`...`",
                    "       *",
                    "       * This intentionally excludes Relay Classic tags, as Prettier does not",
                    "       * support Relay Classic formatting.",
                    "       */",
                    "      if (isGraphQL(path)) {",
                    "        const expressionDocs = node.expressions",
                    "          ? path.map(print, \"expressions\")",
                    "          : [];",
                    "",
                    "        const numQuasis = node.quasis.length;",
                    "",
                    "        if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {",
                    "          return \"``\";",
                    "        }",
                    "",
                    "        const parts = [];",
                    "",
                    "        for (let i = 0; i < numQuasis; i++) {",
                    "          const templateElement = node.quasis[i];",
                    "          const isFirst = i === 0;",
                    "          const isLast = i === numQuasis - 1;",
                    "          const text = templateElement.value.cooked;",
                    "",
                    "          // Bail out if any of the quasis have an invalid escape sequence",
                    "          // (which would make the `cooked` value be `null` or `undefined`)",
                    "          if (typeof text !== \"string\") {",
                    "            return null;",
                    "          }",
                    "",
                    "          const lines = text.split(\"\\n\");",
                    "          const numLines = lines.length;",
                    "          const expressionDoc = expressionDocs[i];",
                    "",
                    "          const startsWithBlankLine =",
                    "            numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";",
                    "          const endsWithBlankLine =",
                    "            numLines > 2 &&",
                    "            lines[numLines - 1].trim() === \"\" &&",
                    "            lines[numLines - 2].trim() === \"\";",
                    "",
                    "          const commentsAndWhitespaceOnly = lines.every((line) =>",
                    "            /^\\s*(?:#[^\\n\\r]*)?$/.test(line)",
                    "          );",
                    "",
                    "          // Bail out if an interpolation occurs within a comment.",
                    "          if (!isLast && /#[^\\n\\r]*$/.test(lines[numLines - 1])) {",
                    "            return null;",
                    "          }",
                    "",
                    "          let doc = null;",
                    "",
                    "          if (commentsAndWhitespaceOnly) {",
                    "            doc = printGraphqlComments(lines);",
                    "          } else {",
                    "            doc = stripTrailingHardline(textToDoc(text, { parser: \"graphql\" }));",
                    "          }",
                    "",
                    "          if (doc) {",
                    "            doc = escapeTemplateCharacters(doc, false);",
                    "            if (!isFirst && startsWithBlankLine) {",
                    "              parts.push(\"\");",
                    "            }",
                    "            parts.push(doc);",
                    "            if (!isLast && endsWithBlankLine) {",
                    "              parts.push(\"\");",
                    "            }",
                    "          } else if (!isFirst && !isLast && startsWithBlankLine) {",
                    "            parts.push(\"\");",
                    "          }",
                    "",
                    "          if (expressionDoc) {",
                    "            parts.push(concat([\"${\", expressionDoc, \"}\"]));",
                    "          }",
                    "        }",
                    "",
                    "        return concat([",
                    "          \"`\",",
                    "          indent(concat([hardline, join(hardline, parts)])),",
                    "          hardline,",
                    "          \"`\",",
                    "        ]);",
                    "      }",
                    "",
                    "      const htmlParser = isHtml(path)",
                    "        ? \"html\"",
                    "        : isAngularComponentTemplate(path)",
                    "        ? \"angular\"",
                    "        : undefined;",
                    "",
                    "      if (htmlParser) {",
                    "        return printHtmlTemplateLiteral(",
                    "          path,",
                    "          print,",
                    "          textToDoc,",
                    "          htmlParser,",
                    "          options",
                    "        );",
                    "      }",
                    "",
                    "      break;",
                    "    }",
                    "",
                    "    case \"TemplateElement\": {",
                    "      /**",
                    "       * md`...`",
                    "       * markdown`...`",
                    "       */",
                    "      if (",
                    "        parentParent &&",
                    "        parentParent.type === \"TaggedTemplateExpression\" &&",
                    "        parent.quasis.length === 1 &&",
                    "        parentParent.tag.type === \"Identifier\" &&",
                    "        (parentParent.tag.name === \"md\" || parentParent.tag.name === \"markdown\")",
                    "      ) {",
                    "        const text = parent.quasis[0].value.raw.replace(",
                    "          /((?:\\\\\\\\)*)\\\\`/g,",
                    "          (_, backslashes) => \"\\\\\".repeat(backslashes.length / 2) + \"`\"",
                    "        );",
                    "        const indentation = getIndentation(text);",
                    "        const hasIndent = indentation !== \"\";",
                    "        return concat([",
                    "          hasIndent",
                    "            ? indent(",
                    "                concat([",
                    "                  softline,",
                    "                  printMarkdown(",
                    "                    text.replace(new RegExp(`^${indentation}`, \"gm\"), \"\")",
                    "                  ),",
                    "                ])",
                    "              )",
                    "            : concat([literalline, dedentToRoot(printMarkdown(text))]),",
                    "          softline,",
                    "        ]);",
                    "      }",
                    "",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  function printMarkdown(text) {",
                    "    const doc = textToDoc(text, { parser: \"markdown\", __inJsTemplate: true });",
                    "    return stripTrailingHardline(escapeTemplateCharacters(doc, true));",
                    "  }",
                    "}",
                    "",
                    "function getIndentation(str) {",
                    "  const firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);",
                    "  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];",
                    "}",
                    "",
                    "function uncook(cookedValue) {",
                    "  return cookedValue.replace(/([\\\\`]|\\${)/g, \"\\\\$1\");",
                    "}",
                    "",
                    "function escapeTemplateCharacters(doc, raw) {",
                    "  return mapDoc(doc, (currentDoc) => {",
                    "    if (!currentDoc.parts) {",
                    "      return currentDoc;",
                    "    }",
                    "",
                    "    const parts = [];",
                    "",
                    "    currentDoc.parts.forEach((part) => {",
                    "      if (typeof part === \"string\") {",
                    "        parts.push(raw ? part.replace(/(\\\\*)`/g, \"$1$1\\\\`\") : uncook(part));",
                    "      } else {",
                    "        parts.push(part);",
                    "      }",
                    "    });",
                    "",
                    "    return { ...currentDoc, parts };",
                    "  });",
                    "}",
                    "",
                    "function transformCssDoc(quasisDoc, path, print) {",
                    "  const parentNode = path.getValue();",
                    "",
                    "  const isEmpty =",
                    "    parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();",
                    "  if (isEmpty) {",
                    "    return \"``\";",
                    "  }",
                    "",
                    "  const expressionDocs = parentNode.expressions",
                    "    ? path.map(print, \"expressions\")",
                    "    : [];",
                    "  const newDoc = replacePlaceholders(quasisDoc, expressionDocs);",
                    "  /* istanbul ignore if */",
                    "  if (!newDoc) {",
                    "    throw new Error(\"Couldn't insert all the expressions\");",
                    "  }",
                    "  return concat([",
                    "    \"`\",",
                    "    indent(concat([hardline, stripTrailingHardline(newDoc)])),",
                    "    softline,",
                    "    \"`\",",
                    "  ]);",
                    "}",
                    "",
                    "// Search all the placeholders in the quasisDoc tree",
                    "// and replace them with the expression docs one by one",
                    "// returns a new doc with all the placeholders replaced,",
                    "// or null if it couldn't replace any expression",
                    "function replacePlaceholders(quasisDoc, expressionDocs) {",
                    "  if (!expressionDocs || !expressionDocs.length) {",
                    "    return quasisDoc;",
                    "  }",
                    "",
                    "  let replaceCounter = 0;",
                    "  const newDoc = mapDoc(quasisDoc, (doc) => {",
                    "    if (!doc || !doc.parts || !doc.parts.length) {",
                    "      return doc;",
                    "    }",
                    "",
                    "    let { parts } = doc;",
                    "    const atIndex = parts.indexOf(\"@\");",
                    "    const placeholderIndex = atIndex + 1;",
                    "    if (",
                    "      atIndex > -1 &&",
                    "      typeof parts[placeholderIndex] === \"string\" &&",
                    "      parts[placeholderIndex].startsWith(\"prettier-placeholder\")",
                    "    ) {",
                    "      // If placeholder is split, join it",
                    "      const at = parts[atIndex];",
                    "      const placeholder = parts[placeholderIndex];",
                    "      const rest = parts.slice(placeholderIndex + 1);",
                    "      parts = parts",
                    "        .slice(0, atIndex)",
                    "        .concat([at + placeholder])",
                    "        .concat(rest);",
                    "    }",
                    "",
                    "    const replacedParts = [];",
                    "    parts.forEach((part) => {",
                    "      if (typeof part !== \"string\" || !part.includes(\"@prettier-placeholder\")) {",
                    "        replacedParts.push(part);",
                    "        return;",
                    "      }",
                    "",
                    "      // When we have multiple placeholders in one line, like:",
                    "      // ${Child}${Child2}:not(:first-child)",
                    "      part.split(/@prettier-placeholder-(\\d+)-id/).forEach((component, idx) => {",
                    "        // The placeholder is always at odd indices",
                    "        if (idx % 2 === 0) {",
                    "          replacedParts.push(component);",
                    "          return;",
                    "        }",
                    "",
                    "        // The component will always be a number at odd index",
                    "        replacedParts.push(\"${\", expressionDocs[component], \"}\");",
                    "        replaceCounter++;",
                    "      });",
                    "    });",
                    "    return { ...doc, parts: replacedParts };",
                    "  });",
                    "  return expressionDocs.length === replaceCounter ? newDoc : null;",
                    "}",
                    "",
                    "function printGraphqlComments(lines) {",
                    "  const parts = [];",
                    "  let seenComment = false;",
                    "",
                    "  lines",
                    "    .map((textLine) => textLine.trim())",
                    "    .forEach((textLine, i, array) => {",
                    "      // Lines are either whitespace only, or a comment (with potential whitespace",
                    "      // around it). Drop whitespace-only lines.",
                    "      if (textLine === \"\") {",
                    "        return;",
                    "      }",
                    "",
                    "      if (array[i - 1] === \"\" && seenComment) {",
                    "        // If a non-first comment is preceded by a blank (whitespace only) line,",
                    "        // add in a blank line.",
                    "        parts.push(concat([hardline, textLine]));",
                    "      } else {",
                    "        parts.push(textLine);",
                    "      }",
                    "",
                    "      seenComment = true;",
                    "    });",
                    "",
                    "  // If `lines` was whitespace only, return `null`.",
                    "  return parts.length === 0 ? null : join(hardline, parts);",
                    "}",
                    "",
                    "/**",
                    " * Template literal in these contexts:",
                    " * <style jsx>{`div{color:red}`}</style>",
                    " * css``",
                    " * css.global``",
                    " * css.resolve``",
                    " */",
                    "function isStyledJsx(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "  return (",
                    "    (parentParent &&",
                    "      node.quasis &&",
                    "      parent.type === \"JSXExpressionContainer\" &&",
                    "      parentParent.type === \"JSXElement\" &&",
                    "      parentParent.openingElement.name.name === \"style\" &&",
                    "      parentParent.openingElement.attributes.some(",
                    "        (attribute) => attribute.name.name === \"jsx\"",
                    "      )) ||",
                    "    (parent &&",
                    "      parent.type === \"TaggedTemplateExpression\" &&",
                    "      parent.tag.type === \"Identifier\" &&",
                    "      parent.tag.name === \"css\") ||",
                    "    (parent &&",
                    "      parent.type === \"TaggedTemplateExpression\" &&",
                    "      parent.tag.type === \"MemberExpression\" &&",
                    "      parent.tag.object.name === \"css\" &&",
                    "      (parent.tag.property.name === \"global\" ||",
                    "        parent.tag.property.name === \"resolve\"))",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * Angular Components can have:",
                    " * - Inline HTML template",
                    " * - Inline CSS styles",
                    " *",
                    " * ...which are both within template literals somewhere",
                    " * inside of the Component decorator factory.",
                    " *",
                    " * E.g.",
                    " * @Component({",
                    " *  template: `<div>...</div>`,",
                    " *  styles: [`h1 { color: blue; }`]",
                    " * })",
                    " */",
                    "function isAngularComponentStyles(path) {",
                    "  return path.match(",
                    "    (node) => node.type === \"TemplateLiteral\",",
                    "    (node, name) => node.type === \"ArrayExpression\" && name === \"elements\",",
                    "    (node, name) =>",
                    "      (node.type === \"Property\" || node.type === \"ObjectProperty\") &&",
                    "      node.key.type === \"Identifier\" &&",
                    "      node.key.name === \"styles\" &&",
                    "      name === \"value\",",
                    "    ...angularComponentObjectExpressionPredicates",
                    "  );",
                    "}",
                    "function isAngularComponentTemplate(path) {",
                    "  return path.match(",
                    "    (node) => node.type === \"TemplateLiteral\",",
                    "    (node, name) =>",
                    "      (node.type === \"Property\" || node.type === \"ObjectProperty\") &&",
                    "      node.key.type === \"Identifier\" &&",
                    "      node.key.name === \"template\" &&",
                    "      name === \"value\",",
                    "    ...angularComponentObjectExpressionPredicates",
                    "  );",
                    "}",
                    "const angularComponentObjectExpressionPredicates = [",
                    "  (node, name) => node.type === \"ObjectExpression\" && name === \"properties\",",
                    "  (node, name) =>",
                    "    node.type === \"CallExpression\" &&",
                    "    node.callee.type === \"Identifier\" &&",
                    "    node.callee.name === \"Component\" &&",
                    "    name === \"arguments\",",
                    "  (node, name) => node.type === \"Decorator\" && name === \"expression\",",
                    "];",
                    "",
                    "/**",
                    " * styled-components template literals",
                    " */",
                    "function isStyledComponents(path) {",
                    "  const parent = path.getParentNode();",
                    "",
                    "  if (!parent || parent.type !== \"TaggedTemplateExpression\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  const { tag } = parent;",
                    "",
                    "  switch (tag.type) {",
                    "    case \"MemberExpression\":",
                    "      return (",
                    "        // styled.foo``",
                    "        isStyledIdentifier(tag.object) ||",
                    "        // Component.extend``",
                    "        isStyledExtend(tag)",
                    "      );",
                    "",
                    "    case \"CallExpression\":",
                    "      return (",
                    "        // styled(Component)``",
                    "        isStyledIdentifier(tag.callee) ||",
                    "        (tag.callee.type === \"MemberExpression\" &&",
                    "          ((tag.callee.object.type === \"MemberExpression\" &&",
                    "            // styled.foo.attrs({})``",
                    "            (isStyledIdentifier(tag.callee.object.object) ||",
                    "              // Component.extend.attrs({})``",
                    "              isStyledExtend(tag.callee.object))) ||",
                    "            // styled(Component).attrs({})``",
                    "            (tag.callee.object.type === \"CallExpression\" &&",
                    "              isStyledIdentifier(tag.callee.object.callee))))",
                    "      );",
                    "",
                    "    case \"Identifier\":",
                    "      // css``",
                    "      return tag.name === \"css\";",
                    "",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * JSX element with CSS prop",
                    " */",
                    "function isCssProp(path) {",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "  return (",
                    "    parentParent &&",
                    "    parent.type === \"JSXExpressionContainer\" &&",
                    "    parentParent.type === \"JSXAttribute\" &&",
                    "    parentParent.name.type === \"JSXIdentifier\" &&",
                    "    parentParent.name.name === \"css\"",
                    "  );",
                    "}",
                    "",
                    "function isStyledIdentifier(node) {",
                    "  return node.type === \"Identifier\" && node.name === \"styled\";",
                    "}",
                    "",
                    "function isStyledExtend(node) {",
                    "  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";",
                    "}",
                    "",
                    "/*",
                    " * react-relay and graphql-tag",
                    " * graphql`...`",
                    " * graphql.experimental`...`",
                    " * gql`...`",
                    " * GraphQL comment block",
                    " *",
                    " * This intentionally excludes Relay Classic tags, as Prettier does not",
                    " * support Relay Classic formatting.",
                    " */",
                    "function isGraphQL(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  return (",
                    "    hasLanguageComment(node, \"GraphQL\") ||",
                    "    (parent &&",
                    "      ((parent.type === \"TaggedTemplateExpression\" &&",
                    "        ((parent.tag.type === \"MemberExpression\" &&",
                    "          parent.tag.object.name === \"graphql\" &&",
                    "          parent.tag.property.name === \"experimental\") ||",
                    "          (parent.tag.type === \"Identifier\" &&",
                    "            (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")))) ||",
                    "        (parent.type === \"CallExpression\" &&",
                    "          parent.callee.type === \"Identifier\" &&",
                    "          parent.callee.name === \"graphql\")))",
                    "  );",
                    "}",
                    "",
                    "function hasLanguageComment(node, languageName) {",
                    "  // This checks for a leading comment that is exactly `/* GraphQL */`",
                    "  // In order to be in line with other implementations of this comment tag",
                    "  // we will not trim the comment value and we will expect exactly one space on",
                    "  // either side of the GraphQL string",
                    "  // Also see ./clean.js",
                    "  return hasLeadingComment(",
                    "    node,",
                    "    (comment) =>",
                    "      isBlockComment(comment) && comment.value === ` ${languageName} `",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " *     - html`...`",
                    " *     - HTML comment block",
                    " */",
                    "function isHtml(path) {",
                    "  return (",
                    "    hasLanguageComment(path.getValue(), \"HTML\") ||",
                    "    path.match(",
                    "      (node) => node.type === \"TemplateLiteral\",",
                    "      (node, name) =>",
                    "        node.type === \"TaggedTemplateExpression\" &&",
                    "        node.tag.type === \"Identifier\" &&",
                    "        node.tag.name === \"html\" &&",
                    "        name === \"quasi\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "// The counter is needed to distinguish nested embeds.",
                    "let htmlTemplateLiteralCounter = 0;",
                    "",
                    "function printHtmlTemplateLiteral(path, print, textToDoc, parser, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  const counter = htmlTemplateLiteralCounter;",
                    "  htmlTemplateLiteralCounter = (htmlTemplateLiteralCounter + 1) >>> 0;",
                    "",
                    "  const composePlaceholder = (index) =>",
                    "    `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;",
                    "",
                    "  const text = node.quasis",
                    "    .map((quasi, index, quasis) =>",
                    "      index === quasis.length - 1",
                    "        ? quasi.value.cooked",
                    "        : quasi.value.cooked + composePlaceholder(index)",
                    "    )",
                    "    .join(\"\");",
                    "",
                    "  const expressionDocs = path.map(print, \"expressions\");",
                    "",
                    "  if (expressionDocs.length === 0 && text.trim().length === 0) {",
                    "    return \"``\";",
                    "  }",
                    "",
                    "  const placeholderRegex = new RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");",
                    "  let topLevelCount = 0;",
                    "",
                    "  const contentDoc = mapDoc(",
                    "    stripTrailingHardline(",
                    "      textToDoc(text, {",
                    "        parser,",
                    "        __onHtmlRoot(root) {",
                    "          topLevelCount = root.children.length;",
                    "        },",
                    "      })",
                    "    ),",
                    "    (doc) => {",
                    "      if (typeof doc !== \"string\") {",
                    "        return doc;",
                    "      }",
                    "",
                    "      const parts = [];",
                    "",
                    "      const components = doc.split(placeholderRegex);",
                    "      for (let i = 0; i < components.length; i++) {",
                    "        let component = components[i];",
                    "",
                    "        if (i % 2 === 0) {",
                    "          if (component) {",
                    "            component = uncook(component);",
                    "            if (options.embeddedInHtml) {",
                    "              component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");",
                    "            }",
                    "            parts.push(component);",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        const placeholderIndex = +component;",
                    "        parts.push(",
                    "          concat([\"${\", group(expressionDocs[placeholderIndex]), \"}\"])",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "  );",
                    "",
                    "  const leadingWhitespace = /^\\s/.test(text) ? \" \" : \"\";",
                    "  const trailingWhitespace = /\\s$/.test(text) ? \" \" : \"\";",
                    "",
                    "  const linebreak =",
                    "    options.htmlWhitespaceSensitivity === \"ignore\"",
                    "      ? hardline",
                    "      : leadingWhitespace && trailingWhitespace",
                    "      ? line",
                    "      : null;",
                    "",
                    "  if (linebreak) {",
                    "    return group(",
                    "      concat([",
                    "        \"`\",",
                    "        indent(concat([linebreak, group(contentDoc)])),",
                    "        linebreak,",
                    "        \"`\",",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  return group(",
                    "    concat([",
                    "      \"`\",",
                    "      leadingWhitespace,",
                    "      topLevelCount > 1 ? indent(group(contentDoc)) : group(contentDoc),",
                    "      trailingWhitespace,",
                    "      \"`\",",
                    "    ])",
                    "  );",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "html-binding.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { concat, join, line },",
                    "} = require(\"../document\");",
                    "",
                    "function printHtmlBinding(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (options.__onHtmlBindingRoot && path.getName() === null) {",
                    "    options.__onHtmlBindingRoot(node, options);",
                    "  }",
                    "",
                    "  if (node.type !== \"File\") {",
                    "    return;",
                    "  }",
                    "",
                    "  if (options.__isVueForBindingLeft) {",
                    "    return path.call(",
                    "      (functionDeclarationPath) => {",
                    "        const { params } = functionDeclarationPath.getValue();",
                    "        return concat([",
                    "          params.length > 1 ? \"(\" : \"\",",
                    "          join(",
                    "            concat([\",\", line]),",
                    "            functionDeclarationPath.map(print, \"params\")",
                    "          ),",
                    "          params.length > 1 ? \")\" : \"\",",
                    "        ]);",
                    "      },",
                    "      \"program\",",
                    "      \"body\",",
                    "      0",
                    "    );",
                    "  }",
                    "",
                    "  if (options.__isVueSlotScope) {",
                    "    return path.call(",
                    "      (functionDeclarationPath) =>",
                    "        join(concat([\",\", line]), functionDeclarationPath.map(print, \"params\")),",
                    "      \"program\",",
                    "      \"body\",",
                    "      0",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "// based on https://github.com/prettier/prettier/blob/master/src/language-html/syntax-vue.js isVueEventBindingExpression()",
                    "function isVueEventBindingExpression(node) {",
                    "  switch (node.type) {",
                    "    case \"MemberExpression\":",
                    "      switch (node.property.type) {",
                    "        case \"Identifier\":",
                    "        case \"NumericLiteral\":",
                    "        case \"StringLiteral\":",
                    "          return isVueEventBindingExpression(node.object);",
                    "      }",
                    "      return false;",
                    "    case \"Identifier\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  isVueEventBindingExpression,",
                    "  printHtmlBinding,",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const estreePrinter = require(\"./printer-estree\");",
                    "const estreeJsonPrinter = require(\"./printer-estree-json\");",
                    "const options = require(\"./options\");",
                    "const createLanguage = require(\"../utils/create-language\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/JavaScript\"), (data) => ({",
                    "    since: \"0.0.0\",",
                    "    parsers: [\"babel\", \"flow\"],",
                    "    vscodeLanguageIds: [\"javascript\", \"mongo\"],",
                    "    interpreters: data.interpreters.concat([\"nodejs\"]),",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JavaScript\"), () => ({",
                    "    name: \"Flow\",",
                    "    since: \"0.0.0\",",
                    "    parsers: [\"babel\", \"flow\"],",
                    "    vscodeLanguageIds: [\"javascript\"],",
                    "    aliases: [],",
                    "    filenames: [],",
                    "    extensions: [\".js.flow\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JSX\"), () => ({",
                    "    since: \"0.0.0\",",
                    "    parsers: [\"babel\", \"flow\"],",
                    "    vscodeLanguageIds: [\"javascriptreact\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/TypeScript\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescript\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/TSX\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescriptreact\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JSON\"), () => ({",
                    "    name: \"JSON.stringify\",",
                    "    since: \"1.13.0\",",
                    "    parsers: [\"json-stringify\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: [], // .json file defaults to json instead of json-stringify",
                    "    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JSON\"), (data) => ({",
                    "    since: \"1.5.0\",",
                    "    parsers: [\"json\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    filenames: data.filenames.concat([\".prettierrc\"]),",
                    "  })),",
                    "  createLanguage(",
                    "    require(\"linguist-languages/data/JSON with Comments\"),",
                    "    (data) => ({",
                    "      since: \"1.5.0\",",
                    "      parsers: [\"json\"],",
                    "      vscodeLanguageIds: [\"jsonc\"],",
                    "      filenames: data.filenames.concat([\".eslintrc\"]),",
                    "    })",
                    "  ),",
                    "  createLanguage(require(\"linguist-languages/data/JSON5\"), () => ({",
                    "    since: \"1.13.0\",",
                    "    parsers: [\"json5\"],",
                    "    vscodeLanguageIds: [\"json5\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  estree: estreePrinter,",
                    "  \"estree-json\": estreeJsonPrinter,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last\");",
                    "",
                    "function locStart(node, opts) {",
                    "  opts = opts || {};",
                    "  // Handle nodes with decorators. They should start at the first decorator",
                    "  if (",
                    "    !opts.ignoreDecorators &&",
                    "    node.declaration &&",
                    "    node.declaration.decorators &&",
                    "    node.declaration.decorators.length > 0",
                    "  ) {",
                    "    return locStart(node.declaration.decorators[0]);",
                    "  }",
                    "  if (!opts.ignoreDecorators && node.decorators && node.decorators.length > 0) {",
                    "    return locStart(node.decorators[0]);",
                    "  }",
                    "",
                    "  if (node.__location) {",
                    "    return node.__location.startOffset;",
                    "  }",
                    "  if (node.range) {",
                    "    return node.range[0];",
                    "  }",
                    "  if (typeof node.start === \"number\") {",
                    "    return node.start;",
                    "  }",
                    "  if (node.loc) {",
                    "    return node.loc.start;",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  const endNode = node.nodes && getLast(node.nodes);",
                    "  if (endNode && node.source && !node.source.end) {",
                    "    node = endNode;",
                    "  }",
                    "",
                    "  if (node.__location) {",
                    "    return node.__location.endOffset;",
                    "  }",
                    "",
                    "  const loc = node.range",
                    "    ? node.range[1]",
                    "    : typeof node.end === \"number\"",
                    "    ? node.end",
                    "    : null;",
                    "",
                    "  if (node.typeAnnotation) {",
                    "    return Math.max(loc, locEnd(node.typeAnnotation));",
                    "  }",
                    "",
                    "  if (node.loc && !loc) {",
                    "    return node.loc.end;",
                    "  }",
                    "",
                    "  return loc;",
                    "}",
                    "",
                    "function composeLoc(startNode, endNodeOrLength = startNode) {",
                    "  const length = typeof endNodeOrLength === \"number\" ? endNodeOrLength : -1;",
                    "  const start = locStart(startNode);",
                    "  const end = length !== -1 ? start + length : locEnd(endNodeOrLength);",
                    "  const startLoc = startNode.loc.start;",
                    "  return {",
                    "    start,",
                    "    end,",
                    "    range: [start, end],",
                    "    loc: {",
                    "      start: startLoc,",
                    "      end:",
                    "        length !== -1",
                    "          ? { line: startLoc.line, column: startLoc.column + length }",
                    "          : endNodeOrLength.loc.end,",
                    "    },",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  locStart,",
                    "  locEnd,",
                    "  composeLoc,",
                    "};"
                ]
            },
            "needs-parens.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "",
                    "const util = require(\"../common/util\");",
                    "const {",
                    "  getLeftSidePathName,",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasNakedLeftSide,",
                    "  hasNode,",
                    "} = require(\"./utils\");",
                    "",
                    "function needsParens(path, options) {",
                    "  const parent = path.getParentNode();",
                    "  if (!parent) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const name = path.getName();",
                    "  const node = path.getNode();",
                    "",
                    "  // If the value of this path is some child of a Node and not a Node",
                    "  // itself, then it doesn't need parentheses. Only Node objects (in",
                    "  // fact, only Expression nodes) need parentheses.",
                    "  if (path.getValue() !== node) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // to avoid unexpected `}}` in HTML interpolations",
                    "  if (",
                    "    options.__isInHtmlInterpolation &&",
                    "    !options.bracketSpacing &&",
                    "    endsWithRightBracket(node) &&",
                    "    isFollowedByRightBracket(path)",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Only statements don't need parentheses.",
                    "  if (isStatement(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    // Preserve parens if we have a Flow annotation comment, unless we're using the Flow",
                    "    // parser. The Flow parser turns Flow comments into type annotation nodes in its",
                    "    // AST, which we handle separately.",
                    "    options.parser !== \"flow\" &&",
                    "    hasFlowShorthandAnnotationComment(path.getValue())",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Identifiers never need parentheses.",
                    "  if (node.type === \"Identifier\") {",
                    "    // ...unless those identifiers are embed placeholders. They might be substituted by complex",
                    "    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):",
                    "    //     let tpl = html`<script> f((${expr}) / 2); </script>`;",
                    "    // If the inner JS formatter removes the parens, the expression might change its meaning:",
                    "    //     f((a + b) / 2)  vs  f(a + b / 2)",
                    "    if (",
                    "      node.extra &&",
                    "      node.extra.parenthesized &&",
                    "      /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "    return false;",
                    "  }",
                    "",
                    "  if (parent.type === \"ParenthesizedExpression\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Add parens around the extends clause of a class. It is needed for almost",
                    "  // all expressions.",
                    "  if (",
                    "    (parent.type === \"ClassDeclaration\" || parent.type === \"ClassExpression\") &&",
                    "    parent.superClass === node &&",
                    "    (node.type === \"ArrowFunctionExpression\" ||",
                    "      node.type === \"AssignmentExpression\" ||",
                    "      node.type === \"AwaitExpression\" ||",
                    "      node.type === \"BinaryExpression\" ||",
                    "      node.type === \"ConditionalExpression\" ||",
                    "      node.type === \"LogicalExpression\" ||",
                    "      node.type === \"NewExpression\" ||",
                    "      node.type === \"ObjectExpression\" ||",
                    "      node.type === \"ParenthesizedExpression\" ||",
                    "      node.type === \"SequenceExpression\" ||",
                    "      node.type === \"TaggedTemplateExpression\" ||",
                    "      node.type === \"UnaryExpression\" ||",
                    "      node.type === \"UpdateExpression\" ||",
                    "      node.type === \"YieldExpression\")",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (parent.type === \"ExportDefaultDeclaration\") {",
                    "    return (",
                    "      // `export default function` or `export default class` can't be followed by",
                    "      // anything after. So an expression like `export default (function(){}).toString()`",
                    "      // needs to be followed by a parentheses",
                    "      shouldWrapFunctionForExportDefault(path, options) ||",
                    "      // `export default (foo, bar)` also needs parentheses",
                    "      node.type === \"SequenceExpression\"",
                    "    );",
                    "  }",
                    "",
                    "  if (parent.type === \"Decorator\" && parent.expression === node) {",
                    "    let hasCallExpression = false;",
                    "    let hasMemberExpression = false;",
                    "    let current = node;",
                    "    while (current) {",
                    "      switch (current.type) {",
                    "        case \"MemberExpression\":",
                    "          hasMemberExpression = true;",
                    "          current = current.object;",
                    "          break;",
                    "        case \"CallExpression\":",
                    "          if (",
                    "            /** @(x().y) */ hasMemberExpression ||",
                    "            /** @(x().y()) */ hasCallExpression",
                    "          ) {",
                    "            return true;",
                    "          }",
                    "          hasCallExpression = true;",
                    "          current = current.callee;",
                    "          break;",
                    "        case \"Identifier\":",
                    "          return false;",
                    "        default:",
                    "          return true;",
                    "      }",
                    "    }",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    (parent.type === \"ArrowFunctionExpression\" &&",
                    "    parent.body === node &&",
                    "    node.type !== \"SequenceExpression\" && // these have parens added anyway",
                    "      util.startsWithNoLookaheadToken(",
                    "        node,",
                    "        /* forbidFunctionClassAndDoExpr */ false",
                    "      )) ||",
                    "    (parent.type === \"ExpressionStatement\" &&",
                    "      util.startsWithNoLookaheadToken(",
                    "        node,",
                    "        /* forbidFunctionClassAndDoExpr */ true",
                    "      ))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"SpreadElement\":",
                    "    case \"SpreadProperty\":",
                    "      return (",
                    "        parent.type === \"MemberExpression\" &&",
                    "        name === \"object\" &&",
                    "        parent.object === node",
                    "      );",
                    "",
                    "    case \"UpdateExpression\":",
                    "      if (parent.type === \"UnaryExpression\") {",
                    "        return (",
                    "          node.prefix &&",
                    "          ((node.operator === \"++\" && parent.operator === \"+\") ||",
                    "            (node.operator === \"--\" && parent.operator === \"-\"))",
                    "        );",
                    "      }",
                    "    // else fallthrough",
                    "    case \"UnaryExpression\":",
                    "      switch (parent.type) {",
                    "        case \"UnaryExpression\":",
                    "          return (",
                    "            node.operator === parent.operator &&",
                    "            (node.operator === \"+\" || node.operator === \"-\")",
                    "          );",
                    "",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"BinaryExpression\":",
                    "          return parent.operator === \"**\" && name === \"left\";",
                    "",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"BinaryExpression\": {",
                    "      if (",
                    "        parent.type === \"UpdateExpression\" ||",
                    "        (parent.type === \"PipelineTopicExpression\" && node.operator === \"|>\")",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "",
                    "      const isLeftOfAForStatement = (node) => {",
                    "        let i = 0;",
                    "        while (node) {",
                    "          const parent = path.getParentNode(i++);",
                    "          if (!parent) {",
                    "            return false;",
                    "          }",
                    "          if (parent.type === \"ForStatement\" && parent.init === node) {",
                    "            return true;",
                    "          }",
                    "          node = parent;",
                    "        }",
                    "        return false;",
                    "      };",
                    "      if (node.operator === \"in\" && isLeftOfAForStatement(node)) {",
                    "        return true;",
                    "      }",
                    "      if (node.operator === \"|>\" && node.extra && node.extra.parenthesized) {",
                    "        const grandParent = path.getParentNode(1);",
                    "        if (",
                    "          grandParent.type === \"BinaryExpression\" &&",
                    "          grandParent.operator === \"|>\"",
                    "        ) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "    }",
                    "    // fallthrough",
                    "    case \"TSTypeAssertion\":",
                    "    case \"TSAsExpression\":",
                    "    case \"LogicalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"ConditionalExpression\":",
                    "          return node.type === \"TSAsExpression\";",
                    "",
                    "        case \"CallExpression\":",
                    "        case \"NewExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ClassExpression\":",
                    "        case \"ClassDeclaration\":",
                    "          return name === \"superClass\" && parent.superClass === node;",
                    "",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"BindExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"UpdateExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"AssignmentExpression\":",
                    "          return (",
                    "            parent.left === node &&",
                    "            (node.type === \"TSTypeAssertion\" || node.type === \"TSAsExpression\")",
                    "          );",
                    "",
                    "        case \"LogicalExpression\":",
                    "          if (node.type === \"LogicalExpression\") {",
                    "            return parent.operator !== node.operator;",
                    "          }",
                    "        // else fallthrough",
                    "",
                    "        case \"BinaryExpression\": {",
                    "          if (!node.operator && node.type !== \"TSTypeAssertion\") {",
                    "            return true;",
                    "          }",
                    "",
                    "          const po = parent.operator;",
                    "          const pp = util.getPrecedence(po);",
                    "          const no = node.operator;",
                    "          const np = util.getPrecedence(no);",
                    "",
                    "          if (pp > np) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (pp === np && name === \"right\") {",
                    "            assert.strictEqual(parent.right, node);",
                    "            return true;",
                    "          }",
                    "",
                    "          if (pp === np && !util.shouldFlatten(po, no)) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (pp < np && no === \"%\") {",
                    "            return po === \"+\" || po === \"-\";",
                    "          }",
                    "",
                    "          // Add parenthesis when working with bitwise operators",
                    "          // It's not strictly needed but helps with code understanding",
                    "          if (util.isBitwiseOperator(po)) {",
                    "            return true;",
                    "          }",
                    "",
                    "          return false;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"SequenceExpression\":",
                    "      switch (parent.type) {",
                    "        case \"ReturnStatement\":",
                    "          return false;",
                    "",
                    "        case \"ForStatement\":",
                    "          // Although parentheses wouldn't hurt around sequence",
                    "          // expressions in the head of for loops, traditional style",
                    "          // dictates that e.g. i++, j++ should not be wrapped with",
                    "          // parentheses.",
                    "          return false;",
                    "",
                    "        case \"ExpressionStatement\":",
                    "          return name !== \"expression\";",
                    "",
                    "        case \"ArrowFunctionExpression\":",
                    "          // We do need parentheses, but SequenceExpressions are handled",
                    "          // specially when printing bodies of arrow functions.",
                    "          return name !== \"body\";",
                    "",
                    "        default:",
                    "          // Otherwise err on the side of overparenthesization, adding",
                    "          // explicit exceptions above if this proves overzealous.",
                    "          return true;",
                    "      }",
                    "",
                    "    case \"YieldExpression\":",
                    "      if (",
                    "        parent.type === \"UnaryExpression\" ||",
                    "        parent.type === \"AwaitExpression\" ||",
                    "        parent.type === \"TSAsExpression\" ||",
                    "        parent.type === \"TSNonNullExpression\"",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // else fallthrough",
                    "    case \"AwaitExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return parent.test === node;",
                    "",
                    "        case \"BinaryExpression\": {",
                    "          if (!node.argument && parent.operator === \"|>\") {",
                    "            return false;",
                    "          }",
                    "          return true;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"TSJSDocFunctionType\":",
                    "    case \"TSConditionalType\":",
                    "      if (parent.type === \"TSConditionalType\" && node === parent.extendsType) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSFunctionType\":",
                    "    case \"TSConstructorType\":",
                    "      if (parent.type === \"TSConditionalType\" && node === parent.checkType) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSUnionType\":",
                    "    case \"TSIntersectionType\":",
                    "      if (",
                    "        parent.type === \"TSUnionType\" ||",
                    "        parent.type === \"TSIntersectionType\"",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSTypeOperator\":",
                    "    case \"TSInferType\":",
                    "      return (",
                    "        parent.type === \"TSArrayType\" ||",
                    "        parent.type === \"TSOptionalType\" ||",
                    "        parent.type === \"TSRestType\" ||",
                    "        (parent.type === \"TSIndexedAccessType\" && node === parent.objectType) ||",
                    "        parent.type === \"TSTypeOperator\" ||",
                    "        (parent.type === \"TSTypeAnnotation\" &&",
                    "          /^TSJSDoc/.test(path.getParentNode(1).type))",
                    "      );",
                    "",
                    "    case \"ArrayTypeAnnotation\":",
                    "      return parent.type === \"NullableTypeAnnotation\";",
                    "",
                    "    case \"IntersectionTypeAnnotation\":",
                    "    case \"UnionTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        parent.type === \"NullableTypeAnnotation\" ||",
                    "        parent.type === \"IntersectionTypeAnnotation\" ||",
                    "        parent.type === \"UnionTypeAnnotation\"",
                    "      );",
                    "",
                    "    case \"NullableTypeAnnotation\":",
                    "      return parent.type === \"ArrayTypeAnnotation\";",
                    "",
                    "    case \"FunctionTypeAnnotation\": {",
                    "      const ancestor =",
                    "        parent.type === \"NullableTypeAnnotation\"",
                    "          ? path.getParentNode(1)",
                    "          : parent;",
                    "",
                    "      return (",
                    "        ancestor.type === \"UnionTypeAnnotation\" ||",
                    "        ancestor.type === \"IntersectionTypeAnnotation\" ||",
                    "        ancestor.type === \"ArrayTypeAnnotation\" ||",
                    "        // We should check ancestor's parent to know whether the parentheses",
                    "        // are really needed, but since ??T doesn't make sense this check",
                    "        // will almost never be true.",
                    "        ancestor.type === \"NullableTypeAnnotation\" ||",
                    "        // See #5283",
                    "        (parent.type === \"FunctionTypeParam\" &&",
                    "          parent.name === null &&",
                    "          node.params &&",
                    "          node.params.some(",
                    "            (param) =>",
                    "              param.typeAnnotation &&",
                    "              param.typeAnnotation.type === \"NullableTypeAnnotation\"",
                    "          ))",
                    "      );",
                    "    }",
                    "",
                    "    case \"StringLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"Literal\":",
                    "      if (",
                    "        typeof node.value === \"string\" &&",
                    "        parent.type === \"ExpressionStatement\" &&",
                    "        !parent.directive",
                    "      ) {",
                    "        // To avoid becoming a directive",
                    "        const grandParent = path.getParentNode(1);",
                    "",
                    "        return (",
                    "          grandParent.type === \"Program\" ||",
                    "          grandParent.type === \"BlockStatement\"",
                    "        );",
                    "      }",
                    "",
                    "      return (",
                    "        parent.type === \"MemberExpression\" &&",
                    "        typeof node.value === \"number\" &&",
                    "        name === \"object\" &&",
                    "        parent.object === node",
                    "      );",
                    "",
                    "    case \"AssignmentExpression\": {",
                    "      const grandParent = path.getParentNode(1);",
                    "",
                    "      if (parent.type === \"ArrowFunctionExpression\" && parent.body === node) {",
                    "        return true;",
                    "      } else if (",
                    "        parent.type === \"ClassProperty\" &&",
                    "        parent.key === node &&",
                    "        parent.computed",
                    "      ) {",
                    "        return false;",
                    "      } else if (",
                    "        parent.type === \"TSPropertySignature\" &&",
                    "        parent.name === node",
                    "      ) {",
                    "        return false;",
                    "      } else if (",
                    "        parent.type === \"ForStatement\" &&",
                    "        (parent.init === node || parent.update === node)",
                    "      ) {",
                    "        return false;",
                    "      } else if (parent.type === \"ExpressionStatement\") {",
                    "        return node.left.type === \"ObjectPattern\";",
                    "      } else if (parent.type === \"TSPropertySignature\" && parent.key === node) {",
                    "        return false;",
                    "      } else if (parent.type === \"AssignmentExpression\") {",
                    "        return false;",
                    "      } else if (",
                    "        parent.type === \"SequenceExpression\" &&",
                    "        grandParent &&",
                    "        grandParent.type === \"ForStatement\" &&",
                    "        (grandParent.init === parent || grandParent.update === parent)",
                    "      ) {",
                    "        return false;",
                    "      } else if (parent.type === \"Property\" && parent.value === node) {",
                    "        return false;",
                    "      } else if (parent.type === \"NGChainedExpression\") {",
                    "        return false;",
                    "      }",
                    "      return true;",
                    "    }",
                    "    case \"ConditionalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"BinaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"NGPipeExpression\":",
                    "        case \"ExportDefaultDeclaration\":",
                    "        case \"AwaitExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TypeCastExpression\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\" && parent.test === node;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"FunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.",
                    "          // Is necessary if it is `expression` of `ExpressionStatement`.",
                    "          return name === \"callee\";",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true; // This is basically a kind of IIFE.",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ArrowFunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"PipelineTopicExpression\":",
                    "          return !!(node.extra && node.extra.parenthesized);",
                    "",
                    "        case \"BinaryExpression\":",
                    "          return (",
                    "            parent.operator !== \"|>\" || (node.extra && node.extra.parenthesized)",
                    "          );",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"TSAsExpression\":",
                    "        case \"BindExpression\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSTypeAssertion\":",
                    "          return true;",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ClassExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "          return name === \"callee\" && parent.callee === node;",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"OptionalCallExpression\": {",
                    "      const parentParent = path.getParentNode(1);",
                    "      if (",
                    "        (parent.type === \"MemberExpression\" && name === \"object\") ||",
                    "        ((parent.type === \"CallExpression\" ||",
                    "          parent.type === \"NewExpression\") &&",
                    "          name === \"callee\") ||",
                    "        (parent.type === \"TSNonNullExpression\" &&",
                    "          parentParent.type === \"MemberExpression\" &&",
                    "          parentParent.object === parent)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "    // fallthrough",
                    "    case \"CallExpression\":",
                    "    case \"MemberExpression\":",
                    "    case \"TaggedTemplateExpression\":",
                    "    case \"TSNonNullExpression\":",
                    "      if (",
                    "        (parent.type === \"BindExpression\" || parent.type === \"NewExpression\") &&",
                    "        name === \"callee\"",
                    "      ) {",
                    "        let object = node;",
                    "        while (object) {",
                    "          switch (object.type) {",
                    "            case \"CallExpression\":",
                    "            case \"OptionalCallExpression\":",
                    "              return true;",
                    "            case \"MemberExpression\":",
                    "            case \"OptionalMemberExpression\":",
                    "            case \"BindExpression\":",
                    "              object = object.object;",
                    "              break;",
                    "            // tagged templates are basically member expressions from a grammar perspective",
                    "            // see https://tc39.github.io/ecma262/#prod-MemberExpression",
                    "            case \"TaggedTemplateExpression\":",
                    "              object = object.tag;",
                    "              break;",
                    "            case \"TSNonNullExpression\":",
                    "              object = object.expression;",
                    "              break;",
                    "            default:",
                    "              return false;",
                    "          }",
                    "        }",
                    "      }",
                    "      return false;",
                    "",
                    "    case \"BindExpression\":",
                    "      return (",
                    "        ((parent.type === \"BindExpression\" ||",
                    "          parent.type === \"NewExpression\") &&",
                    "          name === \"callee\") ||",
                    "        ((parent.type === \"MemberExpression\" ||",
                    "          parent.type === \"OptionalMemberExpression\") &&",
                    "          name === \"object\")",
                    "      );",
                    "    case \"NGPipeExpression\":",
                    "      if (",
                    "        parent.type === \"NGRoot\" ||",
                    "        parent.type === \"NGMicrosyntaxExpression\" ||",
                    "        (parent.type === \"ObjectProperty\" &&",
                    "          // Preserve parens for compatibility with AngularJS expressions",
                    "          !(node.extra && node.extra.parenthesized)) ||",
                    "        parent.type === \"ArrayExpression\" ||",
                    "        ((parent.type === \"CallExpression\" ||",
                    "          parent.type === \"OptionalCallExpression\") &&",
                    "          parent.arguments[name] === node) ||",
                    "        (parent.type === \"NGPipeExpression\" && name === \"right\") ||",
                    "        (parent.type === \"MemberExpression\" && name === \"property\") ||",
                    "        parent.type === \"AssignmentExpression\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "      return true;",
                    "    case \"JSXFragment\":",
                    "    case \"JSXElement\":",
                    "      return (",
                    "        name === \"callee\" ||",
                    "        (parent.type === \"BinaryExpression\" &&",
                    "          parent.operator === \"<\" &&",
                    "          name === \"left\") ||",
                    "        (parent.type !== \"ArrayExpression\" &&",
                    "          parent.type !== \"ArrowFunctionExpression\" &&",
                    "          parent.type !== \"AssignmentExpression\" &&",
                    "          parent.type !== \"AssignmentPattern\" &&",
                    "          parent.type !== \"BinaryExpression\" &&",
                    "          parent.type !== \"CallExpression\" &&",
                    "          parent.type !== \"NewExpression\" &&",
                    "          parent.type !== \"ConditionalExpression\" &&",
                    "          parent.type !== \"ExpressionStatement\" &&",
                    "          parent.type !== \"JsExpressionRoot\" &&",
                    "          parent.type !== \"JSXAttribute\" &&",
                    "          parent.type !== \"JSXElement\" &&",
                    "          parent.type !== \"JSXExpressionContainer\" &&",
                    "          parent.type !== \"JSXFragment\" &&",
                    "          parent.type !== \"LogicalExpression\" &&",
                    "          parent.type !== \"ObjectProperty\" &&",
                    "          parent.type !== \"OptionalCallExpression\" &&",
                    "          parent.type !== \"Property\" &&",
                    "          parent.type !== \"ReturnStatement\" &&",
                    "          parent.type !== \"ThrowStatement\" &&",
                    "          parent.type !== \"TypeCastExpression\" &&",
                    "          parent.type !== \"VariableDeclarator\" &&",
                    "          parent.type !== \"YieldExpression\")",
                    "      );",
                    "    case \"TypeAnnotation\":",
                    "      return (",
                    "        name === \"returnType\" &&",
                    "        parent.type === \"ArrowFunctionExpression\" &&",
                    "        includesFunctionTypeInObjectType(node)",
                    "      );",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isStatement(node) {",
                    "  return (",
                    "    node.type === \"BlockStatement\" ||",
                    "    node.type === \"BreakStatement\" ||",
                    "    node.type === \"ClassBody\" ||",
                    "    node.type === \"ClassDeclaration\" ||",
                    "    node.type === \"ClassMethod\" ||",
                    "    node.type === \"ClassProperty\" ||",
                    "    node.type === \"ClassPrivateProperty\" ||",
                    "    node.type === \"ContinueStatement\" ||",
                    "    node.type === \"DebuggerStatement\" ||",
                    "    node.type === \"DeclareClass\" ||",
                    "    node.type === \"DeclareExportAllDeclaration\" ||",
                    "    node.type === \"DeclareExportDeclaration\" ||",
                    "    node.type === \"DeclareFunction\" ||",
                    "    node.type === \"DeclareInterface\" ||",
                    "    node.type === \"DeclareModule\" ||",
                    "    node.type === \"DeclareModuleExports\" ||",
                    "    node.type === \"DeclareVariable\" ||",
                    "    node.type === \"DoWhileStatement\" ||",
                    "    node.type === \"EnumDeclaration\" ||",
                    "    node.type === \"ExportAllDeclaration\" ||",
                    "    node.type === \"ExportDefaultDeclaration\" ||",
                    "    node.type === \"ExportNamedDeclaration\" ||",
                    "    node.type === \"ExpressionStatement\" ||",
                    "    node.type === \"ForInStatement\" ||",
                    "    node.type === \"ForOfStatement\" ||",
                    "    node.type === \"ForStatement\" ||",
                    "    node.type === \"FunctionDeclaration\" ||",
                    "    node.type === \"IfStatement\" ||",
                    "    node.type === \"ImportDeclaration\" ||",
                    "    node.type === \"InterfaceDeclaration\" ||",
                    "    node.type === \"LabeledStatement\" ||",
                    "    node.type === \"MethodDefinition\" ||",
                    "    node.type === \"ReturnStatement\" ||",
                    "    node.type === \"SwitchStatement\" ||",
                    "    node.type === \"ThrowStatement\" ||",
                    "    node.type === \"TryStatement\" ||",
                    "    node.type === \"TSDeclareFunction\" ||",
                    "    node.type === \"TSEnumDeclaration\" ||",
                    "    node.type === \"TSImportEqualsDeclaration\" ||",
                    "    node.type === \"TSInterfaceDeclaration\" ||",
                    "    node.type === \"TSModuleDeclaration\" ||",
                    "    node.type === \"TSNamespaceExportDeclaration\" ||",
                    "    node.type === \"TypeAlias\" ||",
                    "    node.type === \"VariableDeclaration\" ||",
                    "    node.type === \"WhileStatement\" ||",
                    "    node.type === \"WithStatement\"",
                    "  );",
                    "}",
                    "",
                    "function includesFunctionTypeInObjectType(node) {",
                    "  return hasNode(",
                    "    node,",
                    "    (n1) =>",
                    "      (n1.type === \"ObjectTypeAnnotation\" &&",
                    "        hasNode(",
                    "          n1,",
                    "          (n2) => n2.type === \"FunctionTypeAnnotation\" || undefined",
                    "        )) ||",
                    "      undefined",
                    "  );",
                    "}",
                    "",
                    "function endsWithRightBracket(node) {",
                    "  switch (node.type) {",
                    "    case \"ObjectExpression\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function isFollowedByRightBracket(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const name = path.getName();",
                    "  switch (parent.type) {",
                    "    case \"NGPipeExpression\":",
                    "      if (",
                    "        typeof name === \"number\" &&",
                    "        parent.arguments[name] === node &&",
                    "        parent.arguments.length - 1 === name",
                    "      ) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ObjectProperty\":",
                    "      if (name === \"value\") {",
                    "        const parentParent = path.getParentNode(1);",
                    "        return (",
                    "          parentParent.properties[parentParent.properties.length - 1] === parent",
                    "        );",
                    "      }",
                    "      break;",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      if (name === \"right\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ConditionalExpression\":",
                    "      if (name === \"alternate\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"UnaryExpression\":",
                    "      if (parent.prefix) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function shouldWrapFunctionForExportDefault(path, options) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {",
                    "    return (",
                    "      parent.type === \"ExportDefaultDeclaration\" ||",
                    "      // in some cases the function is already wrapped",
                    "      // (e.g. `export default (function() {})();`)",
                    "      // in this case we don't need to add extra parens",
                    "      !needsParens(path, options)",
                    "    );",
                    "  }",
                    "",
                    "  if (",
                    "    !hasNakedLeftSide(node) ||",
                    "    (parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call(",
                    "    (childPath) => shouldWrapFunctionForExportDefault(childPath, options),",
                    "    ...getLeftSidePathName(path, node)",
                    "  );",
                    "}",
                    "",
                    "module.exports = needsParens;"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options\");",
                    "",
                    "const CATEGORY_JAVASCRIPT = \"JavaScript\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js",
                    "module.exports = {",
                    "  arrowParens: {",
                    "    since: \"1.9.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.9.0\", value: \"avoid\" },",
                    "      { since: \"2.0.0\", value: \"always\" },",
                    "    ],",
                    "    description: \"Include parentheses around a sole arrow function parameter.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"always\",",
                    "        description: \"Always include parens. Example: `(x) => x`\",",
                    "      },",
                    "      {",
                    "        value: \"avoid\",",
                    "        description: \"Omit parens when possible. Example: `x => x`\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  jsxBracketSameLine: {",
                    "    since: \"0.17.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Put > on the last line instead of at a new line.\",",
                    "  },",
                    "  semi: {",
                    "    since: \"1.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print semicolons.\",",
                    "    oppositeDescription:",
                    "      \"Do not print semicolons, except at the beginning of lines which may need them.\",",
                    "  },",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  jsxSingleQuote: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes in JSX.\",",
                    "  },",
                    "  quoteProps: {",
                    "    since: \"1.17.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"as-needed\",",
                    "    description: \"Change when properties in objects are quoted.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"as-needed\",",
                    "        description: \"Only add quotes around object properties where required.\",",
                    "      },",
                    "      {",
                    "        value: \"consistent\",",
                    "        description:",
                    "          \"If at least one property in an object requires quotes, quote all properties.\",",
                    "      },",
                    "      {",
                    "        value: \"preserve\",",
                    "        description: \"Respect the input use of quotes in object properties.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  trailingComma: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"0.0.0\", value: false },",
                    "      { since: \"0.19.0\", value: \"none\" },",
                    "      { since: \"2.0.0\", value: \"es5\" },",
                    "    ],",
                    "    description: \"Print trailing commas wherever possible when multi-line.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"es5\",",
                    "        description:",
                    "          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",",
                    "      },",
                    "      { value: \"none\", description: \"No trailing commas.\" },",
                    "      {",
                    "        value: \"all\",",
                    "        description:",
                    "          \"Trailing commas wherever possible (including function arguments).\",",
                    "      },",
                    "    ],",
                    "  },",
                    "};"
                ]
            },
            "parser-angular.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const locFns = require(\"./loc\");",
                    "",
                    "function createParser(_parse) {",
                    "  const parse = (text, parsers, options) => {",
                    "    const ngEstreeParser = require(\"angular-estree-parser\");",
                    "    const node = _parse(text, ngEstreeParser);",
                    "    return {",
                    "      type: \"NGRoot\",",
                    "      node:",
                    "        options.parser === \"__ng_action\" && node.type !== \"NGChainedExpression\"",
                    "          ? { ...node, type: \"NGChainedExpression\", expressions: [node] }",
                    "          : node,",
                    "    };",
                    "  };",
                    "  return { astFormat: \"estree\", parse, ...locFns };",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    __ng_action: createParser((text, ng) => ng.parseAction(text)),",
                    "    __ng_binding: createParser((text, ng) => ng.parseBinding(text)),",
                    "    __ng_interpolation: createParser((text, ng) => ng.parseInterpolation(text)),",
                    "    __ng_directive: createParser((text, ng) => ng.parseTemplateBindings(text)),",
                    "  },",
                    "};"
                ]
            },
            "parser-babel.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const { hasPragma } = require(\"./pragma\");",
                    "const locFns = require(\"./loc\");",
                    "const postprocess = require(\"./postprocess\");",
                    "",
                    "function babelOptions({ sourceType, extraPlugins = [] }) {",
                    "  return {",
                    "    sourceType,",
                    "    allowAwaitOutsideFunction: true,",
                    "    allowImportExportEverywhere: true,",
                    "    allowReturnOutsideFunction: true,",
                    "    allowSuperOutsideMethod: true,",
                    "    allowUndeclaredExports: true,",
                    "    errorRecovery: true,",
                    "    createParenthesizedExpressions: true,",
                    "    plugins: [",
                    "      // When adding a plugin, please add a test in `tests/js/babel-plugins`,",
                    "      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify",
                    "",
                    "      \"doExpressions\",",
                    "      \"classProperties\",",
                    "      \"exportDefaultFrom\",",
                    "      \"functionBind\",",
                    "      \"functionSent\",",
                    "      \"numericSeparator\",",
                    "      \"classPrivateProperties\",",
                    "      \"throwExpressions\",",
                    "      \"logicalAssignment\",",
                    "      \"classPrivateMethods\",",
                    "      \"v8intrinsic\",",
                    "      \"partialApplication\",",
                    "      [\"decorators\", { decoratorsBeforeExport: false }],",
                    "      \"privateIn\",",
                    "      [\"moduleAttributes\", { version: \"may-2020\" }],",
                    "      [\"recordAndTuple\", { syntaxType: \"hash\" }],",
                    "      ...extraPlugins,",
                    "    ],",
                    "  };",
                    "}",
                    "",
                    "function resolvePluginsConflict(",
                    "  condition,",
                    "  pluginCombinations,",
                    "  conflictPlugins",
                    ") {",
                    "  if (!condition) {",
                    "    return pluginCombinations;",
                    "  }",
                    "  const combinations = [];",
                    "  for (const combination of pluginCombinations) {",
                    "    for (const plugin of conflictPlugins) {",
                    "      combinations.push([...combination, plugin]);",
                    "    }",
                    "  }",
                    "  return combinations;",
                    "}",
                    "",
                    "function createParse(parseMethod, ...pluginCombinations) {",
                    "  return (text, parsers, opts) => {",
                    "    // Inline the require to avoid loading all the JS if we don't use it",
                    "    const babel = require(\"@babel/parser\");",
                    "",
                    "    const sourceType =",
                    "      opts && opts.__babelSourceType === \"script\" ? \"script\" : \"module\";",
                    "",
                    "    let ast;",
                    "    try {",
                    "      const combinations = resolvePluginsConflict(",
                    "        text.includes(\"|>\"),",
                    "        pluginCombinations,",
                    "        [",
                    "          [\"pipelineOperator\", { proposal: \"smart\" }],",
                    "          [\"pipelineOperator\", { proposal: \"minimal\" }],",
                    "          [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                    "        ]",
                    "      );",
                    "      ast = tryCombinations(",
                    "        (options) => babel[parseMethod](text, options),",
                    "        combinations.map((extraPlugins) =>",
                    "          babelOptions({ sourceType, extraPlugins })",
                    "        )",
                    "      );",
                    "    } catch (error) {",
                    "      throw createError(",
                    "        // babel error prints (l:c) with cols that are zero indexed",
                    "        // so we need our custom error",
                    "        error.message.replace(/ \\(.*\\)/, \"\"),",
                    "        error.loc",
                    "          ? {",
                    "              start: {",
                    "                line: error.loc.line,",
                    "                column: error.loc.column + 1,",
                    "              },",
                    "            }",
                    "          : { start: { line: 0, column: 0 } }",
                    "      );",
                    "    }",
                    "    delete ast.tokens;",
                    "    return postprocess(ast, { ...opts, originalText: text });",
                    "  };",
                    "}",
                    "",
                    "const parse = createParse(\"parse\", [\"jsx\", \"flow\"]);",
                    "const parseFlow = createParse(\"parse\", [",
                    "  \"jsx\",",
                    "  [\"flow\", { all: true, enums: true }],",
                    "]);",
                    "const parseTypeScript = createParse(",
                    "  \"parse\",",
                    "  [\"jsx\", \"typescript\"],",
                    "  [\"typescript\"]",
                    ");",
                    "const parseExpression = createParse(\"parseExpression\", [\"jsx\"]);",
                    "",
                    "function tryCombinations(fn, combinations) {",
                    "  let error;",
                    "  for (let i = 0; i < combinations.length; i++) {",
                    "    try {",
                    "      return rethrowSomeRecoveredErrors(fn(combinations[i]));",
                    "    } catch (_error) {",
                    "      if (!error) {",
                    "        error = _error;",
                    "      }",
                    "    }",
                    "  }",
                    "  throw error;",
                    "}",
                    "",
                    "function rethrowSomeRecoveredErrors(ast) {",
                    "  if (ast.errors) {",
                    "    for (const error of ast.errors) {",
                    "      if (",
                    "        typeof error.message === \"string\" &&",
                    "        (error.message.startsWith(",
                    "          // UnexpectedTypeAnnotation",
                    "          // https://github.com/babel/babel/blob/2f31ecf85d85cb100fa08d4d9a09de0fe4a117e4/packages/babel-parser/src/plugins/typescript/index.js#L88",
                    "          \"Did not expect a type annotation here.\"",
                    "        ) ||",
                    "          error.message.startsWith(",
                    "            // ModuleAttributeDifferentFromType",
                    "            // https://github.com/babel/babel/blob/bda759ac3dce548f021ca24e9182b6e6f7c218e3/packages/babel-parser/src/parser/location.js#L99",
                    "            \"The only accepted module attribute is `type`\"",
                    "          ))",
                    "      ) {",
                    "        throw error;",
                    "      }",
                    "    }",
                    "  }",
                    "  return ast;",
                    "}",
                    "",
                    "function parseJson(text, parsers, opts) {",
                    "  const ast = parseExpression(text, parsers, opts);",
                    "",
                    "  ast.comments.forEach(assertJsonNode);",
                    "  assertJsonNode(ast);",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "function assertJsonNode(node, parent) {",
                    "  switch (node.type) {",
                    "    case \"ArrayExpression\":",
                    "      return node.elements.forEach(assertJsonChildNode);",
                    "    case \"ObjectExpression\":",
                    "      return node.properties.forEach(assertJsonChildNode);",
                    "    case \"ObjectProperty\":",
                    "      if (node.computed) {",
                    "        throw createJsonError(\"computed\");",
                    "      }",
                    "",
                    "      if (node.shorthand) {",
                    "        throw createJsonError(\"shorthand\");",
                    "      }",
                    "      return [node.key, node.value].forEach(assertJsonChildNode);",
                    "    case \"UnaryExpression\":",
                    "      switch (node.operator) {",
                    "        case \"+\":",
                    "        case \"-\":",
                    "          return assertJsonChildNode(node.argument);",
                    "        default:",
                    "          throw createJsonError(\"operator\");",
                    "      }",
                    "    case \"Identifier\":",
                    "      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {",
                    "        return;",
                    "      }",
                    "      throw createJsonError();",
                    "    case \"NullLiteral\":",
                    "    case \"BooleanLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"StringLiteral\":",
                    "      return;",
                    "    default:",
                    "      throw createJsonError();",
                    "  }",
                    "",
                    "  function assertJsonChildNode(child) {",
                    "    return assertJsonNode(child, node);",
                    "  }",
                    "",
                    "  function createJsonError(attribute) {",
                    "    const name = !attribute",
                    "      ? node.type",
                    "      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;",
                    "    return createError(`${name} is not allowed in JSON.`, {",
                    "      start: {",
                    "        line: node.loc.start.line,",
                    "        column: node.loc.start.column + 1,",
                    "      },",
                    "    });",
                    "  }",
                    "}",
                    "",
                    "const babel = { parse, astFormat: \"estree\", hasPragma, ...locFns };",
                    "const babelFlow = { ...babel, parse: parseFlow };",
                    "const babelTypeScript = { ...babel, parse: parseTypeScript };",
                    "const babelExpression = { ...babel, parse: parseExpression };",
                    "",
                    "// Export as a plugin so we can reuse the same bundle for UMD loading",
                    "module.exports = {",
                    "  parsers: {",
                    "    babel,",
                    "    \"babel-flow\": babelFlow,",
                    "    \"babel-ts\": babelTypeScript,",
                    "    json: {",
                    "      ...babelExpression,",
                    "      hasPragma() {",
                    "        return true;",
                    "      },",
                    "    },",
                    "    json5: babelExpression,",
                    "    \"json-stringify\": {",
                    "      parse: parseJson,",
                    "      astFormat: \"estree-json\",",
                    "      ...locFns,",
                    "    },",
                    "    /** @internal */",
                    "    __js_expression: babelExpression,",
                    "    /** for vue filter */",
                    "    __vue_expression: babelExpression,",
                    "    /** for vue event binding to handle semicolon */",
                    "    __vue_event_binding: babel,",
                    "  },",
                    "};"
                ]
            },
            "parser-flow.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const includeShebang = require(\"../common/parser-include-shebang\");",
                    "const { hasPragma } = require(\"./pragma\");",
                    "const locFns = require(\"./loc\");",
                    "const postprocess = require(\"./postprocess\");",
                    "",
                    "function parse(text, parsers, opts) {",
                    "  // Inline the require to avoid loading all the JS if we don't use it",
                    "  const flowParser = require(\"flow-parser\");",
                    "",
                    "  const ast = flowParser.parse(text, {",
                    "    enums: true,",
                    "    esproposal_decorators: true,",
                    "    esproposal_class_instance_fields: true,",
                    "    esproposal_class_static_fields: true,",
                    "    esproposal_export_star_as: true,",
                    "    esproposal_optional_chaining: true,",
                    "    esproposal_nullish_coalescing: true,",
                    "  });",
                    "",
                    "  if (ast.errors.length > 0) {",
                    "    const { loc } = ast.errors[0];",
                    "    throw createError(ast.errors[0].message, {",
                    "      start: { line: loc.start.line, column: loc.start.column + 1 },",
                    "      end: { line: loc.end.line, column: loc.end.column + 1 },",
                    "    });",
                    "  }",
                    "",
                    "  includeShebang(text, ast);",
                    "  return postprocess(ast, { ...opts, originalText: text });",
                    "}",
                    "",
                    "// Export as a plugin so we can reuse the same bundle for UMD loading",
                    "module.exports = {",
                    "  parsers: {",
                    "    flow: { parse, astFormat: \"estree\", hasPragma, ...locFns },",
                    "  },",
                    "};"
                ]
            },
            "parser-typescript.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const includeShebang = require(\"../common/parser-include-shebang\");",
                    "const { hasPragma } = require(\"./pragma\");",
                    "const locFns = require(\"./loc\");",
                    "const postprocess = require(\"./postprocess\");",
                    "",
                    "function parse(text, parsers, opts) {",
                    "  const jsx = isProbablyJsx(text);",
                    "  let ast;",
                    "  try {",
                    "    // Try passing with our best guess first.",
                    "    ast = tryParseTypeScript(text, jsx);",
                    "  } catch (firstError) {",
                    "    try {",
                    "      // But if we get it wrong, try the opposite.",
                    "      ast = tryParseTypeScript(text, !jsx);",
                    "    } catch (secondError) {",
                    "      // suppose our guess is correct",
                    "      const e = firstError;",
                    "",
                    "      if (typeof e.lineNumber === \"undefined\") {",
                    "        throw e;",
                    "      }",
                    "",
                    "      throw createError(e.message, {",
                    "        start: { line: e.lineNumber, column: e.column + 1 },",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  includeShebang(text, ast);",
                    "  return postprocess(ast, { ...opts, originalText: text });",
                    "}",
                    "",
                    "function tryParseTypeScript(text, jsx) {",
                    "  const parser = require(\"@typescript-eslint/typescript-estree\");",
                    "  return parser.parse(text, {",
                    "    loc: true,",
                    "    range: true,",
                    "    comment: true,",
                    "    useJSXTextNode: true,",
                    "    jsx,",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * Use a naive regular expression to detect JSX",
                    " */",
                    "function isProbablyJsx(text) {",
                    "  return new RegExp(",
                    "    [",
                    "      \"(^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string",
                    "      \"|\",",
                    "      \"(^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"",
                    "    ].join(\"\"),",
                    "    \"m\"",
                    "  ).test(text);",
                    "}",
                    "",
                    "const parser = { parse, astFormat: \"estree\", hasPragma, ...locFns };",
                    "",
                    "// Export as a plugin so we can reuse the same bundle for UMD loading",
                    "module.exports = {",
                    "  parsers: {",
                    "    typescript: parser,",
                    "  },",
                    "};"
                ]
            },
            "postprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getLast,",
                    "  getNextNonSpaceNonCommentCharacter,",
                    "} = require(\"../common/util\");",
                    "const { composeLoc, locEnd } = require(\"./loc\");",
                    "const { isTypeCastComment } = require(\"./comments\");",
                    "",
                    "function postprocess(ast, options) {",
                    "  // Keep Babel's non-standard ParenthesizedExpression nodes only if they have Closure-style type cast comments.",
                    "  if (options.parser !== \"typescript\" && options.parser !== \"flow\") {",
                    "    const startOffsetsOfTypeCastedNodes = new Set();",
                    "",
                    "    // Comments might be attached not directly to ParenthesizedExpression but to its ancestor.",
                    "    // E.g.: /** @type {Foo} */ (foo).bar();",
                    "    // Let's use the fact that those ancestors and ParenthesizedExpression have the same start offset.",
                    "",
                    "    visitNode(ast, (node) => {",
                    "      if (",
                    "        node.leadingComments &&",
                    "        node.leadingComments.some(isTypeCastComment)",
                    "      ) {",
                    "        startOffsetsOfTypeCastedNodes.add(node.start);",
                    "      }",
                    "    });",
                    "",
                    "    visitNode(ast, (node) => {",
                    "      if (",
                    "        node.type === \"ParenthesizedExpression\" &&",
                    "        !startOffsetsOfTypeCastedNodes.has(node.start)",
                    "      ) {",
                    "        const { expression } = node;",
                    "        if (!expression.extra) {",
                    "          expression.extra = {};",
                    "        }",
                    "        expression.extra.parenthesized = true;",
                    "        expression.extra.parenStart = node.start;",
                    "        return expression;",
                    "      }",
                    "    });",
                    "  }",
                    "",
                    "  visitNode(ast, (node) => {",
                    "    switch (node.type) {",
                    "      case \"LogicalExpression\": {",
                    "        // We remove unneeded parens around same-operator LogicalExpressions",
                    "        if (isUnbalancedLogicalTree(node)) {",
                    "          return rebalanceLogicalTree(node);",
                    "        }",
                    "        break;",
                    "      }",
                    "      // fix unexpected locEnd caused by --no-semi style",
                    "      case \"VariableDeclaration\": {",
                    "        const lastDeclaration = getLast(node.declarations);",
                    "        if (lastDeclaration && lastDeclaration.init) {",
                    "          overrideLocEnd(node, lastDeclaration);",
                    "        }",
                    "        break;",
                    "      }",
                    "      // remove redundant TypeScript nodes",
                    "      case \"TSParenthesizedType\": {",
                    "        return { ...node.typeAnnotation, ...composeLoc(node) };",
                    "      }",
                    "      case \"TSUnionType\":",
                    "      case \"TSIntersectionType\":",
                    "        if (node.types.length === 1) {",
                    "          // override loc, so that comments are attached properly",
                    "          return { ...node.types[0], ...composeLoc(node) };",
                    "        }",
                    "        break;",
                    "      case \"TSTypeParameter\":",
                    "        // babel-ts",
                    "        if (typeof node.name === \"string\") {",
                    "          node.name = {",
                    "            type: \"Identifier\",",
                    "            name: node.name,",
                    "            ...composeLoc(node, node.name.length),",
                    "          };",
                    "        }",
                    "        break;",
                    "      case \"SequenceExpression\":",
                    "        // Babel (unlike other parsers) includes spaces and comments in the range. Let's unify this.",
                    "        if (node.end && node.end > getLast(node.expressions).end) {",
                    "          node.end = getLast(node.expressions).end;",
                    "        }",
                    "        break;",
                    "      case \"ClassProperty\":",
                    "        // TODO: Temporary auto-generated node type. To remove when typescript-estree has proper support for private fields.",
                    "        if (",
                    "          node.key &&",
                    "          node.key.type === \"TSPrivateIdentifier\" &&",
                    "          getNextNonSpaceNonCommentCharacter(",
                    "            options.originalText,",
                    "            node.key,",
                    "            locEnd",
                    "          ) === \"?\"",
                    "        ) {",
                    "          node.optional = true;",
                    "        }",
                    "        break;",
                    "    }",
                    "  });",
                    "",
                    "  return ast;",
                    "",
                    "  /**",
                    "   * - `toOverrideNode` must be the last thing in `toBeOverriddenNode`",
                    "   * - do nothing if there's a semicolon on `toOverrideNode.end` (no need to fix)",
                    "   */",
                    "  function overrideLocEnd(toBeOverriddenNode, toOverrideNode) {",
                    "    if (options.originalText[locEnd(toOverrideNode)] === \";\") {",
                    "      return;",
                    "    }",
                    "    if (Array.isArray(toBeOverriddenNode.range)) {",
                    "      toBeOverriddenNode.range = [",
                    "        toBeOverriddenNode.range[0],",
                    "        toOverrideNode.range[1],",
                    "      ];",
                    "    } else {",
                    "      toBeOverriddenNode.end = toOverrideNode.end;",
                    "    }",
                    "    toBeOverriddenNode.loc = {",
                    "      ...toBeOverriddenNode.loc,",
                    "      end: toBeOverriddenNode.loc.end,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "function visitNode(node, fn, parent, property) {",
                    "  if (!node || typeof node !== \"object\") {",
                    "    return;",
                    "  }",
                    "",
                    "  if (Array.isArray(node)) {",
                    "    for (let i = 0; i < node.length; i++) {",
                    "      visitNode(node[i], fn, node, i);",
                    "    }",
                    "    return;",
                    "  }",
                    "",
                    "  if (typeof node.type !== \"string\") {",
                    "    return;",
                    "  }",
                    "",
                    "  for (const key of Object.keys(node)) {",
                    "    visitNode(node[key], fn, node, key);",
                    "  }",
                    "",
                    "  const replacement = fn(node);",
                    "",
                    "  if (replacement) {",
                    "    parent[property] = replacement;",
                    "  }",
                    "}",
                    "",
                    "function isUnbalancedLogicalTree(node) {",
                    "  return (",
                    "    node.type === \"LogicalExpression\" &&",
                    "    node.right.type === \"LogicalExpression\" &&",
                    "    node.operator === node.right.operator",
                    "  );",
                    "}",
                    "",
                    "function rebalanceLogicalTree(node) {",
                    "  if (!isUnbalancedLogicalTree(node)) {",
                    "    return node;",
                    "  }",
                    "",
                    "  return rebalanceLogicalTree({",
                    "    type: \"LogicalExpression\",",
                    "    operator: node.operator,",
                    "    left: rebalanceLogicalTree({",
                    "      type: \"LogicalExpression\",",
                    "      operator: node.operator,",
                    "      left: node.left,",
                    "      right: node.right.left,",
                    "      ...composeLoc(node.left, node.right.left),",
                    "    }),",
                    "    right: node.right.right,",
                    "    ...composeLoc(node),",
                    "  });",
                    "}",
                    "",
                    "module.exports = postprocess;"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const docblock = require(\"jest-docblock\");",
                    "const { getShebang } = require(\"../common/util\");",
                    "",
                    "function hasPragma(text) {",
                    "  const shebang = getShebang(text);",
                    "  if (shebang) {",
                    "    text = text.slice(shebang.length + 1);",
                    "  }",
                    "  const pragmas = Object.keys(docblock.parse(docblock.extract(text)));",
                    "  return pragmas.includes(\"prettier\") || pragmas.includes(\"format\");",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  const shebang = getShebang(text);",
                    "  if (shebang) {",
                    "    text = text.slice(shebang.length + 1);",
                    "  }",
                    "  const parsedDocblock = docblock.parseWithComments(docblock.extract(text));",
                    "  const pragmas = { format: \"\", ...parsedDocblock.pragmas };",
                    "  const newDocblock = docblock",
                    "    .print({",
                    "      pragmas,",
                    "      comments: parsedDocblock.comments.replace(/^(\\s+?\\r?\\n)+/, \"\"), // remove leading newlines",
                    "    })",
                    "    .replace(/(\\r\\n|\\r)/g, \"\\n\"); // normalise newlines (mitigate use of os.EOL by jest-docblock)",
                    "  const strippedText = docblock.strip(text);",
                    "  const separatingNewlines = strippedText.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\";",
                    "  return (",
                    "    (shebang ? `${shebang}\\n` : \"\") +",
                    "    newDocblock +",
                    "    separatingNewlines +",
                    "    strippedText",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function preprocess(ast, options) {",
                    "  switch (options.parser) {",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "    case \"__js_expression\":",
                    "    case \"__vue_expression\":",
                    "      return {",
                    "        ...ast,",
                    "        type: options.parser.startsWith(\"__\") ? \"JsExpressionRoot\" : \"JsonRoot\",",
                    "        node: ast,",
                    "        comments: [],",
                    "        rootMarker: options.rootMarker,",
                    "      };",
                    "    default:",
                    "      return ast;",
                    "  }",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-estree-json.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { concat, hardline, indent, join } = require(\"../document\").builders;",
                    "const preprocess = require(\"./preprocess\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "  switch (node.type) {",
                    "    case \"JsonRoot\":",
                    "      return concat([path.call(print, \"node\"), hardline]);",
                    "    case \"ArrayExpression\":",
                    "      return node.elements.length === 0",
                    "        ? \"[]\"",
                    "        : concat([",
                    "            \"[\",",
                    "            indent(",
                    "              concat([",
                    "                hardline,",
                    "                join(concat([\",\", hardline]), path.map(print, \"elements\")),",
                    "              ])",
                    "            ),",
                    "            hardline,",
                    "            \"]\",",
                    "          ]);",
                    "    case \"ObjectExpression\":",
                    "      return node.properties.length === 0",
                    "        ? \"{}\"",
                    "        : concat([",
                    "            \"{\",",
                    "            indent(",
                    "              concat([",
                    "                hardline,",
                    "                join(concat([\",\", hardline]), path.map(print, \"properties\")),",
                    "              ])",
                    "            ),",
                    "            hardline,",
                    "            \"}\",",
                    "          ]);",
                    "    case \"ObjectProperty\":",
                    "      return concat([path.call(print, \"key\"), \": \", path.call(print, \"value\")]);",
                    "    case \"UnaryExpression\":",
                    "      return concat([",
                    "        node.operator === \"+\" ? \"\" : node.operator,",
                    "        path.call(print, \"argument\"),",
                    "      ]);",
                    "    case \"NullLiteral\":",
                    "      return \"null\";",
                    "    case \"BooleanLiteral\":",
                    "      return node.value ? \"true\" : \"false\";",
                    "    case \"StringLiteral\":",
                    "    case \"NumericLiteral\":",
                    "      return JSON.stringify(node.value);",
                    "    case \"Identifier\":",
                    "      return JSON.stringify(node.name);",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown type: \" + JSON.stringify(node.type));",
                    "  }",
                    "}",
                    "",
                    "function clean(node, newNode /*, parent*/) {",
                    "  delete newNode.start;",
                    "  delete newNode.end;",
                    "  delete newNode.extra;",
                    "  delete newNode.loc;",
                    "  delete newNode.comments;",
                    "  delete newNode.errors;",
                    "",
                    "  if (node.type === \"Identifier\") {",
                    "    return { type: \"StringLiteral\", value: node.name };",
                    "  }",
                    "  if (node.type === \"UnaryExpression\" && node.operator === \"+\") {",
                    "    return newNode.argument;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "printer-estree.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "",
                    "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
                    "const comments = require(\"../main/comments\");",
                    "const {",
                    "  shouldFlatten,",
                    "  getNextNonSpaceNonCommentCharacter,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  getLast,",
                    "  getStringWidth,",
                    "  printString,",
                    "  printNumber,",
                    "  hasIgnoreComment,",
                    "  hasNodeIgnoreComment,",
                    "  startsWithNoLookaheadToken,",
                    "  getIndentSize,",
                    "  getPreferredQuote,",
                    "} = require(\"../common/util\");",
                    "const {",
                    "  isNextLineEmpty,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "} = require(\"../common/util-shared\");",
                    "const embed = require(\"./embed\");",
                    "const clean = require(\"./clean\");",
                    "const { insertPragma } = require(\"./pragma\");",
                    "const handleComments = require(\"./comments\");",
                    "const pathNeedsParens = require(\"./needs-parens\");",
                    "const {",
                    "  printHtmlBinding,",
                    "  isVueEventBindingExpression,",
                    "} = require(\"./html-binding\");",
                    "const preprocess = require(\"./preprocess\");",
                    "const {",
                    "  classChildNeedsASIProtection,",
                    "  classPropMayCauseASIProblems,",
                    "  conditionalExpressionChainContainsJSX,",
                    "  getFlowVariance,",
                    "  getLeftSidePathName,",
                    "  getParentExportDeclaration,",
                    "  getTypeScriptMappedTypeModifier,",
                    "  hasDanglingComments,",
                    "  hasFlowAnnotationComment,",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasLeadingOwnLineComment,",
                    "  hasNakedLeftSide,",
                    "  hasNewlineBetweenOrAfterDecorators,",
                    "  hasNgSideEffect,",
                    "  hasPrettierIgnore,",
                    "  hasTrailingComment,",
                    "  hasTrailingLineComment,",
                    "  identity,",
                    "  isBinaryish,",
                    "  isCallOrOptionalCallExpression,",
                    "  isEmptyJSXElement,",
                    "  isExportDeclaration,",
                    "  isFlowAnnotationComment,",
                    "  isFunctionNotation,",
                    "  isGetterOrSetter,",
                    "  isJestEachTemplateLiteral,",
                    "  isJSXNode,",
                    "  isJSXWhitespaceExpression,",
                    "  isLastStatement,",
                    "  isLiteral,",
                    "  isMeaningfulJSXText,",
                    "  isMemberExpressionChain,",
                    "  isMemberish,",
                    "  isNgForOf,",
                    "  isObjectType,",
                    "  isObjectTypePropertyAFunction,",
                    "  isSimpleFlowType,",
                    "  isSimpleTemplateLiteral,",
                    "  isStringLiteral,",
                    "  isStringPropSafeToCoerceToIdentifier,",
                    "  isTemplateOnItsOwnLine,",
                    "  isTestCall,",
                    "  isTheOnlyJSXElementInMarkdown,",
                    "  isTSXFile,",
                    "  isTypeAnnotationAFunction,",
                    "  matchJsxWhitespaceRegex,",
                    "  needsHardlineAfterDanglingComment,",
                    "  rawText,",
                    "  returnArgumentHasLeadingComment,",
                    "  shouldPrintComma,",
                    "} = require(\"./utils\");",
                    "",
                    "const printMemberChain = require(\"./print/member-chain\");",
                    "const printCallArguments = require(\"./print/call-arguments\");",
                    "const {",
                    "  printOptionalToken,",
                    "  printFunctionTypeParameters,",
                    "  printMemberLookup,",
                    "  printBindExpressionCallee,",
                    "} = require(\"./print/misc\");",
                    "const { printModuleSource, printModuleSpecifiers } = require(\"./print/module\");",
                    "",
                    "const needsQuoteProps = new WeakMap();",
                    "",
                    "const {",
                    "  builders: {",
                    "    concat,",
                    "    join,",
                    "    line,",
                    "    hardline,",
                    "    softline,",
                    "    literalline,",
                    "    group,",
                    "    indent,",
                    "    align,",
                    "    conditionalGroup,",
                    "    fill,",
                    "    ifBreak,",
                    "    lineSuffixBoundary,",
                    "    addAlignmentToDoc,",
                    "    dedent,",
                    "  },",
                    "  utils: { willBreak, isLineNext, isEmpty, removeLines, normalizeParts },",
                    "  printer: { printDocToString },",
                    "} = require(\"../document\");",
                    "",
                    "let uid = 0;",
                    "",
                    "function genericPrint(path, options, printPath, args) {",
                    "  const node = path.getValue();",
                    "  let needsParens = false;",
                    "  const linesWithoutParens = printPathNoParens(path, options, printPath, args);",
                    "",
                    "  if (!node || isEmpty(linesWithoutParens)) {",
                    "    return linesWithoutParens;",
                    "  }",
                    "",
                    "  const parentExportDecl = getParentExportDeclaration(path);",
                    "  const decorators = [];",
                    "  if (",
                    "    node.type === \"ClassMethod\" ||",
                    "    node.type === \"ClassPrivateMethod\" ||",
                    "    node.type === \"ClassProperty\" ||",
                    "    node.type === \"TSAbstractClassProperty\" ||",
                    "    node.type === \"ClassPrivateProperty\" ||",
                    "    node.type === \"MethodDefinition\" ||",
                    "    node.type === \"TSAbstractMethodDefinition\" ||",
                    "    node.type === \"TSDeclareMethod\"",
                    "  ) {",
                    "    // their decorators are handled themselves",
                    "  } else if (",
                    "    node.decorators &&",
                    "    node.decorators.length > 0 &&",
                    "    // If the parent node is an export declaration and the decorator",
                    "    // was written before the export, the export will be responsible",
                    "    // for printing the decorators.",
                    "    !(",
                    "      parentExportDecl &&",
                    "      options.locStart(parentExportDecl, { ignoreDecorators: true }) >",
                    "        options.locStart(node.decorators[0])",
                    "    )",
                    "  ) {",
                    "    const shouldBreak =",
                    "      node.type === \"ClassExpression\" ||",
                    "      node.type === \"ClassDeclaration\" ||",
                    "      hasNewlineBetweenOrAfterDecorators(node, options);",
                    "",
                    "    const separator = shouldBreak ? hardline : line;",
                    "",
                    "    path.each((decoratorPath) => {",
                    "      let decorator = decoratorPath.getValue();",
                    "      if (decorator.expression) {",
                    "        decorator = decorator.expression;",
                    "      } else {",
                    "        decorator = decorator.callee;",
                    "      }",
                    "",
                    "      decorators.push(printPath(decoratorPath), separator);",
                    "    }, \"decorators\");",
                    "",
                    "    if (parentExportDecl) {",
                    "      decorators.unshift(hardline);",
                    "    }",
                    "  } else if (",
                    "    isExportDeclaration(node) &&",
                    "    node.declaration &&",
                    "    node.declaration.decorators &&",
                    "    node.declaration.decorators.length > 0 &&",
                    "    // Only print decorators here if they were written before the export,",
                    "    // otherwise they are printed by the node.declaration",
                    "    options.locStart(node, { ignoreDecorators: true }) >",
                    "      options.locStart(node.declaration.decorators[0])",
                    "  ) {",
                    "    // Export declarations are responsible for printing any decorators",
                    "    // that logically apply to node.declaration.",
                    "    path.each(",
                    "      (decoratorPath) => {",
                    "        const decorator = decoratorPath.getValue();",
                    "        const prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";",
                    "        decorators.push(prefix, printPath(decoratorPath), hardline);",
                    "      },",
                    "      \"declaration\",",
                    "      \"decorators\"",
                    "    );",
                    "  } else {",
                    "    // Nodes with decorators can't have parentheses, so we can avoid",
                    "    // computing pathNeedsParens() except in this case.",
                    "    needsParens = pathNeedsParens(path, options);",
                    "  }",
                    "",
                    "  const parts = [];",
                    "  if (needsParens) {",
                    "    parts.unshift(\"(\");",
                    "  }",
                    "",
                    "  parts.push(linesWithoutParens);",
                    "",
                    "  if (needsParens) {",
                    "    const node = path.getValue();",
                    "    if (hasFlowShorthandAnnotationComment(node)) {",
                    "      parts.push(\" /*\");",
                    "      parts.push(node.trailingComments[0].value.trimStart());",
                    "      parts.push(\"*/\");",
                    "      node.trailingComments[0].printed = true;",
                    "    }",
                    "",
                    "    parts.push(\")\");",
                    "  }",
                    "",
                    "  if (decorators.length > 0) {",
                    "    return group(concat(decorators.concat(parts)));",
                    "  }",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printDecorators(path, options, print) {",
                    "  const node = path.getValue();",
                    "  return group(",
                    "    concat([",
                    "      join(line, path.map(print, \"decorators\")),",
                    "      hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line,",
                    "    ])",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * The following is the shared logic for",
                    " * ternary operators, namely ConditionalExpression",
                    " * and TSConditionalType",
                    " * @typedef {Object} OperatorOptions",
                    " * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.",
                    " * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.",
                    " * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.",
                    " * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".",
                    " * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".",
                    " * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".",
                    " * @property {string[]} testNodePropertyNames - The properties at which the test nodes can be found on the main node, eg \"test\".",
                    " * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.",
                    " * @param {Options} options - Prettier options",
                    " * @param {Function} print - Print function to call recursively",
                    " * @param {OperatorOptions} operatorOptions",
                    " * @returns Doc",
                    " */",
                    "function printTernaryOperator(path, options, print, operatorOptions) {",
                    "  const node = path.getValue();",
                    "  const consequentNode = node[operatorOptions.consequentNodePropertyName];",
                    "  const alternateNode = node[operatorOptions.alternateNodePropertyName];",
                    "  const parts = [];",
                    "",
                    "  // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".",
                    "  // See tests/jsx/conditional-expression.js for more info.",
                    "  let jsxMode = false;",
                    "  const parent = path.getParentNode();",
                    "  const isParentTest =",
                    "    parent.type === operatorOptions.conditionalNodeType &&",
                    "    operatorOptions.testNodePropertyNames.some((prop) => parent[prop] === node);",
                    "  let forceNoIndent =",
                    "    parent.type === operatorOptions.conditionalNodeType && !isParentTest;",
                    "",
                    "  // Find the outermost non-ConditionalExpression parent, and the outermost",
                    "  // ConditionalExpression parent. We'll use these to determine if we should",
                    "  // print in JSX mode.",
                    "  let currentParent;",
                    "  let previousParent;",
                    "  let i = 0;",
                    "  do {",
                    "    previousParent = currentParent || node;",
                    "    currentParent = path.getParentNode(i);",
                    "    i++;",
                    "  } while (",
                    "    currentParent &&",
                    "    currentParent.type === operatorOptions.conditionalNodeType &&",
                    "    operatorOptions.testNodePropertyNames.every(",
                    "      (prop) => currentParent[prop] !== previousParent",
                    "    )",
                    "  );",
                    "  const firstNonConditionalParent = currentParent || parent;",
                    "  const lastConditionalParent = previousParent;",
                    "",
                    "  if (",
                    "    operatorOptions.shouldCheckJsx &&",
                    "    (isJSXNode(node[operatorOptions.testNodePropertyNames[0]]) ||",
                    "      isJSXNode(consequentNode) ||",
                    "      isJSXNode(alternateNode) ||",
                    "      conditionalExpressionChainContainsJSX(lastConditionalParent))",
                    "  ) {",
                    "    jsxMode = true;",
                    "    forceNoIndent = true;",
                    "",
                    "    // Even though they don't need parens, we wrap (almost) everything in",
                    "    // parens when using ?: within JSX, because the parens are analogous to",
                    "    // curly braces in an if statement.",
                    "    const wrap = (doc) =>",
                    "      concat([",
                    "        ifBreak(\"(\", \"\"),",
                    "        indent(concat([softline, doc])),",
                    "        softline,",
                    "        ifBreak(\")\", \"\"),",
                    "      ]);",
                    "",
                    "    // The only things we don't wrap are:",
                    "    // * Nested conditional expressions in alternates",
                    "    // * null",
                    "    // * undefined",
                    "    const isNil = (node) =>",
                    "      node.type === \"NullLiteral\" ||",
                    "      (node.type === \"Literal\" && node.value === null) ||",
                    "      (node.type === \"Identifier\" && node.name === \"undefined\");",
                    "",
                    "    parts.push(",
                    "      \" ? \",",
                    "      isNil(consequentNode)",
                    "        ? path.call(print, operatorOptions.consequentNodePropertyName)",
                    "        : wrap(path.call(print, operatorOptions.consequentNodePropertyName)),",
                    "      \" : \",",
                    "      alternateNode.type === operatorOptions.conditionalNodeType ||",
                    "        isNil(alternateNode)",
                    "        ? path.call(print, operatorOptions.alternateNodePropertyName)",
                    "        : wrap(path.call(print, operatorOptions.alternateNodePropertyName))",
                    "    );",
                    "  } else {",
                    "    // normal mode",
                    "    const part = concat([",
                    "      line,",
                    "      \"? \",",
                    "      consequentNode.type === operatorOptions.conditionalNodeType",
                    "        ? ifBreak(\"\", \"(\")",
                    "        : \"\",",
                    "      align(2, path.call(print, operatorOptions.consequentNodePropertyName)),",
                    "      consequentNode.type === operatorOptions.conditionalNodeType",
                    "        ? ifBreak(\"\", \")\")",
                    "        : \"\",",
                    "      line,",
                    "      \": \",",
                    "      alternateNode.type === operatorOptions.conditionalNodeType",
                    "        ? path.call(print, operatorOptions.alternateNodePropertyName)",
                    "        : align(2, path.call(print, operatorOptions.alternateNodePropertyName)),",
                    "    ]);",
                    "    parts.push(",
                    "      parent.type !== operatorOptions.conditionalNodeType ||",
                    "        parent[operatorOptions.alternateNodePropertyName] === node ||",
                    "        isParentTest",
                    "        ? part",
                    "        : options.useTabs",
                    "        ? dedent(indent(part))",
                    "        : align(Math.max(0, options.tabWidth - 2), part)",
                    "    );",
                    "  }",
                    "",
                    "  // We want a whole chain of ConditionalExpressions to all",
                    "  // break if any of them break. That means we should only group around the",
                    "  // outer-most ConditionalExpression.",
                    "  const maybeGroup = (doc) =>",
                    "    parent === firstNonConditionalParent ? group(doc) : doc;",
                    "",
                    "  // Break the closing paren to keep the chain right after it:",
                    "  // (a",
                    "  //   ? b",
                    "  //   : c",
                    "  // ).call()",
                    "  const breakClosingParen =",
                    "    !jsxMode &&",
                    "    (parent.type === \"MemberExpression\" ||",
                    "      parent.type === \"OptionalMemberExpression\" ||",
                    "      (parent.type === \"NGPipeExpression\" && parent.left === node)) &&",
                    "    !parent.computed;",
                    "",
                    "  const result = maybeGroup(",
                    "    concat(",
                    "      [].concat(",
                    "        ((testDoc) =>",
                    "          /**",
                    "           *     a",
                    "           *       ? b",
                    "           *       : multiline",
                    "           *         test",
                    "           *         node",
                    "           *       ^^ align(2)",
                    "           *       ? d",
                    "           *       : e",
                    "           */",
                    "          parent.type === operatorOptions.conditionalNodeType &&",
                    "          parent[operatorOptions.alternateNodePropertyName] === node",
                    "            ? align(2, testDoc)",
                    "            : testDoc)(concat(operatorOptions.beforeParts())),",
                    "        forceNoIndent ? concat(parts) : indent(concat(parts)),",
                    "        operatorOptions.afterParts(breakClosingParen)",
                    "      )",
                    "    )",
                    "  );",
                    "",
                    "  return isParentTest",
                    "    ? group(concat([indent(concat([softline, result])), softline]))",
                    "    : result;",
                    "}",
                    "",
                    "function printPathNoParens(path, options, print, args) {",
                    "  const n = path.getValue();",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "",
                    "  if (!n) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof n === \"string\") {",
                    "    return n;",
                    "  }",
                    "",
                    "  const htmlBinding = printHtmlBinding(path, options, print);",
                    "  if (htmlBinding) {",
                    "    return htmlBinding;",
                    "  }",
                    "",
                    "  let parts = [];",
                    "  switch (n.type) {",
                    "    case \"JsExpressionRoot\":",
                    "      return path.call(print, \"node\");",
                    "    case \"JsonRoot\":",
                    "      return concat([path.call(print, \"node\"), hardline]);",
                    "    case \"File\":",
                    "      // Print @babel/parser's InterpreterDirective here so that",
                    "      // leading comments on the `Program` node get printed after the hashbang.",
                    "      if (n.program && n.program.interpreter) {",
                    "        parts.push(",
                    "          path.call(",
                    "            (programPath) => programPath.call(print, \"interpreter\"),",
                    "            \"program\"",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"program\"));",
                    "",
                    "      return concat(parts);",
                    "",
                    "    case \"Program\":",
                    "      // Babel 6",
                    "      if (n.directives) {",
                    "        path.each((childPath) => {",
                    "          parts.push(print(childPath), semi, hardline);",
                    "          if (",
                    "            isNextLineEmpty(",
                    "              options.originalText,",
                    "              childPath.getValue(),",
                    "              options.locEnd",
                    "            )",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }, \"directives\");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        path.call((bodyPath) => {",
                    "          return printStatementSequence(bodyPath, options, print);",
                    "        }, \"body\")",
                    "      );",
                    "",
                    "      parts.push(",
                    "        comments.printDanglingComments(path, options, /* sameIndent */ true)",
                    "      );",
                    "",
                    "      // Only force a trailing newline if there were any contents.",
                    "      if (",
                    "        !n.body.every(({ type }) => type === \"EmptyStatement\") ||",
                    "        n.comments",
                    "      ) {",
                    "        parts.push(hardline);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    // Babel extension.",
                    "    case \"EmptyStatement\":",
                    "      return \"\";",
                    "    case \"ExpressionStatement\":",
                    "      // Detect Flow and TypeScript directives",
                    "      if (n.directive) {",
                    "        return concat([nodeStr(n.expression, options, true), semi]);",
                    "      }",
                    "",
                    "      if (options.parser === \"__vue_event_binding\") {",
                    "        const parent = path.getParentNode();",
                    "        if (",
                    "          parent.type === \"Program\" &&",
                    "          parent.body.length === 1 &&",
                    "          parent.body[0] === n",
                    "        ) {",
                    "          return concat([",
                    "            path.call(print, \"expression\"),",
                    "            isVueEventBindingExpression(n.expression) ? \";\" : \"\",",
                    "          ]);",
                    "        }",
                    "      }",
                    "",
                    "      // Do not append semicolon after the only JSX element in a program",
                    "      return concat([",
                    "        path.call(print, \"expression\"),",
                    "        isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi,",
                    "      ]);",
                    "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
                    "    case \"ParenthesizedExpression\": {",
                    "      const shouldHug = !n.expression.comments;",
                    "      if (shouldHug) {",
                    "        return concat([\"(\", path.call(print, \"expression\"), \")\"]);",
                    "      }",
                    "      return group(",
                    "        concat([",
                    "          \"(\",",
                    "          indent(concat([softline, path.call(print, \"expression\")])),",
                    "          softline,",
                    "          \")\",",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"AssignmentExpression\":",
                    "      return printAssignment(",
                    "        n.left,",
                    "        path.call(print, \"left\"),",
                    "        concat([\" \", n.operator]),",
                    "        n.right,",
                    "        path.call(print, \"right\"),",
                    "        options",
                    "      );",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "    case \"NGPipeExpression\": {",
                    "      const parent = path.getParentNode();",
                    "      const parentParent = path.getParentNode(1);",
                    "      const isInsideParenthesis =",
                    "        n !== parent.body &&",
                    "        (parent.type === \"IfStatement\" ||",
                    "          parent.type === \"WhileStatement\" ||",
                    "          parent.type === \"SwitchStatement\" ||",
                    "          parent.type === \"DoWhileStatement\");",
                    "",
                    "      const parts = printBinaryishExpressions(",
                    "        path,",
                    "        print,",
                    "        options,",
                    "        /* isNested */ false,",
                    "        isInsideParenthesis",
                    "      );",
                    "",
                    "      //   if (",
                    "      //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft",
                    "      //   ) {",
                    "      //",
                    "      // looks super weird, we want to break the children if the parent breaks",
                    "      //",
                    "      //   if (",
                    "      //     this.hasPlugin(\"dynamicImports\") &&",
                    "      //     this.lookahead().type === tt.parenLeft",
                    "      //   ) {",
                    "      if (isInsideParenthesis) {",
                    "        return concat(parts);",
                    "      }",
                    "",
                    "      // Break between the parens in",
                    "      // unaries or in a member or specific call expression, i.e.",
                    "      //",
                    "      //   (",
                    "      //     a &&",
                    "      //     b &&",
                    "      //     c",
                    "      //   ).call()",
                    "      if (",
                    "        ((parent.type === \"CallExpression\" ||",
                    "          parent.type === \"OptionalCallExpression\") &&",
                    "          parent.callee === n) ||",
                    "        parent.type === \"UnaryExpression\" ||",
                    "        ((parent.type === \"MemberExpression\" ||",
                    "          parent.type === \"OptionalMemberExpression\") &&",
                    "          !parent.computed)",
                    "      ) {",
                    "        return group(",
                    "          concat([indent(concat([softline, concat(parts)])), softline])",
                    "        );",
                    "      }",
                    "",
                    "      // Avoid indenting sub-expressions in some cases where the first sub-expression is already",
                    "      // indented accordingly. We should indent sub-expressions where the first case isn't indented.",
                    "      const shouldNotIndent =",
                    "        parent.type === \"ReturnStatement\" ||",
                    "        parent.type === \"ThrowStatement\" ||",
                    "        (parent.type === \"JSXExpressionContainer\" &&",
                    "          parentParent.type === \"JSXAttribute\") ||",
                    "        (n.operator !== \"|\" && parent.type === \"JsExpressionRoot\") ||",
                    "        (n.type !== \"NGPipeExpression\" &&",
                    "          ((parent.type === \"NGRoot\" && options.parser === \"__ng_binding\") ||",
                    "            (parent.type === \"NGMicrosyntaxExpression\" &&",
                    "              parentParent.type === \"NGMicrosyntax\" &&",
                    "              parentParent.body.length === 1))) ||",
                    "        (n === parent.body && parent.type === \"ArrowFunctionExpression\") ||",
                    "        (n !== parent.body && parent.type === \"ForStatement\") ||",
                    "        (parent.type === \"ConditionalExpression\" &&",
                    "          parentParent.type !== \"ReturnStatement\" &&",
                    "          parentParent.type !== \"ThrowStatement\" &&",
                    "          parentParent.type !== \"CallExpression\" &&",
                    "          parentParent.type !== \"OptionalCallExpression\") ||",
                    "        parent.type === \"TemplateLiteral\";",
                    "",
                    "      const shouldIndentIfInlining =",
                    "        parent.type === \"AssignmentExpression\" ||",
                    "        parent.type === \"VariableDeclarator\" ||",
                    "        parent.type === \"ClassProperty\" ||",
                    "        parent.type === \"TSAbstractClassProperty\" ||",
                    "        parent.type === \"ClassPrivateProperty\" ||",
                    "        parent.type === \"ObjectProperty\" ||",
                    "        parent.type === \"Property\";",
                    "",
                    "      const samePrecedenceSubExpression =",
                    "        isBinaryish(n.left) && shouldFlatten(n.operator, n.left.operator);",
                    "",
                    "      if (",
                    "        shouldNotIndent ||",
                    "        (shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression) ||",
                    "        (!shouldInlineLogicalExpression(n) && shouldIndentIfInlining)",
                    "      ) {",
                    "        return group(concat(parts));",
                    "      }",
                    "",
                    "      if (parts.length === 0) {",
                    "        return \"\";",
                    "      }",
                    "",
                    "      // If the right part is a JSX node, we include it in a separate group to",
                    "      // prevent it breaking the whole chain, so we can print the expression like:",
                    "      //",
                    "      //   foo && bar && (",
                    "      //     <Foo>",
                    "      //       <Bar />",
                    "      //     </Foo>",
                    "      //   )",
                    "",
                    "      const hasJSX = isJSXNode(n.right);",
                    "      const firstGroupIndex = parts.findIndex((part) => part.type === \"group\");",
                    "      // Separate the leftmost expression, possibly with its leading comments.",
                    "      const headParts = parts.slice(",
                    "        0,",
                    "        firstGroupIndex === -1 ? 1 : firstGroupIndex + 1",
                    "      );",
                    "      const rest = concat(",
                    "        parts.slice(headParts.length, hasJSX ? -1 : undefined)",
                    "      );",
                    "",
                    "      const groupId = Symbol(\"logicalChain-\" + ++uid);",
                    "      const chain = group(",
                    "        concat([",
                    "          // Don't include the initial expression in the indentation",
                    "          // level. The first item is guaranteed to be the first",
                    "          // left-most expression.",
                    "          ...headParts,",
                    "          indent(rest),",
                    "        ]),",
                    "        { id: groupId }",
                    "      );",
                    "",
                    "      if (!hasJSX) {",
                    "        return chain;",
                    "      }",
                    "",
                    "      const jsxPart = getLast(parts);",
                    "      return group(",
                    "        concat([chain, ifBreak(indent(jsxPart), jsxPart, { groupId })])",
                    "      );",
                    "    }",
                    "    case \"AssignmentPattern\":",
                    "      return concat([",
                    "        path.call(print, \"left\"),",
                    "        \" = \",",
                    "        path.call(print, \"right\"),",
                    "      ]);",
                    "    case \"TSTypeAssertion\": {",
                    "      const shouldBreakAfterCast = !(",
                    "        n.expression.type === \"ArrayExpression\" ||",
                    "        n.expression.type === \"ObjectExpression\"",
                    "      );",
                    "",
                    "      const castGroup = group(",
                    "        concat([",
                    "          \"<\",",
                    "          indent(concat([softline, path.call(print, \"typeAnnotation\")])),",
                    "          softline,",
                    "          \">\",",
                    "        ])",
                    "      );",
                    "",
                    "      const exprContents = concat([",
                    "        ifBreak(\"(\"),",
                    "        indent(concat([softline, path.call(print, \"expression\")])),",
                    "        softline,",
                    "        ifBreak(\")\"),",
                    "      ]);",
                    "",
                    "      if (shouldBreakAfterCast) {",
                    "        return conditionalGroup([",
                    "          concat([castGroup, path.call(print, \"expression\")]),",
                    "          concat([castGroup, group(exprContents, { shouldBreak: true })]),",
                    "          concat([castGroup, path.call(print, \"expression\")]),",
                    "        ]);",
                    "      }",
                    "      return group(concat([castGroup, path.call(print, \"expression\")]));",
                    "    }",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"MemberExpression\": {",
                    "      const parent = path.getParentNode();",
                    "      let firstNonMemberParent;",
                    "      let i = 0;",
                    "      do {",
                    "        firstNonMemberParent = path.getParentNode(i);",
                    "        i++;",
                    "      } while (",
                    "        firstNonMemberParent &&",
                    "        (firstNonMemberParent.type === \"MemberExpression\" ||",
                    "          firstNonMemberParent.type === \"OptionalMemberExpression\" ||",
                    "          firstNonMemberParent.type === \"TSNonNullExpression\")",
                    "      );",
                    "",
                    "      const shouldInline =",
                    "        (firstNonMemberParent &&",
                    "          (firstNonMemberParent.type === \"NewExpression\" ||",
                    "            firstNonMemberParent.type === \"BindExpression\" ||",
                    "            (firstNonMemberParent.type === \"VariableDeclarator\" &&",
                    "              firstNonMemberParent.id.type !== \"Identifier\") ||",
                    "            (firstNonMemberParent.type === \"AssignmentExpression\" &&",
                    "              firstNonMemberParent.left.type !== \"Identifier\"))) ||",
                    "        n.computed ||",
                    "        (n.object.type === \"Identifier\" &&",
                    "          n.property.type === \"Identifier\" &&",
                    "          parent.type !== \"MemberExpression\" &&",
                    "          parent.type !== \"OptionalMemberExpression\");",
                    "",
                    "      return concat([",
                    "        path.call(print, \"object\"),",
                    "        shouldInline",
                    "          ? printMemberLookup(path, options, print)",
                    "          : group(",
                    "              indent(",
                    "                concat([softline, printMemberLookup(path, options, print)])",
                    "              )",
                    "            ),",
                    "      ]);",
                    "    }",
                    "    case \"MetaProperty\":",
                    "      return concat([",
                    "        path.call(print, \"meta\"),",
                    "        \".\",",
                    "        path.call(print, \"property\"),",
                    "      ]);",
                    "    case \"BindExpression\":",
                    "      if (n.object) {",
                    "        parts.push(path.call(print, \"object\"));",
                    "      }",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          indent(",
                    "            concat([softline, printBindExpressionCallee(path, options, print)])",
                    "          )",
                    "        )",
                    "      );",
                    "",
                    "      return concat(parts);",
                    "    case \"Identifier\": {",
                    "      return concat([",
                    "        n.name,",
                    "        printOptionalToken(path),",
                    "        printTypeAnnotation(path, options, print),",
                    "      ]);",
                    "    }",
                    "    case \"V8IntrinsicIdentifier\":",
                    "      return concat([\"%\", n.name]);",
                    "    case \"SpreadElement\":",
                    "    case \"SpreadElementPattern\":",
                    "    case \"SpreadProperty\":",
                    "    case \"SpreadPropertyPattern\":",
                    "    case \"RestElement\":",
                    "    case \"ObjectTypeSpreadProperty\":",
                    "      return concat([",
                    "        \"...\",",
                    "        path.call(print, \"argument\"),",
                    "        printTypeAnnotation(path, options, print),",
                    "      ]);",
                    "    case \"FunctionDeclaration\":",
                    "    case \"FunctionExpression\":",
                    "      parts.push(printFunctionDeclaration(path, print, options));",
                    "      if (!n.body) {",
                    "        parts.push(semi);",
                    "      }",
                    "      return concat(parts);",
                    "    case \"ArrowFunctionExpression\": {",
                    "      if (n.async) {",
                    "        parts.push(\"async \");",
                    "      }",
                    "",
                    "      if (shouldPrintParamsWithoutParens(path, options)) {",
                    "        parts.push(path.call(print, \"params\", 0));",
                    "      } else {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              printFunctionParams(",
                    "                path,",
                    "                print,",
                    "                options,",
                    "                /* expandLast */ args &&",
                    "                  (args.expandLastArg || args.expandFirstArg),",
                    "                /* printTypeParams */ true",
                    "              ),",
                    "              printReturnType(path, print, options),",
                    "            ])",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      const dangling = comments.printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameIndent */ true,",
                    "        (comment) => {",
                    "          const nextCharacter = getNextNonSpaceNonCommentCharacterIndex(",
                    "            options.originalText,",
                    "            comment,",
                    "            options.locEnd",
                    "          );",
                    "          return (",
                    "            options.originalText.slice(nextCharacter, nextCharacter + 2) ===",
                    "            \"=>\"",
                    "          );",
                    "        }",
                    "      );",
                    "      if (dangling) {",
                    "        parts.push(\" \", dangling);",
                    "      }",
                    "",
                    "      parts.push(\" =>\");",
                    "",
                    "      const body = path.call((bodyPath) => print(bodyPath, args), \"body\");",
                    "",
                    "      // We want to always keep these types of nodes on the same line",
                    "      // as the arrow.",
                    "      if (",
                    "        !hasLeadingOwnLineComment(options.originalText, n.body, options) &&",
                    "        (n.body.type === \"ArrayExpression\" ||",
                    "          n.body.type === \"ObjectExpression\" ||",
                    "          n.body.type === \"BlockStatement\" ||",
                    "          isJSXNode(n.body) ||",
                    "          isTemplateOnItsOwnLine(n.body, options.originalText, options) ||",
                    "          n.body.type === \"ArrowFunctionExpression\" ||",
                    "          n.body.type === \"DoExpression\")",
                    "      ) {",
                    "        return group(concat([concat(parts), \" \", body]));",
                    "      }",
                    "",
                    "      // We handle sequence expressions as the body of arrows specially,",
                    "      // so that the required parentheses end up on their own lines.",
                    "      if (n.body.type === \"SequenceExpression\") {",
                    "        return group(",
                    "          concat([",
                    "            concat(parts),",
                    "            group(",
                    "              concat([\" (\", indent(concat([softline, body])), softline, \")\"])",
                    "            ),",
                    "          ])",
                    "        );",
                    "      }",
                    "",
                    "      // if the arrow function is expanded as last argument, we are adding a",
                    "      // level of indentation and need to add a softline to align the closing )",
                    "      // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)",
                    "      // we should align the expression's closing } with the line with the opening {.",
                    "      const shouldAddSoftLine =",
                    "        ((args && args.expandLastArg) ||",
                    "          path.getParentNode().type === \"JSXExpressionContainer\") &&",
                    "        !(n.comments && n.comments.length);",
                    "",
                    "      const printTrailingComma =",
                    "        args && args.expandLastArg && shouldPrintComma(options, \"all\");",
                    "",
                    "      // In order to avoid confusion between",
                    "      // a => a ? a : a",
                    "      // a <= a ? a : a",
                    "      const shouldAddParens =",
                    "        n.body.type === \"ConditionalExpression\" &&",
                    "        !startsWithNoLookaheadToken(n.body, /* forbidFunctionAndClass */ false);",
                    "",
                    "      return group(",
                    "        concat([",
                    "          concat(parts),",
                    "          group(",
                    "            concat([",
                    "              indent(",
                    "                concat([",
                    "                  line,",
                    "                  shouldAddParens ? ifBreak(\"\", \"(\") : \"\",",
                    "                  body,",
                    "                  shouldAddParens ? ifBreak(\"\", \")\") : \"\",",
                    "                ])",
                    "              ),",
                    "              shouldAddSoftLine",
                    "                ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline])",
                    "                : \"\",",
                    "            ])",
                    "          ),",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"YieldExpression\":",
                    "      parts.push(\"yield\");",
                    "",
                    "      if (n.delegate) {",
                    "        parts.push(\"*\");",
                    "      }",
                    "      if (n.argument) {",
                    "        parts.push(\" \", path.call(print, \"argument\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"AwaitExpression\": {",
                    "      parts.push(\"await\");",
                    "      if (n.argument) {",
                    "        parts.push(\" \", path.call(print, \"argument\"));",
                    "      }",
                    "      const parent = path.getParentNode();",
                    "      if (",
                    "        ((parent.type === \"CallExpression\" ||",
                    "          parent.type === \"OptionalCallExpression\") &&",
                    "          parent.callee === n) ||",
                    "        ((parent.type === \"MemberExpression\" ||",
                    "          parent.type === \"OptionalMemberExpression\") &&",
                    "          parent.object === n)",
                    "      ) {",
                    "        return group(",
                    "          concat([indent(concat([softline, concat(parts)])), softline])",
                    "        );",
                    "      }",
                    "      return concat(parts);",
                    "    }",
                    "    case \"ImportSpecifier\":",
                    "      if (n.importKind) {",
                    "        parts.push(path.call(print, \"importKind\"), \" \");",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"imported\"));",
                    "",
                    "      if (n.local && n.local.name !== n.imported.name) {",
                    "        parts.push(\" as \", path.call(print, \"local\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"ExportSpecifier\":",
                    "      parts.push(path.call(print, \"local\"));",
                    "",
                    "      if (n.exported && n.exported.name !== n.local.name) {",
                    "        parts.push(\" as \", path.call(print, \"exported\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"ImportNamespaceSpecifier\":",
                    "      parts.push(\"* as \");",
                    "      parts.push(path.call(print, \"local\"));",
                    "      return concat(parts);",
                    "    case \"ImportDefaultSpecifier\":",
                    "      return path.call(print, \"local\");",
                    "    case \"TSExportAssignment\":",
                    "      return concat([\"export = \", path.call(print, \"expression\"), semi]);",
                    "    case \"ExportDefaultDeclaration\":",
                    "    case \"ExportNamedDeclaration\":",
                    "      return printExportDeclaration(path, options, print);",
                    "    case \"DeclareExportDeclaration\":",
                    "      return concat([\"declare \", printExportDeclaration(path, options, print)]);",
                    "    case \"ExportAllDeclaration\":",
                    "      parts.push(\"export\");",
                    "",
                    "      if (n.exportKind === \"type\") {",
                    "        parts.push(\" type\");",
                    "      }",
                    "",
                    "      parts.push(\" *\");",
                    "",
                    "      if (n.exported) {",
                    "        parts.push(\" as \", path.call(print, \"exported\"));",
                    "      }",
                    "",
                    "      parts.push(printModuleSource(path, options, print), semi);",
                    "",
                    "      return concat(parts);",
                    "",
                    "    case \"ExportNamespaceSpecifier\":",
                    "      return concat([\"* as \", path.call(print, \"exported\")]);",
                    "    case \"ExportDefaultSpecifier\":",
                    "      return path.call(print, \"exported\");",
                    "    case \"ImportDeclaration\": {",
                    "      parts.push(\"import\");",
                    "",
                    "      if (n.importKind && n.importKind !== \"value\") {",
                    "        parts.push(\" \", n.importKind);",
                    "      }",
                    "",
                    "      if (n.specifiers && n.specifiers.length > 0) {",
                    "        parts.push(printModuleSpecifiers(path, options, print));",
                    "        parts.push(printModuleSource(path, options, print));",
                    "      } else if (",
                    "        (n.importKind && n.importKind === \"type\") ||",
                    "        // import {} from 'x'",
                    "        /{\\s*}/.test(",
                    "          options.originalText.slice(",
                    "            options.locStart(n),",
                    "            options.locStart(n.source)",
                    "          )",
                    "        )",
                    "      ) {",
                    "        parts.push(\" {}\", printModuleSource(path, options, print));",
                    "      } else {",
                    "        parts.push(\" \", path.call(print, \"source\"));",
                    "      }",
                    "",
                    "      if (Array.isArray(n.attributes) && n.attributes.length !== 0) {",
                    "        parts.push(\" with \", concat(path.map(print, \"attributes\")));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"ImportAttribute\":",
                    "      return concat([path.call(print, \"key\"), \": \", path.call(print, \"value\")]);",
                    "    case \"Import\":",
                    "      return \"import\";",
                    "    case \"TSModuleBlock\":",
                    "    case \"BlockStatement\": {",
                    "      const naked = path.call((bodyPath) => {",
                    "        return printStatementSequence(bodyPath, options, print);",
                    "      }, \"body\");",
                    "",
                    "      const hasContent = n.body.find((node) => node.type !== \"EmptyStatement\");",
                    "      const hasDirectives = n.directives && n.directives.length > 0;",
                    "",
                    "      const parent = path.getParentNode();",
                    "      const parentParent = path.getParentNode(1);",
                    "      if (",
                    "        !hasContent &&",
                    "        !hasDirectives &&",
                    "        !hasDanglingComments(n) &&",
                    "        (parent.type === \"ArrowFunctionExpression\" ||",
                    "          parent.type === \"FunctionExpression\" ||",
                    "          parent.type === \"FunctionDeclaration\" ||",
                    "          parent.type === \"ObjectMethod\" ||",
                    "          parent.type === \"ClassMethod\" ||",
                    "          parent.type === \"ClassPrivateMethod\" ||",
                    "          parent.type === \"ForStatement\" ||",
                    "          parent.type === \"WhileStatement\" ||",
                    "          parent.type === \"DoWhileStatement\" ||",
                    "          parent.type === \"DoExpression\" ||",
                    "          (parent.type === \"CatchClause\" && !parentParent.finalizer) ||",
                    "          parent.type === \"TSModuleDeclaration\")",
                    "      ) {",
                    "        return \"{}\";",
                    "      }",
                    "",
                    "      parts.push(\"{\");",
                    "",
                    "      // Babel 6",
                    "      if (hasDirectives) {",
                    "        path.each((childPath) => {",
                    "          parts.push(indent(concat([hardline, print(childPath), semi])));",
                    "          if (",
                    "            isNextLineEmpty(",
                    "              options.originalText,",
                    "              childPath.getValue(),",
                    "              options.locEnd",
                    "            )",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }, \"directives\");",
                    "      }",
                    "",
                    "      if (hasContent) {",
                    "        parts.push(indent(concat([hardline, naked])));",
                    "      }",
                    "",
                    "      parts.push(comments.printDanglingComments(path, options));",
                    "      parts.push(hardline, \"}\");",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"ReturnStatement\":",
                    "      return concat([",
                    "        \"return\",",
                    "        printReturnAndThrowArgument(path, options, print),",
                    "      ]);",
                    "    case \"NewExpression\":",
                    "    case \"ImportExpression\":",
                    "    case \"OptionalCallExpression\":",
                    "    case \"CallExpression\": {",
                    "      const isNew = n.type === \"NewExpression\";",
                    "      const isDynamicImport = n.type === \"ImportExpression\";",
                    "",
                    "      const optional = printOptionalToken(path);",
                    "      const args = isDynamicImport ? [n.source] : n.arguments;",
                    "      if (",
                    "        // We want to keep CommonJS- and AMD-style require calls, and AMD-style",
                    "        // define calls, as a unit.",
                    "        // e.g. `define([\"some/lib\", (lib) => {`",
                    "        (!isDynamicImport &&",
                    "          !isNew &&",
                    "          n.callee.type === \"Identifier\" &&",
                    "          (n.callee.name === \"require\" || n.callee.name === \"define\")) ||",
                    "        // Template literals as single arguments",
                    "        (args.length === 1 &&",
                    "          isTemplateOnItsOwnLine(args[0], options.originalText, options)) ||",
                    "        // Keep test declarations on a single line",
                    "        // e.g. `it('long name', () => {`",
                    "        (!isNew && isTestCall(n, path.getParentNode()))",
                    "      ) {",
                    "        return concat([",
                    "          isNew ? \"new \" : \"\",",
                    "          path.call(print, \"callee\"),",
                    "          optional,",
                    "          printFunctionTypeParameters(path, options, print),",
                    "          concat([",
                    "            \"(\",",
                    "            isDynamicImport",
                    "              ? path.call(print, \"source\")",
                    "              : join(\", \", path.map(print, \"arguments\")),",
                    "            \")\",",
                    "          ]),",
                    "        ]);",
                    "      }",
                    "",
                    "      // Inline Flow annotation comments following Identifiers in Call nodes need to",
                    "      // stay with the Identifier. For example:",
                    "      //",
                    "      // foo /*:: <SomeGeneric> */(bar);",
                    "      //",
                    "      // Here, we ensure that such comments stay between the Identifier and the Callee.",
                    "      const isIdentifierWithFlowAnnotation =",
                    "        n.callee &&",
                    "        n.callee.type === \"Identifier\" &&",
                    "        hasFlowAnnotationComment(n.callee.trailingComments);",
                    "      if (isIdentifierWithFlowAnnotation) {",
                    "        n.callee.trailingComments[0].printed = true;",
                    "      }",
                    "",
                    "      // We detect calls on member lookups and possibly print them in a",
                    "      // special chain format. See `printMemberChain` for more info.",
                    "      if (",
                    "        !isDynamicImport &&",
                    "        !isNew &&",
                    "        isMemberish(n.callee) &&",
                    "        !path.call((path) => pathNeedsParens(path, options), \"callee\")",
                    "      ) {",
                    "        return printMemberChain(path, options, print);",
                    "      }",
                    "",
                    "      const contents = concat([",
                    "        isNew ? \"new \" : \"\",",
                    "        isDynamicImport ? \"import\" : path.call(print, \"callee\"),",
                    "        optional,",
                    "        isIdentifierWithFlowAnnotation",
                    "          ? `/*:: ${n.callee.trailingComments[0].value.slice(2).trim()} */`",
                    "          : \"\",",
                    "        printFunctionTypeParameters(path, options, print),",
                    "        printCallArguments(path, options, print),",
                    "      ]);",
                    "",
                    "      // We group here when the callee is itself a call expression.",
                    "      // See `isLongCurriedCallExpression` for more info.",
                    "      if (isDynamicImport || isCallOrOptionalCallExpression(n.callee)) {",
                    "        return group(contents);",
                    "      }",
                    "",
                    "      return contents;",
                    "    }",
                    "",
                    "    case \"ObjectTypeInternalSlot\":",
                    "      return concat([",
                    "        n.static ? \"static \" : \"\",",
                    "        \"[[\",",
                    "        path.call(print, \"id\"),",
                    "        \"]]\",",
                    "        printOptionalToken(path),",
                    "        n.method ? \"\" : \": \",",
                    "        path.call(print, \"value\"),",
                    "      ]);",
                    "",
                    "    case \"ObjectExpression\":",
                    "    case \"ObjectPattern\":",
                    "    case \"ObjectTypeAnnotation\":",
                    "    case \"TSInterfaceBody\":",
                    "    case \"TSTypeLiteral\":",
                    "    case \"RecordExpression\": {",
                    "      let propertiesField;",
                    "",
                    "      if (n.type === \"TSTypeLiteral\") {",
                    "        propertiesField = \"members\";",
                    "      } else if (n.type === \"TSInterfaceBody\") {",
                    "        propertiesField = \"body\";",
                    "      } else {",
                    "        propertiesField = \"properties\";",
                    "      }",
                    "",
                    "      const isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";",
                    "      const fields = [];",
                    "      if (isTypeAnnotation) {",
                    "        fields.push(\"indexers\", \"callProperties\", \"internalSlots\");",
                    "      }",
                    "      fields.push(propertiesField);",
                    "",
                    "      const firstProperty = fields",
                    "        .map((field) => n[field][0])",
                    "        .sort((a, b) => options.locStart(a) - options.locStart(b))[0];",
                    "",
                    "      const parent = path.getParentNode(0);",
                    "      const isFlowInterfaceLikeBody =",
                    "        isTypeAnnotation &&",
                    "        parent &&",
                    "        (parent.type === \"InterfaceDeclaration\" ||",
                    "          parent.type === \"DeclareInterface\" ||",
                    "          parent.type === \"DeclareClass\") &&",
                    "        path.getName() === \"body\";",
                    "      const shouldBreak =",
                    "        n.type === \"TSInterfaceBody\" ||",
                    "        isFlowInterfaceLikeBody ||",
                    "        (n.type === \"ObjectPattern\" &&",
                    "          parent.type !== \"FunctionDeclaration\" &&",
                    "          parent.type !== \"FunctionExpression\" &&",
                    "          parent.type !== \"ArrowFunctionExpression\" &&",
                    "          parent.type !== \"ObjectMethod\" &&",
                    "          parent.type !== \"ClassMethod\" &&",
                    "          parent.type !== \"ClassPrivateMethod\" &&",
                    "          parent.type !== \"AssignmentPattern\" &&",
                    "          parent.type !== \"CatchClause\" &&",
                    "          n.properties.some(",
                    "            (property) =>",
                    "              property.value &&",
                    "              (property.value.type === \"ObjectPattern\" ||",
                    "                property.value.type === \"ArrayPattern\")",
                    "          )) ||",
                    "        (n.type !== \"ObjectPattern\" &&",
                    "          firstProperty &&",
                    "          hasNewlineInRange(",
                    "            options.originalText,",
                    "            options.locStart(n),",
                    "            options.locStart(firstProperty)",
                    "          ));",
                    "",
                    "      const separator = isFlowInterfaceLikeBody",
                    "        ? \";\"",
                    "        : n.type === \"TSInterfaceBody\" || n.type === \"TSTypeLiteral\"",
                    "        ? ifBreak(semi, \";\")",
                    "        : \",\";",
                    "      const leftBrace =",
                    "        n.type === \"RecordExpression\" ? \"#{\" : n.exact ? \"{|\" : \"{\";",
                    "      const rightBrace = n.exact ? \"|}\" : \"}\";",
                    "",
                    "      // Unfortunately, things are grouped together in the ast can be",
                    "      // interleaved in the source code. So we need to reorder them before",
                    "      // printing them.",
                    "      const propsAndLoc = [];",
                    "      fields.forEach((field) => {",
                    "        path.each((childPath) => {",
                    "          const node = childPath.getValue();",
                    "          propsAndLoc.push({",
                    "            node,",
                    "            printed: print(childPath),",
                    "            loc: options.locStart(node),",
                    "          });",
                    "        }, field);",
                    "      });",
                    "",
                    "      let separatorParts = [];",
                    "      const props = propsAndLoc",
                    "        .sort((a, b) => a.loc - b.loc)",
                    "        .map((prop) => {",
                    "          const result = concat(separatorParts.concat(group(prop.printed)));",
                    "          separatorParts = [separator, line];",
                    "          if (",
                    "            (prop.node.type === \"TSPropertySignature\" ||",
                    "              prop.node.type === \"TSMethodSignature\" ||",
                    "              prop.node.type === \"TSConstructSignatureDeclaration\") &&",
                    "            hasNodeIgnoreComment(prop.node)",
                    "          ) {",
                    "            separatorParts.shift();",
                    "          }",
                    "          if (",
                    "            isNextLineEmpty(options.originalText, prop.node, options.locEnd)",
                    "          ) {",
                    "            separatorParts.push(hardline);",
                    "          }",
                    "          return result;",
                    "        });",
                    "",
                    "      if (n.inexact) {",
                    "        let printed;",
                    "        if (hasDanglingComments(n)) {",
                    "          const hasLineComments = !n.comments.every(",
                    "            handleComments.isBlockComment",
                    "          );",
                    "          const printedDanglingComments = comments.printDanglingComments(",
                    "            path,",
                    "            options,",
                    "            /* sameIndent */ true",
                    "          );",
                    "          printed = concat([",
                    "            printedDanglingComments,",
                    "            hasLineComments ||",
                    "            hasNewline(",
                    "              options.originalText,",
                    "              options.locEnd(n.comments[n.comments.length - 1])",
                    "            )",
                    "              ? hardline",
                    "              : line,",
                    "            \"...\",",
                    "          ]);",
                    "        } else {",
                    "          printed = \"...\";",
                    "        }",
                    "        props.push(concat(separatorParts.concat(printed)));",
                    "      }",
                    "",
                    "      const lastElem = getLast(n[propertiesField]);",
                    "",
                    "      const canHaveTrailingSeparator = !(",
                    "        n.inexact ||",
                    "        (lastElem && lastElem.type === \"RestElement\")",
                    "      );",
                    "",
                    "      let content;",
                    "      if (props.length === 0) {",
                    "        if (!hasDanglingComments(n)) {",
                    "          return concat([",
                    "            leftBrace,",
                    "            rightBrace,",
                    "            printTypeAnnotation(path, options, print),",
                    "          ]);",
                    "        }",
                    "",
                    "        content = group(",
                    "          concat([",
                    "            leftBrace,",
                    "            comments.printDanglingComments(path, options),",
                    "            softline,",
                    "            rightBrace,",
                    "            printOptionalToken(path),",
                    "            printTypeAnnotation(path, options, print),",
                    "          ])",
                    "        );",
                    "      } else {",
                    "        content = concat([",
                    "          leftBrace,",
                    "          indent(",
                    "            concat([options.bracketSpacing ? line : softline, concat(props)])",
                    "          ),",
                    "          ifBreak(",
                    "            canHaveTrailingSeparator &&",
                    "              (separator !== \",\" || shouldPrintComma(options))",
                    "              ? separator",
                    "              : \"\"",
                    "          ),",
                    "          concat([options.bracketSpacing ? line : softline, rightBrace]),",
                    "          printOptionalToken(path),",
                    "          printTypeAnnotation(path, options, print),",
                    "        ]);",
                    "      }",
                    "",
                    "      // If we inline the object as first argument of the parent, we don't want",
                    "      // to create another group so that the object breaks before the return",
                    "      // type",
                    "      if (",
                    "        path.match(",
                    "          (node) => node.type === \"ObjectPattern\" && !node.decorators,",
                    "          (node, name, number) =>",
                    "            shouldHugArguments(node) &&",
                    "            (name === \"params\" || name === \"parameters\") &&",
                    "            number === 0",
                    "        ) ||",
                    "        path.match(",
                    "          shouldHugType,",
                    "          (node, name) => name === \"typeAnnotation\",",
                    "          (node, name) => name === \"typeAnnotation\",",
                    "          (node, name, number) =>",
                    "            shouldHugArguments(node) &&",
                    "            (name === \"params\" || name === \"parameters\") &&",
                    "            number === 0",
                    "        )",
                    "      ) {",
                    "        return content;",
                    "      }",
                    "",
                    "      return group(content, { shouldBreak });",
                    "    }",
                    "    // Babel 6",
                    "    case \"ObjectProperty\": // Non-standard AST node type.",
                    "    case \"Property\":",
                    "      if (n.method || n.kind === \"get\" || n.kind === \"set\") {",
                    "        return printMethod(path, options, print);",
                    "      }",
                    "",
                    "      if (n.shorthand) {",
                    "        parts.push(path.call(print, \"value\"));",
                    "      } else {",
                    "        parts.push(",
                    "          printAssignment(",
                    "            n.key,",
                    "            printPropertyKey(path, options, print),",
                    "            \":\",",
                    "            n.value,",
                    "            path.call(print, \"value\"),",
                    "            options",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts); // Babel 6",
                    "    case \"ClassMethod\":",
                    "    case \"ClassPrivateMethod\":",
                    "    case \"MethodDefinition\":",
                    "    case \"TSAbstractMethodDefinition\":",
                    "    case \"TSDeclareMethod\":",
                    "      if (n.decorators && n.decorators.length !== 0) {",
                    "        parts.push(printDecorators(path, options, print));",
                    "      }",
                    "      if (n.accessibility) {",
                    "        parts.push(n.accessibility + \" \");",
                    "      }",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "      if (n.type === \"TSAbstractMethodDefinition\" || n.abstract) {",
                    "        parts.push(\"abstract \");",
                    "      }",
                    "",
                    "      parts.push(printMethod(path, options, print));",
                    "",
                    "      return concat(parts);",
                    "    case \"ObjectMethod\":",
                    "      return printMethod(path, options, print);",
                    "    case \"Decorator\":",
                    "      return concat([",
                    "        \"@\",",
                    "        path.call(print, \"expression\"),",
                    "        path.call(print, \"callee\"),",
                    "      ]);",
                    "    case \"ArrayExpression\":",
                    "    case \"ArrayPattern\":",
                    "    case \"TupleExpression\": {",
                    "      const openBracket = n.type === \"TupleExpression\" ? \"#[\" : \"[\";",
                    "      const closeBracket = \"]\";",
                    "      if (n.elements.length === 0) {",
                    "        if (!hasDanglingComments(n)) {",
                    "          parts.push(openBracket, closeBracket);",
                    "        } else {",
                    "          parts.push(",
                    "            group(",
                    "              concat([",
                    "                openBracket,",
                    "                comments.printDanglingComments(path, options),",
                    "                softline,",
                    "                closeBracket,",
                    "              ])",
                    "            )",
                    "          );",
                    "        }",
                    "      } else {",
                    "        const lastElem = getLast(n.elements);",
                    "        const canHaveTrailingComma = !(",
                    "          lastElem && lastElem.type === \"RestElement\"",
                    "        );",
                    "",
                    "        // JavaScript allows you to have empty elements in an array which",
                    "        // changes its length based on the number of commas. The algorithm",
                    "        // is that if the last argument is null, we need to force insert",
                    "        // a comma to ensure JavaScript recognizes it.",
                    "        //   [,].length === 1",
                    "        //   [1,].length === 1",
                    "        //   [1,,].length === 2",
                    "        //",
                    "        // Note that getLast returns null if the array is empty, but",
                    "        // we already check for an empty array just above so we are safe",
                    "        const needsForcedTrailingComma =",
                    "          canHaveTrailingComma && lastElem === null;",
                    "",
                    "        const shouldBreak =",
                    "          n.elements.length > 1 &&",
                    "          n.elements.every((element, i, elements) => {",
                    "            const elementType = element && element.type;",
                    "            if (",
                    "              elementType !== \"ArrayExpression\" &&",
                    "              elementType !== \"ObjectExpression\"",
                    "            ) {",
                    "              return false;",
                    "            }",
                    "",
                    "            const nextElement = elements[i + 1];",
                    "            if (nextElement && elementType !== nextElement.type) {",
                    "              return false;",
                    "            }",
                    "",
                    "            const itemsKey =",
                    "              elementType === \"ArrayExpression\" ? \"elements\" : \"properties\";",
                    "",
                    "            return element[itemsKey] && element[itemsKey].length > 1;",
                    "          });",
                    "",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              openBracket,",
                    "              indent(",
                    "                concat([",
                    "                  softline,",
                    "                  printArrayItems(path, options, \"elements\", print),",
                    "                ])",
                    "              ),",
                    "              needsForcedTrailingComma ? \",\" : \"\",",
                    "              ifBreak(",
                    "                canHaveTrailingComma &&",
                    "                  !needsForcedTrailingComma &&",
                    "                  shouldPrintComma(options)",
                    "                  ? \",\"",
                    "                  : \"\"",
                    "              ),",
                    "              comments.printDanglingComments(",
                    "                path,",
                    "                options,",
                    "                /* sameIndent */ true",
                    "              ),",
                    "              softline,",
                    "              closeBracket,",
                    "            ]),",
                    "            { shouldBreak }",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(",
                    "        printOptionalToken(path),",
                    "        printTypeAnnotation(path, options, print)",
                    "      );",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"SequenceExpression\": {",
                    "      const parent = path.getParentNode(0);",
                    "      if (",
                    "        parent.type === \"ExpressionStatement\" ||",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        // For ExpressionStatements and for-loop heads, which are among",
                    "        // the few places a SequenceExpression appears unparenthesized, we want",
                    "        // to indent expressions after the first.",
                    "        const parts = [];",
                    "        path.each((p) => {",
                    "          if (p.getName() === 0) {",
                    "            parts.push(print(p));",
                    "          } else {",
                    "            parts.push(\",\", indent(concat([line, print(p)])));",
                    "          }",
                    "        }, \"expressions\");",
                    "        return group(concat(parts));",
                    "      }",
                    "      return group(",
                    "        concat([join(concat([\",\", line]), path.map(print, \"expressions\"))])",
                    "      );",
                    "    }",
                    "    case \"ThisExpression\":",
                    "      return \"this\";",
                    "    case \"Super\":",
                    "      return \"super\";",
                    "    case \"NullLiteral\": // Babel 6 Literal split",
                    "      return \"null\";",
                    "    case \"RegExpLiteral\": // Babel 6 Literal split",
                    "      return printRegex(n);",
                    "    case \"NumericLiteral\": // Babel 6 Literal split",
                    "      return printNumber(n.extra.raw);",
                    "    case \"BigIntLiteral\":",
                    "      // babel: n.extra.raw, flow: n.bigint",
                    "      return (n.bigint || n.extra.raw).toLowerCase();",
                    "    case \"BooleanLiteral\": // Babel 6 Literal split",
                    "    case \"StringLiteral\": // Babel 6 Literal split",
                    "    case \"Literal\":",
                    "      if (n.regex) {",
                    "        return printRegex(n.regex);",
                    "      }",
                    "      // typescript",
                    "      if (n.bigint) {",
                    "        return n.raw.toLowerCase();",
                    "      }",
                    "      if (typeof n.value === \"number\") {",
                    "        return printNumber(n.raw);",
                    "      }",
                    "      if (typeof n.value !== \"string\") {",
                    "        return \"\" + n.value;",
                    "      }",
                    "      return nodeStr(n, options);",
                    "    case \"Directive\":",
                    "      return path.call(print, \"value\"); // Babel 6",
                    "    case \"DirectiveLiteral\":",
                    "      return nodeStr(n, options);",
                    "    case \"UnaryExpression\":",
                    "      parts.push(n.operator);",
                    "",
                    "      if (/[a-z]$/.test(n.operator)) {",
                    "        parts.push(\" \");",
                    "      }",
                    "",
                    "      if (n.argument.comments && n.argument.comments.length > 0) {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              \"(\",",
                    "              indent(concat([softline, path.call(print, \"argument\")])),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          )",
                    "        );",
                    "      } else {",
                    "        parts.push(path.call(print, \"argument\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"UpdateExpression\":",
                    "      parts.push(path.call(print, \"argument\"), n.operator);",
                    "",
                    "      if (n.prefix) {",
                    "        parts.reverse();",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"ConditionalExpression\":",
                    "      return printTernaryOperator(path, options, print, {",
                    "        beforeParts: () => [path.call(print, \"test\")],",
                    "        afterParts: (breakClosingParen) => [breakClosingParen ? softline : \"\"],",
                    "        shouldCheckJsx: true,",
                    "        conditionalNodeType: \"ConditionalExpression\",",
                    "        consequentNodePropertyName: \"consequent\",",
                    "        alternateNodePropertyName: \"alternate\",",
                    "        testNodePropertyNames: [\"test\"],",
                    "      });",
                    "    case \"VariableDeclaration\": {",
                    "      const printed = path.map((childPath) => {",
                    "        return print(childPath);",
                    "      }, \"declarations\");",
                    "",
                    "      // We generally want to terminate all variable declarations with a",
                    "      // semicolon, except when they in the () part of for loops.",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      const isParentForLoop =",
                    "        parentNode.type === \"ForStatement\" ||",
                    "        parentNode.type === \"ForInStatement\" ||",
                    "        parentNode.type === \"ForOfStatement\";",
                    "",
                    "      const hasValue = n.declarations.some((decl) => decl.init);",
                    "",
                    "      let firstVariable;",
                    "      if (printed.length === 1 && !n.declarations[0].comments) {",
                    "        firstVariable = printed[0];",
                    "      } else if (printed.length > 0) {",
                    "        // Indent first var to comply with eslint one-var rule",
                    "        firstVariable = indent(printed[0]);",
                    "      }",
                    "",
                    "      parts = [",
                    "        n.declare ? \"declare \" : \"\",",
                    "        n.kind,",
                    "        firstVariable ? concat([\" \", firstVariable]) : \"\",",
                    "        indent(",
                    "          concat(",
                    "            printed",
                    "              .slice(1)",
                    "              .map((p) =>",
                    "                concat([\",\", hasValue && !isParentForLoop ? hardline : line, p])",
                    "              )",
                    "          )",
                    "        ),",
                    "      ];",
                    "",
                    "      if (!(isParentForLoop && parentNode.body !== n)) {",
                    "        parts.push(semi);",
                    "      }",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"TSTypeAliasDeclaration\": {",
                    "      if (n.declare) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "",
                    "      const printed = printAssignmentRight(",
                    "        n.id,",
                    "        n.typeAnnotation,",
                    "        n.typeAnnotation && path.call(print, \"typeAnnotation\"),",
                    "        options",
                    "      );",
                    "",
                    "      parts.push(",
                    "        \"type \",",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\"),",
                    "        \" =\",",
                    "        printed,",
                    "        semi",
                    "      );",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"VariableDeclarator\":",
                    "      return printAssignment(",
                    "        n.id,",
                    "        path.call(print, \"id\"),",
                    "        \" =\",",
                    "        n.init,",
                    "        n.init && path.call(print, \"init\"),",
                    "        options",
                    "      );",
                    "    case \"WithStatement\":",
                    "      return group(",
                    "        concat([",
                    "          \"with (\",",
                    "          path.call(print, \"object\"),",
                    "          \")\",",
                    "          adjustClause(n.body, path.call(print, \"body\")),",
                    "        ])",
                    "      );",
                    "    case \"IfStatement\": {",
                    "      const con = adjustClause(n.consequent, path.call(print, \"consequent\"));",
                    "      const opening = group(",
                    "        concat([",
                    "          \"if (\",",
                    "          group(",
                    "            concat([",
                    "              indent(concat([softline, path.call(print, \"test\")])),",
                    "              softline,",
                    "            ])",
                    "          ),",
                    "          \")\",",
                    "          con,",
                    "        ])",
                    "      );",
                    "",
                    "      parts.push(opening);",
                    "",
                    "      if (n.alternate) {",
                    "        const commentOnOwnLine =",
                    "          (hasTrailingComment(n.consequent) &&",
                    "            n.consequent.comments.some(",
                    "              (comment) =>",
                    "                comment.trailing && !handleComments.isBlockComment(comment)",
                    "            )) ||",
                    "          needsHardlineAfterDanglingComment(n);",
                    "        const elseOnSameLine =",
                    "          n.consequent.type === \"BlockStatement\" && !commentOnOwnLine;",
                    "        parts.push(elseOnSameLine ? \" \" : hardline);",
                    "",
                    "        if (hasDanglingComments(n)) {",
                    "          parts.push(",
                    "            comments.printDanglingComments(path, options, true),",
                    "            commentOnOwnLine ? hardline : \" \"",
                    "          );",
                    "        }",
                    "",
                    "        parts.push(",
                    "          \"else\",",
                    "          group(",
                    "            adjustClause(",
                    "              n.alternate,",
                    "              path.call(print, \"alternate\"),",
                    "              n.alternate.type === \"IfStatement\"",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"ForStatement\": {",
                    "      const body = adjustClause(n.body, path.call(print, \"body\"));",
                    "",
                    "      // We want to keep dangling comments above the loop to stay consistent.",
                    "      // Any comment positioned between the for statement and the parentheses",
                    "      // is going to be printed before the statement.",
                    "      const dangling = comments.printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameLine */ true",
                    "      );",
                    "      const printedComments = dangling ? concat([dangling, softline]) : \"\";",
                    "",
                    "      if (!n.init && !n.test && !n.update) {",
                    "        return concat([printedComments, group(concat([\"for (;;)\", body]))]);",
                    "      }",
                    "",
                    "      return concat([",
                    "        printedComments,",
                    "        group(",
                    "          concat([",
                    "            \"for (\",",
                    "            group(",
                    "              concat([",
                    "                indent(",
                    "                  concat([",
                    "                    softline,",
                    "                    path.call(print, \"init\"),",
                    "                    \";\",",
                    "                    line,",
                    "                    path.call(print, \"test\"),",
                    "                    \";\",",
                    "                    line,",
                    "                    path.call(print, \"update\"),",
                    "                  ])",
                    "                ),",
                    "                softline,",
                    "              ])",
                    "            ),",
                    "            \")\",",
                    "            body,",
                    "          ])",
                    "        ),",
                    "      ]);",
                    "    }",
                    "    case \"WhileStatement\":",
                    "      return group(",
                    "        concat([",
                    "          \"while (\",",
                    "          group(",
                    "            concat([",
                    "              indent(concat([softline, path.call(print, \"test\")])),",
                    "              softline,",
                    "            ])",
                    "          ),",
                    "          \")\",",
                    "          adjustClause(n.body, path.call(print, \"body\")),",
                    "        ])",
                    "      );",
                    "    case \"ForInStatement\":",
                    "      // Note: esprima can't actually parse \"for each (\".",
                    "      return group(",
                    "        concat([",
                    "          n.each ? \"for each (\" : \"for (\",",
                    "          path.call(print, \"left\"),",
                    "          \" in \",",
                    "          path.call(print, \"right\"),",
                    "          \")\",",
                    "          adjustClause(n.body, path.call(print, \"body\")),",
                    "        ])",
                    "      );",
                    "",
                    "    case \"ForOfStatement\":",
                    "      return group(",
                    "        concat([",
                    "          \"for\",",
                    "          n.await ? \" await\" : \"\",",
                    "          \" (\",",
                    "          path.call(print, \"left\"),",
                    "          \" of \",",
                    "          path.call(print, \"right\"),",
                    "          \")\",",
                    "          adjustClause(n.body, path.call(print, \"body\")),",
                    "        ])",
                    "      );",
                    "",
                    "    case \"DoWhileStatement\": {",
                    "      const clause = adjustClause(n.body, path.call(print, \"body\"));",
                    "      const doBody = group(concat([\"do\", clause]));",
                    "      parts = [doBody];",
                    "",
                    "      if (n.body.type === \"BlockStatement\") {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(hardline);",
                    "      }",
                    "      parts.push(\"while (\");",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          concat([",
                    "            indent(concat([softline, path.call(print, \"test\")])),",
                    "            softline,",
                    "          ])",
                    "        ),",
                    "        \")\",",
                    "        semi",
                    "      );",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"DoExpression\":",
                    "      return concat([\"do \", path.call(print, \"body\")]);",
                    "    case \"BreakStatement\":",
                    "      parts.push(\"break\");",
                    "",
                    "      if (n.label) {",
                    "        parts.push(\" \", path.call(print, \"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return concat(parts);",
                    "    case \"ContinueStatement\":",
                    "      parts.push(\"continue\");",
                    "",
                    "      if (n.label) {",
                    "        parts.push(\" \", path.call(print, \"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return concat(parts);",
                    "    case \"LabeledStatement\":",
                    "      if (n.body.type === \"EmptyStatement\") {",
                    "        return concat([path.call(print, \"label\"), \":;\"]);",
                    "      }",
                    "",
                    "      return concat([",
                    "        path.call(print, \"label\"),",
                    "        \": \",",
                    "        path.call(print, \"body\"),",
                    "      ]);",
                    "    case \"TryStatement\":",
                    "      return concat([",
                    "        \"try \",",
                    "        path.call(print, \"block\"),",
                    "        n.handler ? concat([\" \", path.call(print, \"handler\")]) : \"\",",
                    "        n.finalizer ? concat([\" finally \", path.call(print, \"finalizer\")]) : \"\",",
                    "      ]);",
                    "    case \"CatchClause\":",
                    "      if (n.param) {",
                    "        const hasComments =",
                    "          n.param.comments &&",
                    "          n.param.comments.some(",
                    "            (comment) =>",
                    "              !handleComments.isBlockComment(comment) ||",
                    "              (comment.leading &&",
                    "                hasNewline(options.originalText, options.locEnd(comment))) ||",
                    "              (comment.trailing &&",
                    "                hasNewline(options.originalText, options.locStart(comment), {",
                    "                  backwards: true,",
                    "                }))",
                    "          );",
                    "        const param = path.call(print, \"param\");",
                    "",
                    "        return concat([",
                    "          \"catch \",",
                    "          hasComments",
                    "            ? concat([\"(\", indent(concat([softline, param])), softline, \") \"])",
                    "            : concat([\"(\", param, \") \"]),",
                    "          path.call(print, \"body\"),",
                    "        ]);",
                    "      }",
                    "",
                    "      return concat([\"catch \", path.call(print, \"body\")]);",
                    "    case \"ThrowStatement\":",
                    "      return concat([",
                    "        \"throw\",",
                    "        printReturnAndThrowArgument(path, options, print),",
                    "      ]);",
                    "    // Note: ignoring n.lexical because it has no printing consequences.",
                    "    case \"SwitchStatement\":",
                    "      return concat([",
                    "        group(",
                    "          concat([",
                    "            \"switch (\",",
                    "            indent(concat([softline, path.call(print, \"discriminant\")])),",
                    "            softline,",
                    "            \")\",",
                    "          ])",
                    "        ),",
                    "        \" {\",",
                    "        n.cases.length > 0",
                    "          ? indent(",
                    "              concat([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  path.map((casePath) => {",
                    "                    const caseNode = casePath.getValue();",
                    "                    return concat([",
                    "                      casePath.call(print),",
                    "                      n.cases.indexOf(caseNode) !== n.cases.length - 1 &&",
                    "                      isNextLineEmpty(",
                    "                        options.originalText,",
                    "                        caseNode,",
                    "                        options.locEnd",
                    "                      )",
                    "                        ? hardline",
                    "                        : \"\",",
                    "                    ]);",
                    "                  }, \"cases\")",
                    "                ),",
                    "              ])",
                    "            )",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ]);",
                    "    case \"SwitchCase\": {",
                    "      if (n.test) {",
                    "        parts.push(\"case \", path.call(print, \"test\"), \":\");",
                    "      } else {",
                    "        parts.push(\"default:\");",
                    "      }",
                    "",
                    "      const consequent = n.consequent.filter(",
                    "        (node) => node.type !== \"EmptyStatement\"",
                    "      );",
                    "",
                    "      if (consequent.length > 0) {",
                    "        const cons = path.call((consequentPath) => {",
                    "          return printStatementSequence(consequentPath, options, print);",
                    "        }, \"consequent\");",
                    "",
                    "        parts.push(",
                    "          consequent.length === 1 && consequent[0].type === \"BlockStatement\"",
                    "            ? concat([\" \", cons])",
                    "            : indent(concat([hardline, cons]))",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    // JSX extensions below.",
                    "    case \"DebuggerStatement\":",
                    "      return concat([\"debugger\", semi]);",
                    "    case \"JSXAttribute\":",
                    "      parts.push(path.call(print, \"name\"));",
                    "",
                    "      if (n.value) {",
                    "        let res;",
                    "        if (isStringLiteral(n.value)) {",
                    "          const raw = rawText(n.value);",
                    "          // Unescape all quotes so we get an accurate preferred quote",
                    "          let final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');",
                    "          const quote = getPreferredQuote(",
                    "            final,",
                    "            options.jsxSingleQuote ? \"'\" : '\"'",
                    "          );",
                    "          const escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";",
                    "          final = final.slice(1, -1).replace(new RegExp(quote, \"g\"), escape);",
                    "          res = concat([quote, final, quote]);",
                    "        } else {",
                    "          res = path.call(print, \"value\");",
                    "        }",
                    "        parts.push(\"=\", res);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"JSXIdentifier\":",
                    "      return \"\" + n.name;",
                    "    case \"JSXNamespacedName\":",
                    "      return join(\":\", [",
                    "        path.call(print, \"namespace\"),",
                    "        path.call(print, \"name\"),",
                    "      ]);",
                    "    case \"JSXMemberExpression\":",
                    "      return join(\".\", [",
                    "        path.call(print, \"object\"),",
                    "        path.call(print, \"property\"),",
                    "      ]);",
                    "    case \"TSQualifiedName\":",
                    "      return join(\".\", [path.call(print, \"left\"), path.call(print, \"right\")]);",
                    "    case \"JSXSpreadAttribute\":",
                    "    case \"JSXSpreadChild\": {",
                    "      return concat([",
                    "        \"{\",",
                    "        path.call(",
                    "          (p) => {",
                    "            const printed = concat([\"...\", print(p)]);",
                    "            const n = p.getValue();",
                    "            if (!n.comments || !n.comments.length) {",
                    "              return printed;",
                    "            }",
                    "            return concat([",
                    "              indent(",
                    "                concat([",
                    "                  softline,",
                    "                  comments.printComments(p, () => printed, options),",
                    "                ])",
                    "              ),",
                    "              softline,",
                    "            ]);",
                    "          },",
                    "          n.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"",
                    "        ),",
                    "        \"}\",",
                    "      ]);",
                    "    }",
                    "    case \"JSXExpressionContainer\": {",
                    "      const parent = path.getParentNode(0);",
                    "",
                    "      const hasComments =",
                    "        n.expression.comments && n.expression.comments.length > 0;",
                    "",
                    "      const shouldInline =",
                    "        n.expression.type === \"JSXEmptyExpression\" ||",
                    "        (!hasComments &&",
                    "          (n.expression.type === \"ArrayExpression\" ||",
                    "            n.expression.type === \"ObjectExpression\" ||",
                    "            n.expression.type === \"ArrowFunctionExpression\" ||",
                    "            n.expression.type === \"CallExpression\" ||",
                    "            n.expression.type === \"OptionalCallExpression\" ||",
                    "            n.expression.type === \"FunctionExpression\" ||",
                    "            n.expression.type === \"TemplateLiteral\" ||",
                    "            n.expression.type === \"TaggedTemplateExpression\" ||",
                    "            n.expression.type === \"DoExpression\" ||",
                    "            (isJSXNode(parent) &&",
                    "              (n.expression.type === \"ConditionalExpression\" ||",
                    "                isBinaryish(n.expression)))));",
                    "",
                    "      if (shouldInline) {",
                    "        return group(",
                    "          concat([\"{\", path.call(print, \"expression\"), lineSuffixBoundary, \"}\"])",
                    "        );",
                    "      }",
                    "",
                    "      return group(",
                    "        concat([",
                    "          \"{\",",
                    "          indent(concat([softline, path.call(print, \"expression\")])),",
                    "          softline,",
                    "          lineSuffixBoundary,",
                    "          \"}\",",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"JSXFragment\":",
                    "    case \"JSXElement\": {",
                    "      const elem = comments.printComments(",
                    "        path,",
                    "        () => printJSXElement(path, options, print),",
                    "        options",
                    "      );",
                    "      return maybeWrapJSXElementInParens(path, elem, options);",
                    "    }",
                    "    case \"JSXOpeningElement\": {",
                    "      const n = path.getValue();",
                    "",
                    "      const nameHasComments =",
                    "        (n.name && n.name.comments && n.name.comments.length > 0) ||",
                    "        (n.typeParameters &&",
                    "          n.typeParameters.comments &&",
                    "          n.typeParameters.comments.length > 0);",
                    "",
                    "      // Don't break self-closing elements with no attributes and no comments",
                    "      if (n.selfClosing && !n.attributes.length && !nameHasComments) {",
                    "        return concat([",
                    "          \"<\",",
                    "          path.call(print, \"name\"),",
                    "          path.call(print, \"typeParameters\"),",
                    "          \" />\",",
                    "        ]);",
                    "      }",
                    "",
                    "      // don't break up opening elements with a single long text attribute",
                    "      if (",
                    "        n.attributes &&",
                    "        n.attributes.length === 1 &&",
                    "        n.attributes[0].value &&",
                    "        isStringLiteral(n.attributes[0].value) &&",
                    "        !n.attributes[0].value.value.includes(\"\\n\") &&",
                    "        // We should break for the following cases:",
                    "        // <div",
                    "        //   // comment",
                    "        //   attr=\"value\"",
                    "        // >",
                    "        // <div",
                    "        //   attr=\"value\"",
                    "        //   // comment",
                    "        // >",
                    "        !nameHasComments &&",
                    "        (!n.attributes[0].comments || !n.attributes[0].comments.length)",
                    "      ) {",
                    "        return group(",
                    "          concat([",
                    "            \"<\",",
                    "            path.call(print, \"name\"),",
                    "            path.call(print, \"typeParameters\"),",
                    "            \" \",",
                    "            concat(path.map(print, \"attributes\")),",
                    "            n.selfClosing ? \" />\" : \">\",",
                    "          ])",
                    "        );",
                    "      }",
                    "",
                    "      const lastAttrHasTrailingComments =",
                    "        n.attributes.length && hasTrailingComment(getLast(n.attributes));",
                    "",
                    "      const bracketSameLine =",
                    "        // Simple tags (no attributes and no comment in tag name) should be",
                    "        // kept unbroken regardless of `jsxBracketSameLine`",
                    "        (!n.attributes.length && !nameHasComments) ||",
                    "        (options.jsxBracketSameLine &&",
                    "          // We should print the bracket in a new line for the following cases:",
                    "          // <div",
                    "          //   // comment",
                    "          // >",
                    "          // <div",
                    "          //   attr // comment",
                    "          // >",
                    "          (!nameHasComments || n.attributes.length) &&",
                    "          !lastAttrHasTrailingComments);",
                    "",
                    "      // We should print the opening element expanded if any prop value is a",
                    "      // string literal with newlines",
                    "      const shouldBreak =",
                    "        n.attributes &&",
                    "        n.attributes.some(",
                    "          (attr) =>",
                    "            attr.value &&",
                    "            isStringLiteral(attr.value) &&",
                    "            attr.value.value.includes(\"\\n\")",
                    "        );",
                    "",
                    "      return group(",
                    "        concat([",
                    "          \"<\",",
                    "          path.call(print, \"name\"),",
                    "          path.call(print, \"typeParameters\"),",
                    "          concat([",
                    "            indent(",
                    "              concat(",
                    "                path.map((attr) => concat([line, print(attr)]), \"attributes\")",
                    "              )",
                    "            ),",
                    "            n.selfClosing ? line : bracketSameLine ? \">\" : softline,",
                    "          ]),",
                    "          n.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\",",
                    "        ]),",
                    "        { shouldBreak }",
                    "      );",
                    "    }",
                    "    case \"JSXClosingElement\":",
                    "      return concat([\"</\", path.call(print, \"name\"), \">\"]);",
                    "    case \"JSXOpeningFragment\":",
                    "    case \"JSXClosingFragment\": {",
                    "      const hasComment = n.comments && n.comments.length;",
                    "      const hasOwnLineComment =",
                    "        hasComment && !n.comments.every(handleComments.isBlockComment);",
                    "      const isOpeningFragment = n.type === \"JSXOpeningFragment\";",
                    "      return concat([",
                    "        isOpeningFragment ? \"<\" : \"</\",",
                    "        indent(",
                    "          concat([",
                    "            hasOwnLineComment",
                    "              ? hardline",
                    "              : hasComment && !isOpeningFragment",
                    "              ? \" \"",
                    "              : \"\",",
                    "            comments.printDanglingComments(path, options, true),",
                    "          ])",
                    "        ),",
                    "        hasOwnLineComment ? hardline : \"\",",
                    "        \">\",",
                    "      ]);",
                    "    }",
                    "    case \"JSXText\":",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"JSXTest should be handled by JSXElement\");",
                    "    case \"JSXEmptyExpression\": {",
                    "      const requiresHardline =",
                    "        n.comments && !n.comments.every(handleComments.isBlockComment);",
                    "",
                    "      return concat([",
                    "        comments.printDanglingComments(",
                    "          path,",
                    "          options,",
                    "          /* sameIndent */ !requiresHardline",
                    "        ),",
                    "        requiresHardline ? hardline : \"\",",
                    "      ]);",
                    "    }",
                    "    case \"ClassBody\":",
                    "      if (!n.comments && n.body.length === 0) {",
                    "        return \"{}\";",
                    "      }",
                    "",
                    "      return concat([",
                    "        \"{\",",
                    "        n.body.length > 0",
                    "          ? indent(",
                    "              concat([",
                    "                hardline,",
                    "                path.call((bodyPath) => {",
                    "                  return printStatementSequence(bodyPath, options, print);",
                    "                }, \"body\"),",
                    "              ])",
                    "            )",
                    "          : comments.printDanglingComments(path, options),",
                    "        hardline,",
                    "        \"}\",",
                    "      ]);",
                    "    case \"ClassProperty\":",
                    "    case \"TSAbstractClassProperty\":",
                    "    case \"ClassPrivateProperty\": {",
                    "      if (n.decorators && n.decorators.length !== 0) {",
                    "        parts.push(printDecorators(path, options, print));",
                    "      }",
                    "      if (n.accessibility) {",
                    "        parts.push(n.accessibility + \" \");",
                    "      }",
                    "      if (n.declare) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "      if (n.type === \"TSAbstractClassProperty\" || n.abstract) {",
                    "        parts.push(\"abstract \");",
                    "      }",
                    "      if (n.readonly) {",
                    "        parts.push(\"readonly \");",
                    "      }",
                    "      const variance = getFlowVariance(n);",
                    "      if (variance) {",
                    "        parts.push(variance);",
                    "      }",
                    "      parts.push(",
                    "        printPropertyKey(path, options, print),",
                    "        printOptionalToken(path),",
                    "        printTypeAnnotation(path, options, print)",
                    "      );",
                    "      if (n.value) {",
                    "        parts.push(",
                    "          \" =\",",
                    "          printAssignmentRight(",
                    "            n.key,",
                    "            n.value,",
                    "            path.call(print, \"value\"),",
                    "            options",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\":",
                    "      if (n.declare) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "      parts.push(concat(printClass(path, options, print)));",
                    "      return concat(parts);",
                    "    case \"TSInterfaceHeritage\":",
                    "    case \"TSExpressionWithTypeArguments\": // Babel AST",
                    "      parts.push(path.call(print, \"expression\"));",
                    "",
                    "      if (n.typeParameters) {",
                    "        parts.push(path.call(print, \"typeParameters\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"TemplateElement\":",
                    "      return join(literalline, n.value.raw.split(/\\r?\\n/g));",
                    "    case \"TemplateLiteral\": {",
                    "      let expressions = path.map(print, \"expressions\");",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      if (isJestEachTemplateLiteral(n, parentNode)) {",
                    "        const printed = printJestEachTemplateLiteral(n, expressions, options);",
                    "        if (printed) {",
                    "          return printed;",
                    "        }",
                    "      }",
                    "",
                    "      const isSimple = isSimpleTemplateLiteral(n);",
                    "      if (isSimple) {",
                    "        expressions = expressions.map(",
                    "          (doc) =>",
                    "            printDocToString(doc, { ...options, printWidth: Infinity })",
                    "              .formatted",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(lineSuffixBoundary, \"`\");",
                    "",
                    "      path.each((childPath) => {",
                    "        const i = childPath.getName();",
                    "",
                    "        parts.push(print(childPath));",
                    "",
                    "        if (i < expressions.length) {",
                    "          // For a template literal of the following form:",
                    "          //   `someQuery {",
                    "          //     ${call({",
                    "          //       a,",
                    "          //       b,",
                    "          //     })}",
                    "          //   }`",
                    "          // the expression is on its own line (there is a \\n in the previous",
                    "          // quasi literal), therefore we want to indent the JavaScript",
                    "          // expression inside at the beginning of ${ instead of the beginning",
                    "          // of the `.",
                    "          const { tabWidth } = options;",
                    "          const quasi = childPath.getValue();",
                    "          const indentSize = getIndentSize(quasi.value.raw, tabWidth);",
                    "",
                    "          let printed = expressions[i];",
                    "",
                    "          if (!isSimple) {",
                    "            // Breaks at the template element boundaries (${ and }) are preferred to breaking",
                    "            // in the middle of a MemberExpression",
                    "            if (",
                    "              (n.expressions[i].comments && n.expressions[i].comments.length) ||",
                    "              n.expressions[i].type === \"MemberExpression\" ||",
                    "              n.expressions[i].type === \"OptionalMemberExpression\" ||",
                    "              n.expressions[i].type === \"ConditionalExpression\" ||",
                    "              n.expressions[i].type === \"SequenceExpression\" ||",
                    "              n.expressions[i].type === \"TSAsExpression\" ||",
                    "              isBinaryish(n.expressions[i])",
                    "            ) {",
                    "              printed = concat([indent(concat([softline, printed])), softline]);",
                    "            }",
                    "          }",
                    "",
                    "          const aligned =",
                    "            indentSize === 0 && quasi.value.raw.endsWith(\"\\n\")",
                    "              ? align(-Infinity, printed)",
                    "              : addAlignmentToDoc(printed, indentSize, tabWidth);",
                    "",
                    "          parts.push(group(concat([\"${\", aligned, lineSuffixBoundary, \"}\"])));",
                    "        }",
                    "      }, \"quasis\");",
                    "",
                    "      parts.push(\"`\");",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"TaggedTemplateExpression\":",
                    "      return concat([",
                    "        path.call(print, \"tag\"),",
                    "        path.call(print, \"typeParameters\"),",
                    "        path.call(print, \"quasi\"),",
                    "      ]);",
                    "    // These types are unprintable because they serve as abstract",
                    "    // supertypes for other (printable) types.",
                    "    case \"Node\":",
                    "    case \"Printable\":",
                    "    case \"SourceLocation\":",
                    "    case \"Position\":",
                    "    case \"Statement\":",
                    "    case \"Function\":",
                    "    case \"Pattern\":",
                    "    case \"Expression\":",
                    "    case \"Declaration\":",
                    "    case \"Specifier\":",
                    "    case \"NamedSpecifier\":",
                    "    case \"Comment\":",
                    "    case \"MemberTypeAnnotation\": // Flow",
                    "    case \"Type\":",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));",
                    "    // Type Annotations for Facebook Flow, typically stripped out or",
                    "    // transformed away before printing.",
                    "    case \"TypeAnnotation\":",
                    "    case \"TSTypeAnnotation\":",
                    "      if (n.typeAnnotation) {",
                    "        return path.call(print, \"typeAnnotation\");",
                    "      }",
                    "",
                    "      /* istanbul ignore next */",
                    "      return \"\";",
                    "    case \"TSTupleType\":",
                    "    case \"TupleTypeAnnotation\": {",
                    "      const typesField = n.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";",
                    "      const hasRest =",
                    "        n[typesField].length > 0 &&",
                    "        getLast(n[typesField]).type === \"TSRestType\";",
                    "      return group(",
                    "        concat([",
                    "          \"[\",",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              printArrayItems(path, options, typesField, print),",
                    "            ])",
                    "          ),",
                    "          ifBreak(shouldPrintComma(options, \"all\") && !hasRest ? \",\" : \"\"),",
                    "          comments.printDanglingComments(path, options, /* sameIndent */ true),",
                    "          softline,",
                    "          \"]\",",
                    "        ])",
                    "      );",
                    "    }",
                    "",
                    "    case \"ExistsTypeAnnotation\":",
                    "      return \"*\";",
                    "    case \"EmptyTypeAnnotation\":",
                    "      return \"empty\";",
                    "    case \"AnyTypeAnnotation\":",
                    "      return \"any\";",
                    "    case \"MixedTypeAnnotation\":",
                    "      return \"mixed\";",
                    "    case \"ArrayTypeAnnotation\":",
                    "      return concat([path.call(print, \"elementType\"), \"[]\"]);",
                    "    case \"BooleanTypeAnnotation\":",
                    "      return \"boolean\";",
                    "    case \"BooleanLiteralTypeAnnotation\":",
                    "      return \"\" + n.value;",
                    "    case \"DeclareClass\":",
                    "      return printFlowDeclaration(path, printClass(path, options, print));",
                    "    case \"TSDeclareFunction\":",
                    "      // For TypeScript the TSDeclareFunction node shares the AST",
                    "      // structure with FunctionDeclaration",
                    "      return concat([",
                    "        n.declare ? \"declare \" : \"\",",
                    "        printFunctionDeclaration(path, print, options),",
                    "        semi,",
                    "      ]);",
                    "    case \"DeclareFunction\":",
                    "      return printFlowDeclaration(path, [",
                    "        \"function \",",
                    "        path.call(print, \"id\"),",
                    "        n.predicate ? \" \" : \"\",",
                    "        path.call(print, \"predicate\"),",
                    "        semi,",
                    "      ]);",
                    "    case \"DeclareModule\":",
                    "      return printFlowDeclaration(path, [",
                    "        \"module \",",
                    "        path.call(print, \"id\"),",
                    "        \" \",",
                    "        path.call(print, \"body\"),",
                    "      ]);",
                    "    case \"DeclareModuleExports\":",
                    "      return printFlowDeclaration(path, [",
                    "        \"module.exports\",",
                    "        \": \",",
                    "        path.call(print, \"typeAnnotation\"),",
                    "        semi,",
                    "      ]);",
                    "    case \"DeclareVariable\":",
                    "      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), semi]);",
                    "    case \"DeclareExportAllDeclaration\":",
                    "      return concat([",
                    "        \"declare export *\",",
                    "        printModuleSource(path, options, print),",
                    "      ]);",
                    "    case \"DeclareOpaqueType\":",
                    "    case \"OpaqueType\": {",
                    "      parts.push(",
                    "        \"opaque type \",",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\")",
                    "      );",
                    "",
                    "      if (n.supertype) {",
                    "        parts.push(\": \", path.call(print, \"supertype\"));",
                    "      }",
                    "",
                    "      if (n.impltype) {",
                    "        parts.push(\" = \", path.call(print, \"impltype\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      if (n.type === \"DeclareOpaqueType\") {",
                    "        return printFlowDeclaration(path, parts);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "",
                    "    case \"EnumDeclaration\":",
                    "      return concat([",
                    "        \"enum \",",
                    "        path.call(print, \"id\"),",
                    "        \" \",",
                    "        path.call(print, \"body\"),",
                    "      ]);",
                    "    case \"EnumBooleanBody\":",
                    "    case \"EnumNumberBody\":",
                    "    case \"EnumStringBody\":",
                    "    case \"EnumSymbolBody\": {",
                    "      if (n.type === \"EnumSymbolBody\" || n.explicitType) {",
                    "        let type = null;",
                    "        switch (n.type) {",
                    "          case \"EnumBooleanBody\":",
                    "            type = \"boolean\";",
                    "            break;",
                    "          case \"EnumNumberBody\":",
                    "            type = \"number\";",
                    "            break;",
                    "          case \"EnumStringBody\":",
                    "            type = \"string\";",
                    "            break;",
                    "          case \"EnumSymbolBody\":",
                    "            type = \"symbol\";",
                    "            break;",
                    "        }",
                    "        parts.push(\"of \", type, \" \");",
                    "      }",
                    "      if (n.members.length === 0) {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              \"{\",",
                    "              comments.printDanglingComments(path, options),",
                    "              softline,",
                    "              \"}\",",
                    "            ])",
                    "          )",
                    "        );",
                    "      } else {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              \"{\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  printArrayItems(path, options, \"members\", print),",
                    "                  shouldPrintComma(options) ? \",\" : \"\",",
                    "                ])",
                    "              ),",
                    "              comments.printDanglingComments(",
                    "                path,",
                    "                options,",
                    "                /* sameIndent */ true",
                    "              ),",
                    "              hardline,",
                    "              \"}\",",
                    "            ])",
                    "          )",
                    "        );",
                    "      }",
                    "      return concat(parts);",
                    "    }",
                    "    case \"EnumBooleanMember\":",
                    "    case \"EnumNumberMember\":",
                    "    case \"EnumStringMember\":",
                    "      return concat([",
                    "        path.call(print, \"id\"),",
                    "        \" = \",",
                    "        typeof n.init === \"object\" ? path.call(print, \"init\") : String(n.init),",
                    "      ]);",
                    "    case \"EnumDefaultedMember\":",
                    "      return path.call(print, \"id\");",
                    "",
                    "    case \"FunctionTypeAnnotation\":",
                    "    case \"TSFunctionType\": {",
                    "      // FunctionTypeAnnotation is ambiguous:",
                    "      // declare function foo(a: B): void; OR",
                    "      // var A: (a: B) => void;",
                    "      const parent = path.getParentNode(0);",
                    "      const parentParent = path.getParentNode(1);",
                    "      const parentParentParent = path.getParentNode(2);",
                    "      let isArrowFunctionTypeAnnotation =",
                    "        n.type === \"TSFunctionType\" ||",
                    "        !(",
                    "          ((parent.type === \"ObjectTypeProperty\" ||",
                    "            parent.type === \"ObjectTypeInternalSlot\") &&",
                    "            !getFlowVariance(parent) &&",
                    "            !parent.optional &&",
                    "            options.locStart(parent) === options.locStart(n)) ||",
                    "          parent.type === \"ObjectTypeCallProperty\" ||",
                    "          (parentParentParent && parentParentParent.type === \"DeclareFunction\")",
                    "        );",
                    "",
                    "      let needsColon =",
                    "        isArrowFunctionTypeAnnotation &&",
                    "        (parent.type === \"TypeAnnotation\" ||",
                    "          parent.type === \"TSTypeAnnotation\");",
                    "",
                    "      // Sadly we can't put it inside of FastPath::needsColon because we are",
                    "      // printing \":\" as part of the expression and it would put parenthesis",
                    "      // around :(",
                    "      const needsParens =",
                    "        needsColon &&",
                    "        isArrowFunctionTypeAnnotation &&",
                    "        (parent.type === \"TypeAnnotation\" ||",
                    "          parent.type === \"TSTypeAnnotation\") &&",
                    "        parentParent.type === \"ArrowFunctionExpression\";",
                    "",
                    "      if (isObjectTypePropertyAFunction(parent, options)) {",
                    "        isArrowFunctionTypeAnnotation = true;",
                    "        needsColon = true;",
                    "      }",
                    "",
                    "      if (needsParens) {",
                    "        parts.push(\"(\");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        printFunctionParams(",
                    "          path,",
                    "          print,",
                    "          options,",
                    "          /* expandArg */ false,",
                    "          /* printTypeParams */ true",
                    "        )",
                    "      );",
                    "",
                    "      // The returnType is not wrapped in a TypeAnnotation, so the colon",
                    "      // needs to be added separately.",
                    "      if (n.returnType || n.predicate || n.typeAnnotation) {",
                    "        parts.push(",
                    "          isArrowFunctionTypeAnnotation ? \" => \" : \": \",",
                    "          path.call(print, \"returnType\"),",
                    "          path.call(print, \"predicate\"),",
                    "          path.call(print, \"typeAnnotation\")",
                    "        );",
                    "      }",
                    "      if (needsParens) {",
                    "        parts.push(\")\");",
                    "      }",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"TSRestType\":",
                    "      return concat([\"...\", path.call(print, \"typeAnnotation\")]);",
                    "    case \"TSOptionalType\":",
                    "      return concat([path.call(print, \"typeAnnotation\"), \"?\"]);",
                    "    case \"FunctionTypeParam\":",
                    "      return concat([",
                    "        path.call(print, \"name\"),",
                    "        printOptionalToken(path),",
                    "        n.name ? \": \" : \"\",",
                    "        path.call(print, \"typeAnnotation\"),",
                    "      ]);",
                    "    case \"GenericTypeAnnotation\":",
                    "      return concat([",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\"),",
                    "      ]);",
                    "",
                    "    case \"DeclareInterface\":",
                    "    case \"InterfaceDeclaration\":",
                    "    case \"InterfaceTypeAnnotation\":",
                    "    case \"TSInterfaceDeclaration\": {",
                    "      if (n.type === \"DeclareInterface\" || n.declare) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "",
                    "      if (n.type === \"TSInterfaceDeclaration\") {",
                    "        parts.push(",
                    "          n.abstract ? \"abstract \" : \"\",",
                    "          printTypeScriptModifiers(path, options, print)",
                    "        );",
                    "      }",
                    "",
                    "      parts.push(\"interface\");",
                    "",
                    "      const partsGroup = [];",
                    "",
                    "      if (n.type !== \"InterfaceTypeAnnotation\") {",
                    "        partsGroup.push(",
                    "          \" \",",
                    "          path.call(print, \"id\"),",
                    "          path.call(print, \"typeParameters\")",
                    "        );",
                    "      }",
                    "",
                    "      if (n.extends && n.extends.length !== 0) {",
                    "        partsGroup.push(",
                    "          line,",
                    "          \"extends \",",
                    "          (n.extends.length === 1 ? identity : indent)(",
                    "            join(concat([\",\", line]), path.map(print, \"extends\"))",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      if (",
                    "        (n.id && hasTrailingComment(n.id)) ||",
                    "        (n.extends && n.extends.length !== 0)",
                    "      ) {",
                    "        parts.push(group(indent(concat(partsGroup))));",
                    "      } else {",
                    "        parts.push(...partsGroup);",
                    "      }",
                    "",
                    "      parts.push(\" \", path.call(print, \"body\"));",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"ClassImplements\":",
                    "    case \"InterfaceExtends\":",
                    "      return concat([",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\"),",
                    "      ]);",
                    "    case \"TSClassImplements\":",
                    "      return concat([",
                    "        path.call(print, \"expression\"),",
                    "        path.call(print, \"typeParameters\"),",
                    "      ]);",
                    "    case \"TSIntersectionType\":",
                    "    case \"IntersectionTypeAnnotation\": {",
                    "      const types = path.map(print, \"types\");",
                    "      const result = [];",
                    "      let wasIndented = false;",
                    "      for (let i = 0; i < types.length; ++i) {",
                    "        if (i === 0) {",
                    "          result.push(types[i]);",
                    "        } else if (isObjectType(n.types[i - 1]) && isObjectType(n.types[i])) {",
                    "          // If both are objects, don't indent",
                    "          result.push(",
                    "            concat([\" & \", wasIndented ? indent(types[i]) : types[i]])",
                    "          );",
                    "        } else if (!isObjectType(n.types[i - 1]) && !isObjectType(n.types[i])) {",
                    "          // If no object is involved, go to the next line if it breaks",
                    "          result.push(indent(concat([\" &\", line, types[i]])));",
                    "        } else {",
                    "          // If you go from object to non-object or vis-versa, then inline it",
                    "          if (i > 1) {",
                    "            wasIndented = true;",
                    "          }",
                    "          result.push(\" & \", i > 1 ? indent(types[i]) : types[i]);",
                    "        }",
                    "      }",
                    "      return group(concat(result));",
                    "    }",
                    "    case \"TSUnionType\":",
                    "    case \"UnionTypeAnnotation\": {",
                    "      // single-line variation",
                    "      // A | B | C",
                    "",
                    "      // multi-line variation",
                    "      // | A",
                    "      // | B",
                    "      // | C",
                    "",
                    "      const parent = path.getParentNode();",
                    "",
                    "      // If there's a leading comment, the parent is doing the indentation",
                    "      const shouldIndent =",
                    "        parent.type !== \"TypeParameterInstantiation\" &&",
                    "        parent.type !== \"TSTypeParameterInstantiation\" &&",
                    "        parent.type !== \"GenericTypeAnnotation\" &&",
                    "        parent.type !== \"TSTypeReference\" &&",
                    "        parent.type !== \"TSTypeAssertion\" &&",
                    "        parent.type !== \"TupleTypeAnnotation\" &&",
                    "        parent.type !== \"TSTupleType\" &&",
                    "        !(parent.type === \"FunctionTypeParam\" && !parent.name) &&",
                    "        !(",
                    "          (parent.type === \"TypeAlias\" ||",
                    "            parent.type === \"VariableDeclarator\" ||",
                    "            parent.type === \"TSTypeAliasDeclaration\") &&",
                    "          hasLeadingOwnLineComment(options.originalText, n, options)",
                    "        );",
                    "",
                    "      // {",
                    "      //   a: string",
                    "      // } | null | void",
                    "      // should be inlined and not be printed in the multi-line variant",
                    "      const shouldHug = shouldHugType(n);",
                    "",
                    "      // We want to align the children but without its comment, so it looks like",
                    "      // | child1",
                    "      // // comment",
                    "      // | child2",
                    "      const printed = path.map((typePath) => {",
                    "        let printedType = typePath.call(print);",
                    "        if (!shouldHug) {",
                    "          printedType = align(2, printedType);",
                    "        }",
                    "        return comments.printComments(typePath, () => printedType, options);",
                    "      }, \"types\");",
                    "",
                    "      if (shouldHug) {",
                    "        return join(\" | \", printed);",
                    "      }",
                    "",
                    "      const shouldAddStartLine =",
                    "        shouldIndent &&",
                    "        !hasLeadingOwnLineComment(options.originalText, n, options);",
                    "",
                    "      const code = concat([",
                    "        ifBreak(concat([shouldAddStartLine ? line : \"\", \"| \"])),",
                    "        join(concat([line, \"| \"]), printed),",
                    "      ]);",
                    "",
                    "      if (pathNeedsParens(path, options)) {",
                    "        return group(concat([indent(code), softline]));",
                    "      }",
                    "",
                    "      if (",
                    "        (parent.type === \"TupleTypeAnnotation\" && parent.types.length > 1) ||",
                    "        (parent.type === \"TSTupleType\" && parent.elementTypes.length > 1)",
                    "      ) {",
                    "        return group(",
                    "          concat([",
                    "            indent(concat([ifBreak(concat([\"(\", softline])), code])),",
                    "            softline,",
                    "            ifBreak(\")\"),",
                    "          ])",
                    "        );",
                    "      }",
                    "",
                    "      return group(shouldIndent ? indent(code) : code);",
                    "    }",
                    "    case \"NullableTypeAnnotation\":",
                    "      return concat([\"?\", path.call(print, \"typeAnnotation\")]);",
                    "    case \"TSNullKeyword\":",
                    "    case \"NullLiteralTypeAnnotation\":",
                    "      return \"null\";",
                    "    case \"ThisTypeAnnotation\":",
                    "      return \"this\";",
                    "    case \"NumberTypeAnnotation\":",
                    "      return \"number\";",
                    "    case \"SymbolTypeAnnotation\":",
                    "      return \"symbol\";",
                    "    case \"ObjectTypeCallProperty\":",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"value\"));",
                    "",
                    "      return concat(parts);",
                    "    case \"ObjectTypeIndexer\": {",
                    "      const variance = getFlowVariance(n);",
                    "      return concat([",
                    "        variance || \"\",",
                    "        \"[\",",
                    "        path.call(print, \"id\"),",
                    "        n.id ? \": \" : \"\",",
                    "        path.call(print, \"key\"),",
                    "        \"]: \",",
                    "        path.call(print, \"value\"),",
                    "      ]);",
                    "    }",
                    "    case \"ObjectTypeProperty\": {",
                    "      const variance = getFlowVariance(n);",
                    "",
                    "      let modifier = \"\";",
                    "",
                    "      if (n.proto) {",
                    "        modifier = \"proto \";",
                    "      } else if (n.static) {",
                    "        modifier = \"static \";",
                    "      }",
                    "",
                    "      return concat([",
                    "        modifier,",
                    "        isGetterOrSetter(n) ? n.kind + \" \" : \"\",",
                    "        variance || \"\",",
                    "        printPropertyKey(path, options, print),",
                    "        printOptionalToken(path),",
                    "        isFunctionNotation(n, options) ? \"\" : \": \",",
                    "        path.call(print, \"value\"),",
                    "      ]);",
                    "    }",
                    "    case \"QualifiedTypeIdentifier\":",
                    "      return concat([",
                    "        path.call(print, \"qualification\"),",
                    "        \".\",",
                    "        path.call(print, \"id\"),",
                    "      ]);",
                    "    case \"StringLiteralTypeAnnotation\":",
                    "      return nodeStr(n, options);",
                    "    case \"NumberLiteralTypeAnnotation\":",
                    "      assert.strictEqual(typeof n.value, \"number\");",
                    "",
                    "      if (n.extra != null) {",
                    "        return printNumber(n.extra.raw);",
                    "      }",
                    "      return printNumber(n.raw);",
                    "",
                    "    case \"StringTypeAnnotation\":",
                    "      return \"string\";",
                    "    case \"DeclareTypeAlias\":",
                    "    case \"TypeAlias\": {",
                    "      if (n.type === \"DeclareTypeAlias\" || n.declare) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "",
                    "      const printed = printAssignmentRight(",
                    "        n.id,",
                    "        n.right,",
                    "        path.call(print, \"right\"),",
                    "        options",
                    "      );",
                    "",
                    "      parts.push(",
                    "        \"type \",",
                    "        path.call(print, \"id\"),",
                    "        path.call(print, \"typeParameters\"),",
                    "        \" =\",",
                    "        printed,",
                    "        semi",
                    "      );",
                    "",
                    "      return group(concat(parts));",
                    "    }",
                    "    case \"TypeCastExpression\": {",
                    "      return concat([",
                    "        \"(\",",
                    "        path.call(print, \"expression\"),",
                    "        printTypeAnnotation(path, options, print),",
                    "        \")\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"TypeParameterDeclaration\":",
                    "    case \"TypeParameterInstantiation\": {",
                    "      const value = path.getValue();",
                    "      const commentStart = value.range",
                    "        ? options.originalText.slice(0, value.range[0]).lastIndexOf(\"/*\")",
                    "        : -1;",
                    "      // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here",
                    "      // because we know for sure that this is a type definition.",
                    "      const commentSyntax =",
                    "        commentStart >= 0 &&",
                    "        options.originalText.slice(commentStart).match(/^\\/\\*\\s*::/);",
                    "      if (commentSyntax) {",
                    "        return concat([",
                    "          \"/*:: \",",
                    "          printTypeParameters(path, options, print, \"params\"),",
                    "          \" */\",",
                    "        ]);",
                    "      }",
                    "",
                    "      return printTypeParameters(path, options, print, \"params\");",
                    "    }",
                    "",
                    "    case \"TSTypeParameterDeclaration\":",
                    "    case \"TSTypeParameterInstantiation\":",
                    "      return printTypeParameters(path, options, print, \"params\");",
                    "",
                    "    case \"TSTypeParameter\":",
                    "    case \"TypeParameter\": {",
                    "      const parent = path.getParentNode();",
                    "      if (parent.type === \"TSMappedType\") {",
                    "        parts.push(\"[\", path.call(print, \"name\"));",
                    "        if (n.constraint) {",
                    "          parts.push(\" in \", path.call(print, \"constraint\"));",
                    "        }",
                    "        parts.push(\"]\");",
                    "        return concat(parts);",
                    "      }",
                    "",
                    "      const variance = getFlowVariance(n);",
                    "",
                    "      if (variance) {",
                    "        parts.push(variance);",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"name\"));",
                    "",
                    "      if (n.bound) {",
                    "        parts.push(\": \");",
                    "        parts.push(path.call(print, \"bound\"));",
                    "      }",
                    "",
                    "      if (n.constraint) {",
                    "        parts.push(\" extends \", path.call(print, \"constraint\"));",
                    "      }",
                    "",
                    "      if (n.default) {",
                    "        parts.push(\" = \", path.call(print, \"default\"));",
                    "      }",
                    "",
                    "      // Keep comma if the file extension is .tsx and",
                    "      // has one type parameter that isn't extend with any types.",
                    "      // Because, otherwise formatted result will be invalid as tsx.",
                    "      const grandParent = path.getNode(2);",
                    "      if (",
                    "        parent.params &&",
                    "        parent.params.length === 1 &&",
                    "        isTSXFile(options) &&",
                    "        !n.constraint &&",
                    "        grandParent.type === \"ArrowFunctionExpression\"",
                    "      ) {",
                    "        parts.push(\",\");",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"TypeofTypeAnnotation\":",
                    "      return concat([\"typeof \", path.call(print, \"argument\")]);",
                    "    case \"VoidTypeAnnotation\":",
                    "      return \"void\";",
                    "    case \"InferredPredicate\":",
                    "      return \"%checks\";",
                    "    // Unhandled types below. If encountered, nodes of these types should",
                    "    // be either left alone or desugared into AST types that are fully",
                    "    // supported by the pretty-printer.",
                    "    case \"DeclaredPredicate\":",
                    "      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);",
                    "    case \"TSAbstractKeyword\":",
                    "      return \"abstract\";",
                    "    case \"TSAnyKeyword\":",
                    "      return \"any\";",
                    "    case \"TSAsyncKeyword\":",
                    "      return \"async\";",
                    "    case \"TSBooleanKeyword\":",
                    "      return \"boolean\";",
                    "    case \"TSBigIntKeyword\":",
                    "      return \"bigint\";",
                    "    case \"TSConstKeyword\":",
                    "      return \"const\";",
                    "    case \"TSDeclareKeyword\":",
                    "      return \"declare\";",
                    "    case \"TSExportKeyword\":",
                    "      return \"export\";",
                    "    case \"TSNeverKeyword\":",
                    "      return \"never\";",
                    "    case \"TSNumberKeyword\":",
                    "      return \"number\";",
                    "    case \"TSObjectKeyword\":",
                    "      return \"object\";",
                    "    case \"TSProtectedKeyword\":",
                    "      return \"protected\";",
                    "    case \"TSPrivateKeyword\":",
                    "      return \"private\";",
                    "    case \"TSPublicKeyword\":",
                    "      return \"public\";",
                    "    case \"TSReadonlyKeyword\":",
                    "      return \"readonly\";",
                    "    case \"TSSymbolKeyword\":",
                    "      return \"symbol\";",
                    "    case \"TSStaticKeyword\":",
                    "      return \"static\";",
                    "    case \"TSStringKeyword\":",
                    "      return \"string\";",
                    "    case \"TSUndefinedKeyword\":",
                    "      return \"undefined\";",
                    "    case \"TSUnknownKeyword\":",
                    "      return \"unknown\";",
                    "    case \"TSVoidKeyword\":",
                    "      return \"void\";",
                    "    case \"TSAsExpression\":",
                    "      return concat([",
                    "        path.call(print, \"expression\"),",
                    "        \" as \",",
                    "        path.call(print, \"typeAnnotation\"),",
                    "      ]);",
                    "    case \"TSArrayType\":",
                    "      return concat([path.call(print, \"elementType\"), \"[]\"]);",
                    "    case \"TSPropertySignature\": {",
                    "      if (n.export) {",
                    "        parts.push(\"export \");",
                    "      }",
                    "      if (n.accessibility) {",
                    "        parts.push(n.accessibility + \" \");",
                    "      }",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "      if (n.readonly) {",
                    "        parts.push(\"readonly \");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        printPropertyKey(path, options, print),",
                    "        printOptionalToken(path)",
                    "      );",
                    "",
                    "      if (n.typeAnnotation) {",
                    "        parts.push(\": \");",
                    "        parts.push(path.call(print, \"typeAnnotation\"));",
                    "      }",
                    "",
                    "      // This isn't valid semantically, but it's in the AST so we can print it.",
                    "      if (n.initializer) {",
                    "        parts.push(\" = \", path.call(print, \"initializer\"));",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "    case \"TSParameterProperty\":",
                    "      if (n.accessibility) {",
                    "        parts.push(n.accessibility + \" \");",
                    "      }",
                    "      if (n.export) {",
                    "        parts.push(\"export \");",
                    "      }",
                    "      if (n.static) {",
                    "        parts.push(\"static \");",
                    "      }",
                    "      if (n.readonly) {",
                    "        parts.push(\"readonly \");",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"parameter\"));",
                    "",
                    "      return concat(parts);",
                    "    case \"TSTypeReference\":",
                    "      return concat([",
                    "        path.call(print, \"typeName\"),",
                    "        printTypeParameters(path, options, print, \"typeParameters\"),",
                    "      ]);",
                    "    case \"TSTypeQuery\":",
                    "      return concat([\"typeof \", path.call(print, \"exprName\")]);",
                    "    case \"TSIndexSignature\": {",
                    "      const parent = path.getParentNode();",
                    "",
                    "      // The typescript parser accepts multiple parameters here. If you're",
                    "      // using them, it makes sense to have a trailing comma. But if you",
                    "      // aren't, this is more like a computed property name than an array.",
                    "      // So we leave off the trailing comma when there's just one parameter.",
                    "      const trailingComma =",
                    "        n.parameters.length > 1",
                    "          ? ifBreak(shouldPrintComma(options) ? \",\" : \"\")",
                    "          : \"\";",
                    "",
                    "      const parametersGroup = group(",
                    "        concat([",
                    "          indent(",
                    "            concat([",
                    "              softline,",
                    "              join(concat([\", \", softline]), path.map(print, \"parameters\")),",
                    "            ])",
                    "          ),",
                    "          trailingComma,",
                    "          softline,",
                    "        ])",
                    "      );",
                    "",
                    "      return concat([",
                    "        n.export ? \"export \" : \"\",",
                    "        n.accessibility ? concat([n.accessibility, \" \"]) : \"\",",
                    "        n.static ? \"static \" : \"\",",
                    "        n.readonly ? \"readonly \" : \"\",",
                    "        \"[\",",
                    "        n.parameters ? parametersGroup : \"\",",
                    "        n.typeAnnotation ? \"]: \" : \"]\",",
                    "        n.typeAnnotation ? path.call(print, \"typeAnnotation\") : \"\",",
                    "        parent.type === \"ClassBody\" ? semi : \"\",",
                    "      ]);",
                    "    }",
                    "    case \"TSTypePredicate\":",
                    "      return concat([",
                    "        n.asserts ? \"asserts \" : \"\",",
                    "        path.call(print, \"parameterName\"),",
                    "        n.typeAnnotation",
                    "          ? concat([\" is \", path.call(print, \"typeAnnotation\")])",
                    "          : \"\",",
                    "      ]);",
                    "    case \"TSNonNullExpression\":",
                    "      return concat([path.call(print, \"expression\"), \"!\"]);",
                    "    case \"TSThisType\":",
                    "      return \"this\";",
                    "    case \"TSImportType\":",
                    "      return concat([",
                    "        !n.isTypeOf ? \"\" : \"typeof \",",
                    "        \"import(\",",
                    "        path.call(print, n.parameter ? \"parameter\" : \"argument\"),",
                    "        \")\",",
                    "        !n.qualifier ? \"\" : concat([\".\", path.call(print, \"qualifier\")]),",
                    "        printTypeParameters(path, options, print, \"typeParameters\"),",
                    "      ]);",
                    "    case \"TSLiteralType\":",
                    "      return path.call(print, \"literal\");",
                    "    case \"TSIndexedAccessType\":",
                    "      return concat([",
                    "        path.call(print, \"objectType\"),",
                    "        \"[\",",
                    "        path.call(print, \"indexType\"),",
                    "        \"]\",",
                    "      ]);",
                    "    case \"TSConstructSignatureDeclaration\":",
                    "    case \"TSCallSignatureDeclaration\":",
                    "    case \"TSConstructorType\": {",
                    "      if (n.type !== \"TSCallSignatureDeclaration\") {",
                    "        parts.push(\"new \");",
                    "      }",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          printFunctionParams(",
                    "            path,",
                    "            print,",
                    "            options,",
                    "            /* expandArg */ false,",
                    "            /* printTypeParams */ true",
                    "          )",
                    "        )",
                    "      );",
                    "",
                    "      if (n.returnType || n.typeAnnotation) {",
                    "        const isType = n.type === \"TSConstructorType\";",
                    "        parts.push(",
                    "          isType ? \" => \" : \": \",",
                    "          path.call(print, \"returnType\"),",
                    "          path.call(print, \"typeAnnotation\")",
                    "        );",
                    "      }",
                    "      return concat(parts);",
                    "    }",
                    "    case \"TSTypeOperator\":",
                    "      return concat([n.operator, \" \", path.call(print, \"typeAnnotation\")]);",
                    "    case \"TSMappedType\": {",
                    "      const shouldBreak = hasNewlineInRange(",
                    "        options.originalText,",
                    "        options.locStart(n),",
                    "        options.locEnd(n)",
                    "      );",
                    "      return group(",
                    "        concat([",
                    "          \"{\",",
                    "          indent(",
                    "            concat([",
                    "              options.bracketSpacing ? line : softline,",
                    "              n.readonly",
                    "                ? concat([",
                    "                    getTypeScriptMappedTypeModifier(n.readonly, \"readonly\"),",
                    "                    \" \",",
                    "                  ])",
                    "                : \"\",",
                    "              printTypeScriptModifiers(path, options, print),",
                    "              path.call(print, \"typeParameter\"),",
                    "              n.optional",
                    "                ? getTypeScriptMappedTypeModifier(n.optional, \"?\")",
                    "                : \"\",",
                    "              n.typeAnnotation ? \": \" : \"\",",
                    "              path.call(print, \"typeAnnotation\"),",
                    "              ifBreak(semi, \"\"),",
                    "            ])",
                    "          ),",
                    "          comments.printDanglingComments(path, options, /* sameIndent */ true),",
                    "          options.bracketSpacing ? line : softline,",
                    "          \"}\",",
                    "        ]),",
                    "        { shouldBreak }",
                    "      );",
                    "    }",
                    "    case \"TSMethodSignature\":",
                    "      parts.push(",
                    "        n.accessibility ? concat([n.accessibility, \" \"]) : \"\",",
                    "        n.export ? \"export \" : \"\",",
                    "        n.static ? \"static \" : \"\",",
                    "        n.readonly ? \"readonly \" : \"\",",
                    "        n.computed ? \"[\" : \"\",",
                    "        path.call(print, \"key\"),",
                    "        n.computed ? \"]\" : \"\",",
                    "        printOptionalToken(path),",
                    "        printFunctionParams(",
                    "          path,",
                    "          print,",
                    "          options,",
                    "          /* expandArg */ false,",
                    "          /* printTypeParams */ true",
                    "        )",
                    "      );",
                    "",
                    "      if (n.returnType || n.typeAnnotation) {",
                    "        parts.push(",
                    "          \": \",",
                    "          path.call(print, \"returnType\"),",
                    "          path.call(print, \"typeAnnotation\")",
                    "        );",
                    "      }",
                    "      return group(concat(parts));",
                    "    case \"TSNamespaceExportDeclaration\":",
                    "      parts.push(\"export as namespace \", path.call(print, \"id\"));",
                    "",
                    "      if (options.semi) {",
                    "        parts.push(\";\");",
                    "      }",
                    "",
                    "      return group(concat(parts));",
                    "    case \"TSEnumDeclaration\":",
                    "      if (n.declare) {",
                    "        parts.push(\"declare \");",
                    "      }",
                    "",
                    "      if (n.modifiers) {",
                    "        parts.push(printTypeScriptModifiers(path, options, print));",
                    "      }",
                    "      if (n.const) {",
                    "        parts.push(\"const \");",
                    "      }",
                    "",
                    "      parts.push(\"enum \", path.call(print, \"id\"), \" \");",
                    "",
                    "      if (n.members.length === 0) {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              \"{\",",
                    "              comments.printDanglingComments(path, options),",
                    "              softline,",
                    "              \"}\",",
                    "            ])",
                    "          )",
                    "        );",
                    "      } else {",
                    "        parts.push(",
                    "          group(",
                    "            concat([",
                    "              \"{\",",
                    "              indent(",
                    "                concat([",
                    "                  hardline,",
                    "                  printArrayItems(path, options, \"members\", print),",
                    "                  shouldPrintComma(options, \"es5\") ? \",\" : \"\",",
                    "                ])",
                    "              ),",
                    "              comments.printDanglingComments(",
                    "                path,",
                    "                options,",
                    "                /* sameIndent */ true",
                    "              ),",
                    "              hardline,",
                    "              \"}\",",
                    "            ])",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    case \"TSEnumMember\":",
                    "      parts.push(path.call(print, \"id\"));",
                    "      if (n.initializer) {",
                    "        parts.push(\" = \", path.call(print, \"initializer\"));",
                    "      }",
                    "      return concat(parts);",
                    "    case \"TSImportEqualsDeclaration\":",
                    "      if (n.isExport) {",
                    "        parts.push(\"export \");",
                    "      }",
                    "      parts.push(",
                    "        \"import \",",
                    "        path.call(print, \"id\"),",
                    "        \" = \",",
                    "        path.call(print, \"moduleReference\")",
                    "      );",
                    "",
                    "      if (options.semi) {",
                    "        parts.push(\";\");",
                    "      }",
                    "",
                    "      return group(concat(parts));",
                    "    case \"TSExternalModuleReference\":",
                    "      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);",
                    "    case \"TSModuleDeclaration\": {",
                    "      const parent = path.getParentNode();",
                    "      const isExternalModule = isLiteral(n.id);",
                    "      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";",
                    "      const bodyIsDeclaration = n.body && n.body.type === \"TSModuleDeclaration\";",
                    "",
                    "      if (parentIsDeclaration) {",
                    "        parts.push(\".\");",
                    "      } else {",
                    "        if (n.declare) {",
                    "          parts.push(\"declare \");",
                    "        }",
                    "        parts.push(printTypeScriptModifiers(path, options, print));",
                    "",
                    "        const textBetweenNodeAndItsId = options.originalText.slice(",
                    "          options.locStart(n),",
                    "          options.locStart(n.id)",
                    "        );",
                    "",
                    "        // Global declaration looks like this:",
                    "        // (declare)? global { ... }",
                    "        const isGlobalDeclaration =",
                    "          n.id.type === \"Identifier\" &&",
                    "          n.id.name === \"global\" &&",
                    "          !/namespace|module/.test(textBetweenNodeAndItsId);",
                    "",
                    "        if (!isGlobalDeclaration) {",
                    "          parts.push(",
                    "            isExternalModule ||",
                    "              /(^|\\s)module(\\s|$)/.test(textBetweenNodeAndItsId)",
                    "              ? \"module \"",
                    "              : \"namespace \"",
                    "          );",
                    "        }",
                    "      }",
                    "",
                    "      parts.push(path.call(print, \"id\"));",
                    "",
                    "      if (bodyIsDeclaration) {",
                    "        parts.push(path.call(print, \"body\"));",
                    "      } else if (n.body) {",
                    "        parts.push(\" \", group(path.call(print, \"body\")));",
                    "      } else {",
                    "        parts.push(semi);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }",
                    "",
                    "    case \"PrivateName\":",
                    "      return concat([\"#\", path.call(print, \"id\")]);",
                    "",
                    "    // TODO: Temporary auto-generated node type. To remove when typescript-estree has proper support for private fields.",
                    "    case \"TSPrivateIdentifier\":",
                    "      return n.escapedText;",
                    "",
                    "    case \"TSConditionalType\":",
                    "      return printTernaryOperator(path, options, print, {",
                    "        beforeParts: () => [",
                    "          path.call(print, \"checkType\"),",
                    "          \" \",",
                    "          \"extends\",",
                    "          \" \",",
                    "          path.call(print, \"extendsType\"),",
                    "        ],",
                    "        afterParts: () => [],",
                    "        shouldCheckJsx: false,",
                    "        conditionalNodeType: \"TSConditionalType\",",
                    "        consequentNodePropertyName: \"trueType\",",
                    "        alternateNodePropertyName: \"falseType\",",
                    "        testNodePropertyNames: [\"checkType\", \"extendsType\"],",
                    "      });",
                    "",
                    "    case \"TSInferType\":",
                    "      return concat([\"infer\", \" \", path.call(print, \"typeParameter\")]);",
                    "",
                    "    case \"InterpreterDirective\":",
                    "      parts.push(\"#!\", n.value, hardline);",
                    "",
                    "      if (isNextLineEmpty(options.originalText, n, options.locEnd)) {",
                    "        parts.push(hardline);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "",
                    "    case \"NGRoot\":",
                    "      return concat(",
                    "        [].concat(",
                    "          path.call(print, \"node\"),",
                    "          !n.node.comments || n.node.comments.length === 0",
                    "            ? []",
                    "            : concat([\" //\", n.node.comments[0].value.trimEnd()])",
                    "        )",
                    "      );",
                    "    case \"NGChainedExpression\":",
                    "      return group(",
                    "        join(",
                    "          concat([\";\", line]),",
                    "          path.map(",
                    "            (childPath) =>",
                    "              hasNgSideEffect(childPath)",
                    "                ? print(childPath)",
                    "                : concat([\"(\", print(childPath), \")\"]),",
                    "            \"expressions\"",
                    "          )",
                    "        )",
                    "      );",
                    "    case \"NGEmptyExpression\":",
                    "      return \"\";",
                    "    case \"NGQuotedExpression\":",
                    "      return concat([n.prefix, \": \", n.value.trim()]);",
                    "    case \"NGMicrosyntax\":",
                    "      return concat(",
                    "        path.map(",
                    "          (childPath, index) =>",
                    "            concat([",
                    "              index === 0",
                    "                ? \"\"",
                    "                : isNgForOf(childPath.getValue(), index, n)",
                    "                ? \" \"",
                    "                : concat([\";\", line]),",
                    "              print(childPath),",
                    "            ]),",
                    "          \"body\"",
                    "        )",
                    "      );",
                    "    case \"NGMicrosyntaxKey\":",
                    "      return /^[$_a-z][\\w$]*(-[$_a-z][\\w$])*$/i.test(n.name)",
                    "        ? n.name",
                    "        : JSON.stringify(n.name);",
                    "    case \"NGMicrosyntaxExpression\":",
                    "      return concat([",
                    "        path.call(print, \"expression\"),",
                    "        n.alias === null ? \"\" : concat([\" as \", path.call(print, \"alias\")]),",
                    "      ]);",
                    "    case \"NGMicrosyntaxKeyedExpression\": {",
                    "      const index = path.getName();",
                    "      const parentNode = path.getParentNode();",
                    "      const shouldNotPrintColon =",
                    "        isNgForOf(n, index, parentNode) ||",
                    "        (((index === 1 && (n.key.name === \"then\" || n.key.name === \"else\")) ||",
                    "          (index === 2 &&",
                    "            n.key.name === \"else\" &&",
                    "            parentNode.body[index - 1].type ===",
                    "              \"NGMicrosyntaxKeyedExpression\" &&",
                    "            parentNode.body[index - 1].key.name === \"then\")) &&",
                    "          parentNode.body[0].type === \"NGMicrosyntaxExpression\");",
                    "      return concat([",
                    "        path.call(print, \"key\"),",
                    "        shouldNotPrintColon ? \" \" : \": \",",
                    "        path.call(print, \"expression\"),",
                    "      ]);",
                    "    }",
                    "    case \"NGMicrosyntaxLet\":",
                    "      return concat([",
                    "        \"let \",",
                    "        path.call(print, \"key\"),",
                    "        n.value === null ? \"\" : concat([\" = \", path.call(print, \"value\")]),",
                    "      ]);",
                    "    case \"NGMicrosyntaxAs\":",
                    "      return concat([",
                    "        path.call(print, \"key\"),",
                    "        \" as \",",
                    "        path.call(print, \"alias\"),",
                    "      ]);",
                    "",
                    "    case \"PipelineBareFunction\":",
                    "      return path.call(print, \"callee\");",
                    "    case \"PipelineTopicExpression\":",
                    "      return path.call(print, \"expression\");",
                    "    case \"PipelinePrimaryTopicReference\": {",
                    "      parts.push(\"#\");",
                    "      return concat(parts);",
                    "    }",
                    "",
                    "    case \"ArgumentPlaceholder\":",
                    "      return \"?\";",
                    "",
                    "    // These are not valid TypeScript. Printing them just for the sake of error recovery.",
                    "    case \"TSJSDocAllType\":",
                    "      return \"*\";",
                    "    case \"TSJSDocUnknownType\":",
                    "      return \"?\";",
                    "    case \"TSJSDocNullableType\":",
                    "      return concat([\"?\", path.call(print, \"typeAnnotation\")]);",
                    "    case \"TSJSDocNonNullableType\":",
                    "      return concat([\"!\", path.call(print, \"typeAnnotation\")]);",
                    "    case \"TSJSDocFunctionType\":",
                    "      return concat([",
                    "        \"function(\",",
                    "        // The parameters could be here, but typescript-estree doesn't convert them anyway (throws an error).",
                    "        \"): \",",
                    "        path.call(print, \"typeAnnotation\"),",
                    "      ]);",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown type: \" + JSON.stringify(n.type));",
                    "  }",
                    "}",
                    "",
                    "function printStatementSequence(path, options, print) {",
                    "  const printed = [];",
                    "",
                    "  const bodyNode = path.getNode();",
                    "  const isClass = bodyNode.type === \"ClassBody\";",
                    "",
                    "  path.map((stmtPath, i) => {",
                    "    const stmt = stmtPath.getValue();",
                    "",
                    "    // Just in case the AST has been modified to contain falsy",
                    "    // \"statements,\" it's safer simply to skip them.",
                    "    /* istanbul ignore if */",
                    "    if (!stmt) {",
                    "      return;",
                    "    }",
                    "",
                    "    // Skip printing EmptyStatement nodes to avoid leaving stray",
                    "    // semicolons lying around.",
                    "    if (stmt.type === \"EmptyStatement\") {",
                    "      return;",
                    "    }",
                    "",
                    "    const stmtPrinted = print(stmtPath);",
                    "    const text = options.originalText;",
                    "    const parts = [];",
                    "",
                    "    // in no-semi mode, prepend statement with semicolon if it might break ASI",
                    "    // don't prepend the only JSX element in a program with semicolon",
                    "    if (",
                    "      !options.semi &&",
                    "      !isClass &&",
                    "      !isTheOnlyJSXElementInMarkdown(options, stmtPath) &&",
                    "      stmtNeedsASIProtection(stmtPath, options)",
                    "    ) {",
                    "      if (stmt.comments && stmt.comments.some((comment) => comment.leading)) {",
                    "        parts.push(print(stmtPath, { needsSemi: true }));",
                    "      } else {",
                    "        parts.push(\";\", stmtPrinted);",
                    "      }",
                    "    } else {",
                    "      parts.push(stmtPrinted);",
                    "    }",
                    "",
                    "    if (!options.semi && isClass) {",
                    "      if (classPropMayCauseASIProblems(stmtPath)) {",
                    "        parts.push(\";\");",
                    "      } else if (stmt.type === \"ClassProperty\") {",
                    "        const nextChild = bodyNode.body[i + 1];",
                    "        if (classChildNeedsASIProtection(nextChild)) {",
                    "          parts.push(\";\");",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (",
                    "      isNextLineEmpty(text, stmt, options.locEnd) &&",
                    "      !isLastStatement(stmtPath)",
                    "    ) {",
                    "      parts.push(hardline);",
                    "    }",
                    "",
                    "    printed.push(concat(parts));",
                    "  });",
                    "",
                    "  return join(hardline, printed);",
                    "}",
                    "",
                    "function printPropertyKey(path, options, print) {",
                    "  const node = path.getNode();",
                    "",
                    "  if (node.computed) {",
                    "    return concat([\"[\", path.call(print, \"key\"), \"]\"]);",
                    "  }",
                    "",
                    "  const parent = path.getParentNode();",
                    "  const { key } = node;",
                    "",
                    "  if (",
                    "    node.type === \"ClassPrivateProperty\" &&",
                    "    // flow has `Identifier` key, and babel has `PrivateName` key",
                    "    key.type === \"Identifier\"",
                    "  ) {",
                    "    return concat([\"#\", path.call(print, \"key\")]);",
                    "  }",
                    "",
                    "  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {",
                    "    const objectHasStringProp = (",
                    "      parent.properties ||",
                    "      parent.body ||",
                    "      parent.members",
                    "    ).some(",
                    "      (prop) =>",
                    "        !prop.computed &&",
                    "        prop.key &&",
                    "        isStringLiteral(prop.key) &&",
                    "        !isStringPropSafeToCoerceToIdentifier(prop, options)",
                    "    );",
                    "    needsQuoteProps.set(parent, objectHasStringProp);",
                    "  }",
                    "",
                    "  if (",
                    "    key.type === \"Identifier\" &&",
                    "    (options.parser === \"json\" ||",
                    "      (options.quoteProps === \"consistent\" && needsQuoteProps.get(parent)))",
                    "  ) {",
                    "    // a -> \"a\"",
                    "    const prop = printString(JSON.stringify(key.name), options);",
                    "    return path.call(",
                    "      (keyPath) => comments.printComments(keyPath, () => prop, options),",
                    "      \"key\"",
                    "    );",
                    "  }",
                    "",
                    "  if (",
                    "    isStringPropSafeToCoerceToIdentifier(node, options) &&",
                    "    (options.quoteProps === \"as-needed\" ||",
                    "      (options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent)))",
                    "  ) {",
                    "    // 'a' -> a",
                    "    return path.call(",
                    "      (keyPath) => comments.printComments(keyPath, () => key.value, options),",
                    "      \"key\"",
                    "    );",
                    "  }",
                    "",
                    "  return path.call(print, \"key\");",
                    "}",
                    "",
                    "function printMethod(path, options, print) {",
                    "  const node = path.getNode();",
                    "  const { kind } = node;",
                    "  const value = node.value || node;",
                    "  const parts = [];",
                    "",
                    "  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {",
                    "    if (value.async) {",
                    "      parts.push(\"async \");",
                    "    }",
                    "    if (value.generator) {",
                    "      parts.push(\"*\");",
                    "    }",
                    "  } else {",
                    "    assert.ok(kind === \"get\" || kind === \"set\");",
                    "",
                    "    parts.push(kind, \" \");",
                    "  }",
                    "",
                    "  parts.push(",
                    "    printPropertyKey(path, options, print),",
                    "    node.optional || node.key.optional ? \"?\" : \"\",",
                    "    node === value",
                    "      ? printMethodInternal(path, options, print)",
                    "      : path.call((path) => printMethodInternal(path, options, print), \"value\")",
                    "  );",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printMethodInternal(path, options, print) {",
                    "  const parts = [",
                    "    printFunctionTypeParameters(path, options, print),",
                    "    group(",
                    "      concat([",
                    "        printFunctionParams(path, print, options),",
                    "        printReturnType(path, print, options),",
                    "      ])",
                    "    ),",
                    "  ];",
                    "",
                    "  if (path.getNode().body) {",
                    "    parts.push(\" \", path.call(print, \"body\"));",
                    "  } else {",
                    "    parts.push(options.semi ? \";\" : \"\");",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printJestEachTemplateLiteral(node, expressions, options) {",
                    "  /**",
                    "   * a    | b    | expected",
                    "   * ${1} | ${1} | ${2}",
                    "   * ${1} | ${2} | ${3}",
                    "   * ${2} | ${1} | ${3}",
                    "   */",
                    "  const headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);",
                    "  if (",
                    "    headerNames.length > 1 ||",
                    "    headerNames.some((headerName) => headerName.length !== 0)",
                    "  ) {",
                    "    const parts = [];",
                    "    const stringifiedExpressions = expressions.map(",
                    "      (doc) =>",
                    "        \"${\" +",
                    "        printDocToString(doc, {",
                    "          ...options,",
                    "          printWidth: Infinity,",
                    "          endOfLine: \"lf\",",
                    "        }).formatted +",
                    "        \"}\"",
                    "    );",
                    "",
                    "    const tableBody = [{ hasLineBreak: false, cells: [] }];",
                    "    for (let i = 1; i < node.quasis.length; i++) {",
                    "      const row = tableBody[tableBody.length - 1];",
                    "      const correspondingExpression = stringifiedExpressions[i - 1];",
                    "",
                    "      row.cells.push(correspondingExpression);",
                    "      if (correspondingExpression.includes(\"\\n\")) {",
                    "        row.hasLineBreak = true;",
                    "      }",
                    "",
                    "      if (node.quasis[i].value.raw.includes(\"\\n\")) {",
                    "        tableBody.push({ hasLineBreak: false, cells: [] });",
                    "      }",
                    "    }",
                    "",
                    "    const maxColumnCount = Math.max(",
                    "      headerNames.length,",
                    "      ...tableBody.map((row) => row.cells.length)",
                    "    );",
                    "",
                    "    const maxColumnWidths = Array.from({ length: maxColumnCount }).fill(0);",
                    "    const table = [",
                    "      { cells: headerNames },",
                    "      ...tableBody.filter((row) => row.cells.length !== 0),",
                    "    ];",
                    "    for (const { cells } of table.filter((row) => !row.hasLineBreak)) {",
                    "      cells.forEach((cell, index) => {",
                    "        maxColumnWidths[index] = Math.max(",
                    "          maxColumnWidths[index],",
                    "          getStringWidth(cell)",
                    "        );",
                    "      });",
                    "    }",
                    "",
                    "    parts.push(",
                    "      lineSuffixBoundary,",
                    "      \"`\",",
                    "      indent(",
                    "        concat([",
                    "          hardline,",
                    "          join(",
                    "            hardline,",
                    "            table.map((row) =>",
                    "              join(",
                    "                \" | \",",
                    "                row.cells.map((cell, index) =>",
                    "                  row.hasLineBreak",
                    "                    ? cell",
                    "                    : cell +",
                    "                      \" \".repeat(maxColumnWidths[index] - getStringWidth(cell))",
                    "                )",
                    "              )",
                    "            )",
                    "          ),",
                    "        ])",
                    "      ),",
                    "      hardline,",
                    "      \"`\"",
                    "    );",
                    "    return concat(parts);",
                    "  }",
                    "}",
                    "",
                    "function printTypeAnnotation(path, options, print) {",
                    "  const node = path.getValue();",
                    "  if (!node.typeAnnotation) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const parentNode = path.getParentNode();",
                    "  const isDefinite =",
                    "    node.definite ||",
                    "    (parentNode &&",
                    "      parentNode.type === \"VariableDeclarator\" &&",
                    "      parentNode.definite);",
                    "",
                    "  const isFunctionDeclarationIdentifier =",
                    "    parentNode.type === \"DeclareFunction\" && parentNode.id === node;",
                    "",
                    "  if (",
                    "    isFlowAnnotationComment(options.originalText, node.typeAnnotation, options)",
                    "  ) {",
                    "    return concat([\" /*: \", path.call(print, \"typeAnnotation\"), \" */\"]);",
                    "  }",
                    "",
                    "  return concat([",
                    "    isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \",",
                    "    path.call(print, \"typeAnnotation\"),",
                    "  ]);",
                    "}",
                    "",
                    "function printFunctionParams(path, print, options, expandArg, printTypeParams) {",
                    "  const fun = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const paramsField = fun.parameters ? \"parameters\" : \"params\";",
                    "  const isParametersInTestCall = isTestCall(parent);",
                    "  const shouldHugParameters = shouldHugArguments(fun);",
                    "  const shouldExpandParameters =",
                    "    expandArg &&",
                    "    !(fun[paramsField] && fun[paramsField].some((n) => n.comments));",
                    "",
                    "  const typeParams = printTypeParams",
                    "    ? printFunctionTypeParameters(path, options, print)",
                    "    : \"\";",
                    "",
                    "  let printed = [];",
                    "  if (fun[paramsField]) {",
                    "    const lastArgIndex = fun[paramsField].length - 1;",
                    "",
                    "    printed = path.map((childPath, index) => {",
                    "      const parts = [];",
                    "      const param = childPath.getValue();",
                    "",
                    "      parts.push(print(childPath));",
                    "",
                    "      if (index === lastArgIndex) {",
                    "        if (fun.rest) {",
                    "          parts.push(\",\", line);",
                    "        }",
                    "      } else if (",
                    "        isParametersInTestCall ||",
                    "        shouldHugParameters ||",
                    "        shouldExpandParameters",
                    "      ) {",
                    "        parts.push(\", \");",
                    "      } else if (isNextLineEmpty(options.originalText, param, options.locEnd)) {",
                    "        parts.push(\",\", hardline, hardline);",
                    "      } else {",
                    "        parts.push(\",\", line);",
                    "      }",
                    "",
                    "      return concat(parts);",
                    "    }, paramsField);",
                    "  }",
                    "",
                    "  if (fun.rest) {",
                    "    printed.push(concat([\"...\", path.call(print, \"rest\")]));",
                    "  }",
                    "",
                    "  if (printed.length === 0) {",
                    "    return concat([",
                    "      typeParams,",
                    "      \"(\",",
                    "      comments.printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameIndent */ true,",
                    "        (comment) =>",
                    "          getNextNonSpaceNonCommentCharacter(",
                    "            options.originalText,",
                    "            comment,",
                    "            options.locEnd",
                    "          ) === \")\"",
                    "      ),",
                    "      \")\",",
                    "    ]);",
                    "  }",
                    "",
                    "  const lastParam = getLast(fun[paramsField]);",
                    "",
                    "  // If the parent is a call with the first/last argument expansion and this is the",
                    "  // params of the first/last argument, we don't want the arguments to break and instead",
                    "  // want the whole expression to be on a new line.",
                    "  //",
                    "  // Good:                 Bad:",
                    "  //   verylongcall(         verylongcall((",
                    "  //     (a, b) => {           a,",
                    "  //     }                     b,",
                    "  //   })                    ) => {",
                    "  //                         })",
                    "  if (shouldExpandParameters) {",
                    "    return group(",
                    "      concat([",
                    "        removeLines(typeParams),",
                    "        \"(\",",
                    "        concat(printed.map(removeLines)),",
                    "        \")\",",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  // Single object destructuring should hug",
                    "  //",
                    "  // function({",
                    "  //   a,",
                    "  //   b,",
                    "  //   c",
                    "  // }) {}",
                    "  const hasNotParameterDecorator = fun[paramsField].every(",
                    "    (param) => !param.decorators",
                    "  );",
                    "  if (shouldHugParameters && hasNotParameterDecorator) {",
                    "    return concat([typeParams, \"(\", concat(printed), \")\"]);",
                    "  }",
                    "",
                    "  // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`",
                    "  if (isParametersInTestCall) {",
                    "    return concat([typeParams, \"(\", concat(printed), \")\"]);",
                    "  }",
                    "",
                    "  const isFlowShorthandWithOneArg =",
                    "    (isObjectTypePropertyAFunction(parent, options) ||",
                    "      isTypeAnnotationAFunction(parent, options) ||",
                    "      parent.type === \"TypeAlias\" ||",
                    "      parent.type === \"UnionTypeAnnotation\" ||",
                    "      parent.type === \"TSUnionType\" ||",
                    "      parent.type === \"IntersectionTypeAnnotation\" ||",
                    "      (parent.type === \"FunctionTypeAnnotation\" &&",
                    "        parent.returnType === fun)) &&",
                    "    fun[paramsField].length === 1 &&",
                    "    fun[paramsField][0].name === null &&",
                    "    fun[paramsField][0].typeAnnotation &&",
                    "    fun.typeParameters === null &&",
                    "    isSimpleFlowType(fun[paramsField][0].typeAnnotation) &&",
                    "    !fun.rest;",
                    "",
                    "  if (isFlowShorthandWithOneArg) {",
                    "    if (options.arrowParens === \"always\") {",
                    "      return concat([\"(\", concat(printed), \")\"]);",
                    "    }",
                    "    return concat(printed);",
                    "  }",
                    "",
                    "  const canHaveTrailingComma =",
                    "    !(lastParam && lastParam.type === \"RestElement\") && !fun.rest;",
                    "",
                    "  return concat([",
                    "    typeParams,",
                    "    \"(\",",
                    "    indent(concat([softline, concat(printed)])),",
                    "    ifBreak(",
                    "      canHaveTrailingComma && shouldPrintComma(options, \"all\") ? \",\" : \"\"",
                    "    ),",
                    "    softline,",
                    "    \")\",",
                    "  ]);",
                    "}",
                    "",
                    "function shouldPrintParamsWithoutParens(path, options) {",
                    "  if (options.arrowParens === \"always\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (options.arrowParens === \"avoid\") {",
                    "    const node = path.getValue();",
                    "    return canPrintParamsWithoutParens(node);",
                    "  }",
                    "",
                    "  // Fallback default; should be unreachable",
                    "  return false;",
                    "}",
                    "",
                    "function canPrintParamsWithoutParens(node) {",
                    "  return (",
                    "    node.params.length === 1 &&",
                    "    !node.rest &&",
                    "    !node.typeParameters &&",
                    "    !hasDanglingComments(node) &&",
                    "    node.params[0].type === \"Identifier\" &&",
                    "    !node.params[0].typeAnnotation &&",
                    "    !node.params[0].comments &&",
                    "    !node.params[0].optional &&",
                    "    !node.predicate &&",
                    "    !node.returnType",
                    "  );",
                    "}",
                    "",
                    "function printFunctionDeclaration(path, print, options) {",
                    "  const n = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  if (n.async) {",
                    "    parts.push(\"async \");",
                    "  }",
                    "",
                    "  if (n.generator) {",
                    "    parts.push(\"function* \");",
                    "  } else {",
                    "    parts.push(\"function \");",
                    "  }",
                    "",
                    "  if (n.id) {",
                    "    parts.push(path.call(print, \"id\"));",
                    "  }",
                    "",
                    "  parts.push(",
                    "    printFunctionTypeParameters(path, options, print),",
                    "    group(",
                    "      concat([",
                    "        printFunctionParams(path, print, options),",
                    "        printReturnType(path, print, options),",
                    "      ])",
                    "    ),",
                    "    n.body ? \" \" : \"\",",
                    "    path.call(print, \"body\")",
                    "  );",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printReturnType(path, print, options) {",
                    "  const n = path.getValue();",
                    "  const returnType = path.call(print, \"returnType\");",
                    "",
                    "  if (",
                    "    n.returnType &&",
                    "    isFlowAnnotationComment(options.originalText, n.returnType, options)",
                    "  ) {",
                    "    return concat([\" /*: \", returnType, \" */\"]);",
                    "  }",
                    "",
                    "  const parts = [returnType];",
                    "",
                    "  // prepend colon to TypeScript type annotation",
                    "  if (n.returnType && n.returnType.typeAnnotation) {",
                    "    parts.unshift(\": \");",
                    "  }",
                    "",
                    "  if (n.predicate) {",
                    "    // The return type will already add the colon, but otherwise we",
                    "    // need to do it ourselves",
                    "    parts.push(n.returnType ? \" \" : \": \", path.call(print, \"predicate\"));",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printExportDeclaration(path, options, print) {",
                    "  const decl = path.getValue();",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "  const parts = [\"export \"];",
                    "",
                    "  const isDefault = decl.default || decl.type === \"ExportDefaultDeclaration\";",
                    "",
                    "  if (isDefault) {",
                    "    parts.push(\"default \");",
                    "  }",
                    "",
                    "  parts.push(",
                    "    comments.printDanglingComments(path, options, /* sameIndent */ true)",
                    "  );",
                    "",
                    "  if (needsHardlineAfterDanglingComment(decl)) {",
                    "    parts.push(hardline);",
                    "  }",
                    "",
                    "  if (decl.declaration) {",
                    "    parts.push(path.call(print, \"declaration\"));",
                    "",
                    "    if (",
                    "      isDefault &&",
                    "      decl.declaration.type !== \"ClassDeclaration\" &&",
                    "      decl.declaration.type !== \"FunctionDeclaration\" &&",
                    "      decl.declaration.type !== \"TSInterfaceDeclaration\" &&",
                    "      decl.declaration.type !== \"DeclareClass\" &&",
                    "      decl.declaration.type !== \"DeclareFunction\" &&",
                    "      decl.declaration.type !== \"TSDeclareFunction\"",
                    "    ) {",
                    "      parts.push(semi);",
                    "    }",
                    "  } else {",
                    "    parts.push(decl.exportKind === \"type\" ? \"type \" : \"\");",
                    "    parts.push(printModuleSpecifiers(path, options, print));",
                    "    parts.push(printModuleSource(path, options, print));",
                    "    parts.push(semi);",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printFlowDeclaration(path, parts) {",
                    "  const parentExportDecl = getParentExportDeclaration(path);",
                    "",
                    "  if (parentExportDecl) {",
                    "    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");",
                    "  } else {",
                    "    // If the parent node has type DeclareExportDeclaration, then it",
                    "    // will be responsible for printing the \"declare\" token. Otherwise",
                    "    // it needs to be printed with this non-exported declaration node.",
                    "    parts.unshift(\"declare \");",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function printTypeScriptModifiers(path, options, print) {",
                    "  const n = path.getValue();",
                    "  if (!n.modifiers || !n.modifiers.length) {",
                    "    return \"\";",
                    "  }",
                    "  return concat([join(\" \", path.map(print, \"modifiers\")), \" \"]);",
                    "}",
                    "",
                    "function printTypeParameters(path, options, print, paramsKey) {",
                    "  const n = path.getValue();",
                    "",
                    "  if (!n[paramsKey]) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  // for TypeParameterDeclaration typeParameters is a single node",
                    "  if (!Array.isArray(n[paramsKey])) {",
                    "    return path.call(print, paramsKey);",
                    "  }",
                    "",
                    "  const grandparent = path.getNode(2);",
                    "  const greatGrandParent = path.getNode(3);",
                    "  const greatGreatGrandParent = path.getNode(4);",
                    "",
                    "  const isParameterInTestCall = grandparent != null && isTestCall(grandparent);",
                    "",
                    "  const shouldInline =",
                    "    isParameterInTestCall ||",
                    "    n[paramsKey].length === 0 ||",
                    "    (n[paramsKey].length === 1 &&",
                    "      (shouldHugType(n[paramsKey][0]) ||",
                    "        (n[paramsKey][0].type === \"GenericTypeAnnotation\" &&",
                    "          shouldHugType(n[paramsKey][0].id)) ||",
                    "        (n[paramsKey][0].type === \"TSTypeReference\" &&",
                    "          shouldHugType(n[paramsKey][0].typeName)) ||",
                    "        n[paramsKey][0].type === \"NullableTypeAnnotation\" ||",
                    "        // See https://github.com/prettier/prettier/pull/6467 for the context.",
                    "        (greatGreatGrandParent &&",
                    "          greatGreatGrandParent.type === \"VariableDeclarator\" &&",
                    "          grandparent.type === \"TSTypeAnnotation\" &&",
                    "          greatGrandParent.type !== \"ArrowFunctionExpression\" &&",
                    "          n[paramsKey][0].type !== \"TSUnionType\" &&",
                    "          n[paramsKey][0].type !== \"UnionTypeAnnotation\" &&",
                    "          n[paramsKey][0].type !== \"TSIntersectionType\" &&",
                    "          n[paramsKey][0].type !== \"IntersectionTypeAnnotation\" &&",
                    "          n[paramsKey][0].type !== \"TSConditionalType\" &&",
                    "          n[paramsKey][0].type !== \"TSMappedType\" &&",
                    "          n[paramsKey][0].type !== \"TSTypeOperator\" &&",
                    "          n[paramsKey][0].type !== \"TSIndexedAccessType\" &&",
                    "          n[paramsKey][0].type !== \"TSArrayType\")));",
                    "",
                    "  function printDanglingCommentsForInline(n) {",
                    "    if (!hasDanglingComments(n)) {",
                    "      return \"\";",
                    "    }",
                    "    const hasOnlyBlockComments = n.comments.every(",
                    "      handleComments.isBlockComment",
                    "    );",
                    "    const printed = comments.printDanglingComments(",
                    "      path,",
                    "      options,",
                    "      /* sameIndent */ hasOnlyBlockComments",
                    "    );",
                    "    if (hasOnlyBlockComments) {",
                    "      return printed;",
                    "    }",
                    "    return concat([printed, hardline]);",
                    "  }",
                    "",
                    "  if (shouldInline) {",
                    "    return concat([",
                    "      \"<\",",
                    "      join(\", \", path.map(print, paramsKey)),",
                    "      printDanglingCommentsForInline(n),",
                    "      \">\",",
                    "    ]);",
                    "  }",
                    "",
                    "  return group(",
                    "    concat([",
                    "      \"<\",",
                    "      indent(",
                    "        concat([",
                    "          softline,",
                    "          join(concat([\",\", line]), path.map(print, paramsKey)),",
                    "        ])",
                    "      ),",
                    "      ifBreak(",
                    "        options.parser !== \"typescript\" &&",
                    "          options.parser !== \"babel-ts\" &&",
                    "          shouldPrintComma(options, \"all\")",
                    "          ? \",\"",
                    "          : \"\"",
                    "      ),",
                    "      softline,",
                    "      \">\",",
                    "    ])",
                    "  );",
                    "}",
                    "",
                    "function printClass(path, options, print) {",
                    "  const n = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  if (n.abstract) {",
                    "    parts.push(\"abstract \");",
                    "  }",
                    "",
                    "  parts.push(\"class\");",
                    "",
                    "  // Keep old behaviour of extends in same line",
                    "  // If there is only on extends and there are not comments",
                    "  const groupMode =",
                    "    (n.id && hasTrailingComment(n.id)) ||",
                    "    (n.superClass &&",
                    "      n.superClass.comments &&",
                    "      n.superClass.comments.length !== 0) ||",
                    "    (n.extends && n.extends.length !== 0) || // DeclareClass",
                    "    (n.mixins && n.mixins.length !== 0) ||",
                    "    (n.implements && n.implements.length !== 0);",
                    "",
                    "  const partsGroup = [];",
                    "",
                    "  if (n.id) {",
                    "    partsGroup.push(\" \", path.call(print, \"id\"));",
                    "  }",
                    "",
                    "  partsGroup.push(path.call(print, \"typeParameters\"));",
                    "",
                    "  function printList(listName) {",
                    "    if (n[listName] && n[listName].length !== 0) {",
                    "      const printedLeadingComments = comments.printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameIndent */ true,",
                    "        ({ marker }) => marker === listName",
                    "      );",
                    "      partsGroup.push(",
                    "        line,",
                    "        printedLeadingComments,",
                    "        printedLeadingComments && hardline,",
                    "        listName,",
                    "        group(",
                    "          indent(",
                    "            concat([line, join(concat([\",\", line]), path.map(print, listName))])",
                    "          )",
                    "        )",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (n.superClass) {",
                    "    const printed = concat([",
                    "      \"extends \",",
                    "      path.call(print, \"superClass\"),",
                    "      path.call(print, \"superTypeParameters\"),",
                    "    ]);",
                    "    const printedWithComments = path.call(",
                    "      (superClass) =>",
                    "        comments.printComments(superClass, () => printed, options),",
                    "      \"superClass\"",
                    "    );",
                    "    if (groupMode) {",
                    "      partsGroup.push(line, group(printedWithComments));",
                    "    } else {",
                    "      partsGroup.push(\" \", printedWithComments);",
                    "    }",
                    "  } else {",
                    "    printList(\"extends\");",
                    "  }",
                    "",
                    "  printList(\"mixins\");",
                    "  printList(\"implements\");",
                    "",
                    "  if (groupMode) {",
                    "    parts.push(group(indent(concat(partsGroup))));",
                    "  } else {",
                    "    parts.push(...partsGroup);",
                    "  }",
                    "",
                    "  parts.push(\" \", path.call(print, \"body\"));",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function separatorNoWhitespace(",
                    "  isFacebookTranslationTag,",
                    "  child,",
                    "  childNode,",
                    "  nextNode",
                    ") {",
                    "  if (isFacebookTranslationTag) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (",
                    "    (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                    "    (nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement)",
                    "  ) {",
                    "    return child.length === 1 ? softline : hardline;",
                    "  }",
                    "",
                    "  return softline;",
                    "}",
                    "",
                    "function separatorWithWhitespace(",
                    "  isFacebookTranslationTag,",
                    "  child,",
                    "  childNode,",
                    "  nextNode",
                    ") {",
                    "  if (isFacebookTranslationTag) {",
                    "    return hardline;",
                    "  }",
                    "",
                    "  if (child.length === 1) {",
                    "    return (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                    "      (nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement)",
                    "      ? hardline",
                    "      : softline;",
                    "  }",
                    "",
                    "  return hardline;",
                    "}",
                    "",
                    "// JSX Children are strange, mostly for two reasons:",
                    "// 1. JSX reads newlines into string values, instead of skipping them like JS",
                    "// 2. up to one whitespace between elements within a line is significant,",
                    "//    but not between lines.",
                    "//",
                    "// Leading, trailing, and lone whitespace all need to",
                    "// turn themselves into the rather ugly `{' '}` when breaking.",
                    "//",
                    "// We print JSX using the `fill` doc primitive.",
                    "// This requires that we give it an array of alternating",
                    "// content and whitespace elements.",
                    "// To ensure this we add dummy `\"\"` content elements as needed.",
                    "function printJSXChildren(",
                    "  path,",
                    "  options,",
                    "  print,",
                    "  jsxWhitespace,",
                    "  isFacebookTranslationTag",
                    ") {",
                    "  const n = path.getValue();",
                    "  const children = [];",
                    "",
                    "  // using `map` instead of `each` because it provides `i`",
                    "  path.map((childPath, i) => {",
                    "    const child = childPath.getValue();",
                    "    if (isLiteral(child)) {",
                    "      const text = rawText(child);",
                    "",
                    "      // Contains a non-whitespace character",
                    "      if (isMeaningfulJSXText(child)) {",
                    "        const words = text.split(matchJsxWhitespaceRegex);",
                    "",
                    "        // Starts with whitespace",
                    "        if (words[0] === \"\") {",
                    "          children.push(\"\");",
                    "          words.shift();",
                    "          if (/\\n/.test(words[0])) {",
                    "            const next = n.children[i + 1];",
                    "            children.push(",
                    "              separatorWithWhitespace(",
                    "                isFacebookTranslationTag,",
                    "                words[1],",
                    "                child,",
                    "                next",
                    "              )",
                    "            );",
                    "          } else {",
                    "            children.push(jsxWhitespace);",
                    "          }",
                    "          words.shift();",
                    "        }",
                    "",
                    "        let endWhitespace;",
                    "        // Ends with whitespace",
                    "        if (getLast(words) === \"\") {",
                    "          words.pop();",
                    "          endWhitespace = words.pop();",
                    "        }",
                    "",
                    "        // This was whitespace only without a new line.",
                    "        if (words.length === 0) {",
                    "          return;",
                    "        }",
                    "",
                    "        words.forEach((word, i) => {",
                    "          if (i % 2 === 1) {",
                    "            children.push(line);",
                    "          } else {",
                    "            children.push(word);",
                    "          }",
                    "        });",
                    "",
                    "        if (endWhitespace !== undefined) {",
                    "          if (/\\n/.test(endWhitespace)) {",
                    "            const next = n.children[i + 1];",
                    "            children.push(",
                    "              separatorWithWhitespace(",
                    "                isFacebookTranslationTag,",
                    "                getLast(children),",
                    "                child,",
                    "                next",
                    "              )",
                    "            );",
                    "          } else {",
                    "            children.push(jsxWhitespace);",
                    "          }",
                    "        } else {",
                    "          const next = n.children[i + 1];",
                    "          children.push(",
                    "            separatorNoWhitespace(",
                    "              isFacebookTranslationTag,",
                    "              getLast(children),",
                    "              child,",
                    "              next",
                    "            )",
                    "          );",
                    "        }",
                    "      } else if (/\\n/.test(text)) {",
                    "        // Keep (up to one) blank line between tags/expressions/text.",
                    "        // Note: We don't keep blank lines between text elements.",
                    "        if (text.match(/\\n/g).length > 1) {",
                    "          children.push(\"\");",
                    "          children.push(hardline);",
                    "        }",
                    "      } else {",
                    "        children.push(\"\");",
                    "        children.push(jsxWhitespace);",
                    "      }",
                    "    } else {",
                    "      const printedChild = print(childPath);",
                    "      children.push(printedChild);",
                    "",
                    "      const next = n.children[i + 1];",
                    "      const directlyFollowedByMeaningfulText =",
                    "        next && isMeaningfulJSXText(next);",
                    "      if (directlyFollowedByMeaningfulText) {",
                    "        const firstWord = rawText(next)",
                    "          .trim()",
                    "          .split(matchJsxWhitespaceRegex)[0];",
                    "        children.push(",
                    "          separatorNoWhitespace(",
                    "            isFacebookTranslationTag,",
                    "            firstWord,",
                    "            child,",
                    "            next",
                    "          )",
                    "        );",
                    "      } else {",
                    "        children.push(hardline);",
                    "      }",
                    "    }",
                    "  }, \"children\");",
                    "",
                    "  return children;",
                    "}",
                    "",
                    "// JSX expands children from the inside-out, instead of the outside-in.",
                    "// This is both to break children before attributes,",
                    "// and to ensure that when children break, their parents do as well.",
                    "//",
                    "// Any element that is written without any newlines and fits on a single line",
                    "// is left that way.",
                    "// Not only that, any user-written-line containing multiple JSX siblings",
                    "// should also be kept on one line if possible,",
                    "// so each user-written-line is wrapped in its own group.",
                    "//",
                    "// Elements that contain newlines or don't fit on a single line (recursively)",
                    "// are fully-split, using hardline and shouldBreak: true.",
                    "//",
                    "// To support that case properly, all leading and trailing spaces",
                    "// are stripped from the list of children, and replaced with a single hardline.",
                    "function printJSXElement(path, options, print) {",
                    "  const n = path.getValue();",
                    "",
                    "  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {",
                    "    return concat([",
                    "      path.call(print, \"openingElement\"),",
                    "      path.call(print, \"closingElement\"),",
                    "    ]);",
                    "  }",
                    "",
                    "  const openingLines =",
                    "    n.type === \"JSXElement\"",
                    "      ? path.call(print, \"openingElement\")",
                    "      : path.call(print, \"openingFragment\");",
                    "  const closingLines =",
                    "    n.type === \"JSXElement\"",
                    "      ? path.call(print, \"closingElement\")",
                    "      : path.call(print, \"closingFragment\");",
                    "",
                    "  if (",
                    "    n.children.length === 1 &&",
                    "    n.children[0].type === \"JSXExpressionContainer\" &&",
                    "    (n.children[0].expression.type === \"TemplateLiteral\" ||",
                    "      n.children[0].expression.type === \"TaggedTemplateExpression\")",
                    "  ) {",
                    "    return concat([",
                    "      openingLines,",
                    "      concat(path.map(print, \"children\")),",
                    "      closingLines,",
                    "    ]);",
                    "  }",
                    "",
                    "  // Convert `{\" \"}` to text nodes containing a space.",
                    "  // This makes it easy to turn them into `jsxWhitespace` which",
                    "  // can then print as either a space or `{\" \"}` when breaking.",
                    "  n.children = n.children.map((child) => {",
                    "    if (isJSXWhitespaceExpression(child)) {",
                    "      return {",
                    "        type: \"JSXText\",",
                    "        value: \" \",",
                    "        raw: \" \",",
                    "      };",
                    "    }",
                    "    return child;",
                    "  });",
                    "",
                    "  const containsTag = n.children.filter(isJSXNode).length > 0;",
                    "  const containsMultipleExpressions =",
                    "    n.children.filter((child) => child.type === \"JSXExpressionContainer\")",
                    "      .length > 1;",
                    "  const containsMultipleAttributes =",
                    "    n.type === \"JSXElement\" && n.openingElement.attributes.length > 1;",
                    "",
                    "  // Record any breaks. Should never go from true to false, only false to true.",
                    "  let forcedBreak =",
                    "    willBreak(openingLines) ||",
                    "    containsTag ||",
                    "    containsMultipleAttributes ||",
                    "    containsMultipleExpressions;",
                    "",
                    "  const isMdxBlock = path.getParentNode().rootMarker === \"mdx\";",
                    "",
                    "  const rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';",
                    "  const jsxWhitespace = isMdxBlock",
                    "    ? concat([\" \"])",
                    "    : ifBreak(concat([rawJsxWhitespace, softline]), \" \");",
                    "",
                    "  const isFacebookTranslationTag =",
                    "    n.openingElement &&",
                    "    n.openingElement.name &&",
                    "    n.openingElement.name.name === \"fbt\";",
                    "",
                    "  const children = printJSXChildren(",
                    "    path,",
                    "    options,",
                    "    print,",
                    "    jsxWhitespace,",
                    "    isFacebookTranslationTag",
                    "  );",
                    "",
                    "  const containsText = n.children.some((child) => isMeaningfulJSXText(child));",
                    "",
                    "  // We can end up we multiple whitespace elements with empty string",
                    "  // content between them.",
                    "  // We need to remove empty whitespace and softlines before JSX whitespace",
                    "  // to get the correct output.",
                    "  for (let i = children.length - 2; i >= 0; i--) {",
                    "    const isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";",
                    "    const isPairOfHardlines =",
                    "      children[i] === hardline &&",
                    "      children[i + 1] === \"\" &&",
                    "      children[i + 2] === hardline;",
                    "    const isLineFollowedByJSXWhitespace =",
                    "      (children[i] === softline || children[i] === hardline) &&",
                    "      children[i + 1] === \"\" &&",
                    "      children[i + 2] === jsxWhitespace;",
                    "    const isJSXWhitespaceFollowedByLine =",
                    "      children[i] === jsxWhitespace &&",
                    "      children[i + 1] === \"\" &&",
                    "      (children[i + 2] === softline || children[i + 2] === hardline);",
                    "    const isDoubleJSXWhitespace =",
                    "      children[i] === jsxWhitespace &&",
                    "      children[i + 1] === \"\" &&",
                    "      children[i + 2] === jsxWhitespace;",
                    "    const isPairOfHardOrSoftLines =",
                    "      (children[i] === softline &&",
                    "        children[i + 1] === \"\" &&",
                    "        children[i + 2] === hardline) ||",
                    "      (children[i] === hardline &&",
                    "        children[i + 1] === \"\" &&",
                    "        children[i + 2] === softline);",
                    "",
                    "    if (",
                    "      (isPairOfHardlines && containsText) ||",
                    "      isPairOfEmptyStrings ||",
                    "      isLineFollowedByJSXWhitespace ||",
                    "      isDoubleJSXWhitespace ||",
                    "      isPairOfHardOrSoftLines",
                    "    ) {",
                    "      children.splice(i, 2);",
                    "    } else if (isJSXWhitespaceFollowedByLine) {",
                    "      children.splice(i + 1, 2);",
                    "    }",
                    "  }",
                    "",
                    "  // Trim trailing lines (or empty strings)",
                    "  while (",
                    "    children.length &&",
                    "    (isLineNext(getLast(children)) || isEmpty(getLast(children)))",
                    "  ) {",
                    "    children.pop();",
                    "  }",
                    "",
                    "  // Trim leading lines (or empty strings)",
                    "  while (",
                    "    children.length &&",
                    "    (isLineNext(children[0]) || isEmpty(children[0])) &&",
                    "    (isLineNext(children[1]) || isEmpty(children[1]))",
                    "  ) {",
                    "    children.shift();",
                    "    children.shift();",
                    "  }",
                    "",
                    "  // Tweak how we format children if outputting this element over multiple lines.",
                    "  // Also detect whether we will force this element to output over multiple lines.",
                    "  const multilineChildren = [];",
                    "  children.forEach((child, i) => {",
                    "    // There are a number of situations where we need to ensure we display",
                    "    // whitespace as `{\" \"}` when outputting this element over multiple lines.",
                    "    if (child === jsxWhitespace) {",
                    "      if (i === 1 && children[i - 1] === \"\") {",
                    "        if (children.length === 2) {",
                    "          // Solitary whitespace",
                    "          multilineChildren.push(rawJsxWhitespace);",
                    "          return;",
                    "        }",
                    "        // Leading whitespace",
                    "        multilineChildren.push(concat([rawJsxWhitespace, hardline]));",
                    "        return;",
                    "      } else if (i === children.length - 1) {",
                    "        // Trailing whitespace",
                    "        multilineChildren.push(rawJsxWhitespace);",
                    "        return;",
                    "      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {",
                    "        // Whitespace after line break",
                    "        multilineChildren.push(rawJsxWhitespace);",
                    "        return;",
                    "      }",
                    "    }",
                    "",
                    "    multilineChildren.push(child);",
                    "",
                    "    if (willBreak(child)) {",
                    "      forcedBreak = true;",
                    "    }",
                    "  });",
                    "",
                    "  // If there is text we use `fill` to fit as much onto each line as possible.",
                    "  // When there is no text (just tags and expressions) we use `group`",
                    "  // to output each on a separate line.",
                    "  const content = containsText",
                    "    ? fill(multilineChildren)",
                    "    : group(concat(multilineChildren), { shouldBreak: true });",
                    "",
                    "  if (isMdxBlock) {",
                    "    return content;",
                    "  }",
                    "",
                    "  const multiLineElem = group(",
                    "    concat([",
                    "      openingLines,",
                    "      indent(concat([hardline, content])),",
                    "      hardline,",
                    "      closingLines,",
                    "    ])",
                    "  );",
                    "",
                    "  if (forcedBreak) {",
                    "    return multiLineElem;",
                    "  }",
                    "",
                    "  return conditionalGroup([",
                    "    group(concat([openingLines, concat(children), closingLines])),",
                    "    multiLineElem,",
                    "  ]);",
                    "}",
                    "",
                    "function maybeWrapJSXElementInParens(path, elem, options) {",
                    "  const parent = path.getParentNode();",
                    "  if (!parent) {",
                    "    return elem;",
                    "  }",
                    "",
                    "  const NO_WRAP_PARENTS = {",
                    "    ArrayExpression: true,",
                    "    JSXAttribute: true,",
                    "    JSXElement: true,",
                    "    JSXExpressionContainer: true,",
                    "    JSXFragment: true,",
                    "    ExpressionStatement: true,",
                    "    CallExpression: true,",
                    "    OptionalCallExpression: true,",
                    "    ConditionalExpression: true,",
                    "    JsExpressionRoot: true,",
                    "  };",
                    "  if (NO_WRAP_PARENTS[parent.type]) {",
                    "    return elem;",
                    "  }",
                    "",
                    "  const shouldBreak = path.match(",
                    "    undefined,",
                    "    (node) => node.type === \"ArrowFunctionExpression\",",
                    "    isCallOrOptionalCallExpression,",
                    "    (node) => node.type === \"JSXExpressionContainer\"",
                    "  );",
                    "",
                    "  const needsParens = pathNeedsParens(path, options);",
                    "",
                    "  return group(",
                    "    concat([",
                    "      needsParens ? \"\" : ifBreak(\"(\"),",
                    "      indent(concat([softline, elem])),",
                    "      softline,",
                    "      needsParens ? \"\" : ifBreak(\")\"),",
                    "    ]),",
                    "    { shouldBreak }",
                    "  );",
                    "}",
                    "",
                    "function shouldInlineLogicalExpression(node) {",
                    "  if (node.type !== \"LogicalExpression\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.right.type === \"ObjectExpression\" &&",
                    "    node.right.properties.length !== 0",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    node.right.type === \"ArrayExpression\" &&",
                    "    node.right.elements.length !== 0",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (isJSXNode(node.right)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "// For binary expressions to be consistent, we need to group",
                    "// subsequent operators with the same precedence level under a single",
                    "// group. Otherwise they will be nested such that some of them break",
                    "// onto new lines but not all. Operators with the same precedence",
                    "// level should either all break or not. Because we group them by",
                    "// precedence level and the AST is structured based on precedence",
                    "// level, things are naturally broken up correctly, i.e. `&&` is",
                    "// broken before `+`.",
                    "function printBinaryishExpressions(",
                    "  path,",
                    "  print,",
                    "  options,",
                    "  isNested,",
                    "  isInsideParenthesis",
                    ") {",
                    "  let parts = [];",
                    "  const node = path.getValue();",
                    "",
                    "  // We treat BinaryExpression and LogicalExpression nodes the same.",
                    "  if (isBinaryish(node)) {",
                    "    // Put all operators with the same precedence level in the same",
                    "    // group. The reason we only need to do this with the `left`",
                    "    // expression is because given an expression like `1 + 2 - 3`, it",
                    "    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side",
                    "    // is where the rest of the expression will exist. Binary",
                    "    // expressions on the right side mean they have a difference",
                    "    // precedence level and should be treated as a separate group, so",
                    "    // print them normally. (This doesn't hold for the `**` operator,",
                    "    // which is unique in that it is right-associative.)",
                    "    if (shouldFlatten(node.operator, node.left.operator)) {",
                    "      // Flatten them out by recursively calling this function.",
                    "      parts = parts.concat(",
                    "        path.call(",
                    "          (left) =>",
                    "            printBinaryishExpressions(",
                    "              left,",
                    "              print,",
                    "              options,",
                    "              /* isNested */ true,",
                    "              isInsideParenthesis",
                    "            ),",
                    "          \"left\"",
                    "        )",
                    "      );",
                    "    } else {",
                    "      parts.push(group(path.call(print, \"left\")));",
                    "    }",
                    "",
                    "    const shouldInline = shouldInlineLogicalExpression(node);",
                    "    const lineBeforeOperator =",
                    "      (node.operator === \"|>\" ||",
                    "        node.type === \"NGPipeExpression\" ||",
                    "        (node.operator === \"|\" && options.parser === \"__vue_expression\")) &&",
                    "      !hasLeadingOwnLineComment(options.originalText, node.right, options);",
                    "",
                    "    const operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;",
                    "    const rightSuffix =",
                    "      node.type === \"NGPipeExpression\" && node.arguments.length !== 0",
                    "        ? group(",
                    "            indent(",
                    "              concat([",
                    "                softline,",
                    "                \": \",",
                    "                join(",
                    "                  concat([softline, \":\", ifBreak(\" \")]),",
                    "                  path",
                    "                    .map(print, \"arguments\")",
                    "                    .map((arg) => align(2, group(arg)))",
                    "                ),",
                    "              ])",
                    "            )",
                    "          )",
                    "        : \"\";",
                    "",
                    "    const right = shouldInline",
                    "      ? concat([operator, \" \", path.call(print, \"right\"), rightSuffix])",
                    "      : concat([",
                    "          lineBeforeOperator ? line : \"\",",
                    "          operator,",
                    "          lineBeforeOperator ? \" \" : line,",
                    "          path.call(print, \"right\"),",
                    "          rightSuffix,",
                    "        ]);",
                    "",
                    "    // If there's only a single binary expression, we want to create a group",
                    "    // in order to avoid having a small right part like -1 be on its own line.",
                    "    const parent = path.getParentNode();",
                    "    const shouldBreak = hasTrailingLineComment(node.left);",
                    "    const shouldGroup =",
                    "      shouldBreak ||",
                    "      (!(isInsideParenthesis && node.type === \"LogicalExpression\") &&",
                    "        parent.type !== node.type &&",
                    "        node.left.type !== node.type &&",
                    "        node.right.type !== node.type);",
                    "",
                    "    parts.push(",
                    "      lineBeforeOperator ? \"\" : \" \",",
                    "      shouldGroup ? group(right, { shouldBreak }) : right",
                    "    );",
                    "",
                    "    // The root comments are already printed, but we need to manually print",
                    "    // the other ones since we don't call the normal print on BinaryExpression,",
                    "    // only for the left and right parts",
                    "    if (isNested && node.comments) {",
                    "      parts = normalizeParts(",
                    "        comments.printComments(path, () => concat(parts), options).parts",
                    "      );",
                    "    }",
                    "  } else {",
                    "    // Our stopping case. Simply print the node normally.",
                    "    parts.push(group(path.call(print)));",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printAssignmentRight(leftNode, rightNode, printedRight, options) {",
                    "  if (hasLeadingOwnLineComment(options.originalText, rightNode, options)) {",
                    "    return indent(concat([line, printedRight]));",
                    "  }",
                    "",
                    "  const canBreak =",
                    "    (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) ||",
                    "    (rightNode.type === \"ConditionalExpression\" &&",
                    "      isBinaryish(rightNode.test) &&",
                    "      !shouldInlineLogicalExpression(rightNode.test)) ||",
                    "    rightNode.type === \"StringLiteralTypeAnnotation\" ||",
                    "    (rightNode.type === \"ClassExpression\" &&",
                    "      rightNode.decorators &&",
                    "      rightNode.decorators.length) ||",
                    "    ((leftNode.type === \"Identifier\" ||",
                    "      isStringLiteral(leftNode) ||",
                    "      leftNode.type === \"MemberExpression\") &&",
                    "      (isStringLiteral(rightNode) || isMemberExpressionChain(rightNode)) &&",
                    "      // do not put values on a separate line from the key in json",
                    "      options.parser !== \"json\" &&",
                    "      options.parser !== \"json5\") ||",
                    "    rightNode.type === \"SequenceExpression\";",
                    "",
                    "  if (canBreak) {",
                    "    return group(indent(concat([line, printedRight])));",
                    "  }",
                    "",
                    "  return concat([\" \", printedRight]);",
                    "}",
                    "",
                    "function printAssignment(",
                    "  leftNode,",
                    "  printedLeft,",
                    "  operator,",
                    "  rightNode,",
                    "  printedRight,",
                    "  options",
                    ") {",
                    "  if (!rightNode) {",
                    "    return printedLeft;",
                    "  }",
                    "",
                    "  const printed = printAssignmentRight(",
                    "    leftNode,",
                    "    rightNode,",
                    "    printedRight,",
                    "    options",
                    "  );",
                    "",
                    "  return group(concat([printedLeft, operator, printed]));",
                    "}",
                    "",
                    "function adjustClause(node, clause, forceSpace) {",
                    "  if (node.type === \"EmptyStatement\") {",
                    "    return \";\";",
                    "  }",
                    "",
                    "  if (node.type === \"BlockStatement\" || forceSpace) {",
                    "    return concat([\" \", clause]);",
                    "  }",
                    "",
                    "  return indent(concat([line, clause]));",
                    "}",
                    "",
                    "function nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {",
                    "  const raw = rawText(node);",
                    "  const isDirectiveLiteral =",
                    "    isFlowOrTypeScriptDirectiveLiteral || node.type === \"DirectiveLiteral\";",
                    "  return printString(raw, options, isDirectiveLiteral);",
                    "}",
                    "",
                    "function printRegex(node) {",
                    "  const flags = node.flags.split(\"\").sort().join(\"\");",
                    "  return `/${node.pattern}/${flags}`;",
                    "}",
                    "",
                    "function exprNeedsASIProtection(path, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  const maybeASIProblem =",
                    "    pathNeedsParens(path, options) ||",
                    "    node.type === \"ParenthesizedExpression\" ||",
                    "    node.type === \"TypeCastExpression\" ||",
                    "    (node.type === \"ArrowFunctionExpression\" &&",
                    "      !shouldPrintParamsWithoutParens(path, options)) ||",
                    "    node.type === \"ArrayExpression\" ||",
                    "    node.type === \"ArrayPattern\" ||",
                    "    (node.type === \"UnaryExpression\" &&",
                    "      node.prefix &&",
                    "      (node.operator === \"+\" || node.operator === \"-\")) ||",
                    "    node.type === \"TemplateLiteral\" ||",
                    "    node.type === \"TemplateElement\" ||",
                    "    isJSXNode(node) ||",
                    "    (node.type === \"BindExpression\" && !node.object) ||",
                    "    node.type === \"RegExpLiteral\" ||",
                    "    (node.type === \"Literal\" && node.pattern) ||",
                    "    (node.type === \"Literal\" && node.regex);",
                    "",
                    "  if (maybeASIProblem) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (!hasNakedLeftSide(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call(",
                    "    (childPath) => exprNeedsASIProtection(childPath, options),",
                    "    ...getLeftSidePathName(path, node)",
                    "  );",
                    "}",
                    "",
                    "function stmtNeedsASIProtection(path, options) {",
                    "  const node = path.getNode();",
                    "",
                    "  if (node.type !== \"ExpressionStatement\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call(",
                    "    (childPath) => exprNeedsASIProtection(childPath, options),",
                    "    \"expression\"",
                    "  );",
                    "}",
                    "",
                    "function shouldHugType(node) {",
                    "  if (isSimpleFlowType(node) || isObjectType(node)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {",
                    "    const voidCount = node.types.filter(",
                    "      (n) =>",
                    "        n.type === \"VoidTypeAnnotation\" ||",
                    "        n.type === \"TSVoidKeyword\" ||",
                    "        n.type === \"NullLiteralTypeAnnotation\" ||",
                    "        n.type === \"TSNullKeyword\"",
                    "    ).length;",
                    "",
                    "    const hasObject = node.types.some(",
                    "      (n) =>",
                    "        n.type === \"ObjectTypeAnnotation\" ||",
                    "        n.type === \"TSTypeLiteral\" ||",
                    "        // This is a bit aggressive but captures Array<{x}>",
                    "        n.type === \"GenericTypeAnnotation\" ||",
                    "        n.type === \"TSTypeReference\"",
                    "    );",
                    "",
                    "    if (node.types.length - 1 === voidCount && hasObject) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function shouldHugArguments(fun) {",
                    "  if (!fun || fun.rest) {",
                    "    return false;",
                    "  }",
                    "  const params = fun.params || fun.parameters;",
                    "  if (!params || params.length !== 1) {",
                    "    return false;",
                    "  }",
                    "  const param = params[0];",
                    "  return (",
                    "    !param.comments &&",
                    "    (param.type === \"ObjectPattern\" ||",
                    "      param.type === \"ArrayPattern\" ||",
                    "      (param.type === \"Identifier\" &&",
                    "        param.typeAnnotation &&",
                    "        (param.typeAnnotation.type === \"TypeAnnotation\" ||",
                    "          param.typeAnnotation.type === \"TSTypeAnnotation\") &&",
                    "        isObjectType(param.typeAnnotation.typeAnnotation)) ||",
                    "      (param.type === \"FunctionTypeParam\" &&",
                    "        isObjectType(param.typeAnnotation)) ||",
                    "      (param.type === \"AssignmentPattern\" &&",
                    "        (param.left.type === \"ObjectPattern\" ||",
                    "          param.left.type === \"ArrayPattern\") &&",
                    "        (param.right.type === \"Identifier\" ||",
                    "          (param.right.type === \"ObjectExpression\" &&",
                    "            param.right.properties.length === 0) ||",
                    "          (param.right.type === \"ArrayExpression\" &&",
                    "            param.right.elements.length === 0))))",
                    "  );",
                    "}",
                    "",
                    "function printArrayItems(path, options, printPath, print) {",
                    "  const printedElements = [];",
                    "  let separatorParts = [];",
                    "",
                    "  path.each((childPath) => {",
                    "    printedElements.push(concat(separatorParts));",
                    "    printedElements.push(group(print(childPath)));",
                    "",
                    "    separatorParts = [\",\", line];",
                    "    if (",
                    "      childPath.getValue() &&",
                    "      isNextLineEmpty(",
                    "        options.originalText,",
                    "        childPath.getValue(),",
                    "        options.locEnd",
                    "      )",
                    "    ) {",
                    "      separatorParts.push(softline);",
                    "    }",
                    "  }, printPath);",
                    "",
                    "  return concat(printedElements);",
                    "}",
                    "",
                    "function printReturnAndThrowArgument(path, options, print) {",
                    "  const node = path.getValue();",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "  const parts = [];",
                    "",
                    "  if (node.argument) {",
                    "    if (returnArgumentHasLeadingComment(options, node.argument)) {",
                    "      parts.push(",
                    "        concat([",
                    "          \" (\",",
                    "          indent(concat([hardline, path.call(print, \"argument\")])),",
                    "          hardline,",
                    "          \")\",",
                    "        ])",
                    "      );",
                    "    } else if (",
                    "      isBinaryish(node.argument) ||",
                    "      node.argument.type === \"SequenceExpression\"",
                    "    ) {",
                    "      parts.push(",
                    "        group(",
                    "          concat([",
                    "            ifBreak(\" (\", \" \"),",
                    "            indent(concat([softline, path.call(print, \"argument\")])),",
                    "            softline,",
                    "            ifBreak(\")\"),",
                    "          ])",
                    "        )",
                    "      );",
                    "    } else {",
                    "      parts.push(\" \", path.call(print, \"argument\"));",
                    "    }",
                    "  }",
                    "",
                    "  const lastComment =",
                    "    Array.isArray(node.comments) && node.comments[node.comments.length - 1];",
                    "  const isLastCommentLine =",
                    "    lastComment &&",
                    "    (lastComment.type === \"CommentLine\" || lastComment.type === \"Line\");",
                    "",
                    "  if (isLastCommentLine) {",
                    "    parts.push(semi);",
                    "  }",
                    "",
                    "  if (hasDanglingComments(node)) {",
                    "    parts.push(",
                    "      \" \",",
                    "      comments.printDanglingComments(path, options, /* sameIndent */ true)",
                    "    );",
                    "  }",
                    "",
                    "  if (!isLastCommentLine) {",
                    "    parts.push(semi);",
                    "  }",
                    "",
                    "  return concat(parts);",
                    "}",
                    "",
                    "function willPrintOwnComments(path /*, options */) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  return (",
                    "    ((node &&",
                    "      (isJSXNode(node) ||",
                    "        hasFlowShorthandAnnotationComment(node) ||",
                    "        (parent &&",
                    "          (parent.type === \"CallExpression\" ||",
                    "            parent.type === \"OptionalCallExpression\") &&",
                    "          (hasFlowAnnotationComment(node.leadingComments) ||",
                    "            hasFlowAnnotationComment(node.trailingComments))))) ||",
                    "      (parent &&",
                    "        (parent.type === \"JSXSpreadAttribute\" ||",
                    "          parent.type === \"JSXSpreadChild\" ||",
                    "          parent.type === \"UnionTypeAnnotation\" ||",
                    "          parent.type === \"TSUnionType\" ||",
                    "          ((parent.type === \"ClassDeclaration\" ||",
                    "            parent.type === \"ClassExpression\") &&",
                    "            parent.superClass === node)))) &&",
                    "    (!hasIgnoreComment(path) ||",
                    "      parent.type === \"UnionTypeAnnotation\" ||",
                    "      parent.type === \"TSUnionType\")",
                    "  );",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return (",
                    "    node.type &&",
                    "    node.type !== \"CommentBlock\" &&",
                    "    node.type !== \"CommentLine\" &&",
                    "    node.type !== \"Line\" &&",
                    "    node.type !== \"Block\" &&",
                    "    node.type !== \"EmptyStatement\" &&",
                    "    node.type !== \"TemplateElement\" &&",
                    "    node.type !== \"Import\"",
                    "  );",
                    "}",
                    "",
                    "function printComment(commentPath, options) {",
                    "  const comment = commentPath.getValue();",
                    "",
                    "  switch (comment.type) {",
                    "    case \"CommentBlock\":",
                    "    case \"Block\": {",
                    "      if (isIndentableBlockComment(comment)) {",
                    "        const printed = printIndentableBlockComment(comment);",
                    "        // We need to prevent an edge case of a previous trailing comment",
                    "        // printed as a `lineSuffix` which causes the comments to be",
                    "        // interleaved. See https://github.com/prettier/prettier/issues/4412",
                    "        if (",
                    "          comment.trailing &&",
                    "          !hasNewline(options.originalText, options.locStart(comment), {",
                    "            backwards: true,",
                    "          })",
                    "        ) {",
                    "          return concat([hardline, printed]);",
                    "        }",
                    "        return printed;",
                    "      }",
                    "",
                    "      const commentEnd = options.locEnd(comment);",
                    "      const isInsideFlowComment =",
                    "        options.originalText.slice(commentEnd - 3, commentEnd) === \"*-/\";",
                    "",
                    "      return \"/*\" + comment.value + (isInsideFlowComment ? \"*-/\" : \"*/\");",
                    "    }",
                    "    case \"CommentLine\":",
                    "    case \"Line\":",
                    "      // Supports `//`, `#!`, `<!--`, and `-->`",
                    "      return options.originalText",
                    "        .slice(options.locStart(comment), options.locEnd(comment))",
                    "        .trimEnd();",
                    "    default:",
                    "      throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                    "  }",
                    "}",
                    "",
                    "function isIndentableBlockComment(comment) {",
                    "  // If the comment has multiple lines and every line starts with a star",
                    "  // we can fix the indentation of each line. The stars in the `/*` and",
                    "  // `*/` delimiters are not included in the comment value, so add them",
                    "  // back first.",
                    "  const lines = `*${comment.value}*`.split(\"\\n\");",
                    "  return lines.length > 1 && lines.every((line) => line.trim()[0] === \"*\");",
                    "}",
                    "",
                    "function printIndentableBlockComment(comment) {",
                    "  const lines = comment.value.split(\"\\n\");",
                    "",
                    "  return concat([",
                    "    \"/*\",",
                    "    join(",
                    "      hardline,",
                    "      lines.map((line, index) =>",
                    "        index === 0",
                    "          ? line.trimEnd()",
                    "          : \" \" + (index < lines.length - 1 ? line.trim() : line.trimStart())",
                    "      )",
                    "    ),",
                    "    \"*/\",",
                    "  ]);",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  willPrintOwnComments,",
                    "  canAttachComment,",
                    "  printComment,",
                    "  isBlockComment: handleComments.isBlockComment,",
                    "  handleComments: {",
                    "    ownLine: handleComments.handleOwnLineComment,",
                    "    endOfLine: handleComments.handleEndOfLineComment,",
                    "    remaining: handleComments.handleRemainingComment,",
                    "  },",
                    "  getGapRegex: handleComments.getGapRegex,",
                    "  getCommentChildNodes: handleComments.getCommentChildNodes,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getLast,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasIgnoreComment,",
                    "  hasNodeIgnoreComment,",
                    "  skipWhitespace,",
                    "} = require(\"../common/util\");",
                    "const isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;",
                    "const handleComments = require(\"./comments\");",
                    "",
                    "// We match any whitespace except line terminators because",
                    "// Flow annotation comments cannot be split across lines. For example:",
                    "//",
                    "// (this /*",
                    "// : any */).foo = 5;",
                    "//",
                    "// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so",
                    "// removing the newline would create a type annotation that the user did not intend",
                    "// to create.",
                    "const NON_LINE_TERMINATING_WHITE_SPACE = \"(?:(?=.)\\\\s)\";",
                    "const FLOW_SHORTHAND_ANNOTATION = new RegExp(",
                    "  `^${NON_LINE_TERMINATING_WHITE_SPACE}*:`",
                    ");",
                    "const FLOW_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*::`);",
                    "",
                    "function hasFlowShorthandAnnotationComment(node) {",
                    "  // https://flow.org/en/docs/types/comments/",
                    "  // Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");",
                    "",
                    "  return (",
                    "    node.extra &&",
                    "    node.extra.parenthesized &&",
                    "    node.trailingComments &&",
                    "    node.trailingComments[0].value.match(FLOW_SHORTHAND_ANNOTATION)",
                    "  );",
                    "}",
                    "",
                    "function hasFlowAnnotationComment(comments) {",
                    "  return comments && comments[0].value.match(FLOW_ANNOTATION);",
                    "}",
                    "",
                    "function hasNode(node, fn) {",
                    "  if (!node || typeof node !== \"object\") {",
                    "    return false;",
                    "  }",
                    "  if (Array.isArray(node)) {",
                    "    return node.some((value) => hasNode(value, fn));",
                    "  }",
                    "  const result = fn(node);",
                    "  return typeof result === \"boolean\"",
                    "    ? result",
                    "    : Object.keys(node).some((key) => hasNode(node[key], fn));",
                    "}",
                    "",
                    "function hasNakedLeftSide(node) {",
                    "  return (",
                    "    node.type === \"AssignmentExpression\" ||",
                    "    node.type === \"BinaryExpression\" ||",
                    "    node.type === \"LogicalExpression\" ||",
                    "    node.type === \"NGPipeExpression\" ||",
                    "    node.type === \"ConditionalExpression\" ||",
                    "    node.type === \"CallExpression\" ||",
                    "    node.type === \"OptionalCallExpression\" ||",
                    "    node.type === \"MemberExpression\" ||",
                    "    node.type === \"OptionalMemberExpression\" ||",
                    "    node.type === \"SequenceExpression\" ||",
                    "    node.type === \"TaggedTemplateExpression\" ||",
                    "    node.type === \"BindExpression\" ||",
                    "    (node.type === \"UpdateExpression\" && !node.prefix) ||",
                    "    node.type === \"TSAsExpression\" ||",
                    "    node.type === \"TSNonNullExpression\"",
                    "  );",
                    "}",
                    "",
                    "function getLeftSide(node) {",
                    "  if (node.expressions) {",
                    "    return node.expressions[0];",
                    "  }",
                    "  return (",
                    "    node.left ||",
                    "    node.test ||",
                    "    node.callee ||",
                    "    node.object ||",
                    "    node.tag ||",
                    "    node.argument ||",
                    "    node.expression",
                    "  );",
                    "}",
                    "",
                    "function getLeftSidePathName(path, node) {",
                    "  if (node.expressions) {",
                    "    return [\"expressions\", 0];",
                    "  }",
                    "  if (node.left) {",
                    "    return [\"left\"];",
                    "  }",
                    "  if (node.test) {",
                    "    return [\"test\"];",
                    "  }",
                    "  if (node.object) {",
                    "    return [\"object\"];",
                    "  }",
                    "  if (node.callee) {",
                    "    return [\"callee\"];",
                    "  }",
                    "  if (node.tag) {",
                    "    return [\"tag\"];",
                    "  }",
                    "  if (node.argument) {",
                    "    return [\"argument\"];",
                    "  }",
                    "  if (node.expression) {",
                    "    return [\"expression\"];",
                    "  }",
                    "  throw new Error(\"Unexpected node has no left side\", node);",
                    "}",
                    "",
                    "const exportDeclarationTypes = new Set([",
                    "  \"ExportDefaultDeclaration\",",
                    "  \"ExportDefaultSpecifier\",",
                    "  \"DeclareExportDeclaration\",",
                    "  \"ExportNamedDeclaration\",",
                    "  \"ExportAllDeclaration\",",
                    "]);",
                    "function isExportDeclaration(node) {",
                    "  return node && exportDeclarationTypes.has(node.type);",
                    "}",
                    "",
                    "function getParentExportDeclaration(path) {",
                    "  const parentNode = path.getParentNode();",
                    "  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {",
                    "    return parentNode;",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function isLiteral(node) {",
                    "  return (",
                    "    node.type === \"BooleanLiteral\" ||",
                    "    node.type === \"DirectiveLiteral\" ||",
                    "    node.type === \"Literal\" ||",
                    "    node.type === \"NullLiteral\" ||",
                    "    node.type === \"NumericLiteral\" ||",
                    "    node.type === \"BigIntLiteral\" ||",
                    "    node.type === \"RegExpLiteral\" ||",
                    "    node.type === \"StringLiteral\" ||",
                    "    node.type === \"TemplateLiteral\" ||",
                    "    node.type === \"TSTypeLiteral\" ||",
                    "    node.type === \"JSXText\"",
                    "  );",
                    "}",
                    "",
                    "function isLiteralLikeValue(node) {",
                    "  return (",
                    "    isLiteral(node) ||",
                    "    (node.type === \"Identifier\" && /^[A-Z_]+$/.test(node.name)) ||",
                    "    (node.type === \"ArrayExpression\" &&",
                    "      node.elements.every(",
                    "        (element) => element !== null && isLiteralLikeValue(element)",
                    "      )) ||",
                    "    (node.type === \"ObjectExpression\" &&",
                    "      node.properties.every(",
                    "        (property) =>",
                    "          !property.computed &&",
                    "          property.value &&",
                    "          isLiteralLikeValue(property.value)",
                    "      ))",
                    "  );",
                    "}",
                    "",
                    "function isNumericLiteral(node) {",
                    "  return (",
                    "    node.type === \"NumericLiteral\" ||",
                    "    (node.type === \"Literal\" && typeof node.value === \"number\")",
                    "  );",
                    "}",
                    "",
                    "function isStringLiteral(node) {",
                    "  return (",
                    "    node.type === \"StringLiteral\" ||",
                    "    (node.type === \"Literal\" && typeof node.value === \"string\")",
                    "  );",
                    "}",
                    "",
                    "function isObjectType(n) {",
                    "  return n.type === \"ObjectTypeAnnotation\" || n.type === \"TSTypeLiteral\";",
                    "}",
                    "",
                    "function isFunctionOrArrowExpression(node) {",
                    "  return (",
                    "    node.type === \"FunctionExpression\" ||",
                    "    node.type === \"ArrowFunctionExpression\"",
                    "  );",
                    "}",
                    "",
                    "function isFunctionOrArrowExpressionWithBody(node) {",
                    "  return (",
                    "    node.type === \"FunctionExpression\" ||",
                    "    (node.type === \"ArrowFunctionExpression\" &&",
                    "      node.body.type === \"BlockStatement\")",
                    "  );",
                    "}",
                    "",
                    "function isTemplateLiteral(node) {",
                    "  return node.type === \"TemplateLiteral\";",
                    "}",
                    "",
                    "// `inject` is used in AngularJS 1.x, `async` in Angular 2+",
                    "// example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-",
                    "function isAngularTestWrapper(node) {",
                    "  return (",
                    "    (node.type === \"CallExpression\" ||",
                    "      node.type === \"OptionalCallExpression\") &&",
                    "    node.callee.type === \"Identifier\" &&",
                    "    (node.callee.name === \"async\" ||",
                    "      node.callee.name === \"inject\" ||",
                    "      node.callee.name === \"fakeAsync\")",
                    "  );",
                    "}",
                    "",
                    "function isJSXNode(node) {",
                    "  return node.type === \"JSXElement\" || node.type === \"JSXFragment\";",
                    "}",
                    "",
                    "function isTheOnlyJSXElementInMarkdown(options, path) {",
                    "  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  const node = path.getNode();",
                    "",
                    "  if (!node.expression || !isJSXNode(node.expression)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const parent = path.getParentNode();",
                    "",
                    "  return parent.type === \"Program\" && parent.body.length === 1;",
                    "}",
                    "",
                    "// Detect an expression node representing `{\" \"}`",
                    "function isJSXWhitespaceExpression(node) {",
                    "  return (",
                    "    node.type === \"JSXExpressionContainer\" &&",
                    "    isLiteral(node.expression) &&",
                    "    node.expression.value === \" \" &&",
                    "    !node.expression.comments",
                    "  );",
                    "}",
                    "",
                    "function isMemberExpressionChain(node) {",
                    "  if (",
                    "    node.type !== \"MemberExpression\" &&",
                    "    node.type !== \"OptionalMemberExpression\"",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "  if (node.object.type === \"Identifier\") {",
                    "    return true;",
                    "  }",
                    "  return isMemberExpressionChain(node.object);",
                    "}",
                    "",
                    "function isGetterOrSetter(node) {",
                    "  return node.kind === \"get\" || node.kind === \"set\";",
                    "}",
                    "",
                    "function sameLocStart(nodeA, nodeB, options) {",
                    "  return options.locStart(nodeA) === options.locStart(nodeB);",
                    "}",
                    "",
                    "// TODO: This is a bad hack and we need a better way to distinguish between",
                    "// arrow functions and otherwise",
                    "function isFunctionNotation(node, options) {",
                    "  return isGetterOrSetter(node) || sameLocStart(node, node.value, options);",
                    "}",
                    "",
                    "// Hack to differentiate between the following two which have the same ast",
                    "// type T = { method: () => void };",
                    "// type T = { method(): void };",
                    "function isObjectTypePropertyAFunction(node, options) {",
                    "  return (",
                    "    (node.type === \"ObjectTypeProperty\" ||",
                    "      node.type === \"ObjectTypeInternalSlot\") &&",
                    "    node.value.type === \"FunctionTypeAnnotation\" &&",
                    "    !node.static &&",
                    "    !isFunctionNotation(node, options)",
                    "  );",
                    "}",
                    "",
                    "// Hack to differentiate between the following two which have the same ast",
                    "// declare function f(a): void;",
                    "// var f: (a) => void;",
                    "function isTypeAnnotationAFunction(node, options) {",
                    "  return (",
                    "    (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") &&",
                    "    node.typeAnnotation.type === \"FunctionTypeAnnotation\" &&",
                    "    !node.static &&",
                    "    !sameLocStart(node, node.typeAnnotation, options)",
                    "  );",
                    "}",
                    "",
                    "const binaryishNodeTypes = new Set([",
                    "  \"BinaryExpression\",",
                    "  \"LogicalExpression\",",
                    "  \"NGPipeExpression\",",
                    "]);",
                    "function isBinaryish(node) {",
                    "  return binaryishNodeTypes.has(node.type);",
                    "}",
                    "",
                    "function isMemberish(node) {",
                    "  return (",
                    "    node.type === \"MemberExpression\" ||",
                    "    node.type === \"OptionalMemberExpression\" ||",
                    "    (node.type === \"BindExpression\" && node.object)",
                    "  );",
                    "}",
                    "",
                    "const flowTypeAnnotations = new Set([",
                    "  \"AnyTypeAnnotation\",",
                    "  \"NullLiteralTypeAnnotation\",",
                    "  \"GenericTypeAnnotation\",",
                    "  \"ThisTypeAnnotation\",",
                    "  \"NumberTypeAnnotation\",",
                    "  \"VoidTypeAnnotation\",",
                    "  \"EmptyTypeAnnotation\",",
                    "  \"MixedTypeAnnotation\",",
                    "  \"BooleanTypeAnnotation\",",
                    "  \"BooleanLiteralTypeAnnotation\",",
                    "  \"StringTypeAnnotation\",",
                    "]);",
                    "function isSimpleFlowType(node) {",
                    "  return (",
                    "    node &&",
                    "    flowTypeAnnotations.has(node.type) &&",
                    "    !(node.type === \"GenericTypeAnnotation\" && node.typeParameters)",
                    "  );",
                    "}",
                    "",
                    "const unitTestRe = /^(skip|[fx]?(it|describe|test))$/;",
                    "",
                    "function isSkipOrOnlyBlock(node) {",
                    "  return (",
                    "    (node.callee.type === \"MemberExpression\" ||",
                    "      node.callee.type === \"OptionalMemberExpression\") &&",
                    "    node.callee.object.type === \"Identifier\" &&",
                    "    node.callee.property.type === \"Identifier\" &&",
                    "    unitTestRe.test(node.callee.object.name) &&",
                    "    (node.callee.property.name === \"only\" ||",
                    "      node.callee.property.name === \"skip\")",
                    "  );",
                    "}",
                    "",
                    "function isUnitTestSetUp(n) {",
                    "  const unitTestSetUpRe = /^(before|after)(Each|All)$/;",
                    "  return (",
                    "    n.callee.type === \"Identifier\" &&",
                    "    unitTestSetUpRe.test(n.callee.name) &&",
                    "    n.arguments.length === 1",
                    "  );",
                    "}",
                    "",
                    "// eg; `describe(\"some string\", (done) => {})`",
                    "function isTestCall(n, parent) {",
                    "  if (n.type !== \"CallExpression\") {",
                    "    return false;",
                    "  }",
                    "  if (n.arguments.length === 1) {",
                    "    if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {",
                    "      return isFunctionOrArrowExpression(n.arguments[0]);",
                    "    }",
                    "",
                    "    if (isUnitTestSetUp(n)) {",
                    "      return isAngularTestWrapper(n.arguments[0]);",
                    "    }",
                    "  } else if (n.arguments.length === 2 || n.arguments.length === 3) {",
                    "    if (",
                    "      ((n.callee.type === \"Identifier\" && unitTestRe.test(n.callee.name)) ||",
                    "        isSkipOrOnlyBlock(n)) &&",
                    "      (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))",
                    "    ) {",
                    "      // it(\"name\", () => { ... }, 2500)",
                    "      if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {",
                    "        return false;",
                    "      }",
                    "      return (",
                    "        (n.arguments.length === 2",
                    "          ? isFunctionOrArrowExpression(n.arguments[1])",
                    "          : isFunctionOrArrowExpressionWithBody(n.arguments[1]) &&",
                    "            n.arguments[1].params.length <= 1) ||",
                    "        isAngularTestWrapper(n.arguments[1])",
                    "      );",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function hasLeadingComment(node) {",
                    "  return node.comments && node.comments.some((comment) => comment.leading);",
                    "}",
                    "",
                    "function hasTrailingComment(node) {",
                    "  return node.comments && node.comments.some((comment) => comment.trailing);",
                    "}",
                    "",
                    "function hasTrailingLineComment(node) {",
                    "  return (",
                    "    node.comments &&",
                    "    node.comments.some(",
                    "      (comment) => comment.trailing && !handleComments.isBlockComment(comment)",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function isCallOrOptionalCallExpression(node) {",
                    "  return (",
                    "    node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\"",
                    "  );",
                    "}",
                    "",
                    "function hasDanglingComments(node) {",
                    "  return (",
                    "    node.comments &&",
                    "    node.comments.some((comment) => !comment.leading && !comment.trailing)",
                    "  );",
                    "}",
                    "",
                    "/** identify if an angular expression seems to have side effects */",
                    "function hasNgSideEffect(path) {",
                    "  return hasNode(path.getValue(), (node) => {",
                    "    switch (node.type) {",
                    "      case undefined:",
                    "        return false;",
                    "      case \"CallExpression\":",
                    "      case \"OptionalCallExpression\":",
                    "      case \"AssignmentExpression\":",
                    "        return true;",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function isNgForOf(node, index, parentNode) {",
                    "  return (",
                    "    node.type === \"NGMicrosyntaxKeyedExpression\" &&",
                    "    node.key.name === \"of\" &&",
                    "    index === 1 &&",
                    "    parentNode.body[0].type === \"NGMicrosyntaxLet\" &&",
                    "    parentNode.body[0].value === null",
                    "  );",
                    "}",
                    "",
                    "/** @param node {import(\"estree\").TemplateLiteral} */",
                    "function isSimpleTemplateLiteral(node) {",
                    "  if (node.expressions.length === 0) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return node.expressions.every((expr) => {",
                    "    // Disallow comments since printDocToString can't print them here",
                    "    if (expr.comments) {",
                    "      return false;",
                    "    }",
                    "",
                    "    // Allow `x` and `this`",
                    "    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {",
                    "      return true;",
                    "    }",
                    "",
                    "    // Allow `a.b.c`, `a.b[c]`, and `this.x.y`",
                    "    if (",
                    "      expr.type === \"MemberExpression\" ||",
                    "      expr.type === \"OptionalMemberExpression\"",
                    "    ) {",
                    "      let head = expr;",
                    "      while (",
                    "        head.type === \"MemberExpression\" ||",
                    "        head.type === \"OptionalMemberExpression\"",
                    "      ) {",
                    "        if (",
                    "          head.property.type !== \"Identifier\" &&",
                    "          head.property.type !== \"Literal\" &&",
                    "          head.property.type !== \"StringLiteral\" &&",
                    "          head.property.type !== \"NumericLiteral\"",
                    "        ) {",
                    "          return false;",
                    "        }",
                    "        head = head.object;",
                    "        if (head.comments) {",
                    "          return false;",
                    "        }",
                    "      }",
                    "",
                    "      if (head.type === \"Identifier\" || head.type === \"ThisExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      return false;",
                    "    }",
                    "",
                    "    return false;",
                    "  });",
                    "}",
                    "",
                    "function getFlowVariance(path) {",
                    "  if (!path.variance) {",
                    "    return null;",
                    "  }",
                    "",
                    "  // Babel 7.0 currently uses variance node type, and flow should",
                    "  // follow suit soon:",
                    "  // https://github.com/babel/babel/issues/4722",
                    "  const variance = path.variance.kind || path.variance;",
                    "",
                    "  switch (variance) {",
                    "    case \"plus\":",
                    "      return \"+\";",
                    "    case \"minus\":",
                    "      return \"-\";",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      return variance;",
                    "  }",
                    "}",
                    "",
                    "function classPropMayCauseASIProblems(path) {",
                    "  const node = path.getNode();",
                    "",
                    "  if (node.type !== \"ClassProperty\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  const name = node.key && node.key.name;",
                    "",
                    "  // this isn't actually possible yet with most parsers available today",
                    "  // so isn't properly tested yet.",
                    "  if (",
                    "    (name === \"static\" || name === \"get\" || name === \"set\") &&",
                    "    !node.value &&",
                    "    !node.typeAnnotation",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function classChildNeedsASIProtection(node) {",
                    "  if (!node) {",
                    "    return;",
                    "  }",
                    "",
                    "  if (",
                    "    node.static ||",
                    "    node.accessibility // TypeScript",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (!node.computed) {",
                    "    const name = node.key && node.key.name;",
                    "    if (name === \"in\" || name === \"instanceof\") {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  switch (node.type) {",
                    "    case \"ClassProperty\":",
                    "    case \"TSAbstractClassProperty\":",
                    "      return node.computed;",
                    "    case \"MethodDefinition\": // Flow",
                    "    case \"TSAbstractMethodDefinition\": // TypeScript",
                    "    case \"ClassMethod\":",
                    "    case \"ClassPrivateMethod\": {",
                    "      // Babel",
                    "      const isAsync = node.value ? node.value.async : node.async;",
                    "      const isGenerator = node.value ? node.value.generator : node.generator;",
                    "      if (isAsync || node.kind === \"get\" || node.kind === \"set\") {",
                    "        return false;",
                    "      }",
                    "      if (node.computed || isGenerator) {",
                    "        return true;",
                    "      }",
                    "      return false;",
                    "    }",
                    "    case \"TSIndexSignature\":",
                    "      return true;",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function getTypeScriptMappedTypeModifier(tokenNode, keyword) {",
                    "  if (tokenNode === \"+\") {",
                    "    return \"+\" + keyword;",
                    "  } else if (tokenNode === \"-\") {",
                    "    return \"-\" + keyword;",
                    "  }",
                    "  return keyword;",
                    "}",
                    "",
                    "function hasNewlineBetweenOrAfterDecorators(node, options) {",
                    "  return (",
                    "    hasNewlineInRange(",
                    "      options.originalText,",
                    "      options.locStart(node.decorators[0]),",
                    "      options.locEnd(getLast(node.decorators))",
                    "    ) ||",
                    "    hasNewline(options.originalText, options.locEnd(getLast(node.decorators)))",
                    "  );",
                    "}",
                    "",
                    "// Only space, newline, carriage return, and tab are treated as whitespace",
                    "// inside JSX.",
                    "const jsxWhitespaceChars = \" \\n\\r\\t\";",
                    "const matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\");",
                    "const containsNonJsxWhitespaceRegex = new RegExp(",
                    "  \"[^\" + jsxWhitespaceChars + \"]\"",
                    ");",
                    "",
                    "// Meaningful if it contains non-whitespace characters,",
                    "// or it contains whitespace without a new line.",
                    "function isMeaningfulJSXText(node) {",
                    "  return (",
                    "    isLiteral(node) &&",
                    "    (containsNonJsxWhitespaceRegex.test(rawText(node)) ||",
                    "      !/\\n/.test(rawText(node)))",
                    "  );",
                    "}",
                    "",
                    "function hasJsxIgnoreComment(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Lookup the previous sibling, ignoring any empty JSXText elements",
                    "  const index = parent.children.indexOf(node);",
                    "  let prevSibling = null;",
                    "  for (let i = index; i > 0; i--) {",
                    "    const candidate = parent.children[i - 1];",
                    "    if (candidate.type === \"JSXText\" && !isMeaningfulJSXText(candidate)) {",
                    "      continue;",
                    "    }",
                    "    prevSibling = candidate;",
                    "    break;",
                    "  }",
                    "",
                    "  return (",
                    "    prevSibling &&",
                    "    prevSibling.type === \"JSXExpressionContainer\" &&",
                    "    prevSibling.expression.type === \"JSXEmptyExpression\" &&",
                    "    prevSibling.expression.comments &&",
                    "    prevSibling.expression.comments.find(",
                    "      (comment) => comment.value.trim() === \"prettier-ignore\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function isEmptyJSXElement(node) {",
                    "  if (node.children.length === 0) {",
                    "    return true;",
                    "  }",
                    "  if (node.children.length > 1) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // if there is one text child and does not contain any meaningful text",
                    "  // we can treat the element as empty.",
                    "  const child = node.children[0];",
                    "  return isLiteral(child) && !isMeaningfulJSXText(child);",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  return hasIgnoreComment(path) || hasJsxIgnoreComment(path);",
                    "}",
                    "",
                    "function isLastStatement(path) {",
                    "  const parent = path.getParentNode();",
                    "  if (!parent) {",
                    "    return true;",
                    "  }",
                    "  const node = path.getValue();",
                    "  const body = (parent.body || parent.consequent).filter(",
                    "    (stmt) => stmt.type !== \"EmptyStatement\"",
                    "  );",
                    "  return body && body[body.length - 1] === node;",
                    "}",
                    "",
                    "function isFlowAnnotationComment(text, typeAnnotation, options) {",
                    "  const start = options.locStart(typeAnnotation);",
                    "  const end = skipWhitespace(text, options.locEnd(typeAnnotation));",
                    "  return (",
                    "    text.slice(start, start + 2) === \"/*\" && text.slice(end, end + 2) === \"*/\"",
                    "  );",
                    "}",
                    "",
                    "function hasLeadingOwnLineComment(text, node, options) {",
                    "  if (isJSXNode(node)) {",
                    "    return hasNodeIgnoreComment(node);",
                    "  }",
                    "",
                    "  const res =",
                    "    node.comments &&",
                    "    node.comments.some(",
                    "      (comment) => comment.leading && hasNewline(text, options.locEnd(comment))",
                    "    );",
                    "  return res;",
                    "}",
                    "",
                    "// This recurses the return argument, looking for the first token",
                    "// (the leftmost leaf node) and, if it (or its parents) has any",
                    "// leadingComments, returns true (so it can be wrapped in parens).",
                    "function returnArgumentHasLeadingComment(options, argument) {",
                    "  if (hasLeadingOwnLineComment(options.originalText, argument, options)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (hasNakedLeftSide(argument)) {",
                    "    let leftMost = argument;",
                    "    let newLeftMost;",
                    "    while ((newLeftMost = getLeftSide(leftMost))) {",
                    "      leftMost = newLeftMost;",
                    "",
                    "      if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isStringPropSafeToCoerceToIdentifier(node, options) {",
                    "  return (",
                    "    isStringLiteral(node.key) &&",
                    "    isIdentifierName(node.key.value) &&",
                    "    rawText(node.key).slice(1, -1) === node.key.value &&",
                    "    options.parser !== \"json\" &&",
                    "    // With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.",
                    "    // See https://github.com/microsoft/TypeScript/pull/20075",
                    "    !(",
                    "      (options.parser === \"typescript\" || options.parser === \"babel-ts\") &&",
                    "      node.type === \"ClassProperty\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function isJestEachTemplateLiteral(node, parentNode) {",
                    "  /**",
                    "   * describe.each`table`(name, fn)",
                    "   * describe.only.each`table`(name, fn)",
                    "   * describe.skip.each`table`(name, fn)",
                    "   * test.each`table`(name, fn)",
                    "   * test.only.each`table`(name, fn)",
                    "   * test.skip.each`table`(name, fn)",
                    "   *",
                    "   * Ref: https://github.com/facebook/jest/pull/6102",
                    "   */",
                    "  const jestEachTriggerRegex = /^[fx]?(describe|it|test)$/;",
                    "  return (",
                    "    parentNode.type === \"TaggedTemplateExpression\" &&",
                    "    parentNode.quasi === node &&",
                    "    parentNode.tag.type === \"MemberExpression\" &&",
                    "    parentNode.tag.property.type === \"Identifier\" &&",
                    "    parentNode.tag.property.name === \"each\" &&",
                    "    ((parentNode.tag.object.type === \"Identifier\" &&",
                    "      jestEachTriggerRegex.test(parentNode.tag.object.name)) ||",
                    "      (parentNode.tag.object.type === \"MemberExpression\" &&",
                    "        parentNode.tag.object.property.type === \"Identifier\" &&",
                    "        (parentNode.tag.object.property.name === \"only\" ||",
                    "          parentNode.tag.object.property.name === \"skip\") &&",
                    "        parentNode.tag.object.object.type === \"Identifier\" &&",
                    "        jestEachTriggerRegex.test(parentNode.tag.object.object.name)))",
                    "  );",
                    "}",
                    "",
                    "function templateLiteralHasNewLines(template) {",
                    "  return template.quasis.some((quasi) => quasi.value.raw.includes(\"\\n\"));",
                    "}",
                    "",
                    "function isTemplateOnItsOwnLine(n, text, options) {",
                    "  return (",
                    "    ((n.type === \"TemplateLiteral\" && templateLiteralHasNewLines(n)) ||",
                    "      (n.type === \"TaggedTemplateExpression\" &&",
                    "        templateLiteralHasNewLines(n.quasi))) &&",
                    "    !hasNewline(text, options.locStart(n), { backwards: true })",
                    "  );",
                    "}",
                    "",
                    "function needsHardlineAfterDanglingComment(node) {",
                    "  if (!node.comments) {",
                    "    return false;",
                    "  }",
                    "  const lastDanglingComment = getLast(",
                    "    node.comments.filter((comment) => !comment.leading && !comment.trailing)",
                    "  );",
                    "  return (",
                    "    lastDanglingComment && !handleComments.isBlockComment(lastDanglingComment)",
                    "  );",
                    "}",
                    "",
                    "// If we have nested conditional expressions, we want to print them in JSX mode",
                    "// if there's at least one JSXElement somewhere in the tree.",
                    "//",
                    "// A conditional expression chain like this should be printed in normal mode,",
                    "// because there aren't JSXElements anywhere in it:",
                    "//",
                    "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";",
                    "//",
                    "// But a conditional expression chain like this should be printed in JSX mode,",
                    "// because there is a JSXElement in the last ConditionalExpression:",
                    "//",
                    "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;",
                    "//",
                    "// This type of ConditionalExpression chain is structured like this in the AST:",
                    "//",
                    "// ConditionalExpression {",
                    "//   test: ...,",
                    "//   consequent: ...,",
                    "//   alternate: ConditionalExpression {",
                    "//     test: ...,",
                    "//     consequent: ...,",
                    "//     alternate: ConditionalExpression {",
                    "//       test: ...,",
                    "//       consequent: ...,",
                    "//       alternate: ...,",
                    "//     }",
                    "//   }",
                    "// }",
                    "//",
                    "// We want to traverse over that shape and convert it into a flat structure so",
                    "// that we can find if there's a JSXElement somewhere inside.",
                    "function getConditionalChainContents(node) {",
                    "  // Given this code:",
                    "  //",
                    "  // // Using a ConditionalExpression as the consequent is uncommon, but should",
                    "  // // be handled.",
                    "  // A ? B : C ? D : E ? F ? G : H : I",
                    "  //",
                    "  // which has this AST:",
                    "  //",
                    "  // ConditionalExpression {",
                    "  //   test: Identifier(A),",
                    "  //   consequent: Identifier(B),",
                    "  //   alternate: ConditionalExpression {",
                    "  //     test: Identifier(C),",
                    "  //     consequent: Identifier(D),",
                    "  //     alternate: ConditionalExpression {",
                    "  //       test: Identifier(E),",
                    "  //       consequent: ConditionalExpression {",
                    "  //         test: Identifier(F),",
                    "  //         consequent: Identifier(G),",
                    "  //         alternate: Identifier(H),",
                    "  //       },",
                    "  //       alternate: Identifier(I),",
                    "  //     }",
                    "  //   }",
                    "  // }",
                    "  //",
                    "  // we should return this Array:",
                    "  //",
                    "  // [",
                    "  //   Identifier(A),",
                    "  //   Identifier(B),",
                    "  //   Identifier(C),",
                    "  //   Identifier(D),",
                    "  //   Identifier(E),",
                    "  //   Identifier(F),",
                    "  //   Identifier(G),",
                    "  //   Identifier(H),",
                    "  //   Identifier(I)",
                    "  // ];",
                    "  //",
                    "  // This loses the information about whether each node was the test,",
                    "  // consequent, or alternate, but we don't care about that here- we are only",
                    "  // flattening this structure to find if there's any JSXElements inside.",
                    "  const nonConditionalExpressions = [];",
                    "",
                    "  function recurse(node) {",
                    "    if (node.type === \"ConditionalExpression\") {",
                    "      recurse(node.test);",
                    "      recurse(node.consequent);",
                    "      recurse(node.alternate);",
                    "    } else {",
                    "      nonConditionalExpressions.push(node);",
                    "    }",
                    "  }",
                    "  recurse(node);",
                    "",
                    "  return nonConditionalExpressions;",
                    "}",
                    "",
                    "function conditionalExpressionChainContainsJSX(node) {",
                    "  return Boolean(getConditionalChainContents(node).find(isJSXNode));",
                    "}",
                    "",
                    "// Logic to check for args with multiple anonymous functions. For instance,",
                    "// the following call should be split on multiple lines for readability:",
                    "// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))",
                    "function isFunctionCompositionArgs(args) {",
                    "  if (args.length <= 1) {",
                    "    return false;",
                    "  }",
                    "  let count = 0;",
                    "  for (const arg of args) {",
                    "    if (isFunctionOrArrowExpression(arg)) {",
                    "      count += 1;",
                    "      if (count > 1) {",
                    "        return true;",
                    "      }",
                    "    } else if (isCallOrOptionalCallExpression(arg)) {",
                    "      for (const childArg of arg.arguments) {",
                    "        if (isFunctionOrArrowExpression(childArg)) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "// Logic to determine if a call is a long curried function call.",
                    "// See https://github.com/prettier/prettier/issues/1420.",
                    "//",
                    "// `connect(a, b, c)(d)`",
                    "// In the above call expression, the second call is the parent node and the",
                    "// first call is the current node.",
                    "function isLongCurriedCallExpression(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  return (",
                    "    isCallOrOptionalCallExpression(node) &&",
                    "    isCallOrOptionalCallExpression(parent) &&",
                    "    parent.callee === node &&",
                    "    node.arguments.length > parent.arguments.length &&",
                    "    parent.arguments.length > 0",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {import('estree').Node} node",
                    " * @param {number} depth",
                    " * @returns {boolean}",
                    " */",
                    "function isSimpleCallArgument(node, depth) {",
                    "  if (depth >= 3) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const plusOne = (node) => isSimpleCallArgument(node, depth + 1);",
                    "  const plusTwo = (node) => isSimpleCallArgument(node, depth + 2);",
                    "",
                    "  const regexpPattern =",
                    "    (node.type === \"Literal\" && node.regex && node.regex.pattern) ||",
                    "    (node.type === \"RegExpLiteral\" && node.pattern);",
                    "",
                    "  if (regexpPattern && regexpPattern.length > 5) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"Literal\" ||",
                    "    node.type === \"BigIntLiteral\" ||",
                    "    node.type === \"BooleanLiteral\" ||",
                    "    node.type === \"NullLiteral\" ||",
                    "    node.type === \"NumericLiteral\" ||",
                    "    node.type === \"RegExpLiteral\" ||",
                    "    node.type === \"StringLiteral\" ||",
                    "    node.type === \"Identifier\" ||",
                    "    node.type === \"ThisExpression\" ||",
                    "    node.type === \"Super\" ||",
                    "    node.type === \"PrivateName\" ||",
                    "    node.type === \"ArgumentPlaceholder\" ||",
                    "    node.type === \"Import\"",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (node.type === \"TemplateLiteral\") {",
                    "    return node.expressions.every(plusTwo);",
                    "  }",
                    "",
                    "  if (node.type === \"ObjectExpression\") {",
                    "    return node.properties.every(",
                    "      (p) => !p.computed && (p.shorthand || (p.value && plusTwo(p.value)))",
                    "    );",
                    "  }",
                    "",
                    "  if (node.type === \"ArrayExpression\") {",
                    "    return node.elements.every((x) => x === null || plusTwo(x));",
                    "  }",
                    "",
                    "  if (node.type === \"ImportExpression\") {",
                    "    return plusTwo(node.source, depth);",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"CallExpression\" ||",
                    "    node.type === \"OptionalCallExpression\" ||",
                    "    node.type === \"NewExpression\"",
                    "  ) {",
                    "    return plusOne(node.callee, depth) && node.arguments.every(plusTwo);",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"MemberExpression\" ||",
                    "    node.type === \"OptionalMemberExpression\"",
                    "  ) {",
                    "    return plusOne(node.object, depth) && plusOne(node.property, depth);",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"UnaryExpression\" &&",
                    "    (node.operator === \"!\" || node.operator === \"-\")",
                    "  ) {",
                    "    return plusOne(node.argument, depth);",
                    "  }",
                    "",
                    "  if (node.type === \"TSNonNullExpression\") {",
                    "    return plusOne(node.expression, depth);",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function rawText(node) {",
                    "  return node.extra ? node.extra.raw : node.raw;",
                    "}",
                    "",
                    "function identity(x) {",
                    "  return x;",
                    "}",
                    "",
                    "function isTSXFile(options) {",
                    "  return options.filepath && /\\.tsx$/i.test(options.filepath);",
                    "}",
                    "",
                    "function shouldPrintComma(options, level) {",
                    "  level = level || \"es5\";",
                    "",
                    "  switch (options.trailingComma) {",
                    "    case \"all\":",
                    "      if (level === \"all\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"es5\":",
                    "      if (level === \"es5\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"none\":",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  classChildNeedsASIProtection,",
                    "  classPropMayCauseASIProblems,",
                    "  conditionalExpressionChainContainsJSX,",
                    "  getFlowVariance,",
                    "  getLeftSidePathName,",
                    "  getParentExportDeclaration,",
                    "  getTypeScriptMappedTypeModifier,",
                    "  hasDanglingComments,",
                    "  hasFlowAnnotationComment,",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasLeadingComment,",
                    "  hasLeadingOwnLineComment,",
                    "  hasNakedLeftSide,",
                    "  hasNewlineBetweenOrAfterDecorators,",
                    "  hasNgSideEffect,",
                    "  hasNode,",
                    "  hasPrettierIgnore,",
                    "  hasTrailingComment,",
                    "  hasTrailingLineComment,",
                    "  identity,",
                    "  isBinaryish,",
                    "  isCallOrOptionalCallExpression,",
                    "  isEmptyJSXElement,",
                    "  isExportDeclaration,",
                    "  isFlowAnnotationComment,",
                    "  isFunctionCompositionArgs,",
                    "  isFunctionNotation,",
                    "  isFunctionOrArrowExpression,",
                    "  isGetterOrSetter,",
                    "  isJestEachTemplateLiteral,",
                    "  isJSXNode,",
                    "  isJSXWhitespaceExpression,",
                    "  isLastStatement,",
                    "  isLiteral,",
                    "  isLiteralLikeValue,",
                    "  isLongCurriedCallExpression,",
                    "  isSimpleCallArgument,",
                    "  isMeaningfulJSXText,",
                    "  isMemberExpressionChain,",
                    "  isMemberish,",
                    "  isNgForOf,",
                    "  isNumericLiteral,",
                    "  isObjectType,",
                    "  isObjectTypePropertyAFunction,",
                    "  isSimpleFlowType,",
                    "  isSimpleTemplateLiteral,",
                    "  isStringLiteral,",
                    "  isStringPropSafeToCoerceToIdentifier,",
                    "  isTemplateOnItsOwnLine,",
                    "  isTestCall,",
                    "  isTheOnlyJSXElementInMarkdown,",
                    "  isTSXFile,",
                    "  isTypeAnnotationAFunction,",
                    "  matchJsxWhitespaceRegex,",
                    "  needsHardlineAfterDanglingComment,",
                    "  rawText,",
                    "  returnArgumentHasLeadingComment,",
                    "  shouldPrintComma,",
                    "};"
                ]
            },
            "print": {
                "call-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const comments = require(\"../../main/comments\");",
                        "const { getLast, getPenultimate } = require(\"../../common/util\");",
                        "const { isNextLineEmpty } = require(\"../../common/util-shared\");",
                        "const {",
                        "  hasLeadingComment,",
                        "  hasTrailingComment,",
                        "  isFunctionCompositionArgs,",
                        "  isJSXNode,",
                        "  isLongCurriedCallExpression,",
                        "  shouldPrintComma,",
                        "} = require(\"../utils\");",
                        "",
                        "const {",
                        "  builders: {",
                        "    concat,",
                        "    line,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    ifBreak,",
                        "    breakParent,",
                        "  },",
                        "  utils: { willBreak },",
                        "} = require(\"../../document\");",
                        "",
                        "function printCallArguments(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const isDynamicImport = node.type === \"ImportExpression\";",
                        "  const args = isDynamicImport ? [node.source] : node.arguments;",
                        "",
                        "  if (args.length === 0) {",
                        "    return concat([",
                        "      \"(\",",
                        "      comments.printDanglingComments(path, options, /* sameIndent */ true),",
                        "      \")\",",
                        "    ]);",
                        "  }",
                        "",
                        "  // useEffect(() => { ... }, [foo, bar, baz])",
                        "  if (",
                        "    args.length === 2 &&",
                        "    args[0].type === \"ArrowFunctionExpression\" &&",
                        "    args[0].params.length === 0 &&",
                        "    args[0].body.type === \"BlockStatement\" &&",
                        "    args[1].type === \"ArrayExpression\" &&",
                        "    !args.find((arg) => arg.comments)",
                        "  ) {",
                        "    return concat([",
                        "      \"(\",",
                        "      path.call(print, \"arguments\", 0),",
                        "      \", \",",
                        "      path.call(print, \"arguments\", 1),",
                        "      \")\",",
                        "    ]);",
                        "  }",
                        "",
                        "  // func(",
                        "  //   ({",
                        "  //     a,",
                        "",
                        "  //     b",
                        "  //   }) => {}",
                        "  // );",
                        "  function shouldBreakForArrowFunctionInArguments(arg, argPath) {",
                        "    if (",
                        "      !arg ||",
                        "      arg.type !== \"ArrowFunctionExpression\" ||",
                        "      !arg.body ||",
                        "      arg.body.type !== \"BlockStatement\" ||",
                        "      !arg.params ||",
                        "      arg.params.length < 1",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    let shouldBreak = false;",
                        "    argPath.each((paramPath) => {",
                        "      const printed = concat([print(paramPath)]);",
                        "      shouldBreak = shouldBreak || willBreak(printed);",
                        "    }, \"params\");",
                        "",
                        "    return shouldBreak;",
                        "  }",
                        "",
                        "  let anyArgEmptyLine = false;",
                        "  let shouldBreakForArrowFunction = false;",
                        "  let hasEmptyLineFollowingFirstArg = false;",
                        "  const lastArgIndex = args.length - 1;",
                        "  const printArgument = (argPath, index) => {",
                        "    const arg = argPath.getNode();",
                        "    const parts = [print(argPath)];",
                        "",
                        "    if (index === lastArgIndex) {",
                        "      // do nothing",
                        "    } else if (isNextLineEmpty(options.originalText, arg, options.locEnd)) {",
                        "      if (index === 0) {",
                        "        hasEmptyLineFollowingFirstArg = true;",
                        "      }",
                        "",
                        "      anyArgEmptyLine = true;",
                        "      parts.push(\",\", hardline, hardline);",
                        "    } else {",
                        "      parts.push(\",\", line);",
                        "    }",
                        "",
                        "    shouldBreakForArrowFunction = shouldBreakForArrowFunctionInArguments(",
                        "      arg,",
                        "      argPath",
                        "    );",
                        "",
                        "    return concat(parts);",
                        "  };",
                        "  const printedArguments = isDynamicImport",
                        "    ? [path.call((path) => printArgument(path, 0), \"source\")]",
                        "    : path.map(printArgument, \"arguments\");",
                        "",
                        "  const maybeTrailingComma =",
                        "    // Dynamic imports cannot have trailing commas",
                        "    !(isDynamicImport || (node.callee && node.callee.type === \"Import\")) &&",
                        "    shouldPrintComma(options, \"all\")",
                        "      ? \",\"",
                        "      : \"\";",
                        "",
                        "  function allArgsBrokenOut() {",
                        "    return group(",
                        "      concat([",
                        "        \"(\",",
                        "        indent(concat([line, concat(printedArguments)])),",
                        "        maybeTrailingComma,",
                        "        line,",
                        "        \")\",",
                        "      ]),",
                        "      { shouldBreak: true }",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    path.getParentNode().type !== \"Decorator\" &&",
                        "    isFunctionCompositionArgs(args)",
                        "  ) {",
                        "    return allArgsBrokenOut();",
                        "  }",
                        "",
                        "  const shouldGroupFirst = shouldGroupFirstArg(args);",
                        "  const shouldGroupLast = shouldGroupLastArg(args);",
                        "  if (shouldGroupFirst || shouldGroupLast) {",
                        "    const shouldBreak =",
                        "      (shouldGroupFirst",
                        "        ? printedArguments.slice(1).some(willBreak)",
                        "        : printedArguments.slice(0, -1).some(willBreak)) ||",
                        "      anyArgEmptyLine ||",
                        "      shouldBreakForArrowFunction;",
                        "",
                        "    // We want to print the last argument with a special flag",
                        "    let printedExpanded;",
                        "    let i = 0;",
                        "    const printArgument = (argPath) => {",
                        "      if (shouldGroupFirst && i === 0) {",
                        "        printedExpanded = [",
                        "          concat([",
                        "            argPath.call((p) => print(p, { expandFirstArg: true })),",
                        "            printedArguments.length > 1 ? \",\" : \"\",",
                        "            hasEmptyLineFollowingFirstArg ? hardline : line,",
                        "            hasEmptyLineFollowingFirstArg ? hardline : \"\",",
                        "          ]),",
                        "        ].concat(printedArguments.slice(1));",
                        "      }",
                        "      if (shouldGroupLast && i === args.length - 1) {",
                        "        printedExpanded = printedArguments",
                        "          .slice(0, -1)",
                        "          .concat(argPath.call((p) => print(p, { expandLastArg: true })));",
                        "      }",
                        "      i++;",
                        "    };",
                        "",
                        "    if (isDynamicImport) {",
                        "      path.call(printArgument, \"source\");",
                        "    } else {",
                        "      path.each(printArgument, \"arguments\");",
                        "    }",
                        "",
                        "    const somePrintedArgumentsWillBreak = printedArguments.some(willBreak);",
                        "",
                        "    const simpleConcat = concat([\"(\", concat(printedExpanded), \")\"]);",
                        "",
                        "    return concat([",
                        "      somePrintedArgumentsWillBreak ? breakParent : \"\",",
                        "      conditionalGroup(",
                        "        [",
                        "          !somePrintedArgumentsWillBreak &&",
                        "          !node.typeArguments &&",
                        "          !node.typeParameters",
                        "            ? simpleConcat",
                        "            : ifBreak(allArgsBrokenOut(), simpleConcat),",
                        "          shouldGroupFirst",
                        "            ? concat([",
                        "                \"(\",",
                        "                group(printedExpanded[0], { shouldBreak: true }),",
                        "                concat(printedExpanded.slice(1)),",
                        "                \")\",",
                        "              ])",
                        "            : concat([",
                        "                \"(\",",
                        "                concat(printedArguments.slice(0, -1)),",
                        "                group(getLast(printedExpanded), {",
                        "                  shouldBreak: true,",
                        "                }),",
                        "                \")\",",
                        "              ]),",
                        "          allArgsBrokenOut(),",
                        "        ],",
                        "        { shouldBreak }",
                        "      ),",
                        "    ]);",
                        "  }",
                        "",
                        "  const contents = concat([",
                        "    \"(\",",
                        "    indent(concat([softline, concat(printedArguments)])),",
                        "    ifBreak(maybeTrailingComma),",
                        "    softline,",
                        "    \")\",",
                        "  ]);",
                        "  if (isLongCurriedCallExpression(path)) {",
                        "    // By not wrapping the arguments in a group, the printer prioritizes",
                        "    // breaking up these arguments rather than the args of the parent call.",
                        "    return contents;",
                        "  }",
                        "",
                        "  return group(contents, {",
                        "    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine,",
                        "  });",
                        "}",
                        "",
                        "function couldGroupArg(arg) {",
                        "  return (",
                        "    (arg.type === \"ObjectExpression\" &&",
                        "      (arg.properties.length > 0 || arg.comments)) ||",
                        "    (arg.type === \"ArrayExpression\" &&",
                        "      (arg.elements.length > 0 || arg.comments)) ||",
                        "    (arg.type === \"TSTypeAssertion\" && couldGroupArg(arg.expression)) ||",
                        "    (arg.type === \"TSAsExpression\" && couldGroupArg(arg.expression)) ||",
                        "    arg.type === \"FunctionExpression\" ||",
                        "    (arg.type === \"ArrowFunctionExpression\" &&",
                        "      // we want to avoid breaking inside composite return types but not simple keywords",
                        "      // https://github.com/prettier/prettier/issues/4070",
                        "      // export class Thing implements OtherThing {",
                        "      //   do: (type: Type) => Provider<Prop> = memoize(",
                        "      //     (type: ObjectType): Provider<Opts> => {}",
                        "      //   );",
                        "      // }",
                        "      // https://github.com/prettier/prettier/issues/6099",
                        "      // app.get(\"/\", (req, res): void => {",
                        "      //   res.send(\"Hello World!\");",
                        "      // });",
                        "      (!arg.returnType ||",
                        "        !arg.returnType.typeAnnotation ||",
                        "        arg.returnType.typeAnnotation.type !== \"TSTypeReference\") &&",
                        "      (arg.body.type === \"BlockStatement\" ||",
                        "        arg.body.type === \"ArrowFunctionExpression\" ||",
                        "        arg.body.type === \"ObjectExpression\" ||",
                        "        arg.body.type === \"ArrayExpression\" ||",
                        "        arg.body.type === \"CallExpression\" ||",
                        "        arg.body.type === \"OptionalCallExpression\" ||",
                        "        arg.body.type === \"ConditionalExpression\" ||",
                        "        isJSXNode(arg.body)))",
                        "  );",
                        "}",
                        "",
                        "function shouldGroupLastArg(args) {",
                        "  const lastArg = getLast(args);",
                        "  const penultimateArg = getPenultimate(args);",
                        "  return (",
                        "    !hasLeadingComment(lastArg) &&",
                        "    !hasTrailingComment(lastArg) &&",
                        "    couldGroupArg(lastArg) &&",
                        "    // If the last two arguments are of the same type,",
                        "    // disable last element expansion.",
                        "    (!penultimateArg || penultimateArg.type !== lastArg.type)",
                        "  );",
                        "}",
                        "",
                        "function shouldGroupFirstArg(args) {",
                        "  if (args.length !== 2) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const [firstArg, secondArg] = args;",
                        "  return (",
                        "    (!firstArg.comments || !firstArg.comments.length) &&",
                        "    (firstArg.type === \"FunctionExpression\" ||",
                        "      (firstArg.type === \"ArrowFunctionExpression\" &&",
                        "        firstArg.body.type === \"BlockStatement\")) &&",
                        "    secondArg.type !== \"FunctionExpression\" &&",
                        "    secondArg.type !== \"ArrowFunctionExpression\" &&",
                        "    secondArg.type !== \"ConditionalExpression\" &&",
                        "    !couldGroupArg(secondArg)",
                        "  );",
                        "}",
                        "",
                        "module.exports = printCallArguments;"
                    ]
                },
                "member-chain.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const flat = require(\"lodash/flatten\");",
                        "",
                        "const comments = require(\"../../main/comments\");",
                        "const { getLast } = require(\"../../common/util\");",
                        "const {",
                        "  isNextLineEmpty,",
                        "  isNextLineEmptyAfterIndex,",
                        "  getNextNonSpaceNonCommentCharacterIndex,",
                        "} = require(\"../../common/util-shared\");",
                        "const pathNeedsParens = require(\"../needs-parens\");",
                        "const {",
                        "  hasLeadingComment,",
                        "  hasTrailingComment,",
                        "  isCallOrOptionalCallExpression,",
                        "  isLiteralLikeValue,",
                        "  isLongCurriedCallExpression,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSimpleCallArgument,",
                        "} = require(\"../utils\");",
                        "",
                        "const printCallArguments = require(\"./call-arguments\");",
                        "const {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "  printMemberLookup,",
                        "  printBindExpressionCallee,",
                        "} = require(\"./misc\");",
                        "",
                        "const {",
                        "  builders: {",
                        "    concat,",
                        "    join,",
                        "    hardline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    breakParent,",
                        "  },",
                        "  utils: { willBreak },",
                        "} = require(\"../../document\");",
                        "",
                        "// We detect calls on member expressions specially to format a",
                        "// common pattern better. The pattern we are looking for is this:",
                        "//",
                        "// arr",
                        "//   .map(x => x + 1)",
                        "//   .filter(x => x > 10)",
                        "//   .some(x => x % 2)",
                        "//",
                        "// The way it is structured in the AST is via a nested sequence of",
                        "// MemberExpression and CallExpression. We need to traverse the AST",
                        "// and make groups out of it to print it in the desired way.",
                        "function printMemberChain(path, options, print) {",
                        "  const parent = path.getParentNode();",
                        "  const isExpressionStatement =",
                        "    !parent || parent.type === \"ExpressionStatement\";",
                        "",
                        "  // The first phase is to linearize the AST by traversing it down.",
                        "  //",
                        "  //   a().b()",
                        "  // has the following AST structure:",
                        "  //   CallExpression(MemberExpression(CallExpression(Identifier)))",
                        "  // and we transform it into",
                        "  //   [Identifier, CallExpression, MemberExpression, CallExpression]",
                        "  const printedNodes = [];",
                        "",
                        "  // Here we try to retain one typed empty line after each call expression or",
                        "  // the first group whether it is in parentheses or not",
                        "  function shouldInsertEmptyLineAfter(node) {",
                        "    const { originalText } = options;",
                        "    const nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(",
                        "      originalText,",
                        "      node,",
                        "      options.locEnd",
                        "    );",
                        "    const nextChar = originalText.charAt(nextCharIndex);",
                        "",
                        "    // if it is cut off by a parenthesis, we only account for one typed empty",
                        "    // line after that parenthesis",
                        "    if (nextChar === \")\") {",
                        "      return isNextLineEmptyAfterIndex(",
                        "        originalText,",
                        "        nextCharIndex + 1,",
                        "        options.locEnd",
                        "      );",
                        "    }",
                        "",
                        "    return isNextLineEmpty(originalText, node, options.locEnd);",
                        "  }",
                        "",
                        "  function rec(path) {",
                        "    const node = path.getValue();",
                        "    if (",
                        "      isCallOrOptionalCallExpression(node) &&",
                        "      (isMemberish(node.callee) || isCallOrOptionalCallExpression(node.callee))",
                        "    ) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: concat([",
                        "          comments.printComments(",
                        "            path,",
                        "            () =>",
                        "              concat([",
                        "                printOptionalToken(path),",
                        "                printFunctionTypeParameters(path, options, print),",
                        "                printCallArguments(path, options, print),",
                        "              ]),",
                        "            options",
                        "          ),",
                        "          shouldInsertEmptyLineAfter(node) ? hardline : \"\",",
                        "        ]),",
                        "      });",
                        "      path.call((callee) => rec(callee), \"callee\");",
                        "    } else if (isMemberish(node)) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        needsParens: pathNeedsParens(path, options),",
                        "        printed: comments.printComments(",
                        "          path,",
                        "          () =>",
                        "            node.type === \"OptionalMemberExpression\" ||",
                        "            node.type === \"MemberExpression\"",
                        "              ? printMemberLookup(path, options, print)",
                        "              : printBindExpressionCallee(path, options, print),",
                        "          options",
                        "        ),",
                        "      });",
                        "      path.call((object) => rec(object), \"object\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: comments.printComments(path, () => \"!\", options),",
                        "      });",
                        "      path.call((expression) => rec(expression), \"expression\");",
                        "    } else {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: path.call(print),",
                        "      });",
                        "    }",
                        "  }",
                        "  // Note: the comments of the root node have already been printed, so we",
                        "  // need to extract this first call without printing them as they would",
                        "  // if handled inside of the recursive call.",
                        "  const node = path.getValue();",
                        "  printedNodes.unshift({",
                        "    node,",
                        "    printed: concat([",
                        "      printOptionalToken(path),",
                        "      printFunctionTypeParameters(path, options, print),",
                        "      printCallArguments(path, options, print),",
                        "    ]),",
                        "  });",
                        "",
                        "  if (node.callee) {",
                        "    path.call((callee) => rec(callee), \"callee\");",
                        "  }",
                        "",
                        "  // Once we have a linear list of printed nodes, we want to create groups out",
                        "  // of it.",
                        "  //",
                        "  //   a().b.c().d().e",
                        "  // will be grouped as",
                        "  //   [",
                        "  //     [Identifier, CallExpression],",
                        "  //     [MemberExpression, MemberExpression, CallExpression],",
                        "  //     [MemberExpression, CallExpression],",
                        "  //     [MemberExpression],",
                        "  //   ]",
                        "  // so that we can print it as",
                        "  //   a()",
                        "  //     .b.c()",
                        "  //     .d()",
                        "  //     .e",
                        "",
                        "  // The first group is the first node followed by",
                        "  //   - as many CallExpression as possible",
                        "  //       < fn()()() >.something()",
                        "  //   - as many array accessors as possible",
                        "  //       < fn()[0][1][2] >.something()",
                        "  //   - then, as many MemberExpression as possible but the last one",
                        "  //       < this.items >.something()",
                        "  const groups = [];",
                        "  let currentGroup = [printedNodes[0]];",
                        "  let i = 1;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (",
                        "      printedNodes[i].node.type === \"TSNonNullExpression\" ||",
                        "      isCallOrOptionalCallExpression(printedNodes[i].node) ||",
                        "      ((printedNodes[i].node.type === \"MemberExpression\" ||",
                        "        printedNodes[i].node.type === \"OptionalMemberExpression\") &&",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property))",
                        "    ) {",
                        "      currentGroup.push(printedNodes[i]);",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (!isCallOrOptionalCallExpression(printedNodes[0].node)) {",
                        "    for (; i + 1 < printedNodes.length; ++i) {",
                        "      if (",
                        "        isMemberish(printedNodes[i].node) &&",
                        "        isMemberish(printedNodes[i + 1].node)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "      } else {",
                        "        break;",
                        "      }",
                        "    }",
                        "  }",
                        "  groups.push(currentGroup);",
                        "  currentGroup = [];",
                        "",
                        "  // Then, each following group is a sequence of MemberExpression followed by",
                        "  // a sequence of CallExpression. To compute it, we keep adding things to the",
                        "  // group until we has seen a CallExpression in the past and reach a",
                        "  // MemberExpression",
                        "  let hasSeenCallExpression = false;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {",
                        "      // [0] should be appended at the end of the group instead of the",
                        "      // beginning of the next one",
                        "      if (",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "        continue;",
                        "      }",
                        "",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "",
                        "    if (",
                        "      isCallOrOptionalCallExpression(printedNodes[i].node) ||",
                        "      printedNodes[i].node.type === \"ImportExpression\"",
                        "    ) {",
                        "      hasSeenCallExpression = true;",
                        "    }",
                        "    currentGroup.push(printedNodes[i]);",
                        "",
                        "    if (",
                        "      printedNodes[i].node.comments &&",
                        "      printedNodes[i].node.comments.some((comment) => comment.trailing)",
                        "    ) {",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "  }",
                        "  if (currentGroup.length > 0) {",
                        "    groups.push(currentGroup);",
                        "  }",
                        "",
                        "  // There are cases like Object.keys(), Observable.of(), _.values() where",
                        "  // they are the subject of all the chained calls and therefore should",
                        "  // be kept on the same line:",
                        "  //",
                        "  //   Object.keys(items)",
                        "  //     .filter(x => x)",
                        "  //     .map(x => x)",
                        "  //",
                        "  // In order to detect those cases, we use an heuristic: if the first",
                        "  // node is an identifier with the name starting with a capital",
                        "  // letter or just a sequence of _$. The rationale is that they are",
                        "  // likely to be factories.",
                        "  function isFactory(name) {",
                        "    return /^[A-Z]|^[$_]+$/.test(name);",
                        "  }",
                        "",
                        "  // In case the Identifier is shorter than tab width, we can keep the",
                        "  // first call in a single line, if it's an ExpressionStatement.",
                        "  //",
                        "  //   d3.scaleLinear()",
                        "  //     .domain([0, 100])",
                        "  //     .range([0, width]);",
                        "  //",
                        "  function isShort(name) {",
                        "    return name.length <= options.tabWidth;",
                        "  }",
                        "",
                        "  function shouldNotWrap(groups) {",
                        "    const hasComputed = groups[1].length && groups[1][0].node.computed;",
                        "",
                        "    if (groups[0].length === 1) {",
                        "      const firstNode = groups[0][0].node;",
                        "      return (",
                        "        firstNode.type === \"ThisExpression\" ||",
                        "        (firstNode.type === \"Identifier\" &&",
                        "          (isFactory(firstNode.name) ||",
                        "            (isExpressionStatement && isShort(firstNode.name)) ||",
                        "            hasComputed))",
                        "      );",
                        "    }",
                        "",
                        "    const lastNode = getLast(groups[0]).node;",
                        "    return (",
                        "      (lastNode.type === \"MemberExpression\" ||",
                        "        lastNode.type === \"OptionalMemberExpression\") &&",
                        "      lastNode.property.type === \"Identifier\" &&",
                        "      (isFactory(lastNode.property.name) || hasComputed)",
                        "    );",
                        "  }",
                        "",
                        "  const shouldMerge =",
                        "    groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);",
                        "",
                        "  function printGroup(printedGroup) {",
                        "    const printed = printedGroup.map((tuple) => tuple.printed);",
                        "    // Checks if the last node (i.e. the parent node) needs parens and print",
                        "    // accordingly",
                        "    if (",
                        "      printedGroup.length > 0 &&",
                        "      printedGroup[printedGroup.length - 1].needsParens",
                        "    ) {",
                        "      return concat([\"(\", ...printed, \")\"]);",
                        "    }",
                        "    return concat(printed);",
                        "  }",
                        "",
                        "  function printIndentedGroup(groups) {",
                        "    if (groups.length === 0) {",
                        "      return \"\";",
                        "    }",
                        "    return indent(",
                        "      group(concat([hardline, join(hardline, groups.map(printGroup))]))",
                        "    );",
                        "  }",
                        "",
                        "  const printedGroups = groups.map(printGroup);",
                        "  const oneLine = concat(printedGroups);",
                        "",
                        "  const cutoff = shouldMerge ? 3 : 2;",
                        "  const flatGroups = flat(groups);",
                        "",
                        "  const hasComment =",
                        "    flatGroups.slice(1, -1).some((node) => hasLeadingComment(node.node)) ||",
                        "    flatGroups.slice(0, -1).some((node) => hasTrailingComment(node.node)) ||",
                        "    (groups[cutoff] && hasLeadingComment(groups[cutoff][0].node));",
                        "",
                        "  // If we only have a single `.`, we shouldn't do anything fancy and just",
                        "  // render everything concatenated together.",
                        "  if (groups.length <= cutoff && !hasComment) {",
                        "    if (isLongCurriedCallExpression(path)) {",
                        "      return oneLine;",
                        "    }",
                        "    return group(oneLine);",
                        "  }",
                        "",
                        "  // Find out the last node in the first group and check if it has an",
                        "  // empty line after",
                        "  const lastNodeBeforeIndent = getLast(groups[shouldMerge ? 1 : 0]).node;",
                        "  const shouldHaveEmptyLineBeforeIndent =",
                        "    !isCallOrOptionalCallExpression(lastNodeBeforeIndent) &&",
                        "    shouldInsertEmptyLineAfter(lastNodeBeforeIndent);",
                        "",
                        "  const expanded = concat([",
                        "    printGroup(groups[0]),",
                        "    shouldMerge ? printGroup(groups[1]) : \"\",",
                        "    shouldHaveEmptyLineBeforeIndent ? hardline : \"\",",
                        "    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1)),",
                        "  ]);",
                        "",
                        "  const callExpressions = printedNodes",
                        "    .map(({ node }) => node)",
                        "    .filter(isCallOrOptionalCallExpression);",
                        "",
                        "  function looksLikeFluentConfigurationPattern() {",
                        "    if (",
                        "      isExpressionStatement &&",
                        "      callExpressions.length > 1 &&",
                        "      // Keep simple chains like this on one line:",
                        "      //    req.checkBody(\"name\").notEmpty().optional();",
                        "      !(",
                        "        callExpressions[0].arguments.length <= 1 &&",
                        "        callExpressions.slice(1).every((expr) => expr.arguments.length === 0)",
                        "      )",
                        "    ) {",
                        "      const allArgs = flat(callExpressions.map((expr) => expr.arguments));",
                        "      return allArgs.length > 0 && allArgs.every(isLiteralLikeValue);",
                        "    }",
                        "    return false;",
                        "  }",
                        "",
                        "  function callHasComplexArguments(expr, index) {",
                        "    return (",
                        "      (index !== 0 && expr.arguments.length > 2) ||",
                        "      !expr.arguments.every((arg) => isSimpleCallArgument(arg, 0))",
                        "    );",
                        "  }",
                        "",
                        "  /**",
                        "   * If the last call's argument is a function, it's okay to inline if it fits and there is no other function arguments.",
                        "   *",
                        "   * This chain should be split:",
                        "   *",
                        "   *     const mapped = scopes.filter(scope => scope.value !== '').map((scope, i) => {",
                        "   *       // multi line content",
                        "   *     });",
                        "   *",
                        "   * This chain can be inlined:",
                        "   *",
                        "   *     const mapped = scopes.filter(myFilter).map((scope, i) => {",
                        "   *       // multi line content",
                        "   *     });",
                        "   *",
                        "   */",
                        "  function lastGroupWillBreakAndOtherCallsHaveComplexArguments() {",
                        "    const lastGroupNode = getLast(getLast(groups)).node;",
                        "    const lastGroupDoc = getLast(printedGroups);",
                        "    return (",
                        "      isCallOrOptionalCallExpression(lastGroupNode) &&",
                        "      willBreak(lastGroupDoc) &&",
                        "      callExpressions.some(",
                        "        (expr, index) =>",
                        "          index !== callExpressions.length - 1 &&",
                        "          callHasComplexArguments(expr, index)",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  // We don't want to print in one line if at least one of these conditions occurs:",
                        "  //  * the chain has comments,",
                        "  //  * the head of the chain is a constructor call,",
                        "  //  * the chain is an expression statement and all the arguments are literal-like (\"fluent configuration\" pattern),",
                        "  //  * the chain is longer than 2 calls and has non-trivial arguments or more than 2 arguments in any call but the first one,",
                        "  //  * any group but the last one has a hard line,",
                        "  //  * the last call's arguments have a hard line and other calls have non-trivial arguments.",
                        "  if (",
                        "    hasComment ||",
                        "    printedNodes[0].node.type === \"NewExpression\" ||",
                        "    looksLikeFluentConfigurationPattern() ||",
                        "    (callExpressions.length > 2 &&",
                        "      callExpressions.some(callHasComplexArguments)) ||",
                        "    printedGroups.slice(0, -1).some(willBreak) ||",
                        "    lastGroupWillBreakAndOtherCallsHaveComplexArguments()",
                        "  ) {",
                        "    return group(expanded);",
                        "  }",
                        "",
                        "  return concat([",
                        "    // We only need to check `oneLine` because if `expanded` is chosen",
                        "    // that means that the parent group has already been broken",
                        "    // naturally",
                        "    willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\",",
                        "    conditionalGroup([oneLine, expanded]),",
                        "  ]);",
                        "}",
                        "",
                        "module.exports = printMemberChain;"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNumericLiteral } = require(\"../utils\");",
                        "",
                        "const {",
                        "  builders: { concat, softline, group, indent },",
                        "} = require(\"../../document\");",
                        "",
                        "function printOptionalToken(path) {",
                        "  const node = path.getValue();",
                        "  if (",
                        "    !node.optional ||",
                        "    // It's an optional computed method parsed by typescript-estree.",
                        "    // \"?\" is printed in `printMethod`.",
                        "    (node.type === \"Identifier\" && node === path.getParentNode().key)",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "  if (",
                        "    node.type === \"OptionalCallExpression\" ||",
                        "    (node.type === \"OptionalMemberExpression\" && node.computed)",
                        "  ) {",
                        "    return \"?.\";",
                        "  }",
                        "  return \"?\";",
                        "}",
                        "",
                        "function printFunctionTypeParameters(path, options, print) {",
                        "  const fun = path.getValue();",
                        "  if (fun.typeArguments) {",
                        "    return path.call(print, \"typeArguments\");",
                        "  }",
                        "  if (fun.typeParameters) {",
                        "    return path.call(print, \"typeParameters\");",
                        "  }",
                        "  return \"\";",
                        "}",
                        "",
                        "function printMemberLookup(path, options, print) {",
                        "  const property = path.call(print, \"property\");",
                        "  const n = path.getValue();",
                        "  const optional = printOptionalToken(path);",
                        "",
                        "  if (!n.computed) {",
                        "    return concat([optional, \".\", property]);",
                        "  }",
                        "",
                        "  if (!n.property || isNumericLiteral(n.property)) {",
                        "    return concat([optional, \"[\", property, \"]\"]);",
                        "  }",
                        "",
                        "  return group(",
                        "    concat([optional, \"[\", indent(concat([softline, property])), softline, \"]\"])",
                        "  );",
                        "}",
                        "",
                        "function printBindExpressionCallee(path, options, print) {",
                        "  return concat([\"::\", path.call(print, \"callee\")]);",
                        "}",
                        "",
                        "module.exports = {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "  printMemberLookup,",
                        "  printBindExpressionCallee,",
                        "};"
                    ]
                },
                "module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { concat, softline, group, indent, join, line, ifBreak },",
                        "} = require(\"../../document\");",
                        "const { shouldPrintComma } = require(\"../utils\");",
                        "",
                        "function printModuleSource(path, options, print) {",
                        "  const node = path.getValue();",
                        "  return node.source ? concat([\" from \", path.call(print, \"source\")]) : \"\";",
                        "}",
                        "",
                        "function printModuleSpecifiers(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [node.type === \"ImportDeclaration\" ? \" \" : \"\"];",
                        "",
                        "  if (node.specifiers && node.specifiers.length > 0) {",
                        "    const standalonesSpecifiers = [];",
                        "    const groupedSpecifiers = [];",
                        "",
                        "    path.each((specifierPath) => {",
                        "      const specifierType = path.getValue().type;",
                        "      if (",
                        "        specifierType === \"ExportNamespaceSpecifier\" ||",
                        "        specifierType === \"ExportDefaultSpecifier\" ||",
                        "        specifierType === \"ImportNamespaceSpecifier\" ||",
                        "        specifierType === \"ImportDefaultSpecifier\"",
                        "      ) {",
                        "        standalonesSpecifiers.push(print(specifierPath));",
                        "      } else if (",
                        "        specifierType === \"ExportSpecifier\" ||",
                        "        specifierType === \"ImportSpecifier\"",
                        "      ) {",
                        "        groupedSpecifiers.push(print(specifierPath));",
                        "      } else {",
                        "        /* istanbul ignore next */",
                        "        throw new Error(",
                        "          `Unknown specifier type ${JSON.stringify(specifierType)}`",
                        "        );",
                        "      }",
                        "    }, \"specifiers\");",
                        "",
                        "    parts.push(join(\", \", standalonesSpecifiers));",
                        "",
                        "    if (groupedSpecifiers.length !== 0) {",
                        "      if (standalonesSpecifiers.length !== 0) {",
                        "        parts.push(\", \");",
                        "      }",
                        "",
                        "      const canBreak =",
                        "        groupedSpecifiers.length > 1 ||",
                        "        standalonesSpecifiers.length > 0 ||",
                        "        node.specifiers.some((node) => node.comments);",
                        "",
                        "      if (canBreak) {",
                        "        parts.push(",
                        "          group(",
                        "            concat([",
                        "              \"{\",",
                        "              indent(",
                        "                concat([",
                        "                  options.bracketSpacing ? line : softline,",
                        "                  join(concat([\",\", line]), groupedSpecifiers),",
                        "                ])",
                        "              ),",
                        "              ifBreak(shouldPrintComma(options) ? \",\" : \"\"),",
                        "              options.bracketSpacing ? line : softline,",
                        "              \"}\",",
                        "            ])",
                        "          )",
                        "        );",
                        "      } else {",
                        "        parts.push(",
                        "          concat([",
                        "            \"{\",",
                        "            options.bracketSpacing ? \" \" : \"\",",
                        "            concat(groupedSpecifiers),",
                        "            options.bracketSpacing ? \" \" : \"\",",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      }",
                        "    }",
                        "  } else {",
                        "    parts.push(\"{}\");",
                        "  }",
                        "  return concat(parts);",
                        "}",
                        "",
                        "module.exports = {",
                        "  printModuleSource,",
                        "  printModuleSpecifiers,",
                        "};"
                    ]
                }
            }
        },
        "language-markdown": {
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const cjkRegex = require(\"cjk-regex\");",
                    "const regexpUtil = require(\"regexp-util\");",
                    "const unicodeRegex = require(\"unicode-regex\");",
                    "",
                    "const cjkPattern = `(?:${cjkRegex()",
                    "  .union(",
                    "    unicodeRegex({",
                    "      Script_Extensions: [\"Han\", \"Katakana\", \"Hiragana\", \"Hangul\", \"Bopomofo\"],",
                    "      General_Category: [",
                    "        \"Other_Letter\",",
                    "        \"Letter_Number\",",
                    "        \"Other_Symbol\",",
                    "        \"Modifier_Letter\",",
                    "        \"Modifier_Symbol\",",
                    "        \"Nonspacing_Mark\",",
                    "      ],",
                    "    })",
                    "  )",
                    "  .toString()})(?:${unicodeRegex({",
                    "  Block: [\"Variation_Selectors\", \"Variation_Selectors_Supplement\"],",
                    "}).toString()})?`;",
                    "",
                    "const kPattern = unicodeRegex({ Script: [\"Hangul\"] })",
                    "  .union(unicodeRegex({ Script_Extensions: [\"Hangul\"] }))",
                    "  .toString();",
                    "",
                    "// http://spec.commonmark.org/0.25/#ascii-punctuation-character",
                    "const asciiPunctuationCharset = /* prettier-ignore */ regexpUtil.charset(",
                    "  \"!\", '\"', \"#\",  \"$\", \"%\", \"&\", \"'\", \"(\", \")\", \"*\",",
                    "  \"+\", \",\", \"-\",  \".\", \"/\", \":\", \";\", \"<\", \"=\", \">\",",
                    "  \"?\", \"@\", \"[\", \"\\\\\", \"]\", \"^\", \"_\", \"`\", \"{\", \"|\",",
                    "  \"}\", \"~\"",
                    ");",
                    "",
                    "// http://spec.commonmark.org/0.25/#punctuation-character",
                    "const punctuationCharset = unicodeRegex({",
                    "  // http://unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values",
                    "  General_Category: [",
                    "    /* Pc */ \"Connector_Punctuation\",",
                    "    /* Pd */ \"Dash_Punctuation\",",
                    "    /* Pe */ \"Close_Punctuation\",",
                    "    /* Pf */ \"Final_Punctuation\",",
                    "    /* Pi */ \"Initial_Punctuation\",",
                    "    /* Po */ \"Other_Punctuation\",",
                    "    /* Ps */ \"Open_Punctuation\",",
                    "  ],",
                    "}).union(asciiPunctuationCharset);",
                    "",
                    "const punctuationPattern = punctuationCharset.toString();",
                    "",
                    "module.exports = {",
                    "  cjkPattern,",
                    "  kPattern,",
                    "  punctuationPattern,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getParserName,",
                    "  getMaxContinuousCount,",
                    "  isFrontMatterNode,",
                    "} = require(\"../common/util\");",
                    "const {",
                    "  builders: { hardline, literalline, concat, markAsRoot },",
                    "  utils: { mapDoc },",
                    "} = require(\"../document\");",
                    "const { getFencedCodeBlockValue } = require(\"./utils\");",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"code\" && node.lang !== null) {",
                    "    // only look for the first string so as to support [markdown-preview-enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/code-chunk)",
                    "    const langMatch = node.lang.match(/^[\\w-]+/);",
                    "    const lang = langMatch ? langMatch[0] : \"\";",
                    "    const parser = getParserName(lang, options);",
                    "    if (parser) {",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "      );",
                    "      const doc = textToDoc(",
                    "        getFencedCodeBlockValue(node, options.originalText),",
                    "        { parser }",
                    "      );",
                    "      return markAsRoot(",
                    "        concat([",
                    "          style,",
                    "          node.lang,",
                    "          hardline,",
                    "          replaceNewlinesWithLiterallines(doc),",
                    "          style,",
                    "        ])",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (isFrontMatterNode(node) && node.lang === \"yaml\") {",
                    "    return markAsRoot(",
                    "      concat([",
                    "        \"---\",",
                    "        hardline,",
                    "        node.value && node.value.trim()",
                    "          ? replaceNewlinesWithLiterallines(",
                    "              textToDoc(node.value, { parser: \"yaml\" })",
                    "            )",
                    "          : \"\",",
                    "        \"---\",",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  // MDX",
                    "  switch (node.type) {",
                    "    case \"importExport\":",
                    "      return textToDoc(node.value, { parser: \"babel\" });",
                    "    case \"jsx\":",
                    "      return textToDoc(`<$>${node.value}</$>`, {",
                    "        parser: \"__js_expression\",",
                    "        rootMarker: \"mdx\",",
                    "      });",
                    "  }",
                    "",
                    "  return null;",
                    "",
                    "  function replaceNewlinesWithLiterallines(doc) {",
                    "    return mapDoc(doc, (currentDoc) =>",
                    "      typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\")",
                    "        ? concat(",
                    "            currentDoc",
                    "              .split(/(\\n)/g)",
                    "              .map((v, i) => (i % 2 === 0 ? v : literalline))",
                    "          )",
                    "        : currentDoc",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-markdown\");",
                    "const options = require(\"./options\");",
                    "const createLanguage = require(\"../utils/create-language\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/Markdown\"), (data) => ({",
                    "    since: \"1.8.0\",",
                    "    parsers: [\"markdown\"],",
                    "    vscodeLanguageIds: [\"markdown\"],",
                    "    filenames: data.filenames.concat([\"README\"]),",
                    "    extensions: data.extensions.filter((extension) => extension !== \".mdx\"),",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Markdown\"), () => ({",
                    "    name: \"MDX\",",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"mdx\"],",
                    "    vscodeLanguageIds: [\"mdx\"],",
                    "    filenames: [],",
                    "    extensions: [\".mdx\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  mdast: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "};"
                ]
            },
            "mdx.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * modified from https://github.com/mdx-js/mdx/blob/master/packages/mdx",
                    " *",
                    " * The MIT License (MIT)",
                    " *",
                    " * Copyright (c) 2017-2018 Compositor and Zeit, Inc.",
                    " *",
                    " * Permission is hereby granted, free of charge, to any person obtaining a copy",
                    " * of this software and associated documentation files (the \"Software\"), to deal",
                    " * in the Software without restriction, including without limitation the rights",
                    " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
                    " * copies of the Software, and to permit persons to whom the Software is",
                    " * furnished to do so, subject to the following conditions:",
                    " * The above copyright notice and this permission notice shall be included in",
                    " * all copies or substantial portions of the Software.",
                    " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
                    " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
                    " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
                    " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
                    " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
                    " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
                    " * THE SOFTWARE.",
                    " */",
                    "",
                    "const IMPORT_REGEX = /^import\\s/;",
                    "const EXPORT_REGEX = /^export\\s/;",
                    "const BLOCKS_REGEX = \"[a-z][a-z0-9]*(\\\\.[a-z][a-z0-9]*)*|\";",
                    "const COMMENT_REGEX = \"<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->\";",
                    "const EMPTY_NEWLINE = \"\\n\\n\";",
                    "",
                    "const isImport = (text) => IMPORT_REGEX.test(text);",
                    "const isExport = (text) => EXPORT_REGEX.test(text);",
                    "",
                    "const tokenizeEsSyntax = (eat, value) => {",
                    "  const index = value.indexOf(EMPTY_NEWLINE);",
                    "  const subvalue = value.slice(0, index);",
                    "",
                    "  if (isExport(subvalue) || isImport(subvalue)) {",
                    "    return eat(subvalue)({",
                    "      type: isExport(subvalue) ? \"export\" : \"import\",",
                    "      value: subvalue,",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "tokenizeEsSyntax.locator = (value /*, fromIndex*/) => {",
                    "  return isExport(value) || isImport(value) ? -1 : 1;",
                    "};",
                    "",
                    "function esSyntax() {",
                    "  const { Parser } = this;",
                    "  const tokenizers = Parser.prototype.blockTokenizers;",
                    "  const methods = Parser.prototype.blockMethods;",
                    "",
                    "  tokenizers.esSyntax = tokenizeEsSyntax;",
                    "",
                    "  methods.splice(methods.indexOf(\"paragraph\"), 0, \"esSyntax\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  esSyntax,",
                    "  BLOCKS_REGEX,",
                    "  COMMENT_REGEX,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js",
                    "module.exports = {",
                    "  proseWrap: commonOptions.proseWrap,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};"
                ]
            },
            "parser-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const remarkParse = require(\"remark-parse\");",
                    "const unified = require(\"unified\");",
                    "const pragma = require(\"./pragma\");",
                    "const parseFrontMatter = require(\"../utils/front-matter\");",
                    "const { mapAst, INLINE_NODE_WRAPPER_TYPES } = require(\"./utils\");",
                    "const mdx = require(\"./mdx\");",
                    "const remarkMath = require(\"remark-math\");",
                    "",
                    "/**",
                    " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                    " *",
                    " * 1. restore unescaped character (Text)",
                    " * 2. merge continuous Texts",
                    " * 3. replace whitespaces in InlineCode#value with one whitespace",
                    " *    reference: http://spec.commonmark.org/0.25/#example-605",
                    " * 4. split Text into Sentence",
                    " *",
                    " * interface Word { value: string }",
                    " * interface Whitespace { value: string }",
                    " * interface Sentence { children: Array<Word | Whitespace> }",
                    " * interface InlineCode { children: Array<Sentence> }",
                    " */",
                    "function createParse({ isMDX }) {",
                    "  return (text) => {",
                    "    const processor = unified()",
                    "      .use(remarkParse, {",
                    "        footnotes: true,",
                    "        commonmark: true,",
                    "        ...(isMDX && { blocks: [mdx.BLOCKS_REGEX] }),",
                    "      })",
                    "      .use(frontMatter)",
                    "      .use(remarkMath)",
                    "      .use(isMDX ? mdx.esSyntax : identity)",
                    "      .use(liquid)",
                    "      .use(isMDX ? htmlToJsx : identity);",
                    "    return processor.runSync(processor.parse(text));",
                    "  };",
                    "}",
                    "",
                    "function identity(x) {",
                    "  return x;",
                    "}",
                    "",
                    "function htmlToJsx() {",
                    "  return (ast) =>",
                    "    mapAst(ast, (node, _index, [parent]) => {",
                    "      if (",
                    "        node.type !== \"html\" ||",
                    "        node.value.match(mdx.COMMENT_REGEX) ||",
                    "        INLINE_NODE_WRAPPER_TYPES.includes(parent.type)",
                    "      ) {",
                    "        return node;",
                    "      }",
                    "",
                    "      return { ...node, type: \"jsx\" };",
                    "    });",
                    "}",
                    "",
                    "function frontMatter() {",
                    "  const proto = this.Parser.prototype;",
                    "  proto.blockMethods = [\"frontMatter\"].concat(proto.blockMethods);",
                    "  proto.blockTokenizers.frontMatter = tokenizer;",
                    "",
                    "  function tokenizer(eat, value) {",
                    "    const parsed = parseFrontMatter(value);",
                    "",
                    "    if (parsed.frontMatter) {",
                    "      return eat(parsed.frontMatter.raw)(parsed.frontMatter);",
                    "    }",
                    "  }",
                    "  tokenizer.onlyAtStart = true;",
                    "}",
                    "",
                    "function liquid() {",
                    "  const proto = this.Parser.prototype;",
                    "  const methods = proto.inlineMethods;",
                    "  methods.splice(methods.indexOf(\"text\"), 0, \"liquid\");",
                    "  proto.inlineTokenizers.liquid = tokenizer;",
                    "",
                    "  function tokenizer(eat, value) {",
                    "    const match = value.match(/^({%[\\S\\s]*?%}|{{[\\S\\s]*?}})/);",
                    "",
                    "    if (match) {",
                    "      return eat(match[0])({",
                    "        type: \"liquidNode\",",
                    "        value: match[0],",
                    "      });",
                    "    }",
                    "  }",
                    "  tokenizer.locator = function (value, fromIndex) {",
                    "    return value.indexOf(\"{\", fromIndex);",
                    "  };",
                    "}",
                    "",
                    "const baseParser = {",
                    "  astFormat: \"mdast\",",
                    "  hasPragma: pragma.hasPragma,",
                    "  locStart: (node) => node.position.start.offset,",
                    "  locEnd: (node) => node.position.end.offset,",
                    "  preprocess: (text) => text.replace(/\\n\\s+$/, \"\\n\"), // workaround for https://github.com/remarkjs/remark/issues/350",
                    "};",
                    "",
                    "const markdownParser = { ...baseParser, parse: createParse({ isMDX: false }) };",
                    "",
                    "const mdxParser = { ...baseParser, parse: createParse({ isMDX: true }) };",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    remark: markdownParser,",
                    "    markdown: markdownParser,",
                    "    mdx: mdxParser,",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parseFrontMatter = require(\"../utils/front-matter\");",
                    "",
                    "const pragmas = [\"format\", \"prettier\"];",
                    "",
                    "function startWithPragma(text) {",
                    "  const pragma = `@(${pragmas.join(\"|\")})`;",
                    "  const regex = new RegExp(",
                    "    [",
                    "      `<!--\\\\s*${pragma}\\\\s*-->`,",
                    "      `<!--.*\\r?\\n[\\\\s\\\\S]*(^|\\n)[^\\\\S\\n]*${pragma}[^\\\\S\\n]*($|\\n)[\\\\s\\\\S]*\\n.*-->`,",
                    "    ].join(\"|\"),",
                    "    \"m\"",
                    "  );",
                    "  const matched = text.match(regex);",
                    "  return matched && matched.index === 0;",
                    "}",
                    "",
                    "module.exports = {",
                    "  startWithPragma,",
                    "  hasPragma: (text) =>",
                    "    startWithPragma(parseFrontMatter(text).content.trimStart()),",
                    "  insertPragma: (text) => {",
                    "    const extracted = parseFrontMatter(text);",
                    "    const pragma = `<!-- @${pragmas[0]} -->`;",
                    "    return extracted.frontMatter",
                    "      ? `${extracted.frontMatter.raw}\\n\\n${pragma}\\n\\n${extracted.content}`",
                    "      : `${pragma}\\n\\n${extracted.content}`;",
                    "  },",
                    "};"
                ]
            },
            "preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { getOrderedListItemInfo, mapAst, splitText } = require(\"./utils\");",
                    "",
                    "// 0x0 ~ 0x10ffff",
                    "// eslint-disable-next-line no-control-regex",
                    "const isSingleCharRegex = /^([\\u0000-\\uffff]|[\\ud800-\\udbff][\\udc00-\\udfff])$/;",
                    "",
                    "function preprocess(ast, options) {",
                    "  ast = restoreUnescapedCharacter(ast, options);",
                    "  ast = mergeContinuousTexts(ast);",
                    "  ast = transformInlineCode(ast);",
                    "  ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);",
                    "  ast = markAlignedList(ast, options);",
                    "  ast = splitTextIntoSentences(ast, options);",
                    "  ast = transformImportExport(ast);",
                    "  ast = mergeContinuousImportExport(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "function transformImportExport(ast) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (node.type !== \"import\" && node.type !== \"export\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    return { ...node, type: \"importExport\" };",
                    "  });",
                    "}",
                    "",
                    "function transformInlineCode(ast) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (node.type !== \"inlineCode\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    return { ...node, value: node.value.replace(/\\s+/g, \" \") };",
                    "  });",
                    "}",
                    "",
                    "function restoreUnescapedCharacter(ast, options) {",
                    "  return mapAst(ast, (node) => {",
                    "    return node.type !== \"text\"",
                    "      ? node",
                    "      : {",
                    "          ...node,",
                    "          value:",
                    "            node.value !== \"*\" &&",
                    "            node.value !== \"_\" &&",
                    "            node.value !== \"$\" && // handle these cases in printer",
                    "            isSingleCharRegex.test(node.value) &&",
                    "            node.position.end.offset - node.position.start.offset !==",
                    "              node.value.length",
                    "              ? options.originalText.slice(",
                    "                  node.position.start.offset,",
                    "                  node.position.end.offset",
                    "                )",
                    "              : node.value,",
                    "        };",
                    "  });",
                    "}",
                    "",
                    "function mergeContinuousImportExport(ast) {",
                    "  return mergeChildren(",
                    "    ast,",
                    "    (prevNode, node) =>",
                    "      prevNode.type === \"importExport\" && node.type === \"importExport\",",
                    "    (prevNode, node) => ({",
                    "      type: \"importExport\",",
                    "      value: prevNode.value + \"\\n\\n\" + node.value,",
                    "      position: {",
                    "        start: prevNode.position.start,",
                    "        end: node.position.end,",
                    "      },",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function mergeChildren(ast, shouldMerge, mergeNode) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (!node.children) {",
                    "      return node;",
                    "    }",
                    "    const children = node.children.reduce((current, child) => {",
                    "      const lastChild = current[current.length - 1];",
                    "      if (lastChild && shouldMerge(lastChild, child)) {",
                    "        current.splice(-1, 1, mergeNode(lastChild, child));",
                    "      } else {",
                    "        current.push(child);",
                    "      }",
                    "      return current;",
                    "    }, []);",
                    "    return { ...node, children };",
                    "  });",
                    "}",
                    "",
                    "function mergeContinuousTexts(ast) {",
                    "  return mergeChildren(",
                    "    ast,",
                    "    (prevNode, node) => prevNode.type === \"text\" && node.type === \"text\",",
                    "    (prevNode, node) => ({",
                    "      type: \"text\",",
                    "      value: prevNode.value + node.value,",
                    "      position: {",
                    "        start: prevNode.position.start,",
                    "        end: node.position.end,",
                    "      },",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function splitTextIntoSentences(ast, options) {",
                    "  return mapAst(ast, (node, index, [parentNode]) => {",
                    "    if (node.type !== \"text\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    let { value } = node;",
                    "",
                    "    if (parentNode.type === \"paragraph\") {",
                    "      if (index === 0) {",
                    "        value = value.trimStart();",
                    "      }",
                    "      if (index === parentNode.children.length - 1) {",
                    "        value = value.trimEnd();",
                    "      }",
                    "    }",
                    "",
                    "    return {",
                    "      type: \"sentence\",",
                    "      position: node.position,",
                    "      children: splitText(value, options),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function transformIndentedCodeblockAndMarkItsParentList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"code\") {",
                    "      // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it",
                    "      const isIndented = /^\\n?( {4,}|\\t)/.test(",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        )",
                    "      );",
                    "",
                    "      node.isIndented = isIndented;",
                    "",
                    "      if (isIndented) {",
                    "        for (let i = 0; i < parentStack.length; i++) {",
                    "          const parent = parentStack[i];",
                    "",
                    "          // no need to check checked items",
                    "          if (parent.hasIndentedCodeblock) {",
                    "            break;",
                    "          }",
                    "",
                    "          if (parent.type === \"list\") {",
                    "            parent.hasIndentedCodeblock = true;",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function markAlignedList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"list\" && node.children.length !== 0) {",
                    "      // if one of its parents is not aligned, it's not possible to be aligned in sub-lists",
                    "      for (let i = 0; i < parentStack.length; i++) {",
                    "        const parent = parentStack[i];",
                    "        if (parent.type === \"list\" && !parent.isAligned) {",
                    "          node.isAligned = false;",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      node.isAligned = isAligned(node);",
                    "    }",
                    "",
                    "    return node;",
                    "  });",
                    "",
                    "  function getListItemStart(listItem) {",
                    "    return listItem.children.length === 0",
                    "      ? -1",
                    "      : listItem.children[0].position.start.column - 1;",
                    "  }",
                    "",
                    "  function isAligned(list) {",
                    "    if (!list.ordered) {",
                    "      /**",
                    "       * - 123",
                    "       * - 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const [firstItem, secondItem] = list.children;",
                    "",
                    "    const firstInfo = getOrderedListItemInfo(firstItem, options.originalText);",
                    "",
                    "    if (firstInfo.leadingSpaces.length > 1) {",
                    "      /**",
                    "       * 1.   123",
                    "       *",
                    "       * 1.   123",
                    "       * 1. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const firstStart = getListItemStart(firstItem);",
                    "",
                    "    if (firstStart === -1) {",
                    "      /**",
                    "       * 1.",
                    "       *",
                    "       * 1.",
                    "       * 1.",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (list.children.length === 1) {",
                    "      /**",
                    "       * aligned:",
                    "       *",
                    "       * 11. 123",
                    "       *",
                    "       * not aligned:",
                    "       *",
                    "       * 1. 123",
                    "       */",
                    "      return firstStart % options.tabWidth === 0;",
                    "    }",
                    "",
                    "    const secondStart = getListItemStart(secondItem);",
                    "",
                    "    if (firstStart !== secondStart) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 1. 123",
                    "       *",
                    "       * 1. 123",
                    "       * 11. 123",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (firstStart % options.tabWidth === 0) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 12. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    /**",
                    "     * aligned:",
                    "     *",
                    "     * 11. 123",
                    "     * 1.  123",
                    "     *",
                    "     * not aligned:",
                    "     *",
                    "     * 1. 123",
                    "     * 2. 123",
                    "     */",
                    "    const secondInfo = getOrderedListItemInfo(secondItem, options.originalText);",
                    "    return secondInfo.leadingSpaces.length > 1;",
                    "  }",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const privateUtil = require(\"../common/util\");",
                    "const embed = require(\"./embed\");",
                    "const pragma = require(\"./pragma\");",
                    "const preprocess = require(\"./preprocess\");",
                    "const {",
                    "  builders: {",
                    "    breakParent,",
                    "    concat,",
                    "    join,",
                    "    line,",
                    "    literalline,",
                    "    markAsRoot,",
                    "    hardline,",
                    "    softline,",
                    "    ifBreak,",
                    "    fill,",
                    "    align,",
                    "    indent,",
                    "    group,",
                    "  },",
                    "  utils: { normalizeDoc },",
                    "  printer: { printDocToString },",
                    "} = require(\"../document\");",
                    "const {",
                    "  getFencedCodeBlockValue,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "} = require(\"./utils\");",
                    "const { replaceEndOfLineWith, isFrontMatterNode } = require(\"../common/util\");",
                    "",
                    "const TRAILING_HARDLINE_NODES = new Set([\"importExport\"]);",
                    "const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\"];",
                    "const SIBLING_NODE_TYPES = new Set([",
                    "  \"listItem\",",
                    "  \"definition\",",
                    "  \"footnoteDefinition\",",
                    "]);",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (shouldRemainTheSameContent(path)) {",
                    "    return concat(",
                    "      splitText(",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        ),",
                    "        options",
                    "      ).map((node) =>",
                    "        node.type === \"word\"",
                    "          ? node.value",
                    "          : node.value === \"\"",
                    "          ? \"\"",
                    "          : printLine(path, node.value, options)",
                    "      )",
                    "    );",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"root\":",
                    "      if (node.children.length === 0) {",
                    "        return \"\";",
                    "      }",
                    "      return concat([",
                    "        normalizeDoc(printRoot(path, options, print)),",
                    "        !TRAILING_HARDLINE_NODES.has(getLastDescendantNode(node).type)",
                    "          ? hardline",
                    "          : \"\",",
                    "      ]);",
                    "    case \"paragraph\":",
                    "      return printChildren(path, options, print, {",
                    "        postprocessor: fill,",
                    "      });",
                    "    case \"sentence\":",
                    "      return printChildren(path, options, print);",
                    "    case \"word\":",
                    "      return node.value",
                    "        .replace(/[$*]/g, \"\\\\$&\") // escape all `*` and `$` (math)",
                    "        .replace(",
                    "          new RegExp(",
                    "            [",
                    "              `(^|${punctuationPattern})(_+)`,",
                    "              `(_+)(${punctuationPattern}|$)`,",
                    "            ].join(\"|\"),",
                    "            \"g\"",
                    "          ),",
                    "          (_, text1, underscore1, underscore2, text2) =>",
                    "            (underscore1",
                    "              ? `${text1}${underscore1}`",
                    "              : `${underscore2}${text2}`",
                    "            ).replace(/_/g, \"\\\\_\")",
                    "        ); // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis",
                    "    case \"whitespace\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode.children.indexOf(node);",
                    "      const nextNode = parentNode.children[index + 1];",
                    "",
                    "      const proseWrap =",
                    "        // leading char that may cause different syntax",
                    "        nextNode && /^>|^([*+-]|#{1,6}|\\d+[).])$/.test(nextNode.value)",
                    "          ? \"never\"",
                    "          : options.proseWrap;",
                    "",
                    "      return printLine(path, node.value, { proseWrap });",
                    "    }",
                    "    case \"emphasis\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode.children.indexOf(node);",
                    "      const prevNode = parentNode.children[index - 1];",
                    "      const nextNode = parentNode.children[index + 1];",
                    "      const hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not",
                    "        (prevNode &&",
                    "          prevNode.type === \"sentence\" &&",
                    "          prevNode.children.length > 0 &&",
                    "          privateUtil.getLast(prevNode.children).type === \"word\" &&",
                    "          !privateUtil.getLast(prevNode.children).hasTrailingPunctuation) ||",
                    "        (nextNode &&",
                    "          nextNode.type === \"sentence\" &&",
                    "          nextNode.children.length > 0 &&",
                    "          nextNode.children[0].type === \"word\" &&",
                    "          !nextNode.children[0].hasLeadingPunctuation);",
                    "      const style =",
                    "        hasPrevOrNextWord || getAncestorNode(path, \"emphasis\") ? \"*\" : \"_\";",
                    "      return concat([style, printChildren(path, options, print), style]);",
                    "    }",
                    "    case \"strong\":",
                    "      return concat([\"**\", printChildren(path, options, print), \"**\"]);",
                    "    case \"delete\":",
                    "      return concat([\"~~\", printChildren(path, options, print), \"~~\"]);",
                    "    case \"inlineCode\": {",
                    "      const backtickCount = privateUtil.getMinNotPresentContinuousCount(",
                    "        node.value,",
                    "        \"`\"",
                    "      );",
                    "      const style = \"`\".repeat(backtickCount || 1);",
                    "      const gap = backtickCount ? \" \" : \"\";",
                    "      return concat([style, gap, node.value, gap, style]);",
                    "    }",
                    "    case \"link\":",
                    "      switch (options.originalText[node.position.start.offset]) {",
                    "        case \"<\": {",
                    "          const mailto = \"mailto:\";",
                    "          const url =",
                    "            // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }",
                    "            node.url.startsWith(mailto) &&",
                    "            options.originalText.slice(",
                    "              node.position.start.offset + 1,",
                    "              node.position.start.offset + 1 + mailto.length",
                    "            ) !== mailto",
                    "              ? node.url.slice(mailto.length)",
                    "              : node.url;",
                    "          return concat([\"<\", url, \">\"]);",
                    "        }",
                    "        case \"[\":",
                    "          return concat([",
                    "            \"[\",",
                    "            printChildren(path, options, print),",
                    "            \"](\",",
                    "            printUrl(node.url, \")\"),",
                    "            printTitle(node.title, options),",
                    "            \")\",",
                    "          ]);",
                    "        default:",
                    "          return options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          );",
                    "      }",
                    "    case \"image\":",
                    "      return concat([",
                    "        \"![\",",
                    "        node.alt || \"\",",
                    "        \"](\",",
                    "        printUrl(node.url, \")\"),",
                    "        printTitle(node.title, options),",
                    "        \")\",",
                    "      ]);",
                    "    case \"blockquote\":",
                    "      return concat([\"> \", align(\"> \", printChildren(path, options, print))]);",
                    "    case \"heading\":",
                    "      return concat([",
                    "        \"#\".repeat(node.depth) + \" \",",
                    "        printChildren(path, options, print),",
                    "      ]);",
                    "    case \"code\": {",
                    "      if (node.isIndented) {",
                    "        // indented code block",
                    "        const alignment = \" \".repeat(4);",
                    "        return align(",
                    "          alignment,",
                    "          concat([",
                    "            alignment,",
                    "            concat(replaceEndOfLineWith(node.value, hardline)),",
                    "          ])",
                    "        );",
                    "      }",
                    "",
                    "      // fenced code block",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(",
                    "          3,",
                    "          privateUtil.getMaxContinuousCount(node.value, styleUnit) + 1",
                    "        )",
                    "      );",
                    "      return concat([",
                    "        style,",
                    "        node.lang || \"\",",
                    "        hardline,",
                    "        concat(",
                    "          replaceEndOfLineWith(",
                    "            getFencedCodeBlockValue(node, options.originalText),",
                    "            hardline",
                    "          )",
                    "        ),",
                    "        hardline,",
                    "        style,",
                    "      ]);",
                    "    }",
                    "    case \"yaml\":",
                    "    case \"toml\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"html\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const value =",
                    "        parentNode.type === \"root\" &&",
                    "        privateUtil.getLast(parentNode.children) === node",
                    "          ? node.value.trimEnd()",
                    "          : node.value;",
                    "      const isHtmlComment = /^<!--[\\S\\s]*-->$/.test(value);",
                    "      return concat(",
                    "        replaceEndOfLineWith(",
                    "          value,",
                    "          isHtmlComment ? hardline : markAsRoot(literalline)",
                    "        )",
                    "      );",
                    "    }",
                    "    case \"list\": {",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        node,",
                    "        path.getParentNode()",
                    "      );",
                    "",
                    "      const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(",
                    "        node,",
                    "        options",
                    "      );",
                    "",
                    "      return printChildren(path, options, print, {",
                    "        processor: (childPath, index) => {",
                    "          const prefix = getPrefix();",
                    "          const childNode = childPath.getValue();",
                    "",
                    "          if (",
                    "            childNode.children.length === 2 &&",
                    "            childNode.children[1].type === \"html\" &&",
                    "            childNode.children[0].position.start.column !==",
                    "              childNode.children[1].position.start.column",
                    "          ) {",
                    "            return concat([",
                    "              prefix,",
                    "              printListItem(childPath, options, print, prefix),",
                    "            ]);",
                    "          }",
                    "",
                    "          return concat([",
                    "            prefix,",
                    "            align(",
                    "              \" \".repeat(prefix.length),",
                    "              printListItem(childPath, options, print, prefix)",
                    "            ),",
                    "          ]);",
                    "",
                    "          function getPrefix() {",
                    "            const rawPrefix = node.ordered",
                    "              ? (index === 0",
                    "                  ? node.start",
                    "                  : isGitDiffFriendlyOrderedList",
                    "                  ? 1",
                    "                  : node.start + index) +",
                    "                (nthSiblingIndex % 2 === 0 ? \". \" : \") \")",
                    "              : nthSiblingIndex % 2 === 0",
                    "              ? \"- \"",
                    "              : \"* \";",
                    "",
                    "            return node.isAligned ||",
                    "              /* workaround for https://github.com/remarkjs/remark/issues/315 */ node.hasIndentedCodeblock",
                    "              ? alignListPrefix(rawPrefix, options)",
                    "              : rawPrefix;",
                    "          }",
                    "        },",
                    "      });",
                    "    }",
                    "    case \"thematicBreak\": {",
                    "      const counter = getAncestorCounter(path, \"list\");",
                    "      if (counter === -1) {",
                    "        return \"---\";",
                    "      }",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        path.getParentNode(counter),",
                    "        path.getParentNode(counter + 1)",
                    "      );",
                    "      return nthSiblingIndex % 2 === 0 ? \"***\" : \"---\";",
                    "    }",
                    "    case \"linkReference\":",
                    "      return concat([",
                    "        \"[\",",
                    "        printChildren(path, options, print),",
                    "        \"]\",",
                    "        node.referenceType === \"full\"",
                    "          ? concat([\"[\", node.identifier, \"]\"])",
                    "          : node.referenceType === \"collapsed\"",
                    "          ? \"[]\"",
                    "          : \"\",",
                    "      ]);",
                    "    case \"imageReference\":",
                    "      switch (node.referenceType) {",
                    "        case \"full\":",
                    "          return concat([\"![\", node.alt || \"\", \"][\", node.identifier, \"]\"]);",
                    "        default:",
                    "          return concat([",
                    "            \"![\",",
                    "            node.alt,",
                    "            \"]\",",
                    "            node.referenceType === \"collapsed\" ? \"[]\" : \"\",",
                    "          ]);",
                    "      }",
                    "    case \"definition\": {",
                    "      const lineOrSpace = options.proseWrap === \"always\" ? line : \" \";",
                    "      return group(",
                    "        concat([",
                    "          concat([\"[\", node.identifier, \"]:\"]),",
                    "          indent(",
                    "            concat([",
                    "              lineOrSpace,",
                    "              printUrl(node.url),",
                    "              node.title === null",
                    "                ? \"\"",
                    "                : concat([lineOrSpace, printTitle(node.title, options, false)]),",
                    "            ])",
                    "          ),",
                    "        ])",
                    "      );",
                    "    }",
                    "    case \"footnote\":",
                    "      return concat([\"[^\", printChildren(path, options, print), \"]\"]);",
                    "    case \"footnoteReference\":",
                    "      return concat([\"[^\", node.identifier, \"]\"]);",
                    "    case \"footnoteDefinition\": {",
                    "      const nextNode = path.getParentNode().children[path.getName() + 1];",
                    "      const shouldInlineFootnote =",
                    "        node.children.length === 1 &&",
                    "        node.children[0].type === \"paragraph\" &&",
                    "        (options.proseWrap === \"never\" ||",
                    "          (options.proseWrap === \"preserve\" &&",
                    "            node.children[0].position.start.line ===",
                    "              node.children[0].position.end.line));",
                    "      return concat([",
                    "        \"[^\",",
                    "        node.identifier,",
                    "        \"]: \",",
                    "        shouldInlineFootnote",
                    "          ? printChildren(path, options, print)",
                    "          : group(",
                    "              concat([",
                    "                align(",
                    "                  \" \".repeat(options.tabWidth),",
                    "                  printChildren(path, options, print, {",
                    "                    processor: (childPath, index) => {",
                    "                      return index === 0",
                    "                        ? group(concat([softline, childPath.call(print)]))",
                    "                        : childPath.call(print);",
                    "                    },",
                    "                  })",
                    "                ),",
                    "                nextNode && nextNode.type === \"footnoteDefinition\"",
                    "                  ? softline",
                    "                  : \"\",",
                    "              ])",
                    "            ),",
                    "      ]);",
                    "    }",
                    "    case \"table\":",
                    "      return printTable(path, options, print);",
                    "    case \"tableCell\":",
                    "      return printChildren(path, options, print);",
                    "    case \"break\":",
                    "      return /\\s/.test(options.originalText[node.position.start.offset])",
                    "        ? concat([\"  \", markAsRoot(literalline)])",
                    "        : concat([\"\\\\\", hardline]);",
                    "    case \"liquidNode\":",
                    "      return concat(replaceEndOfLineWith(node.value, hardline));",
                    "    // MDX",
                    "    case \"importExport\":",
                    "    case \"jsx\":",
                    "      return node.value; // fallback to the original text if multiparser failed",
                    "    case \"math\":",
                    "      return concat([",
                    "        \"$$\",",
                    "        hardline,",
                    "        node.value",
                    "          ? concat([",
                    "              concat(replaceEndOfLineWith(node.value, hardline)),",
                    "              hardline,",
                    "            ])",
                    "          : \"\",",
                    "        \"$$\",",
                    "      ]);",
                    "    case \"inlineMath\": {",
                    "      // remark-math trims content but we don't want to remove whitespaces",
                    "      // since it's very possible that it's recognized as math accidentally",
                    "      return options.originalText.slice(",
                    "        options.locStart(node),",
                    "        options.locEnd(node)",
                    "      );",
                    "    }",
                    "",
                    "    case \"tableRow\": // handled in \"table\"",
                    "    case \"listItem\": // handled in \"list\"",
                    "    default:",
                    "      throw new Error(`Unknown markdown type ${JSON.stringify(node.type)}`);",
                    "  }",
                    "}",
                    "",
                    "function printListItem(path, options, print, listPrefix) {",
                    "  const node = path.getValue();",
                    "  const prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";",
                    "  return concat([",
                    "    prefix,",
                    "    printChildren(path, options, print, {",
                    "      processor: (childPath, index) => {",
                    "        if (index === 0 && childPath.getValue().type !== \"list\") {",
                    "          return align(\" \".repeat(prefix.length), childPath.call(print));",
                    "        }",
                    "",
                    "        const alignment = \" \".repeat(",
                    "          clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block",
                    "        );",
                    "        return concat([alignment, align(alignment, childPath.call(print))]);",
                    "      },",
                    "    }),",
                    "  ]);",
                    "}",
                    "",
                    "function alignListPrefix(prefix, options) {",
                    "  const additionalSpaces = getAdditionalSpaces();",
                    "  return (",
                    "    prefix +",
                    "    \" \".repeat(",
                    "      additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block",
                    "    )",
                    "  );",
                    "",
                    "  function getAdditionalSpaces() {",
                    "    const restSpaces = prefix.length % options.tabWidth;",
                    "    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;",
                    "  }",
                    "}",
                    "",
                    "function getNthListSiblingIndex(node, parentNode) {",
                    "  return getNthSiblingIndex(",
                    "    node,",
                    "    parentNode,",
                    "    (siblingNode) => siblingNode.ordered === node.ordered",
                    "  );",
                    "}",
                    "",
                    "function getNthSiblingIndex(node, parentNode, condition) {",
                    "  condition = condition || (() => true);",
                    "",
                    "  let index = -1;",
                    "",
                    "  for (const childNode of parentNode.children) {",
                    "    if (childNode.type === node.type && condition(childNode)) {",
                    "      index++;",
                    "    } else {",
                    "      index = -1;",
                    "    }",
                    "",
                    "    if (childNode === node) {",
                    "      return index;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getAncestorCounter(path, typeOrTypes) {",
                    "  const types = [].concat(typeOrTypes);",
                    "",
                    "  let counter = -1;",
                    "  let ancestorNode;",
                    "",
                    "  while ((ancestorNode = path.getParentNode(++counter))) {",
                    "    if (types.includes(ancestorNode.type)) {",
                    "      return counter;",
                    "    }",
                    "  }",
                    "",
                    "  return -1;",
                    "}",
                    "",
                    "function getAncestorNode(path, typeOrTypes) {",
                    "  const counter = getAncestorCounter(path, typeOrTypes);",
                    "  return counter === -1 ? null : path.getParentNode(counter);",
                    "}",
                    "",
                    "function printLine(path, value, options) {",
                    "  if (options.proseWrap === \"preserve\" && value === \"\\n\") {",
                    "    return hardline;",
                    "  }",
                    "",
                    "  const isBreakable =",
                    "    options.proseWrap === \"always\" &&",
                    "    !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);",
                    "  return value !== \"\"",
                    "    ? isBreakable",
                    "      ? line",
                    "      : \" \"",
                    "    : isBreakable",
                    "    ? softline",
                    "    : \"\";",
                    "}",
                    "",
                    "function printTable(path, options, print) {",
                    "  const hardlineWithoutBreakParent = hardline.parts[0];",
                    "  const node = path.getValue();",
                    "  const contents = []; // { [rowIndex: number]: { [columnIndex: number]: string } }",
                    "",
                    "  path.map((rowPath) => {",
                    "    const rowContents = [];",
                    "",
                    "    rowPath.map((cellPath) => {",
                    "      rowContents.push(",
                    "        printDocToString(cellPath.call(print), options).formatted",
                    "      );",
                    "    }, \"children\");",
                    "",
                    "    contents.push(rowContents);",
                    "  }, \"children\");",
                    "",
                    "  // Get the width of each column",
                    "  const columnMaxWidths = contents.reduce(",
                    "    (currentWidths, rowContents) =>",
                    "      currentWidths.map((width, columnIndex) =>",
                    "        Math.max(width, privateUtil.getStringWidth(rowContents[columnIndex]))",
                    "      ),",
                    "    contents[0].map(() => 3) // minimum width = 3 (---, :--, :-:, --:)",
                    "  );",
                    "  const alignedTable = join(hardlineWithoutBreakParent, [",
                    "    printRow(contents[0]),",
                    "    printSeparator(),",
                    "    join(",
                    "      hardlineWithoutBreakParent,",
                    "      contents.slice(1).map((rowContents) => printRow(rowContents))",
                    "    ),",
                    "  ]);",
                    "",
                    "  if (options.proseWrap !== \"never\") {",
                    "    return concat([breakParent, alignedTable]);",
                    "  }",
                    "",
                    "  // Only if the --prose-wrap never is set and it exceeds the print width.",
                    "  const compactTable = join(hardlineWithoutBreakParent, [",
                    "    printRow(contents[0], /* isCompact */ true),",
                    "    printSeparator(/* isCompact */ true),",
                    "    join(",
                    "      hardlineWithoutBreakParent,",
                    "      contents",
                    "        .slice(1)",
                    "        .map((rowContents) => printRow(rowContents, /* isCompact */ true))",
                    "    ),",
                    "  ]);",
                    "",
                    "  return concat([breakParent, group(ifBreak(compactTable, alignedTable))]);",
                    "",
                    "  function printSeparator(isCompact) {",
                    "    return concat([",
                    "      \"| \",",
                    "      join(",
                    "        \" | \",",
                    "        columnMaxWidths.map((width, index) => {",
                    "          const spaces = isCompact ? 3 : width;",
                    "          switch (node.align[index]) {",
                    "            case \"left\":",
                    "              return \":\" + \"-\".repeat(spaces - 1);",
                    "            case \"right\":",
                    "              return \"-\".repeat(spaces - 1) + \":\";",
                    "            case \"center\":",
                    "              return \":\" + \"-\".repeat(spaces - 2) + \":\";",
                    "            default:",
                    "              return \"-\".repeat(spaces);",
                    "          }",
                    "        })",
                    "      ),",
                    "      \" |\",",
                    "    ]);",
                    "  }",
                    "",
                    "  function printRow(rowContents, isCompact) {",
                    "    return concat([",
                    "      \"| \",",
                    "      join(",
                    "        \" | \",",
                    "        isCompact",
                    "          ? rowContents",
                    "          : rowContents.map((rowContent, columnIndex) => {",
                    "              switch (node.align[columnIndex]) {",
                    "                case \"right\":",
                    "                  return alignRight(rowContent, columnMaxWidths[columnIndex]);",
                    "                case \"center\":",
                    "                  return alignCenter(rowContent, columnMaxWidths[columnIndex]);",
                    "                default:",
                    "                  return alignLeft(rowContent, columnMaxWidths[columnIndex]);",
                    "              }",
                    "            })",
                    "      ),",
                    "      \" |\",",
                    "    ]);",
                    "  }",
                    "",
                    "  function alignLeft(text, width) {",
                    "    const spaces = width - privateUtil.getStringWidth(text);",
                    "    return concat([text, \" \".repeat(spaces)]);",
                    "  }",
                    "",
                    "  function alignRight(text, width) {",
                    "    const spaces = width - privateUtil.getStringWidth(text);",
                    "    return concat([\" \".repeat(spaces), text]);",
                    "  }",
                    "",
                    "  function alignCenter(text, width) {",
                    "    const spaces = width - privateUtil.getStringWidth(text);",
                    "    const left = Math.floor(spaces / 2);",
                    "    const right = spaces - left;",
                    "    return concat([\" \".repeat(left), text, \" \".repeat(right)]);",
                    "  }",
                    "}",
                    "",
                    "function printRoot(path, options, print) {",
                    "  /** @typedef {{ index: number, offset: number }} IgnorePosition */",
                    "  /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */",
                    "  const ignoreRanges = [];",
                    "",
                    "  /** @type {IgnorePosition | null} */",
                    "  let ignoreStart = null;",
                    "",
                    "  const { children } = path.getValue();",
                    "  children.forEach((childNode, index) => {",
                    "    switch (isPrettierIgnore(childNode)) {",
                    "      case \"start\":",
                    "        if (ignoreStart === null) {",
                    "          ignoreStart = { index, offset: childNode.position.end.offset };",
                    "        }",
                    "        break;",
                    "      case \"end\":",
                    "        if (ignoreStart !== null) {",
                    "          ignoreRanges.push({",
                    "            start: ignoreStart,",
                    "            end: { index, offset: childNode.position.start.offset },",
                    "          });",
                    "          ignoreStart = null;",
                    "        }",
                    "        break;",
                    "      default:",
                    "        // do nothing",
                    "        break;",
                    "    }",
                    "  });",
                    "",
                    "  return printChildren(path, options, print, {",
                    "    processor: (childPath, index) => {",
                    "      if (ignoreRanges.length !== 0) {",
                    "        const ignoreRange = ignoreRanges[0];",
                    "",
                    "        if (index === ignoreRange.start.index) {",
                    "          return concat([",
                    "            children[ignoreRange.start.index].value,",
                    "            options.originalText.slice(",
                    "              ignoreRange.start.offset,",
                    "              ignoreRange.end.offset",
                    "            ),",
                    "            children[ignoreRange.end.index].value,",
                    "          ]);",
                    "        }",
                    "",
                    "        if (ignoreRange.start.index < index && index < ignoreRange.end.index) {",
                    "          return false;",
                    "        }",
                    "",
                    "        if (index === ignoreRange.end.index) {",
                    "          ignoreRanges.shift();",
                    "          return false;",
                    "        }",
                    "      }",
                    "",
                    "      return childPath.call(print);",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function printChildren(path, options, print, events) {",
                    "  events = events || {};",
                    "",
                    "  const postprocessor = events.postprocessor || concat;",
                    "  const processor = events.processor || ((childPath) => childPath.call(print));",
                    "",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  let lastChildNode;",
                    "",
                    "  path.map((childPath, index) => {",
                    "    const childNode = childPath.getValue();",
                    "",
                    "    const result = processor(childPath, index);",
                    "    if (result !== false) {",
                    "      const data = {",
                    "        parts,",
                    "        prevNode: lastChildNode,",
                    "        parentNode: node,",
                    "        options,",
                    "      };",
                    "",
                    "      if (!shouldNotPrePrintHardline(childNode, data)) {",
                    "        parts.push(hardline);",
                    "",
                    "        if (lastChildNode && TRAILING_HARDLINE_NODES.has(lastChildNode.type)) {",
                    "          if (shouldPrePrintTripleHardline(childNode, data)) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        } else {",
                    "          if (",
                    "            shouldPrePrintDoubleHardline(childNode, data) ||",
                    "            shouldPrePrintTripleHardline(childNode, data)",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "",
                    "          if (shouldPrePrintTripleHardline(childNode, data)) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }",
                    "      }",
                    "",
                    "      parts.push(result);",
                    "",
                    "      lastChildNode = childNode;",
                    "    }",
                    "  }, \"children\");",
                    "",
                    "  return postprocessor(parts);",
                    "}",
                    "",
                    "function getLastDescendantNode(node) {",
                    "  let current = node;",
                    "  while (current.children && current.children.length !== 0) {",
                    "    current = current.children[current.children.length - 1];",
                    "  }",
                    "  return current;",
                    "}",
                    "",
                    "/** @return {false | 'next' | 'start' | 'end'} */",
                    "function isPrettierIgnore(node) {",
                    "  if (node.type !== \"html\") {",
                    "    return false;",
                    "  }",
                    "  const match = node.value.match(",
                    "    /^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/",
                    "  );",
                    "  return match === null ? false : match[1] ? match[1] : \"next\";",
                    "}",
                    "",
                    "function shouldNotPrePrintHardline(node, data) {",
                    "  const isFirstNode = data.parts.length === 0;",
                    "  const isInlineNode = INLINE_NODE_TYPES.includes(node.type);",
                    "",
                    "  const isInlineHTML =",
                    "    node.type === \"html\" &&",
                    "    INLINE_NODE_WRAPPER_TYPES.includes(data.parentNode.type);",
                    "",
                    "  return isFirstNode || isInlineNode || isInlineHTML;",
                    "}",
                    "",
                    "function shouldPrePrintDoubleHardline(node, data) {",
                    "  const isSequence = (data.prevNode && data.prevNode.type) === node.type;",
                    "  const isSiblingNode = isSequence && SIBLING_NODE_TYPES.has(node.type);",
                    "",
                    "  const isInTightListItem =",
                    "    data.parentNode.type === \"listItem\" && !data.parentNode.loose;",
                    "",
                    "  const isPrevNodeLooseListItem =",
                    "    data.prevNode && data.prevNode.type === \"listItem\" && data.prevNode.loose;",
                    "",
                    "  const isPrevNodePrettierIgnore = isPrettierIgnore(data.prevNode) === \"next\";",
                    "",
                    "  const isBlockHtmlWithoutBlankLineBetweenPrevHtml =",
                    "    node.type === \"html\" &&",
                    "    data.prevNode &&",
                    "    data.prevNode.type === \"html\" &&",
                    "    data.prevNode.position.end.line + 1 === node.position.start.line;",
                    "",
                    "  const isHtmlDirectAfterListItem =",
                    "    node.type === \"html\" &&",
                    "    data.parentNode.type === \"listItem\" &&",
                    "    data.prevNode &&",
                    "    data.prevNode.type === \"paragraph\" &&",
                    "    data.prevNode.position.end.line + 1 === node.position.start.line;",
                    "",
                    "  return (",
                    "    isPrevNodeLooseListItem ||",
                    "    !(",
                    "      isSiblingNode ||",
                    "      isInTightListItem ||",
                    "      isPrevNodePrettierIgnore ||",
                    "      isBlockHtmlWithoutBlankLineBetweenPrevHtml ||",
                    "      isHtmlDirectAfterListItem",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function shouldPrePrintTripleHardline(node, data) {",
                    "  const isPrevNodeList = data.prevNode && data.prevNode.type === \"list\";",
                    "  const isIndentedCode = node.type === \"code\" && node.isIndented;",
                    "",
                    "  return isPrevNodeList && isIndentedCode;",
                    "}",
                    "",
                    "function shouldRemainTheSameContent(path) {",
                    "  const ancestorNode = getAncestorNode(path, [",
                    "    \"linkReference\",",
                    "    \"imageReference\",",
                    "  ]);",
                    "",
                    "  return (",
                    "    ancestorNode &&",
                    "    (ancestorNode.type !== \"linkReference\" ||",
                    "      ancestorNode.referenceType !== \"full\")",
                    "  );",
                    "}",
                    "",
                    "function printUrl(url, dangerousCharOrChars) {",
                    "  const dangerousChars = [\" \"].concat(dangerousCharOrChars || []);",
                    "  return new RegExp(dangerousChars.map((x) => `\\\\${x}`).join(\"|\")).test(url)",
                    "    ? `<${url}>`",
                    "    : url;",
                    "}",
                    "",
                    "function printTitle(title, options, printSpace) {",
                    "  if (printSpace == null) {",
                    "    printSpace = true;",
                    "  }",
                    "",
                    "  if (!title) {",
                    "    return \"\";",
                    "  }",
                    "  if (printSpace) {",
                    "    return \" \" + printTitle(title, options, false);",
                    "  }",
                    "  if (title.includes('\"') && title.includes(\"'\") && !title.includes(\")\")) {",
                    "    return `(${title})`; // avoid escaped quotes",
                    "  }",
                    "  // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split",
                    "  const singleCount = title.split(\"'\").length - 1;",
                    "  const doubleCount = title.split('\"').length - 1;",
                    "  const quote =",
                    "    singleCount > doubleCount",
                    "      ? '\"'",
                    "      : doubleCount > singleCount",
                    "      ? \"'\"",
                    "      : options.singleQuote",
                    "      ? \"'\"",
                    "      : '\"';",
                    "  title = title.replace(new RegExp(`(${quote})`, \"g\"), \"\\\\$1\");",
                    "  return `${quote}${title}${quote}`;",
                    "}",
                    "",
                    "function clamp(value, min, max) {",
                    "  return value < min ? min : value > max ? max : value;",
                    "}",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  delete newObj.position;",
                    "  delete newObj.raw; // front-matter",
                    "",
                    "  // for codeblock",
                    "  if (",
                    "    isFrontMatterNode(ast) ||",
                    "    ast.type === \"code\" ||",
                    "    ast.type === \"yaml\" ||",
                    "    ast.type === \"import\" ||",
                    "    ast.type === \"export\" ||",
                    "    ast.type === \"jsx\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\") {",
                    "    delete newObj.isAligned;",
                    "  }",
                    "",
                    "  // texts can be splitted or merged",
                    "  if (ast.type === \"text\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"inlineCode\") {",
                    "    newObj.value = ast.value.replace(/[\\t\\n ]+/g, \" \");",
                    "  }",
                    "",
                    "  // for insert pragma",
                    "  if (",
                    "    parent &&",
                    "    parent.type === \"root\" &&",
                    "    parent.children.length > 0 &&",
                    "    (parent.children[0] === ast ||",
                    "      (isFrontMatterNode(parent.children[0]) && parent.children[1] === ast)) &&",
                    "    ast.type === \"html\" &&",
                    "    pragma.startWithPragma(ast.value)",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const index = +path.getName();",
                    "",
                    "  if (index === 0) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const prevNode = path.getParentNode().children[index - 1];",
                    "  return isPrettierIgnore(prevNode) === \"next\";",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  embed,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma: pragma.insertPragma,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  cjkPattern,",
                    "  kPattern,",
                    "  punctuationPattern,",
                    "} = require(\"./constants.evaluate\");",
                    "const { getLast } = require(\"../common/util\");",
                    "",
                    "const INLINE_NODE_TYPES = [",
                    "  \"liquidNode\",",
                    "  \"inlineCode\",",
                    "  \"emphasis\",",
                    "  \"strong\",",
                    "  \"delete\",",
                    "  \"link\",",
                    "  \"linkReference\",",
                    "  \"image\",",
                    "  \"imageReference\",",
                    "  \"footnote\",",
                    "  \"footnoteReference\",",
                    "  \"sentence\",",
                    "  \"whitespace\",",
                    "  \"word\",",
                    "  \"break\",",
                    "  \"inlineMath\",",
                    "];",
                    "",
                    "const INLINE_NODE_WRAPPER_TYPES = INLINE_NODE_TYPES.concat([",
                    "  \"tableCell\",",
                    "  \"paragraph\",",
                    "  \"heading\",",
                    "]);",
                    "",
                    "const kRegex = new RegExp(kPattern);",
                    "const punctuationRegex = new RegExp(punctuationPattern);",
                    "",
                    "/**",
                    " * split text into whitespaces and words",
                    " * @param {string} text",
                    " * @return {Array<{ type: \"whitespace\", value: \" \" | \"\\n\" | \"\" } | { type: \"word\", value: string }>}",
                    " */",
                    "function splitText(text, options) {",
                    "  const KIND_NON_CJK = \"non-cjk\";",
                    "  const KIND_CJ_LETTER = \"cj-letter\";",
                    "  const KIND_K_LETTER = \"k-letter\";",
                    "  const KIND_CJK_PUNCTUATION = \"cjk-punctuation\";",
                    "",
                    "  const nodes = [];",
                    "",
                    "  (options.proseWrap === \"preserve\"",
                    "    ? text",
                    "    : text.replace(new RegExp(`(${cjkPattern})\\n(${cjkPattern})`, \"g\"), \"$1$2\")",
                    "  )",
                    "    .split(/([\\t\\n ]+)/)",
                    "    .forEach((token, index, tokens) => {",
                    "      // whitespace",
                    "      if (index % 2 === 1) {",
                    "        nodes.push({",
                    "          type: \"whitespace\",",
                    "          value: /\\n/.test(token) ? \"\\n\" : \" \",",
                    "        });",
                    "        return;",
                    "      }",
                    "",
                    "      // word separated by whitespace",
                    "",
                    "      if ((index === 0 || index === tokens.length - 1) && token === \"\") {",
                    "        return;",
                    "      }",
                    "",
                    "      token",
                    "        .split(new RegExp(`(${cjkPattern})`))",
                    "        .forEach((innerToken, innerIndex, innerTokens) => {",
                    "          if (",
                    "            (innerIndex === 0 || innerIndex === innerTokens.length - 1) &&",
                    "            innerToken === \"\"",
                    "          ) {",
                    "            return;",
                    "          }",
                    "",
                    "          // non-CJK word",
                    "          if (innerIndex % 2 === 0) {",
                    "            if (innerToken !== \"\") {",
                    "              appendNode({",
                    "                type: \"word\",",
                    "                value: innerToken,",
                    "                kind: KIND_NON_CJK,",
                    "                hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),",
                    "                hasTrailingPunctuation: punctuationRegex.test(",
                    "                  getLast(innerToken)",
                    "                ),",
                    "              });",
                    "            }",
                    "            return;",
                    "          }",
                    "",
                    "          // CJK character",
                    "          appendNode(",
                    "            punctuationRegex.test(innerToken)",
                    "              ? {",
                    "                  type: \"word\",",
                    "                  value: innerToken,",
                    "                  kind: KIND_CJK_PUNCTUATION,",
                    "                  hasLeadingPunctuation: true,",
                    "                  hasTrailingPunctuation: true,",
                    "                }",
                    "              : {",
                    "                  type: \"word\",",
                    "                  value: innerToken,",
                    "                  kind: kRegex.test(innerToken)",
                    "                    ? KIND_K_LETTER",
                    "                    : KIND_CJ_LETTER,",
                    "                  hasLeadingPunctuation: false,",
                    "                  hasTrailingPunctuation: false,",
                    "                }",
                    "          );",
                    "        });",
                    "    });",
                    "",
                    "  return nodes;",
                    "",
                    "  function appendNode(node) {",
                    "    const lastNode = getLast(nodes);",
                    "    if (lastNode && lastNode.type === \"word\") {",
                    "      if (",
                    "        (lastNode.kind === KIND_NON_CJK &&",
                    "          node.kind === KIND_CJ_LETTER &&",
                    "          !lastNode.hasTrailingPunctuation) ||",
                    "        (lastNode.kind === KIND_CJ_LETTER &&",
                    "          node.kind === KIND_NON_CJK &&",
                    "          !node.hasLeadingPunctuation)",
                    "      ) {",
                    "        nodes.push({ type: \"whitespace\", value: \" \" });",
                    "      } else if (",
                    "        !isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) &&",
                    "        // disallow leading/trailing full-width whitespace",
                    "        ![lastNode.value, node.value].some((value) => /\\u3000/.test(value))",
                    "      ) {",
                    "        nodes.push({ type: \"whitespace\", value: \"\" });",
                    "      }",
                    "    }",
                    "    nodes.push(node);",
                    "",
                    "    function isBetween(kind1, kind2) {",
                    "      return (",
                    "        (lastNode.kind === kind1 && node.kind === kind2) ||",
                    "        (lastNode.kind === kind2 && node.kind === kind1)",
                    "      );",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getOrderedListItemInfo(orderListItem, originalText) {",
                    "  const [, numberText, marker, leadingSpaces] = originalText",
                    "    .slice(",
                    "      orderListItem.position.start.offset,",
                    "      orderListItem.position.end.offset",
                    "    )",
                    "    .match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);",
                    "",
                    "  return { numberText, marker, leadingSpaces };",
                    "}",
                    "",
                    "function hasGitDiffFriendlyOrderedList(node, options) {",
                    "  if (!node.ordered) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (node.children.length < 2) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const firstNumber = Number(",
                    "    getOrderedListItemInfo(node.children[0], options.originalText).numberText",
                    "  );",
                    "",
                    "  const secondNumber = Number(",
                    "    getOrderedListItemInfo(node.children[1], options.originalText).numberText",
                    "  );",
                    "",
                    "  if (firstNumber === 0 && node.children.length > 2) {",
                    "    const thirdNumber = Number(",
                    "      getOrderedListItemInfo(node.children[2], options.originalText).numberText",
                    "    );",
                    "",
                    "    return secondNumber === 1 && thirdNumber === 1;",
                    "  }",
                    "",
                    "  return secondNumber === 1;",
                    "}",
                    "",
                    "// workaround for https://github.com/remarkjs/remark/issues/351",
                    "// leading and trailing newlines are stripped by remark",
                    "function getFencedCodeBlockValue(node, originalText) {",
                    "  const text = originalText.slice(",
                    "    node.position.start.offset,",
                    "    node.position.end.offset",
                    "  );",
                    "",
                    "  const leadingSpaceCount = text.match(/^\\s*/)[0].length;",
                    "  const replaceRegex = new RegExp(`^\\\\s{0,${leadingSpaceCount}}`);",
                    "",
                    "  const lineContents = text.split(\"\\n\");",
                    "",
                    "  const markerStyle = text[leadingSpaceCount]; // ` or ~",
                    "  const marker = text",
                    "    .slice(leadingSpaceCount)",
                    "    .match(new RegExp(`^[${markerStyle}]+`))[0];",
                    "",
                    "  // https://spec.commonmark.org/0.28/#example-104: Closing fences may be indented by 0-3 spaces",
                    "  // https://spec.commonmark.org/0.28/#example-93: The closing code fence must be at least as long as the opening fence",
                    "  const hasEndMarker = new RegExp(`^\\\\s{0,3}${marker}`).test(",
                    "    lineContents[lineContents.length - 1].slice(",
                    "      getIndent(lineContents.length - 1)",
                    "    )",
                    "  );",
                    "",
                    "  return lineContents",
                    "    .slice(1, hasEndMarker ? -1 : undefined)",
                    "    .map((x, i) => x.slice(getIndent(i + 1)).replace(replaceRegex, \"\"))",
                    "    .join(\"\\n\");",
                    "",
                    "  function getIndent(lineIndex) {",
                    "    return node.position.indent[lineIndex - 1] - 1;",
                    "  }",
                    "}",
                    "",
                    "function mapAst(ast, handler) {",
                    "  return (function preorder(node, index, parentStack) {",
                    "    parentStack = parentStack || [];",
                    "",
                    "    const newNode = { ...handler(node, index, parentStack) };",
                    "    if (newNode.children) {",
                    "      newNode.children = newNode.children.map((child, index) => {",
                    "        return preorder(child, index, [newNode].concat(parentStack));",
                    "      });",
                    "    }",
                    "",
                    "    return newNode;",
                    "  })(ast, null, null);",
                    "}",
                    "",
                    "module.exports = {",
                    "  mapAst,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  getFencedCodeBlockValue,",
                    "  getOrderedListItemInfo,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "};"
                ]
            }
        },
        "language-yaml": {
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const printer = require(\"./printer-yaml\");",
                    "const options = require(\"./options\");",
                    "const createLanguage = require(\"../utils/create-language\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/YAML\"), (data) => ({",
                    "    since: \"1.14.0\",",
                    "    parsers: [\"yaml\"],",
                    "    vscodeLanguageIds: [\"yaml\", \"ansible\"],",
                    "    // yarn.lock is not YAML: https://github.com/yarnpkg/yarn/issues/5629",
                    "    filenames: data.filenames.filter((filename) => filename !== \"yarn.lock\"),",
                    "  })),",
                    "];",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers: { yaml: printer },",
                    "  options,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  proseWrap: commonOptions.proseWrap,",
                    "};"
                ]
            },
            "parser-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error\");",
                    "const { hasPragma } = require(\"./pragma\");",
                    "",
                    "function parse(text) {",
                    "  try {",
                    "    const root = require(\"yaml-unist-parser\").parse(text);",
                    "",
                    "    /**",
                    "     * suppress `comment not printed` error",
                    "     *",
                    "     * comments are handled in printer-yaml.js without using `printComment`",
                    "     * so that it'll always throw errors even if we printed it correctly",
                    "     */",
                    "    delete root.comments;",
                    "",
                    "    return root;",
                    "  } catch (error) {",
                    "    // istanbul ignore next",
                    "    throw error && error.position",
                    "      ? createError(error.message, error.position)",
                    "      : error;",
                    "  }",
                    "}",
                    "",
                    "const parser = {",
                    "  astFormat: \"yaml\",",
                    "  parse,",
                    "  hasPragma,",
                    "  locStart: (node) => node.position.start.offset,",
                    "  locEnd: (node) => node.position.end.offset,",
                    "};",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    yaml: parser,",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function isPragma(text) {",
                    "  return /^\\s*@(prettier|format)\\s*$/.test(text);",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(prettier|format)\\s*?(\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return `# @format\\n\\n${text}`;",
                    "}",
                    "",
                    "module.exports = {",
                    "  isPragma,",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "printer-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { insertPragma, isPragma } = require(\"./pragma\");",
                    "const {",
                    "  getAncestorCount,",
                    "  getBlockValueLineContents,",
                    "  getFlowScalarLineContents,",
                    "  getLast,",
                    "  getLastDescendantNode,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasIndicatorComment,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "  hasPrettierIgnore,",
                    "  isLastDescendantNode,",
                    "  isNextLineEmpty,",
                    "  isNode,",
                    "  isEmptyNode,",
                    "  defineShortcut,",
                    "  mapNode,",
                    "} = require(\"./utils\");",
                    "const docBuilders = require(\"../document\").builders;",
                    "const {",
                    "  conditionalGroup,",
                    "  breakParent,",
                    "  concat,",
                    "  dedent,",
                    "  dedentToRoot,",
                    "  fill,",
                    "  group,",
                    "  hardline,",
                    "  ifBreak,",
                    "  join,",
                    "  line,",
                    "  lineSuffix,",
                    "  literalline,",
                    "  markAsRoot,",
                    "  softline,",
                    "} = docBuilders;",
                    "const { replaceEndOfLineWith, isPreviousLineEmpty } = require(\"../common/util\");",
                    "",
                    "function preprocess(ast) {",
                    "  return mapNode(ast, defineShortcuts);",
                    "}",
                    "",
                    "function defineShortcuts(node) {",
                    "  switch (node.type) {",
                    "    case \"document\":",
                    "      defineShortcut(node, \"head\", () => node.children[0]);",
                    "      defineShortcut(node, \"body\", () => node.children[1]);",
                    "      break;",
                    "    case \"documentBody\":",
                    "    case \"sequenceItem\":",
                    "    case \"flowSequenceItem\":",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      defineShortcut(node, \"content\", () => node.children[0]);",
                    "      break;",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\":",
                    "      defineShortcut(node, \"key\", () => node.children[0]);",
                    "      defineShortcut(node, \"value\", () => node.children[1]);",
                    "      break;",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "  const parentNode = path.getParentNode();",
                    "",
                    "  const tag = !node.tag ? \"\" : path.call(print, \"tag\");",
                    "  const anchor = !node.anchor ? \"\" : path.call(print, \"anchor\");",
                    "",
                    "  const nextEmptyLine =",
                    "    isNode(node, [",
                    "      \"mapping\",",
                    "      \"sequence\",",
                    "      \"comment\",",
                    "      \"directive\",",
                    "      \"mappingItem\",",
                    "      \"sequenceItem\",",
                    "    ]) && !isLastDescendantNode(path)",
                    "      ? printNextEmptyLine(path, options.originalText)",
                    "      : \"\";",
                    "",
                    "  return concat([",
                    "    node.type !== \"mappingValue\" && hasLeadingComments(node)",
                    "      ? concat([join(hardline, path.map(print, \"leadingComments\")), hardline])",
                    "      : \"\",",
                    "    tag,",
                    "    tag && anchor ? \" \" : \"\",",
                    "    anchor,",
                    "    tag || anchor",
                    "      ? isNode(node, [\"sequence\", \"mapping\"]) && !hasMiddleComments(node)",
                    "        ? hardline",
                    "        : \" \"",
                    "      : \"\",",
                    "    hasMiddleComments(node)",
                    "      ? concat([",
                    "          node.middleComments.length === 1 ? \"\" : hardline,",
                    "          join(hardline, path.map(print, \"middleComments\")),",
                    "          hardline,",
                    "        ])",
                    "      : \"\",",
                    "    hasPrettierIgnore(path)",
                    "      ? concat(",
                    "          replaceEndOfLineWith(",
                    "            options.originalText",
                    "              .slice(node.position.start.offset, node.position.end.offset)",
                    "              .trimEnd(),",
                    "            literalline",
                    "          )",
                    "        )",
                    "      : group(_print(node, parentNode, path, options, print)),",
                    "    hasTrailingComment(node) && !isNode(node, [\"document\", \"documentHead\"])",
                    "      ? lineSuffix(",
                    "          concat([",
                    "            node.type === \"mappingValue\" && !node.content ? \"\" : \" \",",
                    "            parentNode.type === \"mappingKey\" &&",
                    "            path.getParentNode(2).type === \"mapping\" &&",
                    "            isInlineNode(node)",
                    "              ? \"\"",
                    "              : breakParent,",
                    "            path.call(print, \"trailingComment\"),",
                    "          ])",
                    "        )",
                    "      : \"\",",
                    "    nextEmptyLine,",
                    "    hasEndComments(node) && !isNode(node, [\"documentHead\", \"documentBody\"])",
                    "      ? align(",
                    "          node.type === \"sequenceItem\" ? 2 : 0,",
                    "          concat([",
                    "            hardline,",
                    "            join(",
                    "              hardline,",
                    "              path.map(",
                    "                (path) =>",
                    "                  concat([",
                    "                    isPreviousLineEmpty(",
                    "                      options.originalText,",
                    "                      path.getValue(),",
                    "                      options.locStart",
                    "                    )",
                    "                      ? hardline",
                    "                      : \"\",",
                    "                    print(path),",
                    "                  ]),",
                    "                \"endComments\"",
                    "              )",
                    "            ),",
                    "          ])",
                    "        )",
                    "      : \"\",",
                    "  ]);",
                    "}",
                    "",
                    "function _print(node, parentNode, path, options, print) {",
                    "  switch (node.type) {",
                    "    case \"root\":",
                    "      return concat([",
                    "        join(",
                    "          hardline,",
                    "          path.map((childPath, index) => {",
                    "            const document = node.children[index];",
                    "            const nextDocument = node.children[index + 1];",
                    "            return concat([",
                    "              print(childPath),",
                    "              shouldPrintDocumentEndMarker(document, nextDocument)",
                    "                ? concat([",
                    "                    hardline,",
                    "                    \"...\",",
                    "                    hasTrailingComment(document)",
                    "                      ? concat([\" \", path.call(print, \"trailingComment\")])",
                    "                      : \"\",",
                    "                  ])",
                    "                : !nextDocument || hasTrailingComment(nextDocument.head)",
                    "                ? \"\"",
                    "                : concat([hardline, \"---\"]),",
                    "            ]);",
                    "          }, \"children\")",
                    "        ),",
                    "        node.children.length === 0 ||",
                    "        ((lastDescendantNode) =>",
                    "          isNode(lastDescendantNode, [\"blockLiteral\", \"blockFolded\"]) &&",
                    "          lastDescendantNode.chomping === \"keep\")(getLastDescendantNode(node))",
                    "          ? \"\"",
                    "          : hardline,",
                    "      ]);",
                    "    case \"document\": {",
                    "      const nextDocument = parentNode.children[path.getName() + 1];",
                    "      return join(",
                    "        hardline,",
                    "        [",
                    "          shouldPrintDocumentHeadEndMarker(",
                    "            node,",
                    "            nextDocument,",
                    "            parentNode,",
                    "            options",
                    "          ) === \"head\"",
                    "            ? join(",
                    "                hardline,",
                    "                [",
                    "                  node.head.children.length === 0 &&",
                    "                  node.head.endComments.length === 0",
                    "                    ? \"\"",
                    "                    : path.call(print, \"head\"),",
                    "                  concat([",
                    "                    \"---\",",
                    "                    hasTrailingComment(node.head)",
                    "                      ? concat([",
                    "                          \" \",",
                    "                          path.call(print, \"head\", \"trailingComment\"),",
                    "                        ])",
                    "                      : \"\",",
                    "                  ]),",
                    "                ].filter(Boolean)",
                    "              )",
                    "            : \"\",",
                    "          shouldPrintDocumentBody(node) ? path.call(print, \"body\") : \"\",",
                    "        ].filter(Boolean)",
                    "      );",
                    "    }",
                    "    case \"documentHead\":",
                    "      return join(",
                    "        hardline,",
                    "        [].concat(path.map(print, \"children\"), path.map(print, \"endComments\"))",
                    "      );",
                    "    case \"documentBody\": {",
                    "      const children = join(hardline, path.map(print, \"children\")).parts;",
                    "      const endComments = join(hardline, path.map(print, \"endComments\")).parts;",
                    "      const separator =",
                    "        children.length === 0 || endComments.length === 0",
                    "          ? \"\"",
                    "          : ((lastDescendantNode) =>",
                    "              isNode(lastDescendantNode, [\"blockFolded\", \"blockLiteral\"])",
                    "                ? lastDescendantNode.chomping === \"keep\"",
                    "                  ? // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)",
                    "                    \"\"",
                    "                  : // an extra newline for better readability",
                    "                    concat([hardline, hardline])",
                    "                : hardline)(getLastDescendantNode(node));",
                    "      return concat([].concat(children, separator, endComments));",
                    "    }",
                    "    case \"directive\":",
                    "      return concat([\"%\", join(\" \", [node.name].concat(node.parameters))]);",
                    "    case \"comment\":",
                    "      return concat([\"#\", node.value]);",
                    "    case \"alias\":",
                    "      return concat([\"*\", node.value]);",
                    "    case \"tag\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"anchor\":",
                    "      return concat([\"&\", node.value]);",
                    "    case \"plain\":",
                    "      return printFlowScalarContent(",
                    "        node.type,",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        ),",
                    "        options",
                    "      );",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\": {",
                    "      const singleQuote = \"'\";",
                    "      const doubleQuote = '\"';",
                    "",
                    "      const raw = options.originalText.slice(",
                    "        node.position.start.offset + 1,",
                    "        node.position.end.offset - 1",
                    "      );",
                    "",
                    "      if (",
                    "        (node.type === \"quoteSingle\" && raw.includes(\"\\\\\")) ||",
                    "        (node.type === \"quoteDouble\" && /\\\\[^\"]/.test(raw))",
                    "      ) {",
                    "        // only quoteDouble can use escape chars",
                    "        // and quoteSingle do not need to escape backslashes",
                    "        const originalQuote =",
                    "          node.type === \"quoteDouble\" ? doubleQuote : singleQuote;",
                    "        return concat([",
                    "          originalQuote,",
                    "          printFlowScalarContent(node.type, raw, options),",
                    "          originalQuote,",
                    "        ]);",
                    "      } else if (raw.includes(doubleQuote)) {",
                    "        return concat([",
                    "          singleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteDouble\"",
                    "              ? raw",
                    "                  // double quote needs to be escaped by backslash in quoteDouble",
                    "                  .replace(/\\\\\"/g, doubleQuote)",
                    "                  .replace(/'/g, singleQuote.repeat(2))",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          singleQuote,",
                    "        ]);",
                    "      }",
                    "",
                    "      if (raw.includes(singleQuote)) {",
                    "        return concat([",
                    "          doubleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteSingle\"",
                    "              ? // single quote needs to be escaped by 2 single quotes in quoteSingle",
                    "                raw.replace(/''/g, singleQuote)",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          doubleQuote,",
                    "        ]);",
                    "      }",
                    "",
                    "      const quote = options.singleQuote ? singleQuote : doubleQuote;",
                    "      return concat([",
                    "        quote,",
                    "        printFlowScalarContent(node.type, raw, options),",
                    "        quote,",
                    "      ]);",
                    "    }",
                    "    case \"blockFolded\":",
                    "    case \"blockLiteral\": {",
                    "      const parentIndent = getAncestorCount(path, (ancestorNode) =>",
                    "        isNode(ancestorNode, [\"sequence\", \"mapping\"])",
                    "      );",
                    "      const isLastDescendant = isLastDescendantNode(path);",
                    "      return concat([",
                    "        node.type === \"blockFolded\" ? \">\" : \"|\",",
                    "        node.indent === null ? \"\" : node.indent.toString(),",
                    "        node.chomping === \"clip\" ? \"\" : node.chomping === \"keep\" ? \"+\" : \"-\",",
                    "        hasIndicatorComment(node)",
                    "          ? concat([\" \", path.call(print, \"indicatorComment\")])",
                    "          : \"\",",
                    "        (node.indent === null ? dedent : dedentToRoot)(",
                    "          align(",
                    "            node.indent === null",
                    "              ? options.tabWidth",
                    "              : node.indent - 1 + parentIndent,",
                    "            concat(",
                    "              getBlockValueLineContents(node, {",
                    "                parentIndent,",
                    "                isLastDescendant,",
                    "                options,",
                    "              }).reduce(",
                    "                (reduced, lineWords, index, lineContents) =>",
                    "                  reduced.concat(",
                    "                    index === 0 ? hardline : \"\",",
                    "                    fill(join(line, lineWords).parts),",
                    "                    index !== lineContents.length - 1",
                    "                      ? lineWords.length === 0",
                    "                        ? hardline",
                    "                        : markAsRoot(literalline)",
                    "                      : node.chomping === \"keep\" && isLastDescendant",
                    "                      ? lineWords.length === 0",
                    "                        ? dedentToRoot(hardline)",
                    "                        : dedentToRoot(literalline)",
                    "                      : \"\"",
                    "                  ),",
                    "                []",
                    "              )",
                    "            )",
                    "          )",
                    "        ),",
                    "      ]);",
                    "    }",
                    "    case \"sequence\":",
                    "      return join(hardline, path.map(print, \"children\"));",
                    "    case \"sequenceItem\":",
                    "      return concat([",
                    "        \"- \",",
                    "        align(2, !node.content ? \"\" : path.call(print, \"content\")),",
                    "      ]);",
                    "    case \"mappingKey\":",
                    "      return !node.content ? \"\" : path.call(print, \"content\");",
                    "    case \"mappingValue\":",
                    "      return !node.content ? \"\" : path.call(print, \"content\");",
                    "    case \"mapping\":",
                    "      return join(hardline, path.map(print, \"children\"));",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\": {",
                    "      const isEmptyMappingKey = isEmptyNode(node.key);",
                    "      const isEmptyMappingValue = isEmptyNode(node.value);",
                    "",
                    "      if (isEmptyMappingKey && isEmptyMappingValue) {",
                    "        return concat([\": \"]);",
                    "      }",
                    "",
                    "      const key = path.call(print, \"key\");",
                    "      const value = path.call(print, \"value\");",
                    "",
                    "      if (isEmptyMappingValue) {",
                    "        return node.type === \"flowMappingItem\" &&",
                    "          parentNode.type === \"flowMapping\"",
                    "          ? key",
                    "          : node.type === \"mappingItem\" &&",
                    "            isAbsolutelyPrintedAsSingleLineNode(node.key.content, options) &&",
                    "            !hasTrailingComment(node.key.content) &&",
                    "            (!parentNode.tag ||",
                    "              parentNode.tag.value !== \"tag:yaml.org,2002:set\")",
                    "          ? concat([key, needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\", \":\"])",
                    "          : concat([\"? \", align(2, key)]);",
                    "      }",
                    "",
                    "      if (isEmptyMappingKey) {",
                    "        return concat([\": \", align(2, value)]);",
                    "      }",
                    "",
                    "      const groupId = Symbol(\"mappingKey\");",
                    "",
                    "      const forceExplicitKey =",
                    "        hasLeadingComments(node.value) || !isInlineNode(node.key.content);",
                    "",
                    "      return forceExplicitKey",
                    "        ? concat([",
                    "            \"? \",",
                    "            align(2, key),",
                    "            hardline,",
                    "            join(",
                    "              \"\",",
                    "              path",
                    "                .map(print, \"value\", \"leadingComments\")",
                    "                .map((comment) => concat([comment, hardline]))",
                    "            ),",
                    "            \": \",",
                    "            align(2, value),",
                    "          ])",
                    "        : // force singleline",
                    "        isSingleLineNode(node.key.content) &&",
                    "          !hasLeadingComments(node.key.content) &&",
                    "          !hasMiddleComments(node.key.content) &&",
                    "          !hasTrailingComment(node.key.content) &&",
                    "          !hasEndComments(node.key) &&",
                    "          !hasLeadingComments(node.value.content) &&",
                    "          !hasMiddleComments(node.value.content) &&",
                    "          !hasEndComments(node.value) &&",
                    "          isAbsolutelyPrintedAsSingleLineNode(node.value.content, options)",
                    "        ? concat([",
                    "            key,",
                    "            needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\",",
                    "            \": \",",
                    "            value,",
                    "          ])",
                    "        : conditionalGroup([",
                    "            concat([",
                    "              group(",
                    "                concat([ifBreak(\"? \"), group(align(2, key), { id: groupId })])",
                    "              ),",
                    "              ifBreak(",
                    "                concat([hardline, \": \", align(2, value)]),",
                    "                indent(",
                    "                  concat([",
                    "                    needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\",",
                    "                    \":\",",
                    "                    hasLeadingComments(node.value.content) ||",
                    "                    (hasEndComments(node.value) &&",
                    "                      node.value.content &&",
                    "                      !isNode(node.value.content, [\"mapping\", \"sequence\"])) ||",
                    "                    (parentNode.type === \"mapping\" &&",
                    "                      hasTrailingComment(node.key.content) &&",
                    "                      isInlineNode(node.value.content)) ||",
                    "                    (isNode(node.value.content, [\"mapping\", \"sequence\"]) &&",
                    "                      node.value.content.tag === null &&",
                    "                      node.value.content.anchor === null)",
                    "                      ? hardline",
                    "                      : !node.value.content",
                    "                      ? \"\"",
                    "                      : line,",
                    "                    value,",
                    "                  ])",
                    "                ),",
                    "                { groupId }",
                    "              ),",
                    "            ]),",
                    "          ]);",
                    "    }",
                    "    case \"flowMapping\":",
                    "    case \"flowSequence\": {",
                    "      const openMarker = node.type === \"flowMapping\" ? \"{\" : \"[\";",
                    "      const closeMarker = node.type === \"flowMapping\" ? \"}\" : \"]\";",
                    "      const bracketSpacing =",
                    "        node.type === \"flowMapping\" &&",
                    "        node.children.length !== 0 &&",
                    "        options.bracketSpacing",
                    "          ? line",
                    "          : softline;",
                    "      const isLastItemEmptyMappingItem =",
                    "        node.children.length !== 0 &&",
                    "        ((lastItem) =>",
                    "          lastItem.type === \"flowMappingItem\" &&",
                    "          isEmptyNode(lastItem.key) &&",
                    "          isEmptyNode(lastItem.value))(getLast(node.children));",
                    "      return concat([",
                    "        openMarker,",
                    "        indent(",
                    "          concat([",
                    "            bracketSpacing,",
                    "            concat(",
                    "              path.map(",
                    "                (childPath, index) =>",
                    "                  concat([",
                    "                    print(childPath),",
                    "                    index === node.children.length - 1",
                    "                      ? \"\"",
                    "                      : concat([",
                    "                          \",\",",
                    "                          line,",
                    "                          node.children[index].position.start.line !==",
                    "                          node.children[index + 1].position.start.line",
                    "                            ? printNextEmptyLine(",
                    "                                childPath,",
                    "                                options.originalText",
                    "                              )",
                    "                            : \"\",",
                    "                        ]),",
                    "                  ]),",
                    "                \"children\"",
                    "              )",
                    "            ),",
                    "            ifBreak(\",\", \"\"),",
                    "          ])",
                    "        ),",
                    "        isLastItemEmptyMappingItem ? \"\" : bracketSpacing,",
                    "        closeMarker,",
                    "      ]);",
                    "    }",
                    "    case \"flowSequenceItem\":",
                    "      return path.call(print, \"content\");",
                    "    // istanbul ignore next",
                    "    default:",
                    "      throw new Error(`Unexpected node type ${node.type}`);",
                    "  }",
                    "",
                    "  function indent(doc) {",
                    "    return docBuilders.align(\" \".repeat(options.tabWidth), doc);",
                    "  }",
                    "}",
                    "",
                    "function align(n, doc) {",
                    "  return typeof n === \"number\" && n > 0",
                    "    ? docBuilders.align(\" \".repeat(n), doc)",
                    "    : docBuilders.align(n, doc);",
                    "}",
                    "",
                    "function isInlineNode(node) {",
                    "  if (!node) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"plain\":",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\":",
                    "    case \"alias\":",
                    "    case \"flowMapping\":",
                    "    case \"flowSequence\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function isSingleLineNode(node) {",
                    "  if (!node) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"plain\":",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\":",
                    "      return node.position.start.line === node.position.end.line;",
                    "    case \"alias\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function shouldPrintDocumentBody(document) {",
                    "  return document.body.children.length !== 0 || hasEndComments(document.body);",
                    "}",
                    "",
                    "function shouldPrintDocumentEndMarker(document, nextDocument) {",
                    "  return (",
                    "    /**",
                    "     *... # trailingComment",
                    "     */",
                    "    hasTrailingComment(document) ||",
                    "    (nextDocument &&",
                    "      /**",
                    "       * ...",
                    "       * %DIRECTIVE",
                    "       * ---",
                    "       */",
                    "      (nextDocument.head.children.length !== 0 ||",
                    "        /**",
                    "         * ...",
                    "         * # endComment",
                    "         * ---",
                    "         */",
                    "        hasEndComments(nextDocument.head)))",
                    "  );",
                    "}",
                    "",
                    "function shouldPrintDocumentHeadEndMarker(",
                    "  document,",
                    "  nextDocument,",
                    "  root,",
                    "  options",
                    ") {",
                    "  if (",
                    "    /**",
                    "     * ---",
                    "     * preserve the first document head end marker",
                    "     */",
                    "    (root.children[0] === document &&",
                    "      /---(\\s|$)/.test(",
                    "        options.originalText.slice(",
                    "          options.locStart(document),",
                    "          options.locStart(document) + 4",
                    "        )",
                    "      )) ||",
                    "    /**",
                    "     * %DIRECTIVE",
                    "     * ---",
                    "     */",
                    "    document.head.children.length !== 0 ||",
                    "    /**",
                    "     * # end comment",
                    "     * ---",
                    "     */",
                    "    hasEndComments(document.head) ||",
                    "    /**",
                    "     * --- # trailing comment",
                    "     */",
                    "    hasTrailingComment(document.head)",
                    "  ) {",
                    "    return \"head\";",
                    "  }",
                    "",
                    "  if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return nextDocument ? \"root\" : false;",
                    "}",
                    "",
                    "function isAbsolutelyPrintedAsSingleLineNode(node, options) {",
                    "  if (!node) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"plain\":",
                    "    case \"quoteSingle\":",
                    "    case \"quoteDouble\":",
                    "      break;",
                    "    case \"alias\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "",
                    "  if (options.proseWrap === \"preserve\") {",
                    "    return node.position.start.line === node.position.end.line;",
                    "  }",
                    "",
                    "  if (",
                    "    // backslash-newline",
                    "    /\\\\$/m.test(",
                    "      options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      )",
                    "    )",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  switch (options.proseWrap) {",
                    "    case \"never\":",
                    "      return !node.value.includes(\"\\n\");",
                    "    case \"always\":",
                    "      return !/[\\n ]/.test(node.value);",
                    "    // istanbul ignore next",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function needsSpaceInFrontOfMappingValue(node) {",
                    "  return node.key.content && node.key.content.type === \"alias\";",
                    "}",
                    "",
                    "function printNextEmptyLine(path, originalText) {",
                    "  const node = path.getValue();",
                    "  const root = path.stack[0];",
                    "",
                    "  root.isNextEmptyLinePrintedChecklist =",
                    "    root.isNextEmptyLinePrintedChecklist || [];",
                    "",
                    "  if (!root.isNextEmptyLinePrintedChecklist[node.position.end.line]) {",
                    "    if (isNextLineEmpty(node, originalText)) {",
                    "      root.isNextEmptyLinePrintedChecklist[node.position.end.line] = true;",
                    "      return softline;",
                    "    }",
                    "  }",
                    "",
                    "  return \"\";",
                    "}",
                    "",
                    "function printFlowScalarContent(nodeType, content, options) {",
                    "  const lineContents = getFlowScalarLineContents(nodeType, content, options);",
                    "  return join(",
                    "    hardline,",
                    "    lineContents.map((lineContentWords) =>",
                    "      fill(join(line, lineContentWords).parts)",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function clean(node, newNode /*, parent */) {",
                    "  if (isNode(newNode)) {",
                    "    delete newNode.position;",
                    "    switch (newNode.type) {",
                    "      case \"comment\":",
                    "        // insert pragma",
                    "        if (isPragma(newNode.value)) {",
                    "          return null;",
                    "        }",
                    "        break;",
                    "      case \"quoteDouble\":",
                    "      case \"quoteSingle\":",
                    "        newNode.type = \"quote\";",
                    "        break;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { getLast } = require(\"../common/util\");",
                    "",
                    "function getAncestorCount(path, filter) {",
                    "  let counter = 0;",
                    "  const pathStackLength = path.stack.length - 1;",
                    "  for (let i = 0; i < pathStackLength; i++) {",
                    "    const value = path.stack[i];",
                    "    if (isNode(value) && filter(value)) {",
                    "      counter++;",
                    "    }",
                    "  }",
                    "  return counter;",
                    "}",
                    "",
                    "/**",
                    " * @param {any} value",
                    " * @param {string[]=} types",
                    " */",
                    "function isNode(value, types) {",
                    "  return (",
                    "    value &&",
                    "    typeof value.type === \"string\" &&",
                    "    (!types || types.includes(value.type))",
                    "  );",
                    "}",
                    "",
                    "function mapNode(node, callback, parent) {",
                    "  return callback(",
                    "    \"children\" in node",
                    "      ? {",
                    "          ...node,",
                    "          children: node.children.map((childNode) =>",
                    "            mapNode(childNode, callback, node)",
                    "          ),",
                    "        }",
                    "      : node,",
                    "    parent",
                    "  );",
                    "}",
                    "",
                    "function defineShortcut(x, key, getter) {",
                    "  Object.defineProperty(x, key, {",
                    "    get: getter,",
                    "    enumerable: false,",
                    "  });",
                    "}",
                    "",
                    "function isNextLineEmpty(node, text) {",
                    "  let newlineCount = 0;",
                    "  const textLength = text.length;",
                    "  for (let i = node.position.end.offset - 1; i < textLength; i++) {",
                    "    const char = text[i];",
                    "",
                    "    if (char === \"\\n\") {",
                    "      newlineCount++;",
                    "    }",
                    "",
                    "    if (newlineCount === 1 && /\\S/.test(char)) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (newlineCount === 2) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isLastDescendantNode(path) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"tag\":",
                    "    case \"anchor\":",
                    "    case \"comment\":",
                    "      return false;",
                    "  }",
                    "",
                    "  const pathStackLength = path.stack.length;",
                    "",
                    "  for (let i = 1; i < pathStackLength; i++) {",
                    "    const item = path.stack[i];",
                    "    const parentItem = path.stack[i - 1];",
                    "",
                    "    if (",
                    "      Array.isArray(parentItem) &&",
                    "      typeof item === \"number\" &&",
                    "      item !== parentItem.length - 1",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function getLastDescendantNode(node) {",
                    "  return \"children\" in node && node.children.length !== 0",
                    "    ? getLastDescendantNode(getLast(node.children))",
                    "    : node;",
                    "}",
                    "",
                    "function isPrettierIgnore(comment) {",
                    "  return comment.value.trim() === \"prettier-ignore\";",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"documentBody\") {",
                    "    const document = path.getParentNode();",
                    "    return (",
                    "      hasEndComments(document.head) &&",
                    "      isPrettierIgnore(getLast(document.head.endComments))",
                    "    );",
                    "  }",
                    "",
                    "  return (",
                    "    hasLeadingComments(node) && isPrettierIgnore(getLast(node.leadingComments))",
                    "  );",
                    "}",
                    "",
                    "function isEmptyNode(node) {",
                    "  return (!node.children || node.children.length === 0) && !hasComments(node);",
                    "}",
                    "",
                    "function hasComments(node) {",
                    "  return (",
                    "    hasLeadingComments(node) ||",
                    "    hasMiddleComments(node) ||",
                    "    hasIndicatorComment(node) ||",
                    "    hasTrailingComment(node) ||",
                    "    hasEndComments(node)",
                    "  );",
                    "}",
                    "",
                    "function hasLeadingComments(node) {",
                    "  return node && node.leadingComments && node.leadingComments.length !== 0;",
                    "}",
                    "",
                    "function hasMiddleComments(node) {",
                    "  return node && node.middleComments && node.middleComments.length !== 0;",
                    "}",
                    "",
                    "function hasIndicatorComment(node) {",
                    "  return node && node.indicatorComment;",
                    "}",
                    "",
                    "function hasTrailingComment(node) {",
                    "  return node && node.trailingComment;",
                    "}",
                    "",
                    "function hasEndComments(node) {",
                    "  return node && node.endComments && node.endComments.length !== 0;",
                    "}",
                    "",
                    "/**",
                    " * \" a   b c   d e   f \" -> [\" a   b\", \"c   d\", \"e   f \"]",
                    " */",
                    "function splitWithSingleSpace(text) {",
                    "  const parts = [];",
                    "",
                    "  let lastPart;",
                    "  for (const part of text.split(/( +)/g)) {",
                    "    if (part !== \" \") {",
                    "      if (lastPart === \" \") {",
                    "        parts.push(part);",
                    "      } else {",
                    "        parts.push((parts.pop() || \"\") + part);",
                    "      }",
                    "    } else if (lastPart === undefined) {",
                    "      parts.unshift(\"\");",
                    "    }",
                    "",
                    "    lastPart = part;",
                    "  }",
                    "",
                    "  if (lastPart === \" \") {",
                    "    parts.push((parts.pop() || \"\") + \" \");",
                    "  }",
                    "",
                    "  if (parts[0] === \"\") {",
                    "    parts.shift();",
                    "    parts.unshift(\" \" + (parts.shift() || \"\"));",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function getFlowScalarLineContents(nodeType, content, options) {",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent, index, lineContents) =>",
                    "      index === 0 && index === lineContents.length - 1",
                    "        ? lineContent",
                    "        : index !== 0 && index !== lineContents.length - 1",
                    "        ? lineContent.trim()",
                    "        : index === 0",
                    "        ? lineContent.trimEnd()",
                    "        : lineContent.trimStart()",
                    "    );",
                    "",
                    "  if (options.proseWrap === \"preserve\") {",
                    "    return rawLineContents.map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : [lineContent]",
                    "    );",
                    "  }",
                    "",
                    "  return rawLineContents",
                    "    .map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "    )",
                    "    .reduce(",
                    "      (reduced, lineContentWords, index) =>",
                    "        index !== 0 &&",
                    "        rawLineContents[index - 1].length !== 0 &&",
                    "        lineContentWords.length !== 0 &&",
                    "        !(",
                    "          // trailing backslash in quoteDouble should be preserved",
                    "          (",
                    "            nodeType === \"quoteDouble\" &&",
                    "            getLast(getLast(reduced)).endsWith(\"\\\\\")",
                    "          )",
                    "        )",
                    "          ? reduced.concat([reduced.pop().concat(lineContentWords)])",
                    "          : reduced.concat([lineContentWords]),",
                    "      []",
                    "    )",
                    "    .map((lineContentWords) =>",
                    "      options.proseWrap === \"never\"",
                    "        ? [lineContentWords.join(\" \")]",
                    "        : lineContentWords",
                    "    );",
                    "}",
                    "",
                    "function getBlockValueLineContents(",
                    "  node,",
                    "  { parentIndent, isLastDescendant, options }",
                    ") {",
                    "  const content =",
                    "    node.position.start.line === node.position.end.line",
                    "      ? \"\"",
                    "      : options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          // exclude open line `>` or `|`",
                    "          .match(/^[^\\n]*?\\n([\\S\\s]*)$/)[1];",
                    "",
                    "  const leadingSpaceCount =",
                    "    node.indent === null",
                    "      ? ((match) => (match ? match[1].length : Infinity))(",
                    "          content.match(/^( *)\\S/m)",
                    "        )",
                    "      : node.indent - 1 + parentIndent;",
                    "",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent) => lineContent.slice(leadingSpaceCount));",
                    "",
                    "  if (options.proseWrap === \"preserve\" || node.type === \"blockLiteral\") {",
                    "    return removeUnnecessaryTrailingNewlines(",
                    "      rawLineContents.map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : [lineContent]",
                    "      )",
                    "    );",
                    "  }",
                    "",
                    "  return removeUnnecessaryTrailingNewlines(",
                    "    rawLineContents",
                    "      .map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "      )",
                    "      .reduce(",
                    "        (reduced, lineContentWords, index) =>",
                    "          index !== 0 &&",
                    "          rawLineContents[index - 1].length !== 0 &&",
                    "          lineContentWords.length !== 0 &&",
                    "          !/^\\s/.test(lineContentWords[0]) &&",
                    "          !/^\\s|\\s$/.test(getLast(reduced))",
                    "            ? reduced.concat([reduced.pop().concat(lineContentWords)])",
                    "            : reduced.concat([lineContentWords]),",
                    "        []",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        lineContentWords.reduce(",
                    "          (reduced, word) =>",
                    "            // disallow trailing spaces",
                    "            reduced.length !== 0 && /\\s$/.test(getLast(reduced))",
                    "              ? reduced.concat(reduced.pop() + \" \" + word)",
                    "              : reduced.concat(word),",
                    "          []",
                    "        )",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        options.proseWrap === \"never\"",
                    "          ? [lineContentWords.join(\" \")]",
                    "          : lineContentWords",
                    "      )",
                    "  );",
                    "",
                    "  function removeUnnecessaryTrailingNewlines(lineContents) {",
                    "    if (node.chomping === \"keep\") {",
                    "      return getLast(lineContents).length === 0",
                    "        ? lineContents.slice(0, -1)",
                    "        : lineContents;",
                    "    }",
                    "",
                    "    let trailingNewlineCount = 0;",
                    "    for (let i = lineContents.length - 1; i >= 0; i--) {",
                    "      if (lineContents[i].length === 0) {",
                    "        trailingNewlineCount++;",
                    "      } else {",
                    "        break;",
                    "      }",
                    "    }",
                    "",
                    "    return trailingNewlineCount === 0",
                    "      ? lineContents",
                    "      : trailingNewlineCount >= 2 && !isLastDescendant",
                    "      ? // next empty line",
                    "        lineContents.slice(0, -(trailingNewlineCount - 1))",
                    "      : lineContents.slice(0, -trailingNewlineCount);",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  getLast,",
                    "  getAncestorCount,",
                    "  isNode,",
                    "  isEmptyNode,",
                    "  mapNode,",
                    "  defineShortcut,",
                    "  isNextLineEmpty,",
                    "  isLastDescendantNode,",
                    "  getBlockValueLineContents,",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasPrettierIgnore,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasIndicatorComment,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "};"
                ]
            }
        },
        "main": {
            "ast-to-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "const comments = require(\"./comments\");",
                    "const FastPath = require(\"../common/fast-path\");",
                    "const multiparser = require(\"./multiparser\");",
                    "",
                    "const doc = require(\"../document\");",
                    "const docBuilders = doc.builders;",
                    "const { concat, hardline, addAlignmentToDoc } = docBuilders;",
                    "const docUtils = doc.utils;",
                    "",
                    "/**",
                    " * Takes an abstract syntax tree (AST) and recursively converts it to a",
                    " * document (series of printing primitives).",
                    " *",
                    " * This is done by descending down the AST recursively. The recursion",
                    " * involves two functions that call each other:",
                    " *",
                    " * 1. printGenerically(), which is defined as an inner function here.",
                    " *    It basically takes care of node caching.",
                    " * 2. callPluginPrintFunction(), which checks for some options, and",
                    " *    ultimately calls the print() function provided by the plugin.",
                    " *",
                    " * The plugin function will call printGenerically() again for child nodes",
                    " * of the current node, which will do its housekeeping, then call the",
                    " * plugin function again, and so on.",
                    " *",
                    " * All the while, these functions pass a \"path\" variable around, which",
                    " * is a stack-like data structure (FastPath) that maintains the current",
                    " * state of the recursion. It is called \"path\", because it represents",
                    " * the path to the current node through the Abstract Syntax Tree.",
                    " */",
                    "function printAstToDoc(ast, options, alignmentSize = 0) {",
                    "  const { printer } = options;",
                    "",
                    "  if (printer.preprocess) {",
                    "    ast = printer.preprocess(ast, options);",
                    "  }",
                    "",
                    "  const cache = new Map();",
                    "",
                    "  function printGenerically(path, args) {",
                    "    const node = path.getValue();",
                    "",
                    "    const shouldCache = node && typeof node === \"object\" && args === undefined;",
                    "    if (shouldCache && cache.has(node)) {",
                    "      return cache.get(node);",
                    "    }",
                    "",
                    "    // We let JSXElement print its comments itself because it adds () around",
                    "    // UnionTypeAnnotation has to align the child without the comments",
                    "    let res;",
                    "    if (",
                    "      printer.willPrintOwnComments &&",
                    "      printer.willPrintOwnComments(path, options)",
                    "    ) {",
                    "      res = callPluginPrintFunction(path, options, printGenerically, args);",
                    "    } else {",
                    "      // printComments will call the plugin print function and check for",
                    "      // comments to print",
                    "      res = comments.printComments(",
                    "        path,",
                    "        (p) => callPluginPrintFunction(p, options, printGenerically, args),",
                    "        options,",
                    "        args && args.needsSemi",
                    "      );",
                    "    }",
                    "",
                    "    if (shouldCache) {",
                    "      cache.set(node, res);",
                    "    }",
                    "",
                    "    return res;",
                    "  }",
                    "",
                    "  let doc = printGenerically(new FastPath(ast));",
                    "  if (alignmentSize > 0) {",
                    "    // Add a hardline to make the indents take effect",
                    "    // It should be removed in index.js format()",
                    "    doc = addAlignmentToDoc(",
                    "      concat([hardline, doc]),",
                    "      alignmentSize,",
                    "      options.tabWidth",
                    "    );",
                    "  }",
                    "  docUtils.propagateBreaks(doc);",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function callPluginPrintFunction(path, options, printPath, args) {",
                    "  assert.ok(path instanceof FastPath);",
                    "",
                    "  const node = path.getValue();",
                    "  const { printer } = options;",
                    "",
                    "  // Escape hatch",
                    "  if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {",
                    "    return options.originalText.slice(",
                    "      options.locStart(node),",
                    "      options.locEnd(node)",
                    "    );",
                    "  }",
                    "",
                    "  if (node) {",
                    "    try {",
                    "      // Potentially switch to a different parser",
                    "      const sub = multiparser.printSubtree(",
                    "        path,",
                    "        printPath,",
                    "        options,",
                    "        printAstToDoc",
                    "      );",
                    "      if (sub) {",
                    "        return sub;",
                    "      }",
                    "    } catch (error) {",
                    "      /* istanbul ignore if */",
                    "      if (process.env.PRETTIER_DEBUG) {",
                    "        throw error;",
                    "      }",
                    "      // Continue with current parser",
                    "    }",
                    "  }",
                    "",
                    "  return printer.print(path, options, printPath, args);",
                    "}",
                    "",
                    "module.exports = printAstToDoc;"
                ]
            },
            "comments.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "const {",
                    "  concat,",
                    "  line,",
                    "  hardline,",
                    "  breakParent,",
                    "  indent,",
                    "  lineSuffix,",
                    "  join,",
                    "  cursor,",
                    "} = require(\"../document\").builders;",
                    "const {",
                    "  hasNewline,",
                    "  skipNewline,",
                    "  skipSpaces,",
                    "  isPreviousLineEmpty,",
                    "} = require(\"../common/util\");",
                    "const {",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "} = require(\"../common/util-shared\");",
                    "const childNodesCacheKey = Symbol(\"child-nodes\");",
                    "",
                    "function getSortedChildNodes(node, options, resultArray) {",
                    "  if (!node) {",
                    "    return;",
                    "  }",
                    "  const { printer, locStart, locEnd } = options;",
                    "",
                    "  if (resultArray) {",
                    "    if (printer.canAttachComment && printer.canAttachComment(node)) {",
                    "      // This reverse insertion sort almost always takes constant",
                    "      // time because we almost always (maybe always?) append the",
                    "      // nodes in order anyway.",
                    "      let i;",
                    "      for (i = resultArray.length - 1; i >= 0; --i) {",
                    "        if (",
                    "          locStart(resultArray[i]) <= locStart(node) &&",
                    "          locEnd(resultArray[i]) <= locEnd(node)",
                    "        ) {",
                    "          break;",
                    "        }",
                    "      }",
                    "      resultArray.splice(i + 1, 0, node);",
                    "      return;",
                    "    }",
                    "  } else if (node[childNodesCacheKey]) {",
                    "    return node[childNodesCacheKey];",
                    "  }",
                    "",
                    "  const childNodes =",
                    "    (printer.getCommentChildNodes &&",
                    "      printer.getCommentChildNodes(node, options)) ||",
                    "    (typeof node === \"object\" &&",
                    "      Object.keys(node)",
                    "        .filter(",
                    "          (n) =>",
                    "            n !== \"enclosingNode\" &&",
                    "            n !== \"precedingNode\" &&",
                    "            n !== \"followingNode\"",
                    "        )",
                    "        .map((n) => node[n]));",
                    "",
                    "  if (!childNodes) {",
                    "    return;",
                    "  }",
                    "",
                    "  if (!resultArray) {",
                    "    Object.defineProperty(node, childNodesCacheKey, {",
                    "      value: (resultArray = []),",
                    "      enumerable: false,",
                    "    });",
                    "  }",
                    "",
                    "  childNodes.forEach((childNode) => {",
                    "    getSortedChildNodes(childNode, options, resultArray);",
                    "  });",
                    "",
                    "  return resultArray;",
                    "}",
                    "",
                    "// As efficiently as possible, decorate the comment object with",
                    "// .precedingNode, .enclosingNode, and/or .followingNode properties, at",
                    "// least one of which is guaranteed to be defined.",
                    "function decorateComment(node, comment, options) {",
                    "  const { locStart, locEnd } = options;",
                    "",
                    "  const childNodes = getSortedChildNodes(node, options);",
                    "  let precedingNode;",
                    "  let followingNode;",
                    "  // Time to dust off the old binary search robes and wizard hat.",
                    "  let left = 0;",
                    "  let right = childNodes.length;",
                    "  while (left < right) {",
                    "    const middle = (left + right) >> 1;",
                    "    const child = childNodes[middle];",
                    "",
                    "    if (",
                    "      locStart(child) - locStart(comment) <= 0 &&",
                    "      locEnd(comment) - locEnd(child) <= 0",
                    "    ) {",
                    "      // The comment is completely contained by this child node.",
                    "      comment.enclosingNode = child;",
                    "",
                    "      decorateComment(child, comment, options);",
                    "      return; // Abandon the binary search at this level.",
                    "    }",
                    "",
                    "    if (locEnd(child) - locStart(comment) <= 0) {",
                    "      // This child node falls completely before the comment.",
                    "      // Because we will never consider this node or any nodes",
                    "      // before it again, this node must be the closest preceding",
                    "      // node we have encountered so far.",
                    "      precedingNode = child;",
                    "      left = middle + 1;",
                    "      continue;",
                    "    }",
                    "",
                    "    if (locEnd(comment) - locStart(child) <= 0) {",
                    "      // This child node falls completely after the comment.",
                    "      // Because we will never consider this node or any nodes after",
                    "      // it again, this node must be the closest following node we",
                    "      // have encountered so far.",
                    "      followingNode = child;",
                    "      right = middle;",
                    "      continue;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw new Error(\"Comment location overlaps with node location\");",
                    "  }",
                    "",
                    "  // We don't want comments inside of different expressions inside of the same",
                    "  // template literal to move to another expression.",
                    "  if (",
                    "    comment.enclosingNode &&",
                    "    comment.enclosingNode.type === \"TemplateLiteral\"",
                    "  ) {",
                    "    const { quasis } = comment.enclosingNode;",
                    "    const commentIndex = findExpressionIndexForComment(",
                    "      quasis,",
                    "      comment,",
                    "      options",
                    "    );",
                    "",
                    "    if (",
                    "      precedingNode &&",
                    "      findExpressionIndexForComment(quasis, precedingNode, options) !==",
                    "        commentIndex",
                    "    ) {",
                    "      precedingNode = null;",
                    "    }",
                    "    if (",
                    "      followingNode &&",
                    "      findExpressionIndexForComment(quasis, followingNode, options) !==",
                    "        commentIndex",
                    "    ) {",
                    "      followingNode = null;",
                    "    }",
                    "  }",
                    "",
                    "  if (precedingNode) {",
                    "    comment.precedingNode = precedingNode;",
                    "  }",
                    "",
                    "  if (followingNode) {",
                    "    comment.followingNode = followingNode;",
                    "  }",
                    "}",
                    "",
                    "function attach(comments, ast, text, options) {",
                    "  if (!Array.isArray(comments)) {",
                    "    return;",
                    "  }",
                    "",
                    "  const tiesToBreak = [];",
                    "  const { locStart, locEnd } = options;",
                    "",
                    "  comments.forEach((comment, i) => {",
                    "    if (",
                    "      options.parser === \"json\" ||",
                    "      options.parser === \"json5\" ||",
                    "      options.parser === \"__js_expression\" ||",
                    "      options.parser === \"__vue_expression\"",
                    "    ) {",
                    "      if (locStart(comment) - locStart(ast) <= 0) {",
                    "        addLeadingComment(ast, comment);",
                    "        return;",
                    "      }",
                    "      if (locEnd(comment) - locEnd(ast) >= 0) {",
                    "        addTrailingComment(ast, comment);",
                    "        return;",
                    "      }",
                    "    }",
                    "",
                    "    decorateComment(ast, comment, options);",
                    "    const { precedingNode, enclosingNode, followingNode } = comment;",
                    "",
                    "    const pluginHandleOwnLineComment =",
                    "      options.printer.handleComments && options.printer.handleComments.ownLine",
                    "        ? options.printer.handleComments.ownLine",
                    "        : () => false;",
                    "    const pluginHandleEndOfLineComment =",
                    "      options.printer.handleComments && options.printer.handleComments.endOfLine",
                    "        ? options.printer.handleComments.endOfLine",
                    "        : () => false;",
                    "    const pluginHandleRemainingComment =",
                    "      options.printer.handleComments && options.printer.handleComments.remaining",
                    "        ? options.printer.handleComments.remaining",
                    "        : () => false;",
                    "",
                    "    const isLastComment = comments.length - 1 === i;",
                    "",
                    "    if (hasNewline(text, locStart(comment), { backwards: true })) {",
                    "      // If a comment exists on its own line, prefer a leading comment.",
                    "      // We also need to check if it's the first line of the file.",
                    "      if (",
                    "        pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)",
                    "      ) {",
                    "        // We're good",
                    "      } else if (followingNode) {",
                    "        // Always a leading comment.",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (precedingNode) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    } else if (hasNewline(text, locEnd(comment))) {",
                    "      if (",
                    "        pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)",
                    "      ) {",
                    "        // We're good",
                    "      } else if (precedingNode) {",
                    "        // There is content before this comment on the same line, but",
                    "        // none after it, so prefer a trailing comment of the previous node.",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (followingNode) {",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    } else {",
                    "      if (",
                    "        pluginHandleRemainingComment(comment, text, options, ast, isLastComment)",
                    "      ) {",
                    "        // We're good",
                    "      } else if (precedingNode && followingNode) {",
                    "        // Otherwise, text exists both before and after the comment on",
                    "        // the same line. If there is both a preceding and following",
                    "        // node, use a tie-breaking algorithm to determine if it should",
                    "        // be attached to the next or previous node. In the last case,",
                    "        // simply attach the right node;",
                    "        const tieCount = tiesToBreak.length;",
                    "        if (tieCount > 0) {",
                    "          const lastTie = tiesToBreak[tieCount - 1];",
                    "          if (lastTie.followingNode !== comment.followingNode) {",
                    "            breakTies(tiesToBreak, text, options);",
                    "          }",
                    "        }",
                    "        tiesToBreak.push(comment);",
                    "      } else if (precedingNode) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (followingNode) {",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    }",
                    "  });",
                    "",
                    "  breakTies(tiesToBreak, text, options);",
                    "",
                    "  comments.forEach((comment) => {",
                    "    // These node references were useful for breaking ties, but we",
                    "    // don't need them anymore, and they create cycles in the AST that",
                    "    // may lead to infinite recursion if we don't delete them here.",
                    "    delete comment.precedingNode;",
                    "    delete comment.enclosingNode;",
                    "    delete comment.followingNode;",
                    "  });",
                    "}",
                    "",
                    "function breakTies(tiesToBreak, text, options) {",
                    "  const tieCount = tiesToBreak.length;",
                    "  if (tieCount === 0) {",
                    "    return;",
                    "  }",
                    "  const { precedingNode, followingNode, enclosingNode } = tiesToBreak[0];",
                    "",
                    "  const gapRegExp =",
                    "    (options.printer.getGapRegex &&",
                    "      options.printer.getGapRegex(enclosingNode)) ||",
                    "    /^[\\s(]*$/;",
                    "",
                    "  let gapEndPos = options.locStart(followingNode);",
                    "",
                    "  // Iterate backwards through tiesToBreak, examining the gaps",
                    "  // between the tied comments. In order to qualify as leading, a",
                    "  // comment must be separated from followingNode by an unbroken series of",
                    "  // gaps (or other comments). Gaps should only contain whitespace or open",
                    "  // parentheses.",
                    "  let indexOfFirstLeadingComment;",
                    "  for (",
                    "    indexOfFirstLeadingComment = tieCount;",
                    "    indexOfFirstLeadingComment > 0;",
                    "    --indexOfFirstLeadingComment",
                    "  ) {",
                    "    const comment = tiesToBreak[indexOfFirstLeadingComment - 1];",
                    "    assert.strictEqual(comment.precedingNode, precedingNode);",
                    "    assert.strictEqual(comment.followingNode, followingNode);",
                    "",
                    "    const gap = text.slice(options.locEnd(comment), gapEndPos);",
                    "",
                    "    if (gapRegExp.test(gap)) {",
                    "      gapEndPos = options.locStart(comment);",
                    "    } else {",
                    "      // The gap string contained something other than whitespace or open",
                    "      // parentheses.",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  tiesToBreak.forEach((comment, i) => {",
                    "    if (i < indexOfFirstLeadingComment) {",
                    "      addTrailingComment(precedingNode, comment);",
                    "    } else {",
                    "      addLeadingComment(followingNode, comment);",
                    "    }",
                    "  });",
                    "",
                    "  tiesToBreak.length = 0;",
                    "}",
                    "",
                    "function printComment(commentPath, options) {",
                    "  const comment = commentPath.getValue();",
                    "  comment.printed = true;",
                    "  return options.printer.printComment(commentPath, options);",
                    "}",
                    "",
                    "function findExpressionIndexForComment(quasis, comment, options) {",
                    "  const startPos = options.locStart(comment) - 1;",
                    "",
                    "  for (let i = 1; i < quasis.length; ++i) {",
                    "    if (startPos < getQuasiRange(quasis[i]).start) {",
                    "      return i - 1;",
                    "    }",
                    "  }",
                    "",
                    "  // We haven't found it, it probably means that some of the locations are off.",
                    "  // Let's just return the first one.",
                    "  /* istanbul ignore next */",
                    "  return 0;",
                    "}",
                    "",
                    "function getQuasiRange(expr) {",
                    "  if (expr.start !== undefined) {",
                    "    // Babel",
                    "    return { start: expr.start, end: expr.end };",
                    "  }",
                    "  // Flow",
                    "  return { start: expr.range[0], end: expr.range[1] };",
                    "}",
                    "",
                    "function printLeadingComment(commentPath, options) {",
                    "  const comment = commentPath.getValue();",
                    "  const contents = printComment(commentPath, options);",
                    "  if (!contents) {",
                    "    return \"\";",
                    "  }",
                    "  const isBlock =",
                    "    options.printer.isBlockComment && options.printer.isBlockComment(comment);",
                    "",
                    "  // Leading block comments should see if they need to stay on the",
                    "  // same line or not.",
                    "  if (isBlock) {",
                    "    const lineBreak = hasNewline(options.originalText, options.locEnd(comment))",
                    "      ? hasNewline(options.originalText, options.locStart(comment), {",
                    "          backwards: true,",
                    "        })",
                    "        ? hardline",
                    "        : line",
                    "      : \" \";",
                    "",
                    "    return concat([contents, lineBreak]);",
                    "  }",
                    "",
                    "  return concat([contents, hardline]);",
                    "}",
                    "",
                    "function printTrailingComment(commentPath, options) {",
                    "  const comment = commentPath.getValue();",
                    "  const contents = printComment(commentPath, options);",
                    "  if (!contents) {",
                    "    return \"\";",
                    "  }",
                    "  const { printer, originalText, locStart } = options;",
                    "  const isBlock = printer.isBlockComment && printer.isBlockComment(comment);",
                    "",
                    "  if (hasNewline(originalText, locStart(comment), { backwards: true })) {",
                    "    // This allows comments at the end of nested structures:",
                    "    // {",
                    "    //   x: 1,",
                    "    //   y: 2",
                    "    //   // A comment",
                    "    // }",
                    "    // Those kinds of comments are almost always leading comments, but",
                    "    // here it doesn't go \"outside\" the block and turns it into a",
                    "    // trailing comment for `2`. We can simulate the above by checking",
                    "    // if this a comment on its own line; normal trailing comments are",
                    "    // always at the end of another expression.",
                    "",
                    "    const isLineBeforeEmpty = isPreviousLineEmpty(",
                    "      originalText,",
                    "      comment,",
                    "      locStart",
                    "    );",
                    "",
                    "    return lineSuffix(",
                    "      concat([hardline, isLineBeforeEmpty ? hardline : \"\", contents])",
                    "    );",
                    "  }",
                    "",
                    "  let printed = concat([\" \", contents]);",
                    "",
                    "  // Trailing block comments never need a newline",
                    "  if (!isBlock) {",
                    "    printed = concat([lineSuffix(printed), breakParent]);",
                    "  }",
                    "",
                    "  return printed;",
                    "}",
                    "",
                    "function printDanglingComments(path, options, sameIndent, filter) {",
                    "  const parts = [];",
                    "  const node = path.getValue();",
                    "",
                    "  if (!node || !node.comments) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  path.each((commentPath) => {",
                    "    const comment = commentPath.getValue();",
                    "    if (",
                    "      comment &&",
                    "      !comment.leading &&",
                    "      !comment.trailing &&",
                    "      (!filter || filter(comment))",
                    "    ) {",
                    "      parts.push(printComment(commentPath, options));",
                    "    }",
                    "  }, \"comments\");",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (sameIndent) {",
                    "    return join(hardline, parts);",
                    "  }",
                    "  return indent(concat([hardline, join(hardline, parts)]));",
                    "}",
                    "",
                    "function prependCursorPlaceholder(path, options, printed) {",
                    "  if (path.getNode() === options.cursorNode && path.getValue()) {",
                    "    return concat([cursor, printed, cursor]);",
                    "  }",
                    "  return printed;",
                    "}",
                    "",
                    "function printComments(path, print, options, needsSemi) {",
                    "  const value = path.getValue();",
                    "  const printed = print(path);",
                    "  const comments = value && value.comments;",
                    "",
                    "  if (!comments || comments.length === 0) {",
                    "    return prependCursorPlaceholder(path, options, printed);",
                    "  }",
                    "",
                    "  const leadingParts = [];",
                    "  const trailingParts = [needsSemi ? \";\" : \"\", printed];",
                    "",
                    "  path.each((commentPath) => {",
                    "    const comment = commentPath.getValue();",
                    "    const { leading, trailing } = comment;",
                    "",
                    "    if (leading) {",
                    "      const contents = printLeadingComment(commentPath, options);",
                    "      if (!contents) {",
                    "        return;",
                    "      }",
                    "      leadingParts.push(contents);",
                    "",
                    "      const text = options.originalText;",
                    "      const index = skipNewline(",
                    "        text,",
                    "        skipSpaces(text, options.locEnd(comment))",
                    "      );",
                    "      if (index !== false && hasNewline(text, index)) {",
                    "        leadingParts.push(hardline);",
                    "      }",
                    "    } else if (trailing) {",
                    "      trailingParts.push(printTrailingComment(commentPath, options));",
                    "    }",
                    "  }, \"comments\");",
                    "",
                    "  return prependCursorPlaceholder(",
                    "    path,",
                    "    options,",
                    "    concat(leadingParts.concat(trailingParts))",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  attach,",
                    "  printComments,",
                    "  printDanglingComments,",
                    "  getSortedChildNodes,",
                    "};"
                ]
            },
            "core-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { outdent } = require(\"outdent\");",
                    "",
                    "const CATEGORY_CONFIG = \"Config\";",
                    "const CATEGORY_EDITOR = \"Editor\";",
                    "const CATEGORY_FORMAT = \"Format\";",
                    "const CATEGORY_OTHER = \"Other\";",
                    "const CATEGORY_OUTPUT = \"Output\";",
                    "const CATEGORY_GLOBAL = \"Global\";",
                    "const CATEGORY_SPECIAL = \"Special\";",
                    "",
                    "/**",
                    " * @typedef {Object} OptionInfo",
                    " * @property {string} [since] - available since version",
                    " * @property {string} category",
                    " * @property {'int' | 'boolean' | 'choice' | 'path'} type",
                    " * @property {boolean} [array] - indicate it's an array of the specified type",
                    " * @property {OptionValueInfo} [default]",
                    " * @property {OptionRangeInfo} [range] - for type int",
                    " * @property {string} description",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionRedirectInfo} [redirect] - redirect deprecated option",
                    " * @property {(value: any) => boolean} [exception]",
                    " * @property {OptionChoiceInfo[]} [choices] - for type choice",
                    " * @property {string} [cliName]",
                    " * @property {string} [cliCategory]",
                    " * @property {string} [cliDescription]",
                    " *",
                    " * @typedef {number | boolean | string} OptionValue",
                    " * @typedef {OptionValue | [{ value: OptionValue[] }] | Array<{ since: string, value: OptionValue}>} OptionValueInfo",
                    " *",
                    " * @typedef {Object} OptionRedirectInfo",
                    " * @property {string} option",
                    " * @property {OptionValue} value",
                    " *",
                    " * @typedef {Object} OptionRangeInfo",
                    " * @property {number} start - recommended range start",
                    " * @property {number} end - recommended range end",
                    " * @property {number} step - recommended range step",
                    " *",
                    " * @typedef {Object} OptionChoiceInfo",
                    " * @property {boolean | string} value - boolean for the option that is originally boolean type",
                    " * @property {string} description",
                    " * @property {string} [since] - undefined if available since the first version of the option",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionValueInfo} [redirect] - redirect deprecated value",
                    " */",
                    "",
                    "/** @type {{ [name: string]: OptionInfo }} */",
                    "const options = {",
                    "  cursorOffset: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: -1,",
                    "    range: { start: -1, end: Infinity, step: 1 },",
                    "    description: outdent`",
                    "      Print (to stderr) where a cursor at the given position would move to after formatting.",
                    "      This option cannot be used with --range-start and --range-end.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  endOfLine: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.15.0\", value: \"auto\" },",
                    "      { since: \"2.0.0\", value: \"lf\" },",
                    "    ],",
                    "    description: \"Which end of line characters to apply.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"lf\",",
                    "        description:",
                    "          \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\",",
                    "      },",
                    "      {",
                    "        value: \"crlf\",",
                    "        description:",
                    "          \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\",",
                    "      },",
                    "      {",
                    "        value: \"cr\",",
                    "        description: \"Carriage Return character only (\\\\r), used very rarely\",",
                    "      },",
                    "      {",
                    "        value: \"auto\",",
                    "        description: outdent`",
                    "          Maintain existing",
                    "          (mixed values within one file are normalised by looking at what's used after the first line)",
                    "        `,",
                    "      },",
                    "    ],",
                    "  },",
                    "  filepath: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"path\",",
                    "    description:",
                    "      \"Specify the input filepath. This will be used to do parser inference.\",",
                    "    cliName: \"stdin-filepath\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "    cliDescription: \"Path to the file to pretend that stdin comes from.\",",
                    "  },",
                    "  insertPragma: {",
                    "    since: \"1.8.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Insert @format pragma into file's first docblock comment.\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  parser: {",
                    "    since: \"0.0.10\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"0.0.10\", value: \"babylon\" },",
                    "      { since: \"1.13.0\", value: undefined },",
                    "    ],",
                    "    description: \"Which parser to use.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"function\",",
                    "    choices: [",
                    "      { value: \"flow\", description: \"Flow\" },",
                    "      { value: \"babel\", since: \"1.16.0\", description: \"JavaScript\" },",
                    "      { value: \"babel-flow\", since: \"1.16.0\", description: \"Flow\" },",
                    "      { value: \"babel-ts\", since: \"2.0.0\", description: \"TypeScript\" },",
                    "      { value: \"typescript\", since: \"1.4.0\", description: \"TypeScript\" },",
                    "      { value: \"css\", since: \"1.7.1\", description: \"CSS\" },",
                    "      { value: \"less\", since: \"1.7.1\", description: \"Less\" },",
                    "      { value: \"scss\", since: \"1.7.1\", description: \"SCSS\" },",
                    "      { value: \"json\", since: \"1.5.0\", description: \"JSON\" },",
                    "      { value: \"json5\", since: \"1.13.0\", description: \"JSON5\" },",
                    "      {",
                    "        value: \"json-stringify\",",
                    "        since: \"1.13.0\",",
                    "        description: \"JSON.stringify\",",
                    "      },",
                    "      { value: \"graphql\", since: \"1.5.0\", description: \"GraphQL\" },",
                    "      { value: \"markdown\", since: \"1.8.0\", description: \"Markdown\" },",
                    "      { value: \"mdx\", since: \"1.15.0\", description: \"MDX\" },",
                    "      { value: \"vue\", since: \"1.10.0\", description: \"Vue\" },",
                    "      { value: \"yaml\", since: \"1.14.0\", description: \"YAML\" },",
                    "      {",
                    "        value: \"glimmer\",",
                    "        since: null,",
                    "        description: \"Handlebars\",",
                    "      },",
                    "      { value: \"html\", since: \"1.15.0\", description: \"HTML\" },",
                    "      { value: \"angular\", since: \"1.15.0\", description: \"Angular\" },",
                    "      {",
                    "        value: \"lwc\",",
                    "        since: \"1.17.0\",",
                    "        description: \"Lightning Web Components\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  plugins: {",
                    "    since: \"1.10.0\",",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description:",
                    "      \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  pluginSearchDirs: {",
                    "    since: \"1.13.0\",",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description: outdent`",
                    "      Custom directory that contains prettier plugins in node_modules subdirectory.",
                    "      Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                    "      Multiple values are accepted.",
                    "    `,",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin-search-dir\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  printWidth: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"int\",",
                    "    default: 80,",
                    "    description: \"The line length where Prettier will try wrap.\",",
                    "    range: { start: 0, end: Infinity, step: 1 },",
                    "  },",
                    "  rangeEnd: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: Infinity,",
                    "    range: { start: 0, end: Infinity, step: 1 },",
                    "    description: outdent`",
                    "      Format code ending at a given character offset (exclusive).",
                    "      The range will extend forwards to the end of the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  rangeStart: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: 0,",
                    "    range: { start: 0, end: Infinity, step: 1 },",
                    "    description: outdent`",
                    "      Format code starting at a given character offset.",
                    "      The range will extend backwards to the start of the first line containing the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  requirePragma: {",
                    "    since: \"1.7.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: outdent`",
                    "      Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                    "      in order for it to be formatted.",
                    "    `,",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  tabWidth: {",
                    "    type: \"int\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    default: 2,",
                    "    description: \"Number of spaces per indentation level.\",",
                    "    range: { start: 0, end: Infinity, step: 1 },",
                    "  },",
                    "  useTabs: {",
                    "    since: \"1.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent with tabs instead of spaces.\",",
                    "  },",
                    "  embeddedLanguageFormatting: {",
                    "    since: \"2.1.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [{ since: \"2.1.0\", value: \"auto\" }],",
                    "    description:",
                    "      \"Control how Prettier formats quoted code embedded in the file.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"auto\",",
                    "        description:",
                    "          \"Format embedded code if Prettier can automatically identify it.\",",
                    "      },",
                    "      {",
                    "        value: \"off\",",
                    "        description: \"Never automatically format embedded code.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "};",
                    "",
                    "module.exports = {",
                    "  CATEGORY_CONFIG,",
                    "  CATEGORY_EDITOR,",
                    "  CATEGORY_FORMAT,",
                    "  CATEGORY_OTHER,",
                    "  CATEGORY_OUTPUT,",
                    "  CATEGORY_GLOBAL,",
                    "  CATEGORY_SPECIAL,",
                    "  options,",
                    "};"
                ]
            },
            "core.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const diff = require(\"diff\");",
                    "",
                    "const normalizeOptions = require(\"./options\").normalize;",
                    "const massageAST = require(\"./massage-ast\");",
                    "const comments = require(\"./comments\");",
                    "const parser = require(\"./parser\");",
                    "const printAstToDoc = require(\"./ast-to-doc\");",
                    "const {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "} = require(\"../common/end-of-line\");",
                    "const rangeUtil = require(\"./range-util\");",
                    "const privateUtil = require(\"../common/util\");",
                    "const {",
                    "  printer: { printDocToString },",
                    "  debug: { printDocToDebug },",
                    "} = require(\"../document\");",
                    "",
                    "const BOM = \"\\uFEFF\";",
                    "",
                    "const CURSOR = Symbol(\"cursor\");",
                    "const PLACEHOLDERS = {",
                    "  cursorOffset: \"<<<PRETTIER_CURSOR>>>\",",
                    "  rangeStart: \"<<<PRETTIER_RANGE_START>>>\",",
                    "  rangeEnd: \"<<<PRETTIER_RANGE_END>>>\",",
                    "};",
                    "",
                    "function ensureAllCommentsPrinted(astComments) {",
                    "  if (!astComments) {",
                    "    return;",
                    "  }",
                    "",
                    "  for (let i = 0; i < astComments.length; ++i) {",
                    "    if (privateUtil.isNodeIgnoreComment(astComments[i])) {",
                    "      // If there's a prettier-ignore, we're not printing that sub-tree so we",
                    "      // don't know if the comments was printed or not.",
                    "      return;",
                    "    }",
                    "  }",
                    "",
                    "  astComments.forEach((comment) => {",
                    "    if (!comment.printed) {",
                    "      throw new Error(",
                    "        'Comment \"' +",
                    "          comment.value.trim() +",
                    "          '\" was not printed. Please report this error!'",
                    "      );",
                    "    }",
                    "    delete comment.printed;",
                    "  });",
                    "}",
                    "",
                    "function attachComments(text, ast, opts) {",
                    "  const astComments = ast.comments;",
                    "  if (astComments) {",
                    "    delete ast.comments;",
                    "    comments.attach(astComments, ast, text, opts);",
                    "  }",
                    "  ast.tokens = [];",
                    "  opts.originalText = opts.parser === \"yaml\" ? text : text.trimEnd();",
                    "  return astComments;",
                    "}",
                    "",
                    "function coreFormat(text, opts, addAlignmentSize) {",
                    "  if (!text || !text.trim().length) {",
                    "    return { formatted: \"\", cursorOffset: 0 };",
                    "  }",
                    "",
                    "  addAlignmentSize = addAlignmentSize || 0;",
                    "",
                    "  const parsed = parser.parse(text, opts);",
                    "  const { ast } = parsed;",
                    "  text = parsed.text;",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    const nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);",
                    "    if (nodeResult && nodeResult.node) {",
                    "      opts.cursorNode = nodeResult.node;",
                    "    }",
                    "  }",
                    "",
                    "  const astComments = attachComments(text, ast, opts);",
                    "  const doc = printAstToDoc(ast, opts, addAlignmentSize);",
                    "",
                    "  const result = printDocToString(doc, opts);",
                    "",
                    "  ensureAllCommentsPrinted(astComments);",
                    "  // Remove extra leading indentation as well as the added indentation after last newline",
                    "  if (addAlignmentSize > 0) {",
                    "    const trimmed = result.formatted.trim();",
                    "",
                    "    if (result.cursorNodeStart !== undefined) {",
                    "      result.cursorNodeStart -= result.formatted.indexOf(trimmed);",
                    "    }",
                    "",
                    "    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);",
                    "  }",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    let oldCursorNodeStart;",
                    "    let oldCursorNodeText;",
                    "",
                    "    let cursorOffsetRelativeToOldCursorNode;",
                    "",
                    "    let newCursorNodeStart;",
                    "    let newCursorNodeText;",
                    "",
                    "    if (opts.cursorNode && result.cursorNodeText) {",
                    "      oldCursorNodeStart = opts.locStart(opts.cursorNode);",
                    "      oldCursorNodeText = text.slice(",
                    "        oldCursorNodeStart,",
                    "        opts.locEnd(opts.cursorNode)",
                    "      );",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode =",
                    "        opts.cursorOffset - oldCursorNodeStart;",
                    "",
                    "      newCursorNodeStart = result.cursorNodeStart;",
                    "      newCursorNodeText = result.cursorNodeText;",
                    "    } else {",
                    "      oldCursorNodeStart = 0;",
                    "      oldCursorNodeText = text;",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;",
                    "",
                    "      newCursorNodeStart = 0;",
                    "      newCursorNodeText = result.formatted;",
                    "    }",
                    "",
                    "    if (oldCursorNodeText === newCursorNodeText) {",
                    "      return {",
                    "        formatted: result.formatted,",
                    "        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,",
                    "      };",
                    "    }",
                    "",
                    "    // diff old and new cursor node texts, with a special cursor",
                    "    // symbol inserted to find out where it moves to",
                    "",
                    "    const oldCursorNodeCharArray = oldCursorNodeText.split(\"\");",
                    "    oldCursorNodeCharArray.splice(",
                    "      cursorOffsetRelativeToOldCursorNode,",
                    "      0,",
                    "      CURSOR",
                    "    );",
                    "",
                    "    const newCursorNodeCharArray = newCursorNodeText.split(\"\");",
                    "",
                    "    const cursorNodeDiff = diff.diffArrays(",
                    "      oldCursorNodeCharArray,",
                    "      newCursorNodeCharArray",
                    "    );",
                    "",
                    "    let cursorOffset = newCursorNodeStart;",
                    "    for (const entry of cursorNodeDiff) {",
                    "      if (entry.removed) {",
                    "        if (entry.value.includes(CURSOR)) {",
                    "          break;",
                    "        }",
                    "      } else {",
                    "        cursorOffset += entry.count;",
                    "      }",
                    "    }",
                    "",
                    "    return { formatted: result.formatted, cursorOffset };",
                    "  }",
                    "",
                    "  return { formatted: result.formatted };",
                    "}",
                    "",
                    "function formatRange(text, opts) {",
                    "  const parsed = parser.parse(text, opts);",
                    "  const { ast } = parsed;",
                    "  text = parsed.text;",
                    "",
                    "  const { rangeStart, rangeEnd } = rangeUtil.calculateRange(text, opts, ast);",
                    "  const rangeString = text.slice(rangeStart, rangeEnd);",
                    "",
                    "  // Try to extend the range backwards to the beginning of the line.",
                    "  // This is so we can detect indentation correctly and restore it.",
                    "  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0",
                    "  const rangeStart2 = Math.min(",
                    "    rangeStart,",
                    "    text.lastIndexOf(\"\\n\", rangeStart) + 1",
                    "  );",
                    "  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];",
                    "",
                    "  const alignmentSize = privateUtil.getAlignmentSize(",
                    "    indentString,",
                    "    opts.tabWidth",
                    "  );",
                    "",
                    "  const rangeResult = coreFormat(",
                    "    rangeString,",
                    "    {",
                    "      ...opts,",
                    "      rangeStart: 0,",
                    "      rangeEnd: Infinity,",
                    "      // track the cursor offset only if it's within our range",
                    "      cursorOffset:",
                    "        opts.cursorOffset >= rangeStart && opts.cursorOffset < rangeEnd",
                    "          ? opts.cursorOffset - rangeStart",
                    "          : -1,",
                    "    },",
                    "    alignmentSize",
                    "  );",
                    "",
                    "  // Since the range contracts to avoid trailing whitespace,",
                    "  // we need to remove the newline that was inserted by the `format` call.",
                    "  const rangeTrimmed = rangeResult.formatted.trimEnd();",
                    "  const rangeLeft = text.slice(0, rangeStart);",
                    "  const rangeRight = text.slice(rangeEnd);",
                    "",
                    "  let { cursorOffset } = opts;",
                    "  if (opts.cursorOffset >= rangeEnd) {",
                    "    // handle the case where the cursor was past the end of the range",
                    "    cursorOffset =",
                    "      opts.cursorOffset - rangeEnd + (rangeStart + rangeTrimmed.length);",
                    "  } else if (rangeResult.cursorOffset !== undefined) {",
                    "    // handle the case where the cursor was in the range",
                    "    cursorOffset = rangeResult.cursorOffset + rangeStart;",
                    "  }",
                    "  // keep the cursor as it was if it was before the start of the range",
                    "",
                    "  let formatted;",
                    "  if (opts.endOfLine === \"lf\") {",
                    "    formatted = rangeLeft + rangeTrimmed + rangeRight;",
                    "  } else {",
                    "    const eol = convertEndOfLineToChars(opts.endOfLine);",
                    "    if (cursorOffset >= 0) {",
                    "      const parts = [rangeLeft, rangeTrimmed, rangeRight];",
                    "      let partIndex = 0;",
                    "      let partOffset = cursorOffset;",
                    "      while (partIndex < parts.length) {",
                    "        const part = parts[partIndex];",
                    "        if (partOffset < part.length) {",
                    "          parts[partIndex] =",
                    "            parts[partIndex].slice(0, partOffset) +",
                    "            PLACEHOLDERS.cursorOffset +",
                    "            parts[partIndex].slice(partOffset);",
                    "          break;",
                    "        }",
                    "        partIndex++;",
                    "        partOffset -= part.length;",
                    "      }",
                    "      const [newRangeLeft, newRangeTrimmed, newRangeRight] = parts;",
                    "      formatted = (",
                    "        newRangeLeft.replace(/\\n/g, eol) +",
                    "        newRangeTrimmed +",
                    "        newRangeRight.replace(/\\n/g, eol)",
                    "      ).replace(PLACEHOLDERS.cursorOffset, (_, index) => {",
                    "        cursorOffset = index;",
                    "        return \"\";",
                    "      });",
                    "    } else {",
                    "      formatted =",
                    "        rangeLeft.replace(/\\n/g, eol) +",
                    "        rangeTrimmed +",
                    "        rangeRight.replace(/\\n/g, eol);",
                    "    }",
                    "  }",
                    "",
                    "  return { formatted, cursorOffset };",
                    "}",
                    "",
                    "function format(text, opts) {",
                    "  const selectedParser = parser.resolveParser(opts);",
                    "  const hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);",
                    "  if (opts.requirePragma && !hasPragma) {",
                    "    return { formatted: text };",
                    "  }",
                    "",
                    "  if (opts.endOfLine === \"auto\") {",
                    "    opts.endOfLine = guessEndOfLine(text);",
                    "  }",
                    "",
                    "  const hasCursor = opts.cursorOffset >= 0;",
                    "  const hasRangeStart = opts.rangeStart > 0;",
                    "  const hasRangeEnd = opts.rangeEnd < text.length;",
                    "",
                    "  // get rid of CR/CRLF parsing",
                    "  if (text.includes(\"\\r\")) {",
                    "    const offsetKeys = [",
                    "      hasCursor && \"cursorOffset\",",
                    "      hasRangeStart && \"rangeStart\",",
                    "      hasRangeEnd && \"rangeEnd\",",
                    "    ]",
                    "      .filter(Boolean)",
                    "      .sort((aKey, bKey) => opts[aKey] - opts[bKey]);",
                    "",
                    "    for (let i = offsetKeys.length - 1; i >= 0; i--) {",
                    "      const key = offsetKeys[i];",
                    "      text =",
                    "        text.slice(0, opts[key]) + PLACEHOLDERS[key] + text.slice(opts[key]);",
                    "    }",
                    "",
                    "    text = text.replace(/\\r\\n?/g, \"\\n\");",
                    "",
                    "    for (let i = 0; i < offsetKeys.length; i++) {",
                    "      const key = offsetKeys[i];",
                    "      text = text.replace(PLACEHOLDERS[key], (_, index) => {",
                    "        opts[key] = index;",
                    "        return \"\";",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  const hasUnicodeBOM = text.charAt(0) === BOM;",
                    "  if (hasUnicodeBOM) {",
                    "    text = text.slice(1);",
                    "    if (hasCursor) {",
                    "      opts.cursorOffset++;",
                    "    }",
                    "    if (hasRangeStart) {",
                    "      opts.rangeStart++;",
                    "    }",
                    "    if (hasRangeEnd) {",
                    "      opts.rangeEnd++;",
                    "    }",
                    "  }",
                    "",
                    "  if (!hasCursor) {",
                    "    opts.cursorOffset = -1;",
                    "  }",
                    "  if (opts.rangeStart < 0) {",
                    "    opts.rangeStart = 0;",
                    "  }",
                    "  if (opts.rangeEnd > text.length) {",
                    "    opts.rangeEnd = text.length;",
                    "  }",
                    "",
                    "  const result =",
                    "    hasRangeStart || hasRangeEnd",
                    "      ? formatRange(text, opts)",
                    "      : coreFormat(",
                    "          opts.insertPragma && opts.printer.insertPragma && !hasPragma",
                    "            ? opts.printer.insertPragma(text)",
                    "            : text,",
                    "          opts",
                    "        );",
                    "",
                    "  if (hasUnicodeBOM) {",
                    "    result.formatted = BOM + result.formatted;",
                    "",
                    "    if (hasCursor) {",
                    "      result.cursorOffset++;",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "module.exports = {",
                    "  formatWithCursor(text, opts) {",
                    "    opts = normalizeOptions(opts);",
                    "    return format(text, opts);",
                    "  },",
                    "",
                    "  parse(text, opts, massage) {",
                    "    opts = normalizeOptions(opts);",
                    "    if (text.includes(\"\\r\")) {",
                    "      text = text.replace(/\\r\\n?/g, \"\\n\");",
                    "    }",
                    "    const parsed = parser.parse(text, opts);",
                    "    if (massage) {",
                    "      parsed.ast = massageAST(parsed.ast, opts);",
                    "    }",
                    "    return parsed;",
                    "  },",
                    "",
                    "  formatAST(ast, opts) {",
                    "    opts = normalizeOptions(opts);",
                    "    const doc = printAstToDoc(ast, opts);",
                    "    return printDocToString(doc, opts);",
                    "  },",
                    "",
                    "  // Doesn't handle shebang for now",
                    "  formatDoc(doc, opts) {",
                    "    const debug = printDocToDebug(doc);",
                    "    opts = normalizeOptions({ ...opts, parser: \"babel\" });",
                    "    return format(debug, opts).formatted;",
                    "  },",
                    "",
                    "  printToDoc(text, opts) {",
                    "    opts = normalizeOptions(opts);",
                    "    const parsed = parser.parse(text, opts);",
                    "    const { ast } = parsed;",
                    "    text = parsed.text;",
                    "    attachComments(text, ast, opts);",
                    "    return printAstToDoc(ast, opts);",
                    "  },",
                    "",
                    "  printDocToString(doc, opts) {",
                    "    return printDocToString(doc, normalizeOptions(opts));",
                    "  },",
                    "};"
                ]
            },
            "massage-ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function massageAST(ast, options, parent) {",
                    "  if (Array.isArray(ast)) {",
                    "    return ast.map((e) => massageAST(e, options, parent)).filter(Boolean);",
                    "  }",
                    "",
                    "  if (!ast || typeof ast !== \"object\") {",
                    "    return ast;",
                    "  }",
                    "",
                    "  const newObj = {};",
                    "  for (const key of Object.keys(ast)) {",
                    "    if (typeof ast[key] !== \"function\") {",
                    "      newObj[key] = massageAST(ast[key], options, ast);",
                    "    }",
                    "  }",
                    "",
                    "  if (options.printer.massageAstNode) {",
                    "    const result = options.printer.massageAstNode(ast, newObj, parent);",
                    "    if (result === null) {",
                    "      return;",
                    "    }",
                    "    if (result) {",
                    "      return result;",
                    "    }",
                    "  }",
                    "",
                    "  return newObj;",
                    "}",
                    "",
                    "module.exports = massageAST;"
                ]
            },
            "multiparser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { normalize } = require(\"./options\");",
                    "const comments = require(\"./comments\");",
                    "",
                    "function printSubtree(path, print, options, printAstToDoc) {",
                    "  if (options.printer.embed && options.embeddedLanguageFormatting === \"auto\") {",
                    "    return options.printer.embed(",
                    "      path,",
                    "      print,",
                    "      (text, partialNextOptions) =>",
                    "        textToDoc(text, partialNextOptions, options, printAstToDoc),",
                    "      options",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc) {",
                    "  const nextOptions = normalize(",
                    "    {",
                    "      ...parentOptions,",
                    "      ...partialNextOptions,",
                    "      parentParser: parentOptions.parser,",
                    "      embeddedInHtml: !!(",
                    "        parentOptions.embeddedInHtml ||",
                    "        parentOptions.parser === \"html\" ||",
                    "        parentOptions.parser === \"vue\" ||",
                    "        parentOptions.parser === \"angular\" ||",
                    "        parentOptions.parser === \"lwc\"",
                    "      ),",
                    "      originalText: text,",
                    "    },",
                    "    { passThrough: true }",
                    "  );",
                    "",
                    "  const result = require(\"./parser\").parse(text, nextOptions);",
                    "  const { ast } = result;",
                    "  text = result.text;",
                    "",
                    "  const astComments = ast.comments;",
                    "  delete ast.comments;",
                    "  comments.attach(astComments, ast, text, nextOptions);",
                    "  return printAstToDoc(ast, nextOptions);",
                    "}",
                    "",
                    "module.exports = {",
                    "  printSubtree,",
                    "};"
                ]
            },
            "options-normalizer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const vnopts = require(\"vnopts\");",
                    "const leven = require(\"leven\");",
                    "const chalk = require(\"chalk\");",
                    "",
                    "const cliDescriptor = {",
                    "  key: (key) => (key.length === 1 ? `-${key}` : `--${key}`),",
                    "  value: (value) => vnopts.apiDescriptor.value(value),",
                    "  pair: ({ key, value }) =>",
                    "    value === false",
                    "      ? `--no-${key}`",
                    "      : value === true",
                    "      ? cliDescriptor.key(key)",
                    "      : value === \"\"",
                    "      ? `${cliDescriptor.key(key)} without an argument`",
                    "      : `${cliDescriptor.key(key)}=${value}`,",
                    "};",
                    "",
                    "class FlagSchema extends vnopts.ChoiceSchema {",
                    "  constructor({ name, flags }) {",
                    "    super({ name, choices: flags });",
                    "    this._flags = flags.slice().sort();",
                    "  }",
                    "  preprocess(value, utils) {",
                    "    if (",
                    "      typeof value === \"string\" &&",
                    "      value.length !== 0 &&",
                    "      !this._flags.includes(value)",
                    "    ) {",
                    "      const suggestion = this._flags.find((flag) => leven(flag, value) < 3);",
                    "      if (suggestion) {",
                    "        utils.logger.warn(",
                    "          [",
                    "            `Unknown flag ${chalk.yellow(utils.descriptor.value(value))},`,",
                    "            `did you mean ${chalk.blue(utils.descriptor.value(suggestion))}?`,",
                    "          ].join(\" \")",
                    "        );",
                    "        return suggestion;",
                    "      }",
                    "    }",
                    "    return value;",
                    "  }",
                    "  expected() {",
                    "    return \"a flag\";",
                    "  }",
                    "}",
                    "",
                    "let hasDeprecationWarned;",
                    "",
                    "function normalizeOptions(",
                    "  options,",
                    "  optionInfos,",
                    "  { logger, isCLI = false, passThrough = false } = {}",
                    ") {",
                    "  const unknown = !passThrough",
                    "    ? vnopts.levenUnknownHandler",
                    "    : Array.isArray(passThrough)",
                    "    ? (key, value) =>",
                    "        !passThrough.includes(key) ? undefined : { [key]: value }",
                    "    : (key, value) => ({ [key]: value });",
                    "",
                    "  const descriptor = isCLI ? cliDescriptor : vnopts.apiDescriptor;",
                    "  const schemas = optionInfosToSchemas(optionInfos, { isCLI });",
                    "  const normalizer = new vnopts.Normalizer(schemas, {",
                    "    logger,",
                    "    unknown,",
                    "    descriptor,",
                    "  });",
                    "",
                    "  const shouldSuppressDuplicateDeprecationWarnings = logger !== false;",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {",
                    "    normalizer._hasDeprecationWarned = hasDeprecationWarned;",
                    "  }",
                    "",
                    "  const normalized = normalizer.normalize(options);",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings) {",
                    "    hasDeprecationWarned = normalizer._hasDeprecationWarned;",
                    "  }",
                    "",
                    "  return normalized;",
                    "}",
                    "",
                    "function optionInfosToSchemas(optionInfos, { isCLI }) {",
                    "  const schemas = [];",
                    "",
                    "  if (isCLI) {",
                    "    schemas.push(vnopts.AnySchema.create({ name: \"_\" }));",
                    "  }",
                    "",
                    "  for (const optionInfo of optionInfos) {",
                    "    schemas.push(optionInfoToSchema(optionInfo, { isCLI, optionInfos }));",
                    "",
                    "    if (optionInfo.alias && isCLI) {",
                    "      schemas.push(",
                    "        vnopts.AliasSchema.create({",
                    "          name: optionInfo.alias,",
                    "          sourceName: optionInfo.name,",
                    "        })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return schemas;",
                    "}",
                    "",
                    "function optionInfoToSchema(optionInfo, { isCLI, optionInfos }) {",
                    "  let SchemaConstructor;",
                    "  const parameters = { name: optionInfo.name };",
                    "  const handlers = {};",
                    "",
                    "  switch (optionInfo.type) {",
                    "    case \"int\":",
                    "      SchemaConstructor = vnopts.IntegerSchema;",
                    "      if (isCLI) {",
                    "        parameters.preprocess = (value) => Number(value);",
                    "      }",
                    "      break;",
                    "    case \"string\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    case \"choice\":",
                    "      SchemaConstructor = vnopts.ChoiceSchema;",
                    "      parameters.choices = optionInfo.choices.map((choiceInfo) =>",
                    "        typeof choiceInfo === \"object\" && choiceInfo.redirect",
                    "          ? {",
                    "              ...choiceInfo,",
                    "              redirect: {",
                    "                to: { key: optionInfo.name, value: choiceInfo.redirect },",
                    "              },",
                    "            }",
                    "          : choiceInfo",
                    "      );",
                    "      break;",
                    "    case \"boolean\":",
                    "      SchemaConstructor = vnopts.BooleanSchema;",
                    "      break;",
                    "    case \"flag\":",
                    "      SchemaConstructor = FlagSchema;",
                    "      parameters.flags = optionInfos",
                    "        .map((optionInfo) =>",
                    "          [].concat(",
                    "            optionInfo.alias || [],",
                    "            optionInfo.description ? optionInfo.name : [],",
                    "            optionInfo.oppositeDescription ? `no-${optionInfo.name}` : []",
                    "          )",
                    "        )",
                    "        .reduce((a, b) => a.concat(b), []);",
                    "      break;",
                    "    case \"path\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    default:",
                    "      throw new Error(`Unexpected type ${optionInfo.type}`);",
                    "  }",
                    "",
                    "  if (optionInfo.exception) {",
                    "    parameters.validate = (value, schema, utils) => {",
                    "      return optionInfo.exception(value) || schema.validate(value, utils);",
                    "    };",
                    "  } else {",
                    "    parameters.validate = (value, schema, utils) => {",
                    "      return value === undefined || schema.validate(value, utils);",
                    "    };",
                    "  }",
                    "",
                    "  if (optionInfo.redirect) {",
                    "    handlers.redirect = (value) =>",
                    "      !value",
                    "        ? undefined",
                    "        : {",
                    "            to: {",
                    "              key: optionInfo.redirect.option,",
                    "              value: optionInfo.redirect.value,",
                    "            },",
                    "          };",
                    "  }",
                    "",
                    "  if (optionInfo.deprecated) {",
                    "    handlers.deprecated = true;",
                    "  }",
                    "",
                    "  // allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2",
                    "  if (isCLI && !optionInfo.array) {",
                    "    const originalPreprocess = parameters.preprocess || ((x) => x);",
                    "    parameters.preprocess = (value, schema, utils) =>",
                    "      schema.preprocess(",
                    "        originalPreprocess(",
                    "          Array.isArray(value) ? value[value.length - 1] : value",
                    "        ),",
                    "        utils",
                    "      );",
                    "  }",
                    "",
                    "  return optionInfo.array",
                    "    ? vnopts.ArraySchema.create({",
                    "        ...(isCLI ? { preprocess: (v) => [].concat(v) } : {}),",
                    "        ...handlers,",
                    "        valueSchema: SchemaConstructor.create(parameters),",
                    "      })",
                    "    : SchemaConstructor.create({ ...parameters, ...handlers });",
                    "}",
                    "",
                    "function normalizeApiOptions(options, optionInfos, opts) {",
                    "  return normalizeOptions(options, optionInfos, opts);",
                    "}",
                    "",
                    "function normalizeCliOptions(options, optionInfos, opts) {",
                    "  return normalizeOptions(options, optionInfos, { isCLI: true, ...opts });",
                    "}",
                    "",
                    "module.exports = {",
                    "  normalizeApiOptions,",
                    "  normalizeCliOptions,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "const path = require(\"path\");",
                    "const readlines = require(\"n-readlines\");",
                    "const fromPairs = require(\"lodash/fromPairs\");",
                    "const { UndefinedParserError } = require(\"../common/errors\");",
                    "const { getSupportInfo } = require(\"../main/support\");",
                    "const normalizer = require(\"./options-normalizer\");",
                    "const { resolveParser } = require(\"./parser\");",
                    "",
                    "const hiddenDefaults = {",
                    "  astFormat: \"estree\",",
                    "  printer: {},",
                    "  originalText: undefined,",
                    "  locStart: null,",
                    "  locEnd: null,",
                    "};",
                    "",
                    "// Copy options and fill in default values.",
                    "function normalize(options, opts) {",
                    "  opts = opts || {};",
                    "",
                    "  const rawOptions = { ...options };",
                    "",
                    "  const supportOptions = getSupportInfo({",
                    "    plugins: options.plugins,",
                    "    showUnreleased: true,",
                    "    showDeprecated: true,",
                    "  }).options;",
                    "",
                    "  const defaults = {",
                    "    ...hiddenDefaults,",
                    "    ...fromPairs(",
                    "      supportOptions",
                    "        .filter((optionInfo) => optionInfo.default !== undefined)",
                    "        .map((option) => [option.name, option.default])",
                    "    ),",
                    "  };",
                    "  if (!rawOptions.parser) {",
                    "    if (!rawOptions.filepath) {",
                    "      const logger = opts.logger || console;",
                    "      logger.warn(",
                    "        \"No parser and no filepath given, using 'babel' the parser now \" +",
                    "          \"but this will throw an error in the future. \" +",
                    "          \"Please specify a parser or a filepath so one can be inferred.\"",
                    "      );",
                    "      rawOptions.parser = \"babel\";",
                    "    } else {",
                    "      rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);",
                    "      if (!rawOptions.parser) {",
                    "        throw new UndefinedParserError(",
                    "          `No parser could be inferred for file: ${rawOptions.filepath}`",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const parser = resolveParser(",
                    "    normalizer.normalizeApiOptions(",
                    "      rawOptions,",
                    "      [supportOptions.find((x) => x.name === \"parser\")],",
                    "      { passThrough: true, logger: false }",
                    "    )",
                    "  );",
                    "  rawOptions.astFormat = parser.astFormat;",
                    "  rawOptions.locEnd = parser.locEnd;",
                    "  rawOptions.locStart = parser.locStart;",
                    "",
                    "  const plugin = getPlugin(rawOptions);",
                    "  rawOptions.printer = plugin.printers[rawOptions.astFormat];",
                    "",
                    "  const pluginDefaults = supportOptions",
                    "    .filter(",
                    "      (optionInfo) =>",
                    "        optionInfo.pluginDefaults &&",
                    "        optionInfo.pluginDefaults[plugin.name] !== undefined",
                    "    )",
                    "    .reduce(",
                    "      (reduced, optionInfo) =>",
                    "        Object.assign(reduced, {",
                    "          [optionInfo.name]: optionInfo.pluginDefaults[plugin.name],",
                    "        }),",
                    "      {}",
                    "    );",
                    "",
                    "  const mixedDefaults = { ...defaults, ...pluginDefaults };",
                    "",
                    "  Object.keys(mixedDefaults).forEach((k) => {",
                    "    if (rawOptions[k] == null) {",
                    "      rawOptions[k] = mixedDefaults[k];",
                    "    }",
                    "  });",
                    "",
                    "  if (rawOptions.parser === \"json\") {",
                    "    rawOptions.trailingComma = \"none\";",
                    "  }",
                    "",
                    "  return normalizer.normalizeApiOptions(rawOptions, supportOptions, {",
                    "    passThrough: Object.keys(hiddenDefaults),",
                    "    ...opts,",
                    "  });",
                    "}",
                    "",
                    "function getPlugin(options) {",
                    "  const { astFormat } = options;",
                    "",
                    "  if (!astFormat) {",
                    "    throw new Error(\"getPlugin() requires astFormat to be set\");",
                    "  }",
                    "  const printerPlugin = options.plugins.find(",
                    "    (plugin) => plugin.printers && plugin.printers[astFormat]",
                    "  );",
                    "  if (!printerPlugin) {",
                    "    throw new Error(`Couldn't find plugin for AST format \"${astFormat}\"`);",
                    "  }",
                    "",
                    "  return printerPlugin;",
                    "}",
                    "",
                    "function getInterpreter(filepath) {",
                    "  if (typeof filepath !== \"string\") {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  let fd;",
                    "  try {",
                    "    fd = fs.openSync(filepath, \"r\");",
                    "  } catch (err) {",
                    "    // istanbul ignore next",
                    "    return \"\";",
                    "  }",
                    "",
                    "  try {",
                    "    const liner = new readlines(fd);",
                    "    const firstLine = liner.next().toString(\"utf8\");",
                    "",
                    "    // #!/bin/env node, #!/usr/bin/env node",
                    "    const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);",
                    "    if (m1) {",
                    "      return m1[1];",
                    "    }",
                    "",
                    "    // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node",
                    "    const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);",
                    "    if (m2) {",
                    "      return m2[1];",
                    "    }",
                    "    return \"\";",
                    "  } catch (err) {",
                    "    // There are some weird cases where paths are missing, causing Jest",
                    "    // failures. It's unclear what these correspond to in the real world.",
                    "    return \"\";",
                    "  } finally {",
                    "    try {",
                    "      // There are some weird cases where paths are missing, causing Jest",
                    "      // failures. It's unclear what these correspond to in the real world.",
                    "      fs.closeSync(fd);",
                    "    } catch (err) {",
                    "      // nop",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function inferParser(filepath, plugins) {",
                    "  const filename = path.basename(filepath).toLowerCase();",
                    "  const languages = getSupportInfo({ plugins }).languages.filter(",
                    "    (language) => language.since !== null",
                    "  );",
                    "",
                    "  // If the file has no extension, we can try to infer the language from the",
                    "  // interpreter in the shebang line, if any; but since this requires FS access,",
                    "  // do it last.",
                    "  let language = languages.find(",
                    "    (language) =>",
                    "      (language.extensions &&",
                    "        language.extensions.some((extension) =>",
                    "          filename.endsWith(extension)",
                    "        )) ||",
                    "      (language.filenames &&",
                    "        language.filenames.find((name) => name.toLowerCase() === filename))",
                    "  );",
                    "",
                    "  if (!language && !filename.includes(\".\")) {",
                    "    const interpreter = getInterpreter(filepath);",
                    "    language = languages.find(",
                    "      (language) =>",
                    "        language.interpreters && language.interpreters.includes(interpreter)",
                    "    );",
                    "  }",
                    "",
                    "  return language && language.parsers[0];",
                    "}",
                    "",
                    "module.exports = { normalize, hiddenDefaults, inferParser };"
                ]
            },
            "parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const { ConfigError } = require(\"../common/errors\");",
                    "const jsLoc = require(\"../language-js/loc\");",
                    "",
                    "const { locStart, locEnd } = jsLoc;",
                    "",
                    "// Use defineProperties()/getOwnPropertyDescriptor() to prevent",
                    "// triggering the parsers getters.",
                    "const ownNames = Object.getOwnPropertyNames;",
                    "const ownDescriptor = Object.getOwnPropertyDescriptor;",
                    "function getParsers(options) {",
                    "  const parsers = {};",
                    "  for (const plugin of options.plugins) {",
                    "    if (!plugin.parsers) {",
                    "      continue;",
                    "    }",
                    "",
                    "    for (const name of ownNames(plugin.parsers)) {",
                    "      Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));",
                    "    }",
                    "  }",
                    "",
                    "  return parsers;",
                    "}",
                    "",
                    "function resolveParser(opts, parsers) {",
                    "  parsers = parsers || getParsers(opts);",
                    "",
                    "  if (typeof opts.parser === \"function\") {",
                    "    // Custom parser API always works with JavaScript.",
                    "    return {",
                    "      parse: opts.parser,",
                    "      astFormat: \"estree\",",
                    "      locStart,",
                    "      locEnd,",
                    "    };",
                    "  }",
                    "",
                    "  if (typeof opts.parser === \"string\") {",
                    "    if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {",
                    "      return parsers[opts.parser];",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    if (process.env.PRETTIER_TARGET === \"universal\") {",
                    "      throw new ConfigError(",
                    "        `Couldn't resolve parser \"${opts.parser}\". Parsers must be explicitly added to the standalone bundle.`",
                    "      );",
                    "    } else {",
                    "      try {",
                    "        return {",
                    "          parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),",
                    "          astFormat: \"estree\",",
                    "          locStart,",
                    "          locEnd,",
                    "        };",
                    "      } catch (err) {",
                    "        /* istanbul ignore next */",
                    "        throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function parse(text, opts) {",
                    "  const parsers = getParsers(opts);",
                    "",
                    "  // Create a new object {parserName: parseFn}. Uses defineProperty() to only call",
                    "  // the parsers getters when actually calling the parser `parse` function.",
                    "  const parsersForCustomParserApi = Object.keys(parsers).reduce(",
                    "    (object, parserName) =>",
                    "      Object.defineProperty(object, parserName, {",
                    "        enumerable: true,",
                    "        get() {",
                    "          return parsers[parserName].parse;",
                    "        },",
                    "      }),",
                    "    {}",
                    "  );",
                    "",
                    "  const parser = resolveParser(opts, parsers);",
                    "",
                    "  try {",
                    "    if (parser.preprocess) {",
                    "      text = parser.preprocess(text, opts);",
                    "    }",
                    "",
                    "    return {",
                    "      text,",
                    "      ast: parser.parse(text, parsersForCustomParserApi, opts),",
                    "    };",
                    "  } catch (error) {",
                    "    const { loc } = error;",
                    "",
                    "    if (loc) {",
                    "      const codeFrame = require(\"@babel/code-frame\");",
                    "      error.codeFrame = codeFrame.codeFrameColumns(text, loc, {",
                    "        highlightCode: true,",
                    "      });",
                    "      error.message += \"\\n\" + error.codeFrame;",
                    "      throw error;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw error.stack;",
                    "  }",
                    "}",
                    "",
                    "module.exports = { parse, resolveParser };"
                ]
            },
            "range-util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const comments = require(\"./comments\");",
                    "",
                    "function findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts) {",
                    "  let resultStartNode = startNodeAndParents.node;",
                    "  let resultEndNode = endNodeAndParents.node;",
                    "",
                    "  if (resultStartNode === resultEndNode) {",
                    "    return {",
                    "      startNode: resultStartNode,",
                    "      endNode: resultEndNode,",
                    "    };",
                    "  }",
                    "",
                    "  for (const endParent of endNodeAndParents.parentNodes) {",
                    "    if (",
                    "      endParent.type !== \"Program\" &&",
                    "      endParent.type !== \"File\" &&",
                    "      opts.locStart(endParent) >= opts.locStart(startNodeAndParents.node)",
                    "    ) {",
                    "      resultEndNode = endParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  for (const startParent of startNodeAndParents.parentNodes) {",
                    "    if (",
                    "      startParent.type !== \"Program\" &&",
                    "      startParent.type !== \"File\" &&",
                    "      opts.locEnd(startParent) <= opts.locEnd(endNodeAndParents.node)",
                    "    ) {",
                    "      resultStartNode = startParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  return {",
                    "    startNode: resultStartNode,",
                    "    endNode: resultEndNode,",
                    "  };",
                    "}",
                    "",
                    "function findNodeAtOffset(node, offset, options, predicate, parentNodes = []) {",
                    "  if (offset < options.locStart(node) || offset > options.locEnd(node)) {",
                    "    return;",
                    "  }",
                    "",
                    "  for (const childNode of comments.getSortedChildNodes(node, options)) {",
                    "    const childResult = findNodeAtOffset(",
                    "      childNode,",
                    "      offset,",
                    "      options,",
                    "      predicate,",
                    "      [node, ...parentNodes]",
                    "    );",
                    "    if (childResult) {",
                    "      return childResult;",
                    "    }",
                    "  }",
                    "",
                    "  if (!predicate || predicate(node)) {",
                    "    return {",
                    "      node,",
                    "      parentNodes,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5",
                    "function isJsSourceElement(type) {",
                    "  return (",
                    "    type === \"Directive\" ||",
                    "    type === \"TypeAlias\" ||",
                    "    type === \"TSExportAssignment\" ||",
                    "    type.startsWith(\"Declare\") ||",
                    "    type.startsWith(\"TSDeclare\") ||",
                    "    type.endsWith(\"Statement\") ||",
                    "    type.endsWith(\"Declaration\")",
                    "  );",
                    "}",
                    "",
                    "const jsonSourceElements = new Set([",
                    "  \"ObjectExpression\",",
                    "  \"ArrayExpression\",",
                    "  \"StringLiteral\",",
                    "  \"NumericLiteral\",",
                    "  \"BooleanLiteral\",",
                    "  \"NullLiteral\",",
                    "]);",
                    "const graphqlSourceElements = new Set([",
                    "  \"OperationDefinition\",",
                    "  \"FragmentDefinition\",",
                    "  \"VariableDefinition\",",
                    "  \"TypeExtensionDefinition\",",
                    "  \"ObjectTypeDefinition\",",
                    "  \"FieldDefinition\",",
                    "  \"DirectiveDefinition\",",
                    "  \"EnumTypeDefinition\",",
                    "  \"EnumValueDefinition\",",
                    "  \"InputValueDefinition\",",
                    "  \"InputObjectTypeDefinition\",",
                    "  \"SchemaDefinition\",",
                    "  \"OperationTypeDefinition\",",
                    "  \"InterfaceTypeDefinition\",",
                    "  \"UnionTypeDefinition\",",
                    "  \"ScalarTypeDefinition\",",
                    "]);",
                    "function isSourceElement(opts, node) {",
                    "  if (node == null) {",
                    "    return false;",
                    "  }",
                    "  switch (opts.parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "      return isJsSourceElement(node.type);",
                    "    case \"json\":",
                    "      return jsonSourceElements.has(node.type);",
                    "    case \"graphql\":",
                    "      return graphqlSourceElements.has(node.kind);",
                    "    case \"vue\":",
                    "      return node.tag !== \"root\";",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function calculateRange(text, opts, ast) {",
                    "  // Contract the range so that it has non-whitespace characters at its endpoints.",
                    "  // This ensures we can format a range that doesn't end on a node.",
                    "  const rangeStringOrig = text.slice(opts.rangeStart, opts.rangeEnd);",
                    "  const startNonWhitespace = Math.max(",
                    "    opts.rangeStart + rangeStringOrig.search(/\\S/),",
                    "    opts.rangeStart",
                    "  );",
                    "  let endNonWhitespace;",
                    "  for (",
                    "    endNonWhitespace = opts.rangeEnd;",
                    "    endNonWhitespace > opts.rangeStart;",
                    "    --endNonWhitespace",
                    "  ) {",
                    "    if (/\\S/.test(text[endNonWhitespace - 1])) {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  const startNodeAndParents = findNodeAtOffset(",
                    "    ast,",
                    "    startNonWhitespace,",
                    "    opts,",
                    "    (node) => isSourceElement(opts, node)",
                    "  );",
                    "  const endNodeAndParents = findNodeAtOffset(",
                    "    ast,",
                    "    endNonWhitespace,",
                    "    opts,",
                    "    (node) => isSourceElement(opts, node)",
                    "  );",
                    "",
                    "  if (!startNodeAndParents || !endNodeAndParents) {",
                    "    return {",
                    "      rangeStart: 0,",
                    "      rangeEnd: 0,",
                    "    };",
                    "  }",
                    "",
                    "  const { startNode, endNode } = findSiblingAncestors(",
                    "    startNodeAndParents,",
                    "    endNodeAndParents,",
                    "    opts",
                    "  );",
                    "",
                    "  return {",
                    "    rangeStart: Math.min(opts.locStart(startNode), opts.locStart(endNode)),",
                    "    rangeEnd: Math.max(opts.locEnd(startNode), opts.locEnd(endNode)),",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  calculateRange,",
                    "  findNodeAtOffset,",
                    "};"
                ]
            },
            "support.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const semver = {",
                    "  compare: require(\"semver/functions/compare\"),",
                    "  lt: require(\"semver/functions/lt\"),",
                    "  gte: require(\"semver/functions/gte\"),",
                    "};",
                    "const arrayify = require(\"../utils/arrayify\");",
                    "const currentVersion = require(\"../../package.json\").version;",
                    "const coreOptions = require(\"./core-options\").options;",
                    "",
                    "/**",
                    " * Strings in `plugins` and `pluginSearchDirs` are handled by a wrapped version",
                    " * of this function created by `withPlugins`. Don't pass them here directly.",
                    " * @param {object} param0",
                    " * @param {(string | object)[]=} param0.plugins Strings are resolved by `withPlugins`.",
                    " * @param {string[]=} param0.pluginSearchDirs Added by `withPlugins`.",
                    " * @param {boolean=} param0.showUnreleased",
                    " * @param {boolean=} param0.showDeprecated",
                    " * @param {boolean=} param0.showInternal",
                    " */",
                    "function getSupportInfo({",
                    "  plugins = [],",
                    "  showUnreleased = false,",
                    "  showDeprecated = false,",
                    "  showInternal = false,",
                    "} = {}) {",
                    "  // pre-release version is smaller than the normal version in semver,",
                    "  // we need to treat it as the normal one so as to test new features.",
                    "  const version = currentVersion.split(\"-\", 1)[0];",
                    "",
                    "  const languages = plugins",
                    "    .reduce((all, plugin) => all.concat(plugin.languages || []), [])",
                    "    .filter(filterSince);",
                    "",
                    "  const options = arrayify(",
                    "    Object.assign({}, ...plugins.map(({ options }) => options), coreOptions),",
                    "    \"name\"",
                    "  )",
                    "    .filter((option) => filterSince(option) && filterDeprecated(option))",
                    "    .sort((a, b) => (a.name === b.name ? 0 : a.name < b.name ? -1 : 1))",
                    "    .map(mapInternal)",
                    "    .map((option) => {",
                    "      option = { ...option };",
                    "",
                    "      if (Array.isArray(option.default)) {",
                    "        option.default =",
                    "          option.default.length === 1",
                    "            ? option.default[0].value",
                    "            : option.default",
                    "                .filter(filterSince)",
                    "                .sort((info1, info2) =>",
                    "                  semver.compare(info2.since, info1.since)",
                    "                )[0].value;",
                    "      }",
                    "",
                    "      if (Array.isArray(option.choices)) {",
                    "        option.choices = option.choices.filter(",
                    "          (option) => filterSince(option) && filterDeprecated(option)",
                    "        );",
                    "",
                    "        if (option.name === \"parser\") {",
                    "          collectParsersFromLanguages(option, languages, plugins);",
                    "        }",
                    "      }",
                    "",
                    "      const pluginDefaults = plugins",
                    "        .filter(",
                    "          (plugin) =>",
                    "            plugin.defaultOptions &&",
                    "            plugin.defaultOptions[option.name] !== undefined",
                    "        )",
                    "        .reduce((reduced, plugin) => {",
                    "          reduced[plugin.name] = plugin.defaultOptions[option.name];",
                    "          return reduced;",
                    "        }, {});",
                    "",
                    "      return { ...option, pluginDefaults };",
                    "    });",
                    "",
                    "  return { languages, options };",
                    "",
                    "  function filterSince(object) {",
                    "    return (",
                    "      showUnreleased ||",
                    "      !(\"since\" in object) ||",
                    "      (object.since && semver.gte(version, object.since))",
                    "    );",
                    "  }",
                    "",
                    "  function filterDeprecated(object) {",
                    "    return (",
                    "      showDeprecated ||",
                    "      !(\"deprecated\" in object) ||",
                    "      (object.deprecated && semver.lt(version, object.deprecated))",
                    "    );",
                    "  }",
                    "",
                    "  function mapInternal(object) {",
                    "    if (showInternal) {",
                    "      return object;",
                    "    }",
                    "    const { cliName, cliCategory, cliDescription, ...newObject } = object;",
                    "    return newObject;",
                    "  }",
                    "}",
                    "",
                    "function collectParsersFromLanguages(option, languages, plugins) {",
                    "  const existingValues = new Set(option.choices.map((choice) => choice.value));",
                    "  for (const language of languages) {",
                    "    if (language.parsers) {",
                    "      for (const value of language.parsers) {",
                    "        if (!existingValues.has(value)) {",
                    "          existingValues.add(value);",
                    "          const plugin = plugins.find(",
                    "            (plugin) => plugin.parsers && plugin.parsers[value]",
                    "          );",
                    "          let description = language.name;",
                    "          if (plugin && plugin.name) {",
                    "            description += ` (plugin: ${plugin.name})`;",
                    "          }",
                    "          option.choices.push({ value, description });",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  getSupportInfo,",
                    "};"
                ]
            }
        },
        "utils": {
            "arrayify.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = (object, keyName) =>",
                    "  Object.entries(object).map(([key, value]) => ({",
                    "    [keyName]: key,",
                    "    ...value,",
                    "  }));"
                ]
            },
            "create-language.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = function (linguistData, override) {",
                    "  const { languageId, ...rest } = linguistData;",
                    "  return {",
                    "    linguistLanguageId: languageId,",
                    "    ...rest,",
                    "    ...override(linguistData),",
                    "  };",
                    "};"
                ]
            },
            "front-matter.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const escape = require(\"escape-string-regexp\");",
                    "",
                    "const DELIMITER_MAP = {",
                    "  \"---\": \"yaml\",",
                    "  \"+++\": \"toml\",",
                    "};",
                    "",
                    "function parse(text) {",
                    "  const delimiterRegex = Object.keys(DELIMITER_MAP).map(escape).join(\"|\");",
                    "",
                    "  const match = text.match(",
                    "    // trailing spaces after delimiters are allowed",
                    "    new RegExp(",
                    "      `^(${delimiterRegex})([^\\\\n]*)\\\\n(?:([\\\\s\\\\S]*?)\\\\n)?\\\\1[^\\\\n\\\\S]*(\\\\n|$)`",
                    "    )",
                    "  );",
                    "",
                    "  if (match === null) {",
                    "    return { frontMatter: null, content: text };",
                    "  }",
                    "",
                    "  const [raw, delimiter, language, value] = match;",
                    "  let lang = DELIMITER_MAP[delimiter];",
                    "  if (lang !== \"toml\" && language && language.trim()) {",
                    "    lang = language.trim();",
                    "  }",
                    "",
                    "  return {",
                    "    frontMatter: {",
                    "      type: \"front-matter\",",
                    "      lang,",
                    "      value,",
                    "      raw: raw.replace(/\\n$/, \"\"),",
                    "    },",
                    "    content: raw.replace(/[^\\n]/g, \" \") + text.slice(raw.length),",
                    "  };",
                    "}",
                    "",
                    "module.exports = parse;"
                ]
            },
            "get-file-content-or-null.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "",
                    "/**",
                    " * @param {string} filename",
                    " * @returns {Promise<null | string>}",
                    " */",
                    "function getFileContentOrNull(filename) {",
                    "  return new Promise((resolve, reject) => {",
                    "    fs.readFile(filename, \"utf8\", (error, data) => {",
                    "      if (error && error.code !== \"ENOENT\") {",
                    "        reject(createError(filename, error));",
                    "      } else {",
                    "        resolve(error ? null : data);",
                    "      }",
                    "    });",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {string} filename",
                    " * @returns {null | string}",
                    " */",
                    "getFileContentOrNull.sync = function (filename) {",
                    "  try {",
                    "    return fs.readFileSync(filename, \"utf8\");",
                    "  } catch (error) {",
                    "    if (error && error.code === \"ENOENT\") {",
                    "      return null;",
                    "    }",
                    "    throw createError(filename, error);",
                    "  }",
                    "};",
                    "",
                    "function createError(filename, error) {",
                    "  return new Error(`Unable to read ${filename}: ${error.message}`);",
                    "}",
                    "",
                    "module.exports = getFileContentOrNull;"
                ]
            },
            "get-last.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = (arr) => arr[arr.length - 1];"
                ]
            },
            "line-column-to-index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// Super inefficient, needs to be cached.",
                    "module.exports = function (lineColumn, text) {",
                    "  let index = 0;",
                    "  for (let i = 0; i < lineColumn.line - 1; ++i) {",
                    "    index = text.indexOf(\"\\n\", index) + 1;",
                    "    if (index === -1) {",
                    "      return -1;",
                    "    }",
                    "  }",
                    "  return index + lineColumn.column;",
                    "};"
                ]
            },
            "load-toml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parse = require(\"@iarna/toml/parse-string\");",
                    "",
                    "module.exports = function (filePath, content) {",
                    "  try {",
                    "    return parse(content);",
                    "  } catch (error) {",
                    "    error.message = `TOML Error in ${filePath}:\\n${error.message}`;",
                    "    throw error;",
                    "  }",
                    "};"
                ]
            }
        }
    },
    "tests_config": {
        "require_prettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const prettierRootDir = process.env.PRETTIER_DIR || \"../\";",
                "",
                "const prettier = require(prettierRootDir);",
                "",
                "module.exports = prettier;"
            ]
        },
        "require_standalone.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const fs = require(\"fs\");",
                "const path = require(\"path\");",
                "const vm = require(\"vm\");",
                "",
                "const sources = [",
                "  \"standalone.js\",",
                "  \"parser-angular.js\",",
                "  \"parser-babel.js\",",
                "  \"parser-flow.js\",",
                "  \"parser-glimmer.js\",",
                "  \"parser-graphql.js\",",
                "  \"parser-html.js\",",
                "  \"parser-markdown.js\",",
                "  \"parser-postcss.js\",",
                "  \"parser-typescript.js\",",
                "  \"parser-yaml.js\",",
                "].map((filename) =>",
                "  fs.readFileSync(path.join(process.env.PRETTIER_DIR, filename), \"utf-8\")",
                ");",
                "",
                "const sandbox = vm.createContext();",
                "vm.runInContext(sources.join(\";\"), sandbox);",
                "",
                "// TODO: maybe expose (and write tests) for `format`, `utils`, and",
                "// `__debug` methods",
                "module.exports = {",
                "  formatWithCursor(input, options) {",
                "    return vm.runInNewContext(",
                "      `prettier.formatWithCursor(",
                "        $$$input,",
                "        Object.assign({ plugins: prettierPlugins }, $$$options)",
                "      );`,",
                "      { $$$input: input, $$$options: options, ...sandbox }",
                "    );",
                "  },",
                "",
                "  __debug: {",
                "    parse(input, options, massage) {",
                "      return vm.runInNewContext(",
                "        `prettier.__debug.parse(",
                "          $$$input,",
                "          Object.assign({ plugins: prettierPlugins }, $$$options),",
                "          ${JSON.stringify(massage)}",
                "        );`,",
                "        { $$$input: input, $$$options: options, ...sandbox }",
                "      );",
                "    },",
                "  },",
                "};"
            ]
        },
        "run_spec.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const fs = require(\"fs\");",
                "const path = require(\"path\");",
                "const { isCI } = require(\"ci-info\");",
                "const checkParsers = require(\"./utils/check-parsers\");",
                "const visualizeRange = require(\"./utils/visualize-range\");",
                "const createSnapshot = require(\"./utils/create-snapshot\");",
                "const composeOptionsForSnapshot = require(\"./utils/compose-options-for-snapshot\");",
                "const visualizeEndOfLine = require(\"./utils/visualize-end-of-line\");",
                "const consistentEndOfLine = require(\"./utils/consistent-end-of-line\");",
                "const stringifyOptionsForTitle = require(\"./utils/stringify-options-for-title\");",
                "",
                "const { TEST_STANDALONE } = process.env;",
                "const AST_COMPARE = isCI || process.env.AST_COMPARE;",
                "const DEEP_COMPARE = isCI || process.env.DEEP_COMPARE;",
                "const TEST_CRLF =",
                "  (isCI && process.platform === \"win32\") || process.env.TEST_CRLF;",
                "",
                "const CURSOR_PLACEHOLDER = \"<|>\";",
                "const RANGE_START_PLACEHOLDER = \"<<<PRETTIER_RANGE_START>>>\";",
                "const RANGE_END_PLACEHOLDER = \"<<<PRETTIER_RANGE_END>>>\";",
                "",
                "const prettier = !TEST_STANDALONE",
                "  ? require(\"prettier/local\")",
                "  : require(\"prettier/standalone\");",
                "",
                "// TODO: these test files need fix",
                "const unstableTests = new Map(",
                "  [",
                "    \"js/class-comment/misc.js\",",
                "    [\"js/comments/dangling_array.js\", (options) => options.semi === false],",
                "    [\"js/comments/jsx.js\", (options) => options.semi === false],",
                "    \"js/comments/return-statement.js\",",
                "    \"js/comments/tagged-template-literal.js\",",
                "    \"js/comments-closure-typecast/iife.js\",",
                "    \"markdown/footnoteDefinition/multiline.md\",",
                "    \"markdown/spec/example-234.md\",",
                "    \"markdown/spec/example-235.md\",",
                "    \"html/multiparser-js/script-tag-escaping.html\",",
                "    [",
                "      \"js/multiparser-markdown/codeblock.js\",",
                "      (options) => options.proseWrap === \"always\",",
                "    ],",
                "    [\"js/no-semi/comments.js\", (options) => options.semi === false],",
                "  ].map((fixture) => {",
                "    const [file, isUnstable = () => true] = Array.isArray(fixture)",
                "      ? fixture",
                "      : [fixture];",
                "    return [path.join(__dirname, \"../tests/\", file), isUnstable];",
                "  })",
                ");",
                "",
                "const isTestDirectory = (dirname, name) =>",
                "  dirname.startsWith(path.join(__dirname, \"../tests\", name));",
                "",
                "global.run_spec = (fixtures, parsers, options) => {",
                "  fixtures = typeof fixtures === \"string\" ? { dirname: fixtures } : fixtures;",
                "  const { dirname } = fixtures;",
                "",
                "  // `IS_PARSER_INFERENCE_TESTS` mean to test `inferParser` on `standalone`",
                "  const IS_PARSER_INFERENCE_TESTS = isTestDirectory(",
                "    dirname,",
                "    \"misc/parser-inference\"",
                "  );",
                "",
                "  // `IS_ERROR_TESTS` mean to watch errors like:",
                "  // - syntax parser hasn't supported yet",
                "  // - syntax errors that should throws",
                "  const IS_ERROR_TESTS = isTestDirectory(dirname, \"misc/errors\");",
                "",
                "  if (IS_PARSER_INFERENCE_TESTS) {",
                "    parsers = [];",
                "  } else if (!parsers || !parsers.length) {",
                "    throw new Error(`No parsers were specified for ${dirname}`);",
                "  }",
                "",
                "  const snippets = (fixtures.snippets || []).map((test, index) => {",
                "    test = typeof test === \"string\" ? { code: test } : test;",
                "    return {",
                "      ...test,",
                "      name: `snippet: ${test.name || `#${index}`}`,",
                "    };",
                "  });",
                "",
                "  const files = fs",
                "    .readdirSync(dirname, { withFileTypes: true })",
                "    .map((file) => {",
                "      const basename = file.name;",
                "      const filename = path.join(dirname, basename);",
                "      if (",
                "        path.extname(basename) === \".snap\" ||",
                "        !file.isFile() ||",
                "        basename[0] === \".\" ||",
                "        basename === \"jsfmt.spec.js\"",
                "      ) {",
                "        return;",
                "      }",
                "",
                "      const text = fs.readFileSync(filename, \"utf8\");",
                "",
                "      return {",
                "        name: basename,",
                "        filename,",
                "        code: text,",
                "      };",
                "    })",
                "    .filter(Boolean);",
                "",
                "  // Make sure tests are in correct location",
                "  // only runs on local and one task on CI",
                "  if (!isCI || process.env.ENABLE_CODE_COVERAGE) {",
                "    checkParsers({ dirname, files }, parsers);",
                "  }",
                "",
                "  const stringifiedOptions = stringifyOptionsForTitle(options);",
                "",
                "  for (const { name, filename, code, output } of [...files, ...snippets]) {",
                "    describe(`${name}${",
                "      stringifiedOptions ? ` - ${stringifiedOptions}` : \"\"",
                "    }`, () => {",
                "      let rangeStart;",
                "      let rangeEnd;",
                "      let cursorOffset;",
                "",
                "      const source = (TEST_CRLF ? code.replace(/\\n/g, \"\\r\\n\") : code)",
                "        .replace(RANGE_START_PLACEHOLDER, (match, offset) => {",
                "          rangeStart = offset;",
                "          return \"\";",
                "        })",
                "        .replace(RANGE_END_PLACEHOLDER, (match, offset) => {",
                "          rangeEnd = offset;",
                "          return \"\";",
                "        });",
                "",
                "      const input = source.replace(CURSOR_PLACEHOLDER, (match, offset) => {",
                "        cursorOffset = offset;",
                "        return \"\";",
                "      });",
                "",
                "      const baseOptions = {",
                "        printWidth: 80,",
                "        ...options,",
                "        rangeStart,",
                "        rangeEnd,",
                "        cursorOffset,",
                "      };",
                "      const mainOptions = {",
                "        ...baseOptions,",
                "        ...(IS_PARSER_INFERENCE_TESTS",
                "          ? { filepath: filename }",
                "          : { parser: parsers[0] }),",
                "      };",
                "",
                "      const hasEndOfLine = \"endOfLine\" in mainOptions;",
                "",
                "      if (IS_ERROR_TESTS) {",
                "        test(\"error test\", () => {",
                "          expect(() => {",
                "            format(input, filename, mainOptions);",
                "          }).toThrowErrorMatchingSnapshot();",
                "        });",
                "        return;",
                "      }",
                "",
                "      const formattedWithCursor = format(input, filename, mainOptions);",
                "      const formatted = formattedWithCursor.replace(CURSOR_PLACEHOLDER, \"\");",
                "      const visualizedOutput = visualizeEndOfLine(formattedWithCursor);",
                "",
                "      test(\"format\", () => {",
                "        expect(visualizedOutput).toEqual(",
                "          visualizeEndOfLine(consistentEndOfLine(formattedWithCursor))",
                "        );",
                "        if (typeof output === \"string\") {",
                "          expect(formatted).toEqual(output);",
                "        } else {",
                "          let codeForSnapshot = hasEndOfLine",
                "            ? code",
                "                .replace(RANGE_START_PLACEHOLDER, \"\")",
                "                .replace(RANGE_END_PLACEHOLDER, \"\")",
                "            : source;",
                "          let codeOffset = 0;",
                "",
                "          if (",
                "            typeof baseOptions.rangeStart === \"number\" ||",
                "            typeof baseOptions.rangeEnd === \"number\"",
                "          ) {",
                "            codeForSnapshot = visualizeRange(codeForSnapshot, baseOptions);",
                "            codeOffset = codeForSnapshot.match(/^>?\\s+1 \\| /)[0].length;",
                "          }",
                "",
                "          if (hasEndOfLine) {",
                "            codeForSnapshot = visualizeEndOfLine(codeForSnapshot);",
                "          }",
                "",
                "          expect(",
                "            createSnapshot(",
                "              codeForSnapshot,",
                "              hasEndOfLine ? visualizedOutput : formattedWithCursor,",
                "              composeOptionsForSnapshot(baseOptions, parsers),",
                "              { codeOffset }",
                "            )",
                "          ).toMatchSnapshot();",
                "        }",
                "      });",
                "",
                "      const parsersToVerify = parsers.slice(1);",
                "      if (parsers.includes(\"typescript\") && !parsers.includes(\"babel-ts\")) {",
                "        parsersToVerify.push(\"babel-ts\");",
                "      }",
                "",
                "      for (const parser of parsersToVerify) {",
                "        const verifyOptions = { ...baseOptions, parser };",
                "",
                "        test(`verify (${parser})`, () => {",
                "          if (",
                "            parser === \"babel-ts\" &&",
                "            options &&",
                "            (options.disableBabelTS === true ||",
                "              (Array.isArray(options.disableBabelTS) &&",
                "                options.disableBabelTS.includes(name)))",
                "          ) {",
                "            expect(() => {",
                "              format(input, filename, verifyOptions);",
                "            }).toThrow(TEST_STANDALONE ? undefined : SyntaxError);",
                "          } else {",
                "            const verifyOutput = format(input, filename, verifyOptions);",
                "            expect(visualizeEndOfLine(verifyOutput)).toEqual(visualizedOutput);",
                "          }",
                "        });",
                "      }",
                "",
                "      const isUnstable = unstableTests.get(filename);",
                "      const isUnstableTest = isUnstable && isUnstable(options || {});",
                "      if (",
                "        DEEP_COMPARE &&",
                "        (formatted !== input || isUnstableTest) &&",
                "        typeof rangeStart === \"undefined\" &&",
                "        typeof rangeEnd === \"undefined\" &&",
                "        typeof cursorOffset === \"undefined\" &&",
                "        !TEST_CRLF",
                "      ) {",
                "        test(\"second format\", () => {",
                "          const secondOutput = format(formatted, filename, mainOptions);",
                "          if (isUnstableTest) {",
                "            // To keep eye on failed tests, this assert never supposed to pass,",
                "            // if it fails, just remove the file from `unstableTests`",
                "            expect(secondOutput).not.toEqual(formatted);",
                "          } else {",
                "            expect(secondOutput).toEqual(formatted);",
                "          }",
                "        });",
                "      }",
                "",
                "      if (AST_COMPARE && formatted !== input) {",
                "        test(\"compare AST\", () => {",
                "          const { cursorOffset, ...parseOptions } = mainOptions;",
                "          const originalAst = parse(input, parseOptions);",
                "          const formattedAst = parse(formatted, parseOptions);",
                "          expect(formattedAst).toEqual(originalAst);",
                "        });",
                "      }",
                "    });",
                "  }",
                "};",
                "",
                "function parse(source, options) {",
                "  return prettier.__debug.parse(source, options, /* massage */ true).ast;",
                "}",
                "",
                "function format(source, filename, options) {",
                "  const result = prettier.formatWithCursor(source, {",
                "    filepath: filename,",
                "    ...options,",
                "  });",
                "",
                "  return options.cursorOffset >= 0",
                "    ? result.formatted.slice(0, result.cursorOffset) +",
                "        CURSOR_PLACEHOLDER +",
                "        result.formatted.slice(result.cursorOffset)",
                "    : result.formatted;",
                "}"
            ]
        },
        "utils": {
            "check-parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const { outdent } = require(\"outdent\");",
                    "",
                    "const TESTS_ROOT = path.join(__dirname, \"../../tests\");",
                    "",
                    "const getCategory = (dirname) =>",
                    "  path.relative(TESTS_ROOT, dirname).split(path.sep).shift();",
                    "",
                    "const categoryParsers = new Map([",
                    "  [",
                    "    \"angular\",",
                    "    {",
                    "      parsers: [\"angular\", \"__ng_interpolation\", \"__ng_action\"],",
                    "      verifyParsers: [],",
                    "      extensions: [\".html\", \".ng\"],",
                    "    },",
                    "  ],",
                    "  [",
                    "    \"css\",",
                    "    { parsers: [\"css\"], verifyParsers: [\"less\", \"scss\"], extensions: [\".css\"] },",
                    "  ],",
                    "  [",
                    "    \"flow\",",
                    "    {",
                    "      parsers: [\"flow\", \"babel-flow\"],",
                    "      verifyParsers: [\"babel\", \"flow\", \"babel-flow\", \"typescript\", \"babel-ts\"],",
                    "      extensions: [\".js\"],",
                    "    },",
                    "  ],",
                    "  [",
                    "    \"flow-repo\",",
                    "    {",
                    "      parsers: [\"flow\", \"babel-flow\"],",
                    "      verifyParsers: [\"babel\", \"flow\", \"babel-flow\", \"typescript\", \"babel-ts\"],",
                    "      extensions: [\".js\"],",
                    "    },",
                    "  ],",
                    "  [",
                    "    \"graphql\",",
                    "    { parsers: [\"graphql\"], verifyParsers: [], extensions: [\".graphql\"] },",
                    "  ],",
                    "  [",
                    "    \"handlebars\",",
                    "    { parsers: [\"glimmer\"], verifyParsers: [], extensions: [\".hbs\"] },",
                    "  ],",
                    "  [\"html\", { parsers: [\"html\"], verifyParsers: [], extensions: [\".html\"] }],",
                    "  [\"mjml\", { parsers: [\"html\"], verifyParsers: [], extensions: [\".mjml\"] }],",
                    "  [",
                    "    \"js\",",
                    "    {",
                    "      parsers: [\"babel\"],",
                    "      verifyParsers: [\"babel\", \"flow\", \"babel-flow\", \"typescript\", \"babel-ts\"],",
                    "      extensions: [\".js\"],",
                    "    },",
                    "  ],",
                    "  [",
                    "    \"json\",",
                    "    {",
                    "      parsers: [\"json\", \"json5\", \"json-stringify\"],",
                    "      verifyParsers: [],",
                    "      extensions: [\".json\"],",
                    "    },",
                    "  ],",
                    "  [",
                    "    \"jsx\",",
                    "    {",
                    "      parsers: [\"babel\", \"flow\", \"babel-flow\", \"typescript\", \"babel-ts\"],",
                    "      verifyParsers: [\"babel\", \"flow\", \"babel-flow\", \"typescript\", \"babel-ts\"],",
                    "      extensions: [\".js\"],",
                    "    },",
                    "  ],",
                    "  [",
                    "    \"less\",",
                    "    {",
                    "      parsers: [\"less\"],",
                    "      verifyParsers: [\"css\", \"scss\"],",
                    "      extensions: [\".less\"],",
                    "    },",
                    "  ],",
                    "  [\"lwc\", { parsers: [\"lwc\"], verifyParsers: [], extensions: [\".html\"] }],",
                    "  [",
                    "    \"markdown\",",
                    "    { parsers: [\"markdown\"], verifyParsers: [], extensions: [\".md\"] },",
                    "  ],",
                    "  [\"mdx\", { parsers: [\"mdx\"], verifyParsers: [], extensions: [\".mdx\"] }],",
                    "  [",
                    "    \"scss\",",
                    "    {",
                    "      parsers: [\"scss\"],",
                    "      verifyParsers: [\"css\", \"less\"],",
                    "      extensions: [\".scss\"],",
                    "    },",
                    "  ],",
                    "  [",
                    "    \"stylefmt-repo\",",
                    "    { parsers: [\"css\", \"scss\"], verifyParsers: [], extensions: [\".css\"] },",
                    "  ],",
                    "  [",
                    "    \"typescript\",",
                    "    {",
                    "      parsers: [\"typescript\", \"babel-ts\"],",
                    "      verifyParsers: [\"babel\", \"flow\", \"babel-flow\", \"typescript\", \"babel-ts\"],",
                    "      extensions: [\".ts\", \".tsx\"],",
                    "    },",
                    "  ],",
                    "  [",
                    "    \"vue\",",
                    "    { parsers: [\"vue\"], verifyParsers: [], extensions: [\".vue\", \".html\"] },",
                    "  ],",
                    "  [\"yaml\", { parsers: [\"yaml\"], verifyParsers: [], extensions: [\".yml\"] }],",
                    "]);",
                    "",
                    "const getParserCategories = (parser) => {",
                    "  const categories = [];",
                    "  for (const [category, { parsers }] of categoryParsers) {",
                    "    if (parsers.includes(parser)) {",
                    "      categories.push(category);",
                    "    }",
                    "  }",
                    "",
                    "  return categories;",
                    "};",
                    "",
                    "const checkParser = ({ dirname, files }, parsers = []) => {",
                    "  const category = getCategory(dirname);",
                    "  const categoryAllowedParsers = categoryParsers.get(category);",
                    "",
                    "  if (!categoryAllowedParsers) {",
                    "    return;",
                    "  }",
                    "",
                    "  const {",
                    "    parsers: allowedParsers = [],",
                    "    verifyParsers: allowedVerifyParsers = [],",
                    "    extensions = [],",
                    "  } = categoryAllowedParsers;",
                    "",
                    "  const [parser, ...verifyParsers] = parsers;",
                    "",
                    "  if (verifyParsers.includes(parser)) {",
                    "    throw new Error(",
                    "      `verifyParsers ${JSON.stringify(",
                    "        verifyParsers",
                    "      )} should not include parser \"${parser}\".`",
                    "    );",
                    "  }",
                    "",
                    "  if (allowedParsers && !allowedParsers.includes(parser)) {",
                    "    const suggestCategories = getParserCategories(parser);",
                    "",
                    "    const suggestion =",
                    "      suggestCategories.length === 0",
                    "        ? \"\"",
                    "        : outdent`",
                    "            Suggest move your tests to:",
                    "            ${suggestCategories",
                    "              .map((category) => `- ${path.join(TESTS_ROOT, category)}`)",
                    "              .join(\"\\n\")}",
                    "",
                    "            Or config to allow use this parser in \"${__filename}\".",
                    "          `;",
                    "",
                    "    throw new Error(",
                    "      `Parser \"${parser}\" should not used in \"${dirname}\".${",
                    "        suggestion ? `\\n\\n${suggestion}` : \"\"",
                    "      }`",
                    "    );",
                    "  }",
                    "",
                    "  if (allowedVerifyParsers) {",
                    "    for (const verifyParser of verifyParsers) {",
                    "      if (!allowedVerifyParsers.includes(verifyParser)) {",
                    "        throw new Error(",
                    "          outdent`",
                    "            Parser \"${verifyParser}\" should not used to verify in \"${dirname}\".",
                    "            Please remove it or config to allow use this parser in \"${__filename}\".",
                    "          `",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  for (const { name, filename } of files) {",
                    "    const ext = path.extname(filename);",
                    "    if (!extensions.includes(ext)) {",
                    "      throw new Error(",
                    "        outdent`",
                    "          File \"${name}\" should not tested in \"${dirname}\".",
                    "          Allowed extensions: ${extensions.join(\",\")}.",
                    "          Please rename it or config to allow test \"${ext}\" file in \"${__filename}\".",
                    "        `",
                    "      );",
                    "    }",
                    "  }",
                    "};",
                    "",
                    "module.exports = checkParser;"
                ]
            },
            "compose-options-for-snapshot.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function composeOptionsForSnapshot(baseOptions, parsers) {",
                    "  const {",
                    "    rangeStart,",
                    "    rangeEnd,",
                    "    cursorOffset,",
                    "    disableBabelTS,",
                    "",
                    "    ...snapshotOptions",
                    "  } = baseOptions;",
                    "",
                    "  return {",
                    "    ...snapshotOptions,",
                    "    parsers,",
                    "  };",
                    "}",
                    "",
                    "module.exports = composeOptionsForSnapshot;"
                ]
            },
            "consistent-end-of-line.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function consistentEndOfLine(text) {",
                    "  let firstEndOfLine;",
                    "  return text.replace(/\\r\\n?|\\n/g, (endOfLine) => {",
                    "    if (!firstEndOfLine) {",
                    "      firstEndOfLine = endOfLine;",
                    "    }",
                    "    return firstEndOfLine;",
                    "  });",
                    "}",
                    "",
                    "module.exports = consistentEndOfLine;"
                ]
            },
            "create-snapshot.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const raw = require(\"jest-snapshot-serializer-raw\").wrap;",
                    "",
                    "function printSeparator(width, description) {",
                    "  description = description || \"\";",
                    "  const leftLength = Math.floor((width - description.length) / 2);",
                    "  const rightLength = width - leftLength - description.length;",
                    "  return \"=\".repeat(leftLength) + description + \"=\".repeat(rightLength);",
                    "}",
                    "",
                    "function stringify(value) {",
                    "  return value === Infinity",
                    "    ? \"Infinity\"",
                    "    : Array.isArray(value)",
                    "    ? `[${value.map((v) => JSON.stringify(v)).join(\", \")}]`",
                    "    : JSON.stringify(value);",
                    "}",
                    "function printOptions(options) {",
                    "  const keys = Object.keys(options).sort();",
                    "  return keys.map((key) => `${key}: ${stringify(options[key])}`).join(\"\\n\");",
                    "}",
                    "",
                    "function createSnapshot(input, output, options, { codeOffset }) {",
                    "  const separatorWidth = 80;",
                    "  const printWidthIndicator =",
                    "    options.printWidth > 0 && Number.isFinite(options.printWidth)",
                    "      ? (codeOffset ? \" \".repeat(codeOffset - 1) + \"|\" : \"\") +",
                    "        \" \".repeat(options.printWidth) +",
                    "        \"| printWidth\"",
                    "      : [];",
                    "  return raw(",
                    "    []",
                    "      .concat(",
                    "        printSeparator(separatorWidth, \"options\"),",
                    "        printOptions(options),",
                    "        printWidthIndicator,",
                    "        printSeparator(separatorWidth, \"input\"),",
                    "        input,",
                    "        printSeparator(separatorWidth, \"output\"),",
                    "        output,",
                    "        printSeparator(separatorWidth)",
                    "      )",
                    "      .join(\"\\n\")",
                    "  );",
                    "}",
                    "",
                    "module.exports = createSnapshot;"
                ]
            },
            "stringify-options-for-title.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function stringifyOptions(options) {",
                    "  const string = JSON.stringify(options || {}, (key, value) =>",
                    "    key === \"disableBabelTS\"",
                    "      ? undefined",
                    "      : value === Infinity",
                    "      ? \"Infinity\"",
                    "      : value",
                    "  );",
                    "",
                    "  return string === \"{}\" ? \"\" : string;",
                    "}",
                    "",
                    "module.exports = stringifyOptions;"
                ]
            },
            "visualize-end-of-line.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function visualizeEndOfLine(text) {",
                    "  return text.replace(/\\r\\n?|\\n/g, (endOfLine) => {",
                    "    switch (endOfLine) {",
                    "      case \"\\n\":",
                    "        return \"<LF>\\n\";",
                    "      case \"\\r\\n\":",
                    "        return \"<CRLF>\\n\";",
                    "      case \"\\r\":",
                    "        return \"<CR>\\n\";",
                    "      default:",
                    "        throw new Error(`Unexpected end of line ${JSON.stringify(endOfLine)}`);",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "module.exports = visualizeEndOfLine;"
                ]
            },
            "visualize-range.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const LinesAndColumns = require(\"lines-and-columns\").default;",
                    "const { codeFrameColumns } = require(\"@babel/code-frame\");",
                    "const codeFrameColumnsOptions = { linesAbove: Infinity, linesBelow: Infinity };",
                    "",
                    "const locationForRange = (text, rangeStart, rangeEnd) => {",
                    "  const lines = new LinesAndColumns(text);",
                    "  const start = lines.locationForIndex(rangeStart);",
                    "  const end = lines.locationForIndex(rangeEnd);",
                    "",
                    "  start.line += 1;",
                    "  start.column += 1;",
                    "  end.line += 1;",
                    "  if (start.line === end.line) {",
                    "    end.column += 1;",
                    "  }",
                    "",
                    "  return {",
                    "    start,",
                    "    end,",
                    "  };",
                    "};",
                    "",
                    "const visualizeRange = (text, { rangeStart = 0, rangeEnd = text.length }) =>",
                    "  codeFrameColumns(",
                    "    text,",
                    "    locationForRange(text, rangeStart, rangeEnd),",
                    "    codeFrameColumnsOptions",
                    "  );",
                    "",
                    "module.exports = visualizeRange;"
                ]
            }
        }
    },
    "tests_integration": {
        "env.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const path = require(\"path\");",
                "const isProduction = process.env.NODE_ENV === \"production\";",
                "const prettierRootDir = isProduction",
                "  ? process.env.PRETTIER_DIR",
                "  : path.join(__dirname, \"..\");",
                "const { bin } = require(path.join(prettierRootDir, \"package.json\"));",
                "const prettierCli = path.join(",
                "  prettierRootDir,",
                "  typeof bin === \"object\" ? bin.prettier : bin",
                ");",
                "",
                "const thirdParty = isProduction",
                "  ? path.join(prettierRootDir, \"./third-party\")",
                "  : path.join(prettierRootDir, \"./src/common/third-party\");",
                "",
                "module.exports = {",
                "  thirdParty,",
                "  prettierCli,",
                "};"
            ]
        },
        "path-serializer.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const replaceCWD = (text) => {",
                "  const cwd = process.cwd();",
                "",
                "  const variants = /^[a-z]:\\\\/i.test(cwd)",
                "    ? [",
                "        cwd.charAt(0).toLowerCase() + cwd.slice(1),",
                "        cwd.charAt(0).toUpperCase() + cwd.slice(1),",
                "      ]",
                "    : [cwd];",
                "",
                "  for (const variant of variants) {",
                "    while (text.includes(variant)) {",
                "      text = text.replace(variant, \"<cwd>\");",
                "    }",
                "  }",
                "",
                "  return text;",
                "};",
                "",
                "module.exports = {",
                "  test: (value) =>",
                "    typeof value === \"string\" &&",
                "    (value.includes(\"\\\\\") || value.includes(process.cwd())),",
                "  print: (value, serializer) =>",
                "    serializer(replaceCWD(value).replace(/\\\\/g, \"/\")),",
                "};"
            ]
        },
        "runPrettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const fs = require(\"fs\");",
                "const path = require(\"path\");",
                "const stripAnsi = require(\"strip-ansi\");",
                "const { SynchronousPromise } = require(\"synchronous-promise\");",
                "const { prettierCli, thirdParty } = require(\"./env\");",
                "",
                "function runPrettier(dir, args, options) {",
                "  args = args || [];",
                "  options = options || {};",
                "",
                "  let status;",
                "  let stdout = \"\";",
                "  let stderr = \"\";",
                "",
                "  jest.spyOn(process, \"exit\").mockImplementation((exitCode) => {",
                "    if (status === undefined) {",
                "      status = exitCode || 0;",
                "    }",
                "  });",
                "",
                "  jest",
                "    .spyOn(process.stdout, \"write\")",
                "    .mockImplementation((text) => appendStdout(text));",
                "",
                "  jest",
                "    .spyOn(process.stderr, \"write\")",
                "    .mockImplementation((text) => appendStderr(text));",
                "",
                "  jest",
                "    .spyOn(console, \"log\")",
                "    .mockImplementation((text) => appendStdout(text + \"\\n\"));",
                "",
                "  jest",
                "    .spyOn(console, \"warn\")",
                "    .mockImplementation((text) => appendStderr(text + \"\\n\"));",
                "",
                "  jest",
                "    .spyOn(console, \"error\")",
                "    .mockImplementation((text) => appendStderr(text + \"\\n\"));",
                "",
                "  jest.spyOn(Date, \"now\").mockImplementation(() => 0);",
                "",
                "  const write = [];",
                "",
                "  jest.spyOn(fs, \"writeFileSync\").mockImplementation((filename, content) => {",
                "    write.push({ filename, content });",
                "  });",
                "",
                "  const origStatSync = fs.statSync;",
                "",
                "  jest.spyOn(fs, \"statSync\").mockImplementation((filename) => {",
                "    if (path.basename(filename) === \"virtualDirectory\") {",
                "      return origStatSync(path.join(__dirname, __filename));",
                "    }",
                "    return origStatSync(filename);",
                "  });",
                "",
                "  const originalCwd = process.cwd();",
                "  const originalArgv = process.argv;",
                "  const originalExitCode = process.exitCode;",
                "  const originalStdinIsTTY = process.stdin.isTTY;",
                "  const originalStdoutIsTTY = process.stdout.isTTY;",
                "",
                "  process.chdir(normalizeDir(dir));",
                "  process.stdin.isTTY = !!options.isTTY;",
                "  process.stdout.isTTY = !!options.stdoutIsTTY;",
                "  process.argv = [\"path/to/node\", \"path/to/prettier/bin\"].concat(args);",
                "",
                "  jest.resetModules();",
                "",
                "  // We cannot use `jest.setMock(\"get-stream\", impl)` here, because in the",
                "  // production build everything is bundled into one file so there is no",
                "  // \"get-stream\" module to mock.",
                "  jest",
                "    .spyOn(require(thirdParty), \"getStream\")",
                "    .mockImplementation(() => SynchronousPromise.resolve(options.input || \"\"));",
                "  jest",
                "    .spyOn(require(thirdParty), \"isCI\")",
                "    .mockImplementation(() => !!options.ci);",
                "  jest",
                "    .spyOn(require(thirdParty), \"cosmiconfig\")",
                "    .mockImplementation((moduleName, options) =>",
                "      require(\"cosmiconfig\").cosmiconfig(moduleName, {",
                "        ...options,",
                "        stopDir: __dirname,",
                "      })",
                "    );",
                "  jest",
                "    .spyOn(require(thirdParty), \"cosmiconfigSync\")",
                "    .mockImplementation((moduleName, options) =>",
                "      require(\"cosmiconfig\").cosmiconfigSync(moduleName, {",
                "        ...options,",
                "        stopDir: __dirname,",
                "      })",
                "    );",
                "  jest",
                "    .spyOn(require(thirdParty), \"findParentDir\")",
                "    .mockImplementation(() => process.cwd());",
                "",
                "  try {",
                "    require(prettierCli);",
                "    status = (status === undefined ? process.exitCode : status) || 0;",
                "  } catch (error) {",
                "    status = 1;",
                "    stderr += error.message;",
                "  } finally {",
                "    process.chdir(originalCwd);",
                "    process.argv = originalArgv;",
                "    process.exitCode = originalExitCode;",
                "    process.stdin.isTTY = originalStdinIsTTY;",
                "    process.stdout.isTTY = originalStdoutIsTTY;",
                "    jest.restoreAllMocks();",
                "  }",
                "",
                "  const result = { status, stdout, stderr, write };",
                "",
                "  const testResult = (testOptions) => {",
                "    testOptions = testOptions || {};",
                "",
                "    Object.keys(result).forEach((name) => {",
                "      test(`(${name})`, () => {",
                "        const value =",
                "          // \\r is trimmed from jest snapshots by default;",
                "          // manually replacing this character with /*CR*/ to test its true presence",
                "          // If ignoreLineEndings is specified, \\r is simply deleted instead",
                "          typeof result[name] === \"string\"",
                "            ? options.ignoreLineEndings",
                "              ? stripAnsi(result[name]).replace(/\\r/g, \"\")",
                "              : stripAnsi(result[name]).replace(/\\r/g, \"/*CR*/\")",
                "            : result[name];",
                "        if (name in testOptions) {",
                "          if (name === \"status\" && testOptions[name] === \"non-zero\") {",
                "            expect(value).not.toEqual(0);",
                "          } else {",
                "            expect(value).toEqual(testOptions[name]);",
                "          }",
                "        } else {",
                "          expect(value).toMatchSnapshot();",
                "        }",
                "      });",
                "    });",
                "",
                "    return result;",
                "  };",
                "",
                "  return { test: testResult, ...result };",
                "",
                "  function appendStdout(text) {",
                "    if (status === undefined) {",
                "      stdout += text;",
                "    }",
                "  }",
                "  function appendStderr(text) {",
                "    if (status === undefined) {",
                "      stderr += text;",
                "    }",
                "  }",
                "}",
                "",
                "function normalizeDir(dir) {",
                "  const isRelative = dir[0] !== \"/\";",
                "  return isRelative ? path.resolve(__dirname, dir) : dir;",
                "}",
                "",
                "module.exports = runPrettier;"
            ]
        },
        "__tests__": {
            "arg-parsing.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"boolean flags do not swallow the next argument\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"--single-quote\",",
                    "    \"file.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"negated options work\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"--no-semi\",",
                    "    \"file.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"unknown options are warned\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"file.js\",",
                    "    \"--unknown\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"unknown negated options are warned\", () => {",
                    "  runPrettier(\"cli/arg-parsing\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"file.js\",",
                    "    \"--no-unknown\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"allow overriding flags\", () => {",
                    "  runPrettier(",
                    "    \"cli/arg-parsing\",",
                    "    [\"--tab-width=1\", \"--tab-width=3\", \"--parser=babel\"],",
                    "    { input: \"function a() { b }\" }",
                    "  ).test({",
                    "    stdout: \"function a() {\\n   b;\\n}\\n\",",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "check.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"checks stdin with --check\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--check\", \"--parser\", \"babel\"], {",
                    "    input: \"0\",",
                    "  }).test({",
                    "    stdout: \"(stdin)\\n\",",
                    "    stderr: \"\",",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"checks stdin with -c (alias for --check)\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"-c\", \"--parser\", \"babel\"], {",
                    "    input: \"0\",",
                    "  }).test({",
                    "    stdout: \"(stdin)\\n\",",
                    "    stderr: \"\",",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"--checks works in CI just as in a non-TTY mode\", () => {",
                    "  const result0 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--check\", \"formatted.js\", \"unformatted.js\"],",
                    "    {",
                    "      stdoutIsTTY: true,",
                    "      ci: true,",
                    "    }",
                    "  ).test({",
                    "    status: 1,",
                    "  });",
                    "",
                    "  const result1 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--check\", \"formatted.js\", \"unformatted.js\"],",
                    "    {",
                    "      stdoutIsTTY: false,",
                    "    }",
                    "  ).test({",
                    "    status: 1,",
                    "  });",
                    "",
                    "  expect(result0.stdout).toEqual(result1.stdout);",
                    "});"
                ]
            },
            "cli.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const fs = require(\"fs\");",
                    "const { prettierCli } = require(\"../env\");",
                    "",
                    "describe(\"CLI\", () => {",
                    "  test(\"CLI should be executable.\", () => {",
                    "    expect(() => fs.accessSync(prettierCli, fs.constants.X_OK)).not.toThrow();",
                    "  });",
                    "});"
                ]
            },
            "config-invalid.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"throw error for unsupported extension\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [",
                    "    \"--config\",",
                    "    \"file/.prettierrc.unsupported\",",
                    "  ]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config format\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [\"--config\", \"file/.prettierrc\"]).test({",
                    "    status: \"non-zero\",",
                    "    stderr: expect.stringMatching(",
                    "      /Cannot (?:resolve|find) module '--invalid--' from/",
                    "    ),",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config target (directory)\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [",
                    "    \"--config\",",
                    "    \"folder/.prettierrc\", // this is a directory",
                    "  ]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config option (int)\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [\"--config\", \"option/int\"]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config option (trailingComma)\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [\"--config\", \"option/trailingComma\"]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with invalid config precedence option (configPrecedence)\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [",
                    "    \"--config-precedence\",",
                    "    \"option/configPrecedence\",",
                    "  ]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves external configuration from package.json\", () => {",
                    "  runPrettier(\"cli/config-external-config-syntax-error\", [",
                    "    \"syntax-error.js\",",
                    "  ]).test({",
                    "    status: 2,",
                    "  });",
                    "});",
                    "",
                    "// Tests below require --parser to prevent an error (no parser/filepath specified)",
                    "",
                    "describe(\"show warning with unknown option\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [",
                    "    \"--config\",",
                    "    \"option/unknown\",",
                    "    \"--parser\",",
                    "    \"babel\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"show warning with kebab-case option key\", () => {",
                    "  runPrettier(\"cli/config/invalid\", [",
                    "    \"--config\",",
                    "    \"option/kebab-case\",",
                    "    \"--parser\",",
                    "    \"babel\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "config-resolution.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const prettier = require(\"prettier/local\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"resolves configuration from external files\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--end-of-line\", \"lf\", \"**/*.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves configuration from external files and overrides by extname\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--end-of-line\", \"lf\", \"**/*.ts\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"accepts configuration from --config\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--config\", \".prettierrc\", \"./js/file.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves external configuration from package.json\", () => {",
                    "  runPrettier(\"cli/config/\", [\"external-config/index.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves configuration file with --find-config-path file\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--find-config-path\", \"no-config/file.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves json configuration file with --find-config-path file\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--find-config-path\", \"rc-json/file.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves yaml configuration file with --find-config-path file\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--find-config-path\", \"rc-yaml/file.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"resolves toml configuration file with --find-config-path file\", () => {",
                    "  runPrettier(\"cli/config/\", [\"--find-config-path\", \"rc-toml/file.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"prints nothing when no file found with --find-config-path\", () => {",
                    "  runPrettier(\"cli/config/\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"--find-config-path\",",
                    "    \"..\",",
                    "  ]).test({",
                    "    stdout: \"\",",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides take precedence\", () => {",
                    "  runPrettier(\"cli/config/\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"--print-width\",",
                    "    \"1\",",
                    "    \"**/*.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with no args\", () => {",
                    "  return prettier.resolveConfig().then((result) => {",
                    "    expect(result).toEqual({});",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with no args\", () => {",
                    "  expect(prettier.resolveConfig.sync()).toEqual({});",
                    "});",
                    "",
                    "test(\"API resolveConfig with file arg\", () => {",
                    "  const file = path.resolve(path.join(__dirname, \"../cli/config/js/file.js\"));",
                    "  return prettier.resolveConfig(file).then((result) => {",
                    "    expect(result).toMatchObject({",
                    "      tabWidth: 8,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with file arg\", () => {",
                    "  const file = path.resolve(path.join(__dirname, \"../cli/config/js/file.js\"));",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    tabWidth: 8,",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with file arg and extension override\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/no-config/file.ts\")",
                    "  );",
                    "  return prettier.resolveConfig(file).then((result) => {",
                    "    expect(result).toMatchObject({",
                    "      semi: true,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with file arg and extension override\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/no-config/file.ts\")",
                    "  );",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    semi: true,",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with file arg and .editorconfig\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/file.js\")",
                    "  );",
                    "  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {",
                    "    expect(result).toMatchObject({",
                    "      useTabs: true,",
                    "      tabWidth: 8,",
                    "      printWidth: 100,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with file arg and .editorconfig\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/file.js\")",
                    "  );",
                    "",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    semi: false,",
                    "  });",
                    "",
                    "  expect(",
                    "    prettier.resolveConfig.sync(file, { editorconfig: true })",
                    "  ).toMatchObject({",
                    "    useTabs: true,",
                    "    tabWidth: 8,",
                    "    printWidth: 100,",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with file arg and .editorconfig (key = unset)\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/tab_width=unset.js\")",
                    "  );",
                    "",
                    "  expect(",
                    "    prettier.resolveConfig.sync(file, { editorconfig: true })",
                    "  ).not.toMatchObject({ tabWidth: \"unset\" });",
                    "});",
                    "",
                    "test(\"API resolveConfig with nested file arg and .editorconfig\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/lib/file.js\")",
                    "  );",
                    "  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {",
                    "    expect(result).toMatchObject({",
                    "      useTabs: false,",
                    "      tabWidth: 2,",
                    "      printWidth: 100,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with nested file arg and .editorconfig\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/lib/file.js\")",
                    "  );",
                    "",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    semi: false,",
                    "  });",
                    "",
                    "  expect(",
                    "    prettier.resolveConfig.sync(file, { editorconfig: true })",
                    "  ).toMatchObject({",
                    "    useTabs: false,",
                    "    tabWidth: 2,",
                    "    printWidth: 100,",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig with nested file arg and .editorconfig and indent_size = tab\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/lib/indent_size=tab.js\")",
                    "  );",
                    "  return prettier.resolveConfig(file, { editorconfig: true }).then((result) => {",
                    "    expect(result).toMatchObject({",
                    "      useTabs: false,",
                    "      tabWidth: 8,",
                    "      printWidth: 100,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync with nested file arg and .editorconfig and indent_size = tab\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/editorconfig/lib/indent_size=tab.js\")",
                    "  );",
                    "",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    semi: false,",
                    "  });",
                    "",
                    "  expect(",
                    "    prettier.resolveConfig.sync(file, { editorconfig: true })",
                    "  ).toMatchObject({",
                    "    useTabs: false,",
                    "    tabWidth: 8,",
                    "    printWidth: 100,",
                    "  });",
                    "});",
                    "",
                    "test(\"API clearConfigCache\", () => {",
                    "  expect(() => prettier.clearConfigCache()).not.toThrowError();",
                    "});",
                    "",
                    "test(\"API resolveConfig overrides work with dotfiles\", () => {",
                    "  const folder = path.join(__dirname, \"../cli/config/dot-overrides\");",
                    "  return expect(",
                    "    prettier.resolveConfig(path.join(folder, \".foo.json\"))",
                    "  ).resolves.toMatchObject({",
                    "    tabWidth: 4,",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync overrides work with absolute paths\", () => {",
                    "  // Absolute path",
                    "  const file = path.join(__dirname, \"../cli/config/filepath/subfolder/file.js\");",
                    "  expect(prettier.resolveConfig.sync(file)).toMatchObject({",
                    "    tabWidth: 6,",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig removes $schema option\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/$schema/index.js\")",
                    "  );",
                    "  return prettier.resolveConfig(file).then((result) => {",
                    "    expect(result).toEqual({",
                    "      tabWidth: 42,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig.sync removes $schema option\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/config/$schema/index.js\")",
                    "  );",
                    "  expect(prettier.resolveConfig.sync(file)).toEqual({",
                    "    tabWidth: 42,",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig resolves relative path values based on config filepath\", () => {",
                    "  const currentDir = path.join(__dirname, \"../cli/config/resolve-relative\");",
                    "  const parentDir = path.resolve(currentDir, \"..\");",
                    "  expect(prettier.resolveConfig.sync(`${currentDir}/index.js`)).toMatchObject({",
                    "    plugins: [path.join(parentDir, \"path-to-plugin\")],",
                    "    pluginSearchDirs: [path.join(parentDir, \"path-to-plugin-search-dir\")],",
                    "  });",
                    "});",
                    "",
                    "test(\"API resolveConfig de-references to an external module\", () => {",
                    "  const currentDir = path.join(__dirname, \"../cli/config/external-config\");",
                    "  expect(prettier.resolveConfig.sync(`${currentDir}/index.js`)).toEqual({",
                    "    printWidth: 77,",
                    "    semi: false,",
                    "  });",
                    "});"
                ]
            },
            "cursor-offset.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"write cursorOffset to stderr with --cursor-offset <int>\", () => {",
                    "  runPrettier(\"cli\", [\"--cursor-offset\", \"2\", \"--parser\", \"babel\"], {",
                    "    input: \" 1\",",
                    "  }).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"cursorOffset should not be affected by full-width character\", () => {",
                    "  runPrettier(\"cli\", [\"--cursor-offset\", \"21\", \"--parser\", \"babel\"], {",
                    "    input:",
                    "      'const x = [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"];',",
                    "    //                              ^ offset = 21                              ^ width = 80",
                    "  }).test({",
                    "    /**",
                    "     * const x = [",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *        ^ offset = 26",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\",",
                    "     *   \"\"",
                    "     * ];",
                    "     */",
                    "    stderr: \"26\\n\",",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "debug-check.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"doesn't crash when --debug-check is passed\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"issue1890.js\", \"--debug-check\"]).test({",
                    "    stdout: \"issue1890.js\\n\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"checks stdin with --debug-check\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--debug-check\", \"--parser\", \"babel\"], {",
                    "    input: \"0\",",
                    "  }).test({",
                    "    stdout: \"(stdin)\\n\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"show diff for 2+ error files with --debug-check\", () => {",
                    "  runPrettier(\"cli/debug-check\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"*.debug-check\",",
                    "    \"--debug-check\",",
                    "    \"--plugin\",",
                    "    \"./plugin-for-testing-debug-check\",",
                    "  ]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"should not exit non-zero for already prettified code with --debug-check + --check\", () => {",
                    "  runPrettier(\"cli/debug-check\", [",
                    "    \"issue-4599.js\",",
                    "    \"--debug-check\",",
                    "    \"--check\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"should not exit non-zero for already prettified code with --debug-check + --list-different\", () => {",
                    "  runPrettier(\"cli/debug-check\", [",
                    "    \"issue-4599.js\",",
                    "    \"--debug-check\",",
                    "    \"--list-different\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "debug-print-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"prints doc with --debug-print-doc\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--debug-print-doc\", \"--parser\", \"babel\"], {",
                    "    input: \"0\",",
                    "  }).test({",
                    "    stdout: '[\"0\", \";\", hardline, breakParent];\\n',",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "doc-mark-as-root.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const docPrinter = prettier.doc.printer;",
                    "const docBuilders = prettier.doc.builders;",
                    "",
                    "const { printDocToString } = docPrinter;",
                    "const { concat, hardline, literalline, trim, indent, markAsRoot } = docBuilders;",
                    "",
                    "describe(\"markAsRoot\", () => {",
                    "  test.each([",
                    "    [",
                    "      \"with hardline will insert a newline with current indentation\",",
                    "      concat([indent(markAsRoot(indent(hardline))), \"123\"]),",
                    "      \"\\n    123\",",
                    "    ],",
                    "    [",
                    "      \"with literalline will insert a newline with root indentation\",",
                    "      concat([indent(markAsRoot(indent(literalline))), \"123\"]),",
                    "      \"\\n  123\",",
                    "    ],",
                    "    [",
                    "      \"followed by trim will trims up to the the first column, ignoring indented root\",",
                    "      concat([indent(markAsRoot(indent(literalline))), trim, \"123\"]),",
                    "      \"\\n123\",",
                    "    ],",
                    "  ])(\"%s\", (_, doc, expected) => {",
                    "    const result = printDocToString(doc, { printWidth: 80, tabWidth: 2 });",
                    "",
                    "    expect(result).toBeDefined();",
                    "    expect(result.formatted).toEqual(expected);",
                    "  });",
                    "});"
                ]
            },
            "doc-trim.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const docPrinter = prettier.doc.printer;",
                    "const docBuilders = prettier.doc.builders;",
                    "",
                    "const { printDocToString } = docPrinter;",
                    "const { concat, line, trim, group, indent } = docBuilders;",
                    "",
                    "// These tests don't use `runPrettier` because `trim` is not used by any",
                    "// bundled parser (only third-party plugins).",
                    "",
                    "describe(\"trim\", () => {",
                    "  test.each([",
                    "    [\"trims the current line\", group(concat([\"hello    \", trim])), \"hello\"],",
                    "    [",
                    "      \"trims existing indentation\",",
                    "      group(",
                    "        concat([",
                    "          \"function()\",",
                    "          line,",
                    "          \"{\",",
                    "          indent(",
                    "            concat([",
                    "              line,",
                    "              group(concat([trim, \"#if DEBUG\"])),",
                    "              line,",
                    "              \"alert(42);\",",
                    "              line,",
                    "              group(concat([trim, \"#endif\"])),",
                    "            ])",
                    "          ),",
                    "          line,",
                    "          \"}\",",
                    "        ])",
                    "      ),",
                    "      `function()",
                    "{",
                    "#if DEBUG",
                    "  alert(42);",
                    "#endif",
                    "}`,",
                    "    ],",
                    "    [",
                    "      \"ignores trimmed characters when fitting the line\",",
                    "      group(concat([\"hello  \", \"  \", trim, line, \"world!\"])),",
                    "      \"hello world!\",",
                    "    ],",
                    "  ])(\"%s\", (_, doc, expected) => {",
                    "    const result = printDocToString(doc, { printWidth: 12, tabWidth: 2 });",
                    "",
                    "    expect(result).toBeDefined();",
                    "    expect(result.formatted).toEqual(expected);",
                    "  });",
                    "});"
                ]
            },
            "early-exit.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"show version with --version\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--version\"]).test({",
                    "    stdout: prettier.version + \"\\n\",",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"show usage with --help\", () => {",
                    "  runPrettier(\"cli\", [\"--help\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"show detailed usage with --help l (alias)\", () => {",
                    "  runPrettier(\"cli\", [\"--help\", \"l\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"show detailed usage with plugin options (automatic resolution)\", () => {",
                    "  runPrettier(\"plugins/automatic\", [",
                    "    \"--help\",",
                    "    \"tab-width\",",
                    "    \"--parser=bar\",",
                    "    \"--plugin-search-dir=.\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"show detailed usage with plugin options (manual resolution)\", () => {",
                    "  runPrettier(\"cli\", [",
                    "    \"--help\",",
                    "    \"tab-width\",",
                    "    \"--plugin=../plugins/automatic/node_modules/prettier-plugin-bar\",",
                    "    \"--parser=bar\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with --help not-found\", () => {",
                    "  runPrettier(\"cli\", [\"--help\", \"not-found\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"show warning with --help not-found (typo)\", () => {",
                    "  runPrettier(\"cli\", [",
                    "    \"--help\",",
                    "    // cspell:disable-next-line",
                    "    \"parserr\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with --check + --list-different\", () => {",
                    "  runPrettier(\"cli\", [\"--check\", \"--list-different\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with --write + --debug-check\", () => {",
                    "  runPrettier(\"cli\", [\"--write\", \"--debug-check\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with --find-config-path + multiple files\", () => {",
                    "  runPrettier(\"cli\", [\"--find-config-path\", \"abc.js\", \"def.js\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error with --file-info + multiple files\", () => {",
                    "  runPrettier(\"cli\", [\"--file-info\", \"abc.js\", \"def.js\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error and show usage with something unexpected\", () => {",
                    "  runPrettier(\"cli\", [], { isTTY: true }).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"node version error\", () => {",
                    "  const originalProcessVersion = process.version;",
                    "  try {",
                    "    Object.defineProperty(process, \"version\", {",
                    "      value: \"v8.0.0\",",
                    "      writable: false,",
                    "    });",
                    "    runPrettier(\"cli\", [\"--help\"]).test({ status: 1 });",
                    "  } finally {",
                    "    Object.defineProperty(process, \"version\", {",
                    "      value: originalProcessVersion,",
                    "      writable: false,",
                    "    });",
                    "  }",
                    "});"
                ]
            },
            "file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const tempy = require(\"tempy\");",
                    "const fs = require(\"fs\");",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const prettier = require(\"prettier/local\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"extracts file-info for a js file\", () => {",
                    "  runPrettier(\"cli/\", [\"--file-info\", \"something.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info for a markdown file\", () => {",
                    "  runPrettier(\"cli/\", [\"--file-info\", \"README.md\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info for a known markdown file with no extension\", () => {",
                    "  runPrettier(\"cli/\", [\"--file-info\", \"README\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info with ignored=true for a file in .prettierignore\", () => {",
                    "  runPrettier(\"cli/ignore-path/\", [\"--file-info\", \"regular-module.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info with ignored=true for a file in a hand-picked .prettierignore\", () => {",
                    "  runPrettier(\"cli/\", [",
                    "    \"--file-info\",",
                    "    \"regular-module.js\",",
                    "    \"--ignore-path=ignore-path/.prettierignore\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info for a file in not_node_modules\", () => {",
                    "  runPrettier(\"cli/with-node-modules/\", [",
                    "    \"--file-info\",",
                    "    \"not_node_modules/file.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info with with ignored=true for a file in node_modules\", () => {",
                    "  runPrettier(\"cli/with-node-modules/\", [",
                    "    \"--file-info\",",
                    "    \"node_modules/file.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info with ignored=false for a file in node_modules when --with-node-modules provided\", () => {",
                    "  runPrettier(\"cli/with-node-modules/\", [",
                    "    \"--file-info\",",
                    "    \"node_modules/file.js\",",
                    "    \"--with-node-modules\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info with inferredParser=null for file.foo\", () => {",
                    "  runPrettier(\"cli/\", [\"--file-info\", \"file.foo\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info with inferredParser=foo when plugins are autoloaded\", () => {",
                    "  runPrettier(\"plugins/automatic/\", [\"--file-info\", \"file.foo\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info with inferredParser=foo when plugins are loaded with --plugin-search-dir\", () => {",
                    "  runPrettier(\"cli/\", [",
                    "    \"--file-info\",",
                    "    \"file.foo\",",
                    "    \"--plugin-search-dir\",",
                    "    \"../plugins/automatic\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info with inferredParser=foo when a plugin is hand-picked\", () => {",
                    "  runPrettier(\"cli/\", [",
                    "    \"--file-info\",",
                    "    \"file.foo\",",
                    "    \"--plugin\",",
                    "    \"../plugins/automatic/node_modules/@prettier/plugin-foo\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo with no args\", () => {",
                    "  return expect(prettier.getFileInfo()).rejects.toThrow(",
                    "    new TypeError(\"expect `filePath` to be a string, got `undefined`\")",
                    "  );",
                    "});",
                    "",
                    "test(\"API getFileInfo.sync with no args\", () => {",
                    "  expect(() => prettier.getFileInfo.sync()).toThrow(",
                    "    new TypeError(\"expect `filePath` to be a string, got `undefined`\")",
                    "  );",
                    "});",
                    "",
                    "test(\"API getFileInfo with filepath only\", () => {",
                    "  expect(prettier.getFileInfo(\"README\")).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"markdown\",",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo.sync with filepath only\", () => {",
                    "  expect(prettier.getFileInfo.sync(\"README\")).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"markdown\",",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo with resolveConfig\", () => {",
                    "  const file1 = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-resolve-config/file.foo\")",
                    "  );",
                    "  const file2 = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-resolve-config/file.bar\")",
                    "  );",
                    "",
                    "  expect(prettier.getFileInfo(file1)).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(prettier.getFileInfo(file2)).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo(file1, {",
                    "      resolveConfig: true,",
                    "    })",
                    "  ).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"json\",",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo(file2, {",
                    "      resolveConfig: true,",
                    "    })",
                    "  ).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo with resolveConfig when no config is present\", () => {",
                    "  const file1 = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-resolve-config-no-config/file.foo\")",
                    "  );",
                    "  const file2 = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-resolve-config-no-config/file.bar\")",
                    "  );",
                    "",
                    "  expect(prettier.getFileInfo(file1)).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(prettier.getFileInfo(file2)).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo(file1, {",
                    "      resolveConfig: true,",
                    "    })",
                    "  ).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo(file2, {",
                    "      resolveConfig: true,",
                    "    })",
                    "  ).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo.sync with resolveConfig\", () => {",
                    "  const file1 = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-resolve-config/file.foo\")",
                    "  );",
                    "  const file2 = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-resolve-config/file.bar\")",
                    "  );",
                    "",
                    "  expect(prettier.getFileInfo.sync(file1)).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(prettier.getFileInfo.sync(file2)).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo.sync(file1, {",
                    "      resolveConfig: true,",
                    "    })",
                    "  ).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"json\",",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo.sync(file2, {",
                    "      resolveConfig: true,",
                    "    })",
                    "  ).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo.sync with resolveConfig when no config is present\", () => {",
                    "  const file1 = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-resolve-config-no-config/file.foo\")",
                    "  );",
                    "  const file2 = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-resolve-config-no-config/file.bar\")",
                    "  );",
                    "",
                    "  expect(prettier.getFileInfo.sync(file1)).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(prettier.getFileInfo.sync(file2)).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo.sync(file1, {",
                    "      resolveConfig: true,",
                    "    })",
                    "  ).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo.sync(file2, {",
                    "      resolveConfig: true,",
                    "    })",
                    "  ).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo with ignorePath\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/ignore-path/regular-module.js\")",
                    "  );",
                    "  const ignorePath = path.resolve(",
                    "    path.join(__dirname, \"../cli/ignore-path/.prettierignore\")",
                    "  );",
                    "",
                    "  expect(prettier.getFileInfo(file)).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "",
                    "  expect(",
                    "    prettier.getFileInfo(file, {",
                    "      ignorePath,",
                    "    })",
                    "  ).resolves.toMatchObject({",
                    "    ignored: true,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo.sync with ignorePath\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/ignore-path/regular-module.js\")",
                    "  );",
                    "  const ignorePath = path.resolve(",
                    "    path.join(__dirname, \"../cli/ignore-path/.prettierignore\")",
                    "  );",
                    "",
                    "  expect(prettier.getFileInfo.sync(file)).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "",
                    "  expect(",
                    "    prettier.getFileInfo.sync(file, {",
                    "      ignorePath,",
                    "    })",
                    "  ).toMatchObject({",
                    "    ignored: true,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"API getFileInfo.sync with ignorePath\", () => {",
                    "  let cwd;",
                    "  let filePath;",
                    "  let options;",
                    "  beforeAll(() => {",
                    "    cwd = process.cwd();",
                    "    const tempDir = tempy.directory();",
                    "    process.chdir(tempDir);",
                    "    const fileDir = \"src\";",
                    "    filePath = `${fileDir}/should-be-ignored.js`;",
                    "    const ignorePath = path.join(tempDir, \".prettierignore\");",
                    "    fs.writeFileSync(ignorePath, filePath, \"utf8\");",
                    "    options = { ignorePath };",
                    "  });",
                    "  afterAll(() => {",
                    "    process.chdir(cwd);",
                    "  });",
                    "  test(\"with relative filePath\", () => {",
                    "    expect(",
                    "      prettier.getFileInfo.sync(filePath, options).ignored",
                    "    ).toMatchInlineSnapshot(\"true\");",
                    "  });",
                    "  test(\"with relative filePath starts with dot\", () => {",
                    "    expect(",
                    "      prettier.getFileInfo.sync(`./${filePath}`, options).ignored",
                    "    ).toMatchInlineSnapshot(\"true\");",
                    "  });",
                    "  test(\"with absolute filePath\", () => {",
                    "    expect(",
                    "      prettier.getFileInfo.sync(path.resolve(filePath), options).ignored",
                    "    ).toMatchInlineSnapshot(\"true\");",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo with withNodeModules\", () => {",
                    "  const file = path.resolve(",
                    "    path.join(__dirname, \"../cli/with-node-modules/node_modules/file.js\")",
                    "  );",
                    "  expect(prettier.getFileInfo(file)).resolves.toMatchObject({",
                    "    ignored: true,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo(file, {",
                    "      withNodeModules: true,",
                    "    })",
                    "  ).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info for a JS file with no extension but a standard shebang\", () => {",
                    "  expect(",
                    "    prettier.getFileInfo.sync(\"tests_integration/cli/shebang/node-shebang\")",
                    "  ).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"extracts file-info for a JS file with no extension but an env-based shebang\", () => {",
                    "  expect(",
                    "    prettier.getFileInfo.sync(\"tests_integration/cli/shebang/env-node-shebang\")",
                    "  ).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"babel\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"returns null parser for unknown shebang\", () => {",
                    "  expect(",
                    "    prettier.getFileInfo.sync(\"tests_integration/cli/shebang/nonsense-shebang\")",
                    "  ).toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo with plugins loaded using pluginSearchDir\", () => {",
                    "  const file = \"file.foo\";",
                    "  const pluginsPath = path.resolve(",
                    "    path.join(__dirname, \"../plugins/automatic\")",
                    "  );",
                    "  expect(prettier.getFileInfo(file)).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo(file, {",
                    "      pluginSearchDirs: [pluginsPath],",
                    "    })",
                    "  ).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"foo\",",
                    "  });",
                    "});",
                    "",
                    "test(\"API getFileInfo with hand-picked plugins\", () => {",
                    "  const file = \"file.foo\";",
                    "  const pluginPath = path.resolve(",
                    "    path.join(",
                    "      __dirname,",
                    "      \"../plugins/automatic/node_modules/@prettier/plugin-foo\"",
                    "    )",
                    "  );",
                    "  expect(prettier.getFileInfo(file)).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: null,",
                    "  });",
                    "  expect(",
                    "    prettier.getFileInfo(file, {",
                    "      plugins: [pluginPath],",
                    "    })",
                    "  ).resolves.toMatchObject({",
                    "    ignored: false,",
                    "    inferredParser: \"foo\",",
                    "  });",
                    "});"
                ]
            },
            "format.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const fooPlugin = require(\"../plugins/defaultOptions/plugin\");",
                    "",
                    "test(\"yaml parser should handle CRLF correctly\", () => {",
                    "  const input = \"a:\\r\\n  123\\r\\n\";",
                    "  expect(",
                    "    // use JSON.stringify to observe CRLF",
                    "    JSON.stringify(",
                    "      prettier.format(input, { parser: \"yaml\", endOfLine: \"auto\" })",
                    "    )",
                    "  ).toMatchSnapshot();",
                    "});",
                    "",
                    "test(\"typescript parser should throw the first error when both JSX and non-JSX mode failed\", () => {",
                    "  const input = `",
                    "import React from \"react\";",
                    "",
                    "const App = () => (",
                    "  <div className=\"App\">",
                    "  </div>",
                    ");",
                    "",
                    "label:",
                    "  `;",
                    "  expect(() =>",
                    "    prettier.format(input, { parser: \"typescript\" })",
                    "  ).toThrowErrorMatchingSnapshot();",
                    "});",
                    "",
                    "test(\"html parser should handle CRLF correctly\", () => {",
                    "  const input = \"<!--\\r\\n  test\\r\\n  test\\r\\n-->\";",
                    "  expect(",
                    "    // use JSON.stringify to observe CRLF",
                    "    JSON.stringify(",
                    "      prettier.format(input, { parser: \"html\", endOfLine: \"auto\" })",
                    "    )",
                    "  ).toMatchSnapshot();",
                    "});",
                    "",
                    "test(\"markdown parser should handle CRLF correctly\", () => {",
                    "  const input = \"```\\r\\n\\r\\n\\r\\n```\";",
                    "  expect(",
                    "    // use JSON.stringify to observe CRLF",
                    "    JSON.stringify(",
                    "      prettier.format(input, { parser: \"markdown\", endOfLine: \"auto\" })",
                    "    )",
                    "  ).toMatchSnapshot();",
                    "});",
                    "",
                    "test(\"should work with foo plugin instance\", () => {",
                    "  const input = \"a:\\r\\n  123\\r\\n\";",
                    "  expect(",
                    "    JSON.stringify(",
                    "      prettier.format(input, { parser: \"foo-parser\", plugins: [fooPlugin] })",
                    "    )",
                    "  ).toMatchInlineSnapshot(",
                    "    '\"\\\\\"{\\\\\\\\\\\\\"tabWidth\\\\\\\\\\\\\":8,\\\\\\\\\\\\\"bracketSpacing\\\\\\\\\\\\\":false}\\\\\"\"'",
                    "  );",
                    "});",
                    "",
                    "test(\"'Adjacent JSX' error should not be swallowed by Babel's error recovery\", () => {",
                    "  const input = \"<a></a>\\n<b></b>\";",
                    "  expect(() =>",
                    "    prettier.format(input, { parser: \"babel\" })",
                    "  ).toThrowErrorMatchingSnapshot();",
                    "});"
                ]
            },
            "help-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const constant = require(\"../../src/cli/constant\");",
                    "const util = require(\"../../src/cli/util\");",
                    "const arrayify = require(\"../../src/utils/arrayify\");",
                    "",
                    "arrayify(",
                    "  {",
                    "    ...util.createDetailedOptionMap(",
                    "      prettier.getSupportInfo({",
                    "        showDeprecated: true,",
                    "        showUnreleased: true,",
                    "        showInternal: true,",
                    "      }).options",
                    "    ),",
                    "    ...util.normalizeDetailedOptionMap(constant.options),",
                    "  },",
                    "  \"name\"",
                    ").forEach((option) => {",
                    "  const optionNames = [",
                    "    option.description ? option.name : null,",
                    "    option.oppositeDescription ? `no-${option.name}` : null,",
                    "  ].filter(Boolean);",
                    "",
                    "  optionNames.forEach((optionName) => {",
                    "    describe(`show detailed usage with --help ${optionName}`, () => {",
                    "      runPrettier(\"cli\", [\"--help\", optionName]).test({",
                    "        status: 0,",
                    "      });",
                    "    });",
                    "  });",
                    "});"
                ]
            },
            "ignore-absolute-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"support absolute filename\", () => {",
                    "  runPrettier(\"cli/ignore-absolute-path\", [",
                    "    path.resolve(__dirname, \"../cli/ignore-absolute-path/ignored/module.js\"),",
                    "    path.resolve(__dirname, \"../cli/ignore-absolute-path/depth1/ignored/*.js\"),",
                    "    path.resolve(__dirname, \"../cli/ignore-absolute-path/regular-module.js\"),",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});"
                ]
            },
            "ignore-emoji.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"ignores file name contains emoji\", () => {",
                    "  runPrettier(\"cli/ignore-emoji\", [\"**/*.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"stdin\", () => {",
                    "  runPrettier(",
                    "    \"cli/ignore-emoji\",",
                    "    [\"--stdin-filepath\", \"ignored/.css\"],",
                    "    { input: \".name {                         display: none; }\" }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "ignore-in-subdirectories.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"ignores files when executing in a subdirectory\", () => {",
                    "  runPrettier(\"cli/ignore-in-subdirectories/web1\", [",
                    "    \"ignore-me/should-ignore.js\",",
                    "    \"--ignore-path\",",
                    "    \"../.prettierignore\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  runPrettier(\"cli/ignore-in-subdirectories/web1\", [",
                    "    \"ignore-me/subdirectory/should-ignore.js\",",
                    "    \"--ignore-path\",",
                    "    \"../.prettierignore\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"formats files when executing in a subdirectory\", () => {",
                    "  runPrettier(\"cli/ignore-in-subdirectories/web1\", [",
                    "    \"should-not-ignore.js\",",
                    "    \"--ignore-path\",",
                    "    \"../.prettierignore\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "",
                    "  runPrettier(\"cli/ignore-in-subdirectories/web2\", [",
                    "    \"should-not-ignore.js\",",
                    "    \"--ignore-path\",",
                    "    \"../.prettierignore\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"ignore files when executing in a subdirectory and using stdin\", () => {",
                    "  runPrettier(",
                    "    \"cli/ignore-in-subdirectories/web1\",",
                    "    [",
                    "      \"--ignore-path\",",
                    "      \"../.prettierignore\",",
                    "      \"--stdin-filepath\",",
                    "      \"ignore-me/example.js\",",
                    "    ],",
                    "    {",
                    "      input: \"hello_world( );\",",
                    "    }",
                    "  ).test({",
                    "    stdout: \"hello_world( );\",",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"formats files when executing in a subdirectory and using stdin\", () => {",
                    "  runPrettier(",
                    "    \"cli/ignore-in-subdirectories/web1\",",
                    "    [\"--ignore-path\", \"../.prettierignore\", \"--stdin-filepath\", \"example.js\"],",
                    "    {",
                    "      input: \"hello_world( );\",",
                    "    }",
                    "  ).test({",
                    "    stdout: `hello_world();",
                    "`,",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "ignore-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"ignore path\", () => {",
                    "  runPrettier(\"cli/ignore-path\", [",
                    "    \"**/*.js\",",
                    "    \"--ignore-path\",",
                    "    \".gitignore\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"support .prettierignore\", () => {",
                    "  runPrettier(\"cli/ignore-path\", [\"**/*.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"ignore file when using --debug-check\", () => {",
                    "  runPrettier(\"cli/ignore-path\", [\"**/*.js\", \"--debug-check\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"outputs files as-is if no --write\", () => {",
                    "  runPrettier(\"cli/ignore-path\", [\"regular-module.js\"], {",
                    "    ignoreLineEndings: true,",
                    "  }).test({",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "ignore-relative-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"support relative paths\", () => {",
                    "  runPrettier(\"cli/ignore-relative-path\", [",
                    "    \"./shouldNotBeIgnored.js\",",
                    "    \"./level1/level2/level3/shouldNotBeFormat.js\",",
                    "    \"level1-glob/level2-glob/level3-glob/shouldNotBeFormat.js\",",
                    "    \"./level1-glob/level2-glob/level3-glob/shouldNotBeIgnored.scss\",",
                    "    \"level1-glob/shouldNotBeIgnored.js\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});"
                ]
            },
            "ignore-vcs-files.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"ignores files in version control systems\", () => {",
                    "  runPrettier(\"cli/ignore-vcs-files\", [",
                    "    \".svn/file.js\",",
                    "    \".hg/file.js\",",
                    "    \"file.js\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});"
                ]
            },
            "infer-parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const prettier = require(\"prettier/local\");",
                    "",
                    "describe(\"stdin no path and no parser\", () => {",
                    "  describe(\"logs error and exits with 2\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [], { input: \"foo\" }).test({",
                    "      status: 2,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"--check logs error but exits with 0\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--check\"], {",
                    "      input: \"foo\",",
                    "    }).test({",
                    "      status: 0,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"--list-different logs error but exits with 0\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--list-different\"], {",
                    "      input: \"foo\",",
                    "    }).test({",
                    "      status: 0,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "describe(\"stdin with unknown path and no parser\", () => {",
                    "  describe(\"logs error and exits with 2\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--stdin-filepath\", \"foo\"], {",
                    "      input: \"foo\",",
                    "    }).test({",
                    "      status: 2,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"--check logs error but exits with 0\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--check\", \"--stdin-filepath\", \"foo\"], {",
                    "      input: \"foo\",",
                    "    }).test({",
                    "      status: 0,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"--list-different logs error but exits with 0\", () => {",
                    "    runPrettier(",
                    "      \"cli/infer-parser/\",",
                    "      [\"--list-different\", \"--stdin-filepath\", \"foo\"],",
                    "      { input: \"foo\" }",
                    "    ).test({",
                    "      status: 0,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "describe(\"unknown path and no parser\", () => {",
                    "  describe(\"specific file\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--end-of-line\", \"lf\", \"FOO\"]).test({",
                    "      status: 2,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"multiple files\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--end-of-line\", \"lf\", \"*\"]).test({",
                    "      status: 2,",
                    "      write: [],",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "describe(\"--check with unknown path and no parser\", () => {",
                    "  describe(\"specific file\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--check\", \"FOO\"]).test({",
                    "      status: 0,",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"multiple files\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--check\", \"*\"]).test({",
                    "      status: 1,",
                    "      write: [],",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "describe(\"--list-different with unknown path and no parser\", () => {",
                    "  describe(\"specific file\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--list-different\", \"FOO\"]).test({",
                    "      status: 0,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"multiple files\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--list-different\", \"*\"]).test({",
                    "      status: 1,",
                    "      stdout: \"foo.js\\n\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "describe(\"--write with unknown path and no parser\", () => {",
                    "  describe(\"specific file\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--write\", \"FOO\"]).test({",
                    "      status: 2,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"multiple files\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--write\", \"*\"]).test({",
                    "      status: 2,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "describe(\"--write and --check with unknown path and no parser\", () => {",
                    "  describe(\"specific file\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--check\", \"--write\", \"FOO\"]).test({",
                    "      status: 0,",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"multiple files\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [\"--check\", \"--write\", \"*\"]).test({",
                    "      status: 0,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "describe(\"--write and --list-different with unknown path and no parser\", () => {",
                    "  describe(\"specific file\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [",
                    "      \"--list-different\",",
                    "      \"--write\",",
                    "      \"FOO\",",
                    "    ]).test({",
                    "      status: 0,",
                    "      stdout: \"\",",
                    "      write: [],",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"multiple files\", () => {",
                    "    runPrettier(\"cli/infer-parser/\", [",
                    "      \"--list-different\",",
                    "      \"--write\",",
                    "      \"*\",",
                    "    ]).test({ status: 0 });",
                    "  });",
                    "});",
                    "",
                    "describe(\"API with no path and no parser\", () => {",
                    "  const _console = global.console;",
                    "",
                    "  beforeEach(() => {",
                    "    global.console = { warn: jest.fn() };",
                    "  });",
                    "",
                    "  afterEach(() => {",
                    "    global.console = _console;",
                    "  });",
                    "",
                    "  test(\"prettier.format\", () => {",
                    "    expect(prettier.format(\" foo  (  )\")).toEqual(\"foo();\\n\");",
                    "    expect(global.console.warn).toHaveBeenCalledTimes(1);",
                    "    expect(global.console.warn.mock.calls[0]).toMatchSnapshot();",
                    "  });",
                    "",
                    "  test(\"prettier.check\", () => {",
                    "    expect(prettier.check(\" foo (  )\")).toBe(false);",
                    "    expect(global.console.warn).toHaveBeenCalledTimes(1);",
                    "    expect(global.console.warn.mock.calls[0]).toMatchSnapshot();",
                    "  });",
                    "});"
                ]
            },
            "invalid-ignore.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"throw error with invalid ignore\", () => {",
                    "  runPrettier(\"cli/invalid-ignore\", [\"something.js\"]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});"
                ]
            },
            "list-different.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"checks stdin with --list-different\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--list-different\", \"--parser\", \"babel\"], {",
                    "    input: \"0\",",
                    "  }).test({",
                    "    stdout: \"(stdin)\\n\",",
                    "    stderr: \"\",",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"checks stdin with -l (alias for --list-different)\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"-l\", \"--parser\", \"babel\"], {",
                    "    input: \"0\",",
                    "  }).test({",
                    "    stdout: \"(stdin)\\n\",",
                    "    stderr: \"\",",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"--list-different works in CI just as in a non-TTY mode\", () => {",
                    "  const result0 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--list-different\", \"formatted.js\", \"unformatted.js\"],",
                    "    {",
                    "      stdoutIsTTY: true,",
                    "      ci: true,",
                    "    }",
                    "  ).test({",
                    "    status: 1,",
                    "  });",
                    "",
                    "  const result1 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--list-different\", \"formatted.js\", \"unformatted.js\"],",
                    "    {",
                    "      stdoutIsTTY: false,",
                    "    }",
                    "  ).test({",
                    "    status: 1,",
                    "  });",
                    "",
                    "  expect(result0.stdout).toEqual(result1.stdout);",
                    "});"
                ]
            },
            "load-toml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const loadToml = require(\"../../src/utils/load-toml\");",
                    "",
                    "describe(\"TOML\", () => {",
                    "  const exampleFilePath = \"example.toml\";",
                    "",
                    "  const exampleToml = `",
                    "# This is a TOML document.",
                    "title = \"TOML Example\"",
                    "[owner]",
                    "name = \"Tom Preston-Werner\"",
                    "dob = 1979-05-27T07:32:00-08:00 # First class dates",
                    "[database]",
                    "server = \"192.168.1.1\"",
                    "ports = [ 8001, 8001, 8002 ]",
                    "connection_max = 5000",
                    "enabled = true",
                    "`;",
                    "",
                    "  const wrongToml = \"///ERROR///\";",
                    "",
                    "  test(\"loads toml successfully\", () => {",
                    "    const parsedToml = loadToml(exampleFilePath, exampleToml);",
                    "    expect(parsedToml).toMatchSnapshot();",
                    "  });",
                    "",
                    "  test(\"throws error on incorrect toml\", () => {",
                    "    expect(() => {",
                    "      loadToml(exampleFilePath, wrongToml);",
                    "    }).toThrow();",
                    "",
                    "    expect(() => {",
                    "      loadToml(exampleFilePath, wrongToml);",
                    "    }).toThrowErrorMatchingSnapshot();",
                    "  });",
                    "});"
                ]
            },
            "loglevel.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const stripAnsi = require(\"strip-ansi\");",
                    "",
                    "test(\"do not show logs with --loglevel silent\", () => {",
                    "  runPrettierWithLogLevel(\"silent\", null);",
                    "});",
                    "",
                    "test(\"do not show warnings with --loglevel error\", () => {",
                    "  runPrettierWithLogLevel(\"error\", [\"[error]\"]);",
                    "});",
                    "",
                    "test(\"show errors and warnings with --loglevel warn\", () => {",
                    "  runPrettierWithLogLevel(\"warn\", [\"[error]\", \"[warn]\"]);",
                    "});",
                    "",
                    "test(\"show all logs with --loglevel debug\", () => {",
                    "  runPrettierWithLogLevel(\"debug\", [\"[error]\", \"[warn]\", \"[debug]\"]);",
                    "});",
                    "",
                    "describe(\"--write with --loglevel=silent doesn't log filenames\", () => {",
                    "  runPrettier(\"cli/write\", [",
                    "    \"--write\",",
                    "    \"unformatted.js\",",
                    "    \"--loglevel=silent\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "function runPrettierWithLogLevel(logLevel, patterns) {",
                    "  const result = runPrettier(\"cli/loglevel\", [",
                    "    \"--loglevel\",",
                    "    logLevel,",
                    "    \"--unknown-option\",",
                    "    \"--parser\",",
                    "    \"unknown-parser\",",
                    "    \"not-found.js\",",
                    "  ]);",
                    "",
                    "  expect(result.status).toEqual(2);",
                    "",
                    "  const stderr = stripAnsi(result.stderr);",
                    "",
                    "  if (patterns) {",
                    "    patterns.forEach((pattern) => {",
                    "      expect(stderr).toMatch(pattern);",
                    "    });",
                    "  } else {",
                    "    expect(stderr).toMatch(/^\\s*$/);",
                    "  }",
                    "}"
                ]
            },
            "normalize-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const docBuilders = prettier.doc.builders;",
                    "const docUtils = prettier.doc.utils;",
                    "",
                    "const { normalizeDoc } = docUtils;",
                    "const { group, concat, fill } = docBuilders;",
                    "",
                    "describe(\"normalizeDoc\", () => {",
                    "  test.each([",
                    "    [",
                    "      \"removes empty strings\",",
                    "      concat([\"\", \"foo\", fill([\"\", \"bar\", \"\"]), \"\"]),",
                    "      concat([\"foo\", fill([\"bar\"])]),",
                    "    ],",
                    "    [",
                    "      \"flattens nested concat\",",
                    "      concat([\"foo \", \"\", concat([\"bar \", \"\", concat([\"baz\", \"\"])])]),",
                    "      concat([\"foo bar baz\"]),",
                    "    ],",
                    "    [",
                    "      \"flattens nested concat in other docs\",",
                    "      group(concat([\"foo \", concat([\"bar \", \"\", concat([\"baz\", \"\"])])])),",
                    "      group(concat([\"foo bar baz\"])),",
                    "    ],",
                    "    [",
                    "      \"keeps groups\",",
                    "      concat([group(\"foo\"), group(\"bar\"), group(\"baz\")]),",
                    "      concat([group(\"foo\"), group(\"bar\"), group(\"baz\")]),",
                    "    ],",
                    "    [",
                    "      \"keeps fills\",",
                    "      fill([\"foo\", fill([\"bar\", fill([\"baz\"])])]),",
                    "      fill([\"foo\", fill([\"bar\", fill([\"baz\"])])]),",
                    "    ],",
                    "  ])(\"%s\", (_, doc, expected) => {",
                    "    const result = normalizeDoc(doc);",
                    "",
                    "    expect(result).toEqual(expected);",
                    "  });",
                    "});"
                ]
            },
            "parser-api.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "test(\"allows custom parser provided as object\", () => {",
                    "  const output = prettier.format(\"1\", {",
                    "    parser(text) {",
                    "      expect(text).toEqual(\"1\");",
                    "      return {",
                    "        type: \"Literal\",",
                    "        value: 2,",
                    "        raw: \"2\",",
                    "      };",
                    "    },",
                    "  });",
                    "  expect(output).toEqual(\"2\");",
                    "});",
                    "",
                    "test(\"allows usage of prettier's supported parsers\", () => {",
                    "  const output = prettier.format(\"foo ( )\", {",
                    "    parser(text, parsers) {",
                    "      expect(typeof parsers.babel).toEqual(\"function\");",
                    "      const ast = parsers.babel(text);",
                    "      ast.program.body[0].expression.callee.name = \"bar\";",
                    "      return ast;",
                    "    },",
                    "  });",
                    "  expect(output).toEqual(\"bar();\\n\");",
                    "});",
                    "",
                    "describe(\"allows passing a string to resolve a parser\", () => {",
                    "  runPrettier(\"./custom-parsers/\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"./custom-rename-input.js\",",
                    "    \"--parser\",",
                    "    \"./custom-rename-parser\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "patterns-dirs.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "// ESLint-like behavior",
                    "// https://github.com/prettier/prettier/pull/6639#issuecomment-548949954",
                    "//",
                    "// 1. `prettier dir1 dir2`  prettify all files with supported extensions inside `dir1` and `dir2`.",
                    "//",
                    "// 2. `prettier dir1 \"dir2/**/*\"`  prettify all files with supported extensions inside `dir1`",
                    "//     as well as all files matched by the `dir2/**/*` glob.",
                    "//     If any of the latter files have unknown extensions  log an error for them. (*)",
                    "//",
                    "// 3. `prettier non-exists-dir \"dir2/**/*\"\"`  log an error that `non-exists-dir` resulted in 0 files",
                    "//     and prettify all files matched by the `dir2/**/*` glob.",
                    "//     If any of the latter files have unknown extensions  log an error for them. (*)",
                    "//     (Note: ESLint just prints an error and doesn't process anything.)",
                    "//",
                    "// 4. `prettier . \"dir2/**/*\"`  prettify all files with supported extensions in `.`",
                    "//     and all files matched by the `dir2/**/*` glob.",
                    "//     If any of the latter files have unknown extensions  log an error for them. (*)",
                    "//",
                    "// (*) That error (\"No parser could be inferred for file\") doesn't affect the error code.",
                    "",
                    "testPatterns(\"1\", [\"dir1\", \"dir2\"]);",
                    "testPatterns(\"1a - with *.foo plugin\", [",
                    "  \"dir1\",",
                    "  \"dir2\",",
                    "  \"--plugin=../../plugins/extensions/plugin\",",
                    "]);",
                    "testPatterns(\"1b - special characters in dir name\", [\"dir1\", \"!dir\"], {",
                    "  stdout: expect.stringMatching(/!dir[/\\\\]a\\.js/),",
                    "});",
                    "testPatterns(\"1c\", [\"dir1\", \"empty\"], { status: 2 });",
                    "",
                    "testPatterns(\"2\", [\"dir1\", \"dir2/**/*\"], { status: 1 });",
                    "",
                    "testPatterns(\"3\", [\"nonexistent-dir\", \"dir2/**/*\"], { status: 2 });",
                    "",
                    "testPatterns(\"4\", [\".\", \"dir2/**/*\"], { status: 1 });",
                    "",
                    "describe(\"Negative patterns\", () => {",
                    "  testPatterns(\"1\", [\"dir1\", \"!dir1/nested1\"]);",
                    "  testPatterns(\"1a\", [\"dir1\", \"!dir1/nested1/*\"]);",
                    "  testPatterns(\"2\", [\".\", \"!dir1/nested1\"]);",
                    "  testPatterns(\"3\", [\".\", \"!dir1/nested1/an1.js\"]);",
                    "  testPatterns(\"4\", [\"!nonexistent-dir1 !nonexistent-dir2\"], { status: 2 });",
                    "  testPatterns(\"with explicit files\", [\"dir1/a1.js\", \"dir2/a2.js\", \"!dir1/*\"], {",
                    "    status: 2,",
                    "  });",
                    "});",
                    "",
                    "testPatterns(\"Exclude yarn.lock when expanding directories\", [\".\"], {",
                    "  stdout: expect.not.stringContaining(\"yarn.lock\"),",
                    "});",
                    "",
                    "const path = require(\"path\");",
                    "const fs = require(\"fs\");",
                    "if (path.sep === \"/\") {",
                    "  // Don't use snapshots in these tests as they're conditionally executed on non-Windows only.",
                    "",
                    "  const base = path.resolve(__dirname, \"../cli/patterns-dirs\");",
                    "",
                    "  // We can't commit these dirs without causing problems on Windows.",
                    "",
                    "  // TODO: these should be moved to a `beforeAll`, but for that to be possible,",
                    "  // `runPrettier` should be refactored to use `describe` and `beforeEach` for doing setup.",
                    "  fs.mkdirSync(path.resolve(base, \"test-a\\\\\"));",
                    "  fs.writeFileSync(path.resolve(base, \"test-a\\\\\", \"test.js\"), \"x\");",
                    "  fs.mkdirSync(path.resolve(base, \"test-b\\\\?\"));",
                    "  fs.writeFileSync(path.resolve(base, \"test-b\\\\?\", \"test.js\"), \"x\");",
                    "",
                    "  describe(\"Backslashes in names\", () => {",
                    "    afterAll(() => {",
                    "      fs.unlinkSync(path.resolve(base, \"test-a\\\\\", \"test.js\"));",
                    "      fs.rmdirSync(path.resolve(base, \"test-a\\\\\"));",
                    "      fs.unlinkSync(path.resolve(base, \"test-b\\\\?\", \"test.js\"));",
                    "      fs.rmdirSync(path.resolve(base, \"test-b\\\\?\"));",
                    "    });",
                    "",
                    "    testPatterns(\"\", [\"test-a\\\\/test.js\"], { stdout: \"test-a\\\\/test.js\\n\" });",
                    "    testPatterns(\"\", [\"test-a\\\\\"], { stdout: \"test-a\\\\/test.js\\n\" });",
                    "    testPatterns(\"\", [\"test-a*/*\"], { stdout: \"test-a\\\\/test.js\\n\" });",
                    "",
                    "    testPatterns(\"\", [\"test-b\\\\?/test.js\"], { stdout: \"test-b\\\\?/test.js\\n\" });",
                    "    testPatterns(\"\", [\"test-b\\\\?\"], { stdout: \"test-b\\\\?/test.js\\n\" });",
                    "    testPatterns(\"\", [\"test-b*/*\"], { stdout: \"test-b\\\\?/test.js\\n\" });",
                    "  });",
                    "}",
                    "",
                    "function testPatterns(namePrefix, cliArgs, expected = {}) {",
                    "  const testName =",
                    "    (namePrefix ? namePrefix + \": \" : \"\") +",
                    "    \"prettier \" +",
                    "    cliArgs",
                    "      .map((arg) => (/^[\\w./=-]+$/.test(arg) ? arg : `'${arg}'`))",
                    "      .join(\" \");",
                    "",
                    "  describe(testName, () => {",
                    "    runPrettier(\"cli/patterns-dirs\", [...cliArgs, \"-l\"]).test({",
                    "      write: [],",
                    "      ...(!(\"status\" in expected) && { stderr: \"\", status: 1 }),",
                    "      ...expected,",
                    "    });",
                    "  });",
                    "}"
                ]
            },
            "patterns-glob.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "/*",
                    "fixtures-1/",
                    " !file.js",
                    " a.js",
                    " b.js",
                    "*/",
                    "",
                    "describe(\"fixtures-1: Should match all files\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-1\", [\"*.js\", \"!file.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"fixtures-1: Should match files except `a.js`\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-1\", [\"*.js\", \"!a.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "/*",
                    "fixtures-2/",
                    " a.js",
                    " !b.js",
                    " !dir.js/",
                    "   1.css",
                    "   2.css",
                    "*/",
                    "",
                    "describe(\"fixtures-2: Should match all js files and all supported files in the '!dir.js' directory\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-2\", [\"*.js\", \"!dir.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"fixtures-2: Should match `a.js` and `!b.js`\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-2\", [\"*.js\", \"!b.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"fixtures-2: Should only match `!b.js`\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-2\", [\"*.js\", \"!a.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "/*",
                    "fixtures-3/",
                    " outside.js",
                    " dir",
                    "   inside.js",
                    "   node_modules/",
                    "   in-node_modules.js",
                    "   .svn/",
                    "    in-svn.js",
                    "*/",
                    "",
                    "describe(\"fixtures-3: Should match `outside.js`, `dir/inside.js` and `dir/node_modules/in-node_modules.js`\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-3\", [",
                    "    \"**/*.js\",",
                    "    \"-l\",",
                    "    \"--with-node-modules\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"fixtures-3: Should only match `outside.js` and `dir/inside.js`\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-3\", [\"**/*.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"fixtures-3: Should exclude `.svn`\", () => {",
                    "  describe(\"(existing)\", () => {",
                    "    runPrettier(\"cli/patterns-glob/fixtures-3\", [",
                    "      \"*.js\",",
                    "      \"dir/.svn/in-svn.js\",",
                    "      \"-l\",",
                    "    ]).test({",
                    "      status: 1,",
                    "    });",
                    "  });",
                    "",
                    "  describe(\"(nonexisting)\", () => {",
                    "    runPrettier(\"cli/patterns-glob/fixtures-3\", [",
                    "      \"*.js\",",
                    "      \".svn/in-svn.js\",",
                    "      \"-l\",",
                    "    ]).test({",
                    "      status: 1,",
                    "    });",
                    "  });",
                    "});",
                    "",
                    "/*",
                    "fixtures-4/",
                    " level-0.js",
                    " 0",
                    "   level-1.js",
                    "   1/",
                    "     level-2.js",
                    "     2/",
                    "       level-3.js",
                    "*/",
                    "",
                    "describe(\"fixtures-4: Should match `level-1.js`\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-4\", [\"./0/./level-1.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"fixtures-4: Should match `level-1.js` #2\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-4\", [",
                    "    \"./0/1/2/../../level-1.js\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"fixtures-4: Should match `level-1.js` #3\", () => {",
                    "  runPrettier(\"cli/patterns-glob/fixtures-4\", [",
                    "    \"./0/non-exists-dir/2/../../level-1.js\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});"
                ]
            },
            "patterns.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"multiple patterns\", () => {",
                    "  runPrettier(\"cli/patterns\", [",
                    "    \"directory/**/*.js\",",
                    "    \"other-directory/**/*.js\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns with non exists pattern\", () => {",
                    "  runPrettier(\"cli/patterns\", [",
                    "    \"directory/**/*.js\",",
                    "    \"non-existent.js\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 2,",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns with ignore nested directories pattern\", () => {",
                    "  runPrettier(\"cli/patterns\", [",
                    "    \"**/*.js\",",
                    "    \"!**/nested-directory/**\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns by with ignore pattern, ignores node_modules by default\", () => {",
                    "  runPrettier(\"cli/patterns\", [\"**/*.js\", \"!directory/**\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns by with ignore pattern, ignores node_modules by with ./**/*.js\", () => {",
                    "  runPrettier(\"cli/patterns\", [\"./**/*.js\", \"!./directory/**\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns by with ignore pattern, doesn't ignore node_modules with --with-node-modules flag\", () => {",
                    "  runPrettier(\"cli/patterns\", [",
                    "    \"**/*.js\",",
                    "    \"!directory/**\",",
                    "    \"-l\",",
                    "    \"--with-node-modules\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"no errors on empty patterns\", () => {",
                    "  // --parser is mandatory if no filepath is passed",
                    "  runPrettier(\"cli/patterns\", [\"--parser\", \"babel\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"multiple patterns, throw error and exit with non zero code on non existing files\", () => {",
                    "  runPrettier(\"cli/patterns\", [",
                    "    \"non-existent.js\",",
                    "    \"other-non-existent.js\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 2,",
                    "  });",
                    "});"
                ]
            },
            "piped-output.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"output with --check + unformatted differs when piped\", () => {",
                    "  const result0 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--check\", \"--no-color\", \"unformatted.js\"],",
                    "    { stdoutIsTTY: true }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  const result1 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--check\", \"--no-color\", \"unformatted.js\"],",
                    "    { stdoutIsTTY: false }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  expect(result0.stdout.length).toBeGreaterThan(result1.stdout.length);",
                    "  expect(result0.write).toEqual(result1.write);",
                    "});",
                    "",
                    "describe(\"no file diffs with --check + formatted file\", () => {",
                    "  const result0 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--check\", \"--no-color\", \"formatted.js\"],",
                    "    { stdoutIsTTY: true }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  const result1 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--check\", \"--no-color\", \"formatted.js\"],",
                    "    { stdoutIsTTY: false }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  expect(result0.stdout).not.toEqual(result1.stdout);",
                    "  expect(result0.stdout.length).toBeGreaterThan(result1.stdout.length);",
                    "  expect(result0.write).toEqual(result1.write);",
                    "});",
                    "",
                    "describe(\"output with --list-different + unformatted differs when piped\", () => {",
                    "  const result0 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--list-different\", \"--no-color\", \"unformatted.js\"],",
                    "    { stdoutIsTTY: true }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  const result1 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--list-different\", \"--no-color\", \"unformatted.js\"],",
                    "    { stdoutIsTTY: false }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  expect(result0.stdout.length).toBeGreaterThan(result1.stdout.length);",
                    "  expect(result0.write).toEqual(result1.write);",
                    "});",
                    "",
                    "describe(\"no file diffs with --list-different + formatted file\", () => {",
                    "  const result0 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--list-different\", \"--no-color\", \"formatted.js\"],",
                    "    { stdoutIsTTY: true }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  const result1 = runPrettier(",
                    "    \"cli/write\",",
                    "    [\"--write\", \"--list-different\", \"--no-color\", \"formatted.js\"],",
                    "    { stdoutIsTTY: false }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "",
                    "  expect(result0.stdout).not.toEqual(result1.stdout);",
                    "  expect(result0.stdout.length).toBeGreaterThan(result1.stdout.length);",
                    "  expect(result0.write).toEqual(result1.write);",
                    "});"
                ]
            },
            "plugin-default-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"plugin default options should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/defaultOptions\",",
                    "    [",
                    "      \"--stdin-filepath\",",
                    "      \"example.foo\",",
                    "      \"--plugin=./plugin\",",
                    "      \"--no-editorconfig\",",
                    "    ],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: JSON.stringify({",
                    "      tabWidth: 8,",
                    "      bracketSpacing: false,",
                    "    }),",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"overriding plugin default options should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/defaultOptions\",",
                    "    [\"--stdin-filepath\", \"example.foo\", \"--plugin=./plugin\", \"--tab-width=4\"],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: JSON.stringify({",
                    "      tabWidth: 4,",
                    "      bracketSpacing: false,",
                    "    }),",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});"
                ]
            },
            "plugin-extensions.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const EOL = \"\\n\";",
                    "",
                    "describe(\"uses 'extensions' from languages to determine parser\", () => {",
                    "  runPrettier(\"plugins/extensions\", [\"*.foo\", \"--plugin=./plugin\"], {",
                    "    ignoreLineEndings: true,",
                    "  }).test({",
                    "    stdout: \"!contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});"
                ]
            },
            "plugin-options-string.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const snapshotDiff = require(\"snapshot-diff\");",
                    "",
                    "describe(\"show external options with `--help`\", () => {",
                    "  const originalStdout = runPrettier(\"plugins/options-string\", [\"--help\"])",
                    "    .stdout;",
                    "  const pluggedStdout = runPrettier(\"plugins/options-string\", [",
                    "    \"--help\",",
                    "    \"--plugin=./plugin\",",
                    "  ]).stdout;",
                    "  expect(snapshotDiff(originalStdout, pluggedStdout)).toMatchSnapshot();",
                    "});",
                    "",
                    "describe(\"show detailed external option with `--help foo-string`\", () => {",
                    "  runPrettier(\"plugins/options-string\", [",
                    "    \"--plugin=./plugin\",",
                    "    \"--help\",",
                    "    \"foo-string\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"external options from CLI should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/options-string\",",
                    "    [",
                    "      \"--plugin=./plugin\",",
                    "      \"--stdin-filepath\",",
                    "      \"example.foo\",",
                    "      \"--foo-string\",",
                    "      \"baz\",",
                    "    ],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: \"foo:baz\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"external options from config file should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/options-string\",",
                    "    [\"--config=./config.json\", \"--stdin-filepath\", \"example.foo\"],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: \"foo:baz\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});"
                ]
            },
            "plugin-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const snapshotDiff = require(\"snapshot-diff\");",
                    "",
                    "describe(\"show external options with `--help`\", () => {",
                    "  const originalStdout = runPrettier(\"plugins/options\", [\"--help\"]).stdout;",
                    "  const pluggedStdout = runPrettier(\"plugins/options\", [",
                    "    \"--help\",",
                    "    \"--plugin=./plugin\",",
                    "  ]).stdout;",
                    "  expect(snapshotDiff(originalStdout, pluggedStdout)).toMatchSnapshot();",
                    "});",
                    "",
                    "describe(\"show detailed external option with `--help foo-option`\", () => {",
                    "  runPrettier(\"plugins/options\", [",
                    "    \"--plugin=./plugin\",",
                    "    \"--help\",",
                    "    \"foo-option\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"include plugin's parsers to the values of the `parser` option`\", () => {",
                    "  runPrettier(\"plugins/options\", [",
                    "    \"--plugin=./plugin\",",
                    "    \"--help\",",
                    "    \"parser\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"external options from CLI should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/options\",",
                    "    [",
                    "      \"--plugin=./plugin\",",
                    "      \"--stdin-filepath\",",
                    "      \"example.foo\",",
                    "      \"--foo-option\",",
                    "      \"baz\",",
                    "    ],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: \"foo:baz\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"external options from config file should work\", () => {",
                    "  runPrettier(",
                    "    \"plugins/options\",",
                    "    [\"--config=./config.json\", \"--stdin-filepath\", \"example.foo\"],",
                    "    { input: \"hello-world\" }",
                    "  ).test({",
                    "    stdout: \"foo:baz\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});"
                ]
            },
            "plugin-precedence.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"json-stringify takes precedence over json for package.json\", () => {",
                    "  runPrettier(\"plugins\", [\"--stdin-filepath=package.json\"], {",
                    "    input:",
                    "      '{ \"a\": \"longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong\" }',",
                    "  }).test({",
                    "    stdout:",
                    "      '{\\n  \"a\": \"longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong\"\\n}\\n',",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});"
                ]
            },
            "plugin-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const EOL = \"\\n\";",
                    "",
                    "describe(\"parser preprocess function is used to reshape input text\", () => {",
                    "  runPrettier(\"plugins/preprocess\", [\"*.foo\", \"--plugin=./plugin\"], {",
                    "    ignoreLineEndings: true,",
                    "  }).test({",
                    "    stdout: \"preprocessed:contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});"
                ]
            },
            "plugin-resolution.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const EOL = \"\\n\";",
                    "",
                    "describe(\"automatically loads 'prettier-plugin-*'\", () => {",
                    "  runPrettier(\"plugins/automatic\", [\"file.txt\", \"--parser=bar\"]).test({",
                    "    stdout: \"content from `prettier-plugin-bar` package + contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"automatically loads '@prettier/plugin-*'\", () => {",
                    "  runPrettier(\"plugins/automatic\", [\"file.txt\", \"--parser=foo\"]).test({",
                    "    stdout: \"foo+contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"automatically loads '@<name>/prettier-plugin-*'\", () => {",
                    "  runPrettier(\"plugins/automatic\", [\"file.txt\", \"--parser=foobar\"]).test({",
                    "    stdout: \"foobar+contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"automatically loads 'prettier-plugin-*' from --plugin-search-dir (same as autoload dir)\", () => {",
                    "  runPrettier(\"plugins/automatic\", [",
                    "    \"file.txt\",",
                    "    \"--parser=foo\",",
                    "    \"--plugin-search-dir=.\",",
                    "  ]).test({",
                    "    stdout: \"foo+contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"automatically loads '@prettier/plugin-*' from --plugin-search-dir (same as autoload dir)\", () => {",
                    "  runPrettier(\"plugins/automatic\", [",
                    "    \"file.txt\",",
                    "    \"--parser=bar\",",
                    "    \"--plugin-search-dir=.\",",
                    "  ]).test({",
                    "    stdout: \"content from `prettier-plugin-bar` package + contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"automatically loads '@<name>/prettier-plugin-*' from --plugin-search-dir (same as autoload dir)\", () => {",
                    "  runPrettier(\"plugins/automatic\", [",
                    "    \"file.txt\",",
                    "    \"--parser=foobar\",",
                    "    \"--plugin-search-dir=.\",",
                    "  ]).test({",
                    "    stdout: \"foobar+contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"automatically loads 'prettier-plugin-*' from --plugin-search-dir (different to autoload dir)\", () => {",
                    "  runPrettier(\"plugins\", [",
                    "    \"automatic/file.txt\",",
                    "    \"--parser=foo\",",
                    "    \"--plugin-search-dir=automatic\",",
                    "  ]).test({",
                    "    stdout: \"foo+contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"automatically loads '@prettier/plugin-*' from --plugin-search-dir (different to autoload dir)\", () => {",
                    "  runPrettier(\"plugins\", [",
                    "    \"automatic/file.txt\",",
                    "    \"--parser=bar\",",
                    "    \"--plugin-search-dir=automatic\",",
                    "  ]).test({",
                    "    stdout: \"content from `prettier-plugin-bar` package + contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"does not crash when --plugin-search-dir does not contain node_modules\", () => {",
                    "  runPrettier(",
                    "    \"plugins/extensions\",",
                    "    [",
                    "      \"file.foo\",",
                    "      \"--end-of-line\",",
                    "      \"lf\",",
                    "      \"--plugin=./plugin\",",
                    "      \"--plugin-search-dir=.\",",
                    "    ],",
                    "    { ignoreLineEndings: true }",
                    "  ).test({",
                    "    stdout: \"!contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"crashes when one of --plugin-search-dir does not exist\", () => {",
                    "  runPrettier(\"plugins/automatic\", [",
                    "    \"file.txt\",",
                    "    \"--parser=foo\",",
                    "    \"--plugin-search-dir=non-existing-dir\",",
                    "    \"--plugin-search-dir=.\",",
                    "  ]).test({",
                    "    stdout: \"\",",
                    "    stderr: \"non-existing-dir does not exist or is not a directory\",",
                    "    status: 1,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"loads --plugin by its relative path\", () => {",
                    "  runPrettier(\"plugins\", [",
                    "    \"automatic/file.txt\",",
                    "    \"--parser=bar\",",
                    "    \"--plugin=./automatic/node_modules/prettier-plugin-bar/index.js\",",
                    "  ]).test({",
                    "    stdout: \"content from `prettier-plugin-bar` package + contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"loads --plugin by its relative path without leading ./\", () => {",
                    "  runPrettier(\"plugins\", [",
                    "    \"automatic/file.txt\",",
                    "    \"--parser=bar\",",
                    "    \"--plugin=automatic/node_modules/prettier-plugin-bar/index.js\",",
                    "  ]).test({",
                    "    stdout: \"content from `prettier-plugin-bar` package + contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"loads --plugin by relative path to its directory (assuming index.js)\", () => {",
                    "  runPrettier(\"plugins\", [",
                    "    \"automatic/file.txt\",",
                    "    \"--parser=bar\",",
                    "    \"--plugin=./automatic/node_modules/prettier-plugin-bar\",",
                    "  ]).test({",
                    "    stdout: \"content from `prettier-plugin-bar` package + contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"loads --plugin by relative path to its directory without leading ./ (assuming index.js)\", () => {",
                    "  runPrettier(\"plugins\", [",
                    "    \"automatic/file.txt\",",
                    "    \"--parser=bar\",",
                    "    \"--plugin=automatic/node_modules/prettier-plugin-bar\",",
                    "  ]).test({",
                    "    stdout: \"content from `prettier-plugin-bar` package + contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"loads --plugin by filename without leading ./ and ext, should resolve to file, not package\", () => {",
                    "  runPrettier(\"plugins/automatic\", [",
                    "    \"file.txt\",",
                    "    \"--parser=bar\",",
                    "    \"--plugin=prettier-plugin-bar\",",
                    "  ]).test({",
                    "    stdout: \"content from `prettier-plugin-bar.js` file + contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});",
                    "",
                    "describe(\"loads --plugin by bespoke plugin name (assuming it is installed in cwd)\", () => {",
                    "  runPrettier(\"plugins/bespoke\", [",
                    "    \"../automatic/file.txt\",",
                    "    \"--parser=bespoke\",",
                    "    \"--plugin=@company/prettier-plugin-bespoke\",",
                    "  ]).test({",
                    "    stdout: \"bespoke+contents\" + EOL,",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});"
                ]
            },
            "plugin-virtual-directory.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"plugin search should not crash when prettier isn't inside a directory\", () => {",
                    "  runPrettier(",
                    "    \"plugins/virtualDirectory\",",
                    "    [\"--stdin-filepath\", \"example.js\", \"--plugin-search-dir=.\"],",
                    "    { input: \"\" }",
                    "  ).test({",
                    "    stdout: \"\",",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "    write: [],",
                    "  });",
                    "});"
                ]
            },
            "schema.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const generateSchema = require(\"../../scripts/generate-schema\");",
                    "",
                    "test(\"schema\", () => {",
                    "  expect(generateSchema(prettier.getSupportInfo().options)).toMatchSnapshot();",
                    "});"
                ]
            },
            "skip-folders.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"skips folders in glob\", () => {",
                    "  runPrettier(\"cli/skip-folders\", [\"**/*\", \"-l\"]).test({",
                    "    status: 1,",
                    "    stderr: \"\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"skip folders passed specifically\", () => {",
                    "  runPrettier(\"cli/skip-folders\", [",
                    "    \"a\",",
                    "    \"a/file.js\",",
                    "    \"b\",",
                    "    \"b/file.js\",",
                    "    \"-l\",",
                    "  ]).test({ status: 1, stderr: \"\" });",
                    "});"
                ]
            },
            "stdin-filepath.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"format correctly if stdin content compatible with stdin-filepath\", () => {",
                    "  runPrettier(",
                    "    \"cli\",",
                    "    [\"--stdin-filepath\", \"abc.css\"],",
                    "    { input: \".name { display: none; }\" } // css",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"throw error if stdin content incompatible with stdin-filepath\", () => {",
                    "  runPrettier(",
                    "    \"cli\",",
                    "    [\"--stdin-filepath\", \"abc.js\"],",
                    "    { input: \".name { display: none; }\" } // css",
                    "  ).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"gracefully handle stdin-filepath with nonexistent directory\", () => {",
                    "  runPrettier(",
                    "    \"cli\",",
                    "    [\"--stdin-filepath\", \"definitely/nonexistent/path.css\"],",
                    "    { input: \".name { display: none; }\" } // css",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"apply editorconfig for stdin-filepath with nonexistent file\", () => {",
                    "  runPrettier(",
                    "    \"cli\",",
                    "    [\"--stdin-filepath\", \"config/editorconfig/nonexistent.js\"],",
                    "    {",
                    "      input: `",
                    "function f() {",
                    "  console.log(\"should be indented with a tab\");",
                    "}",
                    "`.trim(), // js",
                    "    }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"apply editorconfig for stdin-filepath with nonexistent directory\", () => {",
                    "  runPrettier(",
                    "    \"cli\",",
                    "    [\"--stdin-filepath\", \"config/editorconfig/nonexistent/one/two/three.js\"],",
                    "    {",
                    "      input: `",
                    "function f() {",
                    "  console.log(\"should be indented with a tab\");",
                    "}",
                    "`.trim(), // js",
                    "    }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"dont apply editorconfig outside project for stdin-filepath with nonexistent directory\", () => {",
                    "  runPrettier(",
                    "    \"cli\",",
                    "    [",
                    "      \"--stdin-filepath\",",
                    "      \"config/editorconfig/repo-root/nonexistent/one/two/three.js\",",
                    "    ],",
                    "    {",
                    "      input: `",
                    "function f() {",
                    "  console.log(\"should be indented with 2 spaces\");",
                    "}",
                    "`.trim(), // js",
                    "    }",
                    "  ).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"output file as-is if stdin-filepath matched patterns in ignore-path\", () => {",
                    "  runPrettier(\"cli/stdin-ignore\", [\"--stdin-filepath\", \"ignore/example.js\"], {",
                    "    input: \"hello_world( );\",",
                    "  }).test({",
                    "    stdout: \"hello_world( );\",",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "support-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const prettier = require(\"prettier/local\");",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "test(\"API getSupportInfo()\", () => {",
                    "  expect(getCoreInfo()).toMatchSnapshot();",
                    "});",
                    "",
                    "describe(\"CLI --support-info\", () => {",
                    "  runPrettier(\"cli\", \"--support-info\").test({ status: 0 });",
                    "});",
                    "",
                    "function getCoreInfo() {",
                    "  const supportInfo = prettier.getSupportInfo();",
                    "  const languages = supportInfo.languages.reduce(",
                    "    (obj, language) => ({ [language.name]: language.parsers, ...obj }),",
                    "    {}",
                    "  );",
                    "  const options = supportInfo.options.reduce(",
                    "    (obj, option) => ({",
                    "      [option.name]: {",
                    "        type: option.type,",
                    "        default: option.default,",
                    "        ...(option.type === \"int\"",
                    "          ? { range: option.range }",
                    "          : option.type === \"choice\"",
                    "          ? { choices: option.choices.map((choice) => choice.value) }",
                    "          : null),",
                    "      },",
                    "      ...obj,",
                    "    }),",
                    "    {}",
                    "  );",
                    "  return { languages, options };",
                    "}"
                ]
            },
            "syntax-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"exits with non-zero code when input has a syntax error\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--parser\", \"babel\"], {",
                    "    input: \"a.2\",",
                    "  }).test({",
                    "    status: 2,",
                    "  });",
                    "});"
                ]
            },
            "third-party.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const { thirdParty } = require(\"../env\");",
                    "const { cosmiconfig, cosmiconfigSync } = require(thirdParty);",
                    "",
                    "// This don't has to be the same result as `prettier.resolveConfig`,",
                    "// Because we are testing with default `cosmiconfigOptions`",
                    "describe(\"cosmiconfig\", () => {",
                    "  const configs = [",
                    "    {",
                    "      title: \"prettier.config.js\",",
                    "      dirname: path.join(__dirname, \"../cli/config/js/\"),",
                    "      file: path.join(__dirname, \"../cli/config/js/prettier.config.js\"),",
                    "      value: {",
                    "        endOfLine: \"auto\",",
                    "        tabWidth: 8,",
                    "      },",
                    "    },",
                    "    {",
                    "      title: \"package.json\",",
                    "      dirname: path.join(__dirname, \"../cli/config/package/\"),",
                    "      file: path.join(__dirname, \"../cli/config/package/package.json\"),",
                    "      value: {",
                    "        tabWidth: 3,",
                    "        overrides: [",
                    "          {",
                    "            files: \"*.ts\",",
                    "            options: {",
                    "              tabWidth: 5,",
                    "            },",
                    "          },",
                    "        ],",
                    "      },",
                    "    },",
                    "  ];",
                    "",
                    "  for (const { title, dirname, file, value } of configs) {",
                    "    test(`async version ${title}`, async () => {",
                    "      const { config, filepath } = await cosmiconfig(\"prettier\").search(",
                    "        dirname",
                    "      );",
                    "      expect(config).toEqual(value);",
                    "      expect(filepath).toBe(file);",
                    "    });",
                    "",
                    "    test(`sync version ${title}`, () => {",
                    "      const { config, filepath } = cosmiconfigSync(\"prettier\").search(dirname);",
                    "      expect(config).toEqual(value);",
                    "      expect(filepath).toBe(file);",
                    "    });",
                    "  }",
                    "});"
                ]
            },
            "util-shared.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const sharedUtil = require(\"../../src/common/util-shared\");",
                    "",
                    "test(\"shared util has correct structure\", () => {",
                    "  expect(typeof sharedUtil.getMaxContinuousCount).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.getStringWidth).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.getAlignmentSize).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.getIndentSize).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.skip).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.skipWhitespace).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.skipSpaces).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.skipToLineEnd).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.skipEverythingButNewLine).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.skipInlineComment).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.skipTrailingComment).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.skipNewline).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.hasNewline).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.hasNewlineInRange).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.hasSpaces).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.isNextLineEmpty).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.isNextLineEmptyAfterIndex).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.isPreviousLineEmpty).toEqual(\"function\");",
                    "  expect(typeof sharedUtil.getNextNonSpaceNonCommentCharacterIndex).toEqual(",
                    "    \"function\"",
                    "  );",
                    "  expect(typeof sharedUtil.makeString).toEqual(\"function\");",
                    "});",
                    "",
                    "test(\"sharedUtil.getMaxContinuousCount\", () => {",
                    "  const { getMaxContinuousCount } = sharedUtil;",
                    "",
                    "  expect(getMaxContinuousCount(\"|---|--|-|--|---|\", \"-\")).toEqual(3);",
                    "  expect(getMaxContinuousCount(\"|...|\", \".\")).toEqual(3);",
                    "",
                    "  const fixture = [",
                    "    \"([a-f])([a-f])\",",
                    "    \"[a-f][a-f][a-f]\",",
                    "    \"a-fa-fa-fa-f\",",
                    "    \"bbbbbbbbbbbbbbbbbb\", // neither `a-f` `[a-f]` `([a-f])` should matches `b`",
                    "  ].join(\"\");",
                    "  expect(getMaxContinuousCount(fixture, \"([a-f])\")).toEqual(2);",
                    "  expect(getMaxContinuousCount(fixture, \"[a-f]\")).toEqual(3);",
                    "  expect(getMaxContinuousCount(fixture, \"a-f\")).toEqual(4);",
                    "  expect(getMaxContinuousCount(fixture, \"([a\\\\-f])\")).toEqual(0);",
                    "  expect(getMaxContinuousCount(fixture, \"[a\\\\-f]\")).toEqual(0);",
                    "  expect(getMaxContinuousCount(fixture, \"a\\\\-f\")).toEqual(0);",
                    "});",
                    "",
                    "test(\"sharedUtil.getStringWidth\", () => {",
                    "  const { getStringWidth } = sharedUtil;",
                    "",
                    "  // From https://github.com/sindresorhus/string-width/blob/master/test.js",
                    "  expect(getStringWidth(\"abcde\")).toBe(5);",
                    "  expect(getStringWidth(\"\")).toBe(6);",
                    "  expect(getStringWidth(\"abc\")).toBe(9);",
                    "  expect(getStringWidth(\".js\")).toBe(9);",
                    "  expect(getStringWidth(\"\")).toBe(4);",
                    "  expect(getStringWidth(\"\")).toBe(10);",
                    "  expect(getStringWidth(\"A\\uD83C\\uDE00BC\")).toBe(5);",
                    "  expect(getStringWidth(\"\\u001B[31m\\u001B[39m\")).toBe(0);",
                    "  expect(",
                    "    getStringWidth(\"\\u001B]8;;https://github.com\\u0007Click\\u001B]8;;\\u0007\")",
                    "  ).toBe(5);",
                    "  expect(getStringWidth(\"\\u{231A}\")).toBe(2);",
                    "  expect(getStringWidth(\"\\u{2194}\\u{FE0F}\")).toBe(2);",
                    "  expect(getStringWidth(\"\\u{1F469}\")).toBe(2);",
                    "  expect(getStringWidth(\"\\u{1F469}\\u{1F3FF}\")).toBe(2);",
                    "  expect(getStringWidth(String.fromCharCode(0))).toBe(0);",
                    "  expect(getStringWidth(String.fromCharCode(31))).toBe(0);",
                    "  // expect(getStringWidth(String.fromCharCode(127))).toBe(0); // Different with `string-width`",
                    "  expect(getStringWidth(String.fromCharCode(134))).toBe(0);",
                    "  expect(getStringWidth(String.fromCharCode(159))).toBe(0);",
                    "  expect(getStringWidth(\"\\u001B\")).toBe(0);",
                    "  // expect(getStringWidth(\"x\\u0300\"), 1); // Different with `string-width`",
                    "});",
                    "",
                    "test(\"sharedUtil.getAlignmentSize\", () => {",
                    "  const { getAlignmentSize } = sharedUtil;",
                    "  expect(getAlignmentSize(\"   \")).toBe(3);",
                    "  expect(getAlignmentSize(\"   \", /* tabWidth */ 2, /* startIndex */ 2)).toBe(1);",
                    "  expect(getAlignmentSize(\"\\t\\t\", /* tabWidth */ 2)).toBe(4);",
                    "  expect(getAlignmentSize(\"\\t\\t\", /* tabWidth */ 3)).toBe(6);",
                    "  expect(getAlignmentSize(\"\\t\\t\", /* tabWidth */ 3, /* startIndex */ 1)).toBe(",
                    "    3",
                    "  );",
                    "});",
                    "",
                    "test(\"sharedUtil.getIndentSize\", () => {",
                    "  const { getIndentSize } = sharedUtil;",
                    "  expect(getIndentSize(\"\\n   a\")).toBe(3);",
                    "  expect(getIndentSize(\"\\n   a\", /* tabWidth */ 2)).toBe(3);",
                    "  expect(getIndentSize(\"\\n\\t\\ta\", /* tabWidth */ 2)).toBe(4);",
                    "  expect(getIndentSize(\"\\n\\t\\ta\", /* tabWidth */ 3)).toBe(6);",
                    "  expect(getIndentSize(\"\\n\\t\\n\\t\\t\", /* tabWidth */ 2)).toBe(4);",
                    "  expect(getIndentSize(\"\\n \\n  \", /* tabWidth */ 2)).toBe(2);",
                    "  expect(getIndentSize(\"   \\n\\t\\t\\n\", /* tabWidth */ 2)).toBe(0);",
                    "});",
                    "",
                    "test(\"sharedUtil.makeString\", () => {",
                    "  const { makeString } = sharedUtil;",
                    "  const DOUBLE_QUOTE = '\"';",
                    "  const SINGLE_QUOTE = \"'\";",
                    "",
                    "  expect(makeString(\"a\", DOUBLE_QUOTE)).toBe(`${DOUBLE_QUOTE}a${DOUBLE_QUOTE}`);",
                    "  expect(makeString(\"a\", SINGLE_QUOTE)).toBe(`${SINGLE_QUOTE}a${SINGLE_QUOTE}`);",
                    "  expect(makeString(`a${DOUBLE_QUOTE}`, DOUBLE_QUOTE)).toBe(",
                    "    `${DOUBLE_QUOTE}a\\\\${DOUBLE_QUOTE}${DOUBLE_QUOTE}`",
                    "  );",
                    "  expect(makeString(`a${DOUBLE_QUOTE}`, SINGLE_QUOTE)).toBe(",
                    "    `${SINGLE_QUOTE}a${DOUBLE_QUOTE}${SINGLE_QUOTE}`",
                    "  );",
                    "  expect(",
                    "    makeString(\"\\\\a\", SINGLE_QUOTE, /* unescapeUnnecessaryEscapes */ true)",
                    "  ).toBe(`${SINGLE_QUOTE}a${SINGLE_QUOTE}`);",
                    "});"
                ]
            },
            "with-config-precedence.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"CLI overrides take precedence without --config-precedence\", () => {",
                    "  runPrettier(\"cli/config/\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"--print-width\",",
                    "    \"1\",",
                    "    \"**/*.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides take precedence with --config-precedence cli-override\", () => {",
                    "  runPrettier(\"cli/config/\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"--print-width\",",
                    "    \"1\",",
                    "    \"--config-precedence\",",
                    "    \"cli-override\",",
                    "    \"**/*.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides take lower precedence with --config-precedence file-override\", () => {",
                    "  runPrettier(\"cli/config/js/\", [",
                    "    \"--end-of-line\",",
                    "    \"crlf\",",
                    "    \"--tab-width\",",
                    "    \"1\",",
                    "    \"--config-precedence\",",
                    "    \"file-override\",",
                    "    \"**/*.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides are still applied when no config is found with --config-precedence file-override\", () => {",
                    "  runPrettier(\"cli/config/no-config/\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"--tab-width\",",
                    "    \"6\",",
                    "    \"--config-precedence\",",
                    "    \"file-override\",",
                    "    \"**/*.js\",",
                    "    \"--no-editorconfig\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides gets ignored when config exists with --config-precedence prefer-file\", () => {",
                    "  runPrettier(\"cli/config/js/\", [",
                    "    \"--print-width\",",
                    "    \"1\",",
                    "    \"--tab-width\",",
                    "    \"1\",",
                    "    \"--config-precedence\",",
                    "    \"prefer-file\",",
                    "    \"**/*.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI overrides gets applied when no config exists with --config-precedence prefer-file\", () => {",
                    "  runPrettier(\"cli/config/no-config/\", [",
                    "    \"--end-of-line\",",
                    "    \"lf\",",
                    "    \"--print-width\",",
                    "    \"1\",",
                    "    \"--tab-width\",",
                    "    \"7\",",
                    "    \"--no-config\",",
                    "    \"--config-precedence\",",
                    "    \"prefer-file\",",
                    "    \"**/*.js\",",
                    "  ]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI validate options with --config-precedence cli-override\", () => {",
                    "  runPrettier(\"cli/config-precedence\", [",
                    "    \"--config-precedence\",",
                    "    \"cli-override\",",
                    "  ]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI validate options with --config-precedence file-override\", () => {",
                    "  runPrettier(\"cli/config-precedence\", [",
                    "    \"--config-precedence\",",
                    "    \"file-override\",",
                    "  ]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI validate options with --config-precedence prefer-file\", () => {",
                    "  runPrettier(\"cli/config-precedence\", [",
                    "    \"--config-precedence\",",
                    "    \"prefer-file\",",
                    "  ]).test({",
                    "    status: \"non-zero\",",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI --stdin-filepath works with --config-precedence prefer-file\", () => {",
                    "  runPrettier(",
                    "    \"cli/config/\",",
                    "    [\"--stdin-filepath=abc.ts\", \"--no-semi\", \"--config-precedence=prefer-file\"],",
                    "    { input: \"let x: keyof Y = foo<typeof X>()\" } // typescript",
                    "  ).test({",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI --stdin-filepath works with --config-precedence file-override\", () => {",
                    "  runPrettier(",
                    "    \"cli/config/\",",
                    "    [",
                    "      \"--stdin-filepath=abc.ts\",",
                    "      \"--no-semi\",",
                    "      \"--config-precedence=file-override\",",
                    "    ],",
                    "    { input: \"let x: keyof Y = foo<typeof X>()\" } // typescript",
                    "  ).test({",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"CLI --stdin-filepath works with --config-precedence cli-override\", () => {",
                    "  runPrettier(",
                    "    \"cli/config/\",",
                    "    [",
                    "      \"--stdin-filepath=abc.ts\",",
                    "      \"--no-semi\",",
                    "      \"--config-precedence=cli-override\",",
                    "    ],",
                    "    { input: \"let x: keyof Y = foo<typeof X>()\" } // typescript",
                    "  ).test({",
                    "    stderr: \"\",",
                    "    status: 0,",
                    "  });",
                    "});"
                ]
            },
            "with-node-modules.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "expect.addSnapshotSerializer(require(\"../path-serializer\"));",
                    "",
                    "describe(\"ignores node_modules by default\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [\"**/*.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"ignores node_modules by with ./**/*.js\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [\"./**/*.js\", \"-l\"]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"doesn't ignore node_modules with --with-node-modules flag\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [",
                    "    \"**/*.js\",",
                    "    \"-l\",",
                    "    \"--with-node-modules\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"ignores node_modules by default for file list\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [",
                    "    \"node_modules/node-module.js\",",
                    "    \"not_node_modules/file.js\",",
                    "    \"nested/node_modules/node-module.js\",",
                    "    \"regular-module.js\",",
                    "    \"-l\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});",
                    "",
                    "describe(\"doesn't ignore node_modules with --with-node-modules flag for file list\", () => {",
                    "  runPrettier(\"cli/with-node-modules\", [",
                    "    \"node_modules/node-module.js\",",
                    "    \"not_node_modules/file.js\",",
                    "    \"nested/node_modules/node-module.js\",",
                    "    \"regular-module.js\",",
                    "    \"-l\",",
                    "    \"--with-node-modules\",",
                    "  ]).test({",
                    "    status: 1,",
                    "  });",
                    "});"
                ]
            },
            "with-parser-inference.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "const prettier = require(\"prettier/local\");",
                    "",
                    "describe(\"infers postcss parser\", () => {",
                    "  runPrettier(\"cli/with-parser-inference\", [\"--end-of-line\", \"lf\", \"*\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"infers postcss parser with --check\", () => {",
                    "  runPrettier(\"cli/with-parser-inference\", [\"--check\", \"*\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"infers postcss parser with --list-different\", () => {",
                    "  runPrettier(\"cli/with-parser-inference\", [\"--list-different\", \"*\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"infers parser from filename\", () => {",
                    "  test(\"json from .prettierrc\", () => {",
                    "    expect(",
                    "      prettier.format(\"  {   }  \", { filepath: \"x/y/.prettierrc\" })",
                    "    ).toEqual(\"{}\\n\");",
                    "  });",
                    "",
                    "  test(\"babel from Jakefile\", () => {",
                    "    expect(",
                    "      prettier.format(\"let foo = ( x = 1 ) => x\", { filepath: \"x/y/Jakefile\" })",
                    "    ).toEqual(\"let foo = (x = 1) => x;\\n\");",
                    "  });",
                    "});"
                ]
            },
            "with-shebang.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"preserves shebang\", () => {",
                    "  runPrettier(\"cli/with-shebang\", [\"--end-of-line\", \"lf\", \"issue1890.js\"]).test(",
                    "    {",
                    "      status: 0,",
                    "    }",
                    "  );",
                    "});"
                ]
            },
            "write.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const runPrettier = require(\"../runPrettier\");",
                    "",
                    "describe(\"write file with --write + unformatted file\", () => {",
                    "  runPrettier(\"cli/write\", [\"--write\", \"unformatted.js\"]).test({",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"do not write file with --write + formatted file\", () => {",
                    "  runPrettier(\"cli/write\", [\"--write\", \"formatted.js\"]).test({",
                    "    write: [],",
                    "    status: 0,",
                    "  });",
                    "});",
                    "",
                    "describe(\"do not write file with --write + invalid file\", () => {",
                    "  runPrettier(\"cli/write\", [\"--write\", \"invalid.js\"]).test({",
                    "    write: [],",
                    "    status: \"non-zero\",",
                    "  });",
                    "});"
                ]
            },
            "__snapshots__": {
                "arg-parsing.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`allow overriding flags (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`allow overriding flags (write) 1`] = `Array []`;",
                        "",
                        "exports[`boolean flags do not swallow the next argument (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`boolean flags do not swallow the next argument (stdout) 1`] = `",
                        "\"console.log('could be single quote and without semi');",
                        "\"",
                        "`;",
                        "",
                        "exports[`boolean flags do not swallow the next argument (write) 1`] = `Array []`;",
                        "",
                        "exports[`negated options work (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`negated options work (stdout) 1`] = `",
                        "\"console.log(\\\\\"could be single quote and without semi\\\\\")",
                        "\"",
                        "`;",
                        "",
                        "exports[`negated options work (write) 1`] = `Array []`;",
                        "",
                        "exports[`unknown negated options are warned (stderr) 1`] = `",
                        "\"[warn] Ignored unknown option --no-unknown.",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown negated options are warned (stdout) 1`] = `",
                        "\"console.log(\\\\\"could be single quote and without semi\\\\\");",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown negated options are warned (write) 1`] = `Array []`;",
                        "",
                        "exports[`unknown options are warned (stderr) 1`] = `",
                        "\"[warn] Ignored unknown option --unknown.",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown options are warned (stdout) 1`] = `",
                        "\"console.log(\\\\\"could be single quote and without semi\\\\\");",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown options are warned (write) 1`] = `Array []`;"
                    ]
                },
                "check.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`--checks works in CI just as in a non-TTY mode (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`--checks works in CI just as in a non-TTY mode (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`--checks works in CI just as in a non-TTY mode (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "unformatted.js",
                        "Code style issues found in the above file(s). Forgot to run Prettier?",
                        "\"",
                        "`;",
                        "",
                        "exports[`--checks works in CI just as in a non-TTY mode (stdout) 2`] = `",
                        "\"Checking formatting...",
                        "unformatted.js",
                        "Code style issues found in the above file(s). Forgot to run Prettier?",
                        "\"",
                        "`;",
                        "",
                        "exports[`--checks works in CI just as in a non-TTY mode (write) 1`] = `Array []`;",
                        "",
                        "exports[`--checks works in CI just as in a non-TTY mode (write) 2`] = `Array []`;",
                        "",
                        "exports[`checks stdin with --check (write) 1`] = `Array []`;",
                        "",
                        "exports[`checks stdin with -c (alias for --check) (write) 1`] = `Array []`;"
                    ]
                },
                "config-invalid.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`resolves external configuration from package.json (stderr) 1`] = `",
                        "\"[error] Invalid configuration file \\`syntax-error.js\\`: THIS ERROR MESSAGE MUST COME FROM THIS syntax-error.js FILE",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves external configuration from package.json (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves external configuration from package.json (write) 1`] = `Array []`;",
                        "",
                        "exports[`show warning with kebab-case option key (stderr) 1`] = `",
                        "\"[warn] Ignored unknown option { \\\\\"print-width\\\\\": 3 }. Did you mean printWidth?",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with kebab-case option key (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`show warning with kebab-case option key (write) 1`] = `Array []`;",
                        "",
                        "exports[`show warning with unknown option (stderr) 1`] = `",
                        "\"[warn] Ignored unknown option { hello: \\\\\"world\\\\\" }.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with unknown option (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`show warning with unknown option (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error for unsupported extension (stderr) 1`] = `",
                        "\"[error] Invalid configuration file \\`<cwd>/tests_integration/cli/config/invalid\\`: No loader specified for extension \\\\\".unsupported\\\\\"",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error for unsupported extension (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error for unsupported extension (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config format (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config format (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config option (int) (stderr) 1`] = `",
                        "\"[error] Invalid tabWidth value. Expected an integer, but received 0.5.",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config option (int) (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config option (int) (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config option (trailingComma) (stderr) 1`] = `",
                        "\"[error] Invalid trailingComma value. Expected \\\\\"all\\\\\", \\\\\"es5\\\\\" or \\\\\"none\\\\\", but received \\\\\"wow\\\\\".",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config option (trailingComma) (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config option (trailingComma) (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config precedence option (configPrecedence) (stderr) 1`] = `",
                        "\"[error] Invalid --config-precedence value. Expected \\\\\"cli-override\\\\\", \\\\\"file-override\\\\\" or \\\\\"prefer-file\\\\\", but received \\\\\"option/configPrecedence\\\\\".",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config precedence option (configPrecedence) (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config precedence option (configPrecedence) (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with invalid config target (directory) (stderr) 1`] = `",
                        "\"[error] Invalid configuration file \\`<cwd>/tests_integration/cli/config/invalid\\`: EISDIR: illegal operation on a directory, read",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid config target (directory) (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid config target (directory) (write) 1`] = `Array []`;"
                    ]
                },
                "config-resolution.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`CLI overrides take precedence (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides take precedence (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(",
                        "\t\t\\\\\"should have tab width 8\\\\\"",
                        "\t)",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2\\\\\"",
                        "  )",
                        "}",
                        "function f() {",
                        "        console.log(",
                        "                \\\\\"should have space width 8\\\\\"",
                        "        )",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\\\\\"",
                        "  )",
                        "}",
                        "console.log(",
                        "  \\\\\"should have no semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/.file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/Component.js should not have semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/Component.test.js should have semi\\\\\"",
                        ");",
                        "function js() {",
                        "        console.log(",
                        "                \\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\"",
                        "        );",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        endOfLine:",
                        "                \\\\\"auto\\\\\",",
                        "        tabWidth: 8,",
                        "};",
                        "function noConfigJs() {",
                        "  console.log(",
                        "    \\\\\"no-config/file.js should have no semicolons\\\\\"",
                        "  )",
                        "}",
                        "function packageJs() {",
                        "   console.log(",
                        "      \\\\\"package/file.js should have tab width 3\\\\\"",
                        "   );",
                        "}",
                        "function rcJson() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-json/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcToml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-toml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcYaml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-yaml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides take precedence (write) 1`] = `Array []`;",
                        "",
                        "exports[`accepts configuration from --config (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`accepts configuration from --config (stdout) 1`] = `",
                        "\"function js() {",
                        " console.log(\\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\")",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`accepts configuration from --config (write) 1`] = `Array []`;",
                        "",
                        "exports[`prints nothing when no file found with --find-config-path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`prints nothing when no file found with --find-config-path (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves configuration file with --find-config-path file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves configuration file with --find-config-path file (stdout) 1`] = `",
                        "\".prettierrc",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves configuration file with --find-config-path file (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves configuration from external files (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves configuration from external files (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(\\\\\"should have tab width 8\\\\\")",
                        "}",
                        "function f() {",
                        "  console.log(\\\\\"should have space width 2\\\\\")",
                        "}",
                        "function f() {",
                        "        console.log(\\\\\"should have space width 8\\\\\")",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\\\\\"",
                        "  )",
                        "}",
                        "console.log(\\\\\"should have no semi\\\\\")",
                        "console.log(\\\\\"jest/__best-tests__/.file.js should have semi\\\\\");",
                        "console.log(\\\\\"jest/__best-tests__/file.js should have semi\\\\\");",
                        "console.log(\\\\\"jest/Component.js should not have semi\\\\\")",
                        "console.log(\\\\\"jest/Component.test.js should have semi\\\\\");",
                        "function js() {",
                        "        console.log(\\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\");",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        endOfLine: \\\\\"auto\\\\\",",
                        "        tabWidth: 8,",
                        "};",
                        "function noConfigJs() {",
                        "  console.log(\\\\\"no-config/file.js should have no semicolons\\\\\")",
                        "}",
                        "function packageJs() {",
                        "   console.log(\\\\\"package/file.js should have tab width 3\\\\\");",
                        "}",
                        "function rcJson() {",
                        "  console.log.apply(null, [",
                        "    'rc-json/file.js',",
                        "    'should have trailing comma',",
                        "    'and single quotes',",
                        "  ]);",
                        "}",
                        "function rcToml() {",
                        "  console.log.apply(null, [",
                        "    'rc-toml/file.js',",
                        "    'should have trailing comma',",
                        "    'and single quotes',",
                        "  ]);",
                        "}",
                        "function rcYaml() {",
                        "  console.log.apply(null, [",
                        "    'rc-yaml/file.js',",
                        "    'should have trailing comma',",
                        "    'and single quotes',",
                        "  ]);",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves configuration from external files (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves configuration from external files and overrides by extname (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves configuration from external files and overrides by extname (stdout) 1`] = `",
                        "\"function noConfigTs() {",
                        "  console.log(",
                        "    \\\\\"no-config/file.ts should have semicolons because it has a .ts extension\\\\\"",
                        "  );",
                        "}",
                        "function packageTs() {",
                        "     console.log(",
                        "          \\\\\"package/file.ts should have tab width 5 because it has .ts extension\\\\\"",
                        "     );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves configuration from external files and overrides by extname (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves external configuration from package.json (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves external configuration from package.json (stdout) 1`] = `",
                        "\"console.log(\\\\\"should have no semi\\\\\")",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves external configuration from package.json (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves json configuration file with --find-config-path file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves json configuration file with --find-config-path file (stdout) 1`] = `",
                        "\"rc-json/.prettierrc.json",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves json configuration file with --find-config-path file (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves toml configuration file with --find-config-path file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves toml configuration file with --find-config-path file (stdout) 1`] = `",
                        "\"rc-toml/.prettierrc.toml",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves toml configuration file with --find-config-path file (write) 1`] = `Array []`;",
                        "",
                        "exports[`resolves yaml configuration file with --find-config-path file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`resolves yaml configuration file with --find-config-path file (stdout) 1`] = `",
                        "\"rc-yaml/.prettierrc.yaml",
                        "\"",
                        "`;",
                        "",
                        "exports[`resolves yaml configuration file with --find-config-path file (write) 1`] = `Array []`;"
                    ]
                },
                "cursor-offset.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`cursorOffset should not be affected by full-width character (stdout) 1`] = `",
                        "\"const x = [",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "  \\\\\"\\\\\",",
                        "];",
                        "\"",
                        "`;",
                        "",
                        "exports[`cursorOffset should not be affected by full-width character (write) 1`] = `Array []`;",
                        "",
                        "exports[`write cursorOffset to stderr with --cursor-offset <int> (stderr) 1`] = `",
                        "\"1",
                        "\"",
                        "`;",
                        "",
                        "exports[`write cursorOffset to stderr with --cursor-offset <int> (stdout) 1`] = `",
                        "\"1;",
                        "\"",
                        "`;",
                        "",
                        "exports[`write cursorOffset to stderr with --cursor-offset <int> (write) 1`] = `Array []`;"
                    ]
                },
                "debug-check.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`checks stdin with --debug-check (write) 1`] = `Array []`;",
                        "",
                        "exports[`doesn't crash when --debug-check is passed (write) 1`] = `Array []`;",
                        "",
                        "exports[`should not exit non-zero for already prettified code with --debug-check + --check (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`should not exit non-zero for already prettified code with --debug-check + --check (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "issue-4599.js",
                        "All matched files use Prettier code style!",
                        "\"",
                        "`;",
                        "",
                        "exports[`should not exit non-zero for already prettified code with --debug-check + --check (write) 1`] = `Array []`;",
                        "",
                        "exports[`should not exit non-zero for already prettified code with --debug-check + --list-different (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`should not exit non-zero for already prettified code with --debug-check + --list-different (stdout) 1`] = `",
                        "\"issue-4599.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`should not exit non-zero for already prettified code with --debug-check + --list-different (write) 1`] = `Array []`;",
                        "",
                        "exports[`show diff for 2+ error files with --debug-check (stderr) 1`] = `",
                        "\"[error] a.debug-check: prettier(input) !== prettier(prettier(input))",
                        "[error] Index: ",
                        "[error] ===================================================================",
                        "[error] --- \t",
                        "[error] +++ \t",
                        "[error] @@ -1,2 +1,4 @@",
                        "[error]  hello",
                        "[error]  hello",
                        "[error] +hello",
                        "[error] +hello",
                        "[error] ",
                        "[error] b.debug-check: prettier(input) !== prettier(prettier(input))",
                        "[error] Index: ",
                        "[error] ===================================================================",
                        "[error] --- \t",
                        "[error] +++ \t",
                        "[error] @@ -1,2 +1,4 @@",
                        "[error]  world",
                        "[error]  world",
                        "[error] +world",
                        "[error] +world",
                        "[error] ",
                        "\"",
                        "`;",
                        "",
                        "exports[`show diff for 2+ error files with --debug-check (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`show diff for 2+ error files with --debug-check (write) 1`] = `Array []`;"
                    ]
                },
                "debug-print-doc.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`prints doc with --debug-print-doc (write) 1`] = `Array []`;"
                    ]
                },
                "early-exit.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`node version error (stderr) 1`] = `",
                        "\"prettier requires at least version 10.13.0 of Node, please upgrade",
                        "\"",
                        "`;",
                        "",
                        "exports[`node version error (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`node version error (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help l (alias) (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help l (alias) (stdout) 1`] = `",
                        "\"-l, --list-different",
                        "",
                        "  Print the names of files that are different from Prettier's formatting (see also --check).",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help l (alias) (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with plugin options (automatic resolution) (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with plugin options (automatic resolution) (stdout) 1`] = `",
                        "\"--tab-width <int>",
                        "",
                        "  Number of spaces per indentation level.",
                        "",
                        "Default: 2",
                        "Plugin defaults:",
                        "* prettier-plugin-bar: 4",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with plugin options (automatic resolution) (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with plugin options (manual resolution) (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with plugin options (manual resolution) (stdout) 1`] = `",
                        "\"--tab-width <int>",
                        "",
                        "  Number of spaces per indentation level.",
                        "",
                        "Default: 2",
                        "Plugin defaults:",
                        "* ../plugins/automatic/node_modules/prettier-plugin-bar: 4",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with plugin options (manual resolution) (write) 1`] = `Array []`;",
                        "",
                        "exports[`show usage with --help (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show usage with --help (stdout) 1`] = `",
                        "\"Usage: prettier [options] [file/dir/glob ...]",
                        "",
                        "By default, output is written to stdout.",
                        "Stdin is read if it is piped to Prettier and no files are given.",
                        "",
                        "Output options:",
                        "",
                        "  -c, --check              Check if the given files are formatted, print a human-friendly summary",
                        "                           message and paths to unformatted files (see also --list-different).",
                        "  -l, --list-different     Print the names of files that are different from Prettier's formatting (see also --check).",
                        "  --write                  Edit files in-place. (Beware!)",
                        "",
                        "Format options:",
                        "",
                        "  --arrow-parens <always|avoid>",
                        "                           Include parentheses around a sole arrow function parameter.",
                        "                           Defaults to always.",
                        "  --no-bracket-spacing     Do not print spaces between brackets.",
                        "  --embedded-language-formatting <auto|off>",
                        "                           Control how Prettier formats quoted code embedded in the file.",
                        "                           Defaults to auto.",
                        "  --end-of-line <lf|crlf|cr|auto>",
                        "                           Which end of line characters to apply.",
                        "                           Defaults to lf.",
                        "  --html-whitespace-sensitivity <css|strict|ignore>",
                        "                           How to handle whitespaces in HTML.",
                        "                           Defaults to css.",
                        "  --jsx-bracket-same-line  Put > on the last line instead of at a new line.",
                        "                           Defaults to false.",
                        "  --jsx-single-quote       Use single quotes in JSX.",
                        "                           Defaults to false.",
                        "  --parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc>",
                        "                           Which parser to use.",
                        "  --print-width <int>      The line length where Prettier will try wrap.",
                        "                           Defaults to 80.",
                        "  --prose-wrap <always|never|preserve>",
                        "                           How to wrap prose.",
                        "                           Defaults to preserve.",
                        "  --quote-props <as-needed|consistent|preserve>",
                        "                           Change when properties in objects are quoted.",
                        "                           Defaults to as-needed.",
                        "  --no-semi                Do not print semicolons, except at the beginning of lines which may need them.",
                        "  --single-quote           Use single quotes instead of double quotes.",
                        "                           Defaults to false.",
                        "  --tab-width <int>        Number of spaces per indentation level.",
                        "                           Defaults to 2.",
                        "  --trailing-comma <es5|none|all>",
                        "                           Print trailing commas wherever possible when multi-line.",
                        "                           Defaults to es5.",
                        "  --use-tabs               Indent with tabs instead of spaces.",
                        "                           Defaults to false.",
                        "  --vue-indent-script-and-style",
                        "                           Indent script and style tags in Vue files.",
                        "                           Defaults to false.",
                        "",
                        "Config options:",
                        "",
                        "  --config <path>          Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).",
                        "  --no-config              Do not look for a configuration file.",
                        "  --config-precedence <cli-override|file-override|prefer-file>",
                        "                           Define in which order config files and CLI options should be evaluated.",
                        "                           Defaults to cli-override.",
                        "  --no-editorconfig        Don't take .editorconfig into account when parsing configuration.",
                        "  --find-config-path <path>",
                        "                           Find and print the path to a configuration file for the given input file.",
                        "  --ignore-path <path>     Path to a file with patterns describing files to ignore.",
                        "                           Defaults to .prettierignore.",
                        "  --plugin <path>          Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.",
                        "                           Defaults to [].",
                        "  --plugin-search-dir <path>",
                        "                           Custom directory that contains prettier plugins in node_modules subdirectory.",
                        "                           Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                        "                           Multiple values are accepted.",
                        "                           Defaults to [].",
                        "  --with-node-modules      Process files inside 'node_modules' directory.",
                        "",
                        "Editor options:",
                        "",
                        "  --cursor-offset <int>    Print (to stderr) where a cursor at the given position would move to after formatting.",
                        "                           This option cannot be used with --range-start and --range-end.",
                        "                           Defaults to -1.",
                        "  --range-end <int>        Format code ending at a given character offset (exclusive).",
                        "                           The range will extend forwards to the end of the selected statement.",
                        "                           This option cannot be used with --cursor-offset.",
                        "                           Defaults to Infinity.",
                        "  --range-start <int>      Format code starting at a given character offset.",
                        "                           The range will extend backwards to the start of the first line containing the selected statement.",
                        "                           This option cannot be used with --cursor-offset.",
                        "                           Defaults to 0.",
                        "",
                        "Other options:",
                        "",
                        "  --no-color               Do not colorize error messages.",
                        "  --file-info <path>       Extract the following info (as JSON) for a given file path. Reported fields:",
                        "                           * ignored (boolean) - true if file path is filtered by --ignore-path",
                        "                           * inferredParser (string | null) - name of parser inferred from file path",
                        "  -h, --help <flag>        Show CLI usage, or details about the given flag.",
                        "                           Example: --help write",
                        "  --insert-pragma          Insert @format pragma into file's first docblock comment.",
                        "                           Defaults to false.",
                        "  --loglevel <silent|error|warn|log|debug>",
                        "                           What level of logs to report.",
                        "                           Defaults to log.",
                        "  --require-pragma         Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                        "                           in order for it to be formatted.",
                        "                           Defaults to false.",
                        "  --stdin-filepath <path>  Path to the file to pretend that stdin comes from.",
                        "  --support-info           Print support information as JSON.",
                        "  -v, --version            Print Prettier version.",
                        "",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`show usage with --help (write) 1`] = `Array []`;",
                        "",
                        "exports[`show version with --version (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show version with --version (write) 1`] = `Array []`;",
                        "",
                        "exports[`show warning with --help not-found (typo) (stderr) 1`] = `",
                        "\"[warn] Unknown flag \\\\\"parserr\\\\\", did you mean \\\\\"parser\\\\\"?",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with --help not-found (typo) (stdout) 1`] = `",
                        "\"--parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc>",
                        "",
                        "  Which parser to use.",
                        "",
                        "Valid options:",
                        "",
                        "  flow             Flow",
                        "  babel            JavaScript",
                        "  babel-flow       Flow",
                        "  babel-ts         TypeScript",
                        "  typescript       TypeScript",
                        "  css              CSS",
                        "  less             Less",
                        "  scss             SCSS",
                        "  json             JSON",
                        "  json5            JSON5",
                        "  json-stringify   JSON.stringify",
                        "  graphql          GraphQL",
                        "  markdown         Markdown",
                        "  mdx              MDX",
                        "  vue              Vue",
                        "  yaml             YAML",
                        "  html             HTML",
                        "  angular          Angular",
                        "  lwc              Lightning Web Components",
                        "\"",
                        "`;",
                        "",
                        "exports[`show warning with --help not-found (typo) (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error and show usage with something unexpected (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error and show usage with something unexpected (stdout) 1`] = `",
                        "\"Usage: prettier [options] [file/dir/glob ...]",
                        "",
                        "By default, output is written to stdout.",
                        "Stdin is read if it is piped to Prettier and no files are given.",
                        "",
                        "Output options:",
                        "",
                        "  -c, --check              Check if the given files are formatted, print a human-friendly summary",
                        "                           message and paths to unformatted files (see also --list-different).",
                        "  -l, --list-different     Print the names of files that are different from Prettier's formatting (see also --check).",
                        "  --write                  Edit files in-place. (Beware!)",
                        "",
                        "Format options:",
                        "",
                        "  --arrow-parens <always|avoid>",
                        "                           Include parentheses around a sole arrow function parameter.",
                        "                           Defaults to always.",
                        "  --no-bracket-spacing     Do not print spaces between brackets.",
                        "  --embedded-language-formatting <auto|off>",
                        "                           Control how Prettier formats quoted code embedded in the file.",
                        "                           Defaults to auto.",
                        "  --end-of-line <lf|crlf|cr|auto>",
                        "                           Which end of line characters to apply.",
                        "                           Defaults to lf.",
                        "  --html-whitespace-sensitivity <css|strict|ignore>",
                        "                           How to handle whitespaces in HTML.",
                        "                           Defaults to css.",
                        "  --jsx-bracket-same-line  Put > on the last line instead of at a new line.",
                        "                           Defaults to false.",
                        "  --jsx-single-quote       Use single quotes in JSX.",
                        "                           Defaults to false.",
                        "  --parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc>",
                        "                           Which parser to use.",
                        "  --print-width <int>      The line length where Prettier will try wrap.",
                        "                           Defaults to 80.",
                        "  --prose-wrap <always|never|preserve>",
                        "                           How to wrap prose.",
                        "                           Defaults to preserve.",
                        "  --quote-props <as-needed|consistent|preserve>",
                        "                           Change when properties in objects are quoted.",
                        "                           Defaults to as-needed.",
                        "  --no-semi                Do not print semicolons, except at the beginning of lines which may need them.",
                        "  --single-quote           Use single quotes instead of double quotes.",
                        "                           Defaults to false.",
                        "  --tab-width <int>        Number of spaces per indentation level.",
                        "                           Defaults to 2.",
                        "  --trailing-comma <es5|none|all>",
                        "                           Print trailing commas wherever possible when multi-line.",
                        "                           Defaults to es5.",
                        "  --use-tabs               Indent with tabs instead of spaces.",
                        "                           Defaults to false.",
                        "  --vue-indent-script-and-style",
                        "                           Indent script and style tags in Vue files.",
                        "                           Defaults to false.",
                        "",
                        "Config options:",
                        "",
                        "  --config <path>          Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).",
                        "  --no-config              Do not look for a configuration file.",
                        "  --config-precedence <cli-override|file-override|prefer-file>",
                        "                           Define in which order config files and CLI options should be evaluated.",
                        "                           Defaults to cli-override.",
                        "  --no-editorconfig        Don't take .editorconfig into account when parsing configuration.",
                        "  --find-config-path <path>",
                        "                           Find and print the path to a configuration file for the given input file.",
                        "  --ignore-path <path>     Path to a file with patterns describing files to ignore.",
                        "                           Defaults to .prettierignore.",
                        "  --plugin <path>          Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.",
                        "                           Defaults to [].",
                        "  --plugin-search-dir <path>",
                        "                           Custom directory that contains prettier plugins in node_modules subdirectory.",
                        "                           Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                        "                           Multiple values are accepted.",
                        "                           Defaults to [].",
                        "  --with-node-modules      Process files inside 'node_modules' directory.",
                        "",
                        "Editor options:",
                        "",
                        "  --cursor-offset <int>    Print (to stderr) where a cursor at the given position would move to after formatting.",
                        "                           This option cannot be used with --range-start and --range-end.",
                        "                           Defaults to -1.",
                        "  --range-end <int>        Format code ending at a given character offset (exclusive).",
                        "                           The range will extend forwards to the end of the selected statement.",
                        "                           This option cannot be used with --cursor-offset.",
                        "                           Defaults to Infinity.",
                        "  --range-start <int>      Format code starting at a given character offset.",
                        "                           The range will extend backwards to the start of the first line containing the selected statement.",
                        "                           This option cannot be used with --cursor-offset.",
                        "                           Defaults to 0.",
                        "",
                        "Other options:",
                        "",
                        "  --no-color               Do not colorize error messages.",
                        "  --file-info <path>       Extract the following info (as JSON) for a given file path. Reported fields:",
                        "                           * ignored (boolean) - true if file path is filtered by --ignore-path",
                        "                           * inferredParser (string | null) - name of parser inferred from file path",
                        "  -h, --help <flag>        Show CLI usage, or details about the given flag.",
                        "                           Example: --help write",
                        "  --insert-pragma          Insert @format pragma into file's first docblock comment.",
                        "                           Defaults to false.",
                        "  --loglevel <silent|error|warn|log|debug>",
                        "                           What level of logs to report.",
                        "                           Defaults to log.",
                        "  --require-pragma         Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                        "                           in order for it to be formatted.",
                        "                           Defaults to false.",
                        "  --stdin-filepath <path>  Path to the file to pretend that stdin comes from.",
                        "  --support-info           Print support information as JSON.",
                        "  -v, --version            Print Prettier version.",
                        "",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error and show usage with something unexpected (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with --check + --list-different (stderr) 1`] = `",
                        "\"[error] Cannot use --check and --list-different together.",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with --check + --list-different (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with --check + --list-different (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with --file-info + multiple files (stderr) 1`] = `",
                        "\"[error] Cannot use --file-info with multiple files",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with --file-info + multiple files (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with --file-info + multiple files (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with --find-config-path + multiple files (stderr) 1`] = `",
                        "\"[error] Cannot use --find-config-path with multiple files",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with --find-config-path + multiple files (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with --find-config-path + multiple files (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with --help not-found (stderr) 1`] = `",
                        "\"[error] Invalid --help value. Expected a flag, but received \\\\\"not-found\\\\\".",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with --help not-found (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with --help not-found (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error with --write + --debug-check (stderr) 1`] = `",
                        "\"[error] Cannot use --write and --debug-check together.",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with --write + --debug-check (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with --write + --debug-check (write) 1`] = `Array []`;"
                    ]
                },
                "file-info.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`extracts file-info for a file in not_node_modules (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info for a file in not_node_modules (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": \\\\\"babel\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info for a file in not_node_modules (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info for a js file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info for a js file (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": \\\\\"babel\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info for a js file (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info for a known markdown file with no extension (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info for a known markdown file with no extension (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": \\\\\"markdown\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info for a known markdown file with no extension (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info for a markdown file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info for a markdown file (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": \\\\\"markdown\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info for a markdown file (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info with ignored=false for a file in node_modules when --with-node-modules provided (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info with ignored=false for a file in node_modules when --with-node-modules provided (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": \\\\\"babel\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info with ignored=false for a file in node_modules when --with-node-modules provided (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info with ignored=true for a file in .prettierignore (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info with ignored=true for a file in .prettierignore (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": true, \\\\\"inferredParser\\\\\": \\\\\"babel\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info with ignored=true for a file in .prettierignore (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info with ignored=true for a file in a hand-picked .prettierignore (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info with ignored=true for a file in a hand-picked .prettierignore (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": true, \\\\\"inferredParser\\\\\": \\\\\"babel\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info with ignored=true for a file in a hand-picked .prettierignore (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when a plugin is hand-picked (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when a plugin is hand-picked (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": \\\\\"foo\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when a plugin is hand-picked (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when plugins are autoloaded (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when plugins are autoloaded (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": \\\\\"foo\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when plugins are autoloaded (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when plugins are loaded with --plugin-search-dir (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when plugins are loaded with --plugin-search-dir (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": \\\\\"foo\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info with inferredParser=foo when plugins are loaded with --plugin-search-dir (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info with inferredParser=null for file.foo (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info with inferredParser=null for file.foo (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": false, \\\\\"inferredParser\\\\\": null }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info with inferredParser=null for file.foo (write) 1`] = `Array []`;",
                        "",
                        "exports[`extracts file-info with with ignored=true for a file in node_modules (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`extracts file-info with with ignored=true for a file in node_modules (stdout) 1`] = `",
                        "\"{ \\\\\"ignored\\\\\": true, \\\\\"inferredParser\\\\\": \\\\\"babel\\\\\" }",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`extracts file-info with with ignored=true for a file in node_modules (write) 1`] = `Array []`;"
                    ]
                },
                "format.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`'Adjacent JSX' error should not be swallowed by Babel's error recovery 1`] = `",
                        "\"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>? (2:1)",
                        "  1 | <a></a>",
                        "> 2 | <b></b>",
                        "    | ^\"",
                        "`;",
                        "",
                        "exports[`html parser should handle CRLF correctly 1`] = `\"\\\\\"<!--\\\\\\\\r\\\\\\\\n  test\\\\\\\\r\\\\\\\\n  test\\\\\\\\r\\\\\\\\n-->\\\\\\\\r\\\\\\\\n\\\\\"\"`;",
                        "",
                        "exports[`markdown parser should handle CRLF correctly 1`] = `\"\\\\\"\\`\\`\\`\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\\\\\\\r\\\\\\\\n\\`\\`\\`\\\\\\\\r\\\\\\\\n\\\\\"\"`;",
                        "",
                        "exports[`typescript parser should throw the first error when both JSX and non-JSX mode failed 1`] = `",
                        "\"Expression expected. (9:7)",
                        "   7 | );",
                        "   8 | ",
                        ">  9 | label:",
                        "     |       ^",
                        "  10 |   \"",
                        "`;",
                        "",
                        "exports[`yaml parser should handle CRLF correctly 1`] = `\"\\\\\"a: 123\\\\\\\\r\\\\\\\\n\\\\\"\"`;"
                    ]
                },
                "help-options.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`show detailed usage with --help arrow-parens (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help arrow-parens (stdout) 1`] = `",
                        "\"--arrow-parens <always|avoid>",
                        "",
                        "  Include parentheses around a sole arrow function parameter.",
                        "",
                        "Valid options:",
                        "",
                        "  always   Always include parens. Example: \\`(x) => x\\`",
                        "  avoid    Omit parens when possible. Example: \\`x => x\\`",
                        "",
                        "Default: always",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help arrow-parens (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help bracket-spacing (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help bracket-spacing (stdout) 1`] = `",
                        "\"--bracket-spacing",
                        "",
                        "  Print spaces between brackets.",
                        "",
                        "Default: true",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help bracket-spacing (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help check (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help check (stdout) 1`] = `",
                        "\"-c, --check",
                        "",
                        "  Check if the given files are formatted, print a human-friendly summary",
                        "  message and paths to unformatted files (see also --list-different).",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help check (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help color (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help color (stdout) 1`] = `",
                        "\"--color",
                        "",
                        "  Colorize error messages.",
                        "",
                        "Default: true",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help color (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help config (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help config (stdout) 1`] = `",
                        "\"--config <path>",
                        "",
                        "  Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help config (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help config-precedence (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help config-precedence (stdout) 1`] = `",
                        "\"--config-precedence <cli-override|file-override|prefer-file>",
                        "",
                        "  Define in which order config files and CLI options should be evaluated.",
                        "",
                        "Valid options:",
                        "",
                        "  cli-override    CLI options take precedence over config file",
                        "  file-override   Config file take precedence over CLI options",
                        "  prefer-file     If a config file is found will evaluate it and ignore other CLI options.",
                        "                  If no config file is found CLI options will evaluate as normal.",
                        "",
                        "Default: cli-override",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help config-precedence (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help cursor-offset (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help cursor-offset (stdout) 1`] = `",
                        "\"--cursor-offset <int>",
                        "",
                        "  Print (to stderr) where a cursor at the given position would move to after formatting.",
                        "  This option cannot be used with --range-start and --range-end.",
                        "",
                        "Default: -1",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help cursor-offset (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help editorconfig (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help editorconfig (stdout) 1`] = `",
                        "\"--editorconfig",
                        "",
                        "  Take .editorconfig into account when parsing configuration.",
                        "",
                        "Default: true",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help editorconfig (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help embedded-language-formatting (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help embedded-language-formatting (stdout) 1`] = `",
                        "\"--embedded-language-formatting <auto|off>",
                        "",
                        "  Control how Prettier formats quoted code embedded in the file.",
                        "",
                        "Valid options:",
                        "",
                        "  auto   Format embedded code if Prettier can automatically identify it.",
                        "  off    Never automatically format embedded code.",
                        "",
                        "Default: auto",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help embedded-language-formatting (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help end-of-line (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help end-of-line (stdout) 1`] = `",
                        "\"--end-of-line <lf|crlf|cr|auto>",
                        "",
                        "  Which end of line characters to apply.",
                        "",
                        "Valid options:",
                        "",
                        "  lf     Line Feed only (\\\\\\\\n), common on Linux and macOS as well as inside git repos",
                        "  crlf   Carriage Return + Line Feed characters (\\\\\\\\r\\\\\\\\n), common on Windows",
                        "  cr     Carriage Return character only (\\\\\\\\r), used very rarely",
                        "  auto   Maintain existing",
                        "         (mixed values within one file are normalised by looking at what's used after the first line)",
                        "",
                        "Default: lf",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help end-of-line (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help file-info (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help file-info (stdout) 1`] = `",
                        "\"--file-info <path>",
                        "",
                        "  Extract the following info (as JSON) for a given file path. Reported fields:",
                        "  * ignored (boolean) - true if file path is filtered by --ignore-path",
                        "  * inferredParser (string | null) - name of parser inferred from file path",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help file-info (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help find-config-path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help find-config-path (stdout) 1`] = `",
                        "\"--find-config-path <path>",
                        "",
                        "  Find and print the path to a configuration file for the given input file.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help find-config-path (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help help (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help help (stdout) 1`] = `",
                        "\"-h, --help <flag>",
                        "",
                        "  Show CLI usage, or details about the given flag.",
                        "  Example: --help write",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help help (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help html-whitespace-sensitivity (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help html-whitespace-sensitivity (stdout) 1`] = `",
                        "\"--html-whitespace-sensitivity <css|strict|ignore>",
                        "",
                        "  How to handle whitespaces in HTML.",
                        "",
                        "Valid options:",
                        "",
                        "  css      Respect the default value of CSS display property.",
                        "  strict   Whitespaces are considered sensitive.",
                        "  ignore   Whitespaces are considered insensitive.",
                        "",
                        "Default: css",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help html-whitespace-sensitivity (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help ignore-path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help ignore-path (stdout) 1`] = `",
                        "\"--ignore-path <path>",
                        "",
                        "  Path to a file with patterns describing files to ignore.",
                        "",
                        "Default: .prettierignore",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help ignore-path (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help insert-pragma (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help insert-pragma (stdout) 1`] = `",
                        "\"--insert-pragma",
                        "",
                        "  Insert @format pragma into file's first docblock comment.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help insert-pragma (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help jsx-bracket-same-line (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help jsx-bracket-same-line (stdout) 1`] = `",
                        "\"--jsx-bracket-same-line",
                        "",
                        "  Put > on the last line instead of at a new line.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help jsx-bracket-same-line (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help jsx-single-quote (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help jsx-single-quote (stdout) 1`] = `",
                        "\"--jsx-single-quote",
                        "",
                        "  Use single quotes in JSX.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help jsx-single-quote (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help list-different (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help list-different (stdout) 1`] = `",
                        "\"-l, --list-different",
                        "",
                        "  Print the names of files that are different from Prettier's formatting (see also --check).",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help list-different (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help loglevel (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help loglevel (stdout) 1`] = `",
                        "\"--loglevel <silent|error|warn|log|debug>",
                        "",
                        "  What level of logs to report.",
                        "",
                        "Valid options:",
                        "",
                        "  silent   ",
                        "  error    ",
                        "  warn     ",
                        "  log      ",
                        "  debug    ",
                        "",
                        "Default: log",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help loglevel (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-bracket-spacing (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-bracket-spacing (stdout) 1`] = `",
                        "\"--no-bracket-spacing",
                        "",
                        "  Do not print spaces between brackets.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-bracket-spacing (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-color (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-color (stdout) 1`] = `",
                        "\"--no-color",
                        "",
                        "  Do not colorize error messages.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-color (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-config (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-config (stdout) 1`] = `",
                        "\"--no-config",
                        "",
                        "  Do not look for a configuration file.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-config (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-editorconfig (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-editorconfig (stdout) 1`] = `",
                        "\"--no-editorconfig",
                        "",
                        "  Don't take .editorconfig into account when parsing configuration.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-editorconfig (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help no-semi (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help no-semi (stdout) 1`] = `",
                        "\"--no-semi",
                        "",
                        "  Do not print semicolons, except at the beginning of lines which may need them.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help no-semi (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help parser (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help parser (stdout) 1`] = `",
                        "\"--parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc>",
                        "",
                        "  Which parser to use.",
                        "",
                        "Valid options:",
                        "",
                        "  flow             Flow",
                        "  babel            JavaScript",
                        "  babel-flow       Flow",
                        "  babel-ts         TypeScript",
                        "  typescript       TypeScript",
                        "  css              CSS",
                        "  less             Less",
                        "  scss             SCSS",
                        "  json             JSON",
                        "  json5            JSON5",
                        "  json-stringify   JSON.stringify",
                        "  graphql          GraphQL",
                        "  markdown         Markdown",
                        "  mdx              MDX",
                        "  vue              Vue",
                        "  yaml             YAML",
                        "  html             HTML",
                        "  angular          Angular",
                        "  lwc              Lightning Web Components",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help parser (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help plugin (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help plugin (stdout) 1`] = `",
                        "\"--plugin <path>",
                        "",
                        "  Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.",
                        "",
                        "Default: []",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help plugin (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help plugin-search-dir (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help plugin-search-dir (stdout) 1`] = `",
                        "\"--plugin-search-dir <path>",
                        "",
                        "  Custom directory that contains prettier plugins in node_modules subdirectory.",
                        "  Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                        "  Multiple values are accepted.",
                        "",
                        "Default: []",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help plugin-search-dir (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help print-width (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help print-width (stdout) 1`] = `",
                        "\"--print-width <int>",
                        "",
                        "  The line length where Prettier will try wrap.",
                        "",
                        "Default: 80",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help print-width (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help prose-wrap (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help prose-wrap (stdout) 1`] = `",
                        "\"--prose-wrap <always|never|preserve>",
                        "",
                        "  How to wrap prose.",
                        "",
                        "Valid options:",
                        "",
                        "  always     Wrap prose if it exceeds the print width.",
                        "  never      Do not wrap prose.",
                        "  preserve   Wrap prose as-is.",
                        "",
                        "Default: preserve",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help prose-wrap (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help quote-props (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help quote-props (stdout) 1`] = `",
                        "\"--quote-props <as-needed|consistent|preserve>",
                        "",
                        "  Change when properties in objects are quoted.",
                        "",
                        "Valid options:",
                        "",
                        "  as-needed    Only add quotes around object properties where required.",
                        "  consistent   If at least one property in an object requires quotes, quote all properties.",
                        "  preserve     Respect the input use of quotes in object properties.",
                        "",
                        "Default: as-needed",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help quote-props (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help range-end (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help range-end (stdout) 1`] = `",
                        "\"--range-end <int>",
                        "",
                        "  Format code ending at a given character offset (exclusive).",
                        "  The range will extend forwards to the end of the selected statement.",
                        "  This option cannot be used with --cursor-offset.",
                        "",
                        "Default: Infinity",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help range-end (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help range-start (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help range-start (stdout) 1`] = `",
                        "\"--range-start <int>",
                        "",
                        "  Format code starting at a given character offset.",
                        "  The range will extend backwards to the start of the first line containing the selected statement.",
                        "  This option cannot be used with --cursor-offset.",
                        "",
                        "Default: 0",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help range-start (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help require-pragma (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help require-pragma (stdout) 1`] = `",
                        "\"--require-pragma",
                        "",
                        "  Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                        "  in order for it to be formatted.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help require-pragma (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help semi (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help semi (stdout) 1`] = `",
                        "\"--semi",
                        "",
                        "  Print semicolons.",
                        "",
                        "Default: true",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help semi (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help single-quote (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help single-quote (stdout) 1`] = `",
                        "\"--single-quote",
                        "",
                        "  Use single quotes instead of double quotes.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help single-quote (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help stdin-filepath (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help stdin-filepath (stdout) 1`] = `",
                        "\"--stdin-filepath <path>",
                        "",
                        "  Path to the file to pretend that stdin comes from.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help stdin-filepath (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help support-info (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help support-info (stdout) 1`] = `",
                        "\"--support-info",
                        "",
                        "  Print support information as JSON.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help support-info (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help tab-width (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help tab-width (stdout) 1`] = `",
                        "\"--tab-width <int>",
                        "",
                        "  Number of spaces per indentation level.",
                        "",
                        "Default: 2",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help tab-width (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help trailing-comma (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help trailing-comma (stdout) 1`] = `",
                        "\"--trailing-comma <es5|none|all>",
                        "",
                        "  Print trailing commas wherever possible when multi-line.",
                        "",
                        "Valid options:",
                        "",
                        "  es5    Trailing commas where valid in ES5 (objects, arrays, etc.)",
                        "  none   No trailing commas.",
                        "  all    Trailing commas wherever possible (including function arguments).",
                        "",
                        "Default: es5",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help trailing-comma (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help use-tabs (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help use-tabs (stdout) 1`] = `",
                        "\"--use-tabs",
                        "",
                        "  Indent with tabs instead of spaces.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help use-tabs (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help version (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help version (stdout) 1`] = `",
                        "\"-v, --version",
                        "",
                        "  Print Prettier version.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help version (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help vue-indent-script-and-style (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help vue-indent-script-and-style (stdout) 1`] = `",
                        "\"--vue-indent-script-and-style",
                        "",
                        "  Indent script and style tags in Vue files.",
                        "",
                        "Default: false",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help vue-indent-script-and-style (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help with-node-modules (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help with-node-modules (stdout) 1`] = `",
                        "\"--with-node-modules",
                        "",
                        "  Process files inside 'node_modules' directory.",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help with-node-modules (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed usage with --help write (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed usage with --help write (stdout) 1`] = `",
                        "\"--write",
                        "",
                        "  Edit files in-place. (Beware!)",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed usage with --help write (write) 1`] = `Array []`;"
                    ]
                },
                "ignore-absolute-path.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`support absolute filename (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`support absolute filename (stdout) 1`] = `",
                        "\"regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`support absolute filename (write) 1`] = `Array []`;"
                    ]
                },
                "ignore-emoji.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`ignores file name contains emoji (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores file name contains emoji (stdout) 1`] = `",
                        "\"not-ignored.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignores file name contains emoji (write) 1`] = `Array []`;",
                        "",
                        "exports[`stdin (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`stdin (stdout) 1`] = `\".name {                         display: none; }\"`;",
                        "",
                        "exports[`stdin (write) 1`] = `Array []`;"
                    ]
                },
                "ignore-in-subdirectories.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`formats files when executing in a subdirectory (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`formats files when executing in a subdirectory (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`formats files when executing in a subdirectory (stdout) 1`] = `",
                        "\"should-not-ignore.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`formats files when executing in a subdirectory (stdout) 2`] = `",
                        "\"should-not-ignore.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`formats files when executing in a subdirectory (write) 1`] = `Array []`;",
                        "",
                        "exports[`formats files when executing in a subdirectory (write) 2`] = `Array []`;",
                        "",
                        "exports[`formats files when executing in a subdirectory and using stdin (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`formats files when executing in a subdirectory and using stdin (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignore files when executing in a subdirectory and using stdin (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignore files when executing in a subdirectory and using stdin (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignores files when executing in a subdirectory (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores files when executing in a subdirectory (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`ignores files when executing in a subdirectory (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores files when executing in a subdirectory (stdout) 2`] = `\"\"`;",
                        "",
                        "exports[`ignores files when executing in a subdirectory (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignores files when executing in a subdirectory (write) 2`] = `Array []`;"
                    ]
                },
                "ignore-path.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`ignore file when using --debug-check (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignore file when using --debug-check (stdout) 1`] = `",
                        "\"other-regular-modules.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignore file when using --debug-check (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignore path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignore path (stdout) 1`] = `",
                        "\"regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignore path (write) 1`] = `Array []`;",
                        "",
                        "exports[`outputs files as-is if no --write (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`outputs files as-is if no --write (stdout) 1`] = `",
                        "\"'use strict';",
                        "\"",
                        "`;",
                        "",
                        "exports[`outputs files as-is if no --write (write) 1`] = `Array []`;",
                        "",
                        "exports[`support .prettierignore (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`support .prettierignore (stdout) 1`] = `",
                        "\"other-regular-modules.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`support .prettierignore (write) 1`] = `Array []`;"
                    ]
                },
                "ignore-relative-path.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`support relative paths (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`support relative paths (stdout) 1`] = `",
                        "\"shouldNotBeIgnored.js",
                        "level1-glob/level2-glob/level3-glob/shouldNotBeIgnored.scss",
                        "level1-glob/shouldNotBeIgnored.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`support relative paths (write) 1`] = `Array []`;"
                    ]
                },
                "ignore-vcs-files.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`ignores files in version control systems (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores files in version control systems (stdout) 1`] = `",
                        "\"file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignores files in version control systems (write) 1`] = `Array []`;"
                    ]
                },
                "infer-parser.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`--check with unknown path and no parser multiple files (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--check with unknown path and no parser multiple files (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "foo.js",
                        "Code style issues found in the above file(s). Forgot to run Prettier?",
                        "\"",
                        "`;",
                        "",
                        "exports[`--check with unknown path and no parser specific file (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--check with unknown path and no parser specific file (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "All matched files use Prettier code style!",
                        "\"",
                        "`;",
                        "",
                        "exports[`--list-different with unknown path and no parser multiple files (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--list-different with unknown path and no parser specific file (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write and --check with unknown path and no parser multiple files (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write and --check with unknown path and no parser multiple files (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "foo.js",
                        "Code style issues fixed in the above file(s).",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write and --check with unknown path and no parser multiple files (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"foo();",
                        "\",",
                        "    \"filename\": \"foo.js\",",
                        "  },",
                        "]",
                        "`;",
                        "",
                        "exports[`--write and --check with unknown path and no parser specific file (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write and --check with unknown path and no parser specific file (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "All matched files use Prettier code style!",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write and --list-different with unknown path and no parser multiple files (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write and --list-different with unknown path and no parser multiple files (stdout) 1`] = `",
                        "\"foo.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write and --list-different with unknown path and no parser multiple files (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"foo();",
                        "\",",
                        "    \"filename\": \"foo.js\",",
                        "  },",
                        "]",
                        "`;",
                        "",
                        "exports[`--write and --list-different with unknown path and no parser specific file (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write with unknown path and no parser multiple files (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write with unknown path and no parser multiple files (stdout) 1`] = `",
                        "\"foo.js 0ms",
                        "\"",
                        "`;",
                        "",
                        "exports[`--write with unknown path and no parser multiple files (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"foo();",
                        "\",",
                        "    \"filename\": \"foo.js\",",
                        "  },",
                        "]",
                        "`;",
                        "",
                        "exports[`--write with unknown path and no parser specific file (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`API with no path and no parser prettier.check 1`] = `",
                        "Array [",
                        "  \"No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.\",",
                        "]",
                        "`;",
                        "",
                        "exports[`API with no path and no parser prettier.format 1`] = `",
                        "Array [",
                        "  \"No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.\",",
                        "]",
                        "`;",
                        "",
                        "exports[`stdin no path and no parser --check logs error but exits with 0 (stderr) 1`] = `",
                        "\"[error] No parser and no file path given, couldn't infer a parser.",
                        "\"",
                        "`;",
                        "",
                        "exports[`stdin no path and no parser --list-different logs error but exits with 0 (stderr) 1`] = `",
                        "\"[error] No parser and no file path given, couldn't infer a parser.",
                        "\"",
                        "`;",
                        "",
                        "exports[`stdin no path and no parser logs error and exits with 2 (stderr) 1`] = `",
                        "\"[error] No parser and no file path given, couldn't infer a parser.",
                        "\"",
                        "`;",
                        "",
                        "exports[`stdin with unknown path and no parser --check logs error but exits with 0 (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: foo",
                        "\"",
                        "`;",
                        "",
                        "exports[`stdin with unknown path and no parser --list-different logs error but exits with 0 (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: foo",
                        "\"",
                        "`;",
                        "",
                        "exports[`stdin with unknown path and no parser logs error and exits with 2 (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: foo",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown path and no parser multiple files (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown path and no parser multiple files (stdout) 1`] = `",
                        "\"foo();",
                        "\"",
                        "`;",
                        "",
                        "exports[`unknown path and no parser specific file (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: FOO",
                        "\"",
                        "`;"
                    ]
                },
                "invalid-ignore.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`throw error with invalid ignore (stderr) 1`] = `",
                        "\"[error] Unable to read <cwd>/tests_integration/cli/invalid-ignore/.prettierignore: EISDIR: illegal operation on a directory, read",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error with invalid ignore (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error with invalid ignore (write) 1`] = `Array []`;"
                    ]
                },
                "list-different.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`--list-different works in CI just as in a non-TTY mode (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`--list-different works in CI just as in a non-TTY mode (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`--list-different works in CI just as in a non-TTY mode (stdout) 1`] = `",
                        "\"unformatted.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`--list-different works in CI just as in a non-TTY mode (stdout) 2`] = `",
                        "\"unformatted.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`--list-different works in CI just as in a non-TTY mode (write) 1`] = `Array []`;",
                        "",
                        "exports[`--list-different works in CI just as in a non-TTY mode (write) 2`] = `Array []`;",
                        "",
                        "exports[`checks stdin with --list-different (write) 1`] = `Array []`;",
                        "",
                        "exports[`checks stdin with -l (alias for --list-different) (write) 1`] = `Array []`;"
                    ]
                },
                "load-toml.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`TOML loads toml successfully 1`] = `",
                        "Object {",
                        "  \"database\": Object {",
                        "    \"connection_max\": 5000,",
                        "    \"enabled\": true,",
                        "    \"ports\": Array [",
                        "      8001,",
                        "      8001,",
                        "      8002,",
                        "    ],",
                        "    \"server\": \"192.168.1.1\",",
                        "  },",
                        "  \"owner\": Object {",
                        "    \"dob\": 1979-05-27T15:32:00.000Z,",
                        "    \"name\": \"Tom Preston-Werner\",",
                        "  },",
                        "  \"title\": \"TOML Example\",",
                        "}",
                        "`;",
                        "",
                        "exports[`TOML throws error on incorrect toml 1`] = `",
                        "\"TOML Error in example.toml:",
                        "Unknown character \\\\\"47\\\\\" at row 1, col 2, pos 1:",
                        "1> ///ERROR///",
                        "    ^",
                        "",
                        "\"",
                        "`;"
                    ]
                },
                "loglevel.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`--write with --loglevel=silent doesn't log filenames (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`--write with --loglevel=silent doesn't log filenames (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`--write with --loglevel=silent doesn't log filenames (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;"
                    ]
                },
                "parser-api.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`allows passing a string to resolve a parser (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`allows passing a string to resolve a parser (stdout) 1`] = `",
                        "\"/* eslint-disable */",
                        "bar();",
                        "\"",
                        "`;",
                        "",
                        "exports[`allows passing a string to resolve a parser (write) 1`] = `Array []`;"
                    ]
                },
                "patterns-dirs.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`1: prettier dir1 dir2 (stdout) 1`] = `",
                        "\"dir1/a1.js",
                        "dir1/b1.js",
                        "dir1/nested1/an1.css",
                        "dir1/nested1/an1.js",
                        "dir1/nested1/bn1.js",
                        "dir2/a2.js",
                        "dir2/b2.js",
                        "dir2/nested2/an2.js",
                        "dir2/nested2/bn2.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`1a - with *.foo plugin: prettier dir1 dir2 --plugin=../../plugins/extensions/plugin (stdout) 1`] = `",
                        "\"dir1/a1.foo",
                        "dir1/a1.js",
                        "dir1/b1.js",
                        "dir1/nested1/an1.css",
                        "dir1/nested1/an1.js",
                        "dir1/nested1/bn1.js",
                        "dir2/a2.foo",
                        "dir2/a2.js",
                        "dir2/b2.js",
                        "dir2/nested2/an2.js",
                        "dir2/nested2/bn2.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`1c: prettier dir1 empty (stderr) 1`] = `",
                        "\"[error] No supported files were found in the directory: \\\\\"empty\\\\\".",
                        "\"",
                        "`;",
                        "",
                        "exports[`1c: prettier dir1 empty (stdout) 1`] = `",
                        "\"dir1/a1.js",
                        "dir1/b1.js",
                        "dir1/nested1/an1.css",
                        "dir1/nested1/an1.js",
                        "dir1/nested1/bn1.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`2: prettier dir1 'dir2/**/*' (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: dir2/a2.foo",
                        "\"",
                        "`;",
                        "",
                        "exports[`2: prettier dir1 'dir2/**/*' (stdout) 1`] = `",
                        "\"dir1/a1.js",
                        "dir1/b1.js",
                        "dir1/nested1/an1.css",
                        "dir1/nested1/an1.js",
                        "dir1/nested1/bn1.js",
                        "dir2/a2.js",
                        "dir2/b2.js",
                        "dir2/nested2/an2.js",
                        "dir2/nested2/bn2.js",
                        "dir2/node-shebang",
                        "\"",
                        "`;",
                        "",
                        "exports[`3: prettier nonexistent-dir 'dir2/**/*' (stderr) 1`] = `",
                        "\"[error] No files matching the pattern were found: \\\\\"nonexistent-dir\\\\\".",
                        "[error] No parser could be inferred for file: dir2/a2.foo",
                        "\"",
                        "`;",
                        "",
                        "exports[`3: prettier nonexistent-dir 'dir2/**/*' (stdout) 1`] = `",
                        "\"dir2/a2.js",
                        "dir2/b2.js",
                        "dir2/nested2/an2.js",
                        "dir2/nested2/bn2.js",
                        "dir2/node-shebang",
                        "\"",
                        "`;",
                        "",
                        "exports[`4: prettier . 'dir2/**/*' (stderr) 1`] = `",
                        "\"[error] No parser could be inferred for file: dir2/a2.foo",
                        "\"",
                        "`;",
                        "",
                        "exports[`4: prettier . 'dir2/**/*' (stdout) 1`] = `",
                        "\"!dir/a.js",
                        "dir1/a1.js",
                        "dir1/b1.js",
                        "dir1/nested1/an1.css",
                        "dir1/nested1/an1.js",
                        "dir1/nested1/bn1.js",
                        "dir2/a2.js",
                        "dir2/b2.js",
                        "dir2/nested2/an2.js",
                        "dir2/nested2/bn2.js",
                        "dir2/node-shebang",
                        "\"",
                        "`;",
                        "",
                        "exports[`Negative patterns 1: prettier dir1 '!dir1/nested1' (stdout) 1`] = `",
                        "\"dir1/a1.js",
                        "dir1/b1.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`Negative patterns 1a: prettier dir1 '!dir1/nested1/*' (stdout) 1`] = `",
                        "\"dir1/a1.js",
                        "dir1/b1.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`Negative patterns 2: prettier . '!dir1/nested1' (stdout) 1`] = `",
                        "\"!dir/a.js",
                        "dir1/a1.js",
                        "dir1/b1.js",
                        "dir2/a2.js",
                        "dir2/b2.js",
                        "dir2/nested2/an2.js",
                        "dir2/nested2/bn2.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`Negative patterns 3: prettier . '!dir1/nested1/an1.js' (stdout) 1`] = `",
                        "\"!dir/a.js",
                        "dir1/a1.js",
                        "dir1/b1.js",
                        "dir1/nested1/an1.css",
                        "dir1/nested1/bn1.js",
                        "dir2/a2.js",
                        "dir2/b2.js",
                        "dir2/nested2/an2.js",
                        "dir2/nested2/bn2.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`Negative patterns 4: prettier '!nonexistent-dir1 !nonexistent-dir2' (stderr) 1`] = `",
                        "\"[error] No matching files. Patterns: !nonexistent-dir1 !nonexistent-dir2",
                        "\"",
                        "`;",
                        "",
                        "exports[`Negative patterns 4: prettier '!nonexistent-dir1 !nonexistent-dir2' (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`Negative patterns with explicit files: prettier dir1/a1.js dir2/a2.js '!dir1/*' (stderr) 1`] = `",
                        "\"[error] Explicitly specified file was ignored due to negative glob patterns: \\\\\"dir1/a1.js\\\\\".",
                        "\"",
                        "`;",
                        "",
                        "exports[`Negative patterns with explicit files: prettier dir1/a1.js dir2/a2.js '!dir1/*' (stdout) 1`] = `",
                        "\"dir2/a2.js",
                        "\"",
                        "`;"
                    ]
                },
                "patterns-glob.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`fixtures-1: Should match all files (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-1: Should match all files (stdout) 1`] = `",
                        "\"!file.js",
                        "a.js",
                        "b.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-1: Should match all files (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-1: Should match files except \\`a.js\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-1: Should match files except \\`a.js\\` (stdout) 1`] = `",
                        "\"!file.js",
                        "b.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-1: Should match files except \\`a.js\\` (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-2: Should match \\`a.js\\` and \\`!b.js\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-2: Should match \\`a.js\\` and \\`!b.js\\` (stdout) 1`] = `",
                        "\"!b.js",
                        "a.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-2: Should match \\`a.js\\` and \\`!b.js\\` (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-2: Should match all js files and all supported files in the '!dir.js' directory (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-2: Should match all js files and all supported files in the '!dir.js' directory (stdout) 1`] = `",
                        "\"!b.js",
                        "a.js",
                        "!dir.js/1.css",
                        "!dir.js/2.css",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-2: Should match all js files and all supported files in the '!dir.js' directory (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-2: Should only match \\`!b.js\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-2: Should only match \\`!b.js\\` (stdout) 1`] = `",
                        "\"!b.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-2: Should only match \\`!b.js\\` (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-3: Should exclude \\`.svn\\` (existing) (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-3: Should exclude \\`.svn\\` (existing) (stdout) 1`] = `",
                        "\"outside.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-3: Should exclude \\`.svn\\` (existing) (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-3: Should exclude \\`.svn\\` (nonexisting) (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-3: Should exclude \\`.svn\\` (nonexisting) (stdout) 1`] = `",
                        "\"outside.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-3: Should exclude \\`.svn\\` (nonexisting) (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-3: Should match \\`outside.js\\`, \\`dir/inside.js\\` and \\`dir/node_modules/in-node_modules.js\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-3: Should match \\`outside.js\\`, \\`dir/inside.js\\` and \\`dir/node_modules/in-node_modules.js\\` (stdout) 1`] = `",
                        "\"dir/inside.js",
                        "dir/node_modules/in-node_modules.js",
                        "outside.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-3: Should match \\`outside.js\\`, \\`dir/inside.js\\` and \\`dir/node_modules/in-node_modules.js\\` (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-3: Should only match \\`outside.js\\` and \\`dir/inside.js\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-3: Should only match \\`outside.js\\` and \\`dir/inside.js\\` (stdout) 1`] = `",
                        "\"dir/inside.js",
                        "outside.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-3: Should only match \\`outside.js\\` and \\`dir/inside.js\\` (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` #2 (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` #2 (stdout) 1`] = `",
                        "\"0/level-1.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` #2 (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` #3 (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` #3 (stdout) 1`] = `",
                        "\"0/level-1.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` #3 (write) 1`] = `Array []`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` (stdout) 1`] = `",
                        "\"0/level-1.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`fixtures-4: Should match \\`level-1.js\\` (write) 1`] = `Array []`;"
                    ]
                },
                "patterns.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`multiple patterns (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns (stdout) 1`] = `",
                        "\"directory/file.js",
                        "directory/nested-directory/nested-directory-file.js",
                        "other-directory/file.js",
                        "other-directory/nested-directory/nested-directory-file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, doesn't ignore node_modules with --with-node-modules flag (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, doesn't ignore node_modules with --with-node-modules flag (stdout) 1`] = `",
                        "\"node_modules/node-module.js",
                        "other-directory/file.js",
                        "other-directory/nested-directory/nested-directory-file.js",
                        "other-regular-modules.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, doesn't ignore node_modules with --with-node-modules flag (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by default (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by default (stdout) 1`] = `",
                        "\"other-directory/file.js",
                        "other-directory/nested-directory/nested-directory-file.js",
                        "other-regular-modules.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by default (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by with ./**/*.js (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by with ./**/*.js (stdout) 1`] = `",
                        "\"other-directory/file.js",
                        "other-directory/nested-directory/nested-directory-file.js",
                        "other-regular-modules.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns by with ignore pattern, ignores node_modules by with ./**/*.js (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns with ignore nested directories pattern (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns with ignore nested directories pattern (stdout) 1`] = `",
                        "\"directory/file.js",
                        "other-directory/file.js",
                        "other-regular-modules.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns with ignore nested directories pattern (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns with non exists pattern (stderr) 1`] = `",
                        "\"[error] No files matching the pattern were found: \\\\\"non-existent.js\\\\\".",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns with non exists pattern (stdout) 1`] = `",
                        "\"directory/file.js",
                        "directory/nested-directory/nested-directory-file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns with non exists pattern (write) 1`] = `Array []`;",
                        "",
                        "exports[`multiple patterns, throw error and exit with non zero code on non existing files (stderr) 1`] = `",
                        "\"[error] No files matching the pattern were found: \\\\\"non-existent.js\\\\\".",
                        "[error] No files matching the pattern were found: \\\\\"other-non-existent.js\\\\\".",
                        "\"",
                        "`;",
                        "",
                        "exports[`multiple patterns, throw error and exit with non zero code on non existing files (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`multiple patterns, throw error and exit with non zero code on non existing files (write) 1`] = `Array []`;",
                        "",
                        "exports[`no errors on empty patterns (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`no errors on empty patterns (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`no errors on empty patterns (write) 1`] = `Array []`;"
                    ]
                },
                "piped-output.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`no file diffs with --check + formatted file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`no file diffs with --check + formatted file (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`no file diffs with --check + formatted file (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "formatted.jsAll matched files use Prettier code style!",
                        "\"",
                        "`;",
                        "",
                        "exports[`no file diffs with --check + formatted file (stdout) 2`] = `",
                        "\"Checking formatting...",
                        "All matched files use Prettier code style!",
                        "\"",
                        "`;",
                        "",
                        "exports[`no file diffs with --check + formatted file (write) 1`] = `Array []`;",
                        "",
                        "exports[`no file diffs with --check + formatted file (write) 2`] = `Array []`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (stdout) 1`] = `\"formatted.js\"`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (stdout) 2`] = `\"\"`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (write) 1`] = `Array []`;",
                        "",
                        "exports[`no file diffs with --list-different + formatted file (write) 2`] = `Array []`;",
                        "",
                        "exports[`output with --check + unformatted differs when piped (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`output with --check + unformatted differs when piped (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`output with --check + unformatted differs when piped (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "unformatted.jsunformatted.js",
                        "Code style issues fixed in the above file(s).",
                        "\"",
                        "`;",
                        "",
                        "exports[`output with --check + unformatted differs when piped (stdout) 2`] = `",
                        "\"Checking formatting...",
                        "unformatted.js",
                        "Code style issues fixed in the above file(s).",
                        "\"",
                        "`;",
                        "",
                        "exports[`output with --check + unformatted differs when piped (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;",
                        "",
                        "exports[`output with --check + unformatted differs when piped (write) 2`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (stderr) 2`] = `\"\"`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (stdout) 1`] = `",
                        "\"unformatted.jsunformatted.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (stdout) 2`] = `",
                        "\"unformatted.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;",
                        "",
                        "exports[`output with --list-different + unformatted differs when piped (write) 2`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;"
                    ]
                },
                "plugin-options-string.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[` 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -20,18 +20,20 @@",
                        "                             Control how Prettier formats quoted code embedded in the file.",
                        "                             Defaults to auto.",
                        "    --end-of-line <lf|crlf|cr|auto>",
                        "                             Which end of line characters to apply.",
                        "                             Defaults to lf.",
                        "+   --foo-string <string>    foo description",
                        "+                            Defaults to bar.",
                        "    --html-whitespace-sensitivity <css|strict|ignore>",
                        "                             How to handle whitespaces in HTML.",
                        "                             Defaults to css.",
                        "    --jsx-bracket-same-line  Put > on the last line instead of at a new line.",
                        "                             Defaults to false.",
                        "    --jsx-single-quote       Use single quotes in JSX.",
                        "                             Defaults to false.",
                        "-   --parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc>",
                        "+   --parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc|foo-parser>",
                        "                             Which parser to use.",
                        "    --print-width <int>      The line length where Prettier will try wrap.",
                        "                             Defaults to 80.",
                        "    --prose-wrap <always|never|preserve>",
                        "                             How to wrap prose.\"",
                        "`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-string\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-string\\` (stdout) 1`] = `",
                        "\"--foo-string <string>",
                        "",
                        "  foo description",
                        "",
                        "Default: bar",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-string\\` (write) 1`] = `Array []`;"
                    ]
                },
                "plugin-options.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[` 1`] = `",
                        "\"Snapshot Diff:",
                        "- First value",
                        "+ Second value",
                        "",
                        "@@ -20,18 +20,20 @@",
                        "                             Control how Prettier formats quoted code embedded in the file.",
                        "                             Defaults to auto.",
                        "    --end-of-line <lf|crlf|cr|auto>",
                        "                             Which end of line characters to apply.",
                        "                             Defaults to lf.",
                        "+   --foo-option <bar|baz>   foo description",
                        "+                            Defaults to bar.",
                        "    --html-whitespace-sensitivity <css|strict|ignore>",
                        "                             How to handle whitespaces in HTML.",
                        "                             Defaults to css.",
                        "    --jsx-bracket-same-line  Put > on the last line instead of at a new line.",
                        "                             Defaults to false.",
                        "    --jsx-single-quote       Use single quotes in JSX.",
                        "                             Defaults to false.",
                        "-   --parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc>",
                        "+   --parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc|foo-parser>",
                        "                             Which parser to use.",
                        "    --print-width <int>      The line length where Prettier will try wrap.",
                        "                             Defaults to 80.",
                        "    --prose-wrap <always|never|preserve>",
                        "                             How to wrap prose.\"",
                        "`;",
                        "",
                        "exports[`include plugin's parsers to the values of the \\`parser\\` option\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`include plugin's parsers to the values of the \\`parser\\` option\\` (stdout) 1`] = `",
                        "\"--parser <flow|babel|babel-flow|babel-ts|typescript|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|html|angular|lwc|foo-parser>",
                        "",
                        "  Which parser to use.",
                        "",
                        "Valid options:",
                        "",
                        "  flow             Flow",
                        "  babel            JavaScript",
                        "  babel-flow       Flow",
                        "  babel-ts         TypeScript",
                        "  typescript       TypeScript",
                        "  css              CSS",
                        "  less             Less",
                        "  scss             SCSS",
                        "  json             JSON",
                        "  json5            JSON5",
                        "  json-stringify   JSON.stringify",
                        "  graphql          GraphQL",
                        "  markdown         Markdown",
                        "  mdx              MDX",
                        "  vue              Vue",
                        "  yaml             YAML",
                        "  html             HTML",
                        "  angular          Angular",
                        "  lwc              Lightning Web Components",
                        "  foo-parser       foo (plugin: ./plugin)",
                        "\"",
                        "`;",
                        "",
                        "exports[`include plugin's parsers to the values of the \\`parser\\` option\\` (write) 1`] = `Array []`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-option\\` (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-option\\` (stdout) 1`] = `",
                        "\"--foo-option <bar|baz>",
                        "",
                        "  foo description",
                        "",
                        "Valid options:",
                        "",
                        "  bar   bar description",
                        "  baz   baz description",
                        "",
                        "Default: bar",
                        "\"",
                        "`;",
                        "",
                        "exports[`show detailed external option with \\`--help foo-option\\` (write) 1`] = `Array []`;"
                    ]
                },
                "schema.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`schema 1`] = `",
                        "Object {",
                        "  \"$schema\": \"http://json-schema.org/draft-04/schema#\",",
                        "  \"definitions\": Object {",
                        "    \"optionsDefinition\": Object {",
                        "      \"properties\": Object {",
                        "        \"arrowParens\": Object {",
                        "          \"default\": \"always\",",
                        "          \"description\": \"Include parentheses around a sole arrow function parameter.\",",
                        "          \"oneOf\": Array [",
                        "            Object {",
                        "              \"description\": \"Always include parens. Example: \\`(x) => x\\`\",",
                        "              \"enum\": Array [",
                        "                \"always\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Omit parens when possible. Example: \\`x => x\\`\",",
                        "              \"enum\": Array [",
                        "                \"avoid\",",
                        "              ],",
                        "            },",
                        "          ],",
                        "        },",
                        "        \"bracketSpacing\": Object {",
                        "          \"default\": true,",
                        "          \"description\": \"Print spaces between brackets.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "        \"cursorOffset\": Object {",
                        "          \"default\": -1,",
                        "          \"description\": \"Print (to stderr) where a cursor at the given position would move to after formatting.",
                        "This option cannot be used with --range-start and --range-end.\",",
                        "          \"type\": \"integer\",",
                        "        },",
                        "        \"embeddedLanguageFormatting\": Object {",
                        "          \"default\": \"auto\",",
                        "          \"description\": \"Control how Prettier formats quoted code embedded in the file.\",",
                        "          \"oneOf\": Array [",
                        "            Object {",
                        "              \"description\": \"Format embedded code if Prettier can automatically identify it.\",",
                        "              \"enum\": Array [",
                        "                \"auto\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Never automatically format embedded code.\",",
                        "              \"enum\": Array [",
                        "                \"off\",",
                        "              ],",
                        "            },",
                        "          ],",
                        "        },",
                        "        \"endOfLine\": Object {",
                        "          \"default\": \"lf\",",
                        "          \"description\": \"Which end of line characters to apply.\",",
                        "          \"oneOf\": Array [",
                        "            Object {",
                        "              \"description\": \"Line Feed only (\\\\\\\\n), common on Linux and macOS as well as inside git repos\",",
                        "              \"enum\": Array [",
                        "                \"lf\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Carriage Return + Line Feed characters (\\\\\\\\r\\\\\\\\n), common on Windows\",",
                        "              \"enum\": Array [",
                        "                \"crlf\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Carriage Return character only (\\\\\\\\r), used very rarely\",",
                        "              \"enum\": Array [",
                        "                \"cr\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Maintain existing",
                        "(mixed values within one file are normalised by looking at what's used after the first line)\",",
                        "              \"enum\": Array [",
                        "                \"auto\",",
                        "              ],",
                        "            },",
                        "          ],",
                        "        },",
                        "        \"filepath\": Object {",
                        "          \"default\": undefined,",
                        "          \"description\": \"Specify the input filepath. This will be used to do parser inference.\",",
                        "          \"type\": \"string\",",
                        "        },",
                        "        \"htmlWhitespaceSensitivity\": Object {",
                        "          \"default\": \"css\",",
                        "          \"description\": \"How to handle whitespaces in HTML.\",",
                        "          \"oneOf\": Array [",
                        "            Object {",
                        "              \"description\": \"Respect the default value of CSS display property.\",",
                        "              \"enum\": Array [",
                        "                \"css\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Whitespaces are considered sensitive.\",",
                        "              \"enum\": Array [",
                        "                \"strict\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Whitespaces are considered insensitive.\",",
                        "              \"enum\": Array [",
                        "                \"ignore\",",
                        "              ],",
                        "            },",
                        "          ],",
                        "        },",
                        "        \"insertPragma\": Object {",
                        "          \"default\": false,",
                        "          \"description\": \"Insert @format pragma into file's first docblock comment.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "        \"jsxBracketSameLine\": Object {",
                        "          \"default\": false,",
                        "          \"description\": \"Put > on the last line instead of at a new line.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "        \"jsxSingleQuote\": Object {",
                        "          \"default\": false,",
                        "          \"description\": \"Use single quotes in JSX.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "        \"parser\": Object {",
                        "          \"default\": undefined,",
                        "          \"description\": \"Which parser to use.\",",
                        "          \"oneOf\": Array [",
                        "            Object {",
                        "              \"description\": \"Flow\",",
                        "              \"enum\": Array [",
                        "                \"flow\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"JavaScript\",",
                        "              \"enum\": Array [",
                        "                \"babel\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Flow\",",
                        "              \"enum\": Array [",
                        "                \"babel-flow\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"TypeScript\",",
                        "              \"enum\": Array [",
                        "                \"babel-ts\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"TypeScript\",",
                        "              \"enum\": Array [",
                        "                \"typescript\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"CSS\",",
                        "              \"enum\": Array [",
                        "                \"css\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Less\",",
                        "              \"enum\": Array [",
                        "                \"less\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"SCSS\",",
                        "              \"enum\": Array [",
                        "                \"scss\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"JSON\",",
                        "              \"enum\": Array [",
                        "                \"json\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"JSON5\",",
                        "              \"enum\": Array [",
                        "                \"json5\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"JSON.stringify\",",
                        "              \"enum\": Array [",
                        "                \"json-stringify\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"GraphQL\",",
                        "              \"enum\": Array [",
                        "                \"graphql\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Markdown\",",
                        "              \"enum\": Array [",
                        "                \"markdown\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"MDX\",",
                        "              \"enum\": Array [",
                        "                \"mdx\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Vue\",",
                        "              \"enum\": Array [",
                        "                \"vue\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"YAML\",",
                        "              \"enum\": Array [",
                        "                \"yaml\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"HTML\",",
                        "              \"enum\": Array [",
                        "                \"html\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Angular\",",
                        "              \"enum\": Array [",
                        "                \"angular\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Lightning Web Components\",",
                        "              \"enum\": Array [",
                        "                \"lwc\",",
                        "              ],",
                        "            },",
                        "          ],",
                        "        },",
                        "        \"pluginSearchDirs\": Object {",
                        "          \"default\": Array [],",
                        "          \"description\": \"Custom directory that contains prettier plugins in node_modules subdirectory.",
                        "Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                        "Multiple values are accepted.\",",
                        "          \"items\": Object {",
                        "            \"type\": \"string\",",
                        "          },",
                        "          \"type\": \"array\",",
                        "        },",
                        "        \"plugins\": Object {",
                        "          \"default\": Array [],",
                        "          \"description\": \"Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.\",",
                        "          \"items\": Object {",
                        "            \"type\": \"string\",",
                        "          },",
                        "          \"type\": \"array\",",
                        "        },",
                        "        \"printWidth\": Object {",
                        "          \"default\": 80,",
                        "          \"description\": \"The line length where Prettier will try wrap.\",",
                        "          \"type\": \"integer\",",
                        "        },",
                        "        \"proseWrap\": Object {",
                        "          \"default\": \"preserve\",",
                        "          \"description\": \"How to wrap prose.\",",
                        "          \"oneOf\": Array [",
                        "            Object {",
                        "              \"description\": \"Wrap prose if it exceeds the print width.\",",
                        "              \"enum\": Array [",
                        "                \"always\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Do not wrap prose.\",",
                        "              \"enum\": Array [",
                        "                \"never\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Wrap prose as-is.\",",
                        "              \"enum\": Array [",
                        "                \"preserve\",",
                        "              ],",
                        "            },",
                        "          ],",
                        "        },",
                        "        \"quoteProps\": Object {",
                        "          \"default\": \"as-needed\",",
                        "          \"description\": \"Change when properties in objects are quoted.\",",
                        "          \"oneOf\": Array [",
                        "            Object {",
                        "              \"description\": \"Only add quotes around object properties where required.\",",
                        "              \"enum\": Array [",
                        "                \"as-needed\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"If at least one property in an object requires quotes, quote all properties.\",",
                        "              \"enum\": Array [",
                        "                \"consistent\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Respect the input use of quotes in object properties.\",",
                        "              \"enum\": Array [",
                        "                \"preserve\",",
                        "              ],",
                        "            },",
                        "          ],",
                        "        },",
                        "        \"rangeEnd\": Object {",
                        "          \"default\": Infinity,",
                        "          \"description\": \"Format code ending at a given character offset (exclusive).",
                        "The range will extend forwards to the end of the selected statement.",
                        "This option cannot be used with --cursor-offset.\",",
                        "          \"type\": \"integer\",",
                        "        },",
                        "        \"rangeStart\": Object {",
                        "          \"default\": 0,",
                        "          \"description\": \"Format code starting at a given character offset.",
                        "The range will extend backwards to the start of the first line containing the selected statement.",
                        "This option cannot be used with --cursor-offset.\",",
                        "          \"type\": \"integer\",",
                        "        },",
                        "        \"requirePragma\": Object {",
                        "          \"default\": false,",
                        "          \"description\": \"Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                        "in order for it to be formatted.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "        \"semi\": Object {",
                        "          \"default\": true,",
                        "          \"description\": \"Print semicolons.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "        \"singleQuote\": Object {",
                        "          \"default\": false,",
                        "          \"description\": \"Use single quotes instead of double quotes.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "        \"tabWidth\": Object {",
                        "          \"default\": 2,",
                        "          \"description\": \"Number of spaces per indentation level.\",",
                        "          \"type\": \"integer\",",
                        "        },",
                        "        \"trailingComma\": Object {",
                        "          \"default\": \"es5\",",
                        "          \"description\": \"Print trailing commas wherever possible when multi-line.\",",
                        "          \"oneOf\": Array [",
                        "            Object {",
                        "              \"description\": \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",",
                        "              \"enum\": Array [",
                        "                \"es5\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"No trailing commas.\",",
                        "              \"enum\": Array [",
                        "                \"none\",",
                        "              ],",
                        "            },",
                        "            Object {",
                        "              \"description\": \"Trailing commas wherever possible (including function arguments).\",",
                        "              \"enum\": Array [",
                        "                \"all\",",
                        "              ],",
                        "            },",
                        "          ],",
                        "        },",
                        "        \"useTabs\": Object {",
                        "          \"default\": false,",
                        "          \"description\": \"Indent with tabs instead of spaces.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "        \"vueIndentScriptAndStyle\": Object {",
                        "          \"default\": false,",
                        "          \"description\": \"Indent script and style tags in Vue files.\",",
                        "          \"type\": \"boolean\",",
                        "        },",
                        "      },",
                        "      \"type\": \"object\",",
                        "    },",
                        "    \"overridesDefinition\": Object {",
                        "      \"properties\": Object {",
                        "        \"overrides\": Object {",
                        "          \"description\": \"Provide a list of patterns to override prettier configuration.\",",
                        "          \"items\": Object {",
                        "            \"additionalProperties\": false,",
                        "            \"properties\": Object {",
                        "              \"excludeFiles\": Object {",
                        "                \"description\": \"Exclude these files from this override.\",",
                        "                \"oneOf\": Array [",
                        "                  Object {",
                        "                    \"type\": \"string\",",
                        "                  },",
                        "                  Object {",
                        "                    \"items\": Object {",
                        "                      \"type\": \"string\",",
                        "                    },",
                        "                    \"type\": \"array\",",
                        "                  },",
                        "                ],",
                        "              },",
                        "              \"files\": Object {",
                        "                \"description\": \"Include these files in this override.\",",
                        "                \"oneOf\": Array [",
                        "                  Object {",
                        "                    \"type\": \"string\",",
                        "                  },",
                        "                  Object {",
                        "                    \"items\": Object {",
                        "                      \"type\": \"string\",",
                        "                    },",
                        "                    \"type\": \"array\",",
                        "                  },",
                        "                ],",
                        "              },",
                        "              \"options\": Object {",
                        "                \"$ref\": \"#/definitions/optionsDefinition\",",
                        "                \"description\": \"The options to apply for this override.\",",
                        "                \"type\": \"object\",",
                        "              },",
                        "            },",
                        "            \"required\": Array [",
                        "              \"files\",",
                        "            ],",
                        "            \"type\": \"object\",",
                        "          },",
                        "          \"type\": \"array\",",
                        "        },",
                        "      },",
                        "      \"type\": \"object\",",
                        "    },",
                        "  },",
                        "  \"oneOf\": Array [",
                        "    Object {",
                        "      \"allOf\": Array [",
                        "        Object {",
                        "          \"$ref\": \"#/definitions/optionsDefinition\",",
                        "        },",
                        "        Object {",
                        "          \"$ref\": \"#/definitions/overridesDefinition\",",
                        "        },",
                        "      ],",
                        "      \"type\": \"object\",",
                        "    },",
                        "    Object {",
                        "      \"type\": \"string\",",
                        "    },",
                        "  ],",
                        "  \"title\": \"Schema for .prettierrc\",",
                        "}",
                        "`;"
                    ]
                },
                "skip-folders.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`skip folders passed specifically (stdout) 1`] = `",
                        "\"a/file.js",
                        "b/file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`skip folders passed specifically (write) 1`] = `Array []`;",
                        "",
                        "exports[`skips folders in glob (stdout) 1`] = `",
                        "\"a/file.js",
                        "b/file.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`skips folders in glob (write) 1`] = `Array []`;"
                    ]
                },
                "stdin-filepath.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`apply editorconfig for stdin-filepath with nonexistent directory (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`apply editorconfig for stdin-filepath with nonexistent directory (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(\\\\\"should be indented with a tab\\\\\")",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`apply editorconfig for stdin-filepath with nonexistent directory (write) 1`] = `Array []`;",
                        "",
                        "exports[`apply editorconfig for stdin-filepath with nonexistent file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`apply editorconfig for stdin-filepath with nonexistent file (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(\\\\\"should be indented with a tab\\\\\")",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`apply editorconfig for stdin-filepath with nonexistent file (write) 1`] = `Array []`;",
                        "",
                        "exports[`dont apply editorconfig outside project for stdin-filepath with nonexistent directory (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`dont apply editorconfig outside project for stdin-filepath with nonexistent directory (stdout) 1`] = `",
                        "\"function f() {",
                        "  console.log(\\\\\"should be indented with 2 spaces\\\\\")",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`dont apply editorconfig outside project for stdin-filepath with nonexistent directory (write) 1`] = `Array []`;",
                        "",
                        "exports[`format correctly if stdin content compatible with stdin-filepath (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`format correctly if stdin content compatible with stdin-filepath (stdout) 1`] = `",
                        "\".name {",
                        "  display: none;",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`format correctly if stdin content compatible with stdin-filepath (write) 1`] = `Array []`;",
                        "",
                        "exports[`gracefully handle stdin-filepath with nonexistent directory (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`gracefully handle stdin-filepath with nonexistent directory (stdout) 1`] = `",
                        "\".name {",
                        "  display: none;",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`gracefully handle stdin-filepath with nonexistent directory (write) 1`] = `Array []`;",
                        "",
                        "exports[`output file as-is if stdin-filepath matched patterns in ignore-path (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`output file as-is if stdin-filepath matched patterns in ignore-path (write) 1`] = `Array []`;",
                        "",
                        "exports[`throw error if stdin content incompatible with stdin-filepath (stderr) 1`] = `",
                        "\"[error] abc.js: SyntaxError: Unexpected token (1:1)",
                        "[error] > 1 | .name { display: none; }",
                        "[error]     | ^",
                        "\"",
                        "`;",
                        "",
                        "exports[`throw error if stdin content incompatible with stdin-filepath (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`throw error if stdin content incompatible with stdin-filepath (write) 1`] = `Array []`;"
                    ]
                },
                "support-info.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`API getSupportInfo() 1`] = `",
                        "Object {",
                        "  \"languages\": Object {",
                        "    \"Angular\": Array [",
                        "      \"angular\",",
                        "    ],",
                        "    \"CSS\": Array [",
                        "      \"css\",",
                        "    ],",
                        "    \"Flow\": Array [",
                        "      \"babel\",",
                        "      \"flow\",",
                        "    ],",
                        "    \"GraphQL\": Array [",
                        "      \"graphql\",",
                        "    ],",
                        "    \"HTML\": Array [",
                        "      \"html\",",
                        "    ],",
                        "    \"JSON\": Array [",
                        "      \"json\",",
                        "    ],",
                        "    \"JSON with Comments\": Array [",
                        "      \"json\",",
                        "    ],",
                        "    \"JSON.stringify\": Array [",
                        "      \"json-stringify\",",
                        "    ],",
                        "    \"JSON5\": Array [",
                        "      \"json5\",",
                        "    ],",
                        "    \"JSX\": Array [",
                        "      \"babel\",",
                        "      \"flow\",",
                        "    ],",
                        "    \"JavaScript\": Array [",
                        "      \"babel\",",
                        "      \"flow\",",
                        "    ],",
                        "    \"Less\": Array [",
                        "      \"less\",",
                        "    ],",
                        "    \"Lightning Web Components\": Array [",
                        "      \"lwc\",",
                        "    ],",
                        "    \"MDX\": Array [",
                        "      \"mdx\",",
                        "    ],",
                        "    \"Markdown\": Array [",
                        "      \"markdown\",",
                        "    ],",
                        "    \"PostCSS\": Array [",
                        "      \"css\",",
                        "    ],",
                        "    \"SCSS\": Array [",
                        "      \"scss\",",
                        "    ],",
                        "    \"TSX\": Array [",
                        "      \"typescript\",",
                        "      \"babel-ts\",",
                        "    ],",
                        "    \"TypeScript\": Array [",
                        "      \"typescript\",",
                        "      \"babel-ts\",",
                        "    ],",
                        "    \"Vue\": Array [",
                        "      \"vue\",",
                        "    ],",
                        "    \"YAML\": Array [",
                        "      \"yaml\",",
                        "    ],",
                        "  },",
                        "  \"options\": Object {",
                        "    \"arrowParens\": Object {",
                        "      \"choices\": Array [",
                        "        \"always\",",
                        "        \"avoid\",",
                        "      ],",
                        "      \"default\": \"always\",",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"bracketSpacing\": Object {",
                        "      \"default\": true,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"cursorOffset\": Object {",
                        "      \"default\": -1,",
                        "      \"range\": Object {",
                        "        \"end\": Infinity,",
                        "        \"start\": -1,",
                        "        \"step\": 1,",
                        "      },",
                        "      \"type\": \"int\",",
                        "    },",
                        "    \"embeddedLanguageFormatting\": Object {",
                        "      \"choices\": Array [",
                        "        \"auto\",",
                        "        \"off\",",
                        "      ],",
                        "      \"default\": \"auto\",",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"endOfLine\": Object {",
                        "      \"choices\": Array [",
                        "        \"lf\",",
                        "        \"crlf\",",
                        "        \"cr\",",
                        "        \"auto\",",
                        "      ],",
                        "      \"default\": \"lf\",",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"filepath\": Object {",
                        "      \"default\": undefined,",
                        "      \"type\": \"path\",",
                        "    },",
                        "    \"htmlWhitespaceSensitivity\": Object {",
                        "      \"choices\": Array [",
                        "        \"css\",",
                        "        \"strict\",",
                        "        \"ignore\",",
                        "      ],",
                        "      \"default\": \"css\",",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"insertPragma\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"jsxBracketSameLine\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"jsxSingleQuote\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"parser\": Object {",
                        "      \"choices\": Array [",
                        "        \"flow\",",
                        "        \"babel\",",
                        "        \"babel-flow\",",
                        "        \"babel-ts\",",
                        "        \"typescript\",",
                        "        \"css\",",
                        "        \"less\",",
                        "        \"scss\",",
                        "        \"json\",",
                        "        \"json5\",",
                        "        \"json-stringify\",",
                        "        \"graphql\",",
                        "        \"markdown\",",
                        "        \"mdx\",",
                        "        \"vue\",",
                        "        \"yaml\",",
                        "        \"html\",",
                        "        \"angular\",",
                        "        \"lwc\",",
                        "      ],",
                        "      \"default\": undefined,",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"pluginSearchDirs\": Object {",
                        "      \"default\": Array [],",
                        "      \"type\": \"path\",",
                        "    },",
                        "    \"plugins\": Object {",
                        "      \"default\": Array [],",
                        "      \"type\": \"path\",",
                        "    },",
                        "    \"printWidth\": Object {",
                        "      \"default\": 80,",
                        "      \"range\": Object {",
                        "        \"end\": Infinity,",
                        "        \"start\": 0,",
                        "        \"step\": 1,",
                        "      },",
                        "      \"type\": \"int\",",
                        "    },",
                        "    \"proseWrap\": Object {",
                        "      \"choices\": Array [",
                        "        \"always\",",
                        "        \"never\",",
                        "        \"preserve\",",
                        "      ],",
                        "      \"default\": \"preserve\",",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"quoteProps\": Object {",
                        "      \"choices\": Array [",
                        "        \"as-needed\",",
                        "        \"consistent\",",
                        "        \"preserve\",",
                        "      ],",
                        "      \"default\": \"as-needed\",",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"rangeEnd\": Object {",
                        "      \"default\": Infinity,",
                        "      \"range\": Object {",
                        "        \"end\": Infinity,",
                        "        \"start\": 0,",
                        "        \"step\": 1,",
                        "      },",
                        "      \"type\": \"int\",",
                        "    },",
                        "    \"rangeStart\": Object {",
                        "      \"default\": 0,",
                        "      \"range\": Object {",
                        "        \"end\": Infinity,",
                        "        \"start\": 0,",
                        "        \"step\": 1,",
                        "      },",
                        "      \"type\": \"int\",",
                        "    },",
                        "    \"requirePragma\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"semi\": Object {",
                        "      \"default\": true,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"singleQuote\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"tabWidth\": Object {",
                        "      \"default\": 2,",
                        "      \"range\": Object {",
                        "        \"end\": Infinity,",
                        "        \"start\": 0,",
                        "        \"step\": 1,",
                        "      },",
                        "      \"type\": \"int\",",
                        "    },",
                        "    \"trailingComma\": Object {",
                        "      \"choices\": Array [",
                        "        \"es5\",",
                        "        \"none\",",
                        "        \"all\",",
                        "      ],",
                        "      \"default\": \"es5\",",
                        "      \"type\": \"choice\",",
                        "    },",
                        "    \"useTabs\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "    \"vueIndentScriptAndStyle\": Object {",
                        "      \"default\": false,",
                        "      \"type\": \"boolean\",",
                        "    },",
                        "  },",
                        "}",
                        "`;",
                        "",
                        "exports[`CLI --support-info (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI --support-info (stdout) 1`] = `",
                        "\"{",
                        "  \\\\\"languages\\\\\": [",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"js\\\\\", \\\\\"node\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/javascript\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"color\\\\\": \\\\\"#f1e05a\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".js\\\\\",",
                        "        \\\\\"._js\\\\\",",
                        "        \\\\\".bones\\\\\",",
                        "        \\\\\".cjs\\\\\",",
                        "        \\\\\".es\\\\\",",
                        "        \\\\\".es6\\\\\",",
                        "        \\\\\".frag\\\\\",",
                        "        \\\\\".gs\\\\\",",
                        "        \\\\\".jake\\\\\",",
                        "        \\\\\".jsb\\\\\",",
                        "        \\\\\".jscad\\\\\",",
                        "        \\\\\".jsfl\\\\\",",
                        "        \\\\\".jsm\\\\\",",
                        "        \\\\\".jss\\\\\",",
                        "        \\\\\".mjs\\\\\",",
                        "        \\\\\".njs\\\\\",",
                        "        \\\\\".pac\\\\\",",
                        "        \\\\\".sjs\\\\\",",
                        "        \\\\\".ssjs\\\\\",",
                        "        \\\\\".xsjs\\\\\",",
                        "        \\\\\".xsjslib\\\\\"",
                        "      ],",
                        "      \\\\\"filenames\\\\\": [\\\\\"Jakefile\\\\\"],",
                        "      \\\\\"interpreters\\\\\": [",
                        "        \\\\\"chakra\\\\\",",
                        "        \\\\\"d8\\\\\",",
                        "        \\\\\"gjs\\\\\",",
                        "        \\\\\"js\\\\\",",
                        "        \\\\\"node\\\\\",",
                        "        \\\\\"qjs\\\\\",",
                        "        \\\\\"rhino\\\\\",",
                        "        \\\\\"v8\\\\\",",
                        "        \\\\\"v8-shell\\\\\",",
                        "        \\\\\"nodejs\\\\\"",
                        "      ],",
                        "      \\\\\"linguistLanguageId\\\\\": 183,",
                        "      \\\\\"name\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"babel\\\\\", \\\\\"flow\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.js\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"programming\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"javascript\\\\\", \\\\\"mongo\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"aliases\\\\\": [],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/javascript\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"color\\\\\": \\\\\"#f1e05a\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".js.flow\\\\\"],",
                        "      \\\\\"filenames\\\\\": [],",
                        "      \\\\\"interpreters\\\\\": [",
                        "        \\\\\"chakra\\\\\",",
                        "        \\\\\"d8\\\\\",",
                        "        \\\\\"gjs\\\\\",",
                        "        \\\\\"js\\\\\",",
                        "        \\\\\"node\\\\\",",
                        "        \\\\\"qjs\\\\\",",
                        "        \\\\\"rhino\\\\\",",
                        "        \\\\\"v8\\\\\",",
                        "        \\\\\"v8-shell\\\\\"",
                        "      ],",
                        "      \\\\\"linguistLanguageId\\\\\": 183,",
                        "      \\\\\"name\\\\\": \\\\\"Flow\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"babel\\\\\", \\\\\"flow\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.js\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"programming\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"javascript\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/jsx\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"jsx\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".jsx\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 178,",
                        "      \\\\\"name\\\\\": \\\\\"JSX\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"babel\\\\\", \\\\\"flow\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.js.jsx\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"programming\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"javascriptreact\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"typescript\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"ts\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"application/typescript\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"color\\\\\": \\\\\"#2b7489\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".ts\\\\\"],",
                        "      \\\\\"interpreters\\\\\": [\\\\\"deno\\\\\", \\\\\"ts-node\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 378,",
                        "      \\\\\"name\\\\\": \\\\\"TypeScript\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"typescript\\\\\", \\\\\"babel-ts\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.ts\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"programming\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"typescript\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/jsx\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"jsx\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".tsx\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"TypeScript\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 94901924,",
                        "      \\\\\"name\\\\\": \\\\\"TSX\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"typescript\\\\\", \\\\\"babel-ts\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.tsx\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"programming\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"typescriptreact\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"json\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"application/json\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"extensions\\\\\": [],",
                        "      \\\\\"filenames\\\\\": [\\\\\"package.json\\\\\", \\\\\"package-lock.json\\\\\", \\\\\"composer.json\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 174,",
                        "      \\\\\"name\\\\\": \\\\\"JSON.stringify\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"json-stringify\\\\\"],",
                        "      \\\\\"searchable\\\\\": false,",
                        "      \\\\\"since\\\\\": \\\\\"1.13.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.json\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"data\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"json\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"json\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"application/json\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".json\\\\\",",
                        "        \\\\\".avsc\\\\\",",
                        "        \\\\\".geojson\\\\\",",
                        "        \\\\\".gltf\\\\\",",
                        "        \\\\\".har\\\\\",",
                        "        \\\\\".ice\\\\\",",
                        "        \\\\\".JSON-tmLanguage\\\\\",",
                        "        \\\\\".jsonl\\\\\",",
                        "        \\\\\".mcmeta\\\\\",",
                        "        \\\\\".tfstate\\\\\",",
                        "        \\\\\".tfstate.backup\\\\\",",
                        "        \\\\\".topojson\\\\\",",
                        "        \\\\\".webapp\\\\\",",
                        "        \\\\\".webmanifest\\\\\",",
                        "        \\\\\".yy\\\\\",",
                        "        \\\\\".yyp\\\\\"",
                        "      ],",
                        "      \\\\\"filenames\\\\\": [",
                        "        \\\\\".arcconfig\\\\\",",
                        "        \\\\\".htmlhintrc\\\\\",",
                        "        \\\\\".tern-config\\\\\",",
                        "        \\\\\".tern-project\\\\\",",
                        "        \\\\\".watchmanconfig\\\\\",",
                        "        \\\\\"composer.lock\\\\\",",
                        "        \\\\\"mcmod.info\\\\\",",
                        "        \\\\\".prettierrc\\\\\"",
                        "      ],",
                        "      \\\\\"linguistLanguageId\\\\\": 174,",
                        "      \\\\\"name\\\\\": \\\\\"JSON\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"json\\\\\"],",
                        "      \\\\\"searchable\\\\\": false,",
                        "      \\\\\"since\\\\\": \\\\\"1.5.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.json\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"data\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"json\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"jsonc\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/javascript\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".jsonc\\\\\",",
                        "        \\\\\".sublime-build\\\\\",",
                        "        \\\\\".sublime-commands\\\\\",",
                        "        \\\\\".sublime-completions\\\\\",",
                        "        \\\\\".sublime-keymap\\\\\",",
                        "        \\\\\".sublime-macro\\\\\",",
                        "        \\\\\".sublime-menu\\\\\",",
                        "        \\\\\".sublime-mousemap\\\\\",",
                        "        \\\\\".sublime-project\\\\\",",
                        "        \\\\\".sublime-settings\\\\\",",
                        "        \\\\\".sublime-theme\\\\\",",
                        "        \\\\\".sublime-workspace\\\\\",",
                        "        \\\\\".sublime_metrics\\\\\",",
                        "        \\\\\".sublime_session\\\\\"",
                        "      ],",
                        "      \\\\\"filenames\\\\\": [",
                        "        \\\\\".babelrc\\\\\",",
                        "        \\\\\".eslintrc.json\\\\\",",
                        "        \\\\\".jscsrc\\\\\",",
                        "        \\\\\".jshintrc\\\\\",",
                        "        \\\\\".jslintrc\\\\\",",
                        "        \\\\\"jsconfig.json\\\\\",",
                        "        \\\\\"language-configuration.json\\\\\",",
                        "        \\\\\"tsconfig.json\\\\\",",
                        "        \\\\\".eslintrc\\\\\"",
                        "      ],",
                        "      \\\\\"group\\\\\": \\\\\"JSON\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 423,",
                        "      \\\\\"name\\\\\": \\\\\"JSON with Comments\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"json\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.5.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.js\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"data\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"jsonc\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"application/json\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"javascript\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".json5\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 175,",
                        "      \\\\\"name\\\\\": \\\\\"JSON5\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"json5\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.13.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.js\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"data\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"json5\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/css\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"color\\\\\": \\\\\"#563d7c\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".css\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 50,",
                        "      \\\\\"name\\\\\": \\\\\"CSS\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"css\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.css\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"markup\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"css\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"text\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".pcss\\\\\", \\\\\".postcss\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"CSS\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 262764437,",
                        "      \\\\\"name\\\\\": \\\\\"PostCSS\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"css\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.postcss\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"markup\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"postcss\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"less\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/css\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".less\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"CSS\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 198,",
                        "      \\\\\"name\\\\\": \\\\\"Less\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"less\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.css.less\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"markup\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"less\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"scss\\\\\",",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/x-scss\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".scss\\\\\"],",
                        "      \\\\\"group\\\\\": \\\\\"CSS\\\\\",",
                        "      \\\\\"linguistLanguageId\\\\\": 329,",
                        "      \\\\\"name\\\\\": \\\\\"SCSS\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"scss\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.css.scss\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"markup\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"scss\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"text\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".graphql\\\\\", \\\\\".gql\\\\\", \\\\\".graphqls\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 139,",
                        "      \\\\\"name\\\\\": \\\\\"GraphQL\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"graphql\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.5.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.graphql\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"data\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"graphql\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"markdown\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"pandoc\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/x-gfm\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"gfm\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".md\\\\\",",
                        "        \\\\\".markdown\\\\\",",
                        "        \\\\\".mdown\\\\\",",
                        "        \\\\\".mdwn\\\\\",",
                        "        \\\\\".mkd\\\\\",",
                        "        \\\\\".mkdn\\\\\",",
                        "        \\\\\".mkdown\\\\\",",
                        "        \\\\\".ronn\\\\\",",
                        "        \\\\\".workbook\\\\\"",
                        "      ],",
                        "      \\\\\"filenames\\\\\": [\\\\\"contents.lr\\\\\", \\\\\"README\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 222,",
                        "      \\\\\"name\\\\\": \\\\\"Markdown\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"markdown\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.8.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.gfm\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"prose\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"markdown\\\\\"],",
                        "      \\\\\"wrap\\\\\": true",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"markdown\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"pandoc\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/x-gfm\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"gfm\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".mdx\\\\\"],",
                        "      \\\\\"filenames\\\\\": [],",
                        "      \\\\\"linguistLanguageId\\\\\": 222,",
                        "      \\\\\"name\\\\\": \\\\\"MDX\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"mdx\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.15.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.gfm\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"prose\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"mdx\\\\\"],",
                        "      \\\\\"wrap\\\\\": true",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"html\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"xhtml\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/html\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"htmlmixed\\\\\",",
                        "      \\\\\"color\\\\\": \\\\\"#e34c26\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".component.html\\\\\"],",
                        "      \\\\\"filenames\\\\\": [],",
                        "      \\\\\"linguistLanguageId\\\\\": 146,",
                        "      \\\\\"name\\\\\": \\\\\"Angular\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"angular\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.15.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"text.html.basic\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"markup\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"html\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"html\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"xhtml\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/html\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"htmlmixed\\\\\",",
                        "      \\\\\"color\\\\\": \\\\\"#e34c26\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".html\\\\\",",
                        "        \\\\\".htm\\\\\",",
                        "        \\\\\".html.hl\\\\\",",
                        "        \\\\\".inc\\\\\",",
                        "        \\\\\".st\\\\\",",
                        "        \\\\\".xht\\\\\",",
                        "        \\\\\".xhtml\\\\\",",
                        "        \\\\\".mjml\\\\\"",
                        "      ],",
                        "      \\\\\"linguistLanguageId\\\\\": 146,",
                        "      \\\\\"name\\\\\": \\\\\"HTML\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"html\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.15.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"text.html.basic\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"markup\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"html\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"html\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"xhtml\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/html\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"htmlmixed\\\\\",",
                        "      \\\\\"color\\\\\": \\\\\"#e34c26\\\\\",",
                        "      \\\\\"extensions\\\\\": [],",
                        "      \\\\\"filenames\\\\\": [],",
                        "      \\\\\"linguistLanguageId\\\\\": 146,",
                        "      \\\\\"name\\\\\": \\\\\"Lightning Web Components\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"lwc\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.17.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"text.html.basic\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"markup\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"html\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"html\\\\\",",
                        "      \\\\\"color\\\\\": \\\\\"#2c3e50\\\\\",",
                        "      \\\\\"extensions\\\\\": [\\\\\".vue\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 391,",
                        "      \\\\\"name\\\\\": \\\\\"Vue\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"vue\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.10.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"text.html.vue\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"markup\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"vue\\\\\"]",
                        "    },",
                        "    {",
                        "      \\\\\"aceMode\\\\\": \\\\\"yaml\\\\\",",
                        "      \\\\\"aliases\\\\\": [\\\\\"yml\\\\\"],",
                        "      \\\\\"codemirrorMimeType\\\\\": \\\\\"text/x-yaml\\\\\",",
                        "      \\\\\"codemirrorMode\\\\\": \\\\\"yaml\\\\\",",
                        "      \\\\\"extensions\\\\\": [",
                        "        \\\\\".yml\\\\\",",
                        "        \\\\\".mir\\\\\",",
                        "        \\\\\".reek\\\\\",",
                        "        \\\\\".rviz\\\\\",",
                        "        \\\\\".sublime-syntax\\\\\",",
                        "        \\\\\".syntax\\\\\",",
                        "        \\\\\".yaml\\\\\",",
                        "        \\\\\".yaml-tmlanguage\\\\\",",
                        "        \\\\\".yaml.sed\\\\\",",
                        "        \\\\\".yml.mysql\\\\\"",
                        "      ],",
                        "      \\\\\"filenames\\\\\": [\\\\\".clang-format\\\\\", \\\\\".clang-tidy\\\\\", \\\\\".gemrc\\\\\", \\\\\"glide.lock\\\\\"],",
                        "      \\\\\"linguistLanguageId\\\\\": 407,",
                        "      \\\\\"name\\\\\": \\\\\"YAML\\\\\",",
                        "      \\\\\"parsers\\\\\": [\\\\\"yaml\\\\\"],",
                        "      \\\\\"since\\\\\": \\\\\"1.14.0\\\\\",",
                        "      \\\\\"tmScope\\\\\": \\\\\"source.yaml\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"data\\\\\",",
                        "      \\\\\"vscodeLanguageIds\\\\\": [\\\\\"yaml\\\\\", \\\\\"ansible\\\\\"]",
                        "    }",
                        "  ],",
                        "  \\\\\"options\\\\\": [",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Always include parens. Example: \\`(x) => x\\`\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"always\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Omit parens when possible. Example: \\`x => x\\`\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"avoid\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"always\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"Include parentheses around a sole arrow function parameter.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"arrowParens\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.9.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Common\\\\\",",
                        "      \\\\\"default\\\\\": true,",
                        "      \\\\\"description\\\\\": \\\\\"Print spaces between brackets.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"bracketSpacing\\\\\",",
                        "      \\\\\"oppositeDescription\\\\\": \\\\\"Do not print spaces between brackets.\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": -1,",
                        "      \\\\\"description\\\\\": \\\\\"Print (to stderr) where a cursor at the given position would move to after formatting.\\\\\\\\nThis option cannot be used with --range-start and --range-end.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"cursorOffset\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": -1, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Format embedded code if Prettier can automatically identify it.\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"auto\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Never automatically format embedded code.\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"off\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"auto\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"Control how Prettier formats quoted code embedded in the file.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"embeddedLanguageFormatting\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"2.1.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Line Feed only (\\\\\\\\\\\\\\\\n), common on Linux and macOS as well as inside git repos\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"lf\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Carriage Return + Line Feed characters (\\\\\\\\\\\\\\\\r\\\\\\\\\\\\\\\\n), common on Windows\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"crlf\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Carriage Return character only (\\\\\\\\\\\\\\\\r), used very rarely\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"cr\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Maintain existing\\\\\\\\n(mixed values within one file are normalised by looking at what's used after the first line)\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"auto\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"lf\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"Which end of line characters to apply.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"endOfLine\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.15.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"Specify the input filepath. This will be used to do parser inference.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"filepath\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"path\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"HTML\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Respect the default value of CSS display property.\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"css\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Whitespaces are considered sensitive.\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"strict\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Whitespaces are considered insensitive.\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"ignore\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"css\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"How to handle whitespaces in HTML.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"htmlWhitespaceSensitivity\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.15.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Insert @format pragma into file's first docblock comment.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"insertPragma\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.8.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Put > on the last line instead of at a new line.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"jsxBracketSameLine\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.17.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Use single quotes in JSX.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"jsxSingleQuote\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.15.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        { \\\\\"description\\\\\": \\\\\"Flow\\\\\", \\\\\"value\\\\\": \\\\\"flow\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"JavaScript\\\\\", \\\\\"since\\\\\": \\\\\"1.16.0\\\\\", \\\\\"value\\\\\": \\\\\"babel\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"Flow\\\\\", \\\\\"since\\\\\": \\\\\"1.16.0\\\\\", \\\\\"value\\\\\": \\\\\"babel-flow\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"TypeScript\\\\\", \\\\\"since\\\\\": \\\\\"2.0.0\\\\\", \\\\\"value\\\\\": \\\\\"babel-ts\\\\\" },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"TypeScript\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"typescript\\\\\"",
                        "        },",
                        "        { \\\\\"description\\\\\": \\\\\"CSS\\\\\", \\\\\"since\\\\\": \\\\\"1.7.1\\\\\", \\\\\"value\\\\\": \\\\\"css\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"Less\\\\\", \\\\\"since\\\\\": \\\\\"1.7.1\\\\\", \\\\\"value\\\\\": \\\\\"less\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"SCSS\\\\\", \\\\\"since\\\\\": \\\\\"1.7.1\\\\\", \\\\\"value\\\\\": \\\\\"scss\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"JSON\\\\\", \\\\\"since\\\\\": \\\\\"1.5.0\\\\\", \\\\\"value\\\\\": \\\\\"json\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"JSON5\\\\\", \\\\\"since\\\\\": \\\\\"1.13.0\\\\\", \\\\\"value\\\\\": \\\\\"json5\\\\\" },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"JSON.stringify\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.13.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"json-stringify\\\\\"",
                        "        },",
                        "        { \\\\\"description\\\\\": \\\\\"GraphQL\\\\\", \\\\\"since\\\\\": \\\\\"1.5.0\\\\\", \\\\\"value\\\\\": \\\\\"graphql\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"Markdown\\\\\", \\\\\"since\\\\\": \\\\\"1.8.0\\\\\", \\\\\"value\\\\\": \\\\\"markdown\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"MDX\\\\\", \\\\\"since\\\\\": \\\\\"1.15.0\\\\\", \\\\\"value\\\\\": \\\\\"mdx\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"Vue\\\\\", \\\\\"since\\\\\": \\\\\"1.10.0\\\\\", \\\\\"value\\\\\": \\\\\"vue\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"YAML\\\\\", \\\\\"since\\\\\": \\\\\"1.14.0\\\\\", \\\\\"value\\\\\": \\\\\"yaml\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"HTML\\\\\", \\\\\"since\\\\\": \\\\\"1.15.0\\\\\", \\\\\"value\\\\\": \\\\\"html\\\\\" },",
                        "        { \\\\\"description\\\\\": \\\\\"Angular\\\\\", \\\\\"since\\\\\": \\\\\"1.15.0\\\\\", \\\\\"value\\\\\": \\\\\"angular\\\\\" },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Lightning Web Components\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.17.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"lwc\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"description\\\\\": \\\\\"Which parser to use.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"parser\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.0.10\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"array\\\\\": true,",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": [],",
                        "      \\\\\"description\\\\\": \\\\\"Custom directory that contains prettier plugins in node_modules subdirectory.\\\\\\\\nOverrides default behavior when plugins are searched relatively to the location of Prettier.\\\\\\\\nMultiple values are accepted.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"pluginSearchDirs\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.13.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"path\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"array\\\\\": true,",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": [],",
                        "      \\\\\"description\\\\\": \\\\\"Add a plugin. Multiple plugins can be passed as separate \\`--plugin\\`s.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"plugins\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.10.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"path\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": 80,",
                        "      \\\\\"description\\\\\": \\\\\"The line length where Prettier will try wrap.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"printWidth\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": 0, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Common\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Wrap prose if it exceeds the print width.\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.9.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"always\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Do not wrap prose.\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.9.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"never\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Wrap prose as-is.\\\\\",",
                        "          \\\\\"since\\\\\": \\\\\"1.9.0\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"preserve\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"preserve\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"How to wrap prose.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"proseWrap\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.8.2\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Only add quotes around object properties where required.\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"as-needed\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"If at least one property in an object requires quotes, quote all properties.\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"consistent\\\\\"",
                        "        },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Respect the input use of quotes in object properties.\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"preserve\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"as-needed\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"Change when properties in objects are quoted.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"quoteProps\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.17.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": null,",
                        "      \\\\\"description\\\\\": \\\\\"Format code ending at a given character offset (exclusive).\\\\\\\\nThe range will extend forwards to the end of the selected statement.\\\\\\\\nThis option cannot be used with --cursor-offset.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"rangeEnd\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": 0, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": 0,",
                        "      \\\\\"description\\\\\": \\\\\"Format code starting at a given character offset.\\\\\\\\nThe range will extend backwards to the start of the first line containing the selected statement.\\\\\\\\nThis option cannot be used with --cursor-offset.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"rangeStart\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": 0, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"since\\\\\": \\\\\"1.4.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Special\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Require either '@prettier' or '@format' to be present in the file's first docblock comment\\\\\\\\nin order for it to be formatted.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"requirePragma\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.7.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"default\\\\\": true,",
                        "      \\\\\"description\\\\\": \\\\\"Print semicolons.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"semi\\\\\",",
                        "      \\\\\"oppositeDescription\\\\\": \\\\\"Do not print semicolons, except at the beginning of lines which may need them.\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Common\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Use single quotes instead of double quotes.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"singleQuote\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": 2,",
                        "      \\\\\"description\\\\\": \\\\\"Number of spaces per indentation level.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"tabWidth\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"range\\\\\": { \\\\\"end\\\\\": null, \\\\\"start\\\\\": 0, \\\\\"step\\\\\": 1 },",
                        "      \\\\\"type\\\\\": \\\\\"int\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"JavaScript\\\\\",",
                        "      \\\\\"choices\\\\\": [",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Trailing commas where valid in ES5 (objects, arrays, etc.)\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"es5\\\\\"",
                        "        },",
                        "        { \\\\\"description\\\\\": \\\\\"No trailing commas.\\\\\", \\\\\"value\\\\\": \\\\\"none\\\\\" },",
                        "        {",
                        "          \\\\\"description\\\\\": \\\\\"Trailing commas wherever possible (including function arguments).\\\\\",",
                        "          \\\\\"value\\\\\": \\\\\"all\\\\\"",
                        "        }",
                        "      ],",
                        "      \\\\\"default\\\\\": \\\\\"es5\\\\\",",
                        "      \\\\\"description\\\\\": \\\\\"Print trailing commas wherever possible when multi-line.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"trailingComma\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"0.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"choice\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"Global\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Indent with tabs instead of spaces.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"useTabs\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.0.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    },",
                        "    {",
                        "      \\\\\"category\\\\\": \\\\\"HTML\\\\\",",
                        "      \\\\\"default\\\\\": false,",
                        "      \\\\\"description\\\\\": \\\\\"Indent script and style tags in Vue files.\\\\\",",
                        "      \\\\\"name\\\\\": \\\\\"vueIndentScriptAndStyle\\\\\",",
                        "      \\\\\"pluginDefaults\\\\\": {},",
                        "      \\\\\"since\\\\\": \\\\\"1.19.0\\\\\",",
                        "      \\\\\"type\\\\\": \\\\\"boolean\\\\\"",
                        "    }",
                        "  ]",
                        "}",
                        "",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI --support-info (write) 1`] = `Array []`;"
                    ]
                },
                "syntax-error.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`exits with non-zero code when input has a syntax error (stderr) 1`] = `",
                        "\"[error] stdin: SyntaxError: Unexpected token, expected \\\\\";\\\\\" (1:2)",
                        "[error] > 1 | a.2",
                        "[error]     |  ^",
                        "\"",
                        "`;",
                        "",
                        "exports[`exits with non-zero code when input has a syntax error (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`exits with non-zero code when input has a syntax error (write) 1`] = `Array []`;"
                    ]
                },
                "with-config-precedence.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence cli-override (stdout) 1`] = `",
                        "\"let x: keyof Y = foo<typeof X>()",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence cli-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence file-override (stdout) 1`] = `",
                        "\"let x: keyof Y = foo<typeof X>();",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence file-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence prefer-file (stdout) 1`] = `",
                        "\"let x: keyof Y = foo<typeof X>();",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI --stdin-filepath works with --config-precedence prefer-file (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides are still applied when no config is found with --config-precedence file-override (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides are still applied when no config is found with --config-precedence file-override (stdout) 1`] = `",
                        "\"function noConfigJs() {",
                        "      console.log(\\\\\"no-config/file.js should have no semicolons\\\\\")",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides are still applied when no config is found with --config-precedence file-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides gets applied when no config exists with --config-precedence prefer-file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides gets applied when no config exists with --config-precedence prefer-file (stdout) 1`] = `",
                        "\"function noConfigJs() {",
                        "       console.log(",
                        "              \\\\\"no-config/file.js should have no semicolons\\\\\"",
                        "       );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides gets applied when no config exists with --config-precedence prefer-file (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides gets ignored when config exists with --config-precedence prefer-file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides gets ignored when config exists with --config-precedence prefer-file (stdout) 1`] = `",
                        "\"function js() {",
                        "        console.log(\\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\");",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        endOfLine: \\\\\"auto\\\\\",",
                        "        tabWidth: 8,",
                        "};",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides gets ignored when config exists with --config-precedence prefer-file (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides take lower precedence with --config-precedence file-override (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides take lower precedence with --config-precedence file-override (stdout) 1`] = `",
                        "\"function js() {",
                        "        console.log(\\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\");",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        endOfLine: \\\\\"auto\\\\\",",
                        "        tabWidth: 8,",
                        "};",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides take lower precedence with --config-precedence file-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides take precedence with --config-precedence cli-override (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides take precedence with --config-precedence cli-override (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(",
                        "\t\t\\\\\"should have tab width 8\\\\\"",
                        "\t)",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2\\\\\"",
                        "  )",
                        "}",
                        "function f() {",
                        "        console.log(",
                        "                \\\\\"should have space width 8\\\\\"",
                        "        )",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\\\\\"",
                        "  )",
                        "}",
                        "console.log(",
                        "  \\\\\"should have no semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/.file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/Component.js should not have semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/Component.test.js should have semi\\\\\"",
                        ");",
                        "function js() {",
                        "        console.log(",
                        "                \\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\"",
                        "        );",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        endOfLine:",
                        "                \\\\\"auto\\\\\",",
                        "        tabWidth: 8,",
                        "};",
                        "function noConfigJs() {",
                        "  console.log(",
                        "    \\\\\"no-config/file.js should have no semicolons\\\\\"",
                        "  )",
                        "}",
                        "function packageJs() {",
                        "   console.log(",
                        "      \\\\\"package/file.js should have tab width 3\\\\\"",
                        "   );",
                        "}",
                        "function rcJson() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-json/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcToml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-toml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcYaml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-yaml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides take precedence with --config-precedence cli-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI overrides take precedence without --config-precedence (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI overrides take precedence without --config-precedence (stdout) 1`] = `",
                        "\"function f() {",
                        "\tconsole.log(",
                        "\t\t\\\\\"should have tab width 8\\\\\"",
                        "\t)",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2\\\\\"",
                        "  )",
                        "}",
                        "function f() {",
                        "        console.log(",
                        "                \\\\\"should have space width 8\\\\\"",
                        "        )",
                        "}",
                        "function f() {",
                        "  console.log(",
                        "    \\\\\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\\\\\"",
                        "  )",
                        "}",
                        "console.log(",
                        "  \\\\\"should have no semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/.file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/__best-tests__/file.js should have semi\\\\\"",
                        ");",
                        "console.log(",
                        "  \\\\\"jest/Component.js should not have semi\\\\\"",
                        ")",
                        "console.log(",
                        "  \\\\\"jest/Component.test.js should have semi\\\\\"",
                        ");",
                        "function js() {",
                        "        console.log(",
                        "                \\\\\"js/file.js should have tab width 8 (1 if CLI)\\\\\"",
                        "        );",
                        "}",
                        "\\\\\"use strict\\\\\";",
                        "",
                        "module.exports = {",
                        "        endOfLine:",
                        "                \\\\\"auto\\\\\",",
                        "        tabWidth: 8,",
                        "};",
                        "function noConfigJs() {",
                        "  console.log(",
                        "    \\\\\"no-config/file.js should have no semicolons\\\\\"",
                        "  )",
                        "}",
                        "function packageJs() {",
                        "   console.log(",
                        "      \\\\\"package/file.js should have tab width 3\\\\\"",
                        "   );",
                        "}",
                        "function rcJson() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-json/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcToml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-toml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "function rcYaml() {",
                        "  console.log.apply(",
                        "    null,",
                        "    [",
                        "      'rc-yaml/file.js',",
                        "      'should have trailing comma',",
                        "      'and single quotes',",
                        "    ],",
                        "  );",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI overrides take precedence without --config-precedence (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI validate options with --config-precedence cli-override (stderr) 1`] = `",
                        "\"[error] Invalid printWidth value. Expected an integer, but received 0.5.",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI validate options with --config-precedence cli-override (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI validate options with --config-precedence cli-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI validate options with --config-precedence file-override (stderr) 1`] = `",
                        "\"[error] Invalid printWidth value. Expected an integer, but received 0.5.",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI validate options with --config-precedence file-override (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI validate options with --config-precedence file-override (write) 1`] = `Array []`;",
                        "",
                        "exports[`CLI validate options with --config-precedence prefer-file (stderr) 1`] = `",
                        "\"[error] Invalid printWidth value. Expected an integer, but received 0.5.",
                        "\"",
                        "`;",
                        "",
                        "exports[`CLI validate options with --config-precedence prefer-file (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`CLI validate options with --config-precedence prefer-file (write) 1`] = `Array []`;"
                    ]
                },
                "with-node-modules.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag (stdout) 1`] = `",
                        "\"nested/node_modules/node-module.js",
                        "node_modules/node-module.js",
                        "not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag (write) 1`] = `Array []`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag for file list (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag for file list (stdout) 1`] = `",
                        "\"node_modules/node-module.js",
                        "not_node_modules/file.js",
                        "nested/node_modules/node-module.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`doesn't ignore node_modules with --with-node-modules flag for file list (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignores node_modules by default (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores node_modules by default (stdout) 1`] = `",
                        "\"not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignores node_modules by default (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignores node_modules by default for file list (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores node_modules by default for file list (stdout) 1`] = `",
                        "\"not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignores node_modules by default for file list (write) 1`] = `Array []`;",
                        "",
                        "exports[`ignores node_modules by with ./**/*.js (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`ignores node_modules by with ./**/*.js (stdout) 1`] = `",
                        "\"not_node_modules/file.js",
                        "regular-module.js",
                        "\"",
                        "`;",
                        "",
                        "exports[`ignores node_modules by with ./**/*.js (write) 1`] = `Array []`;"
                    ]
                },
                "with-parser-inference.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`infers postcss parser (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`infers postcss parser (stdout) 1`] = `",
                        "\"/* JavaScript */",
                        "\\\\\"use strict\\\\\";",
                        "/* Stylesheet */",
                        "* {",
                        "  outline: none;",
                        "}",
                        "\"",
                        "`;",
                        "",
                        "exports[`infers postcss parser (write) 1`] = `Array []`;",
                        "",
                        "exports[`infers postcss parser with --check (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`infers postcss parser with --check (stdout) 1`] = `",
                        "\"Checking formatting...",
                        "All matched files use Prettier code style!",
                        "\"",
                        "`;",
                        "",
                        "exports[`infers postcss parser with --check (write) 1`] = `Array []`;",
                        "",
                        "exports[`infers postcss parser with --list-different (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`infers postcss parser with --list-different (stdout) 1`] = `\"\"`;",
                        "",
                        "exports[`infers postcss parser with --list-different (write) 1`] = `Array []`;"
                    ]
                },
                "with-shebang.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`preserves shebang (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`preserves shebang (stdout) 1`] = `",
                        "\"#!/usr/bin/env node",
                        "\\\\\"use strict\\\\\";",
                        "\"",
                        "`;",
                        "",
                        "exports[`preserves shebang (write) 1`] = `Array []`;"
                    ]
                },
                "write.js.snap": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Jest Snapshot v1, https://goo.gl/fbAQLP",
                        "",
                        "exports[`do not write file with --write + formatted file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`do not write file with --write + formatted file (stdout) 1`] = `",
                        "\"formatted.js 0ms",
                        "\"",
                        "`;",
                        "",
                        "exports[`do not write file with --write + invalid file (stderr) 1`] = `",
                        "\"[error] invalid.js: SyntaxError: Unexpected token, expected \\\\\";\\\\\" (1:6)",
                        "[error] > 1 | this is invalid!",
                        "[error]     |      ^",
                        "\"",
                        "`;",
                        "",
                        "exports[`do not write file with --write + invalid file (stdout) 1`] = `",
                        "\"",
                        "\"",
                        "`;",
                        "",
                        "exports[`write file with --write + unformatted file (stderr) 1`] = `\"\"`;",
                        "",
                        "exports[`write file with --write + unformatted file (stdout) 1`] = `",
                        "\"unformatted.js 0ms",
                        "\"",
                        "`;",
                        "",
                        "exports[`write file with --write + unformatted file (write) 1`] = `",
                        "Array [",
                        "  Object {",
                        "    \"content\": \"var x = 1;",
                        "\",",
                        "    \"filename\": \"unformatted.js\",",
                        "  },",
                        "]",
                        "`;"
                    ]
                }
            }
        },
        "cli": {
            "arg-parsing": {
                "file.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "console.log(\"could be single quote and without semi\")"
                    ]
                }
            },
            "config": {
                ".prettierrc": {},
                "$schema": {
                    ".prettierrc": {},
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": []
                    }
                },
                "dot-overrides": {
                    ".prettierrc": {}
                },
                "editorconfig": {
                    ".editorconfig": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function f() {",
                            "  console.log(\"should have tab width 8\");",
                            "}"
                        ]
                    },
                    "lib": {
                        "file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "function f() {",
                                "  console.log(\"should have space width 2\");",
                                "}"
                            ]
                        },
                        "indent_size=tab.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "function f() {",
                                "  console.log(\"should have space width 8\");",
                                "}"
                            ]
                        }
                    },
                    "repo-root": {
                        ".hg": {},
                        "file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "function f() {",
                                "  console.log(\"should have space width 2 despite ../.editorconfig specifying 8, because ./.hg is present\");",
                                "}"
                            ]
                        }
                    }
                },
                "external-config": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "console.log(\"should have no semi\");"
                        ]
                    },
                    "package.json": {}
                },
                "filepath": {
                    ".prettierrc": {},
                    "subfolder": {
                        "file.js": {
                            "classes": [],
                            "functions": [],
                            "text": []
                        }
                    }
                },
                "invalid": {
                    "file": {
                        ".prettierrc": {},
                        ".prettierrc.unsupported": {}
                    },
                    "folder": {
                        ".prettierrc": {
                            "placeholder": {}
                        }
                    },
                    "option": {
                        "configPrecedence": {},
                        "int": {},
                        "kebab-case": {},
                        "trailingComma": {},
                        "unknown": {}
                    }
                },
                "jest": {
                    ".prettierrc": {},
                    "Component.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "console.log(\"jest/Component.js should not have semi\")"
                        ]
                    },
                    "Component.test.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "console.log(\"jest/Component.test.js should have semi\");"
                        ]
                    },
                    "__best-tests__": {
                        ".file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "console.log(\"jest/__best-tests__/.file.js should have semi\");"
                            ]
                        },
                        "file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "console.log(\"jest/__best-tests__/file.js should have semi\");"
                            ]
                        }
                    }
                },
                "js": {
                    ".editorconfig": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function js() {",
                            "  console.log(\"js/file.js should have tab width 8 (1 if CLI)\");",
                            "}"
                        ]
                    },
                    "prettier.config.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "module.exports = {",
                            "  endOfLine: 'auto',",
                            "  tabWidth: 8",
                            "};"
                        ]
                    }
                },
                "no-config": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function noConfigJs() {",
                            "  console.log(\"no-config/file.js should have no semicolons\");",
                            "}"
                        ]
                    },
                    "file.ts": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function noConfigTs() {",
                            "  console.log(\"no-config/file.ts should have semicolons because it has a .ts extension\");",
                            "}"
                        ]
                    }
                },
                "package": {
                    ".editorconfig": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function packageJs() {",
                            "  console.log(\"package/file.js should have tab width 3\");",
                            "}"
                        ]
                    },
                    "file.ts": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function packageTs() {",
                            "  console.log(\"package/file.ts should have tab width 5 because it has .ts extension\");",
                            "}"
                        ]
                    },
                    "package.json": {}
                },
                "rc-json": {
                    ".prettierrc.json": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function rcJson() {",
                            "  console.log.apply(null, [",
                            "    \"rc-json/file.js\",",
                            "    \"should have trailing comma\",",
                            "    \"and single quotes\"",
                            "  ]);",
                            "}"
                        ]
                    }
                },
                "rc-toml": {
                    ".prettierrc.toml": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function rcToml() {",
                            "  console.log.apply(null, [",
                            "    \"rc-toml/file.js\",",
                            "    \"should have trailing comma\",",
                            "    \"and single quotes\"",
                            "  ]);",
                            "}"
                        ]
                    }
                },
                "rc-yaml": {
                    ".prettierrc.yaml": {},
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "function rcYaml() {",
                            "  console.log.apply(null, [",
                            "    \"rc-yaml/file.js\",",
                            "    \"should have trailing comma\",",
                            "    \"and single quotes\"",
                            "  ]);",
                            "}"
                        ]
                    }
                },
                "resolve-relative": {
                    ".prettierrc": {}
                }
            },
            "config-external-config-syntax-error": {
                "package.json": {},
                "syntax-error.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "throw new SyntaxError(\"THIS ERROR MESSAGE MUST COME FROM THIS syntax-error.js FILE\");"
                    ]
                }
            },
            "config-precedence": {
                ".prettierrc": {}
            },
            "debug-check": {
                "a.debug-check": {},
                "b.debug-check": {},
                "issue-4599.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "console.log(\"\");"
                    ]
                },
                "plugin-for-testing-debug-check.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"debug-check\",",
                        "      parsers: [\"debug-check-parser\"],",
                        "      extensions: [\".debug-check\"]",
                        "    }",
                        "  ],",
                        "  parsers: {",
                        "    \"debug-check-parser\": {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"debug-check-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"debug-check-ast\": {",
                        "      print: path => path.getValue().text + path.getValue().text",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "ignore-absolute-path": {
                ".prettierignore": {},
                "regular-module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "depth1": {
                    "ignored": {
                        "module.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        }
                    }
                },
                "ignored": {
                    ".prettierrc.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "throw Error('This config should not be evaluated since the directory is ignored');"
                        ]
                    },
                    "module.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    }
                }
            },
            "ignore-emoji": {
                ".prettierignore": {},
                "not-ignored.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const foo",
                        "=         'bar'",
                        ";"
                    ]
                },
                "ignored": {
                    "1.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "const foo",
                            "=         'bar'",
                            ";"
                        ]
                    },
                    ".js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "const foo",
                            "=         'bar'",
                            ";"
                        ]
                    },
                    ".js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "const foo",
                            "=         'bar'",
                            ";"
                        ]
                    }
                }
            },
            "ignore-in-subdirectories": {
                ".prettierignore": {},
                "web1": {
                    "should-not-ignore.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "var x = 'this should be formatted';"
                        ]
                    },
                    "ignore-me": {
                        "should-ignore.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "var x = 'this should not be formatted';"
                            ]
                        },
                        "subdirectory": {
                            "should-ignore.js": {
                                "classes": [],
                                "functions": [],
                                "text": [
                                    "var x = 'this should not be formatted';"
                                ]
                            }
                        }
                    }
                },
                "web2": {
                    "should-not-ignore.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "var x = 'this should be formatted';"
                        ]
                    }
                }
            },
            "ignore-path": {
                ".gitignore": {},
                ".prettierignore": {},
                "other-regular-modules.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "regular-module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                }
            },
            "ignore-relative-path": {
                ".prettierignore": {},
                "shouldNotBeIgnored.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "var x = 'this should be formatted';",
                        ""
                    ]
                },
                "level1": {
                    "level2": {
                        ".prettierrc.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "throw Error('This config should not be evaluated since the directory is ignored');"
                            ]
                        },
                        "level3": {
                            "shouldNotBeFormat.js": {
                                "classes": [],
                                "functions": [],
                                "text": [
                                    "var x = 'this should not be formatted';"
                                ]
                            }
                        }
                    }
                },
                "level1-glob": {
                    "shouldNotBeIgnored.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "var x = 'this should be formatted';",
                            ""
                        ]
                    },
                    "level2-glob": {
                        "level3-glob": {
                            "shouldNotBeFormat.js": {
                                "classes": [],
                                "functions": [],
                                "text": [
                                    "var x = 'this should not be formatted';"
                                ]
                            },
                            "shouldNotBeIgnored.scss": {}
                        }
                    }
                }
            },
            "ignore-vcs-files": {
                "file.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                ".hg": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    }
                },
                ".svn": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "/* eslint-disable */",
                            "'use strict';"
                        ]
                    }
                }
            },
            "infer-parser": {
                "FOO": {},
                "foo.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "foo  (    )"
                    ]
                }
            },
            "invalid-ignore": {
                "something.js": {
                    "classes": [],
                    "functions": [],
                    "text": []
                },
                ".prettierignore": {
                    "placeholder": {}
                }
            },
            "loglevel": {
                ".prettierrc": {}
            },
            "patterns": {
                "file.will-never-support": {},
                "other-regular-modules.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "other-supported-file.css": {},
                "regular-module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "directory": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    },
                    "nested-directory": {
                        "nested-directory-file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        }
                    }
                },
                "other-directory": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    },
                    "nested-directory": {
                        "nested-directory-file.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        }
                    }
                }
            },
            "patterns-dirs": {
                ".gitignore": {},
                "yarn.lock": {},
                "!dir": {
                    "a.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    }
                },
                "dir1": {
                    "a1.foo": {},
                    "a1.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    },
                    "b1.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    },
                    "nested1": {
                        "an1.css": {},
                        "an1.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        },
                        "bn1.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        }
                    }
                },
                "dir2": {
                    "a2.foo": {},
                    "a2.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    },
                    "b2.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    },
                    "node-shebang": {},
                    "nested2": {
                        "an2.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        },
                        "bn2.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "'use strict';"
                            ]
                        }
                    }
                },
                "empty": {
                    ".gitignore": {}
                }
            },
            "patterns-glob": {
                "fixtures-1": {
                    "!file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "foo.",
                            "bar()"
                        ]
                    },
                    "a.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "foo.",
                            "bar()"
                        ]
                    },
                    "b.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "foo.",
                            "bar()"
                        ]
                    }
                },
                "fixtures-2": {
                    "!b.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "foo.",
                            "bar()"
                        ]
                    },
                    "a.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "foo.",
                            "bar()"
                        ]
                    },
                    "!dir.js": {
                        "1.css": {},
                        "2.css": {}
                    }
                },
                "fixtures-3": {
                    "outside.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "foo",
                            ".bar()"
                        ]
                    },
                    "dir": {
                        "inside.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "foo",
                                ".bar()"
                            ]
                        },
                        ".svn": {
                            "in-svn.js": {
                                "classes": [],
                                "functions": [],
                                "text": [
                                    "foo",
                                    ".bar()"
                                ]
                            }
                        }
                    }
                },
                "fixtures-4": {
                    "level-0.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "foo",
                            ".bar()"
                        ]
                    },
                    "0": {
                        "level-1.js": {
                            "classes": [],
                            "functions": [],
                            "text": [
                                "foo",
                                ".bar()"
                            ]
                        },
                        "1": {
                            "level-2.js": {
                                "classes": [],
                                "functions": [],
                                "text": [
                                    "foo",
                                    ".bar()"
                                ]
                            },
                            "2": {
                                "level-3.js": {
                                    "classes": [],
                                    "functions": [],
                                    "text": [
                                        "foo",
                                        ".bar()"
                                    ]
                                }
                            }
                        }
                    }
                }
            },
            "shebang": {
                "env-node-shebang": {},
                "node-shebang": {},
                "nonsense-shebang": {}
            },
            "skip-folders": {
                "a": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "fooA(     )"
                        ]
                    }
                },
                "b": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "fooB(   )"
                        ]
                    }
                }
            },
            "stdin-ignore": {
                ".prettierignore": {}
            },
            "with-node-modules": {
                "regular-module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "'use strict';"
                    ]
                },
                "nested": {},
                "not_node_modules": {
                    "file.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "'use strict';"
                        ]
                    }
                }
            },
            "with-parser-inference": {
                "javascript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/* JavaScript */",
                        "\"use strict\";"
                    ]
                },
                "stylesheet.css": {}
            },
            "with-resolve-config": {
                ".prettierrc": {},
                "file.bar": {},
                "file.foo": {}
            },
            "with-resolve-config-no-config": {
                "file.bar": {},
                "file.foo": {}
            },
            "with-shebang": {
                "issue1890.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "#!/usr/bin/env node",
                        "\"use strict\";"
                    ]
                }
            },
            "write": {
                "formatted.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "var x = 1;"
                    ]
                },
                "invalid.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "this is invalid!"
                    ]
                },
                "unformatted.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "var x      =      1;"
                    ]
                }
            }
        },
        "custom-parsers": {
            "custom-rename-input.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* eslint-disable */",
                    "foo ( )"
                ]
            },
            "custom-rename-parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = function (text, parsers) {",
                    "  const ast = parsers.babel(text);",
                    "  ast.program.body[0].expression.callee.name = \"bar\";",
                    "  return ast;",
                    "};"
                ]
            }
        },
        "plugins": {
            "automatic": {
                "file.txt": {},
                "package.json": {},
                "prettier-plugin-bar.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const prettier = require(\"prettier/local\");",
                        "const { concat } = prettier.doc.builders;",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"bar\",",
                        "      parsers: [\"bar\"]",
                        "    }",
                        "  ],",
                        "  parsers: {",
                        "    bar: {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"bar\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    bar: {",
                        "      print: path =>",
                        "        concat([",
                        "          \"content from `prettier-plugin-bar.js` file + \",",
                        "          path.getValue().text",
                        "        ])",
                        "    }",
                        "  },",
                        "  defaultOptions: {",
                        "    tabWidth: 4",
                        "  }",
                        "};"
                    ]
                }
            },
            "bespoke": {},
            "defaultOptions": {
                "config.json": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"]",
                        "    }",
                        "  ],",
                        "  defaultOptions: {",
                        "    tabWidth: 8,",
                        "    bracketSpacing: false",
                        "  },",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: (path, options) =>",
                        "        JSON.stringify({",
                        "          tabWidth: options.tabWidth,",
                        "          bracketSpacing: options.bracketSpacing",
                        "        })",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "extensions": {
                "file.foo": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const prettier = require(\"prettier/local\");",
                        "const { concat } = prettier.doc.builders;",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"]",
                        "    }",
                        "  ],",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: path => concat([\"!\", path.getValue().text])",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "options": {
                "config.json": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"],",
                        "      since: \"1.0.0\"",
                        "    }",
                        "  ],",
                        "  options: {",
                        "    fooOption: {",
                        "      type: \"choice\",",
                        "      default: \"bar\",",
                        "      description: \"foo description\",",
                        "      choices: [",
                        "        {",
                        "          value: \"bar\",",
                        "          description: \"bar description\"",
                        "        },",
                        "        {",
                        "          value: \"baz\",",
                        "          description: \"baz description\"",
                        "        }",
                        "      ]",
                        "    }",
                        "  },",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: (path, options) =>",
                        "        options.fooOption ? `foo:${options.fooOption}` : path.getValue().text",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "options-string": {
                "config.json": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"],",
                        "      since: \"1.0.0\"",
                        "    }",
                        "  ],",
                        "  options: {",
                        "    fooString: {",
                        "      type: \"string\",",
                        "      default: \"bar\",",
                        "      description: \"foo description\"",
                        "    }",
                        "  },",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: (path, options) =>",
                        "        options.fooString ? `foo:${options.fooString}` : path.getValue().text",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "preprocess": {
                "file.foo": {},
                "plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  languages: [",
                        "    {",
                        "      name: \"foo\",",
                        "      parsers: [\"foo-parser\"],",
                        "      extensions: [\".foo\"],",
                        "      since: \"1.0.0\"",
                        "    }",
                        "  ],",
                        "  parsers: {",
                        "    \"foo-parser\": {",
                        "      preprocess: text => `preprocessed:${text}`,",
                        "      parse: text => ({ text }),",
                        "      astFormat: \"foo-ast\"",
                        "    }",
                        "  },",
                        "  printers: {",
                        "    \"foo-ast\": {",
                        "      print: path => path.getValue().text",
                        "    }",
                        "  }",
                        "};"
                    ]
                }
            },
            "virtualDirectory": {}
        }
    },
    "website": {
        ".eslintrc.yml": {},
        "README.md": {},
        "package.json": {},
        "sidebars.json": {},
        "siteConfig.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "// Docs: https://docusaurus.io/docs/en/site-config.html",
                "",
                "const parseYaml = require(\"js-yaml\").safeLoad;",
                "const path = require(\"path\");",
                "const fs = require(\"fs\");",
                "",
                "const PACKAGE = require(\"../package\");",
                "const GITHUB_URL = `https://github.com/${PACKAGE.repository}`;",
                "",
                "function loadYaml(fsPath) {",
                "  return parseYaml(fs.readFileSync(path.join(__dirname, fsPath), \"utf8\"));",
                "}",
                "",
                "const users = loadYaml(\"./data/users.yml\");",
                "const editors = loadYaml(\"./data/editors.yml\");",
                "const supportedLanguages = loadYaml(\"./data/languages.yml\");",
                "",
                "const siteConfig = {",
                "  title: \"Prettier\",",
                "  tagline: \"Opinionated Code Formatter\",",
                "  githubUrl: GITHUB_URL,",
                "  url: PACKAGE.homepage,",
                "  baseUrl: \"/\",",
                "  projectName: PACKAGE.name,",
                "  repo: PACKAGE.repository,",
                "  cname: \"prettier.io\",",
                "  users,",
                "  editors,",
                "  supportedLanguages,",
                "  tideliftUrl:",
                "    \"https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=website\",",
                "  /* base url for editing docs, usage example: editUrl + 'en/doc1.md' */",
                "  editUrl: `${GITHUB_URL}/edit/master/docs/`,",
                "  headerLinks: [",
                "    { href: \"/playground/\", label: \"Playground\" },",
                "    { doc: \"index\", label: \"About\" },",
                "    { doc: \"install\", label: \"Usage\" },",
                "    { blog: true, label: \"Blog\" },",
                "    { search: true },",
                "    { href: \"https://opencollective.com/prettier\", label: \"Donate\" },",
                "    { href: GITHUB_URL, label: \"GitHub\" },",
                "  ],",
                "  /* path to images for header/footer */",
                "  headerIcon: \"icon.png\",",
                "  footerIcon: \"icon.png\",",
                "  favicon: \"icon.png\",",
                "  /* colors for website */",
                "  colors: {",
                "    primaryColor: \"#1A2B34\",",
                "    secondaryColor: \"#808080\",",
                "  },",
                "  highlight: {",
                "    theme: \"default\",",
                "    version: require(\"highlight.js/package.json\").version,",
                "  },",
                "  usePrism: [\"javascript\", \"jsx\", \"typescript\", \"ts\", \"js\", \"html\"],",
                "  useEnglishUrl: true,",
                "  scripts: [\"https://buttons.github.io/buttons.js\"],",
                "  stylesheets: [",
                "    \"//unpkg.com/@sandhose/prettier-animated-logo@1.0.3/dist/wide.css\",",
                "  ],",
                "  algolia: {",
                "    apiKey: process.env.ALGOLIA_PRETTIER_API_KEY,",
                "    indexName: \"prettier\",",
                "  },",
                "  markdownPlugins: [",
                "    // ignore `<!-- prettier-ignore -->` before passing into Docusaurus to avoid mis-parsing (#3322)",
                "    (md) => {",
                "      md.block.ruler.before(",
                "        \"htmlblock\",",
                "        \"prettierignore\",",
                "        (state, startLine) => {",
                "          const pos = state.bMarks[startLine];",
                "          const max = state.eMarks[startLine];",
                "          if (/<!-- prettier-ignore -->/.test(state.src.slice(pos, max))) {",
                "            state.line += 1;",
                "            return true;",
                "          }",
                "          return false;",
                "        }",
                "      );",
                "    },",
                "  ],",
                "  separateCss: [\"static/separate-css\"],",
                "  gaTrackingId: \"UA-111350464-1\",",
                "  twitter: true,",
                "  twitterUsername: \"PrettierCode\",",
                "  twitterImage: \"icon.png\",",
                "  ogImage: \"icon.png\",",
                "  onPageNav: \"separate\",",
                "};",
                "",
                "module.exports = siteConfig;"
            ]
        },
        "svgo.yml": {},
        "versions.json": {},
        "webpack.config.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "module.exports = {",
                "  entry: {",
                "    playground: \"./playground/index.js\",",
                "  },",
                "  output: {",
                "    filename: \"[name].js\",",
                "    path: __dirname + \"/static/\",",
                "  },",
                "  module: {",
                "    rules: [",
                "      {",
                "        test: /\\.js$/,",
                "        exclude: /node_modules/,",
                "        loader: \"babel-loader\",",
                "        options: {",
                "          presets: [\"@babel/env\", \"@babel/react\"],",
                "        },",
                "      },",
                "    ],",
                "  },",
                "  externals: {",
                "    clipboard: \"ClipboardJS\",",
                "    codemirror: \"CodeMirror\",",
                "    react: \"React\",",
                "    \"react-dom\": \"ReactDOM\",",
                "  },",
                "};"
            ]
        },
        "yarn.lock": {},
        "blog": {
            "2017-04-13-1.0.0.md": {},
            "2017-04-20-1.2.0.md": {},
            "2017-05-03-1.3.0.md": {},
            "2017-06-03-1.4.0.md": {},
            "2017-06-28-1.5.0.md": {},
            "2017-08-29-1.6.0.md": {},
            "2017-09-15-1.7.0.md": {},
            "2017-11-07-1.8.0.md": {},
            "2017-12-05-1.9.0.md": {},
            "2018-01-10-1.10.0.md": {},
            "2018-02-26-1.11.0.md": {},
            "2018-04-09-plugin-php-0.1.md": {},
            "2018-04-11-1.12.0.md": {},
            "2018-05-27-1.13.0.md": {},
            "2018-07-29-1.14.0.md": {},
            "2018-11-07-1.15.0.md": {},
            "2019-01-20-1.16.0.md": {},
            "2019-04-12-1.17.0.md": {},
            "2019-06-06-1.18.0.md": {},
            "2019-11-09-1.19.0.md": {},
            "2020-03-21-2.0.0.md": {}
        },
        "core": {
            "Footer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const React = require(\"react\");",
                    "const PropTypes = require(\"prop-types\");",
                    "",
                    "const GithubButton = (props) => (",
                    "  <a",
                    "    className=\"github-button\"",
                    "    href={props.config.githubUrl}",
                    "    data-icon=\"octicon-star\"",
                    "    data-show-count=\"true\"",
                    "    aria-label=\"Star this project on GitHub\"",
                    "  >",
                    "    Star",
                    "  </a>",
                    ");",
                    "",
                    "GithubButton.propTypes = {",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "class Footer extends React.Component {",
                    "  url(path) {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}docs/${language}${path}`;",
                    "  }",
                    "",
                    "  usersUrl() {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}${language}/users`;",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <footer className=\"footerSection nav-footer\" id=\"footer\">",
                    "        <section className=\"sitemap\">",
                    "          <a href={this.props.config.baseUrl} className=\"nav-home\">",
                    "            <img",
                    "              src={this.props.config.baseUrl + this.props.config.footerIcon}",
                    "              alt={this.props.config.title}",
                    "            />",
                    "          </a>",
                    "          <div>",
                    "            <h5>Docs</h5>",
                    "            <a href={this.url(\"/index.html\")}>About</a>",
                    "            <a href={this.url(\"/install.html\")}>Usage</a>",
                    "            <br />",
                    "            <a href=\"https://www.netlify.com\">",
                    "              <img src=\"https://www.netlify.com/img/global/badges/netlify-color-accent.svg\" />",
                    "            </a>",
                    "          </div>",
                    "          <div>",
                    "            <h5>Community</h5>",
                    "            <a href={this.usersUrl()}>User Showcase</a>",
                    "            <a",
                    "              href=\"http://stackoverflow.com/questions/tagged/prettier\"",
                    "              target=\"_blank\"",
                    "              rel=\"noopener noreferrer\"",
                    "            >",
                    "              Stack Overflow",
                    "            </a>",
                    "            <a href=\"https://gitter.im/jlongster/prettier\">Chat on Gitter</a>",
                    "            <a href=\"https://twitter.com/PrettierCode\">",
                    "              @PrettierCode on Twitter",
                    "            </a>",
                    "            <object",
                    "              type=\"image/svg+xml\"",
                    "              data=\"https://img.shields.io/twitter/follow/prettiercode.svg?label=Follow+Prettier&style=social\"",
                    "            >",
                    "              <a href=\"https://twitter.com/intent/follow?screen_name=prettiercode\">",
                    "                <img",
                    "                  alt=\"Follow Prettier on Twitter\"",
                    "                  src=\"https://img.shields.io/twitter/follow/prettiercode.png?label=Follow+Prettier&style=social\"",
                    "                />",
                    "              </a>",
                    "            </object>",
                    "          </div>",
                    "          <div>",
                    "            <h5>More</h5>",
                    "            <a href={this.props.config.baseUrl + \"blog\"}>Blog</a>",
                    "            <a href={this.props.config.githubUrl}>GitHub</a>",
                    "            <a href={this.props.config.githubUrl + \"/issues\"}>Issues</a>",
                    "            <GithubButton config={this.props.config} />",
                    "          </div>",
                    "        </section>",
                    "      </footer>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "Footer.propTypes = {",
                    "  language: PropTypes.string,",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "module.exports = Footer;"
                ]
            }
        },
        "data": {
            "editors.yml": {},
            "languages.yml": {},
            "users.yml": {}
        },
        "pages": {
            "googlefe164a33bda4034b.html": {},
            "playground-redirect.html": {},
            "en": {
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const React = require(\"react\");",
                        "const PropTypes = require(\"prop-types\");",
                        "const { MarkdownBlock, Container } = require(\"../../core/CompLibrary.js\");",
                        "const AnimatedLogo = require(\"@sandhose/prettier-animated-logo\");",
                        "",
                        "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                        "",
                        "const ButtonGroup = (props) => (",
                        "  <div className=\"buttonGroup buttonWrapper\">{props.children}</div>",
                        ");",
                        "",
                        "ButtonGroup.propTypes = {",
                        "  children: PropTypes.node,",
                        "};",
                        "",
                        "class Button extends React.Component {",
                        "  render() {",
                        "    return (",
                        "      <div className=\"pluginWrapper buttonWrapper\">",
                        "        <a className=\"button\" href={this.props.href} target={this.props.target}>",
                        "          {this.props.children}",
                        "        </a>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Button.defaultProps = {",
                        "  target: \"_self\",",
                        "};",
                        "",
                        "Button.propTypes = {",
                        "  href: PropTypes.string,",
                        "  target: PropTypes.string,",
                        "  children: PropTypes.any,",
                        "};",
                        "",
                        "function Tidelift() {",
                        "  return (",
                        "    <a className=\"tidelift\" href={siteConfig.tideliftUrl}>",
                        "      PRETTIER FOR ENTERPRISE",
                        "    </a>",
                        "  );",
                        "}",
                        "",
                        "const HomeSplash = (props) => {",
                        "  return (",
                        "    <div className=\"homeContainer\">",
                        "      <Tidelift />",
                        "      <div className=\"homeSplashFade\">",
                        "        <div className=\"wrapper homeWrapper\">",
                        "          <div className=\"animatedLogoWrapper\">",
                        "            <AnimatedLogo version=\"wide\" />",
                        "          </div>",
                        "          <div className=\"inner\">",
                        "            <div className=\"section promoSection\">",
                        "              <div className=\"promoRow\">",
                        "                <div className=\"pluginRowBlock\">",
                        "                  <Button href=\"/playground/\">Try It Out</Button>",
                        "                  <Button href={\"/docs/\" + props.language + \"/install.html\"}>",
                        "                    Get Started",
                        "                  </Button>",
                        "                  <Button href={\"/docs/\" + props.language + \"/options.html\"}>",
                        "                    Options",
                        "                  </Button>",
                        "                </div>",
                        "              </div>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </div>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "HomeSplash.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const TldrSection = ({ language }) => (",
                        "  <div className=\"tldrSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-evenly\",",
                        "        }}",
                        "      >",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>What is Prettier?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>An opinionated code formatter</li>",
                        "            <li>Supports many languages</li>",
                        "            <li>Integrates with most editors</li>",
                        "            <li>Has few options</li>",
                        "          </ul>",
                        "        </div>",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>Why?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>You press save and code is formatted</li>",
                        "            <li>No need to discuss style in code review</li>",
                        "            <li>Saves you time and energy</li>",
                        "            <li>",
                        "              <a href={\"/docs/\" + language + \"/why-prettier.html\"}>And more</a>",
                        "            </li>",
                        "          </ul>",
                        "        </div>",
                        "      </div>",
                        "    </Container>",
                        "  </div>",
                        ");",
                        "",
                        "TldrSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const Language = ({ name, nameLink, showName, image, variants }) => (",
                        "  <div",
                        "    className=\"languageCategory\"",
                        "    style={{",
                        "      display: \"flex\",",
                        "      alignItems: \"flex-start\",",
                        "      paddingBottom: \"1em\",",
                        "    }}",
                        "  >",
                        "    <img src={image} style={{ width: \"50px\", padding: \"0 20px\" }} />",
                        "    <ul>",
                        "      {showName && (",
                        "        <li className=\"accented\">",
                        "          {nameLink ? <a href={nameLink}>{name}</a> : name}",
                        "        </li>",
                        "      )}",
                        "      {variants.map((variant) => (",
                        "        <li key={variant}>",
                        "          <MarkdownBlock>{variant}</MarkdownBlock>",
                        "        </li>",
                        "      ))}",
                        "    </ul>",
                        "  </div>",
                        ");",
                        "",
                        "Language.propTypes = {",
                        "  name: PropTypes.string,",
                        "  nameLink: PropTypes.string,",
                        "  showName: PropTypes.bool,",
                        "  image: PropTypes.string,",
                        "  variants: PropTypes.array,",
                        "};",
                        "",
                        "const LanguagesSection = () => {",
                        "  const languageChunks = siteConfig.supportedLanguages.reduce(",
                        "    (acc, language) => {",
                        "      const last = acc[acc.length - 1];",
                        "      if (",
                        "        last &&",
                        "        last.length < 2 &&",
                        "        last.reduce((sum, lang) => sum + lang.variants.length, 0) +",
                        "          language.variants.length <",
                        "          9",
                        "      ) {",
                        "        last.push(language);",
                        "      } else {",
                        "        acc.push([language]);",
                        "      }",
                        "      return acc;",
                        "    },",
                        "    []",
                        "  );",
                        "",
                        "  return (",
                        "    <div",
                        "      className=\"languagesSection productShowcaseSection\"",
                        "      style={{ textAlign: \"center\" }}",
                        "    >",
                        "      <Container>",
                        "        <h2>Works with the Tools You Use</h2>",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {languageChunks.map((languageChunk, index) => (",
                        "            <div key={index} style={{ flex: \"1 1 auto\" }}>",
                        "              {languageChunk.map((language) => (",
                        "                <Language key={language.name} {...language} />",
                        "              ))}",
                        "            </div>",
                        "          ))}",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "const Editor = ({ content = \"\", image, name }) => (",
                        "  <div className=\"editor\">",
                        "    <img className=\"editorImage\" src={image} />",
                        "    <div className=\"editorInfo\">",
                        "      <h3 className=\"editorName\">{name}</h3>",
                        "      <MarkdownBlock>{content.replace(/\\n/g, \"  \\n\")}</MarkdownBlock>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "Editor.propTypes = {",
                        "  content: PropTypes.string,",
                        "  image: PropTypes.string.isRequired,",
                        "  name: PropTypes.string.isRequired,",
                        "};",
                        "",
                        "const EditorSupportSection = () => (",
                        "  <div className=\"editorSupportSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <h2>Editor Support</h2>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-around\",",
                        "        }}",
                        "      >",
                        "        {siteConfig.editors.map((editor) => (",
                        "          <Editor key={editor.name} {...editor} />",
                        "        ))}",
                        "      </div>",
                        "    </Container>",
                        "",
                        "    <div style={{ float: \"right\" }}>",
                        "      <span>Got more? </span>",
                        "      <a",
                        "        href={`${siteConfig.githubUrl}/edit/master/website/data/editors.yml`}",
                        "        className=\"button\"",
                        "      >",
                        "        Send a PR",
                        "      </a>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "const bash = (...args) => `~~~bash\\n${String.raw(...args)}\\n~~~`;",
                        "",
                        "const json = (object) => `~~~json\\n${JSON.stringify(object, null, 2)}\\n~~~`;",
                        "",
                        "class GetStartedSection extends React.Component {",
                        "  constructor(props) {",
                        "    super(props);",
                        "    this.state = {",
                        "      npmClient: \"yarn\",",
                        "    };",
                        "  }",
                        "",
                        "  render() {",
                        "    return (",
                        "      <div className=\"getStartedSection productShowcaseSection\">",
                        "        <Container>",
                        "          <div",
                        "            className=\"getStartedFlexContainer\"",
                        "            style={{",
                        "              display: \"flex\",",
                        "              flexFlow: \"row\",",
                        "              alignItems: \"baseline\",",
                        "              justifyContent: \"space-between\",",
                        "            }}",
                        "          >",
                        "            <div className=\"getStartedSteps\">",
                        "              <h2>Get Started</h2>",
                        "              <ol>",
                        "                <li>",
                        "                  Add prettier to your project:",
                        "                  <div className=\"yarnOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`yarn add prettier --dev --exact`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                  <div className=\"npmOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`npm install prettier --save-dev --save-exact`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                </li>",
                        "                <li>",
                        "                  Verify by running against a file:",
                        "                  <div className=\"yarnOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`yarn prettier --write src/index.js`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                  <div className=\"npmOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`npx prettier --write src/index.js`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                </li>",
                        "                <li>",
                        "                  Run prettier when committing files:",
                        "                  <div className=\"yarnOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`yarn add pretty-quick husky --dev`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                  <div className=\"npmOnly\">",
                        "                    <MarkdownBlock>",
                        "                      {bash`npm install pretty-quick husky --save-dev`}",
                        "                    </MarkdownBlock>",
                        "                  </div>",
                        "                  Then add this config to <code>package.json</code>:",
                        "                  <MarkdownBlock>",
                        "                    {json({",
                        "                      husky: {",
                        "                        hooks: {",
                        "                          \"pre-commit\": \"pretty-quick --staged\",",
                        "                        },",
                        "                      },",
                        "                    })}",
                        "                  </MarkdownBlock>",
                        "                </li>",
                        "              </ol>",
                        "            </div>",
                        "            <div",
                        "              style={{",
                        "                display: \"flex\",",
                        "                flexDirection: \"column\",",
                        "                alignItems: \"flex-end\",",
                        "                flexGrow: 1,",
                        "                marginLeft: \"-75px\",",
                        "              }}",
                        "            >",
                        "              <ButtonGroup>",
                        "                <a className=\"button active showYarnButton\" href=\"#\">",
                        "                  yarn",
                        "                </a>",
                        "                <a className=\"button showNpmButton\" href=\"#\">",
                        "                  npm",
                        "                </a>",
                        "              </ButtonGroup>",
                        "              <img",
                        "                className=\"decorativeRects\"",
                        "                style={{",
                        "                  marginTop: \"32px\",",
                        "                }}",
                        "                src=\"/images/get_started_rects.svg\"",
                        "              />",
                        "            </div>",
                        "          </div>",
                        "        </Container>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "const UsersSection = ({ language }) => {",
                        "  const showcase = siteConfig.users",
                        "    .filter((user) => {",
                        "      return user.pinned;",
                        "    })",
                        "    .map((user, i) => {",
                        "      return (",
                        "        <a key={i} className=\"growOnHover alignCenter\" href={user.infoLink}>",
                        "          <img className=\"user\" src={user.greyImage} title={user.caption} />",
                        "        </a>",
                        "      );",
                        "    });",
                        "",
                        "  return (",
                        "    <div className=\"usersSection productShowcaseSection lightBackground\">",
                        "      <Container>",
                        "        <h2>Used By People You Rely On</h2>",
                        "        <div style={{ textAlign: \"right\" }} />",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {showcase}",
                        "        </div>",
                        "        <div className=\"more-users\">",
                        "          <a",
                        "            className=\"button\"",
                        "            href={siteConfig.baseUrl + language + \"/users/\"}",
                        "            target=\"_self\"",
                        "          >",
                        "            See All Others",
                        "          </a>",
                        "          <a",
                        "            className=\"button\"",
                        "            href={`${siteConfig.githubUrl}/edit/master/website/data/users.yml`}",
                        "          >",
                        "            Add Your Project",
                        "          </a>",
                        "        </div>",
                        "",
                        "        <h2 className=\"ecosystemSubHeader\">Established in the Ecosystem</h2>",
                        "        <div",
                        "          className=\"ecosystemSubSection\"",
                        "          style={{",
                        "            display: \"flex\",",
                        "            justifyContent: \"space-around\",",
                        "            flexFlow: \"row wrap\",",
                        "          }}",
                        "        >",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://npmjs.com/package/prettier\"",
                        "              className=\"growOnHover\"",
                        "            >",
                        "              <img src=\"/images/npm_grey.svg\" style={{ height: \"100px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than <strong data-placeholder=\"dependent-npm\">5000</strong>{\" \"}",
                        "                tools and integrations on npm",
                        "              </p>",
                        "              <Button href=\"https://www.npmjs.com/browse/depended/prettier\">",
                        "                Install Them",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://github.com/prettier/prettier\"",
                        "              className=\"growOnHover\"",
                        "            >",
                        "              <img src=\"/images/github_grey.svg\" style={{ height: \"100px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than{\" \"}",
                        "                <strong data-placeholder=\"dependent-github\">1.6M</strong>{\" \"}",
                        "                dependent repositories on GitHub",
                        "              </p>",
                        "              <Button href=\"https://github.com/prettier/prettier/network/dependents\">",
                        "                Check Them Out",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "UsersSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "class Index extends React.Component {",
                        "  render() {",
                        "    const language = this.props.language || \"en\";",
                        "",
                        "    return (",
                        "      <div>",
                        "        <script src=\"landing.js\" />",
                        "        <HomeSplash language={language} />",
                        "        <div className=\"mainContainer landingContainer\">",
                        "          <TldrSection language={language} />",
                        "          <LanguagesSection />",
                        "          <EditorSupportSection />",
                        "          <GetStartedSection />",
                        "          <UsersSection language={language} />",
                        "        </div>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Index.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "module.exports = Index;"
                    ]
                },
                "versions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * Copyright (c) 2017-present, Facebook, Inc.",
                        " *",
                        " * This source code is licensed under the MIT license found in the",
                        " * LICENSE file in the root directory of this source tree.",
                        " */",
                        "",
                        "const React = require(\"react\");",
                        "const { Container } = require(\"../../core/CompLibrary\");",
                        "",
                        "const CWD = process.cwd();",
                        "",
                        "const versions = require(`${CWD}/versions.json`);",
                        "",
                        "const rootPackageJson = require(`${CWD}/../package.json`);",
                        "const masterVersion = rootPackageJson.version;",
                        "const isMasterDevVersion = masterVersion.endsWith(\"-dev\");",
                        "const devVersion = isMasterDevVersion ? masterVersion : null;",
                        "const latestVersion = isMasterDevVersion",
                        "  ? rootPackageJson.devDependencies.prettier",
                        "  : masterVersion;",
                        "const [latestDocsVersion, ...pastDocsVersions] = versions;",
                        "",
                        "function Versions(props) {",
                        "  const { config: siteConfig } = props;",
                        "  return (",
                        "    <div className=\"docMainWrapper wrapper\">",
                        "      <Container className=\"mainContainer versionsContainer\">",
                        "        <div className=\"post\">",
                        "          <header className=\"postHeader\">",
                        "            <h1>{siteConfig.title} Versions</h1>",
                        "          </header>",
                        "          <table className=\"versions\">",
                        "            <tbody>",
                        "              <tr>",
                        "                <th>Version</th>",
                        "                <th>Install with</th>",
                        "                <th>Documentation</th>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{latestVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/index.html`}>",
                        "                    {latestDocsVersion}",
                        "                  </a>{\" \"}",
                        "                  (latest)",
                        "                </td>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{devVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier/prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/next/index.html`}>",
                        "                    next",
                        "                  </a>{\" \"}",
                        "                  (master)",
                        "                </td>",
                        "              </tr>",
                        "              {pastDocsVersions.length !== 0 &&",
                        "                pastDocsVersions.map((pastDocsVersion, index) => {",
                        "                  const pastMajorVersion = pastDocsVersion.replace(/^v/, \"\");",
                        "                  return (",
                        "                    <tr key={index}>",
                        "                      <td>{pastMajorVersion}.x</td>",
                        "                      <td>",
                        "                        <code>",
                        "                          npm install prettier@",
                        "                          {pastMajorVersion}",
                        "                        </code>",
                        "                      </td>",
                        "                      <td>",
                        "                        <a",
                        "                          href={`${siteConfig.baseUrl}docs/en/${pastDocsVersion}/index.html`}",
                        "                        >",
                        "                          {pastDocsVersion}",
                        "                        </a>",
                        "                      </td>",
                        "                    </tr>",
                        "                  );",
                        "                })}",
                        "            </tbody>",
                        "          </table>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "module.exports = Versions;"
                    ]
                },
                "help": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container, GridBlock } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "class Help extends React.Component {",
                            "  render() {",
                            "    const supportLinks = [",
                            "      {",
                            "        content:",
                            "          \"Learn more using the [documentation on this site.](/docs/en/why-prettier.html)\\n\",",
                            "        title: \"Browse Docs\",",
                            "      },",
                            "      {",
                            "        content: \"Ask questions about the documentation and project\\n\",",
                            "        title: \"Join the community\",",
                            "      },",
                            "      {",
                            "        content: \"Find out what's new with this project\\n\",",
                            "        title: \"Stay up to date\",",
                            "      },",
                            "    ];",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"docMainWrapper wrapper\">",
                            "          <Container className=\"mainContainer documentContainer postContainer\">",
                            "            <div className=\"post\">",
                            "              <header className=\"postHeader\">",
                            "                <h2>Need help?</h2>",
                            "              </header>",
                            "              <p>This project is maintained by a dedicated group of people;</p>",
                            "              <GridBlock contents={supportLinks} layout=\"threeColumn\" />",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Help.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "module.exports = Help;"
                        ]
                    }
                },
                "users": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                            "",
                            "class Users extends React.Component {",
                            "  render() {",
                            "    const showcase = siteConfig.users.map((user, i) => {",
                            "      return (",
                            "        <a key={i} href={user.infoLink}>",
                            "          <img src={user.image} title={user.caption} />",
                            "        </a>",
                            "      );",
                            "    });",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"mainContainer\">",
                            "          <Container padding={[\"bottom\", \"top\"]}>",
                            "            <div className=\"showcaseSection\">",
                            "              <div className=\"prose\">",
                            "                <h1>",
                            "                  Who",
                            "                  {\"'\"}s Using This?",
                            "                </h1>",
                            "                <p>",
                            "                  A few of the{\" \"}",
                            "                  <a href=\"https://www.npmjs.com/browse/depended/prettier\">",
                            "                    many projects",
                            "                  </a>{\" \"}",
                            "                  using Prettier",
                            "                </p>",
                            "              </div>",
                            "              <div className=\"logos\">{showcase}</div>",
                            "              <div className=\"prose\">",
                            "                <p>Are you using this project?</p>",
                            "              </div>",
                            "              <a",
                            "                href={`${siteConfig.githubUrl}/edit/master/website/data/users.yml`}",
                            "                className=\"button\"",
                            "              >",
                            "                Add your company",
                            "              </a>",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Users.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "Users.title = \"Who's using Prettier?\";",
                            "",
                            "module.exports = Users;"
                        ]
                    }
                }
            },
            "playground": {
                "index.html": {}
            }
        },
        "playground": {
            ".eslintrc.yml": {},
            "BottomBar.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"bottom-bar\");",
                    "",
                    "export default function ({ left, right }) {",
                    "  return ReactDOM.createPortal(",
                    "    <React.Fragment>",
                    "      <div className=\"bottom-bar-buttons\">{left}</div>",
                    "      <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">{right}</div>",
                    "    </React.Fragment>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "EditorState.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { stateToggler, shallowEqual } from \"./helpers\";",
                    "import * as storage from \"./storage\";",
                    "",
                    "export default class extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = {",
                    "      showSidebar: false,",
                    "      showAst: false,",
                    "      showDoc: false,",
                    "      showSecondFormat: false,",
                    "      toggleSidebar: () => this.setState(stateToggler(\"showSidebar\")),",
                    "      toggleAst: () => this.setState(stateToggler(\"showAst\")),",
                    "      toggleDoc: () => this.setState(stateToggler(\"showDoc\")),",
                    "      toggleSecondFormat: () => this.setState(stateToggler(\"showSecondFormat\")),",
                    "      ...storage.get(\"editor_state\"),",
                    "    };",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    if (!shallowEqual(this.state, prevState)) {",
                    "      storage.set(\"editor_state\", this.state);",
                    "    }",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "Playground.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { Button, ClipboardButton } from \"./buttons\";",
                    "import EditorState from \"./EditorState\";",
                    "import { DebugPanel, InputPanel, OutputPanel } from \"./panels\";",
                    "import PrettierFormat from \"./PrettierFormat\";",
                    "import { shallowEqual } from \"./helpers\";",
                    "import * as urlHash from \"./urlHash\";",
                    "import formatMarkdown from \"./markdown\";",
                    "import * as util from \"./util\";",
                    "import getCodeSample from \"./codeSamples\";",
                    "",
                    "import { Sidebar, SidebarCategory } from \"./sidebar/components\";",
                    "import SidebarOptions from \"./sidebar/SidebarOptions\";",
                    "import Option from \"./sidebar/options\";",
                    "import { Checkbox } from \"./sidebar/inputs\";",
                    "",
                    "const CATEGORIES_ORDER = [",
                    "  \"Global\",",
                    "  \"Common\",",
                    "  \"JavaScript\",",
                    "  \"Markdown\",",
                    "  \"HTML\",",
                    "  \"Special\",",
                    "];",
                    "const ENABLED_OPTIONS = [",
                    "  \"parser\",",
                    "  \"printWidth\",",
                    "  \"tabWidth\",",
                    "  \"useTabs\",",
                    "  \"semi\",",
                    "  \"singleQuote\",",
                    "  \"bracketSpacing\",",
                    "  \"jsxSingleQuote\",",
                    "  \"jsxBracketSameLine\",",
                    "  \"quoteProps\",",
                    "  \"arrowParens\",",
                    "  \"trailingComma\",",
                    "  \"proseWrap\",",
                    "  \"htmlWhitespaceSensitivity\",",
                    "  \"insertPragma\",",
                    "  \"requirePragma\",",
                    "  \"vueIndentScriptAndStyle\",",
                    "  \"embeddedLanguageFormatting\",",
                    "];",
                    "const ISSUES_URL = \"https://github.com/prettier/prettier/issues/new?body=\";",
                    "const MAX_LENGTH = 8000 - ISSUES_URL.length; // it seems that GitHub limit is 8195",
                    "const COPY_MESSAGE =",
                    "  \"<!-- The issue body has been saved to the clipboard. Please paste it after this line!  -->\\n\";",
                    "",
                    "class Playground extends React.Component {",
                    "  constructor(props) {",
                    "    super();",
                    "",
                    "    const original = urlHash.read();",
                    "",
                    "    const defaultOptions = util.getDefaults(",
                    "      props.availableOptions,",
                    "      ENABLED_OPTIONS",
                    "    );",
                    "",
                    "    const options = Object.assign(defaultOptions, original.options);",
                    "",
                    "    // backwards support for old parser `babylon`",
                    "    if (options.parser === \"babylon\") {",
                    "      options.parser = \"babel\";",
                    "    }",
                    "",
                    "    const content = original.content || getCodeSample(options.parser);",
                    "    const selection = {};",
                    "",
                    "    this.state = { content, options, selection };",
                    "",
                    "    this.handleOptionValueChange = this.handleOptionValueChange.bind(this);",
                    "",
                    "    this.setContent = (content) => this.setState({ content });",
                    "    this.clearContent = this.setContent.bind(this, \"\");",
                    "    this.resetOptions = () => this.setState({ options: defaultOptions });",
                    "    this.setSelection = (selection) => this.setState({ selection });",
                    "    this.setSelectionAsRange = () => {",
                    "      const { selection, content, options } = this.state;",
                    "      const { head, anchor } = selection;",
                    "      const range = [head, anchor].map(",
                    "        ({ ch, line }) =>",
                    "          content.split(\"\\n\").slice(0, line).join(\"\\n\").length +",
                    "          ch +",
                    "          (line ? 1 : 0)",
                    "      );",
                    "      const [rangeStart, rangeEnd] = range.sort((a, b) => a - b);",
                    "      const updatedOptions = { ...options, rangeStart, rangeEnd };",
                    "      if (rangeStart === rangeEnd) {",
                    "        delete updatedOptions.rangeStart;",
                    "        delete updatedOptions.rangeEnd;",
                    "      }",
                    "      this.setState({ options: updatedOptions });",
                    "    };",
                    "",
                    "    this.enabledOptions = orderOptions(props.availableOptions, ENABLED_OPTIONS);",
                    "    this.rangeStartOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeStart\"",
                    "    );",
                    "    this.rangeEndOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeEnd\"",
                    "    );",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    const { content, options } = this.state;",
                    "    if (",
                    "      !shallowEqual(prevState.options, this.state.options) ||",
                    "      prevState.content !== content",
                    "    ) {",
                    "      urlHash.replace({ content, options });",
                    "    }",
                    "  }",
                    "",
                    "  handleOptionValueChange(option, value) {",
                    "    this.setState((state) => {",
                    "      const options = { ...state.options };",
                    "",
                    "      if (option.type === \"int\" && isNaN(value)) {",
                    "        delete options[option.name];",
                    "      } else {",
                    "        options[option.name] = value;",
                    "      }",
                    "",
                    "      const content =",
                    "        state.content === \"\" ||",
                    "        state.content === getCodeSample(state.options.parser)",
                    "          ? getCodeSample(options.parser)",
                    "          : state.content;",
                    "",
                    "      return { options, content };",
                    "    });",
                    "  }",
                    "",
                    "  getMarkdown(formatted, reformatted, full) {",
                    "    const { content, options } = this.state;",
                    "    const { availableOptions, version } = this.props;",
                    "",
                    "    return formatMarkdown(",
                    "      content,",
                    "      formatted,",
                    "      reformatted || \"\",",
                    "      version,",
                    "      window.location.href,",
                    "      options,",
                    "      util.buildCliArgs(availableOptions, options),",
                    "      full",
                    "    );",
                    "  }",
                    "",
                    "  render() {",
                    "    const { worker } = this.props;",
                    "    const { content, options } = this.state;",
                    "",
                    "    return (",
                    "      <EditorState>",
                    "        {(editorState) => (",
                    "          <PrettierFormat",
                    "            worker={worker}",
                    "            code={content}",
                    "            options={options}",
                    "            debugAst={editorState.showAst}",
                    "            debugDoc={editorState.showDoc}",
                    "            reformat={editorState.showSecondFormat}",
                    "          >",
                    "            {({ formatted, debug }) => {",
                    "              const fullReport = this.getMarkdown(",
                    "                formatted,",
                    "                debug.reformatted,",
                    "                true",
                    "              );",
                    "              const showFullReport =",
                    "                encodeURIComponent(fullReport).length < MAX_LENGTH;",
                    "              return (",
                    "                <React.Fragment>",
                    "                  <div className=\"editors-container\">",
                    "                    <Sidebar visible={editorState.showSidebar}>",
                    "                      <SidebarOptions",
                    "                        categories={CATEGORIES_ORDER}",
                    "                        availableOptions={this.enabledOptions}",
                    "                        optionValues={options}",
                    "                        onOptionValueChange={this.handleOptionValueChange}",
                    "                      />",
                    "                      <SidebarCategory title=\"Range\">",
                    "                        <label>",
                    "                          The selected range will be highlighted in yellow in",
                    "                          the input editor",
                    "                        </label>",
                    "                        <Option",
                    "                          option={this.rangeStartOption}",
                    "                          value={",
                    "                            typeof options.rangeStart === \"number\"",
                    "                              ? options.rangeStart",
                    "                              : \"\"",
                    "                          }",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "                        <Option",
                    "                          option={this.rangeEndOption}",
                    "                          value={",
                    "                            typeof options.rangeEnd === \"number\"",
                    "                              ? options.rangeEnd",
                    "                              : \"\"",
                    "                          }",
                    "                          overrideMax={content.length}",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "",
                    "                        <Button onClick={this.setSelectionAsRange}>",
                    "                          Set selected text as range",
                    "                        </Button>",
                    "                      </SidebarCategory>",
                    "                      <SidebarCategory title=\"Debug\">",
                    "                        <Checkbox",
                    "                          label=\"show AST\"",
                    "                          checked={editorState.showAst}",
                    "                          onChange={editorState.toggleAst}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show doc\"",
                    "                          checked={editorState.showDoc}",
                    "                          onChange={editorState.toggleDoc}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show second format\"",
                    "                          checked={editorState.showSecondFormat}",
                    "                          onChange={editorState.toggleSecondFormat}",
                    "                        />",
                    "                      </SidebarCategory>",
                    "                      <div className=\"sub-options\">",
                    "                        <Button onClick={this.resetOptions}>",
                    "                          Reset to defaults",
                    "                        </Button>",
                    "                      </div>",
                    "                    </Sidebar>",
                    "                    <div className=\"editors\">",
                    "                      <InputPanel",
                    "                        mode={util.getCodemirrorMode(options.parser)}",
                    "                        ruler={options.printWidth}",
                    "                        value={content}",
                    "                        codeSample={getCodeSample(options.parser)}",
                    "                        overlayStart={options.rangeStart}",
                    "                        overlayEnd={options.rangeEnd}",
                    "                        onChange={this.setContent}",
                    "                        onSelectionChange={this.setSelection}",
                    "                      />",
                    "                      {editorState.showAst ? (",
                    "                        <DebugPanel",
                    "                          value={debug.ast || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showDoc ? (",
                    "                        <DebugPanel value={debug.doc || \"\"} />",
                    "                      ) : null}",
                    "                      <OutputPanel",
                    "                        mode={util.getCodemirrorMode(options.parser)}",
                    "                        value={formatted}",
                    "                        ruler={options.printWidth}",
                    "                      />",
                    "                      {editorState.showSecondFormat ? (",
                    "                        <OutputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          value={getSecondFormat(formatted, debug.reformatted)}",
                    "                          ruler={options.printWidth}",
                    "                        />",
                    "                      ) : null}",
                    "                    </div>",
                    "                  </div>",
                    "                  <div className=\"bottom-bar\">",
                    "                    <div className=\"bottom-bar-buttons\">",
                    "                      <Button onClick={editorState.toggleSidebar}>",
                    "                        {editorState.showSidebar ? \"Hide\" : \"Show\"} options",
                    "                      </Button>",
                    "                      <Button onClick={this.clearContent}>Clear</Button>",
                    "                      <ClipboardButton",
                    "                        copy={JSON.stringify(",
                    "                          // Remove `parser` since people usually paste this",
                    "                          // into their .prettierrc and specifying a top-level",
                    "                          // parser there is an anti-pattern. Note:",
                    "                          // `JSON.stringify` omits keys whose values are",
                    "                          // `undefined`.",
                    "                          { ...options, parser: undefined },",
                    "                          null,",
                    "                          2",
                    "                        )}",
                    "                      >",
                    "                        Copy config JSON",
                    "                      </ClipboardButton>",
                    "                    </div>",
                    "                    <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">",
                    "                      <ClipboardButton copy={window.location.href}>",
                    "                        Copy link",
                    "                      </ClipboardButton>",
                    "                      <ClipboardButton",
                    "                        copy={() =>",
                    "                          this.getMarkdown(formatted, debug.reformatted)",
                    "                        }",
                    "                      >",
                    "                        Copy markdown",
                    "                      </ClipboardButton>",
                    "                      <a",
                    "                        href={getReportLink(",
                    "                          showFullReport ? fullReport : COPY_MESSAGE",
                    "                        )}",
                    "                        target=\"_blank\"",
                    "                        rel=\"noopener noreferrer\"",
                    "                      >",
                    "                        <ClipboardButton",
                    "                          copy={() => (showFullReport ? \"\" : fullReport)}",
                    "                        >",
                    "                          Report issue",
                    "                        </ClipboardButton>",
                    "                      </a>",
                    "                    </div>",
                    "                  </div>",
                    "                </React.Fragment>",
                    "              );",
                    "            }}",
                    "          </PrettierFormat>",
                    "        )}",
                    "      </EditorState>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function orderOptions(availableOptions, order) {",
                    "  const optionsByName = {};",
                    "  for (const option of availableOptions) {",
                    "    optionsByName[option.name] = option;",
                    "  }",
                    "",
                    "  return order.map((name) => optionsByName[name]);",
                    "}",
                    "",
                    "function getReportLink(reportBody) {",
                    "  return `${ISSUES_URL}${encodeURIComponent(reportBody)}`;",
                    "}",
                    "",
                    "function getSecondFormat(formatted, reformatted) {",
                    "  return formatted === \"\"",
                    "    ? \"\"",
                    "    : formatted === reformatted",
                    "    ? \" Second format is unchanged.\"",
                    "    : reformatted;",
                    "}",
                    "",
                    "export default Playground;"
                ]
            },
            "PrettierFormat.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "export default class PrettierFormat extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { formatted: \"\", debug: {} };",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.format();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    for (const key of [\"code\", \"options\", \"debugAst\", \"debugDoc\", \"reformat\"]) {",
                    "      if (prevProps[key] !== this.props[key]) {",
                    "        this.format();",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  format() {",
                    "    const {",
                    "      worker,",
                    "      code,",
                    "      options,",
                    "      debugAst: ast,",
                    "      debugDoc: doc,",
                    "      reformat,",
                    "    } = this.props;",
                    "",
                    "    worker",
                    "      .format(code, options, { ast, doc, reformat })",
                    "      .then((result) => this.setState(result));",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "VersionLink.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"version\");",
                    "",
                    "export default function ({ version }) {",
                    "  const match = version.match(/^pr-(\\d+)$/);",
                    "  let href;",
                    "  if (match) {",
                    "    href = `pull/${match[1]}`;",
                    "  } else if (version.match(/\\.0$/)) {",
                    "    href = `releases/tag/${version}`;",
                    "  } else {",
                    "    href = `blob/master/CHANGELOG.md#${version.replace(/\\./g, \"\")}`;",
                    "  }",
                    "",
                    "  const formattedVersion = match ? `PR #${match[1]}` : `v${version}`;",
                    "",
                    "  React.useEffect(() => {",
                    "    document.title = `Prettier ${formattedVersion}`;",
                    "  }, [formattedVersion]);",
                    "",
                    "  return ReactDOM.createPortal(",
                    "    <a",
                    "      href={`https://github.com/prettier/prettier/${href}`}",
                    "      target=\"_blank\"",
                    "      rel=\"noreferrer noopener\"",
                    "    >",
                    "      {formattedVersion}",
                    "    </a>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "WorkerApi.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export default function (source) {",
                    "  const worker = new Worker(source);",
                    "  let counter = 0;",
                    "  const handlers = {};",
                    "",
                    "  worker.addEventListener(\"message\", (event) => {",
                    "    const { uid, message, error } = event.data;",
                    "",
                    "    if (!handlers[uid]) {",
                    "      return;",
                    "    }",
                    "",
                    "    const [resolve, reject] = handlers[uid];",
                    "    delete handlers[uid];",
                    "",
                    "    if (error) {",
                    "      reject(error);",
                    "    } else {",
                    "      resolve(message);",
                    "    }",
                    "  });",
                    "",
                    "  function postMessage(message) {",
                    "    const uid = ++counter;",
                    "    return new Promise((resolve, reject) => {",
                    "      handlers[uid] = [resolve, reject];",
                    "      worker.postMessage({ uid, message });",
                    "    });",
                    "  }",
                    "",
                    "  return {",
                    "    getMetadata() {",
                    "      return postMessage({ type: \"meta\" });",
                    "    },",
                    "    format(code, options, debug) {",
                    "      return postMessage({ type: \"format\", code, options, debug });",
                    "    },",
                    "    postMessage,",
                    "  };",
                    "}"
                ]
            },
            "buttons.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import ClipboardJS from \"clipboard\";",
                    "",
                    "export const Button = React.forwardRef((props, ref) => (",
                    "  <button type=\"button\" className=\"btn\" ref={ref} {...props} />",
                    "));",
                    "",
                    "export class ClipboardButton extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { showTooltip: false, tooltipText: \"\" };",
                    "    this.timer = null;",
                    "    this.ref = React.createRef();",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.clipboard = new ClipboardJS(this.ref.current, {",
                    "      text: () => {",
                    "        const { copy } = this.props;",
                    "        return typeof copy === \"function\" ? copy() : copy;",
                    "      },",
                    "    });",
                    "    this.clipboard.on(\"success\", () => this.showTooltip(\"Copied!\"));",
                    "    this.clipboard.on(\"error\", () => this.showTooltip(\"Press ctrl+c to copy\"));",
                    "  }",
                    "",
                    "  showTooltip(text) {",
                    "    this.setState({ showTooltip: true, tooltipText: text }, () => {",
                    "      if (this.timer) {",
                    "        clearTimeout(this.timer);",
                    "      }",
                    "      this.timer = setTimeout(() => {",
                    "        this.timer = null;",
                    "        this.setState({ showTooltip: false });",
                    "      }, 2000);",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { children, copy, ...rest } = this.props;",
                    "    const { showTooltip, tooltipText } = this.state;",
                    "",
                    "    return (",
                    "      <Button ref={this.ref} {...rest}>",
                    "        {showTooltip ? <span className=\"tooltip\">{tooltipText}</span> : null}",
                    "        {children}",
                    "      </Button>",
                    "    );",
                    "  }",
                    "}"
                ]
            },
            "codeSamples.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export default function (parser) {",
                    "  switch (parser) {",
                    "    case \"babel\":",
                    "      return [",
                    "        'function HelloWorld({greeting = \"hello\", greeted = \\'\"World\"\\', silent = false, onMouseOver,}) {',",
                    "        \"\",",
                    "        \"  if(!greeting){return null};\",",
                    "        \"\",",
                    "        \"     // TODO: Don't use random in render\",",
                    "        '  let num = Math.floor (Math.random() * 1E+7).toString().replace(/\\\\.\\\\d+/ig, \"\")',",
                    "        \"\",",
                    "        \"  return <div className='HelloWorld' title={`You are visitor number ${ num }`} onMouseOver={onMouseOver}>\",",
                    "        \"\",",
                    "        \"    <strong>{ greeting.slice( 0, 1 ).toUpperCase() + greeting.slice(1).toLowerCase() }</strong>\",",
                    "        '    {greeting.endsWith(\",\") ? \" \" : <span style={{color: \\'\\\\grey\\'}}>\", \"</span> }',",
                    "        \"    <em>\",",
                    "        \"\\t{ greeted }\",",
                    "        \"\\t</em>\",",
                    "        \"    { (silent)\",",
                    "        '      ? \".\"',",
                    "        '      : \"!\"}',",
                    "        \"\",",
                    "        \"    </div>;\",",
                    "        \"\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"flow\":",
                    "    case \"babel-flow\":",
                    "      return [",
                    "        \"declare export function graphql<Props, Variables, Component: React$ComponentType<Props>>\",",
                    "        \"  (query: GQLDocument, config?: Config<Props, QueryConfigOptions<Variables>>):\",",
                    "        \"  (Component: Component) => React$ComponentType<$Diff<React$ElementConfig<Component>, {\",",
                    "        \"    data: Object|void,\",",
                    "        \"    mutate: Function|void\",",
                    "        \"  }>>\",",
                    "        \"\",",
                    "        'declare type FetchPolicy = \"cache-first\" | \"cache-and-network\" | \"network-only\" | \"cache-only\"',",
                    "      ].join(\"\\n\");",
                    "    case \"typescript\":",
                    "    case \"babel-ts\":",
                    "      return [",
                    "        \"interface MyInterface {\",",
                    "        \"  foo(): string,\",",
                    "        \"  bar: Array<number>,\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"export abstract class Foo implements MyInterface {\",",
                    "        \"  foo() {\",",
                    "        \"            // TODO: return an actual value here\",",
                    "        \"        return 'hello'\",",
                    "        \"      }\",",
                    "        \"  get bar() {\",",
                    "        \"    return [  1,\",",
                    "        \"\",",
                    "        \"      2, 3,\",",
                    "        \"    ]\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"type RequestType = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'OPTIONS' | 'CONNECT' | 'DELETE' | 'TRACE'\",",
                    "      ].join(\"\\n\");",
                    "    case \"css\":",
                    "      // Excerpted from the Bootstrap source, which is licensed under the MIT license:",
                    "      // https://github.com/twbs/bootstrap/blob/v4.0.0-beta.3/LICENSE",
                    "      return [",
                    "        \"@media (max-width: 480px) {\",",
                    "        \"  .bd-examples {margin-right: -.75rem;margin-left: -.75rem\",",
                    "        \"  }\",",
                    "        \"  \",",
                    "        ' .bd-examples>[class^=\"col-\"]  {',",
                    "        \"    padding-right: .75rem;\",",
                    "        \"    padding-left: .75rem;\",",
                    "        \"  \",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"scss\":",
                    "      // Excerpted from the Bootstrap source, which is licensed under the MIT license:",
                    "      // https://github.com/twbs/bootstrap/blob/v4.0.0-beta.3/LICENSE",
                    "      return [",
                    "        \"@function color-yiq($color) {\",",
                    "        \"  $r: red($color);$g: green($color);$b: blue($color);\",",
                    "        \"\",",
                    "        \"  $yiq: (($r * 299) + ($g * 587) + ($b * 114)) / 1000;\",",
                    "        \"\",",
                    "        \"  @if ($yiq >= $yiq-contrasted-threshold) {\",",
                    "        \"    @return $yiq-text-dark;\",",
                    "        \"} @else {\",",
                    "        \"    @return $yiq-text-light;\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"@each $color, $value in $colors {\",",
                    "        \"  .swatch-#{$color} {\",",
                    "        \"    color: color-yiq($value);\",",
                    "        \"    background-color: #{$value};\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"less\":",
                    "      // Copied from http://lesscss.org/features/#detached-rulesets-feature",
                    "      return [",
                    "        \"@my-ruleset: {\",",
                    "        \"    .my-selector {\",",
                    "        \"      @media tv {\",",
                    "        \"        background-color: black;\",",
                    "        \"      }\",",
                    "        \"    }\",",
                    "        \"  };\",",
                    "        \"@media (orientation:portrait) {\",",
                    "        \"    @my-ruleset();\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      // Excerpted & adapted from Wikipedia, under the Creative Commons Attribution-ShareAlike License",
                    "      // https://en.wikipedia.org/wiki/JSON#Example",
                    "      return [",
                    "        '{\"allOn\": \"Single\", \"Line\": \"example\",',",
                    "        '\"noSpace\":true,',",
                    "        '  \"quote\": {',",
                    "        \"    'singleQuote': 'example',\",",
                    "        '                  \"indented\": true,',",
                    "        \"  },\",",
                    "        '  \"phoneNumbers\": [',",
                    "        '    {\"type\": \"home\",',",
                    "        '      \"number\": \"212 555-1234\"},',",
                    "        '    {\"type\": \"office\",',",
                    "        '      \"trailing\": \"commas by accident\"},',",
                    "        \"  ],\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"graphql\":",
                    "      return [",
                    "        \"query Browse($offset: Int, $limit: Int, $categories: [String!], $search: String) {\",",
                    "        \"  browse(limit: $limit, offset: $offset, categories: $categories, search: $search) {\",",
                    "        \"    total,\",",
                    "        \"    results {\",",
                    "        \"        title\",",
                    "        \"        price\",",
                    "        \"    }\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"markdown\":",
                    "      return [",
                    "        \"Header\",",
                    "        \"======\",",
                    "        \"\",",
                    "        \"_Look,_ code blocks are formatted *too!*\",",
                    "        \"\",",
                    "        \"``` js\",",
                    "        \"function identity(x) { return x }\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"Pilot|Airport|Hours\",",
                    "        \"--|:--:|--:\",",
                    "        \"John Doe|SKG|1338\",",
                    "        \"Jane Roe|JFK|314\",",
                    "        \"\",",
                    "        \"- - - - - - - - - - - - - - -\",",
                    "        \"\",",
                    "        \"+ List\",",
                    "        \" + with a [link] (/to/somewhere)\",",
                    "        \"+ and [another one]\",",
                    "        \"\",",
                    "        \"\",",
                    "        \"  [another one]:  http://example.com 'Example title'\",",
                    "        \"\",",
                    "        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",",
                    "        \"Curabitur consectetur maximus risus, sed maximus tellus tincidunt et.\",",
                    "      ].join(\"\\n\");",
                    "    case \"mdx\":",
                    "      // modified from https://github.com/mdx-js/mdx/blob/master/packages/mdx/test/fixtures/blog-post.md",
                    "      return [",
                    "        \"import     {     Baz } from     './Fixture'\",",
                    "        \"import { Buz  }   from './Fixture'\",",
                    "        \"\",",
                    "        \"export  const   foo    = {\",",
                    "        \"  hi:     `Fudge ${Baz.displayName || 'Baz'}`,\",",
                    "        \"  authors: [\",",
                    "        \"     'fred',\",",
                    "        \"           'sally'\",",
                    "        \"    ]\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"# Hello,    world!\",",
                    "        \"\",",
                    "        \"\",",
                    "        \" I'm an awesome   paragraph.\",",
                    "        \"\",",
                    "        \"<!-- I'm a comment -->\",",
                    "        \"\",",
                    "        \"<Foo bg='red'>\",",
                    "        \"      <Bar    >hi    </Bar>\",",
                    "        \"       {  hello       }\",",
                    "        \"       {     /* another comment */}\",",
                    "        \"</Foo>\",",
                    "        \"\",",
                    "        \"```\",",
                    "        \"test codeblock\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"```js\",",
                    "        \"module.exports = 'test'\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"```sh\",",
                    "        \"npm i -g foo\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"| Test  | Table   |\",",
                    "        \"|    :---     | :----  |\",",
                    "        \"|   Col1  | Col2    |\",",
                    "        \"\",",
                    "        \"export   default     ({children   }) => < div>{    children}</div>\",",
                    "        \"\",",
                    "      ].join(\"\\n\");",
                    "    case \"vue\":",
                    "      return [",
                    "        \"<template>\",",
                    "        \"  <p>Templates are formatted as well...\",",
                    "        \"    </p>\",",
                    "        \"</template>\",",
                    "        \"\",",
                    "        \"<script>\",",
                    "        \"let Prettier = format => { your.js('though') }\",",
                    "        \"</script>\",",
                    "        \"\",",
                    "        \"<style>\",",
                    "        \".and { css: too !important }\",",
                    "        \"</style>\",",
                    "      ].join(\"\\n\");",
                    "    case \"yaml\":",
                    "      // modified from http://yaml.org/start.html",
                    "      return [",
                    "        \"---\",",
                    "        \"invoice   :   34843\",",
                    "        \"date   :    2001-01-23\",",
                    "        \"bill-to:    &id001\",",
                    "        \"    given    : Chris\",",
                    "        \"    family  : Dumars\",",
                    "        \"    address:\",",
                    "        \"        lines: |\",",
                    "        \"            458 Walkman Dr.\",",
                    "        \"            Suite #292\",",
                    "        \"        city        : Royal Oak\",",
                    "        \"        state      : MI\",",
                    "        \"        postal  : 48046\",",
                    "        \"ship-to: *id001\",",
                    "        \"product:\",",
                    "        \"    - \",",
                    "        \"    \",",
                    "        \"      sku         : BL394D\",",
                    "        \"      ? quantity    \",",
                    "        \"      : 4\",",
                    "        \"      description : Basketball\",",
                    "        \"      ? price       \",",
                    "        \"      : 450.00\",",
                    "        \"      \",",
                    "        \"      \",",
                    "        \"    - \",",
                    "        \"      sku          :   BL4438H\",",
                    "        \"      quantity      :  1\",",
                    "        \"      description:      Super Hoop\",",
                    "        \"      price         :  2392.00\",",
                    "        \"      \",",
                    "        \"      \",",
                    "        \"tax  :  251.42\",",
                    "        \"total : 4443.52\",",
                    "        \"comments: >\",",
                    "        \"    Late afternoon is best.\",",
                    "        \"    Backup contact is Nancy\",",
                    "        \"    Billsmer @ 338-4338.\",",
                    "        \"\",",
                    "      ].join(\"\\n\");",
                    "    case \"glimmer\":",
                    "      // modified from http://handlebarsjs.com/",
                    "      return [",
                    "        '  <div     class=\"entry\"    >',",
                    "        \"  <h1>{{  title    }}</h1>\",",
                    "        '  <div   class=\"body\">',",
                    "        \"            {{   body         }}\",",
                    "        \"</div> </div>\",",
                    "      ].join(\"\\n\");",
                    "    case \"html\":",
                    "    case \"angular\":",
                    "    case \"lwc\":",
                    "      return [",
                    "        \"<!DOCTYPE html>\",",
                    "        '<HTML CLASS=\"no-js mY-ClAsS\">',",
                    "        \"  <HEAD>\",",
                    "        '    <META CHARSET=\"utf-8\">',",
                    "        \"    <TITLE>My tITlE</TITLE>\",",
                    "        '    <META NAME=\"description\" content=\"My CoNtEnT\">',",
                    "        \"  </HEAD>\",",
                    "        \"  <body>\",",
                    "        \"    <P>Hello world!<BR> This is HTML5 Boilerplate.</P>\",",
                    "        \"    <SCRIPT>\",",
                    "        \"      window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;\",",
                    "        \"      ga('create', 'UA-XXXXX-Y', 'auto'); ga('send', 'pageview')\",",
                    "        \"    </SCRIPT>\",",
                    "        '    <SCRIPT src=\"https://www.google-analytics.com/analytics.js\" ASYNC DEFER></SCRIPT>',",
                    "        \"  </body>\",",
                    "        \"</HTML>\",",
                    "      ].join(\"\\n\");",
                    "    default:",
                    "      return \"\";",
                    "  }",
                    "}"
                ]
            },
            "helpers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function stateToggler(key) {",
                    "  return (state) => ({ [key]: !state[key] });",
                    "}",
                    "",
                    "const { hasOwnProperty } = Object.prototype;",
                    "",
                    "function is(x, y) {",
                    "  // SameValue algorithm",
                    "  if (x === y) {",
                    "    // Steps 1-5, 7-10",
                    "    // Steps 6.b-6.e: +0 != -0",
                    "    return x !== 0 || 1 / x === 1 / y;",
                    "  }",
                    "  // Step 6.a: NaN == NaN",
                    "  return x !== x && y !== y;",
                    "}",
                    "",
                    "export function shallowEqual(objA, objB) {",
                    "  if (is(objA, objB)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    typeof objA !== \"object\" ||",
                    "    objA === null ||",
                    "    typeof objB !== \"object\" ||",
                    "    objB === null",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const keysA = Object.keys(objA);",
                    "  const keysB = Object.keys(objB);",
                    "",
                    "  if (keysA.length !== keysB.length) {",
                    "    return false;",
                    "  }",
                    "",
                    "  for (let i = 0; i < keysA.length; i++) {",
                    "    if (",
                    "      !hasOwnProperty.call(objB, keysA[i]) ||",
                    "      !is(objA[keysA[i]], objB[keysA[i]])",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"codemirror-graphql/mode\";",
                    "",
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "import Playground from \"./Playground\";",
                    "import VersionLink from \"./VersionLink\";",
                    "import WorkerApi from \"./WorkerApi\";",
                    "import { fixPrettierVersion } from \"./util\";",
                    "",
                    "class App extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { loaded: false };",
                    "    this.worker = new WorkerApi(\"/worker.js\");",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.worker.getMetadata().then(({ supportInfo, version }) => {",
                    "      this.setState({",
                    "        loaded: true,",
                    "        availableOptions: supportInfo.options.map(augmentOption),",
                    "        version: fixPrettierVersion(version),",
                    "      });",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { loaded, availableOptions, version } = this.state;",
                    "",
                    "    if (!loaded) {",
                    "      return \"Loading...\";",
                    "    }",
                    "",
                    "    return (",
                    "      <React.Fragment>",
                    "        <VersionLink version={version} />",
                    "        <Playground",
                    "          worker={this.worker}",
                    "          availableOptions={availableOptions}",
                    "          version={version}",
                    "        />",
                    "      </React.Fragment>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function augmentOption(option) {",
                    "  if (option.type === \"boolean\" && option.default === true) {",
                    "    option.inverted = true;",
                    "  }",
                    "",
                    "  option.cliName =",
                    "    \"--\" +",
                    "    (option.inverted ? \"no-\" : \"\") +",
                    "    option.name.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();",
                    "",
                    "  return option;",
                    "}",
                    "",
                    "ReactDOM.render(<App />, document.getElementById(\"root\"));"
                ]
            },
            "markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function formatMarkdown(",
                    "  input,",
                    "  output,",
                    "  output2,",
                    "  version,",
                    "  url,",
                    "  options,",
                    "  cliOptions,",
                    "  full",
                    ") {",
                    "  const syntax = getMarkdownSyntax(options);",
                    "  const optionsString = formatCLIOptions(cliOptions);",
                    "  const isIdempotent = output2 === \"\" || output === output2;",
                    "",
                    "  return [",
                    "    `**Prettier ${version}**`,",
                    "    `[Playground link](${url})`,",
                    "    optionsString === \"\" ? null : codeBlock(optionsString, \"sh\"),",
                    "    \"\",",
                    "    \"**Input:**\",",
                    "    codeBlock(input, syntax),",
                    "    \"\",",
                    "    \"**Output:**\",",
                    "    codeBlock(output, syntax),",
                    "  ]",
                    "    .concat(",
                    "      isIdempotent ? [] : [\"\", \"**Second Output:**\", codeBlock(output2, syntax)]",
                    "    )",
                    "    .concat(full ? [\"\", \"**Expected behavior:**\", \"\"] : [])",
                    "    .filter((part) => {",
                    "      return part != null;",
                    "    })",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function getMarkdownSyntax(options) {",
                    "  switch (options.parser) {",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"flow\":",
                    "      return \"jsx\";",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "      return \"tsx\";",
                    "    case \"json\":",
                    "    case \"json-stringify\":",
                    "      return \"jsonc\";",
                    "    case \"glimmer\":",
                    "      return \"hbs\";",
                    "    case \"angular\":",
                    "    case \"lwc\":",
                    "      return \"html\";",
                    "    default:",
                    "      return options.parser;",
                    "  }",
                    "}",
                    "",
                    "function formatCLIOptions(cliOptions) {",
                    "  return cliOptions",
                    "    .map(([name, value]) => (value === true ? name : `${name} ${value}`))",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function codeBlock(content, syntax) {",
                    "  const backtickSequences = content.match(/`+/g) || [];",
                    "  const longestBacktickSequenceLength = Math.max(",
                    "    ...backtickSequences.map(({ length }) => length)",
                    "  );",
                    "  const fenceLength = Math.max(3, longestBacktickSequenceLength + 1);",
                    "  const fence = \"`\".repeat(fenceLength);",
                    "  return [fence + (syntax || \"\"), content, fence].join(\"\\n\");",
                    "}",
                    "",
                    "module.exports = formatMarkdown;"
                ]
            },
            "panels.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import CodeMirror from \"codemirror\";",
                    "import * as React from \"react\";",
                    "",
                    "class CodeMirrorPanel extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this._textareaRef = React.createRef();",
                    "    this._codeMirror = null;",
                    "    this._cached = \"\";",
                    "    this._overlay = null;",
                    "    this.handleChange = this.handleChange.bind(this);",
                    "    this.handleFocus = this.handleFocus.bind(this);",
                    "    this.handleSelectionChange = this.handleSelectionChange.bind(this);",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    const options = { ...this.props };",
                    "    delete options.ruler;",
                    "    delete options.rulerColor;",
                    "    delete options.value;",
                    "    delete options.onChange;",
                    "",
                    "    options.rulers = [makeRuler(this.props)];",
                    "",
                    "    if (options.foldGutter) {",
                    "      options.gutters = [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"];",
                    "    }",
                    "",
                    "    this._codeMirror = CodeMirror.fromTextArea(",
                    "      this._textareaRef.current,",
                    "      options",
                    "    );",
                    "    this._codeMirror.on(\"change\", this.handleChange);",
                    "    this._codeMirror.on(\"focus\", this.handleFocus);",
                    "    this._codeMirror.on(\"beforeSelectionChange\", this.handleSelectionChange);",
                    "",
                    "    window.CodeMirror.keyMap.pcSublime[\"Ctrl-L\"] = false;",
                    "    window.CodeMirror.keyMap.sublime[\"Ctrl-L\"] = false;",
                    "",
                    "    this.updateValue(this.props.value || \"\");",
                    "    this.updateOverlay();",
                    "  }",
                    "",
                    "  componentWillUnmount() {",
                    "    this._codeMirror && this._codeMirror.toTextArea();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    if (this.props.value !== this._cached) {",
                    "      this.updateValue(this.props.value);",
                    "    }",
                    "    if (",
                    "      this.props.overlayStart !== prevProps.overlayStart ||",
                    "      this.props.overlayEnd !== prevProps.overlayEnd",
                    "    ) {",
                    "      this.updateOverlay();",
                    "    }",
                    "    if (this.props.mode !== prevProps.mode) {",
                    "      this._codeMirror.setOption(\"mode\", this.props.mode);",
                    "    }",
                    "    if (this.props.ruler !== prevProps.ruler) {",
                    "      this._codeMirror.setOption(\"rulers\", [makeRuler(this.props)]);",
                    "    }",
                    "  }",
                    "",
                    "  updateValue(value) {",
                    "    this._cached = value;",
                    "    this._codeMirror.setValue(value);",
                    "",
                    "    if (this.props.autoFold instanceof RegExp) {",
                    "      const lines = value.split(\"\\n\");",
                    "      // going backwards to prevent unfolding folds created earlier",
                    "      for (let i = lines.length - 1; i >= 0; i--) {",
                    "        if (this.props.autoFold.test(lines[i])) {",
                    "          this._codeMirror.foldCode(i);",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  updateOverlay() {",
                    "    if (!this.props.readOnly) {",
                    "      if (this._overlay) {",
                    "        this._codeMirror.removeOverlay(this._overlay);",
                    "      }",
                    "      const [start, end] = getIndexPosition(this.props.value, [",
                    "        this.props.overlayStart,",
                    "        this.props.overlayEnd,",
                    "      ]);",
                    "      this._overlay = createOverlay(start, end);",
                    "      this._codeMirror.addOverlay(this._overlay);",
                    "    }",
                    "  }",
                    "",
                    "  handleFocus(/* codeMirror, event */) {",
                    "    if (this._codeMirror.getValue() === this.props.codeSample) {",
                    "      this._codeMirror.execCommand(\"selectAll\");",
                    "    }",
                    "  }",
                    "",
                    "  handleChange(doc, change) {",
                    "    if (change.origin !== \"setValue\") {",
                    "      this._cached = doc.getValue();",
                    "      this.props.onChange(this._cached);",
                    "      this.updateOverlay();",
                    "    }",
                    "  }",
                    "",
                    "  handleSelectionChange(doc, change) {",
                    "    if (this.props.onSelectionChange) {",
                    "      this.props.onSelectionChange(change.ranges[0]);",
                    "    }",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <div className=\"editor input\">",
                    "        <textarea ref={this._textareaRef} />",
                    "      </div>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function getIndexPosition(text, indexes) {",
                    "  indexes = indexes.slice();",
                    "  let line = 0;",
                    "  let count = 0;",
                    "  let lineStart = 0;",
                    "  const result = [];",
                    "",
                    "  while (indexes.length) {",
                    "    const index = indexes.shift();",
                    "",
                    "    while (count < index && count < text.length) {",
                    "      if (text[count] === \"\\n\") {",
                    "        line++;",
                    "        lineStart = count + 1;",
                    "      }",
                    "      count++;",
                    "    }",
                    "",
                    "    result.push({ line, pos: count - lineStart });",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function createOverlay(start, end) {",
                    "  return {",
                    "    token(stream) {",
                    "      const { line } = stream.lineOracle;",
                    "",
                    "      if (line < start.line || line > end.line) {",
                    "        stream.skipToEnd();",
                    "      } else if (line === start.line && stream.pos < start.pos) {",
                    "        stream.pos = start.pos;",
                    "      } else if (line === end.line) {",
                    "        if (stream.pos < end.pos) {",
                    "          stream.pos = end.pos;",
                    "          return \"searching\";",
                    "        }",
                    "        stream.skipToEnd();",
                    "      } else {",
                    "        stream.skipToEnd();",
                    "        return \"searching\";",
                    "      }",
                    "    },",
                    "  };",
                    "}",
                    "",
                    "function makeRuler(props) {",
                    "  return { column: props.ruler, color: props.rulerColor };",
                    "}",
                    "",
                    "export function InputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      lineNumbers={true}",
                    "      keyMap=\"sublime\"",
                    "      autoCloseBrackets={true}",
                    "      matchBrackets={true}",
                    "      showCursorWhenSelecting={true}",
                    "      tabSize={4}",
                    "      rulerColor=\"#eeeeee\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function OutputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={true}",
                    "      rulerColor=\"#444444\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function DebugPanel({ value, autoFold }) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={false}",
                    "      foldGutter={true}",
                    "      autoFold={autoFold}",
                    "      mode=\"jsx\"",
                    "      value={value}",
                    "    />",
                    "  );",
                    "}"
                ]
            },
            "storage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function get(key) {",
                    "  try {",
                    "    return JSON.parse(window.localStorage.getItem(key));",
                    "  } catch (_) {",
                    "    // noop",
                    "  }",
                    "}",
                    "",
                    "export function set(key, value) {",
                    "  try {",
                    "    window.localStorage.setItem(key, JSON.stringify(value));",
                    "  } catch (_) {",
                    "    // noop",
                    "  }",
                    "}"
                ]
            },
            "urlHash.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import LZString from \"lz-string\";",
                    "",
                    "export function read() {",
                    "  const hash = document.location.hash.slice(1);",
                    "  if (!hash) {",
                    "    return {};",
                    "  }",
                    "",
                    "  // backwards support for old json encoded URIComponent",
                    "  const decode = hash.includes(\"%7B%22\")",
                    "    ? decodeURIComponent",
                    "    : LZString.decompressFromEncodedURIComponent;",
                    "",
                    "  try {",
                    "    return JSON.parse(decode(hash));",
                    "  } catch (_) {",
                    "    return {};",
                    "  }",
                    "}",
                    "",
                    "export function replace(state) {",
                    "  const hash = LZString.compressToEncodedURIComponent(JSON.stringify(state));",
                    "  if (",
                    "    typeof URL === \"function\" &&",
                    "    typeof history === \"object\" &&",
                    "    typeof history.replaceState === \"function\"",
                    "  ) {",
                    "    const url = new URL(location);",
                    "    url.hash = hash;",
                    "    history.replaceState(null, null, url);",
                    "  } else {",
                    "    location.hash = hash;",
                    "  }",
                    "}"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function fixPrettierVersion(version) {",
                    "  const match = version.match(/^\\d+\\.\\d+\\.\\d+-pr.(\\d+)$/);",
                    "  if (match) {",
                    "    return `pr-${match[1]}`;",
                    "  }",
                    "  return version;",
                    "}",
                    "",
                    "export function getDefaults(availableOptions, optionNames) {",
                    "  const defaults = {};",
                    "  for (const option of availableOptions) {",
                    "    if (optionNames.includes(option.name)) {",
                    "      defaults[option.name] =",
                    "        option.name === \"parser\" ? \"babel\" : option.default;",
                    "    }",
                    "  }",
                    "  return defaults;",
                    "}",
                    "",
                    "export function buildCliArgs(availableOptions, options) {",
                    "  const args = [];",
                    "  for (const option of availableOptions) {",
                    "    const value = options[option.name];",
                    "",
                    "    if (typeof value === \"undefined\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (option.type === \"boolean\") {",
                    "      if ((value && !option.inverted) || (!value && option.inverted)) {",
                    "        args.push([option.cliName, true]);",
                    "      }",
                    "    } else if (value !== option.default || option.name === \"rangeStart\") {",
                    "      args.push([option.cliName, value]);",
                    "    }",
                    "  }",
                    "  return args;",
                    "}",
                    "",
                    "export function getCodemirrorMode(parser) {",
                    "  switch (parser) {",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return \"css\";",
                    "    case \"graphql\":",
                    "      return \"graphql\";",
                    "    case \"markdown\":",
                    "      return \"markdown\";",
                    "    default:",
                    "      return \"jsx\";",
                    "  }",
                    "}",
                    "",
                    "const astAutoFold = {",
                    "  estree: /^\\s*\"(loc|start|end)\":/,",
                    "  postcss: /^\\s*\"(source|input|raws|file)\":/,",
                    "  html: /^\\s*\"(sourceSpan|valueSpan|nameSpan|startSourceSpan|endSourceSpan|tagDefinition)\":/,",
                    "  mdast: /^\\s*\"position\":/,",
                    "  yaml: /^\\s*\"position\":/,",
                    "  glimmer: /^\\s*\"loc\":/,",
                    "};",
                    "",
                    "export function getAstAutoFold(parser) {",
                    "  switch (parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return astAutoFold.estree;",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return astAutoFold.postcss;",
                    "    case \"html\":",
                    "    case \"angular\":",
                    "    case \"vue\":",
                    "    case \"lwc\":",
                    "      return astAutoFold.html;",
                    "    case \"markdown\":",
                    "    case \"mdx\":",
                    "      return astAutoFold.mdast;",
                    "    case \"yaml\":",
                    "      return astAutoFold.yaml;",
                    "    case \"glimmer\":",
                    "      return astAutoFold.glimmer;",
                    "  }",
                    "}"
                ]
            },
            "sidebar": {
                "SidebarOptions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "import groupBy from \"lodash/groupBy\";",
                        "",
                        "import { SidebarCategory } from \"./components\";",
                        "import Option from \"./options\";",
                        "",
                        "export default function ({",
                        "  categories,",
                        "  availableOptions,",
                        "  optionValues,",
                        "  onOptionValueChange,",
                        "}) {",
                        "  const options = groupBy(availableOptions, \"category\");",
                        "  return categories.map((category) =>",
                        "    options[category] ? (",
                        "      <SidebarCategory key={category} title={category}>",
                        "        {options[category].map((option) => (",
                        "          <Option",
                        "            key={option.name}",
                        "            option={option}",
                        "            value={optionValues[option.name]}",
                        "            onChange={onOptionValueChange}",
                        "          />",
                        "        ))}",
                        "      </SidebarCategory>",
                        "    ) : null",
                        "  );",
                        "}"
                    ]
                },
                "components.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Sidebar({ visible, children }) {",
                        "  return (",
                        "    <div className={`options-container ${visible ? \"open\" : \"\"}`}>",
                        "      <div className=\"options\">{children}</div>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "export function SidebarCategory({ title, children }) {",
                        "  return (",
                        "    <details className=\"sub-options\" open=\"true\">",
                        "      <summary>{title}</summary>",
                        "      {children}",
                        "    </details>",
                        "  );",
                        "}"
                    ]
                },
                "inputs.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Checkbox({ label: _label, title, checked, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      <input",
                        "        type=\"checkbox\"",
                        "        checked={checked}",
                        "        onChange={(ev) => onChange(ev.target.checked)}",
                        "      />{\" \"}",
                        "      {_label}",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function Select({ label: _label, title, values, selected, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <select value={selected} onChange={(ev) => onChange(ev.target.value)}>",
                        "        {values.map((val) => (",
                        "          <option key={val} value={val}>",
                        "            {val}",
                        "          </option>",
                        "        ))}",
                        "      </select>",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function NumberInput({",
                        "  label: _label,",
                        "  title,",
                        "  value,",
                        "  min,",
                        "  max,",
                        "  step,",
                        "  onChange,",
                        "}) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <input",
                        "        type=\"number\"",
                        "        min={min}",
                        "        max={max}",
                        "        step={step}",
                        "        value={value}",
                        "        onChange={(ev) => onChange(parseInt(ev.target.value, 10))}",
                        "      />",
                        "    </label>",
                        "  );",
                        "}"
                    ]
                },
                "options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "import { Checkbox, Select, NumberInput } from \"./inputs\";",
                        "",
                        "export function BooleanOption({ option, value, onChange }) {",
                        "  function maybeInvert(value) {",
                        "    return option.inverted ? !value : value;",
                        "  }",
                        "  return (",
                        "    <Checkbox",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      checked={maybeInvert(value)}",
                        "      onChange={(checked) => onChange(option, maybeInvert(checked))}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function ChoiceOption({ option, value, onChange }) {",
                        "  return (",
                        "    <Select",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      values={option.choices.map((choice) => choice.value)}",
                        "      selected={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function NumberOption({ option, value, onChange }) {",
                        "  return (",
                        "    <NumberInput",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      min={option.range.start}",
                        "      max={option.range.end}",
                        "      step={option.range.step}",
                        "      value={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export default function (props) {",
                        "  switch (props.option.type) {",
                        "    case \"boolean\":",
                        "      return <BooleanOption {...props} />;",
                        "    case \"int\":",
                        "      return <NumberOption {...props} />;",
                        "    case \"choice\":",
                        "      return <ChoiceOption {...props} />;",
                        "    default:",
                        "      throw new Error(\"unsupported type\");",
                        "  }",
                        "}",
                        "",
                        "function getDescription(option) {",
                        "  const description = option.inverted",
                        "    ? option.oppositeDescription",
                        "    : option.description;",
                        "  return description && description.replace(/\\n/g, \" \");",
                        "}"
                    ]
                }
            }
        },
        "static": {
            "_redirects": {},
            "icon.png": {},
            "install-service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/* eslint-env browser */",
                    "",
                    "if (\"serviceWorker\" in navigator) {",
                    "  navigator.serviceWorker.register(\"/service-worker.js\", {",
                    "    scope: \"/playground/\",",
                    "  });",
                    "}"
                ]
            },
            "landing.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/* eslint-env browser */",
                    "",
                    "if (location.hash.slice(1).startsWith(encodeURIComponent(\"{\"))) {",
                    "  location.pathname = \"/playground/\";",
                    "}",
                    "",
                    "window.addEventListener(\"load\", () => {",
                    "  // We don't have access to a unique body css attribute for just the homepage",
                    "  // so instead it is set on load. It's only really visible on a vertical overscroll",
                    "  document.body.style.backgroundColor = \"rgb(24, 32, 37)\";",
                    "",
                    "  const logoWrapper = document.querySelector(\".animatedLogoWrapper\");",
                    "  const logo = document.querySelector(\".prettier-logo-wide\");",
                    "  const lastDash = logo.querySelector(\"g:last-of-type path:last-of-type\");",
                    "",
                    "  function handleLogoDrag(event) {",
                    "    logo.classList.add(\"rolling\");",
                    "    event.preventDefault();",
                    "  }",
                    "",
                    "  logoWrapper.setAttribute(\"draggable\", \"true\");",
                    "  logoWrapper.addEventListener(\"touchstart\", handleLogoDrag);",
                    "  logoWrapper.addEventListener(\"dragstart\", handleLogoDrag);",
                    "",
                    "  lastDash.addEventListener(\"animationend\", (event) => {",
                    "    if (event.animationName.match(/roll/)) {",
                    "      logo.classList.remove(\"rolling\");",
                    "    }",
                    "  });",
                    "",
                    "  const yarnButton = document.querySelector(\".showYarnButton\");",
                    "  const npmButton = document.querySelector(\".showNpmButton\");",
                    "  const getStartedSection = document.querySelector(\".getStartedSection\");",
                    "",
                    "  npmButton.addEventListener(\"click\", (event) => {",
                    "    event.preventDefault();",
                    "    npmButton.classList.add(\"active\");",
                    "    yarnButton.classList.remove(\"active\");",
                    "    getStartedSection.classList.add(\"getStartedSection--npm\");",
                    "  });",
                    "  yarnButton.addEventListener(\"click\", (event) => {",
                    "    event.preventDefault();",
                    "    yarnButton.classList.add(\"active\");",
                    "    npmButton.classList.remove(\"active\");",
                    "    getStartedSection.classList.remove(\"getStartedSection--npm\");",
                    "  });",
                    "});"
                ]
            },
            "manifest.json": {},
            "overrides.css": {},
            "prettier-centered-logo-static.svg": {},
            "prettier.png": {},
            "service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* eslint-env serviceworker */",
                    "/* global toolbox */",
                    "",
                    "\"use strict\";",
                    "",
                    "importScripts(\"https://unpkg.com/sw-toolbox@3.6.0/sw-toolbox.js\");",
                    "",
                    "toolbox.precache([",
                    "  // Scripts",
                    "  \"lib/standalone.js\",",
                    "  \"lib/parser-angular.js\",",
                    "  \"lib/parser-babel.js\",",
                    "  \"lib/parser-flow.js\",",
                    "  \"lib/parser-glimmer.js\",",
                    "  \"lib/parser-graphql.js\",",
                    "  \"lib/parser-html.js\",",
                    "  \"lib/parser-markdown.js\",",
                    "  \"lib/parser-postcss.js\",",
                    "  \"lib/parser-typescript.js\",",
                    "  \"lib/parser-yaml.js\",",
                    "  \"playground.js\",",
                    "  \"https://unpkg.com/sw-toolbox@3.6.0/sw-toolbox.js\",",
                    "",
                    "  // CodeMirror; keep this in sync with website/pages/playground/index.html",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/codemirror.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/fold/foldgutter.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/codemirror.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/mode/javascript/javascript.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/mode/xml/xml.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/mode/jsx/jsx.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/mode/css/css.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/mode/markdown/markdown.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/display/placeholder.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/display/rulers.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/search/searchcursor.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/edit/matchbrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/edit/closebrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/comment/comment.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/wrap/hardwrap.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/fold/foldcode.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/fold/foldgutter.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/addon/fold/brace-fold.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.52.2/keymap/sublime.min.js\",",
                    "",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react/16.13.1/umd/react.production.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react-dom/16.13.1/umd/react-dom.production.min.js\",",
                    "",
                    "  // Images",
                    "  \"/prettier.png\",",
                    "]);",
                    "",
                    "// Default to hit the cache only if there's a network error",
                    "toolbox.router.default = toolbox.networkFirst;",
                    "",
                    "// For scripts, stylesheets and images, we can use the \"fastest\" strategy",
                    "// This means you need to reload twice to get new changes",
                    "toolbox.router.get(/\\.(js|css|png|svg)$/, toolbox.fastest);"
                ]
            },
            "worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* eslint-env worker */",
                    "/* eslint no-var: off, strict: off */",
                    "/* globals prettier prettierPlugins */",
                    "",
                    "var imported = Object.create(null);",
                    "function importScriptOnce(url) {",
                    "  if (!imported[url]) {",
                    "    imported[url] = true;",
                    "    importScripts(url);",
                    "  }",
                    "}",
                    "",
                    "// this is required to only load parsers when we need them",
                    "var parsers = {",
                    "  // JS - Babel",
                    "  get babel() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers.babel;",
                    "  },",
                    "  get \"babel-flow\"() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers[\"babel-flow\"];",
                    "  },",
                    "  get \"babel-ts\"() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers[\"babel-ts\"];",
                    "  },",
                    "  get json() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers.json;",
                    "  },",
                    "  get json5() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers.json5;",
                    "  },",
                    "  get \"json-stringify\"() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers[\"json-stringify\"];",
                    "  },",
                    "  get __js_expression() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers.__js_expression;",
                    "  },",
                    "  get __vue_expression() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers.__vue_expression;",
                    "  },",
                    "  get __vue_event_binding() {",
                    "    importScriptOnce(\"lib/parser-babel.js\");",
                    "    return prettierPlugins.babel.parsers.__vue_event_binding;",
                    "  },",
                    "  // JS - Flow",
                    "  get flow() {",
                    "    importScriptOnce(\"lib/parser-flow.js\");",
                    "    return prettierPlugins.flow.parsers.flow;",
                    "  },",
                    "  // JS - TypeScript",
                    "  get typescript() {",
                    "    importScriptOnce(\"lib/parser-typescript.js\");",
                    "    return prettierPlugins.typescript.parsers.typescript;",
                    "  },",
                    "  // JS - Angular Action",
                    "  get __ng_action() {",
                    "    importScriptOnce(\"lib/parser-angular.js\");",
                    "    return prettierPlugins.angular.parsers.__ng_action;",
                    "  },",
                    "  // JS - Angular Binding",
                    "  get __ng_binding() {",
                    "    importScriptOnce(\"lib/parser-angular.js\");",
                    "    return prettierPlugins.angular.parsers.__ng_binding;",
                    "  },",
                    "  // JS - Angular Interpolation",
                    "  get __ng_interpolation() {",
                    "    importScriptOnce(\"lib/parser-angular.js\");",
                    "    return prettierPlugins.angular.parsers.__ng_interpolation;",
                    "  },",
                    "  // JS - Angular Directive",
                    "  get __ng_directive() {",
                    "    importScriptOnce(\"lib/parser-angular.js\");",
                    "    return prettierPlugins.angular.parsers.__ng_directive;",
                    "  },",
                    "",
                    "  // CSS",
                    "  get css() {",
                    "    importScriptOnce(\"lib/parser-postcss.js\");",
                    "    return prettierPlugins.postcss.parsers.css;",
                    "  },",
                    "  get less() {",
                    "    importScriptOnce(\"lib/parser-postcss.js\");",
                    "    return prettierPlugins.postcss.parsers.css;",
                    "  },",
                    "  get scss() {",
                    "    importScriptOnce(\"lib/parser-postcss.js\");",
                    "    return prettierPlugins.postcss.parsers.css;",
                    "  },",
                    "",
                    "  // GraphQL",
                    "  get graphql() {",
                    "    importScriptOnce(\"lib/parser-graphql.js\");",
                    "    return prettierPlugins.graphql.parsers.graphql;",
                    "  },",
                    "",
                    "  // Markdown",
                    "  get markdown() {",
                    "    importScriptOnce(\"lib/parser-markdown.js\");",
                    "    return prettierPlugins.markdown.parsers.remark;",
                    "  },",
                    "  get mdx() {",
                    "    importScriptOnce(\"lib/parser-markdown.js\");",
                    "    return prettierPlugins.markdown.parsers.mdx;",
                    "  },",
                    "",
                    "  // YAML",
                    "  get yaml() {",
                    "    importScriptOnce(\"lib/parser-yaml.js\");",
                    "    return prettierPlugins.yaml.parsers.yaml;",
                    "  },",
                    "",
                    "  // Handlebars",
                    "  get glimmer() {",
                    "    importScriptOnce(\"lib/parser-glimmer.js\");",
                    "    return prettierPlugins.glimmer.parsers.glimmer;",
                    "  },",
                    "",
                    "  // HTML",
                    "  get html() {",
                    "    importScriptOnce(\"lib/parser-html.js\");",
                    "    return prettierPlugins.html.parsers.html;",
                    "  },",
                    "  // Vue",
                    "  get vue() {",
                    "    importScriptOnce(\"lib/parser-html.js\");",
                    "    return prettierPlugins.html.parsers.vue;",
                    "  },",
                    "  // Angular",
                    "  get angular() {",
                    "    importScriptOnce(\"lib/parser-html.js\");",
                    "    return prettierPlugins.html.parsers.angular;",
                    "  },",
                    "  // Lightning Web Components",
                    "  get lwc() {",
                    "    importScriptOnce(\"lib/parser-html.js\");",
                    "    return prettierPlugins.html.parsers.lwc;",
                    "  },",
                    "};",
                    "",
                    "importScripts(\"lib/standalone.js\");",
                    "// eslint-disable-next-line no-unused-vars",
                    "var PRETTIER_DEBUG = true;",
                    "",
                    "self.onmessage = function (event) {",
                    "  self.postMessage({",
                    "    uid: event.data.uid,",
                    "    message: handleMessage(event.data.message),",
                    "  });",
                    "};",
                    "",
                    "function handleMessage(message) {",
                    "  if (message.type === \"meta\") {",
                    "    return {",
                    "      type: \"meta\",",
                    "      supportInfo: JSON.parse(",
                    "        JSON.stringify(",
                    "          prettier.getSupportInfo({",
                    "            showUnreleased: true,",
                    "          })",
                    "        )",
                    "      ),",
                    "      version: prettier.version,",
                    "    };",
                    "  }",
                    "",
                    "  if (message.type === \"format\") {",
                    "    var options = message.options || {};",
                    "",
                    "    delete options.ast;",
                    "    delete options.doc;",
                    "    delete options.output2;",
                    "",
                    "    var plugins = [{ parsers }];",
                    "    options.plugins = plugins;",
                    "",
                    "    var response = {",
                    "      formatted: formatCode(message.code, options),",
                    "      debug: {",
                    "        ast: null,",
                    "        doc: null,",
                    "        reformatted: null,",
                    "      },",
                    "    };",
                    "",
                    "    if (message.debug.ast) {",
                    "      var ast;",
                    "      var errored = false;",
                    "      try {",
                    "        ast = JSON.stringify(prettier.__debug.parse(message.code, options).ast);",
                    "      } catch (e) {",
                    "        errored = true;",
                    "        ast = String(e);",
                    "      }",
                    "",
                    "      if (!errored) {",
                    "        try {",
                    "          ast = formatCode(ast, { parser: \"json\", plugins });",
                    "        } catch (e) {",
                    "          ast = JSON.stringify(ast, null, 2);",
                    "        }",
                    "      }",
                    "      response.debug.ast = ast;",
                    "    }",
                    "",
                    "    if (message.debug.doc) {",
                    "      try {",
                    "        response.debug.doc = prettier.__debug.formatDoc(",
                    "          prettier.__debug.printToDoc(message.code, options),",
                    "          { parser: \"babel\", plugins }",
                    "        );",
                    "      } catch (e) {",
                    "        response.debug.doc = String(e);",
                    "      }",
                    "    }",
                    "",
                    "    if (message.debug.reformat) {",
                    "      response.debug.reformatted = formatCode(response.formatted, options);",
                    "    }",
                    "",
                    "    return response;",
                    "  }",
                    "}",
                    "",
                    "function formatCode(text, options) {",
                    "  try {",
                    "    return prettier.format(text, options);",
                    "  } catch (e) {",
                    "    if (e.constructor && e.constructor.name === \"SyntaxError\") {",
                    "      // Likely something wrong with the user's code",
                    "      return String(e);",
                    "    }",
                    "    // Likely a bug in Prettier",
                    "    // Provide the whole stack for debugging",
                    "    return e.stack || String(e);",
                    "  }",
                    "}"
                ]
            },
            "images": {
                "get_started_rects.svg": {},
                "github.svg": {},
                "github_grey.svg": {},
                "npm.svg": {},
                "npm_grey.svg": {},
                "tidelift-small.png": {},
                "editors": {
                    "atom-128px.png": {},
                    "editor_atom.svg": {},
                    "editor_emacs.svg": {},
                    "editor_espresso.svg": {},
                    "editor_sublime.svg": {},
                    "editor_vim.svg": {},
                    "editor_vs.svg": {},
                    "editor_vscode.svg": {},
                    "editor_webstorm.svg": {},
                    "emacs-128px.png": {},
                    "espresso-128px.png": {},
                    "sublimetext-128px.png": {},
                    "vim-128px.png": {},
                    "visualstudio-128px.png": {},
                    "vscode-128px.png": {},
                    "webstorm-128px.png": {}
                },
                "languages": {
                    "css-128px.png": {},
                    "css_small_grey.svg": {},
                    "graphql-128px.png": {},
                    "graphql_small_grey.svg": {},
                    "js-128px.png": {},
                    "js_small_grey.svg": {},
                    "markdown-128px.png": {},
                    "markdown_small_grey.svg": {},
                    "python_small_grey.svg": {},
                    "swift_small_grey.svg": {},
                    "tools_css.svg": {},
                    "tools_gql.svg": {},
                    "tools_html.svg": {},
                    "tools_js.svg": {},
                    "tools_md.svg": {},
                    "tools_wip.svg": {},
                    "tools_yaml.svg": {}
                },
                "users": {
                    "3yourmind.svg": {},
                    "algolia-200x100.png": {},
                    "assertible-200x100.png": {},
                    "babel-200x100.png": {},
                    "brigad-200x100.png": {},
                    "buildcom.svg": {},
                    "campusjaeger.svg": {},
                    "charlietango-200x100.png": {},
                    "chillicream.svg": {},
                    "codecarrot.svg": {},
                    "codemix-200x100.png": {},
                    "computerbase.svg": {},
                    "contiamo-200x100.png": {},
                    "danger-200x100.png": {},
                    "discord-200x100.png": {},
                    "drizly-200x100.png": {},
                    "dropbox.svg": {},
                    "dropbox_grey.svg": {},
                    "escrow-200x100.png": {},
                    "estalee.svg": {},
                    "eventstag-200x100.png": {},
                    "exponea.svg": {},
                    "eyesquare-200x100.png": {},
                    "facebook-200x100.png": {},
                    "freelancer-200x100.png": {},
                    "getonboard-200x100.png": {},
                    "gumgum-200x100.png": {},
                    "hackclub-200x100.png": {},
                    "hasura-200x100.png": {},
                    "hearthsim-200x100.png": {},
                    "heroku.svg": {},
                    "holidaycheck-200x100.png": {},
                    "housinganywhere.svg": {},
                    "hudl-200x100.png": {},
                    "ideati-200x100.png": {},
                    "iress-200x100.png": {},
                    "jane-200x100.png": {},
                    "jest-200x100.png": {},
                    "leesa.svg": {},
                    "lifesum-200x100.png": {},
                    "loyaltylion-200x100.png": {},
                    "m6web-200x100.png": {},
                    "materialui-200x100.png": {},
                    "mathrioshka-200x100.png": {},
                    "metric-ai-white.svg": {},
                    "monei-200x100.png": {},
                    "mongodb-200x100.png": {},
                    "moonmail-200x100.png": {},
                    "n26-200x100.png": {},
                    "nhl-200x100.png": {},
                    "nrwl-200x100.png": {},
                    "openbravo-200x100.png": {},
                    "outreach-200x100.png": {},
                    "paypal-200x100.png": {},
                    "quip.svg": {},
                    "react-200x100.png": {},
                    "researchanddesign.svg": {},
                    "rnfirebase-200x100.png": {},
                    "salesforce.svg": {},
                    "sevenspan-200x100.png": {},
                    "shelf-200x100.png": {},
                    "smooth-code-200x100.png": {},
                    "storybook-200x100.png": {},
                    "swissdev-devops-jobs-200-100.png": {},
                    "talkable-200x100.png": {},
                    "toptal.png": {},
                    "tradeshift-200x100.png": {},
                    "tradie-training.png": {},
                    "transloadit-200x100.png": {},
                    "troops-200x100.png": {},
                    "used_by_babel.svg": {},
                    "used_by_danger.svg": {},
                    "used_by_facebook.svg": {},
                    "used_by_jest.svg": {},
                    "used_by_react.svg": {},
                    "used_by_spotify.svg": {},
                    "used_by_storybook.svg": {},
                    "used_by_webpack.svg": {},
                    "used_by_yarn.svg": {},
                    "used_by_zeit.svg": {},
                    "webflow-200x100.png": {},
                    "webpack-200x100.png": {},
                    "wingify-200x100.png": {},
                    "wire-200x100.png": {},
                    "yarn-200x100.png": {},
                    "yelp-200x100.png": {},
                    "zeit-200x100.png": {},
                    "zipch-200x100.png": {}
                }
            },
            "separate-css": {
                "playground.css": {}
            }
        },
        "versioned_docs": {
            "version-stable": {
                "api.md": {},
                "browser.md": {},
                "cli.md": {},
                "comparison.md": {},
                "configuration.md": {},
                "editors.md": {},
                "for-enterprise.md": {},
                "ignore.md": {},
                "index.md": {},
                "install.md": {},
                "integrating-with-linters.md": {},
                "option-philosophy.md": {},
                "options.md": {},
                "plugins.md": {},
                "precommit.md": {},
                "rationale.md": {},
                "related-projects.md": {},
                "technical-details.md": {},
                "vim.md": {},
                "watching-files.md": {},
                "webstorm.md": {},
                "why-prettier.md": {}
            }
        },
        "versioned_sidebars": {
            "version-stable-sidebars.json": {}
        }
    }
}