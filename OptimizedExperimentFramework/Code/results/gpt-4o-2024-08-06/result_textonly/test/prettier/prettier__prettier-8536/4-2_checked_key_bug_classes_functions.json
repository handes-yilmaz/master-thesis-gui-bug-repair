{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/document/doc-printer.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const { getStringWidth } = require(\"../common/util\");",
                "const { convertEndOfLineToChars } = require(\"../common/end-of-line\");",
                "const { concat, fill, cursor } = require(\"./doc-builders\");",
                "",
                "/** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */",
                "let groupModeMap;",
                "",
                "const MODE_BREAK = 1;",
                "const MODE_FLAT = 2;",
                "",
                "function rootIndent() {",
                "  return { value: \"\", length: 0, queue: [] };",
                "}",
                "",
                "function makeIndent(ind, options) {",
                "  return generateInd(ind, { type: \"indent\" }, options);",
                "}",
                "",
                "function makeAlign(ind, n, options) {",
                "  return n === -Infinity",
                "    ? ind.root || rootIndent()",
                "    : n < 0",
                "    ? generateInd(ind, { type: \"dedent\" }, options)",
                "    : !n",
                "    ? ind",
                "    : n.type === \"root\"",
                "    ? { ...ind, root: ind }",
                "    : typeof n === \"string\"",
                "    ? generateInd(ind, { type: \"stringAlign\", n }, options)",
                "    : generateInd(ind, { type: \"numberAlign\", n }, options);",
                "}",
                "",
                "function generateInd(ind, newPart, options) {",
                "  const queue =",
                "    newPart.type === \"dedent\"",
                "      ? ind.queue.slice(0, -1)",
                "      : ind.queue.concat(newPart);",
                "",
                "  let value = \"\";",
                "  let length = 0;",
                "  let lastTabs = 0;",
                "  let lastSpaces = 0;",
                "",
                "  for (const part of queue) {",
                "    switch (part.type) {",
                "      case \"indent\":",
                "        flush();",
                "        if (options.useTabs) {",
                "          addTabs(1);",
                "        } else {",
                "          addSpaces(options.tabWidth);",
                "        }",
                "        break;",
                "      case \"stringAlign\":",
                "        flush();",
                "        value += part.n;",
                "        length += part.n.length;",
                "        break;",
                "      case \"numberAlign\":",
                "        lastTabs += 1;",
                "        lastSpaces += part.n;",
                "        break;",
                "      /* istanbul ignore next */",
                "      default:",
                "        throw new Error(`Unexpected type '${part.type}'`);",
                "    }",
                "  }",
                "",
                "  flushSpaces();",
                "",
                "  return { ...ind, value, length, queue };",
                "",
                "  function addTabs(count) {",
                "    value += \"\\t\".repeat(count);",
                "    length += options.tabWidth * count;",
                "  }",
                "",
                "  function addSpaces(count) {",
                "    value += \" \".repeat(count);",
                "    length += count;",
                "  }",
                "",
                "  function flush() {",
                "    if (options.useTabs) {",
                "      flushTabs();",
                "    } else {",
                "      flushSpaces();",
                "    }",
                "  }",
                "",
                "  function flushTabs() {",
                "    if (lastTabs > 0) {",
                "      addTabs(lastTabs);",
                "    }",
                "    resetLast();",
                "  }",
                "",
                "  function flushSpaces() {",
                "    if (lastSpaces > 0) {",
                "      addSpaces(lastSpaces);",
                "    }",
                "    resetLast();",
                "  }",
                "",
                "  function resetLast() {",
                "    lastTabs = 0;",
                "    lastSpaces = 0;",
                "  }",
                "}",
                "",
                "function trim(out) {",
                "  if (out.length === 0) {",
                "    return 0;",
                "  }",
                "",
                "  let trimCount = 0;",
                "",
                "  // Trim whitespace at the end of line",
                "  while (",
                "    out.length > 0 &&",
                "    typeof out[out.length - 1] === \"string\" &&",
                "    out[out.length - 1].match(/^[\\t ]*$/)",
                "  ) {",
                "    trimCount += out.pop().length;",
                "  }",
                "",
                "  if (out.length && typeof out[out.length - 1] === \"string\") {",
                "    const trimmed = out[out.length - 1].replace(/[\\t ]*$/, \"\");",
                "    trimCount += out[out.length - 1].length - trimmed.length;",
                "    out[out.length - 1] = trimmed;",
                "  }",
                "",
                "  return trimCount;",
                "}",
                "",
                "function fits(next, restCommands, width, options, mustBeFlat) {",
                "  let restIdx = restCommands.length;",
                "  const cmds = [next];",
                "  // `out` is only used for width counting because `trim` requires to look",
                "  // backwards for space characters.",
                "  const out = [];",
                "  while (width >= 0) {",
                "    if (cmds.length === 0) {",
                "      if (restIdx === 0) {",
                "        return true;",
                "      }",
                "      cmds.push(restCommands[restIdx - 1]);",
                "",
                "      restIdx--;",
                "",
                "      continue;",
                "    }",
                "",
                "    const [ind, mode, doc] = cmds.pop();",
                "",
                "    if (typeof doc === \"string\") {",
                "      out.push(doc);",
                "",
                "      width -= getStringWidth(doc);",
                "    } else {",
                "      switch (doc.type) {",
                "        case \"concat\":",
                "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                "            cmds.push([ind, mode, doc.parts[i]]);",
                "          }",
                "",
                "          break;",
                "        case \"indent\":",
                "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                "",
                "          break;",
                "        case \"align\":",
                "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                "",
                "          break;",
                "        case \"trim\":",
                "          width += trim(out);",
                "",
                "          break;",
                "        case \"group\":",
                "          if (mustBeFlat && doc.break) {",
                "            return false;",
                "          }",
                "          cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);",
                "",
                "          if (doc.id) {",
                "            groupModeMap[doc.id] = cmds[cmds.length - 1][1];",
                "          }",
                "          break;",
                "        case \"fill\":",
                "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                "            cmds.push([ind, mode, doc.parts[i]]);",
                "          }",
                "",
                "          break;",
                "        case \"if-break\": {",
                "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                "          if (groupMode === MODE_BREAK) {",
                "            if (doc.breakContents) {",
                "              cmds.push([ind, mode, doc.breakContents]);",
                "            }",
                "          }",
                "          if (groupMode === MODE_FLAT) {",
                "            if (doc.flatContents) {",
                "              cmds.push([ind, mode, doc.flatContents]);",
                "            }",
                "          }",
                "",
                "          break;",
                "        }",
                "        case \"line\":",
                "          switch (mode) {",
                "            // fallthrough",
                "            case MODE_FLAT:",
                "              if (!doc.hard) {",
                "                if (!doc.soft) {",
                "                  out.push(\" \");",
                "",
                "                  width -= 1;",
                "                }",
                "",
                "                break;",
                "              }",
                "              return true;",
                "",
                "            case MODE_BREAK:",
                "              return true;",
                "          }",
                "          break;",
                "      }",
                "    }",
                "  }",
                "  return false;",
                "}",
                "",
                "function printDocToString(doc, options) {",
                "  groupModeMap = {};",
                "",
                "  const width = options.printWidth;",
                "  const newLine = convertEndOfLineToChars(options.endOfLine);",
                "  let pos = 0;",
                "  // cmds is basically a stack. We've turned a recursive call into a",
                "  // while loop which is much faster. The while loop below adds new",
                "  // cmds to the array instead of recursively calling `print`.",
                "  const cmds = [[rootIndent(), MODE_BREAK, doc]];",
                "  const out = [];",
                "  let shouldRemeasure = false;",
                "  let lineSuffix = [];",
                "",
                "  while (cmds.length !== 0) {",
                "    const [ind, mode, doc] = cmds.pop();",
                "",
                "    if (typeof doc === \"string\") {",
                "      const formatted =",
                "        newLine !== \"\\n\" && doc.includes(\"\\n\")",
                "          ? doc.replace(/\\n/g, newLine)",
                "          : doc;",
                "      out.push(formatted);",
                "      pos += getStringWidth(formatted);",
                "    } else {",
                "      switch (doc.type) {",
                "        case \"cursor\":",
                "          out.push(cursor.placeholder);",
                "",
                "          break;",
                "        case \"concat\":",
                "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                "            cmds.push([ind, mode, doc.parts[i]]);",
                "          }",
                "",
                "          break;",
                "        case \"indent\":",
                "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                "",
                "          break;",
                "        case \"align\":",
                "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                "",
                "          break;",
                "        case \"trim\":",
                "          pos -= trim(out);",
                "",
                "          break;",
                "        case \"group\":",
                "          switch (mode) {",
                "            case MODE_FLAT:",
                "              if (!shouldRemeasure) {",
                "                cmds.push([",
                "                  ind,",
                "                  doc.break ? MODE_BREAK : MODE_FLAT,",
                "                  doc.contents,",
                "                ]);",
                "",
                "                break;",
                "              }",
                "            // fallthrough",
                "",
                "            case MODE_BREAK: {",
                "              shouldRemeasure = false;",
                "",
                "              const next = [ind, MODE_FLAT, doc.contents];",
                "              const rem = width - pos;",
                "",
                "              if (!doc.break && fits(next, cmds, rem, options)) {",
                "                cmds.push(next);",
                "              } else {",
                "                // Expanded states are a rare case where a document",
                "                // can manually provide multiple representations of",
                "                // itself. It provides an array of documents",
                "                // going from the least expanded (most flattened)",
                "                // representation first to the most expanded. If a",
                "                // group has these, we need to manually go through",
                "                // these states and find the first one that fits.",
                "                if (doc.expandedStates) {",
                "                  const mostExpanded =",
                "                    doc.expandedStates[doc.expandedStates.length - 1];",
                "",
                "                  if (doc.break) {",
                "                    cmds.push([ind, MODE_BREAK, mostExpanded]);",
                "",
                "                    break;",
                "                  } else {",
                "                    for (let i = 1; i < doc.expandedStates.length + 1; i++) {",
                "                      if (i >= doc.expandedStates.length) {",
                "                        cmds.push([ind, MODE_BREAK, mostExpanded]);",
                "",
                "                        break;",
                "                      } else {",
                "                        const state = doc.expandedStates[i];",
                "                        const cmd = [ind, MODE_FLAT, state];",
                "",
                "                        if (fits(cmd, cmds, rem, options)) {",
                "                          cmds.push(cmd);",
                "",
                "                          break;",
                "                        }",
                "                      }",
                "                    }",
                "                  }",
                "                } else {",
                "                  cmds.push([ind, MODE_BREAK, doc.contents]);",
                "                }",
                "              }",
                "",
                "              break;",
                "            }",
                "          }",
                "",
                "          if (doc.id) {",
                "            groupModeMap[doc.id] = cmds[cmds.length - 1][1];",
                "          }",
                "          break;",
                "        // Fills each line with as much code as possible before moving to a new",
                "        // line with the same indentation.",
                "        //",
                "        // Expects doc.parts to be an array of alternating content and",
                "        // whitespace. The whitespace contains the linebreaks.",
                "        //",
                "        // For example:",
                "        //   [\"I\", line, \"love\", line, \"monkeys\"]",
                "        // or",
                "        //   [{ type: group, ... }, softline, { type: group, ... }]",
                "        //",
                "        // It uses this parts structure to handle three main layout cases:",
                "        // * The first two content items fit on the same line without",
                "        //   breaking",
                "        //   -> output the first content item and the whitespace \"flat\".",
                "        // * Only the first content item fits on the line without breaking",
                "        //   -> output the first content item \"flat\" and the whitespace with",
                "        //   \"break\".",
                "        // * Neither content item fits on the line without breaking",
                "        //   -> output the first content item and the whitespace with \"break\".",
                "        case \"fill\": {",
                "          const rem = width - pos;",
                "",
                "          const { parts } = doc;",
                "          if (parts.length === 0) {",
                "            break;",
                "          }",
                "",
                "          const [content, whitespace] = parts;",
                "          const contentFlatCmd = [ind, MODE_FLAT, content];",
                "          const contentBreakCmd = [ind, MODE_BREAK, content];",
                "          const contentFits = fits(contentFlatCmd, [], rem, options, true);",
                "",
                "          if (parts.length === 1) {",
                "            if (contentFits) {",
                "              cmds.push(contentFlatCmd);",
                "            } else {",
                "              cmds.push(contentBreakCmd);",
                "            }",
                "            break;",
                "          }",
                "",
                "          const whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];",
                "          const whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];",
                "",
                "          if (parts.length === 2) {",
                "            if (contentFits) {",
                "              cmds.push(whitespaceFlatCmd);",
                "              cmds.push(contentFlatCmd);",
                "            } else {",
                "              cmds.push(whitespaceBreakCmd);",
                "              cmds.push(contentBreakCmd);",
                "            }",
                "            break;",
                "          }",
                "",
                "          // At this point we've handled the first pair (context, separator)",
                "          // and will create a new fill doc for the rest of the content.",
                "          // Ideally we wouldn't mutate the array here but copying all the",
                "          // elements to a new array would make this algorithm quadratic,",
                "          // which is unusable for large arrays (e.g. large texts in JSX).",
                "          parts.splice(0, 2);",
                "          const remainingCmd = [ind, mode, fill(parts)];",
                "",
                "          const secondContent = parts[0];",
                "",
                "          const firstAndSecondContentFlatCmd = [",
                "            ind,",
                "            MODE_FLAT,",
                "            concat([content, whitespace, secondContent]),",
                "          ];",
                "          const firstAndSecondContentFits = fits(",
                "            firstAndSecondContentFlatCmd,",
                "            [],",
                "            rem,",
                "            options,",
                "            true",
                "          );",
                "",
                "          if (firstAndSecondContentFits) {",
                "            cmds.push(remainingCmd);",
                "            cmds.push(whitespaceFlatCmd);",
                "            cmds.push(contentFlatCmd);",
                "          } else if (contentFits) {",
                "            cmds.push(remainingCmd);",
                "            cmds.push(whitespaceBreakCmd);",
                "            cmds.push(contentFlatCmd);",
                "          } else {",
                "            cmds.push(remainingCmd);",
                "            cmds.push(whitespaceBreakCmd);",
                "            cmds.push(contentBreakCmd);",
                "          }",
                "          break;",
                "        }",
                "        case \"if-break\": {",
                "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                "          if (groupMode === MODE_BREAK) {",
                "            if (doc.breakContents) {",
                "              cmds.push([ind, mode, doc.breakContents]);",
                "            }",
                "          }",
                "          if (groupMode === MODE_FLAT) {",
                "            if (doc.flatContents) {",
                "              cmds.push([ind, mode, doc.flatContents]);",
                "            }",
                "          }",
                "",
                "          break;",
                "        }",
                "        case \"line-suffix\":",
                "          lineSuffix.push([ind, mode, doc.contents]);",
                "          break;",
                "        case \"line-suffix-boundary\":",
                "          if (lineSuffix.length > 0) {",
                "            cmds.push([ind, mode, { type: \"line\", hard: true }]);",
                "          }",
                "          break;",
                "        case \"line\":",
                "          switch (mode) {",
                "            case MODE_FLAT:",
                "              if (!doc.hard) {",
                "                if (!doc.soft) {",
                "                  out.push(\" \");",
                "",
                "                  pos += 1;",
                "                }",
                "",
                "                break;",
                "              } else {",
                "                // This line was forced into the output even if we",
                "                // were in flattened mode, so we need to tell the next",
                "                // group that no matter what, it needs to remeasure",
                "                // because the previous measurement didn't accurately",
                "                // capture the entire expression (this is necessary",
                "                // for nested groups)",
                "                shouldRemeasure = true;",
                "              }",
                "            // fallthrough",
                "",
                "            case MODE_BREAK:",
                "              if (lineSuffix.length) {",
                "                cmds.push([ind, mode, doc]);",
                "                cmds.push(...lineSuffix.reverse());",
                "                lineSuffix = [];",
                "                break;",
                "              }",
                ""
            ]
        },
        "2": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/language-js/printer-estree.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const assert = require(\"assert\");",
                "",
                "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
                "const comments = require(\"../main/comments\");",
                "const {",
                "  shouldFlatten,",
                "  getNextNonSpaceNonCommentCharacter,",
                "  hasNewline,",
                "  hasNewlineInRange,",
                "  getLast,",
                "  getStringWidth,",
                "  printString,",
                "  printNumber,",
                "  hasIgnoreComment,",
                "  hasNodeIgnoreComment,",
                "  startsWithNoLookaheadToken,",
                "  getIndentSize,",
                "  getPreferredQuote,",
                "} = require(\"../common/util\");",
                "const {",
                "  isNextLineEmpty,",
                "  getNextNonSpaceNonCommentCharacterIndex,",
                "} = require(\"../common/util-shared\");",
                "const embed = require(\"./embed\");",
                "const clean = require(\"./clean\");",
                "const { insertPragma } = require(\"./pragma\");",
                "const handleComments = require(\"./comments\");",
                "const pathNeedsParens = require(\"./needs-parens\");",
                "const {",
                "  printHtmlBinding,",
                "  isVueEventBindingExpression,",
                "} = require(\"./html-binding\");",
                "const preprocess = require(\"./preprocess\");",
                "const {",
                "  classChildNeedsASIProtection,",
                "  classPropMayCauseASIProblems,",
                "  conditionalExpressionChainContainsJSX,",
                "  getFlowVariance,",
                "  getLeftSidePathName,",
                "  getParentExportDeclaration,",
                "  getTypeScriptMappedTypeModifier,",
                "  hasDanglingComments,",
                "  hasFlowAnnotationComment,",
                "  hasFlowShorthandAnnotationComment,",
                "  hasLeadingOwnLineComment,",
                "  hasNakedLeftSide,",
                "  hasNewlineBetweenOrAfterDecorators,",
                "  hasNgSideEffect,",
                "  hasPrettierIgnore,",
                "  hasTrailingComment,",
                "  hasTrailingLineComment,",
                "  identity,",
                "  isBinaryish,",
                "  isCallOrOptionalCallExpression,",
                "  isEmptyJSXElement,",
                "  isExportDeclaration,",
                "  isFlowAnnotationComment,",
                "  isFunctionNotation,",
                "  isGetterOrSetter,",
                "  isJestEachTemplateLiteral,",
                "  isJSXNode,",
                "  isJSXWhitespaceExpression,",
                "  isLastStatement,",
                "  isLiteral,",
                "  isMeaningfulJSXText,",
                "  isMemberExpressionChain,",
                "  isMemberish,",
                "  isNgForOf,",
                "  isObjectType,",
                "  isObjectTypePropertyAFunction,",
                "  isSimpleFlowType,",
                "  isSimpleTemplateLiteral,",
                "  isStringLiteral,",
                "  isStringPropSafeToCoerceToIdentifier,",
                "  isTemplateOnItsOwnLine,",
                "  isTestCall,",
                "  isTheOnlyJSXElementInMarkdown,",
                "  isTSXFile,",
                "  isTypeAnnotationAFunction,",
                "  matchJsxWhitespaceRegex,",
                "  needsHardlineAfterDanglingComment,",
                "  rawText,",
                "  returnArgumentHasLeadingComment,",
                "  shouldPrintComma,",
                "} = require(\"./utils\");",
                "",
                "const printMemberChain = require(\"./print/member-chain\");",
                "const printCallArguments = require(\"./print/call-arguments\");",
                "const {",
                "  printOptionalToken,",
                "  printFunctionTypeParameters,",
                "  printMemberLookup,",
                "  printBindExpressionCallee,",
                "} = require(\"./print/misc\");",
                "const { printModuleSource, printModuleSpecifiers } = require(\"./print/module\");",
                "",
                "const needsQuoteProps = new WeakMap();",
                "",
                "const {",
                "  builders: {",
                "    concat,",
                "    join,",
                "    line,",
                "    hardline,",
                "    softline,",
                "    literalline,",
                "    group,",
                "    indent,",
                "    align,",
                "    conditionalGroup,",
                "    fill,",
                "    ifBreak,",
                "    lineSuffixBoundary,",
                "    addAlignmentToDoc,",
                "    dedent,",
                "  },",
                "  utils: { willBreak, isLineNext, isEmpty, removeLines, normalizeParts },",
                "  printer: { printDocToString },",
                "} = require(\"../document\");",
                "",
                "let uid = 0;",
                "",
                "function genericPrint(path, options, printPath, args) {",
                "  const node = path.getValue();",
                "  let needsParens = false;",
                "  const linesWithoutParens = printPathNoParens(path, options, printPath, args);",
                "",
                "  if (!node || isEmpty(linesWithoutParens)) {",
                "    return linesWithoutParens;",
                "  }",
                "",
                "  const parentExportDecl = getParentExportDeclaration(path);",
                "  const decorators = [];",
                "  if (",
                "    node.type === \"ClassMethod\" ||",
                "    node.type === \"ClassPrivateMethod\" ||",
                "    node.type === \"ClassProperty\" ||",
                "    node.type === \"TSAbstractClassProperty\" ||",
                "    node.type === \"ClassPrivateProperty\" ||",
                "    node.type === \"MethodDefinition\" ||",
                "    node.type === \"TSAbstractMethodDefinition\" ||",
                "    node.type === \"TSDeclareMethod\"",
                "  ) {",
                "    // their decorators are handled themselves",
                "  } else if (",
                "    node.decorators &&",
                "    node.decorators.length > 0 &&",
                "    // If the parent node is an export declaration and the decorator",
                "    // was written before the export, the export will be responsible",
                "    // for printing the decorators.",
                "    !(",
                "      parentExportDecl &&",
                "      options.locStart(parentExportDecl, { ignoreDecorators: true }) >",
                "        options.locStart(node.decorators[0])",
                "    )",
                "  ) {",
                "    const shouldBreak =",
                "      node.type === \"ClassExpression\" ||",
                "      node.type === \"ClassDeclaration\" ||",
                "      hasNewlineBetweenOrAfterDecorators(node, options);",
                "",
                "    const separator = shouldBreak ? hardline : line;",
                "",
                "    path.each((decoratorPath) => {",
                "      let decorator = decoratorPath.getValue();",
                "      if (decorator.expression) {",
                "        decorator = decorator.expression;",
                "      } else {",
                "        decorator = decorator.callee;",
                "      }",
                "",
                "      decorators.push(printPath(decoratorPath), separator);",
                "    }, \"decorators\");",
                "",
                "    if (parentExportDecl) {",
                "      decorators.unshift(hardline);",
                "    }",
                "  } else if (",
                "    isExportDeclaration(node) &&",
                "    node.declaration &&",
                "    node.declaration.decorators &&",
                "    node.declaration.decorators.length > 0 &&",
                "    // Only print decorators here if they were written before the export,",
                "    // otherwise they are printed by the node.declaration",
                "    options.locStart(node, { ignoreDecorators: true }) >",
                "      options.locStart(node.declaration.decorators[0])",
                "  ) {",
                "    // Export declarations are responsible for printing any decorators",
                "    // that logically apply to node.declaration.",
                "    path.each(",
                "      (decoratorPath) => {",
                "        const decorator = decoratorPath.getValue();",
                "        const prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";",
                "        decorators.push(prefix, printPath(decoratorPath), hardline);",
                "      },",
                "      \"declaration\",",
                "      \"decorators\"",
                "    );",
                "  } else {",
                "    // Nodes with decorators can't have parentheses, so we can avoid",
                "    // computing pathNeedsParens() except in this case.",
                "    needsParens = pathNeedsParens(path, options);",
                "  }",
                "",
                "  const parts = [];",
                "  if (needsParens) {",
                "    parts.unshift(\"(\");",
                "  }",
                "",
                "  parts.push(linesWithoutParens);",
                "",
                "  if (needsParens) {",
                "    const node = path.getValue();",
                "    if (hasFlowShorthandAnnotationComment(node)) {",
                "      parts.push(\" /*\");",
                "      parts.push(node.trailingComments[0].value.trimStart());",
                "      parts.push(\"*/\");",
                "      node.trailingComments[0].printed = true;",
                "    }",
                "",
                "    parts.push(\")\");",
                "  }",
                "",
                "  if (decorators.length > 0) {",
                "    return group(concat(decorators.concat(parts)));",
                "  }",
                "  return concat(parts);",
                "}",
                "",
                "function printDecorators(path, options, print) {",
                "  const node = path.getValue();",
                "  return group(",
                "    concat([",
                "      join(line, path.map(print, \"decorators\")),",
                "      hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line,",
                "    ])",
                "  );",
                "}",
                "",
                "/**",
                " * The following is the shared logic for",
                " * ternary operators, namely ConditionalExpression",
                " * and TSConditionalType",
                " * @typedef {Object} OperatorOptions",
                " * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.",
                " * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.",
                " * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.",
                " * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".",
                " * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".",
                " * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".",
                " * @property {string[]} testNodePropertyNames - The properties at which the test nodes can be found on the main node, eg \"test\".",
                " * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.",
                " * @param {Options} options - Prettier options",
                " * @param {Function} print - Print function to call recursively",
                " * @param {OperatorOptions} operatorOptions",
                " * @returns Doc",
                " */",
                "function printTernaryOperator(path, options, print, operatorOptions) {",
                "  const node = path.getValue();",
                "  const consequentNode = node[operatorOptions.consequentNodePropertyName];",
                "  const alternateNode = node[operatorOptions.alternateNodePropertyName];",
                "  const parts = [];",
                "",
                "  // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".",
                "  // See tests/jsx/conditional-expression.js for more info.",
                "  let jsxMode = false;",
                "  const parent = path.getParentNode();",
                "  const isParentTest =",
                "    parent.type === operatorOptions.conditionalNodeType &&",
                "    operatorOptions.testNodePropertyNames.some((prop) => parent[prop] === node);",
                "  let forceNoIndent =",
                "    parent.type === operatorOptions.conditionalNodeType && !isParentTest;",
                "",
                "  // Find the outermost non-ConditionalExpression parent, and the outermost",
                "  // ConditionalExpression parent. We'll use these to determine if we should",
                "  // print in JSX mode.",
                "  let currentParent;",
                "  let previousParent;",
                "  let i = 0;",
                "  do {",
                "    previousParent = currentParent || node;",
                "    currentParent = path.getParentNode(i);",
                "    i++;",
                "  } while (",
                "    currentParent &&",
                "    currentParent.type === operatorOptions.conditionalNodeType &&",
                "    operatorOptions.testNodePropertyNames.every(",
                "      (prop) => currentParent[prop] !== previousParent",
                "    )",
                "  );",
                "  const firstNonConditionalParent = currentParent || parent;",
                "  const lastConditionalParent = previousParent;",
                "",
                "  if (",
                "    operatorOptions.shouldCheckJsx &&",
                "    (isJSXNode(node[operatorOptions.testNodePropertyNames[0]]) ||",
                "      isJSXNode(consequentNode) ||",
                "      isJSXNode(alternateNode) ||",
                "      conditionalExpressionChainContainsJSX(lastConditionalParent))",
                "  ) {",
                "    jsxMode = true;",
                "    forceNoIndent = true;",
                "",
                "    // Even though they don't need parens, we wrap (almost) everything in",
                "    // parens when using ?: within JSX, because the parens are analogous to",
                "    // curly braces in an if statement.",
                "    const wrap = (doc) =>",
                "      concat([",
                "        ifBreak(\"(\", \"\"),",
                "        indent(concat([softline, doc])),",
                "        softline,",
                "        ifBreak(\")\", \"\"),",
                "      ]);",
                "",
                "    // The only things we don't wrap are:",
                "    // * Nested conditional expressions in alternates",
                "    // * null",
                "    // * undefined",
                "    const isNil = (node) =>",
                "      node.type === \"NullLiteral\" ||",
                "      (node.type === \"Literal\" && node.value === null) ||",
                "      (node.type === \"Identifier\" && node.name === \"undefined\");",
                "",
                "    parts.push(",
                "      \" ? \",",
                "      isNil(consequentNode)",
                "        ? path.call(print, operatorOptions.consequentNodePropertyName)",
                "        : wrap(path.call(print, operatorOptions.consequentNodePropertyName)),",
                "      \" : \",",
                "      alternateNode.type === operatorOptions.conditionalNodeType ||",
                "        isNil(alternateNode)",
                "        ? path.call(print, operatorOptions.alternateNodePropertyName)",
                "        : wrap(path.call(print, operatorOptions.alternateNodePropertyName))",
                "    );",
                "  } else {",
                "    // normal mode",
                "    const part = concat([",
                "      line,",
                "      \"? \",",
                "      consequentNode.type === operatorOptions.conditionalNodeType",
                "        ? ifBreak(\"\", \"(\")",
                "        : \"\",",
                "      align(2, path.call(print, operatorOptions.consequentNodePropertyName)),",
                "      consequentNode.type === operatorOptions.conditionalNodeType",
                "        ? ifBreak(\"\", \")\")",
                "        : \"\",",
                "      line,",
                "      \": \",",
                "      alternateNode.type === operatorOptions.conditionalNodeType",
                "        ? path.call(print, operatorOptions.alternateNodePropertyName)",
                "        : align(2, path.call(print, operatorOptions.alternateNodePropertyName)),",
                "    ]);",
                "    parts.push(",
                "      parent.type !== operatorOptions.conditionalNodeType ||",
                "        parent[operatorOptions.alternateNodePropertyName] === node ||",
                "        isParentTest",
                "        ? part",
                "        : options.useTabs",
                "        ? dedent(indent(part))",
                "        : align(Math.max(0, options.tabWidth - 2), part)",
                "    );",
                "  }",
                "",
                "  // We want a whole chain of ConditionalExpressions to all",
                "  // break if any of them break. That means we should only group around the",
                "  // outer-most ConditionalExpression.",
                "  const maybeGroup = (doc) =>",
                "    parent === firstNonConditionalParent ? group(doc) : doc;",
                "",
                "  // Break the closing paren to keep the chain right after it:",
                "  // (a",
                "  //   ? b",
                "  //   : c",
                "  // ).call()",
                "  const breakClosingParen =",
                "    !jsxMode &&",
                "    (parent.type === \"MemberExpression\" ||",
                "      parent.type === \"OptionalMemberExpression\" ||",
                "      (parent.type === \"NGPipeExpression\" && parent.left === node)) &&",
                "    !parent.computed;",
                "",
                "  const result = maybeGroup(",
                "    concat(",
                "      [].concat(",
                "        ((testDoc) =>",
                "          /**",
                "           *     a",
                "           *       ? b",
                "           *       : multiline",
                "           *         test",
                "           *         node",
                "           *       ^^ align(2)",
                "           *       ? d",
                "           *       : e",
                "           */",
                "          parent.type === operatorOptions.conditionalNodeType &&",
                "          parent[operatorOptions.alternateNodePropertyName] === node",
                "            ? align(2, testDoc)",
                "            : testDoc)(concat(operatorOptions.beforeParts())),",
                "        forceNoIndent ? concat(parts) : indent(concat(parts)),",
                "        operatorOptions.afterParts(breakClosingParen)",
                "      )",
                "    )",
                "  );",
                "",
                "  return isParentTest",
                "    ? group(concat([indent(concat([softline, result])), softline]))",
                "    : result;",
                "}",
                "",
                "function printPathNoParens(path, options, print, args) {",
                "  const n = path.getValue();",
                "  const semi = options.semi ? \";\" : \"\";",
                "",
                "  if (!n) {",
                "    return \"\";",
                "  }",
                "",
                "  if (typeof n === \"string\") {",
                "    return n;",
                "  }",
                "",
                "  const htmlBinding = printHtmlBinding(path, options, print);",
                "  if (htmlBinding) {",
                "    return htmlBinding;",
                "  }",
                "",
                "  let parts = [];",
                "  switch (n.type) {",
                "    case \"JsExpressionRoot\":",
                "      return path.call(print, \"node\");",
                "    case \"JsonRoot\":",
                "      return concat([path.call(print, \"node\"), hardline]);",
                "    case \"File\":",
                "      // Print @babel/parser's InterpreterDirective here so that",
                "      // leading comments on the `Program` node get printed after the hashbang.",
                "      if (n.program && n.program.interpreter) {",
                "        parts.push(",
                "          path.call(",
                "            (programPath) => programPath.call(print, \"interpreter\"),",
                "            \"program\"",
                "          )",
                "        );",
                "      }",
                "",
                "      parts.push(path.call(print, \"program\"));",
                "",
                "      return concat(parts);",
                "",
                "    case \"Program\":",
                "      // Babel 6",
                "      if (n.directives) {",
                "        path.each((childPath) => {",
                "          parts.push(print(childPath), semi, hardline);",
                "          if (",
                "            isNextLineEmpty(",
                "              options.originalText,",
                "              childPath.getValue(),",
                "              options.locEnd",
                "            )",
                "          ) {",
                "            parts.push(hardline);",
                "          }",
                "        }, \"directives\");",
                "      }",
                "",
                "      parts.push(",
                "        path.call((bodyPath) => {",
                "          return printStatementSequence(bodyPath, options, print);",
                "        }, \"body\")",
                "      );",
                "",
                "      parts.push(",
                "        comments.printDanglingComments(path, options, /* sameIndent */ true)",
                "      );",
                "",
                "      // Only force a trailing newline if there were any contents.",
                "      if (",
                "        !n.body.every(({ type }) => type === \"EmptyStatement\") ||",
                "        n.comments",
                "      ) {",
                "        parts.push(hardline);",
                "      }",
                "",
                "      return concat(parts);",
                "    // Babel extension.",
                "    case \"EmptyStatement\":",
                "      return \"\";",
                "    case \"ExpressionStatement\":",
                "      // Detect Flow and TypeScript directives",
                "      if (n.directive) {",
                "        return concat([nodeStr(n.expression, options, true), semi]);",
                "      }",
                "",
                "      if (options.parser === \"__vue_event_binding\") {",
                "        const parent = path.getParentNode();",
                "        if (",
                "          parent.type === \"Program\" &&",
                "          parent.body.length === 1 &&"
            ]
        }
    },
    "bug_functions": {}
}